\Sorry Gerry,
\\Again your enthusiasm is to be commended, but we'll never get the thing translated this way.
\\I can't spend all my time making "quick fixes" and "haphazard updates" to the program and the Noodle.
\\We must proceed in a slow, orderly fashion, step by boring step, page by tedious page.
\\Gerry

\I've been trying to do the exercises from a guide for the students, and as you say the names of the variables are given: A and B.
\I can't use A as such, nor "variable A" because we have not that concepts in a simple language for programming like the Plains.

\I will retake the way with you.

\Sorry, again.

\Pablo 

In mathematics we give short, "proper noun" names to everything...

let h = the height of a rectangle
let w = the width of a rectangle
let a = the area of a rectangle

...and then we put those short names into equations which are easily manipulated:

a = w * h

But in ordinary speech we give proper-noun names to very few things.
For example:

"I am sitting in a chair at a desk."

Note that I did NOT say:

"Let c = a chair. Let d = a desk. I am sitting in c at d."

That would be VERY unnatural.

Since Plain English and Español Llano are "natural" langauges,
they follow the pattern and naming conventions of ordinary speech.
So we say things like: "the height" and "the width" and "the area" instead of h, w, and a.
This kind of naming, together with the way we allow spaces in names, is one of the most
important distinguishing features of Plain English and Español Llano.

And yes, this makes equations wordy and harder to manipulate.
But most of the statements in most programs are not equations.
The proof is below, from an article I wrote earlier. You don't have to read the whole thing,
just get the general idea.

---

Most of the code in most programs does simple stuff like "move this over there" and "show that on the screen" -
things that can be conveniently expressed in a natural language. Let's consider an example we can examine in detail:

Our compiler - a sophisticated Plain-English-to-Executable-Machine-Code translator - has 3,050 imperative sentences in it.

1,306 of those (about 42%) are conditional statements, and at least half of those are trivial things like these:

\If the item is not found, break.
\If the compiler's abort flag is set, exit.

The remainder of those conditional statements are slightly more complex, but all of them fit on a single line.
Here are a couple of the longer ones:

\If the length is 4, attach $FF32 to the fragment's code; exit.
\If the rider's token is any numeric literal, compile the literal given the rider; exit.

Of the remaining sentences:

272 (about 9%) are simple assignment statements:

\Put the type name into the field's type name.

202 (about 7%) are just the infrastructure for various loops:

\Loop.
\Get a field from the type's fields.
\[ other stuff here]
\Repeat.

183 (6%) simply add something to the end of this or that list, like so:

\Add the field to the type's fields.

164 (about 5%) are trivial statements used to return boolean results, start and stop various timers, show the program's current status, and write interesting things to the compiler's output listing.

\Say no.
\Say yes.
\Set the variable's compiled flag.
\Start the compiler's timer.
\Stop the compiler's timer.
\Show status "Compiling...".
\List the globals in the compiler's listing.

119 (about 4%) advance the focus in the source code, sentences like:

\Bump the rider.
\Move the rider (code rules).

92 (about 3%) are used to create, destroy and keep internal indexes up to date, sentences like:

\Create the type index using 7919 for the bucket count.
\Index the type given the type's name.
\Destroy the type index.

58 (about 2%) are used to find things in various lists:

\Find a variable given the name.

37 (about 1%) are calls to various conversion routines:

\Convert the rider's token to a ratio.

31 (about 1%) are used to generate actual machine code (plus those that appear in conditional statements, as above):

\Attach $E8 and the address to the fragment.

And that accounts for 80% of the code in our compiler.

Only 57 of the remaining sentences (less than 2% of the whole) are mathematical in nature, a line here and there like these:

\Add 4 to the routine's parameter size.
\Subtract the length from the local's offset.
\Multiply the type's scale by the base type's scale.
\Calculate the length of the field's type.
\Round the address up to the nearest multiple of 4096.

And the rest are not formulaic at all. Stuff like:

\Copy the field into another field.
\Append the fragment to the current routine's fragments.
\Abort with "I was hoping for a definition but all I found was '" then the token.
\Initialize the compiler.
\Remove any trailing backslashes from the path name.
\Reduce the monikette's type to a type for utility use.
\Eliminate duplicate nicknames from the type's fields.
\Prepend "original " to the term's name.
\Extend the name with the rider's token.
\Unquote the other string.
\Read the source file's path into the source file's buffer.
\Generate the literal's name.
\Extract a file name from the compiler's abort path.
\Write the compiler's exe to the compiler's exe path.
\Swap the monikettes with the other monikettes.
\Skip any leading noise in the substring.
\Scrub the utility index.
\Fill the compiler's exe with the null byte given the compiler's exe size.
\Position the rider's token on the rider's source.
\Pluralize the type's plural name.
\Link.
\Finalize the compiler.
\Check for invalid optional info on the type.

And that's why we say that most of what most programs do is easy stuff, stuff that can be
conveniently expressed in a natural language. And that, in turn, is why we like programming in Plain English:
the thoughts in our heads are typed in as Plain English "pseudo code" and, with a tweak here and there,
that pseudo code actually compiles and runs. And is self-documenting, to boot.

---

Gerry

PS. Thank you for your address. Sharon and Chuckles have already put a pin the map.
The picture of your house reminds me of the house (in California) where Steve Jobs and Steve Wozniak
invented the Apple II computer. At least how it looked in a movie we saw.
I think this is the beginning of something great. May God lead and bless us.



