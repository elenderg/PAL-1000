i actually meant the CAL. i don't know how peripherals will work on the fpga board. but if you
(we) wanted hardware that is strictly compatible with the CAL, then the fpga route is a good interim
solution.

\ I've got nothing against FPGAs, if they've got enough memory and are able to talk to the devices we need.

if we're going to target intel without windows, then that's fine, too.

\ I don't see any point in doing that. As you said, Intel's x86 architecture is "a bloated whale of a system".
\ Our job, as Osmosians, is to PROVE that all that complexity is unnecessary by creating practical
\ systems without that complexity. Systems that can be used for both education and commercial applications.
\ The CAL on Windows is a "proof of concept," as much as Dan and I could accomplish in six months in the back bedroom.
\ Not yet ideal, and still very ugly "under the covers," but good enough to be used for both education (ala the Golden Key) and
\ for commercial applications (like www.rhymingreader.com).

we'd just have to build up the pieces of a Plain English kernel and loader.

\ Moot point, see above.

doing graphics on a bare system shouldn't be too difficult. it's made harder by linux and windows,
because they need to support a wide variety of potential configurations. it's easier on mac, because they
control the hardware.

\ Which is why it is wise to develop our own Osmosian hardware; void of everything that is superfluous.
\ I was serious about the executable format I described in my previous post:

\ Byte 0: the first instruction to be executred.
\ Bytes 1-n: whatever the compiler writer wants them to be.

\ That can be easily taught to a beginner - unlike PE and ELF - and yet is powerful enough for use in a commercial application.

if we're targeting intel/x86...

\ We're not targeting Intel/x86. Done that, been there (with the current CAL, using only a handful of the Intel's
\ hundreds of instructions and using Windows, not so much as an operating system, but to simulate a library of
\ device-driver subroutines).

then getting it running in a virtual machine would be one of the first hurdles to overcome.
i just meant as an intermediary, so we could iron out some bugs. if any show up.

so the fpga machine is meant as an interim solution. i'd design some hardware and "print" it to the fpga.
then, once it's working and stabilized, we build some custom chips. isn't that how it generally happens?

\ Yes, I think that is how it generally happens. The important thing is for us to agree, up front, on exactly
\ what it is we're trying to PROVE, and what kind of system we need to prove it. Then it's easy to know what is
\ appropriate and what isn't. If I sound "religiously fervent" about this, it's because this mandate comes from the Bible:
\ "Be not conformed to this world: but be ye transformed by the renewing of your mind, that ye may prove what is that good,
\ and acceptable, and perfect, will of God," Romans 12:2. I'd like to prove that a computer system can be small, simple, efficient,
\ cheap and quiet (fanless), yet powerful enough to run, say, a Redbox DVD kiosk, or a wysiwyg page-layout application that's
\ simpler - but just as useful - as Microsoft Word or Powerpoint; the whole system being suitable, at the same time, for
\ education, with every part - top to bottom - simple enough to be grasped by a bright middle-school student.

\ That's the thing I've been dreaming about for 12 years now. Clearly, an Intel x86 with Windows doesn't quite fit the bill.
\ But it's the best Dan and I could do in six months, working in the back bedroom.

\ Gerry
