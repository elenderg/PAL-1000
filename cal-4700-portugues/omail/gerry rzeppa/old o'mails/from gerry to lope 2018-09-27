Hello again, Lope.

I'm in blue, as usual, you're in black.

I'm sorry I was in blackout there for a while. I felt I needed to do more more research about executables. 

\ I wondered where you had gone.

There's more to this than I can get in one or two or 20 sittings.

\ No doubt. The computer industry has really over-complicated things.
\ The same thing happened with the automobile industry.
\ In 1964, you could look under the hood of your car and actually find and replace
\ many of the components with just wrenches and screwdrivers.
\ Now you can  hardly even find the components, there's so much crap on top of them.
\ The CAL is (and is supposed to be) like a 1964 Chevy, not a 2018 Chevy.

I think that I'll learn more talking to you than on my own for the intended specific purpose of translating CAL.

\ Okay, let's do it!

Out of curiousity, at which nth iteration of these primitive CALs was it when you were able to stop using Delphi?

\ Before we even dreamed of the CAL, we used Delphi Pascal to write a Pascal-like language we called AIQ.
\ I don't remember what the name stood for.
\ We used AIQ, all by itself, to make the first version of the CAL.
\ It had the desktop (with the menus and the tabs), the text editor,
\ and just enough of the compiler to compile and run this program:

\ To run:
\ Call "kernel32.dll" "ExitProcess" with 0.

\ After that we did all our work in the CAL, though it was a while before the CAL
\ could compile himself. Before that, he could only compile little test programs like the one above
\ and things like:

\ To run:
\ Beep.
\
\ To beep:
\ Call "user32.dll" "MessageBeep" with 0.

\ Get the idea? The first CAL could call an EXTERNAL Windows DLL, and that's about it.
\ The next CAL could call an internal routine (Beep) that, in turn, called an EXTERNAL Windows DLL.
\ Then we got IF statements working, and after that, LOOPs, etc.

\ It took my elder son Dan and I, six months to write the whole CAL-3040 (which was the first full version).
\ We worked side by side on a single computer with two monitors (both monitors showing the same thing).
\ When Dan knew what he was doing, he would run the mouse and I would type, and vice-versa.
\ So every line of code was checked twice and agreed upon before we ever ran it.
\ We hardly ever wrote more than a dozen lines without testing.

Please give me some credit that I know this. I think so that I know the differences. 
A web page is a text file but it has markups. The browser like Chrome is a binary file that ends in ".exe" file extension. 
A text file usually can be read easily with a text editor like Notepad. 
When a web page is read by Chrome, it hides the markups and renders it as intended.

\ Chrome doesn't just "hide the markups," it INTERPRETS whatever CSS, HTML, JavaScript, etc, it finds.
\ In other words, it translates the CSS, HTML, JavaScript, etc, into a "virtual machine language" that is then 
\ interpreted by a "virtual machiine" that is also part of the Chrome executable.
\ It is this "virtual machine" that maps the virtual instructions to actual instructions on the target machine.

When Notepad opens up a web page that's saved on the local computer (where Notepad.exe itself resides) then one can see the markups.

\ Sure, ugly stuff like this:

\ <html>
\ <head>
\ <title>The Osmosian Order of Plain English Programmers</title>
\ <meta http-equiv="content-type" content="text/html; charset=iso8859-1"/>
\ <meta http-equiv="imagetoolbar" content="no"/>
\ <meta name="description" content="The Osmosian Order of Plain English Programmers"/>
\ <meta name="keywords" content="osmosian, plain english, english, programming, programmer, programming language, basic, 
\   basic programming, beginning programming, beginner, art, homeschool, home school, compiler, learn to program"/>
\ <meta name="robots" content="all"/>

\ And sometimes even uglier stuff like this:

\ function handlehelp() {
\    document.location="mailto:help@osmosian.com";
\  };

[Right now we're using] just Plain English, right. However, I was thinking of all the people who are reading web pages.

\ They rare able to read web pages because they have a browser that interprets the code in those web pages.

There are more people out there who will just be more content using the browser and we can connect to them.

\ Sure. But the easiest way to make a web page is to make a blog using WordPress or something else like that.
\ I hate working on the web, and even I have been able to do it. Examples:

\ https://osmosianplainenglishprogramming.blog/ (WordPress)
\ https://www.kickstarter.com/projects/1335354839/art-for-the-rest-of-us (Kickstarter)
\ https://rapturejunkies.blogspot.com/?view=snapshot (Blogger)

\ No programming necessary, in any language.

They don't see the HTML, etc.; just the plain english language also that the web page puts out.
We can teach CAL to put out web pages but instruct him in plain english only.
 For example, let's say we want a bare web page. We might make an imperative statement like "Build a bare web page."

\ It sounds like you want to replace CSS, HTML, and JavaScript, etc, with a Plain English syntax. Yes?
\ Okay, here's what you need to do:
\ 1. Precisely define the syntax, then
\ 2. Get Google (and Microsoft, and anyone else who makes a browser)
\     to update their browsers to interpret Plain English code as well as CSS, HTML, JavaScript, etc.
\ Unfortunately, that's not going to happen.
\ So Plan B:
\ 1. Make the CAL put out CSS, HTML, and JavaScript (instead of Windows executables)
\ Sounds simple enough, but it's not. Let me prove it to you.

\ This tiny program actually runs when you compile it with the CAL on a Windows machine:

\ To run:
\ Start up.
\ Clear the screen.
\ Say "Hello, World!" and wait.
\ Shut down.

\ The screen goes blank, corner to corner, and a voice says, "Hello World!"
\ then the program terminates.

\ Exactly what CSS, HTML, and JavaScript statements does that program translate into?
 
[you and I come from different backgrounds in programming] Which means we have some things to contribute to each other's knowledge.

\ I'm always willing to learn. In fact, I'll believe ANYTHING - if it's true!

Which assembly code are easy to understand?

\ I liked IBM 370 Assembler, back in the day, and
\ I wrote an assembler for Z80 chips once.
\ Today's chips are such a mess that their assembler languages are a mess too.

"MOV" and "JMP" and "JNZ" are mnemonically comprehensible, although still not plain english or even C.

\ That's the idea. In assembler, you're either loading something into a register from memory, or
\ puting something into memory from a register, or
\ doing something with a couple of registers (like adding one to another)
\ One instruction per line.

When we go to machine language, that's really gibberish to me, although I could make out some text strings here and there.

\ Machine language is not meant to be read by humans, only by machines.

The Intelx86 instructions might be few but in a program file, they're repeated so many times the whole thing is unintelligible (for me).

\ Of course. Machine language is not meant to be read by humans, only by machines.

Even if they were written in Plain English, they're still kind of unintelligible. 

\ I don't think that's true. Consider this "Plain English" assembler:

\ Load register D with the address of "the total".
\ Load register A from memory (the address is in register D).
\ Add 1 to register A.
\ Store register A in memory (the addressis in register D).

\ That's easy enough, yes? 

The IRS tax code, which is also written in plain English --if I have to read it-- you might as well throw a tieza brick to my head.

\ Too much of a good thing is always a bad thing. That's why we invented higher-level programming languages,
\ where one statement represents many assembler statements.
\ The four "Plain English" assembler statements above, for example, might have come from this single statement:

\ Add 1 to the total.

\ But somebody has to know just enough assembler to tell the computer how to generate those many statements from the one.
\ That's us and the CAL.

[To Cal]
Make a bare webpage.
Put "Hello, World!" in the webpage's body.
[These functions will have to be defined. The text file produced will have HTML markup that won't be seen by the regular web user.]

\ See above. It's the CONTENT of that text file that I was asking for.
\ We can't hit an UNEFINED target.

[Exactly what's in the text file the "WebCAL" puts out?] Put the text file on a web server.

\ You can put it anywhere you like. But exactly what is in that text file?

There's another category of computers and that is the server; in particular, web servers. They're run almost exclusively by Linux OS. 

\ So if you want to write server-side programs in Plain English, you need a CAL that generates
\ Linux executables instead of Windows executables.
\ If you want to rewrite the CAL to do that, great.
\ I don't know enough about Linux to do that, so I've tried several times before
\ to find a Linux expert to do it for me, without success.
\ Are you a Linux expert?

Your sample.zip from osmosian.com seem able to access the web easily. I can't seem to compile it though. What version of CAL was it compiled on?

\ I think the sample on the web page compiles with the CAL-3040.
\ But the way to study that program is to use the current version which goes with
\ the CAL-4707, which is available in the same directly as  your o'mail mailbox.
\ More on this below.

I do [ want to go through the whole compiler course].

\ Okay, let's begin at the beginning.
\ 1. Copy the CAL 4707 from our shared directory to your computer.
\ 2. Print the first 54 pages of the instruction manual (from the PDF or the native CAL version).
\ 3. Read and study them, doing EXACTLY what the CAL says to do.
\ 4. Try to ask me at least one pertinent question about each page as you go along.
\ (This will help me understand what you know and what you don't so I don't bore you
\ with things you already know, and so I don't skip things you need to know.)

There are two ways of getting CAL more connected with the public WWW users. 
One is being able to deal with web pages (read and produce). This is easier and CAL already reads web pages.
\ The CAL DOWNLOADS web pages, as text. He does not now how to "read" or display or interpret them.
\ You will see how little he really can do after the exercise above.

The other is to put CAL itself (or something resembling it) on the web to be used like it's on your desktop app.

\ Can't be done. The CAL does stuff that programs running in a browser are not allowed to do,
\ like access the file system directly.

This is harder but there are more improved technogies now. Can you point me to some links (you mentioned before about Javascript projects)?

\ I think it's best, at this time, that we focus on the CAL as he is today.
\ Once you FULLY understand how he compiles Plain English into Windows executables
\ we'll be able to talk more succinctly about JavaScript, etc.

This pdf manual is good even though I'm having a difficult time. I think it's just a matter of knowing which topics I need to concentrate on.

\ All of them, actually. But we'll get there. It's not hard stuff, just tedious stuff.

Whenever you can, go ahead and email me those exercises a bit at a time (or all of them). 

\ Let's begin as I suggested just above. I'll repeat the instructions here for your convenience:

\ 1. Copy the CAL 4707 from our shared directory to your computer.
\ 2. Print the first 54 pages of the instruction manual (from the PDF or the native CAL version).
\ 3. Read and study them, doing EXACTLY what the CAL says to do.
\ 4. Try to ask me at least one pertinent question about each page as you go along.
\ (This will help me understand what you know and what you don't so I don't bore you
\ with things you already know, and so I don't skip things you need to know.)

\ Gerry
