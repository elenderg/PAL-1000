\ Hello again, Lope.

\ I'm in blue, as usual; you're in black.

There's more to this than I can get in one or two or 20 sittings.
I think that I'll learn more talking to you than on my own for the intended specific purpose of translating CAL.
...
I do [want to go through the whole compiler course].

\ Okay, then, let's get started. The first thing you need to do is get to know the CAL a whole lot better.
\ Here's how to do that, in four easy steps:

\ 1. Copy the CAL-4707 from our shared directory to your computer (I want to be sure we're using the same version).
\ 2. Print the first 54 pages of the instruction manual in the "documentation" subdirectory.
\ 3. Read and study those pages, doing EXACTLY and ONLY what the CAL says to do as you read.
\ 4. Ask me any questions that pop into your mind as you progress; hopefully, you'll have at least one question per page.

\ I realize this exercise may sound unnecessary, but trust me, it will make the rest of the steps MUCH easier.
\ And it will answer a lot of your other questions with tangible examples as you go along.
\ Here, for example, are 13  things you will get out of this exercise, all of which you will definitely need to discuss the Compiler in depth:

\ - You'll learn about the six source files that make up the CAL
\ - You'll get lots of practice using the CAL's Editor and Incremental Find facility, both of which you'll need to use, frequently, for the rest of the project
\ - You'll learn how to create a "Baby CAL" from a "Parent CAL"
\ - You'll learn about the different kinds of routines that are in the Noodle and why they are there
\ - You'll get a better understanding of the syntax of Plain English, which will make understanding the Compiler a lot easier
\ - You'll learn how to create a new program using the CAL's simple and obvious "project management" facility
\ - You'll find out how much Windows crap we had to bury to make the language usable at a high level
\ - You'll learn about the important differences between comments, remarks, and qualifiers
\ - You'll learn how to abort a program that is in an eternal loop
\ - You'll learn how to create and manage dynamic memory structures
\ - You'll learn how the CAL supports both built-in and user-defined Types
\ - You'll learn how the CAL supports Literal, Global, Local, and Parameter variables
\ - You'll learn about Strings, Substrings, and Riders - all of which are essential to the compiler

\ And here are 9 more things you'll learn, not specifically necessary to understanding the Compiler, but interesting and useful nevertheless:

\ - You'll learn how the CAL exposes the Windows file system to a user
\ - You'll learn how the CAL simplifies Windows event-driven "messaging" system
\ - You'll learn how to draw on the screen without flicker
\ - You'll learn how to display text messages on the screen
\ - You'll learn how to make buttons, and how to make them respond to user interactions
\ - You'll learn how to write a trivial line-editor in Plain English
\ - You'll find out how the CAL stores and interprets documents written in a simple "markup language" of our own making
\ - You'll learn how to download and "scan" a page from the web
\ - You'll learn how to print from a Plain English program
 
\ After that - assuming you ask lots of good questions along the way - we'll be ready to dive into re-creating the Compiler.
\ And by the end of those exercises, you'll know exactly where the CAL needs to change:
\ - to support a language other than English; and/or
\ - to generate Linux executables instead of Windows executables; and/or
\ - to generate web pages instead of Windows executables.

\ Gerry

\ PS. Here are quick answers to your other questions:

Out of curiousity, at which nth iteration of these primitive CALs was it when you were able to stop using Delphi?

\ Before we even dreamed of the CAL, we used Delphi Pascal to write a Pascal-like language we called AIQ.
\ I don't remember what the name stood for.
\ AIQ was easy to develop because it was just Pascal without the semicolons; we didn't have to "invent" anything new.
\ We stopped using Delphi as soon as AIQ could compile itself.
\ We then used AIQ, all by itself, to make the first version of the CAL.
\ We stopped using AIQ once the CAL was able to compile himself.
\ I don't remember how many iterations it took; but I do remember that...
\ It took my elder son Dan and I about six months to write the whole CAL-3040 (which was the first full version).
\ We worked side-by-side, all day, every day, on a single computer with two monitors (both monitors showing the same thing).
\ When Dan knew what he was doing, he would run the mouse and I would type, and vice-versa.
\ So every line of code was checked twice and agreed upon before we ever ran it.
\ We hardly ever wrote more than a dozen lines without testing.

Your sample.zip from osmosian.com seem able to access the web easily. I can't seem to compile it though. What version of CAL was it compiled on?

\ I think the sample program on our site uses the CAL-3040.
\ But it doesn't matter because you'll be recreating the sample program, from scratch, as you follow the steps above.

A web page is a text file but it has markups. The browser like Chrome is a binary file that ends in ".exe" file extension. 
When a web page is read by Chrome, it hides the markups and renders it as intended.

\ Chrome doesn't just "hide the markups" - it INTERPRETS whatever CSS, HTML, JavaScript, etc, that it finds.
\ In other words, it translates the CSS, HTML, JavaScript, etc, into a "virtual machine language" (sometimes called "bytecode") that is then 
\ interpreted by a "virtual machiine" that is also part of the Chrome executable.
\ It is this "virtual machine" that maps the virtual instructions to actual instructions on a target machine.

Which assembly code are easy to understand?

\ Well, I liked IBM 370 Assembler, back in the day, and
\ I wrote an assembler for Z80 chips in one day when I was young and spry. But...
\ Today's chips are such a mess that their assembler languages are a mess too.

There's another category of computers and that is the server; in particular, web servers. They're run almost exclusively by Linux OS. 

\ If you want to write Linux server-side programs in Plain English, you need a CAL that generates
\ Linux executables instead of Windows executables.
\ If you want to modify the CAL to do that, great.
\ I don't know enough about Linux, but I've tried several times to find a Linux expert to do it for me, without success.
\ If you're a Linux expert, you'll know enough about the CAL when we're done going through the Compiler to do that.

[Two ways to make the CAL more accessible to web users:]
One is being able to deal with web pages (read and produce). This is easier and CAL already reads web pages.

\ The CAL DOWNLOADS web pages, as text. But he does not know how to read or display or interpret them.
\ You will see how little he really can do after you get through the exercise above.

The other is to put CAL itself (or something resembling it) on the web to be used like it's on your desktop app.

\ I don't think this is possible. The CAL does stuff that programs running in a browser are not allowed to do,
\ like write directly to the screen, access the complete file system, spawn new processes, etc.

Can you point me to some links (you mentioned before about Javascript projects)?

\ I think it's best, at this time, that we focus on the CAL as he is today.
\ Once you FULLY understand how he compiles Plain English into Windows executables
\ we'll be able to talk more succinctly about generating JavaScript from Plain English, etc.

