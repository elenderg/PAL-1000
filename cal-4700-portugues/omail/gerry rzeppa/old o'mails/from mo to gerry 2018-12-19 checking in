\ This guy [https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/index.html] for example, 
\ was doing great at explaining how to deal directly with Raspberry Pi hardware.

yeah, i was following through that until i got to the usb part. i never understood why usb had to
be so complicated. i know it's supposed to be universal, but (and i think you'll agree with me on this)
being universal doesn't mean it has to be super complex. flexible, yes, but complicated, no. like signal
lights. they're pretty universal, but they're also incredibly simplistic.

\ My neighbor has a 1965 Mustang that takes him wherever he wants to go.

i have a honda fit that i love, and i'd like to have an electric car, but i do like the simplicity of the older
cars. i've tried to work on my car when things go wrong, but i don't have a chip reader, so i can't
diagnose computer problems or reset codes. 

\ It would still leave us with a very ugly piece of hardware. That slick little stick has a freaking fan on it!

fans are important for computers. remember that a computer is basically the result of teaching a rock
to harness lightning. that generates some heat. but the excess heat is from trying to make the rock
faster and faster, when (again, we agree here) it would be better to just write simpler and faster
software.

\ You're looking in the wrong places for simple. Study computers like the Apple II, and PCs running DOS
\ and the original Macintosh.

do you know of any resources for looking at the code for those things? or should i just reverse-
engineer it? 

regarding hdmi/usb/peripherals, it should be possible to create hardware that handles all that interaction
and does a (safe) direct-memory-addressing scheme. but it's a give-and-take: simpler software means
more complex hardware; simpler hardware means more complex software. it's the same loop you were
talking about.

well, nothing really to report. just catching up.

peace,
mo