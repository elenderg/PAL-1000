Querido Pablo:

\If we could link Speech Recognition with Plain English we could go ahead.

Using Plain English to create a machine like the HAL-9000 was actually our original plan.
The text of a one-page paper I wrote on the subject in 2006 is at the bottom of this post.
More than ten years before Amazon introduced the ECHO! I should have applied for a patent.

\I'm enjoying to read from it. Specially the story about Perspective.

It's a true story.

\If we program an Arduino with a simple program that checks the port to receive instructions, we could use it as an expansion board
\preprogrammed with some sensor readings and outputs activation beforehand. Just thinking!

Dan says the Plain English USB/Serial Port routines are almost ready.
I will put some Español Llano headers on them and send them to you soon, God willing.

\Martín Amín is progressing so much that makes us wonder how awake he is.
\He is almost half year old.

Wow! Such a Big Boy already! But he seems just a little more interested in the TV than the computer.
I have a similar problem with Chuckles -- he'd rather PLAY video games than PROGRAM them.
I will show the video to Sharon and Chuckles tomorrow. Thanks.

Gerry

-------

HOW TO BUILD AN APPARENTLY INTELLIGENT MACHINE

We begin with some reasonable definitions so our goals will be tangible and measurable:

(a) If the machine does what we tell it to do, it UNDERSTANDS.
(b) If the machine can be taught new things, by whatever means, it LEARNS.
(c) If the machine can tell us what it knows and what it has done, it REMEMBERS.

Then we develop a programming language that is a subset of a natural language so the
teaching of the machine can take place over a long period of time, by a wide variety of
people, without the danger of older input becoming syntactically obsolete, and without the
nuisance of a steep learning curve. [eg, Plain English, Español Llano, etc]

Next, we teach the machine to maintain compiled and indexed copies of all type, global
variable, and routine definitions submitted by the wide variety of people mentioned above.
We teach it to rank said definitions based on weighted feedback from those same people,
and to keep only those definitions that produce results acceptable to those people. We
teach it to eliminate exact duplicates, of course, and to randomly exercise functionally
equivalent definitions in the interest of producing further feedback.
[This would have to be a dedicated machine, not a compiler application]
  
(An example may be helpful at this point. Let's say someone is attempting to teach the
machine how to perform an image search on the internet. His instructions will probably
include a sentence such as "Log on to the internet." which the machine will hopefully resolve
to an existing routine. If the person is satisfied that the machine rightly understood the
sentence, he will move on. But if he is not, he will tell the machine why he is dissatisfied, and
the machine will then attempt to service him with a different routine (marking the other
routine as unsatisfactory for the stated reason). If, in the end, no satisfactory routine is
found, the machine will say, "I don't know how to do that." and the individual will have to
teach the machine that particular skill as well, or wait until someone else does.)

Finally, we teach the machine to make a record of all of the significant actions it performs,
and to analyze and report on any or all of the recorded events.

At this point, the machine is "alive"; all that remains is to connect it to various input and
output devices, including the internet, and let it grow. Clones of a given machine, connected
to different devices at different times, will of course grow in different ways.

-------