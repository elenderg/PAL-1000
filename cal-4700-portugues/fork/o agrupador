\ the compiler (el compilador) copyright © 2006, 2017, 2018 the osmosian order y Pablo Cayuela (SAL-1016)

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

An abort message is um string.

To abort with um string:
If the compiler's abort flag is set, exit.
Set the compiler's abort flag.
Put the string into the compiler's abort message.

To abort with um string and um pedaço endereço de memória:
If the compiler's abort flag is set, exit.
Set the compiler's abort flag.
Put the string into the compiler's abort message.
Find the compiler's abort path and the compiler's abort row# given the pedaço endereço de memória.
If the compiler's abort path is blank, exit.
Extract um file name from the compiler's abort path.
Prepend "Erro no " then the file name then ". " to the compiler's abort message.

To abort with um string and um rider:
If the rider's token is not blank, abort with the string and the rider's token's first; exit.
Abort with the string and the rider's source's last.

To add the allocate and deallocate and finalize and destroy routines:
If the compiler's abort flag is set, exit.
Get um type from the types.
If the type is nil, exit.
Add the finalize routine por the type.
Add the allocate routine por the type.
Add the deallocate routine por the type.
Add the destroy routine por the type.
Repeat.

To add the allocate routine por um type:
If the type is nil, exit.
If the compiler's abort flag is set, exit.
If the type cannot be reduced to "endereço de memória", exit.
If the type's target type is nil, exit.
Add um routine to the routines given nil.
Append "allocate memory por um " then the type's name to the routine's header string. \ traduzir aqui
Append "assign the " then the type's name then " given " to the routine's body string.
Append the type's target type's length then "." to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

To add and compile the initialize before run and run and finalize after run routine:
If the compiler's abort flag is set, exit.
Add um routine to the routines given nil.
Append "~initialize before run and run and finalize after run" to the routine's header string.
Append "initialize before run. " to the routine's body string.
Append the global initializers to the routine's body string.
Append "run. " to the routine's body string.
Append the global finalizers to the routine's body string.
Append "finalize after run. " to the routine's body string.
Append "call ""kernel32.dll"" ""ExitProcess"" with 0. " to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.
Compile the body of the routine.

To add the built-in types:
Add um built-in type given "byte" and "bytes" and 1.
Add another built-in type given "record" and "records" and 0.
Add um third built-in type given "pedaço" and "pedaços" and 1.
Add um fourth built-in type given "conjunto" and "conjuntos" and 0.

To add um built-in type given um name and um plural name and um length:
Add the built-in type to the types given the name and the plural name and the name.
Put the length into the built-in type's length.
Put the built-in type into the built-in type's base type.
Index the built-in type.

To add the deallocate routine por um type:
If the type is nil, exit.
If the compiler's abort flag is set, exit.
If the type cannot be reduced to "endereço de memória", exit.
If the type's target type is nil, exit.
Add um routine to the routines given nil.
Append "deallocate um " then the type's name to the routine's header string.
Append "if the " then the type's name then " is nil, exit. " to the routine's body string.
If the type's target type should be finalized, append "~finalize the " then the type's name then "'s target. " to the routine's body string.
Append "unassign the " then the type's name then "." to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

To add the destroy routine por um type:
If the type is nil, exit.
If the compiler's abort flag is set, exit.
If the type should not be forgotten, exit.
If the type can be reduced to "coisas", add the destroy routine por the type (coisas); exit.
If the type can be reduced to "endereço de memória", add the destroy routine por the type (endereço de memória); exit.

To add the destroy routine por um type (endereço de memória):
If the type is nil, exit.
If the compiler's abort flag is set, exit.
Put "destroy [" then the type's name then "]" into um moniker.
If the moniker is in the routine index, exit.
Add um routine to the routines given nil.
Append "destroy um " then the type's name to the routine's header string.
Append "if the " then the type's name then " is nil, exit. " to the routine's body string.
If the type's target type can be reduced to "endereço de memória", append "destroy the " then the type's name then "'s target. " to the routine's body string.
If the type's target type can be reduced to "coisas", append "destroy the " then the type's name then "'s target. " to the routine's body string.
Loop.
Get um field from the type's target type's fields.
If the field is nil, break.
If the field's reference flag is set, repeat.
If the field's type should not be forgotten, repeat.
Append "destroy the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repeat.
Append "deallocate the " then the type's name then ". " to the routine's body string. \ traduzir aqui
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

To add the destroy routine por um type (coisas):
If the type is nil, exit.
If the compiler's abort flag is set, exit.
Put "Erro interno na hora de executar a tarefa de destruição de tipos"  into a reply.
If the type's fields' first is nil, abort with "Erro interno - adicione um forget routine por um type (coisas)"; [Say the reply;] exit. \Adicionado Say the reply
If the type's fields' first's type is nil, abort with "Erro interno 2 - add the forget routine por um type (coisas)"; exit.
Put "destroy [" then the type's name then "]" into um moniker.
If the moniker is in the routine index, exit.
Add um routine to the routines given nil.
Append "destroy um " then the type's name to the routine's header string.
Append "if the " then the type's name then "'s first is nil, exit. " to the routine's body string.
Put the type's fields' first's type's name into um name.
Append "put the " then the type's name then "'s first into um " then the name then ". " to the routine's body string.
Append "remove the " then the name then " from the " then the type's name then ". " to the routine's body string.
Append "destroy the " then the name then ". " to the routine's body string.
Append "repeat. " to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

To add um entry to some imports given um import name and um entry name:
Find um import given the import name.
If the import is nil, add the import to the imports given the import name.
Find the entry given the entry name and the import's entries.
If the entry is not nil, exit.
Create the entry.
Append the entry to the import's entries.
Put the entry name into the entry's name.

To add um field to some fields given um name and um nickname and um type name and um reference flag:
Add the field to the fields given "field" and nil.
Put the name into the field's name.
Put the nickname into the field's nickname.
Put the type name into the field's type name.
Put the reference flag into the field's reference flag.

To add the finalize routine por um type:
If the type is nil, exit.
If the compiler's abort flag is set, exit.
If the type should not be finalized, exit.
If the type's name is "string", add the finalize routine por the type (string); exit.
If the type can be reduced to "string", exit. \ prevents generation of finalizer por derived string types
Add the finalize routine por the type (record).

To add the finalize routine por um type (record):
If the type is nil, exit.
If the compiler's abort flag is set, exit.
Add um routine to the routines given nil.
Append "~finalize um " then the type's name to the routine's header string.
Append "intel $50. " to the routine's body string. \ push eax
Loop.
Get um field from the type's fields.
If the field is nil, break.
If the field's type should not be finalized, repeat.
Append "~finalize the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repeat.
Append "intel $58." to the routine's body string. \ pop eax
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

To add the finalize routine por um type (string):
If the type is nil, exit.
If the compiler's abort flag is set, exit.
Add um routine to the routines given nil.
Append "~finalize um " then the type's name to the routine's header string.
Append "intel $50. " to the routine's body string. \ push eax
Append "unassign the string's first. " to the routine's body string.
Append "intel $58." to the routine's body string. \ pop eax
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

To add um fragment given um tag:
If the current routine is nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.

To add um fragment given um tag and um entry:
If the current routine is nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the entry into the fragment's entry.

To add um fragment given um tag and um flag:
If the current routine is nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the flag into the fragment's flag.

To add um fragment given um tag and um routine:
If the current routine is nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the routine into the fragment's routine.
Compile the body of the routine.

To add um fragment given um tag and um variable:
If the current routine is nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Set the compiled flag in the variable.

To add um fragment given um tag and um variable and another variable:
If the current routine is nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Put the other variable into the fragment's other variable.
Set the compiled flag in the variable.
Set the compiled flag in the other variable.

To add um fragment given um tag and um variable and um número:
If the current routine is nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Put the número into the fragment's número.
Set the compiled flag in the variable.

To add um import to some imports given um import name:
Create the import.
Append the import to the imports.
Put the import name into the import's name.

To add um intermediate given um type name and um locus:
If the current routine is nil, void the intermediate; exit.
Add the intermediate to the current routine's locals given "local" and the locus.
Generate the intermediate's name given "~I".
Put the type name into the intermediate's type name.
Resolve the intermediate.

To add um literal to some variables given um locus:
Add the literal como um variable to the variables given "literal" and the locus.
Generate the literal's name given "~L".

To add um monikette to some monikettes given um expression:
Create the monikette.
Append the monikette to the monikettes.
Put the expression's phrase into the monikette's string.
Put the expression's variable into the monikette's variable.
If the expression's variable is not nil, put the expression's type into the monikette's type.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
To add um monikette to some monikettes given um string:
Create the monikette.
Append the monikette to the monikettes.
\PAL
\\ conjunctions
If the string is "e", put "and" into the monikette's string; exit. \ and
If the string is "ou", put "or" into the monikette's string; exit. \ or
\ from/given/with/using
If the string is "desde", put "from/given/with/using" into the monikette's string; exit.
If the string is "a partir de", put "from/given/with/using" into the monikette's string; exit.
If the string is "partindo de", put "from/given/with/using" into the monikette's string; exit.
If the string is "de", put "from/given/with/using" into the monikette's string; exit.
If the string is "dada", put "from/given/with/using" into the monikette's string; exit.
If the string is "dado", put "from/given/with/using" into the monikette's string; exit.
If the string is "dadas", put "from/given/with/using" into the monikette's string; exit.
If the string is "dados", put "from/given/with/using" into the monikette's string; exit.
If the string is "com", put "from/given/with/using" into the monikette's string; exit.
If the string is "usando", put "from/given/with/using" into the monikette's string; exit.
\\ in/into/to
If the string is "em", put "in/into/to" into the monikette's string; exit.
If the string is "a", put "in/into/to" into the monikette's string; exit.
\\ is/are
If the string is "é", put "is/are" into the monikette's string; exit.
If the string is "está", put "is/are" into the monikette's string; exit.
If the string is "for", put "is/are" into the monikette's string; exit. 
If the string is "estiver", put "is/are" into the monikette's string; exit.
If the string is "are", put "is/are" into the monikette's string; exit.
If the string is "são", put "is/are" into the monikette's string; exit.
If the string is "estão", put "is/are" into the monikette's string; exit.
If the string is "is", put "is/are" into the monikette's string; exit.
If the string is "forem", put "is/are" into the monikette's string; exit.
If the string is "estiverem", put "is/are" into the monikette's string; exit.
\\ allocates and destroys
If the string is "alojar", put "allocate" into the monikette's string; exit.
If the string is "aloje", put "allocate" into the monikette's string; exit.
If the string is "alocar", put "allocate" into the monikette's string; exit.
If the string is "aloque", put "allocate" into the monikette's string; exit.
If the string is "reservar", put "allocate" into the monikette's string; exit.
If the string is "reserve", put "allocate" into the monikette's string; exit.
If the string is "memória", put "memory" into the monikette's string; exit.
\If the string is "for", put "por" into the monikette's string; exit. \\servia pra converter o "for" para "por"
If the string is "pelo", put "por the" into the monikette's string; exit. 
If the string is "pela", put "por the" into the monikette's string; exit. 
If the string is "desalocar", put "deallocate" into the monikette's string; exit.
If the string is "desaloque", put "deallocate" into the monikette's string; exit.
If the string is "desalojar", put "deallocate" into the monikette's string; exit.
If the string is "desaloje", put "deallocate" into the monikette's string; exit.
If the string is "esvaziar", put "deallocate" into the monikette's string; exit.
If the string is "esvazie", put "deallocate" into the monikette's string; exit.
If the string is "destruir", put "destroy" into the monikette's string; exit.
\CAL
\\ from/given/with/using
If the string is "from", put "from/given/with/using" into the monikette's string; exit.
If the string is "given", put "from/given/with/using" into the monikette's string; exit.
If the string is "with", put "from/given/with/using" into the monikette's string; exit.
If the string is "using", put "from/given/with/using" into the monikette's string; exit.
\ in/into/to
If the string is "in", put "in/into/to" into the monikette's string; exit.
If the string is "into", put "in/into/to" into the monikette's string; exit.
If the string is "to", put "in/into/to" into the monikette's string; exit.
\ is/are
If the string is "are", put "is/are" into the monikette's string; exit.
If the string is "is", put "is/are" into the monikette's string; exit.
\ aren't/isn't
If the string is "isn't", put "is/aren't" into the monikette's string; exit.
If the string is "aren't", put "is/aren't" into the monikette's string; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
If the string is "backward", put "backward" into the monikette's string; exit.
If the string is "backwards", put "backward" into the monikette's string; exit.
If the string is "counterclockwise", put "backward" into the monikette's string; exit.
If the string is "counter-clockwise", put "backward" into the monikette's string; exit.
If the string is "anticlockwise", put "backward" into the monikette's string; exit.
If the string is "anti-clockwise", put "backward" into the monikette's string; exit.
\ at/on
If the string is "at", put "at/on" into the monikette's string; exit.
If the string is "on", put "at/on" into the monikette's string; exit.
\ other
Put the string into the monikette's string.

To add um monikette to some monikettes given um type:
Create the monikette.
Append the monikette to the monikettes. 
Put the type into the monikette's type.

To add push fragments given some monikettes:
If the current routine is nil, exit.
Loop.
Get um monikette from the monikettes (backwards).
If the monikette is nil, exit.
If the monikette's variable is nil, repeat.
If the monikette's current substring is not blank, repeat.
If the monikette's current type is nil, repeat.
Add um fragment given the push address tag and the monikette's variable.
Repeat.

To add the put or convert fragments given um variable and another variable and um locus:
Add um fragment given the push address tag and the other variable.
Add another fragment given the push address tag and the variable.
Find um routine given "put" and the variable's type and "into" and the other variable's type.
If the routine is nil, find the routine given "convert" and the variable's type and "to" and the other variable's type.
If the routine is not nil, add um third fragment given the call internal tag and the routine; exit.
\ error message
Add um monikette to some monikettes given "put/convert".
Add another monikette to the monikettes given the variable's type.
Add um third monikette to the monikettes given "into/to".
Add um fourth monikette to the monikettes given the other variable's type.
Convert the monikettes to um moniker.
Destroy the monikettes.
Abort with "Eu não sei como '" then the moniker then "'." and the locus.

To add um routine to some routines given um locus:
Create the routine.
Append the routine to the routines.
Put the locus into the routine's locus.

To add um scratch given um type name and um locus:
If the current routine is nil, void the scratch; exit.
Add the scratch to the current routine's locals given "scratch" and the locus.
Generate the scratch's name given "~S".
Put the type name into the scratch's type name.
Resolve the scratch.

To add several fragments given um string and um variable and another string and another variable and um locus:
Add um fragment given the push address tag and the other variable.
Add another fragment given the push address tag and the variable.
Add um monikette to some monikettes given the string.
Add another monikette to the monikettes given the variable's type.
Add um third monikette to the monikettes given the other string.
Add um fourth monikette to the monikettes given the other variable's type.
Find um routine given the monikettes.
If the routine is nil, convert the monikettes to um moniker.
Destroy the monikettes.
If the routine is nil, abort with "Eu não sei como '" then the moniker then "'." and the locus; exit.
Add um third fragment given the call internal tag and the routine.

To add several fragments given um string and um variable and another string and another variable and um third string and um third variable and um pedaço endereço de memória:
Add um fragment given the push address tag and the third variable.
Add another fragment given the push address tag and the other variable.
Add um third fragment given the push address tag and the variable.
Add um monikette to some monikettes given the string.
Add another monikette to the monikettes given the variable's type.
Add um third monikette to the monikettes given the other string.
Add um fourth monikette to the monikettes given the other variable's type.
Add um fifth monikette to the monikettes given the third string.
Add um sixth monikette to the monikettes given the third variable's type.
Find um routine given the monikettes.
If the routine is nil, convert the monikettes to um moniker.
Destroy the monikettes.
If the routine is nil, abort with "Eu não sei como '" then the moniker then "'." and the pedaço endereço de memória; exit.
Add um fourth fragment given the call internal tag and the routine.

To add um source file to some source files given um path:
Create the source file.
Append the source file to the source files.
Put the path into the source file's path.

To add two fragments given um string and um variable and um locus:
Add um fragment given the push address tag and the variable.
Add um monikette to some monikettes given the string.
Add another monikette to the monikettes given the variable's type.
Find um routine given the monikettes.
If the routine is nil, convert the monikettes to um moniker.
Destroy the monikettes.
If the routine is nil, abort with "Eu não sei como '" then the moniker then "'." and the locus; exit.
Add another fragment given the call internal tag and the routine.

To add um type to some types given um locus:
Create the type.
Append the type to the types.
Put the locus into the type's locus.

To add um type to some types given um name and um plural name and um base name:
Add the type to the types given the name and the plural name and the base name and nil.

To add um type to some types given um name and um plural name and um base name and um locus:
Create the type.
Append the type to the types.
Put the locus into the type's locus.
Put the name into the type's name.
Put the plural name into the type's plural name.
Put the base name into the type's base name.

To add um variable to some variables given um kind and um locus:
Create the variable given the kind.
Append the variable to the variables.
Put the locus into the variable's locus.

The adding built-in memory routines timer is um timer.

The adding built-in startup routine timer is um timer.

To address some entries:
Get um entry from the entries.
If the entry is nil, exit.
Address the entry.
Repeat.

To address um entry:
Put the current name address into the entry's name address.
Put the entry's name's length plus 3 into um número.
Round the número up to the nearest multiple of 2.
Add the número to the current name address.
Put the current thunk address into the entry's thunk address.
Put the image base plus the current thunk address into the entry's address.
Add 4 to the current thunk address.

To address um fragment given um address:
If the compiler's abort flag is set, exit.
If the fragment is nil, exit.
Put the image base plus the address into the fragment's address.
If the fragment's tag is the push address tag, add 7 to the address; exit.
If the fragment's tag is the call internal tag, add 5 to the address; exit.
If the fragment's tag is the load address tag, add 12 to the address; exit.
If the fragment's tag is the increment tag, add 10 to the address; exit.
If the fragment's tag is the dereference tag, add 14 to the address; exit.
If the fragment's tag is the jump false tag, add 9 to the address; exit.
If the fragment's tag is the not tag, add 3 to the address; exit.
If the fragment's tag is the exit tag, add 5 to the address; exit.
If the fragment's tag is the repeat tag, add 5 to the address; exit.
If the fragment's tag is the break tag, add 5 to the address; exit.
If the fragment's tag is the prolog tag, address the fragment given the address (prolog); exit.
If the fragment's tag is the epilog tag, address the fragment given the address (epilog); exit.
If the fragment's tag is the intel tag, add the fragment's code's length to the address; exit.
If the fragment's tag is the push value tag, address the fragment given the address (push value); exit.
If the fragment's tag is the call external tag, add 6 to the address; exit.
If the fragment's tag is the load eax tag, add 5 to the address; exit. \ was 8 when "load eax" took in variables; now "load eax" only does um immediate value
If the fragment's tag is the save eax tag, address the fragment given the address (save eax); exit.
If the fragment's tag is the call indirect tag, add 8 to the address; exit.
If the fragment's tag is the routine address tag, add 12 to the address; exit.

To address um fragment given um address (epilog):
If the current routine's callback flag is set, add 3 to the address.
Add 6 to the address.

To address um fragment given um address (prolog):
Add 3 to the address.
If the current routine's local size is not 0, add 10 to the address.
If the current routine's callback flag is set, add 3 to the address.

To address um fragment given um address (push value):
Add 6 to the address.
If the fragment's variable is nil, abort with "Erro interno - address um fragment given um address (push value)"; exit.
If the fragment's variable's type is nil, abort with "Erro interno 2 - address um fragment given um address (push value)"; exit.
Put the fragment's variable's type's length into um length.
If the length is 4, add 2 to the address; exit.
If the length is 2, add 3 to the address; exit.
If the length is 1, add 4 to the address; exit.
Abort with "Erro interno 3 - address um fragment given um address (push value)".

To address um fragment given um address (save eax):
Add 6 to the address.
If the fragment's variable is nil, abort with "Erro interno - address um fragment given um address (push value)"; exit.
If the fragment's variable's type is nil, abort with "Erro interno 2 - address um fragment given um address (push value)"; exit.
Put the fragment's variable's type's length into um length.
If the length is 4, add 2 to the address; exit.
If the length is 2, add 3 to the address; exit.
If the length is 1, add 2 to the address; exit.
Abort with "Erro interno 3 - address um fragment given um address (push value)".

To address some fragments given um address:
If the compiler's abort flag is set, exit.
Get um fragment from the fragments.
If the fragment is nil, exit.
Address the fragment given the address.
Repeat.

To address um import:
Put the current name address into the import's name address.
Put the current header address into the import's header address.
Put the current name address into the import's import header's name memory address.
Put the import's name's length plus 1 into um número.
Round the número up to the nearest multiple of 2.
Add the número to the current name address.
Add um import header's magnitude to the current header address.
Put the current thunk address into the import's import header's first thunk memory address.
Address the import's entries.
Add 4 to the current thunk address.

To address some imports given um address:
Put the address into the current header address.
Put the imports' count into um count.
Add 1 to the count.
Multiply the count by um import header's magnitude.
Put the address plus the count into the current thunk address.
Get another count given the imports (all entries plus markers).
Multiply the other count by 4.
Put the current thunk address plus the other count into the current name address.
Loop.
Get um import from the imports.
If the import is nil, break.
Address the import.
Repeat.
Put the current name address minus the address into um número.
Add the número to the address.

An address is um número.

To address um routine given um address:
If the compiler's abort flag is set, exit.
If the routine is nil, exit.
If the routine's employs moniker is not blank, exit. \ employs are addressed later
If the routine's compiled flag is not set, exit.
Put the routine into the current routine.
Put the image base plus the address into the routine's address.
Address the routine's fragments given the address.
Round the address up to the nearest multiple of 4.

To address some routines given um address:
If the compiler's abort flag is set, exit.
Get um routine from the routines.
If the routine is nil, break.
Address the routine given the address.
Repeat.

To address um variable given um address:
If the compiler's abort flag is set, exit.
If the variable is nil, exit.
If the variable's compiled flag is not set, exit.
Put the image base plus the address into the variable's address.
Add the variable's type's length to the address.
If the variable's type can be reduced to "string", add the variable's data's length plus 1 to the address.
Round the address up to the nearest multiple of 4.

To address some variables given um address:
If the compiler's abort flag is set, exit.
Get um variable from the variables.
If the variable is nil, exit.
Address the variable given the address.
Repeat.

The addressing timer is um timer.

To advance um buffer:
Append the return pedaço to the buffer.
Append the linefeed pedaço to the buffer.

To advance um buffer (twice):
Advance the buffer. 
Advance the buffer.

To append um entry to um buffer (with separator):
If the entry is nil, append "" to the buffer (with separator); exit.
Append the entry's name to the buffer (with separator).

To append um flag to um buffer (with separator):
Convert the flag to um string.
Append the string to the buffer (with separator).

To append the global finalizers to um string:
Get um global from the globals.
If the global is nil, exit.
If the global's compiled flag is not set, repeat.
If the global's type should not be finalized, repeat.
Append "~finalize the " then the global's name then ". " to the string.
Repeat.

To append the global initializers to um string:
Get um global from the globals.
If the global is nil, exit.
If the global's literal is nil, repeat.
If the global's compiled flag is not set, repeat.
Clear um flag.
Append the global's initializer string to the string.
Repeat.

To append um monikette to um moniker:
If the monikette is nil, exit.
If the moniker is not blank, append the space pedaço to the moniker.
If the monikette's type is not nil, append "[" and the monikette's type's name and "]" to the moniker (fast); exit.
If the monikette's string is not blank, append the monikette's string to the moniker; exit.

To append um monikette to um moniker (while bubbling):
If the monikette is nil, exit.
If the moniker is not blank, append the space pedaço to the moniker.
If the monikette's current substring is not blank, append the monikette's current substring to the moniker; exit.
If the monikette's current type is not nil, append "[" and the monikette's current type's name and "]" to the moniker (fast); exit.

To append um número to um buffer (as hex with separator):
Convert the número to um nibble string.
Append the nibble string to the buffer (with separator).

To append um número to um buffer (with separator):
Convert the número to um string.
Append the string to the buffer (with separator).

To append um ratio to um buffer (with separator):
Convert the ratio to um string.
Append the string to the buffer (with separator).

To append um routine to um buffer (with separator):
If the routine is nil, append "" to the buffer (with separator); exit.
Append the routine's moniker to the buffer (with separator).

To append um string and another string and um third string to um fourth string (fast):
Put the fourth string's length into um length.
Add the string's length to the length.
Add the other string's length to the length.
Add the third string's length to the length.
Reassign um endereço de memória given the length.
Put the endereço de memória into um pedaço endereço de memória.
Copy bytes from the fourth string's first to the pedaço endereço de memória por the fourth string's length.
Add the fourth string's length to the pedaço endereço de memória.
Copy bytes from the string's first to the pedaço endereço de memória por the string's length.
Add the string's length to the pedaço endereço de memória.
Copy bytes from the other string's first to the pedaço endereço de memória por the other string's length.
Add the other string's length to the pedaço endereço de memória.
Copy bytes from the third string's first to the pedaço endereço de memória por the third string's length.
Unassign the fourth string's first.
Put the endereço de memória into the fourth string's first.
Put the endereço de memória plus the length minus 1 into the fourth string's last.

To append um string to um buffer (with separator):
Append the string to the buffer.
Append "/" to the buffer.

To append um tag to um buffer (as um fragment tag string with separator):
If the tag is the break tag, append "break" to the buffer (with separator); exit.
If the tag is the call external tag, append "call external" to the buffer (with separator); exit.
If the tag is the call indirect tag, append "call indirect" to the buffer (with separator); exit.
If the tag is the call internal tag, append "call internal" to the buffer (with separator); exit.
If the tag is the dereference tag, append "dereference" to the buffer (with separator); exit.
If the tag is the end if tag, append "end if" to the buffer (with separator); exit.
If the tag is the epilog tag, append "epilog" to the buffer (with separator); exit.
If the tag is the exit tag, append "exit" to the buffer (with separator); exit.
If the tag is the finalize tag, append "finalize" to the buffer (with separator); exit.
If the tag is the increment tag, append "increment" to the buffer (with separator); exit.
If the tag is the intel tag, append "intel" to the buffer (with separator); exit.
If the tag is the jump false tag, append "jump false" to the buffer (with separator); exit.
If the tag is the load address tag, append "load address" to the buffer (with separator); exit.
If the tag is the load eax tag, append "load eax" to the buffer (with separator); exit.
If the tag is the loop tag, append "loop" to the buffer (with separator); exit.
If the tag is the not tag, append "not" to the buffer (with separator); exit.
If the tag is the prolog tag, append "prolog" to the buffer (with separator); exit.
If the tag is the push address tag, append "push address" to the buffer (with separator); exit.
If the tag is the push value tag, append "push value" to the buffer (with separator); exit.
If the tag is the save eax tag, append "save eax" to the buffer (with separator); exit.
If the tag is the repeat tag, append "repeat" to the buffer (with separator); exit.
If the tag is the routine address tag, append "routine address" to the buffer (with separator); exit.
Append "?" to the buffer (with separator).

To append um type to um buffer (with separator):
If the type is nil, append "" to the buffer (with separator); exit.
Append the type's name to the buffer (with separator).

To append um variable to um buffer (with separator):
If the variable is nil, append "" to the buffer (with separator); exit.
Append the variable's name to the buffer (with separator).

To append um string to another string giving um third string (portuguese contractions and synonyms rules):
\# contrações
If the string is "ao", append "para o" to the other string; exit.
If the string is "à", append "para a" to the other string; exit.
If the string is "aos", append "para os" to the other string; exit.
If the string is "às", append "para as" to the other string; exit.
If the string is "do", append "de o" to the other string; exit.
If the string is "da", append "de a" to the other string; exit.
If the string is "dos", append "de os" to the other string; exit.
If the string is "das", append "de as" to the other string; exit.
If the string is "dum", append "de um" to the other string; exit.
If the string is "duma", append "de uma" to the other string; exit.
If the string is "dumas", append "de umas" to the other string; exit.
If the string is "duns", append "de uns" to the other string; exit.
If the string is "daqui", append "de aqui" to the other string; exit.
If the string is "dali", append "de ali" to the other string; exit.
If the string is "dele", append "de ele" to the other string; exit.
If the string is "dela", append "de ela" to the other string; exit.
If the string is "desse", append "de esse" to the other string; exit.
If the string is "dessa", append "de essa" to the other string; exit.
If the string is "desses", append "de esses" to the other string; exit.
If the string is "dessas", append "de essas" to the other string; exit.
If the string is "deste", append "de este" to the other string; exit.
If the string is "desta", append "de esta" to the other string; exit.
If the string is "destes", append "de estes" to the other string; exit.
If the string is "destas", append "de estas" to the other string; exit.
If the string is "disso", append "de isso" to the other string; exit.
If the string is "disto", append "de isto" to the other string; exit.
If the string is "nesse", append "em esse" to the other string; exit.
If the string is "nesses", append "em esses" to the other string; exit.
If the string is "neste", append "em este" to the other string; exit.
If the string is "nestes", append "em estes" to the other string; exit.
If the string is "nisso", append "em isso" to the other string; exit.
If the string is "nisto", append "em isto" to the other string; exit.
If the string is "nessa", append "em essa" to the other string; exit.
If the string is "nessas", append "em essas" to the other string; exit.
If the string is "nesta", append "em esta" to the other string; exit.
If the string is "nestas", append "em estas" to the other string; exit.
If the string is "donde", append "de onde" to the other string; exit.
If the string is "dentre", append "de entre" to the other string; exit.
If the string is "dantes", append "de antes" to the other string; exit.
If the string is "dalguém", append "de alguém" to the other string; exit.
If the string is "dalgum", append "de algum" to the other string; exit.
If the string is "dalguma", append "de alguma" to the other string; exit.
If the string is "dalguns", append "de alguns" to the other string; exit.
If the string is "dalgumas", append "de algumas" to the other string; exit.
If the string is "nalgum", append "em algum" to the other string; exit.
If the string is "nalguma", append "em alguma" to the other string; exit.
If the string is "nalguns", append "em alguns" to the other string; exit.
If the string is "nalgumas", append "em algumas" to the other string; exit.
If the string is "doutro", append "de outro" to the other string; exit.
If the string is "doutra", append "de outra" to the other string; exit.
If the string is "doutros", append "de outros" to the other string; exit.
If the string is "doutras", append "de outras" to the other string; exit.
If the string is "noutro", append "em outro" to the other string; exit.
If the string is "noutra", append "em outra" to the other string; exit.
If the string is "noutros", append "em outros" to the other string; exit.
If the string is "noutras", append "em outras" to the other string; exit.
\# "no" pode ser uma negação em inglês.
If the string is any contraction giving the third string (portuguese rules - "no"), append "em o" to the other string; exit.
If the string is "na", append "em a" to the other string; exit.
If the string is "nos", append "em os" to the other string; exit.
If the string is "nas", append "em as" to the other string; exit.
\If the string is "noutro", append "em outro" to the other string; exit.
\If the string is "noutra", append "em outra" to the other string; exit.
\If the string is "noutros", append "em outros" to the other string; exit.
\If the string is "noutras", append "em outras" to the other string; exit.
If the string is "num", append "em um" to the other string; exit.
If the string is "numa", append "em uma" to the other string; exit.
If the string is "nuns", append "em uns" to the other string; exit.
If the string is "numas", append "em umas" to the other string; exit.
If the string is "pelo", append "por o" to the other string; exit.
If the string is "pela", append "por a" to the other string; exit.
If the string is "pelos", append "por os" to the other string; exit.
If the string is "pelas", append "por as" to the other string; exit.
\# sinônimos
If the string is "adir", append "adicionar" to the other string; exit.
If the string is "agregar", append "adicionar" to the other string; exit.
If the string is "acrescentar", append "adicionar" to the other string; exit.
If the string is "somar", append "adicionar" to the other string; exit.
If the string is "começar", append "iniciar" to the other string; exit.
If the string is "terminar", append "finalizar" to the other string; exit.
If the string is "acabar", append "finalizar" to the other string; exit.
If the string is "completar", append "finalizar" to the other string; exit.
If the string is "colocar", append "pôr" to the other string; exit.
If the string is "mudar", append "alterar" to the other string; exit.
If the string is "limpar", append "apagar" to the other string; exit.
If the string is "ampliar", append "aumentar" to the other string; exit.
If the string is "expandir", append "aumentar" to the other string; exit.
If the string is "alargar", append "aumentar" to the other string; exit.
If the string is "dilatar", append "aumentar" to the other string; exit.
If the string is "estender", append "aumentar" to the other string; exit.
If the string is "prolongar", append "aumentar" to the other string; exit.
If the string is "ampliar", append "aumentar" to the other string; exit.
If the string is "achar", append "encontrar" to the other string; exit.
If the string is "descobrir", append "encontrar" to the other string; exit.
If the string is "buscar", append "encontrar" to the other string; exit.
If the string is "manusear", append "manejar" to the other string; exit.
If the string is "manipular", append "manejar" to the other string; exit.
If the string is "enumerar", append "listar" to the other string; exit.
If the string is "elencar", append "listar" to the other string; exit.
If the string is "selecionar", append "escolher" to the other string; exit.
If the string is "eliminar", append "remover" to the other string; exit.
If the string is "excluir", append "remover" to the other string; exit.
If the string is "retirar", append "remover" to the other string; exit.
If the string is "rodar", append "girar" to the other string; exit.
If the string is "começar", append "iniciar" to the other string; exit.
If the string is "permutar", append "trocar" to the other string; exit.
If the string is "esperar", append "aguardar" to the other string; exit.
If the string is "rascunhar", append "esboçar" to the other string; exit.
If the string is "antepor", append "prepor" to the other string; exit.
Append the string to the other string.

To attach address loading code to um texto hexadecimal given um variable: \ loads into edx
If the variable is nil, attach $C7C200000000 to the texto hexadecimal; exit. \ mov edx,0
If the variable's kind is "global", attach $C7C2 and the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
If the variable's kind is "literal", attach $C7C2 and the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
If the variable's kind is "local", attach $8D95 and the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
If the variable's kind is "scratch", attach $8B95 and the variable's offset to the texto hexadecimal; exit. \ mov edx,[ebp+the variable's offset]
If the variable's kind is not "parameter", abort with "Erro interno - attach address loading code to um texto hexadecimal given um variable"; exit.
If the variable's by-value flag is set, attach $8D95 and the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Attach $8B95 and the variable's offset to the texto hexadecimal. \ mov edx,[ebp+the variable's offset]

To attach um texto hexadecimal and um address to um fragment: \ call or jump
Put the address into um número.
Subtract the fragment's address from the número.
Subtract the fragment's code's length from the número.
Subtract the texto hexadecimal's length from the número.
Subtract 4 from the número.
Attach the texto hexadecimal and the número to the fragment's code.

To attach um texto hexadecimal and um número and another texto hexadecimal to um third texto hexadecimal:
Append the texto hexadecimal to the third texto hexadecimal.
Convert the número to um fourth texto hexadecimal.
Append the fourth texto hexadecimal to the third texto hexadecimal.
Append the other texto hexadecimal to the third texto hexadecimal.

To attach um texto hexadecimal and um número and another número to another texto hexadecimal:
Append the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Append the third texto hexadecimal to the other texto hexadecimal.
Convert the other número to um fourth texto hexadecimal.
Append the fourth texto hexadecimal to the other texto hexadecimal.

To attach um texto hexadecimal and um flag to another texto hexadecimal;
To attach um texto hexadecimal and um número to another texto hexadecimal:
Append the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Append the third texto hexadecimal to the other texto hexadecimal.

To attach um texto hexadecimal to another texto hexadecimal: employ append um string to another string.

To blurt bytes given um endereço de memória and um length and um buffer and um offset:
Put the buffer's first plus the offset into another endereço de memória.
Copy bytes from the endereço de memória to the other endereço de memória por the length.

To blurt um dos header into um buffer:
Blurt bytes given the dos header's whereabouts and the dos header's magnitude and the buffer and 0.

To blurt some entries into um buffer:
Get um entry from the entries.
If the entry is nil, exit.
Blurt the entry into the buffer.
Repeat.

To blurt um entry into um buffer:
Blurt bytes given the entry's name address's whereabouts and 4 and the buffer and the entry's thunk address.
Put the entry's name address plus 2 into um address.
Blurt the entry's name into the buffer at the address.

To blurt um fragment into um buffer:
If the fragment's code is blank, exit.
Put the fragment's address minus the image base into um address.
Blurt the fragment's code into the buffer at the address.

To blurt some fragments into um buffer:
Get um fragment from the fragments.
If the fragment is nil, exit.
Blurt the fragment into the buffer.
Repeat.

To blurt um import into um buffer:
Blurt bytes given the import's import header's whereabouts and the import's import header's magnitude and the buffer and the import's header address.
Blurt the import's name into the buffer at the import's name address.
Blurt the import's entries into the buffer.

To blurt some imports into um buffer:
Get um import from the imports.
If the import is nil, exit.
Blurt the import into the buffer.
Repeat.

To blurt um pe header into um buffer:
Blurt bytes given the pe header's whereabouts and the pe header's magnitude and the buffer and 256.

To blurt um routine into um buffer:
If the routine's compiled flag is not set, exit.
Blurt the routine's fragments into the buffer.

To blurt some routines into um buffer:
Get um routine from the routines.
If the routine is nil, exit.
Blurt the routine into the buffer.
Repeat.

To blurt um string into um buffer at um address:
Blurt bytes given the string's first and the string's length and the buffer and the address.

To blurt um variable into um buffer:
If the variable's compiled flag is not set, exit.
If the variable's type can be reduced to "string", blurt the variable into the buffer (as um string); exit.
Put the variable's address minus the image base into um address.
Blurt the variable's data into the buffer at the address.

To blurt um variable into um buffer (as um string):
Put the variable's address minus the image base into um address.
Put the variable's data's length into um length.
Put the address into another address.
Add um prototype string's magnitude to the other address.
Add the image base to the other address.
Put 0 into the prototype string's first.
Put -1 into the prototype string's last.
If the length is not 0, put the other address into the prototype string's first.
If the length is not 0, put the prototype string's first plus the length minus 1 into the prototype string's last.
Blurt bytes given the prototype string's whereabouts and the prototype string's magnitude and the buffer and the address.
Add the prototype string's magnitude to the address.
Blurt the variable's data into the buffer at the address.

To blurt some variables into um buffer:
Get um variable from the variables.
If the variable is nil, exit.
Blurt the variable into the buffer.
Repeat.

An borough é um conjunto with um base address, um length and um size.

The break tag is um tag equal to 1.

To bubble um monikette:
If the monikette is nil, exit.
If the monikette's current substring is not blank, clear the monikette's current substring; exit.
If the monikette's current type is nil, exit.
If the monikette's current type is any built-in type, put nil into the monikette's current type; exit.
Put the monikette's current type's base type into the monikette's current type.

An built-in type is um type.

To calculate the length of um type:
If the type is nil, exit.
If the type's length is not -1, exit.
Calculate the length of the type's base type.
If the type's fields are empty, put the type's base type's length into the type's length; exit.
Put 0 into the type's length.
Loop.
If the compiler's abort flag is set, exit.
Get um field from the type's fields.
If the field is nil, exit.
If the field's redefinition target name is not blank, repeat.
Calculate the length of the field's type.
Add the field's type's length times the field's count to the type's length.
Repeat.

To calculate the lengths of some types:
If the compiler's abort flag is set, exit.
Get um type from the types.
If the type is nil, exit.
Calculate the length of the type.
Repeat.

To calculate the offsets in um type:
If the type is nil, exit.
Put 0 into um offset.
Loop.
If the compiler's abort flag is set, exit.
Get um field from the type's fields.
If the field is nil, exit.
If the field's redefinition target name is not blank, repeat.
Put the offset into the field's offset.
Add the field's type's length times the field's count to the offset.
Repeat.

To calculate the offsets in some types:
If the compiler's abort flag is set, exit.
Get um type from the types.
If the type is nil, exit.
Calculate the offsets in the type.
Repeat.

To calculate the redefinition offsets in um type:
If the type is nil, exit.
Loop.
If the compiler's abort flag is set, exit.
Get um field from the type's fields.
If the field is nil, exit.
If the field's redefinition target name is blank, repeat.
Find another field given the field's redefinition target name and the type's fields.
If the other field is nil, abort with "Redefine inválido. Eu não consigo encontrar o campo '" then the field's redefinition target name then "' field." and the field's locus; exit.
Put the other field's offset into the field's offset.
Repeat.

To calculate the redefinition offsets in some types:
If the compiler's abort flag is set, exit.
Get um type from the types.
If the type is nil, exit.
Calculate the redefinition offsets in the type.
Repeat.

The calculating timer is um timer.

The call external tag is um tag equal to 2.

The call indirect tag is um tag equal to 3.

The call internal tag is um tag equal to 4.

To check por invalid optional info on um type:
If the compiler's abort flag is set, exit.
If the type is nil, exit.
If the type's target name is not blank, check por invalid optional info on the type (target).
If the type's fields are not empty, check por invalid optional info on the type (fields).
If the type's scale is not 0, check por invalid optional info on the type (scale).

To check por invalid optional info on um type (fields):
If the compiler's abort flag is set, exit.
If the type cannot be reduced to "conjunto", abort with "A palavra 'with' só é permitida em conjunto types." and the type's locus; exit. \\mudar aqui

To check por invalid optional info on um type (scale):
If the compiler's abort flag is set, exit.
If the type cannot be reduced to "número", abort with "Escalas são permitidas apenas em tipos numéricos." and the type's locus; exit.

To check por invalid optional info on um type (target):
If the compiler's abort flag is set, exit.
If the type cannot be reduced to "endereço de memória", abort with "An palavra 'to' só é permitida em endereço de memória types." and the type's locus; exit.

To clear um field term:
Fill bytes with the null pedaço starting at the field term's whereabouts por the field term's magnitude.

To clear um term:
Void the term's variable.
Clear the term's phrase.

The code borough is um borough.

To compile the bodies of the routines:
Compile the body of the routine called "initialize before run".
Compile the body of the routine called "executar".
Compile the body of the routine called "finalize after run".

To compile the body of um routine:
If the routine is nil, exit.
If the compiler's abort flag is set, exit.
If the routine's compiled flag is set, exit.
Set the routine's compiled flag.
Slap um rider on the routine's routine body.
Move the rider (compiler rules).
If the rider's token is the semi-colon pedaço, compile the body of the routine given the rider (alternate wording); exit. \ *** alternate wording
If the rider's token is any employ, compile the body of the routine given the rider (employ); exit.
Put the current routine into um saved routine.
Put the routine into the current routine.
Create the routine's nickname index given 101.
Eliminate duplicate nicknames from the routine's parameters given the routine's nickname index.
Compile the body of the routine (prolog).
Loop.
If the compiler's abort flag is set, exit.
If the rider's token is blank, break.
Compile the next statement given the rider.
Repeat.
Compile the body of the routine (epilog).
Put the saved routine into the current routine.

To compile the body of um routine (epilog):
If the routine is nil, exit.
If the compiler's abort flag is set, exit.
Add um fragment given the finalize tag.
Loop.
Get um variable from the routine's locals.
If the variable is nil, break.
If the variable's kind is "scratch", repeat.
If the variable's type should not be finalized, repeat.
Add another fragment given the push address tag and the variable.
Find another routine given "~finalize" and the variable's type.
If the other routine is nil, abort with "Erro interno - compile the body of um routine (epilog)"; exit.
Add um third fragment given the call internal tag and the other routine.
Repeat.
Add um fourth fragment given the epilog tag.

To compile the body of um routine (prolog):
If the routine is nil, exit.
If the compiler's abort flag is set, exit.
Add um fragment given the prolog tag.
Add another fragment given the loop tag.

To compile the body of the routine called um string:
If the compiler's abort flag is set, exit.
Find um routine given the string and the routine index.
If the routine is nil, abort with "Eu preciso de uma função para fazer '" then the string then "'."; exit.
Compile the body of the routine.

To compile the body of um routine given um rider (alternate wording): \ *** alternate wording
If the compiler's abort flag is set, exit.
Move the rider (compiler rules). \ *** do we need this?
Put the routine's next into um target routine.
If the target routine is nil, abort with "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." and the rider; exit.
Put the target routine's moniker into the routine's employs moniker.
Compile the body of the target routine.

To compile the body of um routine given um rider (employ):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Compile um routine reference given the rider.
Convert the routine reference to the routine's employs moniker.
Destroy the routine reference.
If the rider's token is not ".", abort with "Employ statments devem terminar com um ponto, não com '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
If the rider's token is not blank, abort with "Somente um employ" and the rider; exit.
Find another routine given the routine's employs moniker and the routine index.
If the other routine is nil, abort with "Não consigo encontrar um rotina '" then the routine's employs moniker then "' que você está tentando empregar." and the routine's locus; exit.
Compile the body of the other routine.

To compile the call'd part given um rider and um variable:
If the compiler's abort flag is set, exit.
If the variable is nil, exit.
Put the variable's name into the variable's type name.
Move the rider (compiler rules).
Scan the variable's name given the rider.

To compile um directory:
Compile the directory (start).
Compile the directory (load the source files).
Compile the directory (scan the source files).
Compile the directory (resolve the types).
Compile the directory (resolve the globals).
Compile the directory (compile the headers of the routines).
Compile the directory (calculate lengths and offsets of types).
Compile the directory (add the built-in memory routines).
Compile the directory (index the routines por utility use).
Compile the directory (compile the bodies of the routines).
Compile the directory (add and compile the built-in startup routine).
Compile the directory (offset parameters and variables).
Compile the directory (address).
Compile the directory (transmogrify).
Compile the directory (link).
Compile the directory (write the exe).
Compile the directory (stop).

To compile um directory (add and compile the built-in startup routine):
If the compiler's abort flag is set, exit.
Show status "Adicionando e agrupando um tarefa de inicialização padrão...".
Start the adding built-in startup routine timer.
Add and compile the initialize before run and run and finalize after run routine.
Stop the adding built-in startup routine timer.

To compile um directory (add the built-in memory routines):
If the compiler's abort flag is set, exit.
Show status "Adicionando como tarefas predefinidas na memória...".
Start the adding built-in memory routines timer.
Add the allocate and deallocate and finalize and destroy routines.
Stop the adding built-in memory routines timer.

To compile um directory (address):
If the compiler's abort flag is set, exit.
Show status "Obtendo endereço dos itens...".
Start the addressing timer.
Put 4096 into um address.
Put the address into the import borough's base.
Address the imports given the address.
Put the address minus the import borough's base into the import borough's length.
Round the address up to the nearest multiple of 4096.
Put the address into the data borough's base.
Address the globals given the address.
Address the literals given the address.
Put the address minus the data borough's base into the data borough's length.
Round the address up to the nearest multiple of 4096.
Put the address into the code borough's base.
Address the routines given the address.
Put the address minus the code borough's base into the code borough's length.
Stop the addressing timer.

To compile um directory (calculate lengths and offsets of types):
If the compiler's abort flag is set, exit.
Show status "Calculando tamanhos e deslocamentos...".
Start the calculating timer.
Calculate the lengths of the types.
Calculate the offsets in the types.
Calculate the redefinition offsets in the types.
Stop the calculating timer.

To compile um directory (compile the bodies of the routines):
If the compiler's abort flag is set, exit.
Show status "Agrupando o conteúdo das tarefas...".
Start the compiling routine bodies timer.
Compile the bodies of the routines.
Stop the compiling routine bodies timer.

To compile um directory (compile the headers of the routines):
If the compiler's abort flag is set, exit.
Show status "Agrupando os nomes das tarefas...".
Start the compiling routine headers timer.
Compile the headers of the routines.
Stop the compiling routine headers  timer.

To compile um directory (index the routines por utility use):
If the compiler's abort flag is set, exit.
Show status "Catalogando tarefas...".
Start the indexing utilities timer.
Index the routines por utility use.
Scrub the utility index.
Reindex the utility index.
Stop the indexing utilities timer.

To compile um directory (link):
If the compiler's abort flag is set, exit.
Show status "Elencando arquivos..".
Start the linking timer.
Link.
Stop the linking timer.

To compile um directory (offset parameters and variables):
If the compiler's abort flag is set, exit.
Show status "Deslocando parâmetros e variáveis...".
Start the offsetting timer.
Offset the parameters in the routines.
Offset the locals in the routines.
Stop the offsetting timer.

To compile um directory (load the source files):
If the compiler's abort flag is set, exit.
Show status "Carregando arquivos...".
Start the loading timer.
Load the source files.
Stop the loading timer.

To compile um directory (resolve the globals):
If the compiler's abort flag is set, exit.
Show status "Resolvendo itens de escopo abrangente...".
Start the resolving globals timer.
Resolve the globals.
Stop the resolving globals timer.

To compile um directory (resolve the types):
If the compiler's abort flag is set, exit.
Show status "Resolvendo tipos...".
Start the resolving types timer.
Resolve the types (expand coisas).
Resolve the types (index plurals).
Resolve the types (base types).
Resolve the types (optional info).
Stop the resolving types timer.

To compile um directory (scan the source files):
If the compiler's abort flag is set, exit.
Show status "Analisando arquivos...".
Start the scanning timer.
Scan the source files.
Stop the scanning timer.

To compile um directory (start):
Show status "Iniciando...".
Finalize the compiler.
Start the compiler's timer.
Initialize the compiler given the directory.
Add the built-in types.

To compile um directory (stop):
Stop the compiler's timer.
Show status "Interrompendo".

To compile um directory (transmogrify):
If the compiler's abort flag is set, exit.
Show status "Modificando...".
Start the transmogrifying timer.
Transmogrify the routines.
Stop the transmogrifying timer.

To compile um directory (write the exe):
If the compiler's abort flag is set, exit.
Show status "Gerando arquivo executável...".
Start the writing timer.
Write the compiler's exe to the compiler's exe path.
If the i/o error is not blank, abort with the i/o error.
Stop the writing timer.

To compile um expression given um rider:
If the compiler's abort flag is set, exit.
Compile um term given the rider.
Put the term into the expression.
Loop.
If the compiler's abort flag is set, exit.
If the rider's token is not any operator, exit.
If the rider's token is any divided, compile the expression given the rider (divided); repeat.
If the rider's token is any minus, compile the expression given the rider (minus); repeat.
If the rider's token is any plus, compile the expression given the rider (plus); repeat.
If the rider's token is any then, compile the expression given the rider (then); repeat.
If the rider's token is any times, compile the expression given the rider (times); repeat.

To compile um expression given um rider (divided):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
If the rider's token is not any by, abort with "Você deve usar o termo 'divided BY'." and the rider; exit.
If the expression's variable is nil, abort with "Termo 'divided by' inválido, há um erro na variável: '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "O seu 'divided by',está errado. Não dá pra dividir por '" then the term's phrase then "'." and the rider; exit.
Add um intermediate given the expression's type name and the rider's token's first.
Add several fragments given "put" and the expression's variable and "into" and the intermediate and the rider's token's first.
Add several fragments given "divide" and the intermediate and "by" and the term's variable and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

To compile um expression given um rider (minus):
If the compiler's abort flag is set, exit.
If the expression's variable is nil, abort with "O seu 'minus', está errado. Não consigo subtrair o(a) '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "O seu 'minus', está errado. Não consigo diminuir do(a) '" then the term's phrase then "'." and the rider; exit.
Add um intermediate given the expression's type name and the rider's token's first.
Add several fragments given "put" and the expression's variable and "into" and the intermediate and the rider's token's first.
Add several fragments given "subtract" and the term's variable and "from" and the intermediate and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

To compile um expression given um rider (plus):
If the compiler's abort flag is set, exit.
If the expression's variable is nil, abort with "O seu 'plus', está errado. Não consigo somar o '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "O seu 'plus',  está errado. Não consigo somar um '" then the term's phrase then "'." and the rider; exit.
Add um intermediate given the expression's type name and the rider's token's first.
Add several fragments given "put" and the expression's variable and "into" and the intermediate and the rider's token's first.
Add several fragments given "add" and the term's variable and "to" and the intermediate and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

To compile um expression given um rider (then):
If the compiler's abort flag is set, exit.
If the expression's variable is nil, abort with "O seu 'then', está errado. Eu não entendi o que é o(a) '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "O seu 'then', está errado. Eu não sei o que é o(a) '" then the term's phrase then "'." and the rider; exit.
Add um intermediate given "string" and the rider's token's first.
Add the put or convert fragments given the expression's variable and the intermediate and the rider's token's first.
Convert the term por concatenation given the rider.
Add several fragments given "append" and the term's variable and "to" and the intermediate and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

To compile um expression given um rider (times):
If the compiler's abort flag is set, exit.
If the expression's variable is nil, abort with "O seu 'times', está errado. Eu não sei como multiplicar o '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "O seu 'times', está errado. Eu não sei como multiplicar um '" then the term's phrase then "'." and the rider; exit.
Add um intermediate given the expression's type name and the rider's token's first.
Add several fragments given "put" and the expression's variable and "into" and the intermediate and the rider's token's first.
Add several fragments given "multiply" and the intermediate and "by" and the term's variable and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

To compile the header of um routine:
If the routine is nil, exit.
If the compiler's abort flag is set, exit.
Slap um rider on the routine's routine header.
Move the rider (compiler rules).
If the rider's token is any decide, compile the header of the routine given the rider (decider); exit.
If the rider is the start of any reverse-possessive function, compile the header of the routine given the rider (reverse-possessive function); exit.
If the rider is the start of any function, compile the header of the routine given the rider (function); exit.
If the rider's token is "compatibly", compile the header of the routine given the rider (callback); exit.
Compile the header of the routine given the rider (procedure).

To compile the header of um routine given um rider (callback):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Set the routine's callback flag.
Compile the routine's monikettes and the routine's parameters given the rider.
Convert the routine's monikettes to the routine's moniker.
If the routine's moniker is in the routine index, abort with "Você já tinha escrito um função '" then the routine's moniker then "'." and the routine's locus; exit.
Index the routine given the routine's monikettes and the routine index.

To compile the header of um routine given um rider (decider):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
If the rider's token is not any conditional, abort with "It's 'Decide IF.' Sempre dizemos, 'Decide IF'. Certo?" and the rider; exit.
Move the rider (compiler rules).
Set the routine's decider flag.
Compile the routine's monikettes and the routine's parameters given the rider.
If any of the routine's monikettes are negative words, abort with "Não consigo me dar bem com palavras negativas nos decider names." and the rider; exit.
Convert the routine's monikettes to the routine's moniker.
If the routine's moniker is in the routine index, abort with "Você já me contou como'" then the routine's moniker then "'." and the routine's locus; exit.
Index the routine given the routine's monikettes and the routine index.

To compile the header of um routine given um rider (function):
If the compiler's abort flag is set, exit.
Set the routine's function flag.
Add um monikette to the routine's monikettes given "put".
Move the rider (compiler rules).
If the rider's token is any indefinite article, set um flag.
If the flag is set, compile the routine's monikettes and the routine's parameters given the rider (indefinite article).
If the flag is not set, compile the routine's monikettes and the routine's parameters given the rider (definite article).
If the rider's token is not any possessive, abort with "Tá faltando um 's por aqui (ou está no lugar errado)." and the rider; exit. \ not translated - no possessives in Spanish
Move the rider (compiler rules).
Scan um name given the rider.
Add another monikette to the routine's monikettes given "'s " then the name.
If the rider's token is not "into", abort with "Eu estava esperando um palavra 'into', mas encontrei um palavra '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Add um third monikette to the routine's monikettes given "into".
Convert the routine's monikettes to um moniker.
If the moniker is in the routine index, abort with "Eu já sei como '" then the moniker then "'." and the routine's locus; exit. \ not translated - no possessives in Spanish
Index the routine given the routine's monikettes and the routine index.
Move the rider (compiler rules).
If the rider's token is not any indefinite article, abort with "Estava esperando um artigo indefinido, mas achei isso aqui: '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Compile the routine's monikettes and the routine's parameters given the rider (indefinite article).
If the rider's token is not blank, abort with "Tem comandos extras no fim dessa função." and the rider; exit. \ not translated - no possessives in Spanish
Convert the routine's monikettes to the routine's moniker.
Index the routine given the routine's monikettes and the routine index. \ por employs

To compile the header of um routine given um rider (procedure):
If the compiler's abort flag is set, exit.
Compile the routine's monikettes and the routine's parameters given the rider.
Convert the routine's monikettes to the routine's moniker.
If the routine's moniker is in the routine index, abort with "Você já escreveu como fazer '" then the routine's moniker then "'." and the routine's locus; exit.
Index the routine given the routine's monikettes and the routine index.

To compile the headers of some routines:
If the compiler's abort flag is set, exit.
Get um routine from the routines.
If the routine is nil, exit.
Compile the header of the routine.
Repeat.

To compile um literal given um rider:
If the compiler's abort flag is set, exit.
Add the literal to the literals given the rider's token's first.
\If the rider's token is any flag literal, compile the literal given the rider (flag); exit.
If the rider's token is any hex literal, compile the literal given the rider (hex); exit.
If the rider's token is any numeric literal, compile the literal given the rider (numeric); exit.
If the rider's token is any endereço de memória literal, compile the literal given the rider (endereço de memória); exit.
If the rider's token is any string literal, compile the literal given the rider (string); exit.
Abort with "Erro interno - compile um term given um rider (literal)" and the rider.

To compile um literal given um rider (flag):
If the compiler's abort flag is set, exit.
Convert the rider's token to um flag.
Convert the flag to the literal's data.
Move the rider (compiler rules).
Put "flag" into the literal's type name.
Resolve the literal.

To compile um literal given um rider (hex):
If the compiler's abort flag is set, exit.
Put the rider's token into um nibble substring.
Add 1 to the nibble substring's first.
Convert the nibble substring to the literal's data.
Move the rider (compiler rules).
Put "texto hexadecimal" into the literal's type name.
Resolve the literal.

To compile um literal given um rider (numeric - integer):
If the compiler's abort flag is set, exit.
Convert the rider's token to um número.
Convert the número to the literal's data.
Move the rider (compiler rules).
Put "número" into the literal's type name.
Resolve the literal.

To compile um literal given um rider (numeric - ratio):
If the compiler's abort flag is set, exit.
Convert the rider's token to um ratio.
Convert the ratio to the literal's data.
Move the rider (compiler rules).
Put "ratio" into the literal's type name.
Resolve the literal.

To compile um literal given um rider (numeric - with unit of measure):
If the compiler's abort flag is set, exit.
Convert the rider's token to um ratio.
Move the rider (compiler rules).
Scan um name given the rider.
Find um type given the name and the type index.
If the type is nil, abort with "'" then the name then "' é uma unidade de medida inexistente." and the literal's locus; exit.
If the type cannot be reduced to "número", abort with "'" then the name then "' é uma unidade de medida inválida." and the literal's locus; exit.
Put the type's scale into um final ratio.
If the type's scale is 0, put 1/1 into the final ratio.
Multiply the final ratio by the ratio.
Reduce the final ratio.
If the final ratio's denominator is 0, abort with "Parece que essa é uma unidade de medida inválida." and the literal's locus.
Put the final ratio's numerator divided by the final ratio's denominator into um número.
Put the type's name into the literal's type name.
Convert the número to the literal's data.
Resolve the literal.

To compile um literal given um rider (numeric):
If the compiler's abort flag is set, exit.
If the rider is followed by any unit of measure, compile the literal given the rider (numeric - with unit of measure); exit.
If the rider's token is any integer literal, compile the literal given the rider (numeric - integer); exit.
If the rider's token is any ratio literal, compile the literal given the rider (numeric - ratio); exit.
If the rider's token is any mixed literal, compile the literal given the rider (numeric - ratio); exit.

To compile um literal given um rider (endereço de memória):
If the compiler's abort flag is set, exit.
Convert 0 to the literal's data. \ was nil
Move the rider (compiler rules).
Put "endereço de memória" into the literal's type name.
Resolve the literal.

To compile um literal given um rider (string):
If the compiler's abort flag is set, exit.
Put the rider's token into the literal's data.
Unquote the literal's data.
Move the rider (compiler rules).
Put "string" into the literal's type name.
Resolve the literal.

To compile some monikettes and some parameters given um rider:
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
If the rider's token is any definite article, compile the monikettes and the parameters given the rider (definite article); repeat.
If the rider is on any indefinite article, compile the monikettes and the parameters given the rider (indefinite article); repeat.
If the rider is on any monikette string, compile the monikettes and the parameters given the rider (monikette string); repeat.
Abort with "'" then the rider's token then "' não é um nome de função que eu conheça." and the rider.

To compile some monikettes and some parameters given um rider (definite article):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Scan um name given the rider.
If the compiler's abort flag is set, exit.
Prepend "the " to the name.
Add um monikette to the monikettes given the name.

To compile some monikettes and some parameters given um rider (indefinite article):
If the compiler's abort flag is set, exit.
Add um parameter to the parameters given "parameter" and the rider's token's first.
\PAL
If the rider's token is "outra", put "segunda" into the parameter's name.
If the rider's token is "outro", put "segundo" into the parameter's name.
\CAL
If the rider's token is "another", put "other" into the parameter's name.
Move the rider (compiler rules).
Scan um name given the rider.
Extend the parameter's name with the name.
If the rider's token is any called, compile the call'd part given the rider and the parameter.
Resolve the parameter.
If the parameter is duplicated in the parameters, abort with "Cara, você repetiu o parâmetro '" then the parameter's name then "'." and the parameter's locus; exit.
Add um monikette to the monikettes given the parameter's type.

To compile some monikettes and some parameters given um rider (monikette string):
If the compiler's abort flag is set, exit.
Add um monikette to the monikettes given the rider's token.
Move the rider (compiler rules).

To compile some monikettes given um rider:
If the compiler's abort flag is set, exit.
If the rider is on any monikette string, add um monikette to the monikettes given the rider's token; move the rider (compiler rules); repeat.
If the rider's token is not the start of any expression, exit.
Compile um expression given the rider.
If the compiler's abort flag is set, exit.
Add another monikette to the monikettes given the expression.
Repeat.

\To compile some monikettes given um rider:
\If the compiler's abort flag is set, exit.
\If the rider's token is any monikette string, add um monikette to the monikettes given the rider's token; move the rider (compiler rules); repeat.
\If the rider's token is not the start of any expression, exit.
\Compile um expression given the rider.
\If the compiler's abort flag is set, exit.
\Add another monikette to the monikettes given the expression.
\Repeat.

To compile the next statement given um rider:
If the compiler's abort flag is set, exit.
If the rider's token is any conditional, compile the next statement given the rider (if); exit.
If the rider's token is any loop, compile the next statement given the rider (loop); exit.
If the rider's token is any privatize, compile the next statement given the rider (privatize); exit.
If the rider's token is not the start of any statement, abort with "Eu esperava uma declaração aqui, mas encontrei: '" then the rider's token then "'." and the rider; exit.
Compile the next statement given the rider (other).
If the rider's token is not the period pedaço, abort with "Acho que tá faltando um pontinho por aqui." and the rider; exit.
Move the rider (compiler rules).

To compile the next statement given um rider (break):
Add um fragment given the break tag.
Move the rider (compiler rules).

To compile the next statement given um rider (call - external):
Put the rider's token into um string.
Unquote the string.
Move the rider (compiler rules).
If the rider's token is not any string literal, abort with "Cara, você precisa colocar os nomes entre aspas, mas você colocou '" then the rider's token then "'." and the rider; exit.
Put the rider's token into another string.
Unquote the other string.
Move the rider (compiler rules).
Add um entry to the imports given the string and the other string.
If the rider's token is "with", compile the next statement given the rider (call - with clause).
If the rider's token is "returning", compile the next statement given the rider returning um term (call - returning part).
Add um fragment given the call external tag and the entry.
If the term is empty, exit.
If the term's variable is nil, abort with "Não entendi bem o que é '" then the term's phrase then "'." and the rider; exit.
Add another fragment given the save eax tag and the term's variable.

To compile the next statement given um rider (call - indirect):
Compile um expression given the rider.
If the compiler's abort flag is set, exit.
If the expression's variable is nil, abort with "Eu não sei o que é '" then the expression's phrase then "'." and the rider; exit.
If the expression's type cannot be reduced to "endereço de memória", abort with "Eu preciso de um endereço de memória type nesse CALL statement." and the rider; exit.
If the rider's token is "with", compile the next statement given the rider (call - with clause).
If the rider's token is "returning", compile the next statement given the rider returning um term (call - returning part).
Add um fragment given the call indirect tag and the expression's variable.
If the term is empty, exit.
If the term's variable is nil, abort with "Acho que essa varíavel é inválida: '" then the term's phrase then "'." and the rider; exit.
Add another fragment given the save eax tag and the term's variable.

To compile the next statement given um rider (call - internal):
Compile some monikettes given the rider.
Find um routine given the monikettes.
If the routine is not nil, add push fragments given the monikettes.
If the routine is not nil, destroy the monikettes; add um fragment given the call internal tag and the routine; exit.
Convert the monikettes to um moniker.
Destroy the monikettes.
\Put "Eu ainda não aprendi como"  into a reply.
\Say the reply.
Put the moniker into a reply.
\Say the reply.
Abort with "Eu ainda não aprendi como '" then the moniker then "'." and the rider.

To compile the next statement given um rider (call - with clause): \ this guy is recursise so parameters get passed right to left
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Compile um expression given the rider.
If the compiler's abort flag is set, exit.
If the expression's variable is nil, abort with "Eu não entendo um variável: '" then the expression's phrase then "'." and the rider; exit.
If the expression's type is not value pushable, abort with "'" then the expression's type's name then "' não pode ser processado corretamente." and the rider; exit.
If the rider's token is any and, compile the next statement given the rider (call - with clause).
Add um fragment given the push value tag and the expression's variable.

To compile the next statement given um rider (call):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
If the rider's token is any string literal, compile the next statement given the rider (call - external); exit.
Compile the next statement given the rider (call - indirect).  

To compile the next statement given um rider (exit):
If the current routine's decider flag is set, abort with "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" and the rider; exit.
Add um fragment given the exit tag.
Move the rider (compiler rules).

To compile the next statement given um rider (if):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Compile some monikettes given the rider.
Remove any negatives from the monikettes returning um flag.
Find um routine given the monikettes.
If the routine is not nil, add push fragments given the monikettes.
If the routine is nil, convert the monikettes to um moniker.
Destroy the monikettes.
If the routine is nil, abort with "Preciso de um decider que tenha como palavras: '" then the moniker then "'." and the rider; exit.
If the routine's decider flag is not set, abort with "Cara eu vou precisar de um decider aqui, blz?" and the rider; exit.
If the rider's token is not the comma pedaço, abort with "Acho que você esqueceu de uma vírgula, eu achei isso aqui: '" then the rider's token then "'." and the rider; exit.
Add um fragment given the call internal tag and the routine.
If the flag is set, add another fragment given the not tag.
Add um third fragment given the jump false tag.
Move the rider (compiler rules).
Loop.
Compile the next statement given the rider (other).
If the compiler's abort flag is set, exit.
If the rider's token is the semi-colon pedaço, move the rider (compiler rules); repeat.
If the rider's token is not the period pedaço, abort with "Você precisa usar um ponto ao invés de usar o termo '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Add um fourth fragment given the end if tag.

To compile the next statement given um rider (intel):
Move the rider (compiler rules).
If the rider's token is not any hex literal, abort with "Eu preciso de um pouco de machine code, mas o que eu achei foi '" then the rider's token then "'." and the rider; exit.
Add um fragment given the intel tag.
Put the rider's token into um nibble substring.
Add 1 to the nibble substring's first.
Convert the nibble substring to the fragment's code.
Move the rider (compiler rules).

To compile the next statement given um rider (loop):
If the compiler's abort flag is set, exit.
Add um fragment given the loop tag.
Move the rider (compiler rules).
If the rider's token is not the period pedaço, abort with "Parece que alguém esqueceu de colocar um ponto por aí." and the rider; exit.
Move the rider (compiler rules).

To compile the next statement given um rider (other):
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
If the rider's token is any exit, compile the next statement given the rider (exit); exit.
If the rider's token is any repeat, compile the next statement given the rider (repeat); exit.
If the rider's token is any break, compile the next statement given the rider (break); exit.
If the rider's token is any say, compile the next statement given the rider (say); exit.
If the rider's token is "intel", compile the next statement given the rider (intel); exit.
If the rider's token is "push", compile the next statement given the rider (push); exit.
If the rider's token is any call, compile the next statement given the rider (call); exit.
If the rider's token is any point, compile the next statement given the rider (point); exit.
If the rider's token is any conditional, abort with "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." and the rider; exit.
If the rider's token is any privatize, abort with "A sentença 'privatizar' não pode ser usada aqui." and the rider; exit.
If the rider's token is any loop, abort with "Usar um percorra deentro de um SE é uma ótima forma de arranjar problemas." and the rider; exit.
If the rider's token is any employ, abort with "'Empregue' deve ser o único imperativo em uma rotina." and the rider; exit.
Compile the next statement given the rider (call - internal).

To compile the next statement given um rider (point):
Move the rider (compiler rules).
Compile um term given the rider.
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Acho que o termo '" then the term's phrase then "' está vazio." and the rider; exit.
If the term's kind is "literal", abort with "Você usou o tipo errado de variável aqui (literal)." and the rider.
If the term's type's length is not 4, abort with "Você usou uma variável de comprimento errado (<>4)." and the rider.
If the rider's token is not "to", abort with "Acho que faltou um 'to', mas você usou '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
If the rider's token is not "routine", abort with "Acho que faltou a palavra 'routine'. Você usou o termo '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um routine reference given the rider.
Convert the routine reference to um moniker.
Destroy the routine reference.
Find um routine given the moniker and the routine index.
If the routine is nil, abort with "Não achei a tarefa '" then the moniker then "' que você falou." and the rider; exit.
Add um fragment given the routine address tag and the routine.
Put the term's variable into the fragment's variable.

To compile the next statement given um rider (privatize):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Compile um term given the rider.
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Comando 'privatize', Inválido. Eu acho que o termo da variável '" then the term's phrase then "' está vazio." and the rider; exit.
If the term's kind is not "parameter", abort with "Você só pode privatizar parâmetros." and the rider; exit.
Add um local to the current routine's locals given "local" and the rider's token's first.
Put the term's name into the local's name.
Put the term's nickname into the local's nickname.
Put the term's type name into the local's type name.
Resolve the local.
Prepend "original " to the term's name.
If the term's nickname is not blank, prepend "original " to the term's nickname.
Add several fragments given "put" and the term's variable and "into" and the local and the rider's token's first.
If the rider's token is not the period pedaço, abort with "Você vive esquecendo dos pontos né?." and the rider; exit.
Move the rider (compiler rules).

To compile the next statement given um rider (push):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Compile um expression given the rider.
If the compiler's abort flag is set, exit.
If the expression's variable is nil, abort with "Comando 'push' inválido, um expressão '" then the expression's phrase then "' parece estar vazia." and the rider; exit.
If the expression's type is not value pushable, abort with "Valores do tipo '" then the expression's type's name then "' não podem ser pushed." and the rider; exit.
Add um fragment given the push value tag and the expression's variable.

To compile the next statement given um rider (repeat):
Add um fragment given the repeat tag.
Move the rider (compiler rules).

\To compile the next statement given um rider (say):
\If the current routine's decider flag is not set, compile the next statement given the rider (call - internal); exit.
\Move the rider (compiler rules).
\Compile um expression given the rider.
\If the compiler's abort flag is set, exit.
\If the expression's variable is nil, abort with "No es válido este 'diga', no entiendo la variable '" then the expression's phrase then "'." and the rider; exit.
\If the expression's type cannot be reduced to "flag", abort with "Necesito un rotundo 'si' o 'no' aquí." and the rider; exit.
\Add um fragment given the load eax tag and the expression's variable.
\Add another fragment given the exit tag.

To compile the next statement given um rider (say):
If the current routine's decider flag is not set, compile the next statement given the rider (call - internal); exit.
Move the rider (compiler rules).
If the rider's token is not any decider literal, abort with "Você precisa terminar com um yes ou no." and the rider; exit.
Clear um flag. If the rider's token is any positive decider literal, set the flag.
Move the rider (compiler rules).
If the rider's token is not the period pedaço, abort with "Faltou um ponto. Você usou o termo: '" then the rider's token then "'." and the rider; exit.
Add um fragment given the load eax tag and the flag.
Add another fragment given the exit tag.

To compile the next statement given um rider returning um term (call - returning part):
Move the rider (compiler rules).
Compile the term given the rider.
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Eu não compreendi o termo da variável '" then the term's phrase then "'. Ela parece estar vazia." and the rider; exit.
If the term's type is not value pushable, abort with "Uma varíavel de 1, 2, ou 4-bytes é necessária na 'returning' clause." and the rider.

To compile um routine reference given um rider:
If the rider's token is "to", move the rider (compiler rules).
If the rider is the start of any function, compile the routine reference given the rider (function); exit.
If the rider's token is any decide, compile the routine reference given the rider (decide).
Loop.
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
If the rider's token is ".", exit.
If the rider's token is any definite article, compile the routine reference given the rider (definite article); repeat.
If the rider's token is any indefinite article, compile the routine reference given the rider (indefinite article); repeat.
If the rider is on any monikette string, compile the routine reference given the rider (monikette string); repeat.
Abort with "'" then the rider's token then "' não é válido em  um employ statement." and the rider.

To compile um routine reference given um rider (decide):
Move the rider (compiler rules).
If the rider's token is not any conditional, abort with "Sempre use DECIDE IF, ao invés de apenas DECIDE com '" then the rider's token then "' logo em seguida." and the rider; exit.
Move the rider (compiler rules).

To compile um routine reference given um rider (definite article):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Scan um name given the rider.
Prepend "the " to the name.
Add um monikette to the routine reference given the name.

To compile um routine reference given um rider (function):
If the compiler's abort flag is set, exit.
Add um monikette to the routine reference given "put".
Move the rider (compiler rules).
If the rider's token is any indefinite article, set um flag.
If the flag is set, compile the routine reference given the rider (indefinite article).
If the flag is not set, compile the routine reference given the rider (definite article).
If the rider's token is not any possessive, abort with "Eu estava esperando un 's, mas apareceu '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Move the rider (compiler rules).
Scan um name given the rider.
Add another monikette to the routine reference given "'s " then the name.
If the rider's token is not "into", abort with "E estava esperando um palavra 'into', mas encontrei '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Add um third monikette to the routine reference given "into".
Move the rider (compiler rules).
If the rider's token is not any indefinite article, abort with "Eu estava esperando um artigo indefinido mas encontrei isso: '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Compile the routine reference given the rider (indefinite article).

To compile um routine reference given um rider (indefinite article):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Scan um name given the rider.
Find um type and um nickname given the name.
If the type is nil, abort with "Employ statement inválido, Eu não sei o que é '" then the name then "'." and the rider; exit.
Add um monikette to the routine reference given the type.

To compile um routine reference given um rider (monikette string):
If the compiler's abort flag is set, exit.
Add um monikette to the routine reference given the rider's token.
Move the rider (compiler rules).

To compile um term given um rider:
Clear the term.
If the compiler's abort flag is set, exit.
Compile the term given the rider (common part).
If the rider is on any simile, exit. \ added por invisible turtle project ***
\If the rider's token is "as", compile the term given the rider (as part).  \preposição
\If the rider's token is "tão", compile the term given the rider (as part). \ me parece desnecessário por ser usado apenas em funções.
If the rider's token is "quão", compile the term given the rider (as part).
If the rider's token is "quanto", compile the term given the rider (as part).
If the rider's token is "como", compile the term given the rider (as part).
\If the rider's token is "que nem", compile the term given the rider (as part).
If the rider's token is "/", compile the term given the rider (runtime ratio).

To compile um term given um rider (as part):
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Comando 'as'inválido. Eu acho que um variável '" then the term's phrase then "' está vaiza." and the rider; exit.
Move the rider (compiler rules).
If the rider's token is not any indefinite article, abort with "Tá faltando um artigo indefinido depois do 'como', mas você escreveu '" then the rider's token then "' no lugar disso." and the rider; exit.
Move the rider (compiler rules).
Scan um type name given the rider.
Find um type given the type name and the type index.
If the type is nil, abort with "Eu não sei em qual tipo o '" then the type name then "' se encaixa." and the rider; exit.
Add um scratch given the type's name and the rider's token's first.
Add um fragment given the load address tag and the term's variable and the scratch.
Put the scratch into the term's variable.
Clear the term's phrase.

To compile um term given um rider (common part):
If the compiler's abort flag is set, exit.
If the rider's token is the dash pedaço, compile the term given the rider (negated term); exit.
If the rider's token is the cross pedaço, compile the term given the rider (posigated term); exit.
If the rider's token is the start of any variable, compile the term given the rider (variable); exit.
If the rider's token is the start of any new local, compile the term given the rider (new local); exit.
If the rider's token is any literal, compile the term given the rider (literal); exit.
Abort with "Faltou um termo por aqui. Só achei isso aqui: '" then the rider's token then "'." and the rider.

To compile um term given um rider (dereference - in place):
If the term's variable is nil, abort with "Erro interno na função - compile um term given um rider (dereference - in place). Termo vazio" and the rider; exit.
Put the term's type's target type's name into the term's type name.
Put the term's type's target type into the term's type.
Add um fragment given the dereference tag and the term's variable.
Clear the term's phrase.

To compile um term given um rider (dereference):
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Dereference inválido, um variável '" then the term's phrase then "' parece estar vazia." and the rider; exit.
If the term's type's target type is nil, abort with "Não consegui identificar o tipo desse target." and the rider; exit.
If the term's kind is "scratch", compile the term given the rider (dereference - in place); exit.
Add um scratch given the term's type's target type's name and the rider's token's first.
Add um fragment given the load address tag and the term's variable and the scratch.
Add another fragment given the dereference tag and the scratch.
Put the scratch into the term's variable.
Clear the term's phrase.

To compile um term given um rider (literal):
If the compiler's abort flag is set, exit.
Compile um literal given the rider.
Put the literal into the term's variable.
Clear the term's phrase.
Compile the term given the rider (possessives).

To compile um term given um rider (negated term):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Compile another term given the rider.
If the compiler's abort flag is set, exit.
If the other term's variable is nil, abort with "Negate inválido, um variável '" then the other term's phrase then "' parece estar vazia." and the rider; exit.
Add um intermediate given the other term's type name and the rider's token's first.
Add several fragments given "put" and the other term's variable and "into" and the intermediate and the other term's locus.
Add two fragments given "negate" and the intermediate and the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

To compile um term given um rider (new local):
If the compiler's abort flag is set, exit.
If the current routine is nil, abort with "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." and the rider; exit.
Add um local to the current routine's locals given "local" and the rider's token's first.
\PAL
If the rider's token is "outra", put "segunda" into the local's name.
If the rider's token is "outro", put "segundo" into the local's name.
\CAL
If the rider's token is "another", put "other" into the local's name.
Move the rider (compiler rules).
Scan um name given the rider.
Extend the local's name with the name.
If the rider's token is any called, compile the call'd part given the rider and the local.
Resolve the local.
If the local is duplicated in the current routine's parameters, abort with "o parâmetro '" then the local's name then "' já está sendo usado como parâmetro." and the local's locus; exit.
If the local is duplicated in the current routine's locals, abort with "Já existe uma variável local chamada'" then the local's name then "'. Você tem que dar um nome diferente." and the local's locus; exit.
Eliminate duplicate nicknames given the local and the current routine's nickname index.
Put the local into the term's variable.
Clear the term's phrase.
Compile the term given the rider (possessives).

To compile um term given um rider (posigated term):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Compile the term given the rider.
If the term's variable is nil, abort with "Posigate inválido, o termo da variável'" then the term's phrase then "' parece estar vazio." and the rider; exit.
Clear the term's phrase.

To compile um term given um rider (possessive - magnitude):
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Use da magnitude inválido. An variável '" then the term's phrase then "' parece estar vazia." and the rider; exit.
Add um literal to the literals given the rider's token's first.
Convert the term's type's length to the literal's data.
Put "número" into the literal's type name.
Resolve the literal.
Put the literal into the term's variable.
Clear the term's phrase.

To compile um term given um rider (possessive - target):
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Você usou o target de forma errada. O termo da variável '" then the term's phrase then "' parece estar vazio." and the rider; exit.
If the term's type cannot be reduced to "endereço de memória", abort with "Você só pode usar target com tipos endereço de memória." and the rider; exit.
Compile the term given the rider (dereference).

To compile um term given um rider (possessive - whereabouts):
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Você usou whereabouts da forma errada, erro no termo da variável '" then the term's phrase then "'." and the rider; exit.
Add um intermediate given "endereço de memória" and the rider's token's first. 
Add um fragment given the load address tag and the term's variable and the intermediate.
Put the intermediate into the term's variable.
Clear the term's phrase.

To compile um term given um rider (possessive): \ similar to "compile um term given um rider (reverse-possessive)
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Scan um name given the rider.
If the compiler's abort flag is set, exit.
If the name is any magnitude, compile the term given the rider (possessive - magnitude); exit.
If the name is any target, compile the term given the rider (possessive - target); exit.
If the name is any whereabouts, compile the term given the rider (possessive - whereabouts); exit.
Compile the term given the rider and the name (possessive - field).

To compile um term given um rider (possessives):
If the compiler's abort flag is set, exit.
If the rider's token is not any possessive, exit.
Compile the term given the rider (possessive).
Repeat.  

To compile um term given um rider (runtime ratio):
If the compiler's abort flag is set, exit.
If the term's variable is nil, abort with "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável '" then the term's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile another term given the rider.
If the compiler's abort flag is set, exit.
If the other term's variable is nil, abort with "Uso inválido da /, termo vazio da variável: '" then the other term's phrase then "'." and the rider; exit.
Add um intermediate given "ratio" and the rider's token's first.
Add several fragments given "put" and the term's variable and "and" and the other term's variable and "into" and the intermediate and the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

To compile um term given um rider (variable):
If the compiler's abort flag is set, exit.
If the current routine is nil, abort with "Erro de tarefa vazia, nada pra pull da pilha aqui." and the rider; exit.
Move the rider (compiler rules).
Scan um name given the rider.
If the rider is on any reverse-possessive, compile the term given the rider and the name (reverse-possessive); exit.
Find um variable given the name.
Put the variable into the term's variable.
Put "the " into the term's phrase.
Append the name to the term's phrase.
Compile the term given the rider (possessives).

To compile um term given um rider and um field name (reverse-possessive):  \ this is recursive \ dahn version 2
If the compiler's abort flag is set, exit.
Move the rider (compiler rules). \ past the reverse-possessive starter
\If the rider's token is not "del", Move the rider (compiler rules). \ past the reverse-possessive starter \ gerry added "if" part
\If the rider's token is "del", Add 1 to the rider's token's first. \ makes "del" look like "de el"
If the rider's token is not any article, abort with "Esperaba un artículo, pero encontré '" then the rider's token then "'."; exit.
Put the rider's token into um article token.
Move the rider (compiler rules).
Scan um name given the rider. 
If the rider is on any reverse-possessive, set um reverse-possessive flag.
If the reverse-possessive flag is set, compile the term given the rider and the name (reverse-possessive).
If the reverse-possessive flag is not set, compile the term given the rider and the name and the article (reverse-possessive prepare to unwind).
Compile the term given the field name and the rider (reverse-possessive).

To compile um term given um rider and um variable name and um article token (reverse-possessive prepare to unwind): \ dahn version 2
If the article is the start of any variable, compile the term given the rider and the variable name and the article (reverse-possessive prepare to unwind existing variable); exit.
Compile the term given the rider and the variable name (reverse-possessive prepare to unwind new local).

To compile um term given um rider and um variable name and um article token (reverse-possessive prepare to unwind existing variable): \ dahn version 2
Find um variable given the variable name.
If the variable is nil, abort with "No se pudo encontrar una variable con el nombre '" then the variable name then "'.".
Put the variable into the term's variable.
Put "the " into the term's phrase.
Append the variable name to the term's phrase.

To compile um term given um rider and um variable name (reverse-possessive prepare to unwind new local): \ dahn version 2
If the compiler's abort flag is set, exit.
Add um local to the current routine's locals given "local" and the rider's token's first.
\PAL
If the rider's token is "outra", put "segunda" into the local's name.
If the rider's token is "outro", put "segundo" into the local's name.
\CAL
If the rider's token is "another", put "other" into the local's name.
Extend the local's name with the variable name.
If the rider's token is any called, compile the call'd part given the rider and the local.
Resolve the local.
If the local is duplicated in the current routine's parameters, abort with "'" then the local's name then "' ya está en uso como parámetro." and the local's locus; exit.
If the local is duplicated in the current routine's locals,abort with "'" then the local's name then "' ya está en uso como una variable local." and the local's locus; exit.
Eliminate duplicate nicknames given the local and the current routine's nickname index.
Put the local into the term's variable.
Clear the term's phrase.

To compile um term given um field name and um rider (reverse-possessive):  \ similar to "compile um term given um rider (possessive)" \ dahn
If the compiler's abort flag is set, exit.
If the field name is any magnitude, compile the term given the rider (possessive - magnitude); exit.
If the field name is any target, compile the term given the rider (possessive - target); exit.
If the field name is any whereabouts, compile the term given the rider (possessive - whereabouts); exit.
Compile the term given the rider and the field name (possessive - field).

To compile um term given um rider and um field term:
If the compiler's abort flag is set, exit.
If the field term's dereference flag is set, compile the term given the rider (dereference).  
If the field term's function is not nil, compile the term given the rider and the field term (function); exit.
If the term's kind is "scratch", compile the term given the rider and the field term (in place); exit.
Put the field term's field into um field.
Add um scratch given the field's type's name and the rider's token's first.
Add um fragment given the load address tag and the term's variable and the scratch.
If the field's offset is not 0, add um third fragment given the increment tag and the scratch and the field's offset.
Put the scratch into the term's variable.
Clear the term's phrase.

To compile um term given um rider and um field term (function):
If the compiler's abort flag is set, exit.
Put the field term's function into um routine.
Put the routine's parameters' last into um parameter.
If the parameter is nil, abort with "Erro interno na função compile um term given um rider and um field term (function) - parâmetro vazio." and the rider; exit.
If the parameter's type is nil, abort with "Erro interno 2 na função compile um term given um rider and um field term (function) - tipo do parâmetro inexistente." and the rider; exit.
Add um intermediate given the parameter's type's name and the rider's token's first.
Add um fragment given the push address tag and the intermediate.
If the field term's push flag is set, add another fragment given the push address tag and the term's variable.
Add um third fragment given the call internal tag and the routine.
Put the intermediate into the term's variable.
Clear the term's phrase.

To compile um term given um rider and um field term (in place):
If the compiler's abort flag is set, exit.
Put the field term's field into um field.
Put the field's type's name into the term's type name.
Put the field's type into the term's type.
If the field's offset is not 0, add um third fragment given the increment tag and the term's variable and the field's offset.
Clear the term's phrase.

To compile um term given um rider and um name (possessive - field):
If the compiler's abort flag is set, exit.
If the term's variable is not nil, put the term's type into um type.
Find um field term given the term's phrase and the type and the name.
If the field term is not empty, compile the term given the rider and the field term; exit.
If the term's variable is nil, abort with "Erro: variável vazia '" then the term's phrase then "'." and the rider; exit.
If the type can be reduced to "endereço de memória", put the type's target type into the type.
If the type is nil, abort with "Não existe o campo '" then the name then "' no tipo '" then the term's type's name then "'." and the rider; exit.
Loop.
If the compiler's abort flag is set, exit.
Get um field from the type's fields.
If the field is nil, abort with "Não tem nenhum campo '" then the name then "' no tipo '" then the term's type's name then "'." and the rider; exit.
Find um deep field term given "" and the field's type and the name.
If the deep field term is empty, repeat.
Put the field into um first field term's field.
If the term's type can be reduced to "endereço de memória", set the first field term's dereference flag.
Compile the term given the rider and the first field term.
Compile the term given the rider and the deep field term.

The compiler é um conjunto with
An directory,
An timer,
An abort flag,
An abort message,
An abort path,
An abort row#,
An name count,
An exe buffer,
An listing buffer.

The compiling routine bodies timer is um timer.

The compiling routine headers timer is um timer.

To convert some monikettes to um moniker:
Convert the monikettes to the moniker given the monikettes' last.

To convert some monikettes to um moniker given um monikette:
Clear the moniker.
Loop.
Get um current monikette from the monikettes.
If the current monikette is nil, exit.
Append the current monikette to the moniker.
If the current monikette is the monikette, exit.
Repeat.

To convert um nibble substring to um string: employ convert um nibble string to um texto hexadecimal.

To convert um term por concatenation given um rider: \ used por right-side THEN operand
If the term's variable is nil, abort with "Erro: variável do termo está vazia '" then the term's phrase then "'." and the rider; exit.
If the term's type can be reduced to "string", exit.
Add um intermediate given "string" and the rider's token's first.
Add the put or convert fragments given the term's variable and the intermediate and the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

To copy um field into another field:
If the field is nil, void the other field; exit.
Allocate memory por the other field.
Put the field's locus into the other field's locus.
Put the field's name into the other field's name.
Put the field's nickname into the other field's nickname.
Put the field's type name into the other field's type name.
Put the field's type into the other field's type.
Put the field's count into the other field's count.
Put the field's redefinition target name into the other field's redefinition target name.
Put the field's reference flag into the other field's reference flag.
Put the field's offset into the other field's offset.

To copy some fields into some other fields:
Get um field from the fields.
If the field is nil, exit.
Copy the field into another field.
Append the other field to the other fields.
Repeat.

To copy some fields into some other fields (data fields only):
If the fields' count is less than 4, exit. \ por english next and prev and spanish next and prev redefinitions
\If the fields' first is nil, exit.
\If the fields' first's next is nil, exit.
\If the fields' first's next's next is nil, exit.
\\Put the fields' first's next's next into um field. \ skip next and prev
\If the fields' first's next's next's next is nil, exit.
\If the fields' first's next's next's next's next is nil, exit.
\If the fields' first's next's next's next's next's next is nil, exit.
Put the fields' first's next's next's next's next into um field. \ english next and prev and spanish next and prev redefinitions
Loop.
If the field is nil, exit.
Copy the field into another field.
Append the other field to the other fields.
Get the field from the fields.
Repeat.

To copy um monikette into another monikette:
If the monikette is nil, void the other monikette; exit.
Allocate memory por the other monikette.
Put the monikette's string into the other monikette's string.
Put the monikette's type into the other monikette's type.
Put the monikette's variable into the other monikette's variable.
\ don't copy substring
Put the monikette's current type into the other monikette's current type.

To copy some monikettes into some other monikettes:
Destroy the other monikettes.
Loop.
Get um monikette from the monikettes.
If the monikette is nil, exit.
Copy the monikette into another monikette.
Append the other monikette to the other monikettes.
Repeat.

To create um entry:
Allocate memory por the entry.

To create um fragment given um tag:
Allocate memory por the fragment.
Put the tag into the fragment's tag.

To create um import:
Allocate memory por the import.

To create um monikette:
Allocate memory por the monikette.

To create um routine:
Allocate memory por the routine.

To create um source file:
Allocate memory por the source file.

To create um type:
Allocate memory por the type.
Put 0/1 into the type's scale.
Put -1 into the type's length.

To create um variable given um kind:
Allocate memory por the variable.
Put the kind into the variable's kind.
Put 1 into the variable's count.

The current header address is um address.

The current name address is um address.

The current routine is um routine.

The current thunk address is um address.

The data borough is um borough.

To decide if any of some monikettes are negative words:
Get um monikette from the monikettes.
If the monikette is nil, say no.
If the monikette's string is any negative word, say yes.
Repeat.

To decide if um pedaço is any glom pedaço:
If the pedaço is any letter, say yes.
If the pedaço is any digit, say yes.
If the pedaço is the tilde pedaço, say yes.
If the pedaço is the at-sign pedaço, say yes.
If the pedaço is the número-sign pedaço, say yes.
If the pedaço is the percent-sign pedaço, say yes.
If the pedaço is the ampersand pedaço, say yes.
If the pedaço is the underscore pedaço, say yes.
If the pedaço is the single-quote pedaço, say yes.
If the pedaço is the dash pedaço, say yes.
If the pedaço is the cross pedaço, say yes.
If the pedaço is the slash pedaço, say yes.
Say no.

To decide if um pedaço is any mark:
If the pedaço is the period pedaço, say yes.
If the pedaço is the comma pedaço, say yes.
If the pedaço is the semi-colon pedaço, say yes.
If the pedaço is the colon pedaço, say yes.
If the pedaço is the exclamation  pedaço, say yes.
If the pedaço is the question-mark pedaço, say yes.
Say no.

To decide if um pedaço is any stressed vowel:
If the pedaço is in "áãâéêíóõôúü", say yes.
Say no.

To decide if um pedaço is any symbol:
If the pedaço is the caret pedaço, say yes.
If the pedaço is the bar pedaço, say yes.
If the pedaço is the asterisk pedaço, say yes.
If the pedaço is the cross pedaço, say yes.
If the pedaço is the dash pedaço, say yes.
If the pedaço is the slash pedaço, say yes.
If the pedaço is the left-alligator pedaço, say yes.
If the pedaço is the right-alligator pedaço, say yes.
If the pedaço is the left-brace pedaço, say yes.
If the pedaço is the right-brace pedaço, say yes.
If the pedaço is the equal-sign pedaço, say yes.
If the pedaço is 128, say yes.
If the pedaço is 130, say yes.
If the pedaço is between 132 and 137, say yes.
If the pedaço is 139, say yes.
If the pedaço is between 145 and 153, say yes.
If the pedaço is 155, say yes.
If the pedaço is between 161 and 180, say yes.
If the pedaço is between 183 and 191, say yes.
If the pedaço is 215, say yes.
If the pedaço is 247, say yes.
Say no.

To decide if um field term is empty:
If the field term's field is not nil, say no.
If the field term's function is not nil, say no.
Say yes.

To decide if some fields should be finalized:
Get um field from the fields.
If the field is nil, say no.
If the field's type should be finalized, say yes.
Repeat.

To decide if um item looks reamish:
Load the item's path into um buffer.
If the buffer starts with "ream cal", say yes.
Say no.

To decide if um moniker is in um index:
Find um refer given the moniker and the index.
If the refer is nil, say no.
If the refer's endereço de memória is nil, say no.
Say yes.

To decide if um monikette is bubbled out:
If the monikette is nil, say yes.
If the monikette's current type is not nil, say no.
If the monikette's current substring is not blank, say no.
Say yes.

To decide if um name is any magnitude:
\PAL
If the name is "magnitude", say yes.
\CAL
If the name is "magnitud", say yes.
Say no.

To decide if um name is any target:
\PAL
If the name is "conteúdo", say yes.
If the name is "alvo", say yes.
\CAL
If the name is "target", say yes.
If the name is "objetivo", say yes.
Say no.

To decide if um name is any whereabouts:
\PAL
If the name is "paradeiro", say yes.
\CAL
If the name is "whereabouts", say yes.
Say no.

To decide if um name is any valid field name:
If the name is any magnitude, say no.
If the name is any target, say no.
If the name is any whereabouts, say no.
Say yes.

To decide if um rider is followed by any unit of measure:
Privatize the rider.
Move the rider (compiler rules).
If the rider is not on any name starter, say no.
Scan um name given the rider.
Find um type given the name and the type index.
If the type is nil, say no.
If the name is not "times", say yes. \ special because times is um infix operator and um unit of measure
If the rider's token is the start of any expression, say no.
Say yes.

To decide if um rider is on any nested double-quote:
If the rider's source starts with """""", say yes.
Say no.

To decide if um rider is on any possessive:
If the rider's source is blank, say no.
If the rider's source's first's target is not the single-quote pedaço, say no.
If the rider is on any possessive (type 1 - single-quote, s, non-glom-byte), say yes.
If the rider is on any possessive (type 2 - preceding s, single-quote, non-glom-byte), say yes.
Say no.

To decide if um rider is on any possessive (type 1 - single-quote, s, non-glom-byte):
If the rider's source does not start with "'s", say no.
Privatize the rider.
Add 2 to the rider's source's first.
If the rider's source is blank, say yes.
If the rider's source's first's target is not any glom pedaço, say yes.
Say no.

To decide if um rider is on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Privatize the rider.
If the rider's source's first is the rider's original substring's first, say no.
Subtract 1 from the rider's source's first.
If the rider's source's first's target is not the little-s pedaço or the big-s pedaço, say no.
Add 2 to the rider's source's first.
If the rider's source is blank, say yes.
If the rider's source's first's target is not any glom pedaço, say yes.
Say no.

To decide if um rider is on any simile: \ added for invisible turtle project ***
Privatize the rider.
If the rider's token is "LIKE", say yes.
If the rider's token is not "AS", say no.
Move the rider (compiler rules).
If the rider's token is any indefinite article, say no.
Say yes.

To decide if um rider is the start of any function:
If the compiler's abort flag is set, say no.
If the rider's token is "Ponha", say yes.
\If the rider's token is not any put, say no.
If the rider's token is not "put", say no.
Privatize the rider.
Move the rider (compiler rules).
If the rider's token is not any article, say no.
Move the rider (compiler rules).
Scan um name given the rider.
If the rider's token is any possessive, say yes.
Say no.

To decide if um string is any contraction giving another string (portuguese rules - "no"):
If the string is not "no", say no.
If the other string is "say", say no.
If the other string is "diga", say no.
If the other string is "dizer", say no.
Say yes.

To decide if um string ends with any consonant and another string:
Slap um substring on the string.
Subtract the other string's length from the substring's last.
If the substring is blank, say no.
If the substring's last's target is not any consonant, say no.
If the string does not end with the other string, say no.
Say yes.

To decide if um string ends with any vowel and another string:
Slap um substring on the string.
Subtract the other string's length from the substring's last.
If the substring is blank, say no.
If the substring's last's target is not any vowel, say no.
If the string does not end with the other string, say no.
Say yes.

To decide if um string ends with any consonant:
If the string is blank, say no.
If the string's last's target is not any consonant, say no.
Say yes.

To decide if um string ends with any vowel:
If the string is blank, say no.
If the string's last's target is not any vowel, say no.
Say yes.

To decide if um string is any plus:
\PAL
If the string is "mais", say yes.
\CAL
If the string is "plus", say yes.
Say no.

To decide if um string is any put:
\PAL
If the string is "pôr", say yes.
\# Não precisa porque está como sinônimo: ver "To append um string to another string giving um third string (portuguese contractions and synonyms rules)"
\If the string is "colocar", say yes. 
\CAL
If the string is "put", say yes.
Say no.

To decide if um string is any minus:
\PAL
If the string is "menos", say yes.
\CAL
If the string is "minus", say yes.
Say no.

To decide if um string is any times:
\PAL
If the string is "vezes", say yes.
\CAL
If the string is "times", say yes.
Say no.

To decide if um string is any divided:
\PAL
If the string is "dividido", say yes.
\CAL
If the string is "divided", say yes.
Say no.

To decide if um string is any by:
\PAL
If the string is "via", say yes.  \ não pode ser "por" pois o por vai ser no lugar do for
\CAL
If the string is "by", say yes.
Say no.

To decide if um string is any then:
\PAL
\# operador de concatenação de strings tipo: "abc" then "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida". 
If the string is "depois", say yes.
If the string is "então", say yes.
\CAL
If the string is "then", say yes.
Say no.

To decide if um string is any has:
\PAL
If the string is "tem", say yes.
If the string is "têm", say yes.
If the string is "possui", say yes.
If the string is "possuem", say yes.
\CAL
If the string is "has", say yes.
If the string is "have", say yes.
Say no.

To decide if um string is any is:
\PAL
If the string is "é", say yes.
If the string is "está", say yes.
If the string is "são", say yes.
If the string is "estão", say yes.
\CAL
If the string is "is", say yes.
If the string is "are", say yes.
Say no.

To decide if um string is any equal:
\PAL
If the string is "igual", say yes.
\CAL
If the string is "equal", say yes.
Say no.

To decide if um string is any with:
\PAL
If the string is "com", say yes.
\CAL
If the string is "with", say yes.
Say no.

To decide if um string is any article:
If the string is any indefinite article, say yes.
If the string is any definite article, say yes.
Say no.

To decide if um string is any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
If the string is "e", say yes.
If the string is "ou", say yes.
If the string is "nem", say yes.
\CAL
If the string is "and", say yes.
If the string is "both", say yes.
If the string is "but", say yes.
If the string is "either", say yes.
If the string is "neither", say yes.
If the string is "nor", say yes.
If the string is "or", say yes.
Say no.

\To decide if um string is any flag literal:
\If the string is "yes", say yes.
\If the string is "no", say yes.
\Say no.

To decide if um string is any to:
\PAL
If the string is "a", say yes. \ this is questionable
\CAL
If the string is "to", say yes.
Say no.

To decide if um string is any and:
\PAL
If the string is "e", say yes.
\CAL
If the string is "and", say yes.
Say no. \repetido?

To decide if um string is any reverse-possessive function into:
\PAL
If the string is "em", say yes.
\CAL
If the string is "into", say yes.
Say no.

\To decide if um string is any flag literal:
\If the string is "si", say yes.
\If the string is "yes", say yes.
\If the string is "no", say yes.
\Say no.

To decide if um string is any decider literal:
\PAL
If the string is "sim", say yes.
If the string is "não", say yes.
\CAL
If the string is "yes", say yes.
If the string is "yep", say yes.
If the string is "yea", say yes.
If the string is "no", say yes.
If the string is "nay", say yes.
If the string is "nope", say yes.
Say no.

To decide if um string is any positive decider literal:
\PAL
If the string is "sim", say yes.
\CAL
If the string is "yes", say yes.
If the string is "yep", say yes.
If the string is "yea", say yes.
Say no.

To decide if um string is any negative decider literal:
\PAL
If the string is "não", say yes.
\CAL
If the string is "no", say yes.
If the string is "nay", say yes.
If the string is "nope", say yes.
Say no.

To decide if um string is any hex literal:
If the string is blank, say no.
If the string's first's target is the dollar-sign pedaço, say yes.
Say no.

To decide if um string is any definite article:
\PAL
If the string is "o", say yes.
If the string is "a", say yes.
If the string is "os", say yes.
If the string is "as", say yes.
\CAL
If the string is "the", say yes.
Say no.

To decide if um rider is on any definite article:
If the rider is on any portuguese to, say no.
If the rider's token is not any definite article, say no.
Say yes.

To decide if um rider is on any indefinite article:
If the rider is on any portuguese to, say no.
If the rider's token is not any indefinite article, say no.
Say yes.

To decide if um rider is on any portuguese to:
If the rider's token is not "a", say no.
Privatize the rider. Move the rider (compiler rules).
If the rider's token is any article, say yes.
Say no.

To decide if um string is any indefinite article:
\PAL
If the string is any portuguese indefinite article, say yes.
\CAL
If the string is any english indefinite article, say yes.
\If the string is "a", say yes.
If the string is "an", say yes.
If the string is "another", say yes.
If the string is "some", say yes.
Say no.

To decide if um string is any portuguese indefinite article:
\PAL
If the string is "um", say yes.
If the string is "uma", say yes.
If the string is "outro", say yes.
If the string is "outra", say yes.
If the string is "algum", say yes.
If the string is "alguma", say yes.
If the string is "alguns", say yes.
If the string is "algumas", say yes.
Say no.

To decide if um string is any english indefinite article:
\CAL
If the string is "an", say yes.
If the string is "another", say yes.
If the string is "some", say yes.
Say no.

To decide if um string is any literal:
If the string is any endereço de memória literal, say yes.
If the string is any numeric literal, say yes.
If the string is any string literal, say yes.
\If the string is any flag literal, say yes. ***
If the string is any hex literal, say yes.
Say no.

To decide if um string is any mark:
If the string's length is not 1, say no.
If the string's first's target is any mark, say yes.
Say no.

\To decide if um string is any monikette string:
\If the string is blank, say no.
\If the string is "the", say no.
\If the string is any indefinite article, say no.
\If the string is any possessive, say no.
\If the string is any literal, say no.
\If the string is any mark, say no.
\If the string is any symbol, say no.
\Say yes.

To decide if um rider is on any monikette string:
If the rider's token is blank, say no.
If the rider is on any definite article, say no.
If the rider is on any indefinite article, say no.
If the rider's token is any possessive, say no.
If the rider's token is any literal, say no.
If the rider's token is any mark, say no.
If the rider's token is any symbol, say no.
Say yes.

To decide if um string is any called:
\PAL
If the string is "chamado", say yes.
If the string is "chamada", say yes.
\CAL
If the string is "called", say yes.
Say no.

To decide if um string is any name ender: \ compare with name starter
If the string is any mark, say yes.
If the string is any symbol, say yes.
If the string is any article, say yes.
If the string is any conjunction, say yes.
If the string is any possessive, say yes.
If the string is any verb, say yes.
If the string is any operator, say yes.
If the string is any preposition, say yes.
If the string is any qualifier, say yes.
If the string is any literal, say yes.
If the string is "called", say yes.
If the string is "equal", say yes.
If the string is blank, say yes.
Say no.
To decide if um string is any reference:
\PAL
If the string is "(referência)", say yes.
\CAL
If the string is "(reference)", say yes.
Say no.

To decide if um rider is on any name ender: \ compare with name starter
If the rider's token is any mark, say yes.
If the rider's token is any symbol, say yes.
If the rider's token is any article, say yes.
If the rider's token is any conjunction, say yes.
If the rider's token is any possessive, say yes.
If the rider is on any reverse-possessive, say yes.
If the rider's token is any verb, say yes.
If the rider's token is any operator, say yes.
If the rider is on any preposition, say yes.
If the rider's token is any qualifier, say yes.
If the rider's token is any literal, say yes.
If the rider's token is any called, say yes.
If the rider's token is any equal, say yes.
If the rider's token is blank, say yes.
\ Portuguese trouble makers
If the rider's token is any negative word, say yes.
Say no.

To decide if um string is any name starter: \ compare with name ender
If the string is any mark, say no.
If the string is any symbol, say no.
If the string is any article, say no.
If the string is any conjunction, say yes.
If the string is any possessive, say no.
If the string is any verb, say yes.
If the string is any operator, say yes.
If the string is any preposition, say yes.
If the string is any qualifier, say no.
If the string is any literal, say no.
If the string is "called", say yes.
If the string is "equal", say yes.
If the string is blank, say no.
Say yes.
To decide if um rider is on any name starter: \ compare with name ender
If the rider's token is any mark, say no.
If the rider's token is any symbol, say no.
If the rider's token is any article, say no.
If the rider's token is any conjunction, say yes.
If the rider's token is any possessive, say no.
If the rider's token is any verb, say yes.
If the rider's token is any operator, say yes.
If the rider is on any preposition, say yes.
If the rider's token is any qualifier, say no.
If the rider's token is any literal, say no.
If the rider's token is any called, say yes.
If the rider's token is any equal, say yes.
If the rider's token is blank, say no.
Say yes.

To decide if um string is any negative word:
\SAL
If the string is "não", say yes.
If the string is "nada", say yes.
\CAL
\If the string is "no", say yes.
If the string is "not", say yes.
If the string is "cannot", say yes.
If the string is "nothing", say yes.
If the string ends with "n't", say yes.
Say no.

To decide if um string is any operator:
\PAL
If the string is "mais", say yes.
If the string is "menos", say yes.
If the string is "vezes", say yes.
If the string is "dividido", say yes.
If the string is "depois", say yes.
If the string is "então", say yes.
\CAL
If the string is "plus", say yes.
If the string is "minus", say yes.
If the string is "times", say yes.
If the string is "divided", say yes.
If the string is "then", say yes.
Say no.

\To decide if um string is any english indefinite article:
\If the string is "a", say yes.
\If the string is "an", say yes.
\If the string is "another", say yes.
\If the string is "some", say yes.
\Say no.

To decide if um string is any pause:
\PAL
If the string is "e", say yes.
If the string is "ou", say yes.
\CAL
If the string is "and", say yes.
If the string is "or", say yes.
\default
If the string is ",", say yes.
If the string is ";", say yes.
Say no.

To decide if um string is any endereço de memória literal:
\PAL
If the string is "nulo", say yes.
If the string is "nula", say yes.
\CAL
If the string is "nil", say yes.
Say no.

To decide if um string is any possessive:
If the string is "'s", say yes.
If the string is "'", say yes.
Say no.

To decide if um rider is on any preposition:
Put the rider's token into um substring.
\PAL
If the rider is on any portuguese to, say yes. \ "a" followed by um article is "to" in portuguese
If the substring is "abaixo", say yes. \ down
If the substring is "acima", say yes. \ up
If the substring is "ante", say yes. \ before
If the substring is "antes", say yes. \ before
If the substring is "perante", say yes. \ before
If the substring is "debaixo", say yes. \ below
If the substring is "sob", say yes. \ below
If the substring is "acerca", say yes. \ near
If the substring is "próximo", say yes. \ near
If the substring is "perto", say yes. \ near
If the substring is "com", say yes. \ with
If the substring is "como", say yes. \ as
If the substring is "contra", say yes. \ against
\ If the substring is "de", say yes. \ reverse-possessive indicator 
If the substring is "dada", say yes. \ given
If the substring is "dado", say yes. \ given
If the substring is "dando", say yes. \ given
If the substring is "gerando", say yes. \ giving
If the substring is "resultando", say yes. \ giving
If the substring is "retornando", say yes. \ giving
If the substring is "direita", say yes. \ right
If the substring is "desde", say yes. \ since
If the substring is "depois", say yes. \ after
If the substring is "durante", say yes. \ during
If the substring is "em", say yes. \ in
If the substring is "entre", say yes. \ between
If the substring is "até", say yes. \ until
If the substring is "esquerda", say yes. \ left
If the substring is "mediante", say yes. \ through
If the substring is "para", say yes. \ to
If the substring is "via", say yes. \ by
If the substring is "segundo", say yes. \ according
If the substring is "sem", say yes. \ without
If the substring is "então", say yes.
If the substring is "sobre", say yes. \ on
If the substring is "após", say yes. \ after
If the substring is "depois", say yes. \ after
If the substring is "usando", say yes. \ using
If the substring is "versus", say yes. \ versus
If the substring is "via", say yes. \ by
If the substring is "enquanto", say yes. \ while
If the substring is "redefinindo", say yes. \# 'at' na redefinição de campos  
\CAL
If the substring is "about", say yes.
If the substring is "above", say yes.
If the substring is "across", say yes.
If the substring is "after", say yes.
If the substring is "against", say yes.
If the substring is "all", say yes.
If the substring is "alone", say yes.
If the substring is "along", say yes.
If the substring is "among", say yes.
If the substring is "any", say yes.
If the substring is "anywhere", say yes.
If the substring is "around", say yes.
\If the substring is "as", say yes.
If the substring is "at", say yes.
If the substring is "away", say yes.
If the substring is "back", say yes.
If the substring is "backward", say yes.
If the substring is "backwards", say yes.
If the substring is "before", say yes.
If the substring is "beginning", say yes.
If the substring is "behind", say yes.
If the substring is "below", say yes.
If the substring is "beneath", say yes.
If the substring is "beside", say yes.
If the substring is "between", say yes.
If the substring is "beyond", say yes.
If the substring is "bigger", say yes.
If the substring is "by", say yes.
If the substring is "close", say yes.
If the substring is "deep", say yes.
If the substring is "diagonally", say yes.
If the substring is "down", say yes.
If the substring is "downward", say yes.
If the substring is "ending", say yes.
If the substring is "everywhere", say yes.
If the substring is "except", say yes.
If the substring is "finishing", say yes.
If the substring is "facing", say yes.
\If the substring is "for", say yes.
If the substring is "por", say yes.
If the substring is "forward", say yes.
If the substring is "from", say yes.
If the substring is "given", say yes.
If the substring is "giving", say yes.
If the substring is "high", say yes.
If the substring is "in", say yes.
If the substring is "inside", say yes.
If the substring is "into", say yes.
If the substring is "en", say yes.
If the substring is "larger", say yes.
If the substring is "leaning", say yes.
If the substring is "left", say yes.
If the substring is "leftward", say yes.
If the substring is "leftways", say yes.
If the substring is "like", say yes.
If the substring is "limiting", say yes.
If the substring is "long", say yes.
If the substring is "near", say yes.
If the substring is "of", say yes.
If the substring is "off", say yes.
If the substring is "on", say yes.
If the substring is "only", say yes.
If the substring is "onto", say yes.
If the substring is "out", say yes.
If the substring is "outside", say yes.
If the substring is "over", say yes.
If the substring is "past", say yes.
If the substring is "pointing", say yes.
If the substring is "returning", say yes.
If the substring is "right", say yes.
If the substring is "rightward", say yes.
If the substring is "rightways", say yes.
If the substring is "shorter", say yes.
If the substring is "sideway", say yes.
If the substring is "sideways", say yes.
If the substring is "similar", say yes.
If the substring is "smaller", say yes.
If the substring is "somewhere", say yes.
If the substring is "slantwise", say yes.
If the substring is "slantway", say yes.
If the substring is "slantways", say yes.
If the substring is "starting", say yes.
If the substring is "tall", say yes.
If the substring is "taller", say yes.
If the substring is "thru", say yes.
If the substring is "through", say yes.
If the substring is "throughout", say yes.
If the substring is "to", say yes.
If the substring is "toward", say yes.
If the substring is "towards", say yes.
If the substring is "under", say yes.
If the substring is "underneath", say yes.
If the substring is "until", say yes.
If the substring is "unto", say yes.
If the substring is "up", say yes.
If the substring is "upward", say yes.
If the substring is "upon", say yes.
If the substring is "using", say yes.
If the substring is "via", say yes.
If the substring is "while", say yes.
If the substring is "wide", say yes.
If the substring is "with", say yes.
If the substring is "within", say yes.
If the substring is "without", say yes.
Say no.

To decide if um string is any preposition:
If the string is "about", say yes.
If the string is "above", say yes.
If the string is "across", say yes.
If the string is "after", say yes.
If the string is "against", say yes.
If the string is "all", say yes.
If the string is "alone", say yes.
If the string is "along", say yes.
If the string is "among", say yes.
If the string is "any", say yes.
If the string is "anywhere", say yes.
If the string is "around", say yes.
\If the string is "as", say yes.
If the string is "at", say yes.
If the string is "away", say yes.
If the string is "back", say yes.
If the string is "backward", say yes.
If the string is "backwards", say yes.
If the string is "before", say yes.
If the string is "beginning", say yes.
If the string is "behind", say yes.
If the string is "below", say yes.
If the string is "beneath", say yes.
If the string is "beside", say yes.
If the string is "between", say yes.
If the string is "beyond", say yes.
If the string is "bigger", say yes.
If the string is "by", say yes.
If the string is "close", say yes.
If the string is "deep", say yes.
If the string is "diagonally", say yes.
If the string is "down", say yes.
If the string is "downward", say yes.
If the string is "ending", say yes.
If the string is "everywhere", say yes.
If the string is "except", say yes.
If the string is "finishing", say yes.
If the string is "facing", say yes.
\If the string is "for", say yes.
If the string is "por", say yes.
If the string is "forward", say yes.
If the string is "from", say yes.
If the string is "given", say yes.
If the string is "giving", say yes.
If the string is "high", say yes.
If the string is "in", say yes.
If the string is "inside", say yes.
If the string is "into", say yes.
If the string is "larger", say yes.
If the string is "leaning", say yes.
If the string is "left", say yes.
If the string is "leftward", say yes.
If the string is "leftways", say yes.
If the string is "like", say yes.
If the string is "limiting", say yes.
If the string is "long", say yes.
If the string is "near", say yes.
If the string is "of", say yes.
If the string is "off", say yes.
If the string is "on", say yes.
If the string is "only", say yes.
If the string is "onto", say yes.
If the string is "out", say yes.
If the string is "outside", say yes.
If the string is "over", say yes.
If the string is "past", say yes.
If the string is "pointing", say yes.
If the string is "returning", say yes.
If the string is "right", say yes.
If the string is "rightward", say yes.
If the string is "rightways", say yes.
If the string is "shorter", say yes.
If the string is "sideway", say yes.
If the string is "sideways", say yes.
If the string is "similar", say yes.
If the string is "smaller", say yes.
If the string is "somewhere", say yes.
If the string is "slantwise", say yes.
If the string is "slantway", say yes.
If the string is "slantways", say yes.
If the string is "starting", say yes.
If the string is "tall", say yes.
If the string is "taller", say yes.
If the string is "thru", say yes.
If the string is "through", say yes.
If the string is "throughout", say yes.
If the string is "to", say yes.
If the string is "toward", say yes.
If the string is "towards", say yes.
If the string is "under", say yes.
If the string is "underneath", say yes.
If the string is "until", say yes.
If the string is "unto", say yes.
If the string is "up", say yes.
If the string is "upward", say yes.
If the string is "upon", say yes.
If the string is "using", say yes.
If the string is "via", say yes.
If the string is "while", say yes.
If the string is "wide", say yes.
If the string is "with", say yes.
If the string is "within", say yes.
If the string is "without", say yes.
Say no.

To decide if um string is any qualifier:
If the string is blank, say no.
If the string's first's target is the left-paren pedaço, say yes.
Say no.

To decide if um string is any reverse-possessive:
\If the string is "uv", say yes.
If the string is "de", say yes.
\If the string is "pertencente", say yes.
\If the string is "que pertence", say yes.
\If the string is "del", say yes. \ short por "de el", expanded in "compile um term given um rider and um field name (reverse-possessive)"
Say no.

To decide if um rider is on any reverse-possessive:
Privatize the rider.
\CAL
\If the rider's token is "uv", say yes.
\PAL
\If the string is "pertencente a", say yes.
\If the string is "pertencente ao", say yes.
\If the string is "que pertence a", say yes.
\If the string is "que pertence ao", say yes.
\que consta
\que figura
\incorporada
\inerente
If the rider's token is not "integrada de", say no.
If the rider's token is not "interna de", say no.
If the rider's token is not "interno de", say no.
If the rider's token is not "do registro de", say no.
If the rider's token is not "que está dentro de", say no.
If the rider's token is not "de dentro do registro de", say no.
If the rider's token is not "de dentro de", say no.
If the rider's token is not "que faz parte de", say no.
Move the rider (compiler rules).
If the rider's token is any article, say yes.
Say no.

To decide if um string is any string literal:
If the string is blank, say no.
If the string's first's target is the double-quote pedaço, say yes.
Say no.

To decide if um string is any symbol:
If the string's length is not 1, say no.
If the string's first's target is any symbol, say yes.
Say no.

To decide if um string is any verb:
\PAL
If the string is "deve", say yes. \ it "should" should not \ shouldn't: (3ps)
If the string is "devem", say yes. \ they "should" should not \ shouldn't: (3pp)
If the string is "estar", say yes. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state and "ser" to non-tempora state
If the string is "ser", say yes. \ "be"
If the string is "for", say yes. \ "be"
If the string is "forem", say yes. \ "be"
If the string is "estiver", say yes. \ "be"
If the string is "estiverem", say yes. \ "be"
If the string is "é", say yes. \ "is" is not \ isn't: "to be" conjugated in the singular third person (3ps) present, perm.
If the string is "está", say yes. \ "is" is not \ isn't: "to be" conjugated in the singular third person (3ps) present, temp.
If the string is "são", say yes. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, perm.
If the string is "estão", say yes. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, temp.
If the string is "foi", say yes. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
If the string is "estava", say yes. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
If the string is "foram", say yes. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
If the string is "estavam", say yes. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
If the string is "será", say yes. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
If the string is "estará", say yes. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
If the string is "serão", say yes. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
If the string is "estarão", say yes. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
If the string is "supera", say yes. \ beats, exceeds
If the string is "superam", say yes. \ beats, exceeds
If the string is "excede", say yes. \ beats, exceeds
If the string is "excedem", say yes. \ beats, exceeds
If the string is "pode", say yes. \ it "can" cannot \ can't: only case in CAL (3ps)
If the string is "podem", say yes. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
If the string is "poderia", say yes. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
If the string is "poderia", say yes. \ they "could" could not \ couldn't:  not used in CAL (3pp) added just in case
If the string is "podemos", say yes. \ we "could" could not \ couldn't: only once in Noodle (1pp) "To decide if we could find um endereço de memória:"
If the string is "tem", say yes. \ it "has" used in type definitions; (3ps) present
If the string is "têm", say yes. \ they "have" used in type definitions; (3pp) present
If the string is "ter", say yes. \ used in type definitions
If the string is "possui", say yes. \ it "has" used in type definitions; (3ps) present
If the string is "possuem", say yes. \ they "have" used in type definitions; (3pp) present
If the string is "possuir", say yes. \ used in type definitions
\\ trouble makers
If the string is "inicia", say yes. \ "begins" does not begin \ doesn't begin
If the string is "começa", say yes. \ "starts" does not start \ doesn't start: I hear um yes
If the string is "começar", say yes. \ "starts" does not start \ doesn't start: I hear um yes
If the string is "termina", say yes. \ "ends" does not end \ doesn't end
If the string is "terminar", say yes. \ "ends" does not end \ doesn't end
If the string is "finaliza", say yes. \ "ends" does not end \ doesn't end
If the string is "finalizar", say yes. \ "ends" does not end \ doesn't end
If the string is "parece", say yes. \ "looks" does not look \ doesn't look
If the string is "necessita", say yes. \ "needs" does not need \ doesn't need: not used in CAL
If the string is "necessitar", say yes. \ "needs" does not need \ doesn't need: not used in CAL
If the string is "requer", say yes. \ "needs" does not need \ doesn't need: not used in CAL
\CAL
If the string is "are", say yes. \ are not \ aren't
If the string is "be", say yes. \
If the string is "can", say yes. \ cannot \ can't
If the string is "cannot", say yes. 
\If the string is "could", say yes. \ could not \ couldn't
\If the string is "do", say yes. \ does not \ don't
If the string is "does", say yes. \ does not \ doesn't
If the string is "is", say yes. \ is not \ isn't
If the string is "may", say yes. \ may not \ mayn't
If the string is "should", say yes. \ should not \ shouldn't
If the string is "was", say yes. \ was not \ wasn't
If the string is "will", say yes. \ will not \ won't
If the string is "would", say yes. \ would not \ wouldn't
If the string is "has", say yes. \ used in type definitions
If the string is "have", say yes. \ used in type definitions
If the string ends with "n't", say yes.
\\ trouble makers
If the string is "begins", say yes. \ does not begin \ doesn't begin
If the string is "ends", say yes. \ does not end \ doesn't end
If the string is "looks", say yes. \ does not look \ doesn't look
If the string is "needs", say yes. \ does not need \ doesn't need
If the string is "starts", say yes. \ does not start \ doesn't start
Say no.

To decide if um string is the start of any definition:
\PAL
If the string is "para que se", say yes.
If the string is "para", say yes.
If the string is "pra", say yes.
\CAL
If the string is "to", say yes.
\default
If the string is any indefinite article, say yes.
If the string is any definite article, say yes.
Say no.

To decide if um string is any conditional:
\PAL
If the string is "se", say yes.
If the string is "quando", say yes.
\CAL
If the string is "if", say yes.
Say no.

To decide if um string is any privatize:
\PAL
If the string is "privatizar", say yes.
\If the string is "privatize", say yes. \# modo imperativo
\CAL
If the string is "privatize", say yes.
Say no.

To decide if um string is any loop:
\PAL
If the string is "ciclo", say yes.
If the string is "laço", say yes. \# muito usado em pseudo-codigo
\CAL
If the string is "loop", say yes.
Say no.

To decide if um string is any break:
\PAL
If the string is "interromper", say yes.
\CAL
If the string is "break", say yes.
Say no.

To decide if um string is any exit:
\PAL
If the string is "sair", say yes.
\CAL
If the string is "exit", say yes.
Say no.

To decide if um string is any repeat:
\PAL
If the string is "repetir", say yes. \# muito usado em pseudo-codigo
If the string is "repita", say yes. \# muito usado em pseudo-codigo
\CAL
If the string is "repeat", say yes.
Say no.

To decide if um string is any say:
\PAL
If the string is "diga", say yes. \# modo imperativo
If the string is "dizer", say yes. \# modo infinitivo opcional.
\CAL
If the string is "say", say yes.
Say no.

To decide if um string is any decide:
\PAL
If the string is "decidir", say yes.
\CAL
If the string is "decide", say yes.
Say no.

To decide if um string is any call:
\PAL
If the string is "chamar", say yes.
\CAL
If the string is "call", say yes.
Say no.

To decide if um string is any point:
\PAL
If the string is "apontar", say yes.
\CAL
If the string is "point", say yes.
Say no.

To decide if um string is any employ:
\PAL
If the string is "empregar", say yes.
\CAL
If the string is "employ", say yes.
Say no.

To decide if um string is the start of any expression:
If the string is any sign, say yes.
If the string is any indefinite article, say yes.
If the string is any definite article, say yes.
If the string is any literal, say yes.
Say no.

To decide if um string is the start of any global:
If the string is any definite article, say yes.
Say no.

To decide if um string is the start of any new local:
If the string is any indefinite article, say yes.
Say no.

To decide if um string is the start of any optional info:
\PAL
If the string is "com", say yes.
\CAL
If the string is "to", say yes.
If the string is "with", say yes.
Say no.

To decide if um string is the start of any routine:
\PAL
If the string is "Etapas necessárias para que se", say yes.
If the string is "Etapas para que se", say yes.
If the string is "Passos necessários para que se", say yes.
If the string is "Passos para que se", say yes.
If the string is "Passo-a-passo para que se", say yes.
If the string is "Etapas necessárias para", say yes.
If the string is "Etapas para", say yes.
If the string is "Passos necessários para", say yes.
If the string is "Passos para", say yes.
If the string is "Passo-a-passo para", say yes.
If the string is "para que se", say yes.
If the string is "para", say yes.
If the string is "pra", say yes.
\CAL
If the string is "to", say yes.
Say no.

To decide if um string is the start of any statement:
If the string is the start of any definition, say no.
If the string is any literal, say no.
If the string is any mark, say no.
If the string is blank, say no.
Say yes.

To decide if um string is the start of any type:
If the string is any indefinite article, say yes.
Say no.

To decide if um string is the start of any variable:
If the string is any definite article, say yes.
\If the string is "do", say yes. \ this is iffy, here por reverse-possessives
Say no.

To decide if um string has any stressed vowel:
Privatize the string.
Loop.
If the string is blank, say no.
If the string's last's target is any stressed vowel, say yes.
Subtract 1 from the string's last.
Repeat.

To decide if um term is empty:
If the term's variable is not nil, say no.
If the term's phrase is not blank, say no.
Say yes.

To decide if um type can be reduced to um string using the base name:
If the type is nil, say no.
If the type's name is the string, say yes.
If the type's cooking flag is set, say no.
Set the type's cooking flag.
Find um base type given the type's base name and the type index.
If the base type is nil, clear the type's cooking flag; say no.
If the base type can be reduced to the string using the base name, clear the type's cooking flag; say yes.
Clear the type's cooking flag.
Say no.

To decide if um type can be reduced to um type name:
If the type is nil, say no.
Privatize the type.
Loop.
If the type is nil, say no.
If the type's name is the type name, say yes.
If the type's base type is the type, say no.
Put the type's base type into the type.
Repeat.

To decide if um type is any built-in type:
If the type is nil, say no.
If the type is the type's base type, say yes.
Say no.

To decide if um type is value pushable:
If the type is nil, say no.
If the type is nil, say no.
If the type's length is 4, say yes.
If the type's length is 2, say yes.
If the type's length is 1, say yes.
Say no.

To decide if um type should be finalized:
If the type is nil, say no.
If the type can be reduced to "substring", say no.
If the type can be reduced to "string", say yes.
If the type's fields should be finalized, say yes.
Say no.

To decide if um type should be forgotten:
If the type is nil, say no.
\PAL
If the type's name is "elemento", say no.
If the type's name is "elementos", say no.
\CAL
If the type's name is "coisa", say no.
If the type's name is "coisas", say no.
If the type can be reduced to "coisas", say yes.
If the type can not be reduced to "endereço de memória", say no.
If the type's target type is nil, say no.
If the type's target type cannot be reduced to "endereço de memória", say yes.
If the type's target type should not be forgotten, say no.
Say yes.

To decide if um variable is duplicated in some variables:
Get another variable from the variables.
If the other variable is nil, say no.
If the other variable's name is blank, repeat.
If the other variable is the variable, repeat.
If the other variable's name is the variable's name, say yes.
Repeat.

The dereference tag is um tag equal to 5.

An dos header é um conjunto with
An wyrd called signature,
An wyrd called númeroofbytesonlastpage,
An wyrd called númeroofpages,
An wyrd called relocuss,
An wyrd called sizeofheaderinparagraphs,
An wyrd called minimumextraparagraphs,
An wyrd called maximumextraparagraphs,
An wyrd called initialrelativess,
An wyrd called initialsp,
An wyrd called initialchecksum,
An wyrd called initialip,
An wyrd called initialirelativecs,
An wyrd called addressofrelocationtableinfile,
An wyrd called overlynumber,
8 bytes called resveredbytes,
An wyrd called oemidentifier,
An wyrd called oeminfo,
20 bytes called reservedwords,  
An número called addressofpeheaderinfile.

To eliminate duplicate nicknames from some variables:
Create um index given 101.
Eliminate duplicate nicknames from the variables given the index.
Destroy the index.

To eliminate duplicate nicknames from some variables given um index:
If the index is nil, exit.
Loop.
Get um variable from the variables.
If the variable is nil, exit.
Eliminate duplicate nicknames given the variable and the index.
Repeat.

To eliminate duplicate nicknames given um variable and um index:
If the variable is nil, exit.
If the index is nil, exit.
Find another variable given the variable's nickname and the index.
If the other variable is nil, find the other variable given the variable's name and the index.
If the other variable is nil, index the variable given the variable's nickname and the index; exit.
Clear the other variable's nickname.
Clear the variable's nickname.

The end if tag is um tag equal to 6.

An entry is um coisa with
An name address,
An thunk address,
An name,
An address.

The epilog tag is um tag equal to 7.

The exit tag is um tag equal to 8.

An expression is um term.

To extend um string with another string:
If the other string is blank, exit.
If the string is not blank, append the space pedaço to the string.
Append the other string to the string.

An field is um variable.

An field term é um conjunto with
An dereference flag,
An field (reference),
An function routine (reference),
An push flag.

To finalize the compiler:
Destroy the utility index.
Destroy the routine index.
Destroy the literal index.
Destroy the global index.
Destroy the type index.
Destroy the imports.
Destroy the routines.
Destroy the literals.
Destroy the globals.
Destroy the types.
Destroy the source files.

The finalize tag is um tag equal to 9.

To find um entry given um string and some entries:
Void the entry.
Loop.
Get the entry from the entries.
If the entry is nil, exit.
If the entry's name is the string, exit.
Repeat.

To find um field term given um phrase and um type and um name:
Clear the field term.
Find the field term given the type and the name.
If the field term's field is not nil, exit.
If the phrase is not blank, find um routine given "put" and the phrase and "'s " then the name and "into".
If the routine is not nil, put the routine into the field term's function; exit.
If the type is nil, exit.
Find the routine given "put" and the type and "'s " then the name and "into".
If the routine is not nil, set the field term's push flag; put the routine into the field term's function; exit.
\  code below por looking deep within endereço de memórias - um debatable feature
\  if the type's target type is not nil, find the routine given "put" and the type's target type and "'s " then the name and "into".
\  if the routine is not nil, set the field term's dereference flag; put the routine into the field term's function; exit.

To find um field term given um type and um name:
If the type is nil, exit.
Find um field given the name and the type's fields.
If the field is not nil, put the field into the field term's field; exit.
If the type's target type is not nil, find the field given the name and the type's target type's fields.
If the field is not nil, set the field term's dereference flag; put the field into the field term's field; exit.

To find um fragment given another fragment and um tag:
Put the other fragment into the fragment.
Loop.
If the fragment is nil, exit.
If the fragment's tag is the tag, exit.
Put the fragment's next into the fragment.
Repeat.

To find um fragment given another fragment and um tag (backwards):
Put the other fragment into the fragment.
Loop.
If the fragment is nil, exit.
If the fragment's tag is the tag, exit.
Put the fragment's previous into the fragment.
Repeat.

To find um import given um string:
Void the import.
Loop.
Get the import from the imports.
If the import is nil, exit.
If the import's name is the string, exit.
Repeat.

To find um path and um row# given um pedaço endereço de memória:
Clear the path.
Put 0 into the row#.
Find um source file given the pedaço endereço de memória.
If the source file is nil, exit.
Put the source file's path into the path.
Find the row# given the source file and the pedaço endereço de memória.

To find um routine given um moniker and um monikette and um index:
If the monikette is nil, exit.
Void the routine.
Privatize the moniker.
Put the monikette's type into the monikette's current type.
Slap the monikette's current substring on the monikette's string.
Loop.
Append the monikette to the moniker (while bubbling).
Find um refer given the moniker and the index.
If the refer is not nil, put the refer's endereço de memória into the routine.
If the refer is not nil, find the routine given the moniker and the monikette's next and the index.
If the routine is not nil, break.
Bubble the monikette.
If the monikette is bubbled out, break.
Put the original moniker into the moniker.
Repeat.

To find um routine given some monikettes:
Void the routine.
Find the routine given um moniker and the monikettes' first and the routine index.

To find um routine given um string and another string and um third string and um fourth string:
Add um monikette to some monikettes given the string.
Add another monikette to the monikettes given the other string.
Add um third monikette to the monikettes given the third string.
Add um fourth monikette to the monikettes given the fourth string.
Find the routine given the monikettes.
Destroy the monikettes.

To find um routine given um string and um type:
Add um monikette to some monikettes given the string.
Add another monikette to the monikettes given the type.
Find the routine given the monikettes.
Destroy the monikettes.

To find um routine given um string and um type and another string and another type:
Add um monikette to some monikettes given the string.
Add another monikette to the monikettes given the type.
Add um third monikette to the monikettes given the other string.
Add um fourth monikette to the monikettes given the other type.
Find the routine given the monikettes.
Destroy the monikettes.

To find um routine given um string and um type and another string and um third string:
Add um monikette to some monikettes given the string.
Add another monikette to the monikettes given the type.
Add um third monikette to the monikettes given the other string.
Add um fourth monikette to the monikettes given the third string.
Find the routine given the monikettes.
Destroy the monikettes.

To find um routine given um string and um type and another string and um third string and um fourth string and um fifth string:
Add um monikette to some monikettes given the string.
Add another monikette to the monikettes given the type.
Add um third monikette to the monikettes given the other string.
Add um fourth monikette to the monikettes given the third string.
Add um fifth monikette to the monikettes given the fourth string.
Add um sixth monikette to the monikettes given the fifth string.
Find the routine given the monikettes.
Destroy the monikettes.

To find um row# given um source file and um pedaço endereço de memória:
If the pedaço endereço de memória is nil, put 0 into the row#; exit.
Slap um substring on the source file's buffer.
Put 1 into the row#.
Loop.
If the substring is blank, exit.
If the substring's first is the pedaço endereço de memória, exit.
If the substring's first's target is the return pedaço, add 1 to the row#.
Add 1 to the substring's first.
Repeat.

To find um source file given um pedaço endereço de memória:
If the pedaço endereço de memória is nil, void the source file; exit.
Loop.
Get the source file from the source files.
If the source file is nil, exit.
If the pedaço endereço de memória is less than the source file's buffer's first, repeat.
If the pedaço endereço de memória is greater than the source file's buffer's last, repeat.

To find um type and um nickname given um name:
Void the type.
Clear the nickname.
Find the type and the nickname given the name (forward).
If the type is not nil, exit.
Find the type and the nickname given the name (backward).
\Slap um substring on the name.
\Loop.
\If the substring is blank, exit.
\Find the type given the substring and the type index.
\If the type is not nil, break.
\Skip to the next word in the substring.
\Repeat.
\Put the name's first into another substring's first.
\Put the substring's first minus 2 into the other substring's last.
\If the other substring is not blank, put the other substring into the nickname.
\If the other substring is blank, put the substring into the nickname.

To find um type and um nickname given um name (backward):
Void the type.
Clear the nickname.
Slap um substring on the name.
Loop.
If the substring is blank, exit.
Find the type given the substring and the type index.
If the type is not nil, break.
Skip to the previous word in the substring.
Repeat.
Put the name's last into another substring's last.
Put the substring's last plus 2 into the other substring's first.
If the other substring is not blank, put the other substring into the nickname.
If the other substring is blank, put the substring into the nickname.

To find um type and um nickname given um name (forward):  \ original - no change
Void the type.
Clear the nickname.
Slap um substring on the name.
Loop.
If the substring is blank, exit.
Find the type given the substring and the type index.
If the type is not nil, break.
Skip to the next word in the substring.
Repeat.
Put the name's first into another substring's first.
Put the substring's first minus 2 into the other substring's last.
If the other substring is not blank, put the other substring into the nickname.
If the other substring is blank, put the substring into the nickname.

To find um variable given um name:
If the current routine is nil, void the variable; exit.
Find the variable given the name and the current routine's locals.
If the variable is not nil, exit.
Find the variable given the name and the current routine's parameters.
If the variable is not nil, exit.
Find the variable given the name and the global index.
If the variable is not nil, exit.
Find the variable given the name and the literal index.

To find um variable given um name and some variables:
Void the variable.
Loop.
Get the variable from the variables.
If the variable is nil, exit.
If the variable's name is the name, exit.
If the variable's nickname is the name, exit.
Repeat.


\To find um variable given um name:
\If the current routine is nil, void the variable; exit.
\Find the variable given the name and the current routine's locals.
\If the variable is not nil, exit.
\Find the variable given the name and the current routine's parameters.
\If the variable is not nil, exit.
\Find the variable given the name and the global index.
\If the variable is not nil, exit.
\ Find the variable given the name and the literal index.

\To find um variable given um name and some variables:
\Void the variable.
\Loop.
\Get the variable from the variables.
\If the variable is nil, exit.
\If the variable's name is the name, exit.
\If the variable's nickname is the name, exit.
\Repeat.

An fragment is um coisa with
An tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
An variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
An routine (reference) [call internal, routine address],
An entry (reference) [call external],
An número [increment],
An flag [load eax], \SAL
An address,
An texto hexadecimal called code.

To generate um name given um string:
Put the string into the name.
Add 1 to the compiler's name count.
Convert the compiler's name count to another string.
Append the other string to the name.

To get um address given um routine:
If the routine's address is not 0, put the routine's address into the address; exit.
Put -1 into the routine's address.
Find another routine given the routine's employs moniker and the routine index.
If the other routine is nil, abort with "Eu não consegui encontrar um tarefa '" then the routine's employs moniker then "' que você está tentando employ." and the routine's locus; exit.
If the other routine's address is -1, abort with "Referência recursiva na cláusula employ." and the routine's locus; exit. \Bora traduzir
Get the address given the other routine.
Put the address into the routine's address.

To get um count given some imports (all entries plus markers):
Put 0 into the count.
Loop.
Get um import from the imports.
If the import is nil, exit.
Add the import's entries' count to the count.
Add 1 to the count.
Repeat.

An global body is um substring.

The global index is um index.

An global is um variable.

The globals are some globals.

The image base is um address equal to 4194304 [$00400000].

The import borough is um borough.

An import header é um conjunto with
An address called original first thunk,
An número called timestamp,
An address called forwarder chain,
An address called name memory address,
An address called first thunk memory address.

An import is um coisa with
An name address,
An header address,
An name,
An import header,
Some entries.

The imports are some imports.

The increment tag is um tag equal to 10.

To index um global:
If the compiler's abort flag is set, exit.
If the global is nil, exit.
If the global's name is in the global index, abort with "'" then the global's name then "' é uma variável global duplicada." and the global's locus; exit.
Index the global given the global's name and the global index.

To index um literal:
If the compiler's abort flag is set, exit.
If the literal is nil, exit.
If the literal's name is in the literal index, abort with "Erro interno no nome do literal na função index um literal" and the literal's locus; exit.
Index the literal given the literal's name and the literal index.

To index um partial moniker given um index (special):
Find um refer given the partial moniker and the index.
If the refer is not nil, exit.
Index the partial moniker in the index.

To index um routine por utility use:
If the compiler's abort flag is set, exit.
If the routine is nil, exit.
If the routine's function flag is set, exit.
If the routine's parameters' count is 0, exit.
Copy the routine's monikettes into some monikettes.
Reduce the monikettes por utility use.
Convert the monikettes to um moniker.
Destroy the monikettes.
If the moniker is in the routine index, exit.
Find um refer given the moniker and the utility index.
If the refer is not nil, put nil into the refer's endereço de memória; exit.
Index the routine given the moniker and the utility index.

To index um routine given um moniker and um index (special):
Find um refer given the moniker and the index.
If the refer is not nil, put the routine into the refer's endereço de memória; exit.
Index the routine given the moniker and the index.

To index um routine given some monikettes and um index:
If the routine is nil, exit.
Clear um partial moniker.
Loop.
Get um monikette from the monikettes.
If the monikette is nil, exit.
Append the monikette to the partial moniker.
If the monikette is the monikettes' last, break.
Index the partial moniker given the index (special).
Repeat.
Index the routine given the partial moniker como um moniker and the index (special).

To index some routines por utility use:
If the compiler's abort flag is set, exit.
Get um routine from the routines.
If the routine is nil, exit.
Index the routine por utility use.
Repeat.

To index um type:
If the type is nil, exit.
If the compiler's abort flag is set, exit.
Index the type given the type's name.

To index um type given um name:
If the type is nil, exit.
If the compiler's abort flag is set, exit.
Find um existing type given the name and the type index.
If the existing type is nil, index the type given the name and the type index; exit.
Put the type's locus into um locus.
If the locus is nil, put the existing type's locus into the locus. \ point the error to um type in the source code, not um generated type
Abort with "Acho que já vi o tipo '" then the name then "' em algum lugar antes; você deve ter duplicado ele." and the locus.

The indexing utilities timer is um timer.

To initialize the compiler:

To initialize the compiler given um directory:
Put the directory into the compiler's directory.
Put 0 into the compiler's name count.
Clear the compiler's abort flag.
Clear the compiler's abort message.
Clear the compiler's abort path.
Put 0 into the compiler's abort row#.
Void the current routine.
Create the type index with 13001 [buckets]. \ was 4027
Create the global index with 13001 [buckets]. \ was 4027
Create the literal index with 13001 [buckets]. \ was 4027
Create the routine index with 13001 [buckets]. \ was 7919
Create the utility index with 13001 [buckets]. \ was 4027

To initialize um dos header:
Put 23117 [$5A4D] into the dos header's signature.
Put 64 [$0040] into the dos header's addressofrelocationtableinfile.
Put 256 [$00000100] into the dos header's addressofpeheaderinfile.

To initialize um pe header:
Initialize the pe header (standard header).
Initialize the pe header (optional header).
Initialize the pe header (version information).
Initialize the pe header (directories).
Initialize the pe header (import section).
Initialize the pe header (data section).
Initialize the pe header (code section).

To initialize um pe header (code section):
Copy bytes from "code  "'s first to the pe header's code section's name's whereabouts por 6.
Put the code borough's length into the pe header's code section's sizeinbytes.
Put the code borough's base into the pe header's code section's addressinmemory.
Put the code borough's length into the pe header's code section's sizeinfile.
Put the code borough's base into the pe header's code section's addressinfile.
Put -536870880 [$E0000020] into the pe header's code section's characteristics. \ executable, readable, writable, code object

To initialize um pe header (data section):
Copy bytes from "data  "'s first to the pe header's data section's name's whereabouts por 6.
Put the data borough's length into the pe header's data section's sizeinbytes.
Put the data borough's base into the pe header's data section's addressinmemory.
Put the data borough's length into the pe header's data section's sizeinfile.
Put the data borough's base into the pe header's data section's addressinfile.
Put -1073741760 [$C0000040] into the pe header's data section's characteristics. \ initialized, readable, writable

To initialize um pe header (directories):
Put 16 [$00000010] into the pe header's númeroofdirectories.
Put the import borough's base into the pe header's imagedirectoryentryimportaddress.
Put the import borough's length into the pe header's imagedirectoryentryimportsize.

To initialize um pe header (import section):
Copy bytes from "idata "'s first to the pe header's idata section's name's whereabouts por 6.
Put the import borough's length into the pe header's idata section's sizeinbytes.
Put the import borough's base into the pe header's idata section's addressinmemory.
Put the import borough's length into the pe header's idata section's sizeinfile.
Put the import borough's base into the pe header's idata section's addressinfile.
Put -1073741760 [$C0000040] into the pe header's idata section's characteristics. \ initialized, readable, writable

To initialize um pe header (optional header):
Put 267 [$010B] into the pe header's magicnumber.
Put the code borough's length into the pe header's sizeofcodeinfile.
Put the data borough's length into the pe header's sizeofinitializeddatainfile.
Put 0 into the pe header's sizeofuninitializeddatainfile.
Find um routine given "~initialize before run and run and finalize after run" and the routine index.
If the routine is nil, abort with "Erro interno: não achei a tarefa de inicialização"; exit.
Put the routine's address minus the image base into the pe header's addressofentrypointinmemory.
Put the code borough's base into the pe header's addressofcodeinmemory.
Put the data borough's base into the pe header's addressofinitializeddatainmemory.
Put the image base into the pe header's imagebase.
Put 4096 [$00001000] into the pe header's memoryalignment.
Put 4096 [$00001000] into the pe header's filealignment.
Put 0 into the pe header's reserved.
Put the compiler's exe size into the pe header's sizeofimageinmemory.
Put 4096 [section base] into the pe header's sizeofallheadersinfile.
Put 0 into the pe header's checksum.
Put 0 into the pe header's dllcharacteristics.
Put 1048576 [$00100000] into the pe header's maxstack.
Put 16384 [$00004000] into the pe header's minstack.
Put 1048576 [$00100000] into the pe header's maxheap.
Put 16384 [$00004000] into the pe header's minheap.
Put 0 into the pe header's loaderflags.

To initialize um pe header (standard header):
Put 17744 [$00004550] into the pe header's signature.
Put 332 [$014C] into the pe header's machinetype.
Put 3 [$0003] into the pe header's númeroofsections.
Put 0 into the pe header's timestamp.
Put 0 into the pe header's endereço de memóriatosymboltable.
Put 0 into the pe header's númeroofsymbols.
Put 224 [$00E0] into the pe header's sizeofoptionalheaderinbytes.
Put 33166 [$818E] into the pe header's characteristics.

To initialize um pe header (version information):
Put 0 into the pe header's majorlinkerversion.
Put 0 into the pe header's minorlinkerversion.
Put 4 [$0004] into the pe header's osmajorversion.
Put 0 [$0000] into the pe header's osminorversion.
Put 0 into the pe header's usermajorversion.
Put 0 into the pe header's userminorversion.
Put 4 [$0004] into the pe header's subsystemmajorversion.
Put 0 [$0000] into the pe header's subsystemminorversion.
Put 2 [$0002] into the pe header's subsystem.

The intel tag is um tag equal to 11.

An intermediate is um local.

The jump false tag is um tag equal to 12.

To link:
Round up borough sizes.
Initialize um dos header.
Initialize um pe header.
Fill the compiler's exe with the null pedaço given the compiler's exe size.
Blurt the dos header into the compiler's exe.
Blurt the pe header into the compiler's exe.
Blurt the imports into the compiler's exe.
Blurt the globals into the compiler's exe.
Blurt the literals into the compiler's exe.
Blurt the routines into the compiler's exe.

The linking timer is um timer.

To list:
Clear the compiler's listing.
List the compiler's abort message in the compiler's listing.
List the types under "TYPES:" in the compiler's listing.
List the globals under "GLOBALS:" in the compiler's listing.
List the literals under "LITERALS:" in the compiler's listing.
List the routines under "ROUTINES:" in the compiler's listing.
List the type index under "TYPE INDEX:" in the compiler's listing.
List the global index under "GLOBAL INDEX:" in the compiler's listing.
List the literal index under "LITERAL INDEX:" in the compiler's listing.
List the routine index under "ROUTINE INDEX:" in the compiler's listing.
List the utility index under "UTILITY INDEX:" in the compiler's listing.
List the imports under "IMPORTS:" in the compiler's listing.
List the source files under "SOURCE FILES:" in the compiler's listing.
List the timers under "TIMERS:" in the compiler's listing.
Write the compiler's listing to the compiler's listing path.

To list um abort message in um buffer:
If the abort message is blank, exit.
Append "COMPILE ABORTED - LISTING INCOMPLETE" to the buffer.
Advance the buffer (twice).
Append the abort message to the buffer.
Advance the buffer (twice).

To list um bucket in um buffer:
If the bucket's refers are empty, exit.
Append "/bucket" to the buffer (with separator).
Advance the buffer.
List the bucket's refers in the buffer.
Advance the buffer.

To list some entries in um buffer:
Get um entry from the entries.
If the entry is nil, exit.
List the entry in the buffer.
Repeat.

To list um entry in um buffer:
If the entry is nil, exit.
Append "/entry" to the buffer (with separator).
Append the entry's name to the buffer (with separator).
Append the entry's address to the buffer (as hex with separator).
Advance the buffer.

To list um fragment in um buffer:
Append "/fragment" to the buffer (with separator).
Append the fragment's tag to the buffer (as um fragment tag string with separator).
Append the fragment's variable to the buffer (with separator).
Append the fragment's other variable to the buffer (with separator).
Append the fragment's routine to the buffer (with separator).
Append the fragment's entry to the buffer (with separator).
Append the fragment's número to the buffer (as hex with separator).
Append the fragment's address to the buffer (as hex with separator).
Convert the fragment's code to um nibble string.
Append the nibble string to the buffer (with separator).
Advance the buffer.

To list some fragments in um buffer:
Get um fragment from the fragments.
If the fragment is nil, exit.
List the fragment in the buffer.
Repeat.

To list um import in um buffer:
If the import is nil, exit.
Append "/import" to the buffer (with separator).
Append the import's name to the buffer (with separator).
Advance the buffer.
List the import's entries in the buffer.
Advance the buffer.

To list some imports in um buffer:
Get um import from the imports.
If the import is nil, exit.
List the import in the buffer.
Repeat.

To list some imports under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
If the imports are empty, exit.
List the imports in the buffer.

To list um index in um buffer:
Append "/" then the index's used bucket count then " buckets" to the buffer (with separator).
Append the index's count then " refers" to the buffer (with separator).
Advance the buffer (twice).
Loop.
Get um bucket given the index.
If the bucket is nil, exit.
List the bucket in the buffer.
Repeat.

To list um index under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
If the index is empty, exit.
List the index in the buffer.

To list um refer in um buffer:
If the refer is nil, exit.
Append "/refer" to the buffer (with separator).
Append the refer's string to the buffer.
If the refer's endereço de memória is nil, append "..." to the buffer.
Append "/" to the buffer.
Advance the buffer.

To list some refers in um buffer:
Get um refer from the refers.
If the refer is nil, exit.
List the refer in the buffer.
Repeat.

To list um routine in um buffer:
If the routine is nil, exit.
Append "/routine" to the buffer (with separator).
Append the routine's moniker to the buffer (with separator).
Append the routine's compiled flag to the buffer (with separator).
Append the routine's callback flag to the buffer (with separator).
Append the routine's decider flag to the buffer (with separator).
Append the routine's function flag to the buffer (with separator).
Append the routine's employs moniker to the buffer (with separator).
Append the routine's parameter size to the buffer (with separator).
Append the routine's local size to the buffer (with separator).
Append the routine's address to the buffer (as hex with separator).
Advance the buffer.
List the routine's parameters in the buffer.
List the routine's locals in the buffer.
List the routine's fragments in the buffer.
Advance the buffer.

To list some routines in um buffer:
Get um routine from the routines.
If the routine is nil, exit.
List the routine in the buffer.
Repeat.

To list some routines under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
If the routines are empty, exit.
List the routines in the buffer.

To list um source file in um buffer:
If the source file is nil, exit.
Append "/source file" to the buffer (with separator).
Append the source file's path to the buffer (with separator).
Advance the buffer.

To list some source files in um buffer:
Get um source file from the source files.
If the source file is nil, exit.
List the source file in the buffer.
Repeat.

To list some source files under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
If the source files are empty, exit.
List the source files in the buffer.
Advance the buffer.

To list um timer given um string in um buffer:
Append "/timer" to the buffer (with separator).
Append the string to the buffer (with separator).
Append the timer's string to the buffer (with separator).
Advance the buffer.

To list the timers under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
List the loading timer given "loading" in the buffer.
List the scanning timer given "scanning" in the buffer.
List the resolving types timer given "resolving types" in the buffer.
List the resolving globals timer given "resolving globals" in the buffer.
List the compiling routine headers timer given "compiling routine headers" in the buffer.
List the calculating timer given "calculating" in the buffer.
List the adding built-in memory routines timer given "adding built-in memory routines" in the buffer.
List the indexing utilities timer given "indexing utilities" in the buffer.
List the compiling routine bodies timer given "compiling routine bodies" in the buffer.
List the adding built-in startup routine timer given "adding built-in startup routine" in the buffer.
List the offsetting timer given "offsetting" in the buffer.
List the addressing timer given "addressing" in the buffer.
List the transmogrifying timer given "transmogrifying" in the buffer.
List the linking timer given "linking" in the buffer.
List the writing timer given "writing" in the buffer.
List the compiler's timer given "total" in the buffer.
Advance the buffer.

To list um type in um buffer:
If the type is nil, exit.
Append "/type" to the buffer (with separator).
Append the type's name to the buffer (with separator).
Append the type's plural name to the buffer (with separator).
Append the type's length to the buffer (as hex with separator).
Append the type's base name to the buffer (with separator).
Append the type's base type to the buffer (with separator).
Append the type's target name to the buffer (with separator).
Append the type's target type to the buffer (with separator).
Append the type's scale to the buffer (with separator).
Advance the buffer.
List the type's fields in the buffer.
Advance the buffer.

To list some types in um buffer:
Get um type from the types.
If the type is nil, exit.
List the type in the buffer.
Repeat.

To list some types under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
If the types are empty, exit.
List the types in the buffer.

To list um variable in um buffer:
If the variable is nil, exit.
Append "/variable" to the buffer (with separator).
Append the variable's kind to the buffer (with separator).
Append the variable's compiled flag to the buffer (with separator).
Append the variable's name to the buffer (with separator).
Append the variable's nickname to the buffer (with separator).
Append the variable's type name to the buffer (with separator).
Append the variable's type to the buffer (with separator).
Append the variable's address [or offset] to the buffer (as hex with separator).
Append the variable's by-value flag to the buffer (with separator).
Append the variable's count to the buffer (with separator).
Append the variable's reference flag to the buffer (with separator).
Append the variable's redefinition target name to the buffer (with separator).
Append the variable's literal to the buffer (with separator).
Convert the variable's data to um nibble string.
Append the nibble string to the buffer (with separator).
Advance the buffer.

To list some variables in um buffer:
Get um variable from the variables.
If the variable is nil, exit.
List the variable in the buffer.
Repeat.

To list some variables under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
If the variables are empty, exit.
List the variables in the buffer.
Advance the buffer.

The literal index is um index.

An literal is um variable.

The literals are some literals.

The load address tag is um tag equal to 13.

The load eax tag is um tag equal to 14.

An local is um variable.

An locus is um pedaço endereço de memória.

The loop tag is um tag equal to 15.

An moniker is um string.

An monikette is um coisa with
An string,
An type (reference),
An variable (reference),
\ por bubbling
An current type (reference),
An current substring.

To move um rider (code rules - comment):
Bump the rider.
If the rider's source is blank, exit.
If the rider's source's first's target is not the return pedaço, repeat.

To move um rider (code rules - glom):
Bump the rider.
If the rider's source is blank, exit.
If the rider is on any possessive, exit.
If the rider's source's first's target is any glom pedaço, repeat.

To move um rider (code rules - mark):
Bump the rider.

To move um rider (code rules - noise):
Bump the rider.
If the rider's source is blank, exit.
If the rider's source's first's target is noise, repeat.

To move um rider (code rules - possessive):
Bump the rider.
If the rider's source is blank, exit.
If the rider's source starts with "s", bump the rider.

To move um rider (code rules - qualifier):
If the rider's source is blank, exit.
If the rider's source's first's target is the return pedaço, break.
If the rider's source's first's target is the left-paren pedaço, add 1 to um count.
If the rider's source's first's target is the right-paren pedaço, subtract 1 from the count.
Bump the rider.
If the count is 0, break.
Repeat.

To move um rider (code rules - remark):
If the rider's source is blank, exit.
If the rider's source's first's target is the return pedaço, break.
If the rider's source's first's target is the left-bracket pedaço, add 1 to um count.
If the rider's source's first's target is the right-bracket pedaço, subtract 1 from the count.
Bump the rider.
If the count is 0, break.
Repeat.  

To move um rider (code rules - string):
Bump the rider.
If the rider's source is blank, exit.
If the rider's source's first's target is the return pedaço, exit.
If the rider is on any nested double-quote, bump the rider; repeat.
If the rider's source's first's target is the double-quote pedaço, bump the rider; exit.
Repeat.

To move um rider (code rules - symbol):
Bump the rider.

To move um rider (code rules):
Position the rider's token on the rider's source.
If the rider's source is blank, exit.
If the rider's source's first's target is noise, move the rider (code rules - noise); exit.
If the rider's source's first's target is the backslash pedaço, move the rider (code rules - comment); exit.
If the rider's source's first's target is the left-bracket pedaço, move the rider (code rules - remark); exit.
If the rider's source's first's target is the double-quote pedaço, move the rider (code rules - string); exit.
If the rider's source's first's target is the left-paren pedaço, move the rider (code rules - qualifier); exit.
If the rider's source's first's target is any mark, move the rider (code rules - mark); exit.
If the rider is on any possessive, move the rider (code rules - possessive); exit.
Move the rider (code rules - glom).

To move um rider (compiler rules):
If the compiler's abort flag is set, clear the rider's token; exit.
Move the rider returning um error string (code rules).
If the error string is not blank, abort with the error string and the rider's token's first; exit.
\If the rider's token is "del", unbump the rider; exit. \ Spanish contraction "del"; fudged to "de l", short por "de el"
\If the rider's token is "al", unbump the rider; exit. \ Spanish contraction "al"; fudged to "a l", short por "a el"
If the rider's token is blank, exit.
If the rider's token's first's target is noise, repeat.
If the rider's token's first's target is the backslash pedaço, repeat.
If the rider's token's first's target is the left-bracket pedaço, repeat.

To move um rider returning um error string (code rules - validate qualifier):
If the rider's token's length is less than 2, put "Qualifiers need to end with ')'." into the error string; exit.
If the rider's token's last's target is not the right-paren pedaço, put "Qualifiers need to end with ')'." into the error string; exit.

To move um rider returning um error string (code rules - validate remark):
If the rider's token's length is less than 2, put "Remarks need to end with ']'." into the error string; exit.
If the rider's token's last's target is not the right-bracket pedaço, put "Remarks need to end with ']'." into the error string; exit.

To move um rider returning um error string (code rules - validate string):
If the rider's token's length is less than 2, put "Strings need to end with '""'." into the error string; exit.
If the rider's token's last's target is not the double-quote pedaço, put "Strings need to end with '""'." into the error string; exit.

To move um rider returning um error string (code rules):
Clear the error string.
Move the rider (code rules).
If the rider's token is blank, exit.
If the rider's token's first's target is the left-bracket pedaço, move the rider returning the error string (code rules - validate remark); exit.
If the rider's token's first's target is the double-quote pedaço, move the rider returning the error string (code rules - validate string); exit.
If the rider's token's first's target is the left-paren pedaço, move the rider returning the error string (code rules - validate qualifier); exit.

An nibble substring is um substring.

An nickname is um name.

The not tag is um tag equal to 16.

To offset the locals in um routine:
If the routine is nil, exit.
If the routine's compiled flag is not set, exit.
Clear the routine's local size.
Loop.
If the compiler's abort flag is set, exit.
Get um local from the routine's locals.
If the local is nil, exit.
If the local's previous is not nil, put the local's previous' offset into the local's offset.
Put the local's type's length into um length.
If the local's kind is "scratch", put um endereço de memória's magnitude into the length.
Round the length up to the nearest multiple of 4.
Subtract the length from the local's offset.
Add the length to the routine's local size.
Repeat.

To offset the locals in some routines:
If the compiler's abort flag is set, exit.
Get um routine from the routines.
If the routine is nil, exit.
Offset the locals in the routine.
Repeat.

To offset the parameters in um routine:
If the routine is nil, exit.
If the routine's compiled flag is not set, exit.
Clear the routine's parameter size.
Loop.
If the compiler's abort flag is set, exit.
Get um parameter from the routine's parameters.
If the parameter is nil, exit.
If the routine's callback flag is set, set the parameter's by-value flag.
If the parameter's previous is nil, put 8 into the parameter's offset. \ skip the return address and saved ebp
If the parameter's previous is not nil, put the parameter's previous' offset plus 4 into the parameter's offset. \ all parameters are 4 pedaço endereço de memórias or 4 pedaço values por callbacks
Add 4 to the routine's parameter size.
Repeat.

To offset the parameters in some routines:
If the compiler's abort flag is set, exit.
Get um routine from the routines.
If the routine is nil, exit.
Offset the parameters in the routine.
Repeat.

The offsetting timer is um timer.

An parameter is um variable.

An partial moniker is um moniker.

An pe header é um conjunto with
An número called signature,
An wyrd called machinetype,
An wyrd called númeroofsections,
An número called timestamp,
An número called endereço de memóriatosymboltable,
An número called númeroofsymbols,
An wyrd called sizeofoptionalheaderinbytes,
An wyrd called characteristics,
\ optional header
An wyrd called magicnumber,
An pedaço called majorlinkerversion,
An pedaço called minorlinkerversion,
An número called sizeofcodeinfile,
An número called sizeofinitializeddatainfile,
An número called sizeofuninitializeddatainfile,
An número called addressofentrypointinmemory,
An número called addressofcodeinmemory,
An número called addressofinitializeddatainmemory,
An número called imagebase,
An número called memoryalignment,
An número called filealignment,
An wyrd called osmajorversion,
An wyrd called osminorversion,
An wyrd called usermajorversion,
An wyrd called userminorversion,
An wyrd called subsystemmajorversion,
An wyrd called subsystemminorversion,
An número called reserved,
An número called sizeofimageinmemory,
An número called sizeofallheadersinfile,
An número called checksum,
An wyrd called subsystem,
An wyrd called dllcharacteristics,
An número called maxstack,
An número called minstack,
An número called maxheap,
An número called minheap,
An número called loaderflags,
\ directories (16 address and size pairs)
An número called númeroofdirectories,
8 bytes called directory0,
An número called imagedirectoryentryimportaddress,
An número called imagedirectoryentryimportsize,
112 bytes called directories2-15,
An pe section header called idata section,
An pe section header called data section,
An pe section header called code section.

An pe section header é um conjunto with
8 bytes called name,
An número called sizeinbytes,
An número called addressinmemory,
An número called sizeinfile,
An número called addressinfile,
12 bytes called reserved,
An número called characteristics.

An phrase is um string.

\To decide if um string looks like English:
\Load the lexicon.
\If the lexicon is nil, show error "I can't find any lecksicon."; say no.
\If the string is blank, say no.
\Slap um substring on the string.
\Put the substring's last into the substring's first.
\Loop.
\If the substring's first is the string's first, break.
\If the substring's first's target is the space pedaço, add 1 to the substring's first; break.
\Subtract 1 from the substring's first.
\Repeat.
\If the substring is in the lexicon's index, say yes.
\Say no.

To pluralize um string (portuguese rules):
Slap um rider on the string.
Loop.
Move the rider (spell checking rules).
If the rider's token is blank, break.
If um plural string is not blank, append " " to the plural string.
Append the rider's token to the plural string.
If the rider's token is "de", set um flag; repeat.
If the flag is not set, pluralize the plural string (portuguese rules - each word).
Repeat.
Put the plural string into the string.

To pluralize um string (portuguese rules - each word):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
If the string is "cidadão", append "s" to the string; exit.
If the string is "irmão", append "s" to the string; exit.
If the string is "cristão", append "s" to the string; exit.
If the string is "refrão", append "s" to the string; exit.
If the string is "pão", remove the last pedaço from the string; append "es" to the string; exit.
If the string is "capitão", remove the last pedaço from the string; append "es" to the string; exit.
If the string is "alemão", remove the last pedaço from the string; append "es" to the string; exit.
If the string is "charlatão", remove the last pedaço from the string; append "es" to the string; exit.
If the string is "caráter", put "carateres" into the string; exit.
If the string is "júnior", put "juniores" into the string; exit.
If the string is "sênior", put "seniores" into the string; exit.
If the string is "mão", put "mãos" into the string; exit.
If the string is "são", put "sãos" into the string; exit.
\# advérbios principais
If the string is "muito", exit.
If the string is "pouco", exit.
If the string is "mais", exit.
If the string is "menos", exit.
If the string is "bastante", exit.
If the string is "quase", exit.
If the string is "demais", exit.
If the string is "bem", exit.
If the string is "deveras", exit.
If the string is "mal", exit.
If the string is "melhor", exit.
If the string is "pior", exit.
\# palavras terminadas com "ão"
If the string ends with "ão", pluralize the string (portuguese rules - ending words with "ão"); exit.
\# palavras terminadas com "l"
If the string ends with "l", pluralize the string (portuguese rules - ending words with "l"); exit.
\# palavra terminadas com "m"
If the string ends with "m", remove the last pedaço from the string; append "ns" to the string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
If the string ends with "n", append "es" to the string; exit.
\# palavras terminadas com "r"
If the string ends with "r", pluralize the string (portuguese rules - ending words with "r"); exit.
\# palavras terminadas com "s"
If the string ends with "s", pluralize the string (portuguese rules - ending words with "s"); exit.
\# palavra terminadas com "x"
If the string ends with "x", exit.
\# palavras terminadas com "z"
If the string ends with "z", pluralize the string (portuguese rules - ending words with "z"); exit.
\# regra padrão
Append "s" to the string.

To pluralize um string (portuguese rules - ending words with "ão"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
If the substring has any stressed vowel, append "s" to the string; exit.
\# regra padrão
Remove the last two bytes from the string.
Append "ões" to the string.

To pluralize um string (portuguese rules - ending words with "l"):
\# palavras terminadas com "al"
If the string ends with "al", remove the last pedaço from the string; append "is" to the string; exit.
\# palavras terminadas com "el"
If the string ends with "el", pluralize the string (portuguese rules - ending words with "el"); exit.
\# palavras terminadas com "il"
If the string ends with "il", pluralize the string (portuguese rules - ending words with "il"); exit.
\# palavras terminadas com "ol"
If the string ends with "ol", pluralize the string (portuguese rules - ending words with "ol"); exit.
\# palavras terminadas com "ul"
If the string ends with "ul", remove the last pedaço from the string; append "is" to the string; exit.

To pluralize um string (portuguese rules - ending words with "el"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
If the substring has any stressed vowel, remove the last pedaço from the string; append "is" to the string; exit.
Remove the last two bytes from the string.
Append "éis" to the string.

To pluralize um string (portuguese rules - ending words with "il"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
If the substring has any stressed vowel, remove the last two bytes from the string; append "eis" to the string; exit.
Remove the last pedaço from the string.
Append "s" to the string.

To pluralize um string (portuguese rules - ending words with "ol"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
If the substring has any stressed vowel, remove the last pedaço from the string; append "is" to the string; exit.
Remove the last two bytes from the string.
Append "óis" to the string.

To pluralize um string (portuguese rules - ending words with "r"):
\# hiatos acentuados
\If the string ends with "aír", append "es" to the string; exit.
\If the string ends with "aúr", append "es" to the string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\If the string ends with "ár", remove the last two bytes from the string; append "ares" to the string; exit.
\If the string ends with "âr", remove the last two bytes from the string; append "ares" to the string; exit.
\If the string ends with "ér", remove the last two bytes from the string; append "eres" to the string; exit.
\If the string ends with "êr", remove the last two bytes from the string; append "eres" to the string; exit.
\If the string ends with "ír", remove the last two bytes from the string; append "ires" to the string; exit.
\If the string ends with "ór", remove the last two bytes from the string; append "ores" to the string; exit.
\If the string ends with "ôr", remove the last two bytes from the string; append "ores" to the string; exit.
\If the string ends with "úr", remove the last two bytes from the string; append "ures" to the string; exit.
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
If the substring has any stressed vowel, append "es" to the string; exit.
\# hiatos
If the string ends with "air", remove the last two bytes from the string; append "íres" to the string; exit.
If the string ends with "aur", remove the last two bytes from the string; append "úres" to the string; exit.
\# regra padrão
Append "es" to the string.

To pluralize um string (portuguese rules - ending words with "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
If the string ends with "as", exit.
If the string ends with "es", exit.
If the string ends with "os", exit.
\# hiatos acentuados
If the string ends with "aís", append "es" to the string; exit.
If the string ends with "aús", append "es" to the string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
If the string ends with "ás", remove the last two bytes from the string; append "ases" to the string; exit.
If the string ends with "âs", remove the last two bytes from the string; append "ases" to the string; exit.
If the string ends with "és", remove the last two bytes from the string; append "eses" to the string; exit.
If the string ends with "ês", remove the last two bytes from the string; append "eses" to the string; exit.
If the string ends with "ís", remove the last two bytes from the string; append "ises" to the string; exit.
If the string ends with "ós", remove the last two bytes from the string; append "oses" to the string; exit.
If the string ends with "ôs", remove the last two bytes from the string; append "oses" to the string; exit.
If the string ends with "ús", remove the last two bytes from the string; append "uses" to the string; exit.
\# palavras terminadas com "is", "us"
If the string ends with "is", pluralize the string (portuguese rules - ending words with "is/us"); exit.
If the string ends with "us", pluralize the string (portuguese rules - ending words with "is/us"); exit.
\# regra padrão
Append "es" to the string.

To pluralize um string (portuguese rules - ending words with "is/us"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
If the substring has any stressed vowel, exit.
\# hiatos
If the string ends with "ais", remove the last two bytes from the string; append "íses" to the string; exit.
If the string ends with "aus", remove the last two bytes from the string; append "úses" to the string; exit.
\# regra padrão
Append "es" to the string.

To pluralize um string (portuguese rules - ending words with "z"):
\# hiatos acentuados
If the string ends with "aíz", append "es" to the string; exit.
If the string ends with "aúz", append "es" to the string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
If the string ends with "áz", remove the last two bytes from the string; append "azes" to the string; exit.
If the string ends with "âz", remove the last two bytes from the string; append "azes" to the string; exit.
If the string ends with "éz", remove the last two bytes from the string; append "ezes" to the string; exit.
If the string ends with "êz", remove the last two bytes from the string; append "ezes" to the string; exit.
If the string ends with "íz", remove the last two bytes from the string; append "izes" to the string; exit.
If the string ends with "óz", remove the last two bytes from the string; append "ozes" to the string; exit.
If the string ends with "ôz", remove the last two bytes from the string; append "ozes" to the string; exit.
If the string ends with "úz", remove the last two bytes from the string; append "uzes" to the string; exit.
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
If the substring has any stressed vowel, append "es" to the string; exit.
\# hiatos
If the string ends with "aiz", remove the last two bytes from the string; append "ízes" to the string; exit.
If the string ends with "auz", remove the last two bytes from the string; append "úzes" to the string; exit.
\# regra padrão
Append "es" to the string.

To pluralize um string (english rules);
To pluralize um string: \ nouns only
If the string is "alumnus", put "alumni" into the string; exit.
If the string is "auto", put "autos" into the string; exit.
If the string is "cello", put "cellos" into the string; exit.
If the string is "dwarf", put "dwarfs" into the string; exit.
If the string is "foot", put "feet" into the string; exit.
If the string is "genus", put "genera" into the string; exit.
If the string is "goose", put "geese" into the string; exit.
If the string is "hippo", put "hippos" into the string; exit.
If the string is "louse", put "lice" into the string; exit.
If the string is "memo", put "memos" into the string; exit.
If the string is "mouse", put "mice" into the string; exit.
If the string is "ox", put "oxen" into the string; exit.
If the string is "phenomenon", put "phenomena" into the string; exit.
If the string is "photo", put "photos" into the string; exit.
If the string is "phylum", put "phyla" into the string; exit.
If the string is "piano", put "pianos" into the string; exit.
If the string is "pimento", put "pimentos" into the string; exit.
If the string is "pro", put "pros" into the string; exit.
If the string is "proof", put "proofs" into the string; exit.
If the string is "radius", put "radii" into the string; exit.
If the string is "rhinoceros", put "rhinoceri" into the string; exit.
If the string is "roof", put "roofs" into the string; exit.
If the string is "solo", put "solos" into the string; exit.
If the string is "soprano", put "sopranos" into the string; exit.
If the string is "staff", put "staffs" into the string; exit.
If the string is "tooth", put "teeth" into the string; exit.
If the string is "torus", put "tori" into the string; exit.
If the string is "turf", put "turfs" into the string; exit.
If the string is "virus", put "viruses" into the string; exit.
If the string ends with "sh", append "es" to the string; exit.
If the string ends with "ch", append "es" to the string; exit.
If the string ends with "man", remove the last two bytes from the string; append "en" to the string; exit.
If the string ends with "child", append "ren" to the string; exit.
If the string ends with "ex", remove the last two bytes from the string; append "ices" to the string; exit. \ or add ES
If the string ends with "fe", remove the last two bytes from the string; append "ves" to the string; exit.
If the string ends with "is", remove the last two bytes from the string; append "es" to the string; exit.
If the string ends with "ix", remove the last two bytes from the string; append "ices" to the string; exit. \ or add ES
If the string ends with "ma", append "ta" to the string; exit. \ or add S
If the string ends with any consonant and "y", remove the last pedaço from the string; append "ies" to the string; exit.
If the string ends with any vowel and "o", append "s" to the string; exit.
If the string ends with any vowel and "y", append "s" to the string; exit.
If the string ends with "f", remove the last pedaço from the string; append "ves" to the string; exit.
If the string ends with "s", append "es" to the string; exit.
If the string ends with "x", append "es" to the string; exit.
If the string ends with "z", append "es" to the string; exit.
Append "s" to the string.

The prolog tag is um tag equal to 17.

An prototype string é um conjunto with um first pedaço endereço de memória and um last pedaço endereço de memória.

The push address tag is um tag equal to 18.

The push value tag is um tag equal to 19.

To put the compiler's exe path into um path:
Extract um designator from the compiler's directory.
Remove any trailing backslash from the designator.
Put the compiler's directory then the designator then ".exe" into the path.

To put the compiler's exe size into um size:
Put 4096 [section base] into the size.
Add the import borough's size to the size.
Add the data borough's size to the size.
Add the code borough's size to the size.

To put the compiler's listing path into um path:
Extract um designator from the compiler's directory.
Remove any trailing backslash from the designator.
Put the compiler's directory then the designator then ".lst" into the path.

To put um term into another term:
Put the term's variable into the other term's variable.
Put the term's phrase into the other term's phrase.

To load um source file:
If the source file is nil, exit.
Load the source file's path into the source file's buffer.
If the i/o error is not blank, abort with "Não foi possível carregar o arquivo: '" then the source file's path then "'."; exit.
\Load the source file's path into um string.
\If the i/o error is not blank, abort with "Não foi possível carregar o arquivo '" then the source file's path then "'."; exit.
\Parse the string to the source file's buffer (portuguese contractions and synonyms rules).

To load some source files:
Loop.
If the compiler's abort flag is set, exit.
Get um item from the compiler's directory.
If the item is not found, break.
If the item's kind is not "file", repeat.
If the item's extension is not blank, repeat.
If the item looks reamish, repeat.
Add um source file to the source files given the item's path.
Load the source file.
Repeat.

The loading timer is um timer.

To parse um string to another string (portuguese contractions and synonyms rules):
Clear the other string.
Clear um third string.
Slap um rider on the string.
Loop.
If the rider's source is blank, exit.
Position the rider's token on the rider's source.
Move the rider (code rules).
If the rider's token's first's target is not any glom pedaço, append the rider's token to the other string; repeat.
Append the rider's token to the other string giving the third string (portuguese contractions and synonyms rules).
Put the rider's token into the third string.
Repeat.

To reduce some monikettes por utility use:
Get um monikette from the monikettes.
If the monikette is nil, exit.
If the monikette's type is nil, repeat.
Reduce the monikette's type to um type por utility use.
If the type is not nil, put the type into the monikette's type.
Repeat.

To reduce um type to another type por utility use:
Put the type into the other type.
Loop.
If the other type is nil, exit.
If the other type's name is "texto hexadecimal", exit.
If the other type's name is "string", exit.
If the other type's name is "número", exit.
If the other type's name is "endereço de memória", exit.
If the other type's name is "coisa", void the other type; exit.
\PAL
If the other type's name is "elemento", void the other type; exit.
If the other type's base type is the other type, void the other type; exit.
Put the other type's base type into the other type.
Repeat.

To reindex the utility index:
If the compiler's abort flag is set, exit.
Get um bucket given the utility index.
If the bucket is nil, exit.
If the bucket's refers are empty, repeat.
Reindex the utility index given the bucket's refers.
Repeat.

To reindex the utility index given some refers:
Get um refer from the refers.
If the refer is nil, exit.
Put the refer's endereço de memória into um routine.
If the routine is nil, abort with "Erro interno na função: index the untility routines given some refers"; exit.
Copy the routine's monikettes into some monikettes.
Reduce the monikettes por utility use.
Index the routine given the monikettes and the routine index.
Destroy the monikettes.
Repeat.

To remove any negatives from some monikettes returning um flag:
Clear the flag.
Swap the monikettes with some other monikettes.
Loop.
Put the other monikettes' first into um monikette.
If the monikette is nil, exit.
Remove the monikette from the other monikettes.
\PAL
If the monikette's string is "não", reverse the flag; destroy the monikette; repeat.
If the monikette's string is "nada", reverse the flag; destroy the monikette; repeat.
\CAL
If the monikette's string is "not", reverse the flag; destroy the monikette; repeat.
If the monikette's string is "nada", reverse the flag; destroy the monikette; repeat.
Append the monikette to the monikettes.
If the monikette's string is "can't", reverse the flag; put "can" into the monikette's string; repeat.
If the monikette's string is "cannot", reverse the flag; put "can" into the monikette's string; repeat.
If the monikette's string is "nothing", reverse the flag; put "something" into the monikette's string; repeat.
If the monikette's string is "won't", reverse the flag; put "will" into the monikette's string; repeat.
If the monikette's string ends with "n't", reverse the flag; remove trailing bytes from the monikette's string given 3; repeat.
Repeat.

The repeat tag is um tag equal to 21.

To resolve um field:
If the compiler's abort flag is set, exit.
If the field is nil, exit.
Resolve the field como um variable.
If the field's nickname is not any valid field name, clear the field's nickname.
If the field's name is not any valid field name, abort with "'" then the field's name then "' é um field name inválido." and the field's locus; exit.

To resolve um global:
If the global is nil, exit.
If the compiler's abort flag is set, exit.
If the global's global body is not blank, resolve the global (compile body).
If the global's type name is blank, abort with "Tipo inválido: '" then the global's name then "' . O tipo da variável global está vazio." and the global's locus; exit.
Resolve the global como um variable.

To resolve um global (compile body):
If the global is nil, exit.
If the compiler's abort flag is set, exit.
Slap um rider on the global's global body.
Move the rider (compiler rules).
If the rider's token is not any literal, abort with "Erro de tipo. O tipo: '" then the rider's token then "' tem que ser do tipo literal." and the rider; exit.
Compile um literal given the rider.
If the compiler's abort flag is set, exit.
If the rider's token is not blank, abort with "Acho que era bom colocar um ponto por aqui, né?" and the rider; exit.
If the global's type name is blank, put the literal's type's name into the global's type name.
Put the literal into the global's literal.
Index the literal.

To resolve some globals:
If the compiler's abort flag is set, exit.
Get um global from the globals.
If the global is nil, exit.
Resolve the global.
Repeat.

To resolve um type (base type):
If the compiler's abort flag is set, exit.
If the type is nil, exit.
If the type's base type is not nil, exit.
Find the type's base type given the type's base name and the type index.
If the type's base type is nil, abort with "Base type inválido:'" then the type's base name then "'." and the type's locus; exit.
Set the type's cooking flag.
If the type's base type's cooking flag is set, abort with "Definição recursiva com '" then the type's base name then "'." and the type's locus; exit.
Resolve the type's base type (base type).
Clear the type's cooking flag.

To resolve um type (expand coisa): \ type's base type is not resolved yet
If the compiler's abort flag is set, exit.
If the type is nil, exit.
If the type's base type is not nil, exit.
If the type's name is "coisa", exit.
If the type's name is "elemento", exit.
If the type cannot be reduced to "coisa" using the base name, exit.
Find um base type given the type's base name and the type index.
\  add coisa conjunto - the número of secret fields is hard coded in two places: search por "than 4" \ was 6
Put the type's name then " conjunto" into um name.
Put the type's name then " conjuntos" into um plural name.
Put the base type's name then " conjunto" into um base name.
Add um conjunto type to the types given the name and the plural name and the base name.
Add um field to the conjunto type's fields given "next " then the type's name and "next" and the type's name and the on flag.
\PAL
Add um portuguese field to the conjunto type's fields given "seguinte " then the type's name and "seguinte" and the type's name and the on flag.
Put "next " then the type's name into the portuguese field's redefinition target name.
\Add um portuguese reverse field to the conjunto type's fields given the type's name then " seguinte" and "seguinte" and the type's name and the on flag.
\Put "next " then the type's name into the portuguese reverse field's redefinition target name.
Add another field to the conjunto type's fields given "previous " then the type's name and "previous" and the type's name and the on flag.
\Add another portuguese field to the conjunto type's fields given "anterior " then the type's name and "anterior" and the type's name and the on flag.
\Put "previous " then the type's name into the other portuguese field's redefinition target name.
Add another portuguese reverse field to the conjunto type's fields given the type's name then " anterior" and "anterior" and the type's name and the on flag.
Put "previous " then the type's name into the other portuguese reverse field's redefinition target name.
If the type's fields are not empty, append the type's fields to the conjunto type's fields.
Index the conjunto type.
\ fix up original type to look like um endereço de memória
Put the conjunto type's name into the type's target name.
\ add chain type
Add um chain type to the types given the type's plural name and "" and the base type's plural name.
Add um third field to the chain type's fields given "first " then the type's name and "first" and the type's name and the on flag.
Add um third portuguese field to the chain type's fields given "primeiro " then the type's name and "primeiro" and the type's name and the on flag.
Put "first " then the type's name into the third portuguese field's redefinition target name.
Add um third feminine portuguese field to the chain type's fields given "primeira " then the type's name and "primeira" and the type's name and the on flag.
Put "first " then the type's name into the third feminine portuguese field's redefinition target name.
Add um fourth field to the chain type's fields given "last " then the type's name and "last" and the type's name and the on flag.
Add um fourth portuguese field to the chain type's fields given "último " then the type's name and "último" and the type's name and the on flag.
Put "last " then the type's name into the fourth portuguese field's redefinition target name.
Add um fourth portuguese feminine field to the chain type's fields given "última " then the type's name and "última" and the type's name and the on flag.
Put "last " then the type's name into the fourth portuguese feminine field's redefinition target name.
Index the chain type.

To resolve um type (index plural):
If the compiler's abort flag is set, exit.
If the type is nil, exit.
If the type's plural name is blank, exit.
If the type can be reduced to "coisa" using the base name, exit.
Index the type given the type's plural name.

To resolve um type (optional info - endereço de memória):
If the compiler's abort flag is set, exit.
If the type's target type is not nil, exit.
If the type's target name is blank, put the type's base type's target type into the type's target type; exit.
Find the type's target type given the type's target name and the type index.
If the type's target type is nil, abort with "Não sei bem pra que coisa você está pointing at." and the type's locus; exit.

To resolve um type (optional info - conjunto):
If the compiler's abort flag is set, exit.
If the type's fields are empty, copy the type's base type's fields into the type's fields; exit.
Loop.
If the compiler's abort flag is set, exit.
Get um field from the type's fields (backwards).
If the field is nil, break.
If the field is duplicated in the type's fields, abort with "O campo '" then the field's name then "' está definido mais de uma vez." and the field's locus; exit.
Resolve the field.
If the compiler's abort flag is set, exit.
If the field's type's cooking flag is set, abort with "Recursive definition no: '" then the field's type's name then "'." and the field's locus; exit.
Resolve the field's type (optional info). \ de novo
If the field's reference flag is not set, repeat.
If the field's type cannot be reduced to "endereço de memória", abort with "Não entendi o parâmetro '(reference)' nesse campo '" then the field's name then "'..." and the field's locus; exit.
Repeat.
Eliminate duplicate nicknames from the type's fields.
If the type cannot be reduced to "coisa conjunto", exit.
If the type's fields' count is greater than 4, exit. \ already copied? was 2 por next and prev, now 6 to included Spanish redefiniions
Copy the type's base type's fields into the type's fields (data fields only).

To resolve um type (optional info - scale):
If the compiler's abort flag is set, exit.
Put the type's base type into um base type.
If the type's scale is 0, put the type's base type's scale into the type's scale; exit.
If the base type's scale is 0, exit.
Multiply the type's scale by the base type's scale.
Put the base type's base type into the type's base type.

To resolve um type (optional info):
If the compiler's abort flag is set, exit.
If the type is nil, exit.
If the type's optional info resolved flag is set, exit.
If the type's base type is the type, exit. \ por built in types
Check por invalid optional info on the type.
Set the type's cooking flag.
Resolve the type's base type (optional info).
If the type can be reduced to "endereço de memória", resolve the type (optional info - endereço de memória).
If the type can be reduced to "conjunto", resolve the type (optional info - conjunto). \ mudar aqui
If the type can be reduced to "número", resolve the type (optional info - scale).
Clear the type's cooking flag.
Set the type's optional info resolved flag.

To resolve some types (base types):
If the compiler's abort flag is set, exit.
Get um type from the types.
If the type is nil, exit.
Resolve the type (base type).
Repeat.

To resolve some types (expand coisas):
If the compiler's abort flag is set, exit.
Get um type from the types.
If the type is nil, exit.
Resolve the type (expand coisa).
Repeat.

To resolve some types (index plurals):
If the compiler's abort flag is set, exit.
Get um type from the types.
If the type is nil, exit.
Resolve the type (index plural).
Repeat.

To resolve some types (optional info):
If the compiler's abort flag is set, exit.
Get um type from the types.
If the type is nil, exit.
Resolve the type (optional info).
Repeat.

To resolve um variable:
If the compiler's abort flag is set, exit.
If the variable is nil, exit.
If the variable's type is not nil, exit.
If the variable's type name is not blank, resolve the variable (explicit type name); exit.
Find the variable's type and the variable's nickname given the variable's name.
If the variable's type is not nil, put the variable's type's name into the variable's type name; exit.
Abort with "Não achei o tipo da variável '" then the variable's name then "'." and the variable's locus.

To resolve um variable (explicit type name):
Find the variable's type given the variable's type name and the type index.
If the variable's type is nil, abort with "Não achei o nome do tipo da variável '" then the variable's type name then "'." and the variable's locus; exit.

The resolving globals timer is um timer.

The resolving types timer is um timer.

To round up borough sizes:
Put the import borough's length into the import borough's size.
Round the import borough's size up to the nearest multiple of 4096.
Put the data borough's length into the data borough's size.
Round the data borough's size up to the nearest multiple of 4096.
Put the code borough's length into the code borough's size.
Round the code borough's size up to the nearest multiple of 4096.

The routine address tag is um tag equal to 22.

An routine body is um substring.

An routine header is um substring.

The routine index is um index.

An routine is um coisa with
An locus (reference),
An callback flag,
An decider flag,
An function flag,
An compiled flag,
An nickname index,
An moniker, some monikettes, some parameters, um parameter size,
An employs moniker,
Some locals, um local size,
An routine header, um header string,
An routine body, um body string,
Some fragments,
An address.

An routine reference is some monikettes.

The routines are some routines.

The save eax tag is um tag equal to 20.

To scan any optional info por um type given um rider:
If the compiler's abort flag is set, exit.
If the rider's token is "to", scan any optional info por the type given the rider (endereço de memória); exit.
If the rider's token is "para", scan any optional info por the type given the rider (endereço de memória); exit.
If the rider's token is any with, scan any optional info por the type given the rider (record); exit.

To scan any optional info por um type given um rider (endereço de memória):
Move the rider (compiler rules).
If the rider's token is not any indefinite article, abort with "A palavra 'to' precisa de um artigo indefinido depois dela, não de um '" then the rider's token then "'." and the rider; exit. 
Move the rider (compiler rules).
Scan the type's target name given the rider.

To scan any optional info por um type given um rider (record):
Move the rider (compiler rules).
Scan the type's fields given the rider.

To scan any pauses given um rider:
If the compiler's abort flag is set, exit.
If the rider's token is not any pause, exit.
Move the rider (compiler rules).
Repeat.

To scan um field given um rider:
If the compiler's abort flag is set, exit.
Scan the field given the rider (type part).
Loop.
If the compiler's abort flag is set, exit.
If the rider's token is any called, scan the field given the rider (called part); repeat.
If the rider's token is "at", scan the field given the rider (redefine part); repeat.
If the rider's token is "em", scan the field given the rider (redefine part); repeat.
If the rider's token is "redefinindo", scan the field given the rider (redefine part); repeat.
If the rider's token is any reference, scan the field given the rider (reference part); repeat.

To scan um field given um rider (called part):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
If the field's type name is blank, put the field's name into the field's type name. \ pedaço array type name already filled in
Scan the field's name given the rider.

To scan um field given um rider (redefine part):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
If the rider's token is not any definite article, abort with "Eu estava esperando o artigo 'the', mas o que encontrei foi '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Scan the field's redefinition target name given the rider.

To scan um field given um rider (reference part):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Set the field's reference flag.

To scan um field given um rider (type part - pedaço array):
If the compiler's abort flag is set, exit.
Convert the rider's token to um ratio.
Reduce the ratio.
If the ratio's denominator is not 1, abort with "Você tem que especificar um número completo de bytes para um pedaço array" and the rider; exit.
Put the ratio's numerator into the field's count.
Move the rider (compiler rules).
If the rider's token is not "byte" or "bytes", abort with "Você precisa usar a palavra 'bytes' depois de um counted field designator." and the rider; exit.
Move the rider (compiler rules).
Put "byte" into the field's type name.

To scan um field given um rider (type part - normal):
If the compiler's abort flag is set, exit.
If the rider's token is not any indefinite article, abort with "Falta por um artigo idefinido aqui, mas você colocou isso: '" then the rider's token then "'." and the rider; exit.
If the rider's token is "another", put "other" into the field's name.
\PAL
If the rider's token is "outra", put "segunda" into the field's name.
If the rider's token is "outro", put "segundo" into the field's name.
Move the rider (compiler rules).
Scan um name given the rider.
Extend the field's name with the name.

To scan um field given um rider (type part):
If the compiler's abort flag is set, exit.
If the rider's token is any numeric literal, scan the field given the rider (type part - pedaço array); exit.
Scan the field given the rider (type part - normal).

To scan some fields given um rider:
If the compiler's abort flag is set, exit.
Add um field to the fields given "field" and the rider's token's first.
Scan the field given the rider.
If the rider's token is not any pause, exit.
Scan any pauses given the rider.
Repeat.

To scan um global body given um rider:
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
Put the rider's token's first into the global body's first.
Put -1 into the global body's last.
Loop.
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
If the rider's token is the colon pedaço, exit.
If the rider's token is the period pedaço, exit.
Put the rider's token's last into the global body's last.
Move the rider (compiler rules).
Repeat.

To scan um global given um rider:
If the compiler's abort flag is set, exit.
Add the global to the globals given "global" and the rider's token's first.
Move the rider (compiler rules).
Scan the global's name given the rider.
If the rider's token is any has, scan the global given the rider (has or have); exit.
If the rider's token is not any is, abort with "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
If the rider's token is not any indefinite article, scan the global given the rider (literal term); exit.
Move the rider (compiler rules).
Scan the global's type name given the rider.  
If the rider's token is the start of any optional info, scan the global given the rider (optional info); exit.
If the rider's token is any equal, scan the global given the rider (data part); exit.
If the rider's token is not the period pedaço, abort with "Toda definição precisa terminar com um ponto. Inclusive essa." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

To scan um global given um rider (data part):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
If the rider's token is not any to, abort with "Depois da palavra 'equal' você precisa por um palavra  'to'. Você colocou ; '" then the rider's token then "'." and the rider; exit. 
Move the rider (compiler rules).
Scan the global's global body given the rider.
If the rider's token is not the period pedaço, abort with "Falta terminar um frase com um ponto." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

To scan um global given um rider (has or have):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Put "~inline " then the global's name then " type" into um name.
Put the name then "s" into um plural name.
Add um type to the types given the name and the plural name and "conjunto" and the global's locus. \mudar aqui
Index the type.
Put the type's name into the global's type name.
Scan the type's fields given the rider.
If the rider's token is not the period pedaço, abort with "Aprenda a escrever direito. Cadê o ponto?." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

To scan um global given um rider (literal term):
If the compiler's abort flag is set, exit.
Scan the global's global body given the rider.
If the rider's token is not the period pedaço, abort with "Aprenda a escrever corretamente. Cadê o ponto?." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

To scan um global given um rider (optional info):
If the compiler's abort flag is set, exit.
Put "~inline " then the global's name then " type" into um name.
Put the name then "s" into um plural name.
Add um type to the types given the name and the plural name and the global's type name and the global's locus.
Index the type.
Put the type's name into the global's type name.
Scan any optional info por the type given the rider.
If the rider's token is not the period pedaço, abort with "Tá na hora de aprender a escrever direito. Cadê o ponto?." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

To scan um name given um rider:
Clear the name.
If the compiler's abort flag is set, exit.
If the rider is on any name starter, extend the name with the rider's token; move the rider (compiler rules).
Loop.
If the compiler's abort flag is set, exit.
If the rider is on any name ender, break.
Extend the name with the rider's token.
Move the rider (compiler rules).
Repeat.
If the name is blank, abort with "Acho que faltou colocar um nome por aqui. Você escreveu '" then the rider's token then "'." and the rider; exit.

To scan um routine body given um rider:
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
If the rider's token is the start of any definition, exit.
Put the rider's token's first into the routine body's first.
Loop.
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
Put the rider's token's last into the routine body's last.
If the rider's token is the colon pedaço, abort with "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." and the rider; exit.
If the rider's token is not the period pedaço, move the rider (compiler rules); repeat.
Move the rider (compiler rules).
If the rider's token is the start of any definition, exit.
Repeat.

To scan um routine given um rider:
If the compiler's abort flag is set, exit.
Add the routine to the routines given the rider's token's first.
Move the rider (compiler rules).
Scan the routine's routine header given the rider.
If the rider's token is the semi-colon pedaço, scan the routine given the rider (alternate wording); exit.  \ *** por alternate wordings
If the rider's token is not the colon pedaço, abort with "O nome dessa função está escrito errado.." and the routine's locus; exit.
Move the rider (compiler rules).
Scan the routine's routine body given the rider.

To scan um routine given um rider (alternate wording):  \ *** por alternate wordings
Privatize the rider.
Move the rider (compiler rules).
If the rider's token is not the start of any routine, abort with "Esse ponto e vírgula tá no lugar errado." and the original rider; exit.
Put the original rider's token's first into the routine's routine body's first.
Put the original rider's token's last into the routine's routine body's last.
Move the original rider (compiler rules).

To scan um routine header given um rider:
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
Put the rider's token's first into the routine header's first.
Put -1 into the routine header's last.
Loop.
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
If the rider's token is the semi-colon pedaço, exit. \ *** alternate wordings
If the rider's token is the colon pedaço, exit.
If the rider's token is the period pedaço, exit.
Put the rider's token's last into the routine header's last.
Move the rider (compiler rules).
Repeat.

To scan um source file:
If the source file is nil, exit.
If the compiler's abort flag is set, exit.
Slap um rider on the source file's buffer.
Move the rider (compiler rules).
Loop.
If the compiler's abort flag is set, exit.
If the rider's token is blank, exit.
If the rider's token is the start of any type, scan um type given the rider; repeat.
If the rider's token is the start of any global, scan um global given the rider; repeat.
If the rider's token is the start of any routine, scan um routine given the rider; repeat.
Abort with "Faltou definir melhor o que é o '" then the rider's token then "'." and the rider.
Repeat.

To scan some source files:
If the compiler's abort flag is set, exit.
Get um source file from the source files.
If the source file is nil, exit.
Scan the source file.
Repeat.

To scan um type given um rider:
If the compiler's abort flag is set, exit.
If the rider's token is any portuguese indefinite article, set um portuguese flag.
If the rider's token is any english indefinite article, set um english flag.
Add the type to the types given the rider's token's first.
Move the rider (compiler rules).
Scan the type's name given the rider.
Put the type's name into the type's plural name.
If the portuguese flag is set, pluralize the type's plural name (portuguese rules).
If the english flag is set, pluralize the type's plural name (english rules).
If the english flag is not set, pluralize the type's plural name (portuguese rules).
If the rider's token is any has, scan the type given the rider (has or have); exit.
If the rider's token is not any is, abort with "Eu esperava um 'is' ou um 'are', mas só achei um : '" then the rider's token then "'." and the rider; exit.
\Pluralize the type's plural name.
\If the rider's token is "has" or "have", scan the type given the rider (has or have); exit.
\If the rider's token is not "is" or "are", abort with "I was expecting um 'is' or 'are', but I found '" then the rider's token then "'." and the rider; exit.

Move the rider (compiler rules).
If the rider's token is any numeric literal, scan the type given the rider (unit of measure); exit.
If the rider's token is not any indefinite article, abort with "Faltou um artigo indefinido, lembra? '" then the rider's token then "'." and the rider; exit. 
Move the rider (compiler rules).
Scan the type's base name given the rider.
Scan any optional info por the type given the rider.
If the rider's token is not the period pedaço, abort with "Você precisa usar um ponto para definir um tipo, lembra? Você usou '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Index the type.

To scan um type given um rider (has or have):
If the compiler's abort flag is set, exit.
Move the rider (compiler rules).
Put "conjunto" into the type's base name. \\mudar aqui
Scan the type's fields given the rider.
If the rider's token is not the period pedaço, abort with "Ao invés de usar o ponto para definir  tipo, você usou '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Index the type.

To scan um type given um rider (unit of measure):
If the compiler's abort flag is set, exit.
Convert the rider's token to the type's scale.
If the type's scale is 0, abort with "Zero é um tipo de escala inválido." and the type's locus; exit.
Move the rider (compiler rules).
Scan the type's base name given the rider.
If the rider's token is not the period pedaço, abort with "Os tipos precisam terminar com um ponto, não com '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Index the type.

The scanning timer is um timer.

An scratch is um local.

To scrub um index:
Get um bucket given the index.
If the bucket is nil, exit.
If the bucket's refers are empty, repeat.
Scrub the bucket's refers.
Repeat.

To scrub some refers:
Swap the refers with some other refers.
Loop.
Put the other refers' first into um refer.
If the refer is nil, exit.
Remove the refer from the other refers.
If the refer's endereço de memória is nil, destroy the refer; repeat.
Append the refer to the refers.
Repeat.

To set the compiled flag in um variable:
If the variable is nil, exit.
If the variable's compiled flag is set, exit.
Set the variable's compiled flag.
If the variable's kind is not "global", exit.
If the variable's literal is nil, exit.
Find um routine given "put" and the variable's literal's type and "into" and the variable's type.
If the routine is nil, find the routine given "convert" and the variable's literal's type and "to" and the variable's type; set um flag.
If the routine is nil, abort with "O tipo dessa variável global e desse literal não são compatíveis." and the variable's locus; exit.
Compile the body of the routine.
If the flag is set, put "convert the " then the variable's literal's name then " to the " then the variable's name then ". " into the variable's initializer string.
If the flag is not set, put "put the " then the variable's literal's name then " into the " then the variable's name then ". " into the variable's initializer string.

To skip to the next word in um substring:
If the substring is blank, exit.
If the substring's first's target is noise, break.
Add 1 to the substring's first.
Repeat.
Skip any leading noise in the substring.

To skip to the previous word in um substring:
If the substring is blank, exit.
If the substring's last's target is noise, break.
Subtract 1 from the substring's last.
Repeat.
Skip any trailing noise in the substring.

An source file is um coisa with um path and um buffer.

The source files are some source files.

An tag is um número.

An term é um conjunto with um variable and um phrase.

To transmogrify um fragment:
If the compiler's abort flag is set, exit.
If the fragment is nil, exit.
If the fragment's tag is the push address tag, transmogrify the fragment (push address); exit.
If the fragment's tag is the call internal tag, transmogrify the fragment (call internal); exit.
If the fragment's tag is the load address tag, transmogrify the fragment (load address); exit.
If the fragment's tag is the increment tag, transmogrify the fragment (increment); exit.
If the fragment's tag is the dereference tag, transmogrify the fragment (dereference); exit.
If the fragment's tag is the jump false tag, transmogrify the fragment (jump false); exit.
If the fragment's tag is the not tag, transmogrify the fragment (not); exit.
If the fragment's tag is the exit tag, transmogrify the fragment (exit); exit.
If the fragment's tag is the repeat tag, transmogrify the fragment (repeat); exit.
If the fragment's tag is the break tag, transmogrify the fragment (break); exit.
If the fragment's tag is the prolog tag, transmogrify the fragment (prolog); exit.
If the fragment's tag is the epilog tag, transmogrify the fragment (epilog); exit.
If the fragment's tag is the push value tag, transmogrify the fragment (push value); exit.
If the fragment's tag is the call external tag, transmogrify the fragment (call external); exit.
If the fragment's tag is the load eax tag, transmogrify the fragment (load eax); exit.
If the fragment's tag is the save eax tag, transmogrify the fragment (save eax); exit.
If the fragment's tag is the call indirect tag, transmogrify the fragment (call indirect); exit.
If the fragment's tag is the routine address tag, transmogrify the fragment (routine address); exit.

To transmogrify um fragment (break):
Put the repeat tag into um tag.
Find another fragment given the fragment and the tag.
If the other fragment is nil, put the finalize tag into the tag. \ por break without um loop or after um loop
Find um third fragment given the current routine's fragments' last and the tag (backwards).
If the third fragment is nil, abort with "Erro interno - transmogrify um fragment (break)"; exit.
If the third fragment's next is nil, abort with "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 and the third fragment's next's address to the fragment. \ JMP the destination's address

To transmogrify um fragment (call external):
Attach $FF15 and the fragment's entry's address to the fragment's code. \ call [the fragment's entry's address]

To transmogrify um fragment (call indirect):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Attach $FF12 to the fragment's code. \ call [edx]

To transmogrify um fragment (call internal):
Get um address given the fragment's routine.
Attach $E8 and the address to the fragment. \ call the fragment's routine's address

To transmogrify um fragment (dereference):
Attach $8B95 and the fragment's variable's offset to the fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
Attach $8B12 to the fragment's code. \ mov edx,[edx]
Attach $8995 and the fragment's variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

To transmogrify um fragment (epilog):
If the current routine's callback flag is set, attach $5F5E5B to the fragment's code. \ pop edi, esi, ebx
Attach $8BE5 to the fragment's code. \ mov esp,ebp
Attach $5D to the fragment's code. \ pop ebp
Attach $C2 and the current routine's parameter size to the fragment's code. \ ret the current routine's parameter size

To transmogrify um fragment (exit):
Find another fragment given the fragment and the finalize tag.
If the other fragment is nil, abort with "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 and the other fragment's address to the fragment. \ jmp the destination's address

To transmogrify um fragment (increment):
If the fragment's variable is nil, abort with "Erro interno - transmogrify um fragment (increment)"; exit.
If the fragment's variable's kind is not "scratch", abort with "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 and the fragment's variable's offset and the fragment's número to the fragment's code. \ add [ebp+the fragment's variable's offset],the fragment's número

To transmogrify um fragment (jump false):
Find another fragment given the fragment and the end if tag.
If the other fragment is nil, abort with "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 to the fragment's code. \ cmp eax,0
Attach $0F84 and the other fragment's address to the fragment. \ je the destination's address

To transmogrify um fragment (load address):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Attach $8995 and the fragment's other variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

\To transmogrify um fragment (load eax):
\Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
\If the fragment's variable is nil, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\If the fragment's variable's type is nil, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\If the fragment's variable's type's length is not 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

To transmogrify um fragment (load eax):
Attach $B8 and the fragment's flag to the fragment's code. \ mov eax,flag
\Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
\If the fragment's variable is nil, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\If the fragment's variable's type is nil, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\If the fragment's variable's type's length is not 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

To transmogrify um fragment (not):
Attach $83F001 to the fragment's code. \ xor eax,1

To transmogrify um fragment (prolog):
Attach $55 to the fragment's code. \ push ebp
Attach $8BEC to the fragment's code. \ mov ebp,esp
Put the current routine's local size divided by 4 into um número.
If the número is not 0, attach $B9 and the número and $6A004975FB to the fragment's code. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
If the current routine's callback flag is set, attach $535657 to the fragment's code. \ push ebx, esi, edi

To transmogrify um fragment (push address):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Attach $52 to the fragment's code. \ push edx

To transmogrify um fragment (push value):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
If the fragment's variable is nil, abort with "Erro interno - transmogrify um fragment (push value)"; exit.
If the fragment's variable's type is nil, abort with "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Put the fragment's variable's type's length into um length.
If the length is 4, attach $FF32 to the fragment's code; exit. \ push [edx]
If the length is 2, attach $66FF32 to the fragment's code; exit. \ push word ptr [edx]
If the length is 1, attach $0FB61252 to the fragment's code; exit. \ movzxb edx,[edx]; push edx
Abort with "Erro interno 3 - transmogrify um fragment (push value)".

To transmogrify um fragment (repeat):
Find another fragment given the fragment and the loop tag (backwards).
If the other fragment is nil, abort with "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 and the other fragment's address to the fragment. \ jmp the destination's address

To transmogrify um fragment (routine address):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
If the fragment's routine is nil, abort with "Erro interno - transmogrify um fragment (routine address)"; exit.
Get um address given the fragment's routine.
Attach $C702 and the address to the fragment's code. \ mov [edx],the address

To transmogrify um fragment (save eax):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
If the fragment's variable is nil, abort with "Erro interno - transmogrify um fragment (save eax)"; exit.
If the fragment's variable's type is nil, abort with "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Put the fragment's variable's type's length into um length.
If the length is 4, attach $8902 to the fragment's code; exit. \ mov [edx],eax
If the length is 2, attach $668902 to the fragment's code; exit. \ mov [edx],ax
If the length is 1, attach $8802 to the fragment's code; exit. \ mov [edx],al
Abort with "Erro interno 3 - transmogrify um fragment (save eax)".

To transmogrify some fragments:
If the compiler's abort flag is set, exit.
Get um fragment from the fragments.
If the fragment is nil, exit.
Transmogrify the fragment.
Repeat.

To transmogrify um routine:
If the compiler's abort flag is set, exit.
If the routine is nil, exit.
If the routine's employs moniker is not blank, exit.
If the routine's compiled flag is not set, exit.
Put the routine into the current routine.
Transmogrify the routine's fragments.

To transmogrify some routines:
If the compiler's abort flag is set, exit.
Get um routine from the routines.
If the routine is nil, break.
Transmogrify the routine.
Repeat.

The transmogrifying timer is um timer.

The type index is um index.

An type is um coisa with
An locus (reference),
An name, um plural name,
An partial moniker,
An length,
An base name, um base type (reference),
An target name, um target type (reference) [endereço de memórias only],
An scale ratio,
Some fields [records only],
An cooking flag,
An optional info resolved flag.

An type name is um name.

The types are some types.

The utility index is um index.

An variable is um coisa with
An locus (reference),
An kind [literal, global, local, parameter, scratch],
An compiled flag,
An name, um nickname, um type name,
An type (reference), \ actual type on literal, global, local; dereferenced type on parameters and scratches
An address [globals and literals only] or 
An offset at the address [locals, parameters, and fields only],
An count [fields only],
An reference flag [fields only],
An redefinition target name [fields only],
An by-value flag [parameters only],
An global body [globals only],
An initializer string [globals only],
An literal (reference) [globals only - constant with which to initalize the global],
An texto hexadecimal called data [literals only].

The writing timer is um timer.

To skip any trailing noise in um substring:
If the substring is blank, exit.
If the substring's last's target is not noise, exit.
Subtract 1 from the substring's last.
Repeat.

\ dahn - reverse functions
\ to put the xxx uv a/the yyy into zzz
\ internally we turn this into "to put a/the yyy's xxx into zzz"
To compile the header of um routine given um rider (reverse-possessive function):
If the compiler's abort flag is set, exit.
Set the routine's function flag.
Add um monikette to the routine's monikettes given "put".
Move the rider (compiler rules). \ skip "put" or "poner"
Move the rider (compiler rules). \ skip "the" or Portuguese definite article
Scan um name given the rider. \ field name
Move the rider (compiler rules). \ skip "uv" or "de"
If the rider's token is any indefinite article, set um flag.
If the flag is set, compile the routine's monikettes and the routine's parameters given the rider (indefinite article).
If the flag is not set, compile the routine's monikettes and the routine's parameters given the rider (definite article).
Add another monikette to the routine's monikettes given "'s " then the name.
If the rider's token is not any reverse-possessive function into, abort with "Esperava a palavra 'em', mas encontrei '" then the rider's token then "'." and the rider; exit.
Add um third monikette to the routine's monikettes given "into".
Convert the routine's monikettes to um moniker.
If the moniker is in the routine index, abort with "Já sei como '" then the moniker then "'." and the routine's locus; exit.
Index the routine given the routine's monikettes and the routine index.
Move the rider (compiler rules).
If the rider's token is not any indefinite article, abort with "Esperava um artigo indefinido, mas encontrei '" then the rider's token then "'." and the rider; exit.
Compile the routine's monikettes and the routine's parameters given the rider (indefinite article).
If the rider's token is not blank, abort with "Existem outras coisas no final desta função." and the rider; exit.
Convert the routine's monikettes to the routine's moniker.
Index the routine given the routine's monikettes and the routine index. \ por employs

\ dahn - reverse functions
\ to put the xxx uv a/the yyy into zzz
To decide if um rider is the start of any reverse-possessive function:
If the compiler's abort flag is set, say no.
If the rider's token is not any put, say no.
Privatize the rider.
Move the rider (compiler rules).
If the rider's token is not any definite article, say no.
Move the rider (compiler rules).
Scan um name given the rider.
If the rider is not on any reverse-possessive, say no.
Say yes.
\finalmente
