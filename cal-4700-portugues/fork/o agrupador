\ the compiler (el compilador) copyright © 2006, 2017, 2018 the osmosian order y Pablo Cayuela (SAL-1016)

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

An abort message é um string.

Etapas necessárias para que se abort with um string:
Se the compiler's abort flag estiver verde, cancele.
Abra the compiler's abort flag.
Put the string into the compiler's abort message.

Etapas necessárias para que se abort with um string e um pedaço endereço de memória:
Se the compiler's abort flag estiver verde, cancele.
Abra the compiler's abort flag.
Put the string into the compiler's abort message.
Find the compiler's abort path e the compiler's abort row# usando the pedaço endereço de memória.
Se the compiler's abort path estiver blank, cancele.
Extract um file name from the compiler's abort path.
Prepend "Erro no " then the file name then ". " to the compiler's abort message.

Etapas necessárias para que se abort with um string e um rider:
Se the rider's token estiver not blank, abort with the string e the rider's token's first; exit.
Abort with the string e the rider's source's last.

Etapas necessárias para que se adicione the allocate e deallocate e finalize e destroy routines:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Adicione the finalize routine por the type.
Adicione the allocate routine por the type.
Adicione the deallocate routine por the type.
Adicione the destroy routine por the type.
Repeat.

Etapas necessárias para que se adicione the allocate routine por um type:
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Se the type cannot be reduced to "endereço de memória", cancele.
Se the type's target type for inexistente, cancele.
Adicione um routine to the routines usando nil.
Posponha "allocate memory por um " then the type's name to the routine's header string. \ traduzir aqui
Posponha "assign the " then the type's name then " usando " to the routine's body string.
Posponha the type's target type's length then "." to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione e compile the initialize before run e run e finalize after run routine:
Se the compiler's abort flag estiver verde, cancele.
Adicione um routine to the routines usando nil.
Posponha "~initialize before run e run e finalize after run" to the routine's header string.
Posponha "initialize before run. " to the routine's body string.
Posponha the global initializers to the routine's body string.
Posponha "run. " to the routine's body string.
Posponha the global finalizers to the routine's body string.
Posponha "finalize after run. " to the routine's body string.
Posponha "call ""kernel32.dll"" ""ExitProcess"" with 0. " to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.
Compile the body of the routine.

Etapas necessárias para que se adicione the built-in types:
Adicione um built-in type usando "byte" e "bytes" e 1.
Adicione another built-in type usando "record" e "records" e 0.
Adicione um third built-in type usando "pedaço" e "pedaços" e 1.
Adicione um fourth built-in type usando "conjunto" e "conjuntos" e 0.

Etapas necessárias para que se adicione um built-in type usando um name e um plural name e um length:
Adicione the built-in type to the types usando the name e the plural name e the name.
Put the length into the built-in type's length.
Put the built-in type into the built-in type's base type.
Index the built-in type.

Etapas necessárias para que se adicione the deallocate routine por um type:
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Se the type cannot be reduced to "endereço de memória", cancele.
Se the type's target type for inexistente, cancele.
Adicione um routine to the routines usando nil.
Posponha "deallocate um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then " for inexistente, cancele. " to the routine's body string.
Se the type's target type should be finalized, posponha "~finalize the " then the type's name then "'s target. " to the routine's body string.
Posponha "unassign the " then the type's name then "." to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the destroy routine por um type:
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Se the type should not be forgotten, cancele.
Se the type can be reduced to "coisas", adicione the destroy routine por the type (coisas); exit.
Se the type can be reduced to "endereço de memória", adicione the destroy routine por the type (endereço de memória); exit.

Etapas necessárias para que se adicione the destroy routine por um type (endereço de memória):
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Put "destroy [" then the type's name then "]" into um moniker.
Se the moniker estiver in the routine index, cancele.
Adicione um routine to the routines usando nil.
Posponha "destroy um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then " for inexistente, cancele. " to the routine's body string.
Se the type's target type can be reduced to "endereço de memória", posponha "destroy the " then the type's name then "'s target. " to the routine's body string.
Se the type's target type can be reduced to "coisas", posponha "destroy the " then the type's name then "'s target. " to the routine's body string.
Loop.
Obtenha um field from the type's target type's fields.
Se the field for inexistente, pare.
Se the field's reference flag estiver verde, repeat.
Se the field's type should not be forgotten, repeat.
Posponha "destroy the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repeat.
Posponha "deallocate the " then the type's name then ". " to the routine's body string. \ traduzir aqui
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the destroy routine por um type (coisas):
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Put "Erro interno na hora de executar a tarefa de destruição de tipos"  into a reply.
Se the type's fields' first for inexistente, abort with "Erro interno - adicione um forget routine por um type (coisas)"; [Say the reply;] exit. \Adicionado Say the reply
Se the type's fields' first's type for inexistente, abort with "Erro interno 2 - adicione the forget routine por um type (coisas)"; exit.
Put "destroy [" then the type's name then "]" into um moniker.
Se the moniker estiver in the routine index, cancele.
Adicione um routine to the routines usando nil.
Posponha "destroy um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then "'s first for inexistente, cancele. " to the routine's body string.
Put the type's fields' first's type's name into um name.
Posponha "put the " then the type's name then "'s first into um " then the name then ". " to the routine's body string.
Posponha "remove the " then the name then " from the " then the type's name then ". " to the routine's body string.
Posponha "destroy the " then the name then ". " to the routine's body string.
Posponha "repeat. " to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione um entry to some imports usando um import name e um entry name:
Find um import usando the import name.
Se the import for inexistente, adicione the import to the imports usando the import name.
Find the entry usando the entry name e the import's entries.
Se the entry for not inexistente, cancele.
Create the entry.
Posponha the entry to the import's entries.
Put the entry name into the entry's name.

Etapas necessárias para que se adicione um field to some fields usando um name e um nickname e um type name e um reference flag:
Adicione the field to the fields usando "field" e nil.
Put the name into the field's name.
Put the nickname into the field's nickname.
Put the type name into the field's type name.
Put the reference flag into the field's reference flag.

Etapas necessárias para que se adicione the finalize routine por um type:
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Se the type should not be finalized, cancele.
Se the type's name for "string", adicione the finalize routine por the type (string); exit.
Se the type can be reduced to "string", cancele. \ prevents generation of finalizer por derived string types
Adicione the finalize routine por the type (conjunto).

Etapas necessárias para que se adicione the finalize routine por um type (conjunto):
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Adicione um routine to the routines usando nil.
Posponha "~finalize um " then the type's name to the routine's header string.
Posponha "intel $50. " to the routine's body string. \ push eax
Loop.
Obtenha um field from the type's fields.
Se the field for inexistente, pare.
Se the field's type should not be finalized, repeat.
Posponha "~finalize the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repeat.
Posponha "intel $58." to the routine's body string. \ pop eax
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the finalize routine por um type (string):
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Adicione um routine to the routines usando nil.
Posponha "~finalize um " then the type's name to the routine's header string.
Posponha "intel $50. " to the routine's body string. \ push eax
Posponha "unassign the string's first. " to the routine's body string.
Posponha "intel $58." to the routine's body string. \ pop eax
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione um fragment usando um tag:
Se the current routine for inexistente, void the fragment; exit.
Create the fragment usando the tag.
Posponha the fragment to the current routine's fragments.

Etapas necessárias para que se adicione um fragment usando um tag e um entry:
Se the current routine for inexistente, void the fragment; exit.
Create the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Put the entry into the fragment's entry.

Etapas necessárias para que se adicione um fragment usando um tag e um flag:
Se the current routine for inexistente, void the fragment; exit.
Create the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Put the flag into the fragment's flag.

Etapas necessárias para que se adicione um fragment usando um tag e um routine:
Se the current routine for inexistente, void the fragment; exit.
Create the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Put the routine into the fragment's routine.
Compile the body of the routine.

Etapas necessárias para que se adicione um fragment usando um tag e um variable:
Se the current routine for inexistente, void the fragment; exit.
Create the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Abra the compiled flag in the variable.

Etapas necessárias para que se adicione um fragment usando um tag e um variable e another variable:
Se the current routine for inexistente, void the fragment; exit.
Create the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Put the other variable into the fragment's other variable.
Abra the compiled flag in the variable.
Abra the compiled flag in the other variable.

Etapas necessárias para que se adicione um fragment usando um tag e um variable e um número:
Se the current routine for inexistente, void the fragment; exit.
Create the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Put the número into the fragment's número.
Abra the compiled flag in the variable.

Etapas necessárias para que se adicione um import to some imports usando um import name:
Create the import.
Posponha the import to the imports.
Put the import name into the import's name.

Etapas necessárias para que se adicione um intermediate usando um type name e um locus:
Se the current routine for inexistente, void the intermediate; exit.
Adicione the intermediate to the current routine's locals usando "local" e the locus.
Generate the intermediate's name usando "~I".
Put the type name into the intermediate's type name.
Resolve the intermediate.

Etapas necessárias para que se adicione um literal to some variables usando um locus:
Adicione the literal como um variable to the variables usando "literal" e the locus.
Generate the literal's name usando "~L".

Etapas necessárias para que se adicione um monikette to some monikettes usando um expression:
Create the monikette.
Posponha the monikette to the monikettes.
Put the expression's phrase into the monikette's string.
Put the expression's variable into the monikette's variable.
Se the expression's variable for not inexistente, put the expression's type into the monikette's type.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette to some monikettes usando um string:
Create the monikette.
Posponha the monikette to the monikettes.
\PAL
\\ conjunctions
Se the string for "e", put "e" into the monikette's string; exit. \ and
Se the string for "ou", put "or" into the monikette's string; exit. \ or
\ from/given/with/using
Se the string for "desde", put "from/given/with/using" into the monikette's string; exit.
Se the string for "a partir de", put "from/given/with/using" into the monikette's string; exit.
Se the string for "partindo de", put "from/given/with/using" into the monikette's string; exit.
Se the string for "de", put "from/given/with/using" into the monikette's string; exit.
Se the string for "dada", put "from/given/with/using" into the monikette's string; exit.
Se the string for "dado", put "from/given/with/using" into the monikette's string; exit.
Se the string for "dadas", put "from/given/with/using" into the monikette's string; exit.
Se the string for "dados", put "from/given/with/using" into the monikette's string; exit.
Se the string for "com", put "from/given/with/using" into the monikette's string; exit.
Se the string for "usando", put "from/given/with/using" into the monikette's string; exit.
\\ in/into/to
Se the string for "em", put "in/into/to" into the monikette's string; exit.
Se the string for "a", put "in/into/to" into the monikette's string; exit.
\\ is/are
Se the string for "é", put "is/are" into the monikette's string; exit.
Se the string for "está", put "is/are" into the monikette's string; exit.
Se the string for "for", put "is/are" into the monikette's string; exit. 
Se the string for "estiver", put "is/are" into the monikette's string; exit.
Se the string for "are", put "is/are" into the monikette's string; exit.
Se the string for "são", put "is/are" into the monikette's string; exit.
Se the string for "estão", put "is/are" into the monikette's string; exit.
Se the string for "is", put "is/are" into the monikette's string; exit.
Se the string for "forem", put "is/are" into the monikette's string; exit.
Se the string for "estiverem", put "is/are" into the monikette's string; exit.
\\ allocates e destroys
Se the string for "alojar", put "allocate" into the monikette's string; exit.
Se the string for "aloje", put "allocate" into the monikette's string; exit.
Se the string for "alocar", put "allocate" into the monikette's string; exit.
Se the string for "aloque", put "allocate" into the monikette's string; exit.
Se the string for "reservar", put "allocate" into the monikette's string; exit.
Se the string for "reserve", put "allocate" into the monikette's string; exit.
Se the string for "memória", put "memory" into the monikette's string; exit.
\Se the string for "for", put "por" into the monikette's string; exit. \\servia pra converter o "for" para "por"
Se the string for "pelo", put "por the" into the monikette's string; exit. 
Se the string for "pela", put "por the" into the monikette's string; exit. 
Se the string for "desalocar", put "deallocate" into the monikette's string; exit.
Se the string for "desaloque", put "deallocate" into the monikette's string; exit.
Se the string for "desalojar", put "deallocate" into the monikette's string; exit.
Se the string for "desaloje", put "deallocate" into the monikette's string; exit.
Se the string for "esvaziar", put "deallocate" into the monikette's string; exit.
Se the string for "esvazie", put "deallocate" into the monikette's string; exit.
Se the string for "destruir", put "destroy" into the monikette's string; exit.
\CAL
\\ from/given/with/using
Se the string for "from", put "from/given/with/using" into the monikette's string; exit.
Se the string for "given", put "from/given/with/using" into the monikette's string; exit.
Se the string for "with", put "from/given/with/using" into the monikette's string; exit.
Se the string for "using", put "from/given/with/using" into the monikette's string; exit.
\ in/into/to
Se the string for "in", put "in/into/to" into the monikette's string; exit.
Se the string for "into", put "in/into/to" into the monikette's string; exit.
Se the string for "to", put "in/into/to" into the monikette's string; exit.
\ is/are
Se the string for "are", put "is/are" into the monikette's string; exit.
Se the string for "is", put "is/are" into the monikette's string; exit.
\ aren't/isn't
Se the string for "isn't", put "is/aren't" into the monikette's string; exit.
Se the string for "aren't", put "is/aren't" into the monikette's string; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se the string for "backward", put "backward" into the monikette's string; exit.
Se the string for "backwards", put "backward" into the monikette's string; exit.
Se the string for "counterclockwise", put "backward" into the monikette's string; exit.
Se the string for "counter-clockwise", put "backward" into the monikette's string; exit.
Se the string for "anticlockwise", put "backward" into the monikette's string; exit.
Se the string for "anti-clockwise", put "backward" into the monikette's string; exit.
\ at/on
Se the string for "at", put "at/on" into the monikette's string; exit.
Se the string for "on", put "at/on" into the monikette's string; exit.
\ other
Put the string into the monikette's string.

Etapas necessárias para que se adicione um monikette to some monikettes usando um type:
Create the monikette.
Posponha the monikette to the monikettes. 
Put the type into the monikette's type.

Etapas necessárias para que se adicione push fragments usando some monikettes:
Se the current routine for inexistente, cancele.
Loop.
Obtenha um monikette from the monikettes (backwards).
Se the monikette for inexistente, cancele.
Se the monikette's variable for inexistente, repeat.
Se the monikette's current substring estiver not blank, repeat.
Se the monikette's current type for inexistente, repeat.
Adicione um fragment usando the push address tag e the monikette's variable.
Repeat.

Etapas necessárias para que se adicione the put or convert fragments usando um variable e another variable e um locus:
Adicione um fragment usando the push address tag e the other variable.
Adicione another fragment usando the push address tag e the variable.
Find um routine usando "put" e the variable's type e "into" e the other variable's type.
Se the routine for inexistente, find the routine usando "convert" e the variable's type e "to" e the other variable's type.
Se the routine for not inexistente, adicione um third fragment usando the call internal tag e the routine; exit.
\ error message
Adicione um monikette to some monikettes usando "put/convert".
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando "into/to".
Adicione um fourth monikette to the monikettes usando the other variable's type.
Convert the monikettes to um moniker.
Destroy the monikettes.
Abort with "Eu não sei como '" then the moniker then "'." e the locus.

Etapas necessárias para que se adicione um routine to some routines usando um locus:
Create the routine.
Posponha the routine to the routines.
Put the locus into the routine's locus.

Etapas necessárias para que se adicione um scratch usando um type name e um locus:
Se the current routine for inexistente, void the scratch; exit.
Adicione the scratch to the current routine's locals usando "scratch" e the locus.
Generate the scratch's name usando "~S".
Put the type name into the scratch's type name.
Resolve the scratch.

Etapas necessárias para que se adicione several fragments usando um string e um variable e another string e another variable e um locus:
Adicione um fragment usando the push address tag e the other variable.
Adicione another fragment usando the push address tag e the variable.
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other variable's type.
Find um routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the locus; exit.
Adicione um third fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione several fragments usando um string e um variable e another string e another variable e um third string e um third variable e um pedaço endereço de memória:
Adicione um fragment usando the push address tag e the third variable.
Adicione another fragment usando the push address tag e the other variable.
Adicione um third fragment usando the push address tag e the variable.
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other variable's type.
Adicione um fifth monikette to the monikettes usando the third string.
Adicione um sixth monikette to the monikettes usando the third variable's type.
Find um routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the pedaço endereço de memória; exit.
Adicione um fourth fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione um source file to some source files usando um path:
Create the source file.
Posponha the source file to the source files.
Put the path into the source file's path.

Etapas necessárias para que se adicione two fragments usando um string e um variable e um locus:
Adicione um fragment usando the push address tag e the variable.
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Find um routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the locus; exit.
Adicione another fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione um type to some types usando um locus:
Create the type.
Posponha the type to the types.
Put the locus into the type's locus.

Etapas necessárias para que se adicione um type to some types usando um name e um plural name e um base name:
Adicione the type to the types usando the name e the plural name e the base name e nil.

Etapas necessárias para que se adicione um type to some types usando um name e um plural name e um base name e um locus:
Create the type.
Posponha the type to the types.
Put the locus into the type's locus.
Put the name into the type's name.
Put the plural name into the type's plural name.
Put the base name into the type's base name.

Etapas necessárias para que se adicione um variable to some variables usando um kind e um locus:
Create the variable usando the kind.
Posponha the variable to the variables.
Put the locus into the variable's locus.

The adding built-in memory routines timer é um timer.

The adding built-in startup routine timer é um timer.

Etapas necessárias para que se address some entries:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
Address the entry.
Repeat.

Etapas necessárias para que se address um entry:
Put the current name address into the entry's name address.
Put the entry's name's length plus 3 into um número.
Round the número up to the nearest multiple of 2.
Adicione the número to the current name address.
Put the current thunk address into the entry's thunk address.
Put the image base plus the current thunk address into the entry's address.
Adicione 4 to the current thunk address.

Etapas necessárias para que se address um fragment usando um address:
Se the compiler's abort flag estiver verde, cancele.
Se the fragment for inexistente, cancele.
Put the image base plus the address into the fragment's address.
Se the fragment's tag é the push address tag, adicione 7 to the address; exit.
Se the fragment's tag é the call internal tag, adicione 5 to the address; exit.
Se the fragment's tag é the load address tag, adicione 12 to the address; exit.
Se the fragment's tag é the increment tag, adicione 10 to the address; exit.
Se the fragment's tag é the dereference tag, adicione 14 to the address; exit.
Se the fragment's tag é the jump false tag, adicione 9 to the address; exit.
Se the fragment's tag é the not tag, adicione 3 to the address; exit.
Se the fragment's tag é the exit tag, adicione 5 to the address; exit.
Se the fragment's tag é the repeat tag, adicione 5 to the address; exit.
Se the fragment's tag é the break tag, adicione 5 to the address; exit.
Se the fragment's tag é the prolog tag, address the fragment usando the address (prolog); exit.
Se the fragment's tag é the epilog tag, address the fragment usando the address (epilog); exit.
Se the fragment's tag é the intel tag, adicione the fragment's code's length to the address; exit.
Se the fragment's tag é the push value tag, address the fragment usando the address (push value); exit.
Se the fragment's tag é the call external tag, adicione 6 to the address; exit.
Se the fragment's tag é the load eax tag, adicione 5 to the address; exit. \ was 8 when "load eax" took in variables; now "load eax" only does um immediate value
Se the fragment's tag é the save eax tag, address the fragment usando the address (save eax); exit.
Se the fragment's tag é the call indirect tag, adicione 8 to the address; exit.
Se the fragment's tag é the routine address tag, adicione 12 to the address; exit.

Etapas necessárias para que se address um fragment usando um address (epilog):
Se the current routine's callback flag estiver verde, adicione 3 to the address.
Adicione 6 to the address.

Etapas necessárias para que se address um fragment usando um address (prolog):
Adicione 3 to the address.
Se the current routine's local size for not 0, adicione 10 to the address.
Se the current routine's callback flag estiver verde, adicione 3 to the address.

Etapas necessárias para que se address um fragment usando um address (push value):
Adicione 6 to the address.
Se the fragment's variable for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Put the fragment's variable's type's length into um length.
Se the length for 4, adicione 2 to the address; exit.
Se the length for 2, adicione 3 to the address; exit.
Se the length for 1, adicione 4 to the address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address um fragment usando um address (save eax):
Adicione 6 to the address.
Se the fragment's variable for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Put the fragment's variable's type's length into um length.
Se the length for 4, adicione 2 to the address; exit.
Se the length for 2, adicione 3 to the address; exit.
Se the length for 1, adicione 2 to the address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address some fragments usando um address:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Address the fragment usando the address.
Repeat.

Etapas necessárias para que se address um import:
Put the current name address into the import's name address.
Put the current header address into the import's header address.
Put the current name address into the import's import header's name memory address.
Put the import's name's length plus 1 into um número.
Round the número up to the nearest multiple of 2.
Adicione the número to the current name address.
Adicione um import header's magnitude to the current header address.
Put the current thunk address into the import's import header's first thunk memory address.
Address the import's entries.
Adicione 4 to the current thunk address.

Etapas necessárias para que se address some imports usando um address:
Put the address into the current header address.
Put the imports' count into um count.
Adicione 1 to the count.
Multiplique the count por [via] um import header's magnitude.
Put the address plus the count into the current thunk address.
Obtenha another count usando the imports (all entries plus markers).
Multiplique the other count por [via] 4.
Put the current thunk address plus the other count into the current name address.
Loop.
Obtenha um import from the imports.
Se the import for inexistente, pare.
Address the import.
Repeat.
Put the current name address minus the address into um número.
Adicione the número to the address.

An address é um número.

Etapas necessárias para que se address um routine usando um address:
Se the compiler's abort flag estiver verde, cancele.
Se the routine for inexistente, cancele.
Se the routine's employs moniker estiver not blank, cancele. \ employs are addressed later
Se the routine's compiled flag estiver not verde, cancele.
Put the routine into the current routine.
Put the image base plus the address into the routine's address.
Address the routine's fragments usando the address.
Round the address up to the nearest multiple of 4.

Etapas necessárias para que se address some routines usando um address:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um routine from the routines.
Se the routine for inexistente, pare.
Address the routine usando the address.
Repeat.

Etapas necessárias para que se address um variable usando um address:
Se the compiler's abort flag estiver verde, cancele.
Se the variable for inexistente, cancele.
Se the variable's compiled flag estiver not verde, cancele.
Put the image base plus the address into the variable's address.
Adicione the variable's type's length to the address.
Se the variable's type can be reduced to "string", adicione the variable's data's length plus 1 to the address.
Round the address up to the nearest multiple of 4.

Etapas necessárias para que se address some variables usando um address:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um variable from the variables.
Se the variable for inexistente, cancele.
Address the variable usando the address.
Repeat.

The addressing timer é um timer.

Etapas necessárias para que se advance um buffer:
Posponha the return pedaço to the buffer.
Posponha the linefeed pedaço to the buffer.

Etapas necessárias para que se advance um buffer (twice):
Advance the buffer. 
Advance the buffer.

Etapas necessárias para que se posponha um entry to um buffer (with separator):
Se the entry for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the entry's name to the buffer (with separator).

Etapas necessárias para que se posponha um flag to um buffer (with separator):
Convert the flag to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha the global finalizers to um string:
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Se the global's compiled flag estiver not verde, repeat.
Se the global's type should not be finalized, repeat.
Posponha "~finalize the " then the global's name then ". " to the string.
Repeat.

Etapas necessárias para que se posponha the global initializers to um string:
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Se the global's literal for inexistente, repeat.
Se the global's compiled flag estiver not verde, repeat.
Feche um flag.
Posponha the global's initializer string to the string.
Repeat.

Etapas necessárias para que se posponha um monikette to um moniker:
Se the monikette for inexistente, cancele.
Se the moniker estiver not blank, posponha the space pedaço to the moniker.
Se the monikette's type for not inexistente, posponha "[" e the monikette's type's name e "]" to the moniker (fast); exit.
Se the monikette's string estiver not blank, posponha the monikette's string to the moniker; exit.

Etapas necessárias para que se posponha um monikette to um moniker (while bubbling):
Se the monikette for inexistente, cancele.
Se the moniker estiver not blank, posponha the space pedaço to the moniker.
Se the monikette's current substring estiver not blank, posponha the monikette's current substring to the moniker; exit.
Se the monikette's current type for not inexistente, posponha "[" e the monikette's current type's name e "]" to the moniker (fast); exit.

Etapas necessárias para que se posponha um número to um buffer (as hex with separator):
Convert the número to um nibble string.
Posponha the nibble string to the buffer (with separator).

Etapas necessárias para que se posponha um número to um buffer (with separator):
Convert the número to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha um ratio to um buffer (with separator):
Convert the ratio to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha um routine to um buffer (with separator):
Se the routine for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the routine's moniker to the buffer (with separator).

Etapas necessárias para que se posponha um string e another string e um third string to um fourth string (fast):
Put the fourth string's length into um length.
Adicione the string's length to the length.
Adicione the other string's length to the length.
Adicione the third string's length to the length.
Reassign um endereço de memória usando the length.
Put the endereço de memória into um pedaço endereço de memória.
Copy pedaços from the fourth string's first to the pedaço endereço de memória por the fourth string's length.
Adicione the fourth string's length to the pedaço endereço de memória.
Copy pedaços from the string's first to the pedaço endereço de memória por the string's length.
Adicione the string's length to the pedaço endereço de memória.
Copy pedaços from the other string's first to the pedaço endereço de memória por the other string's length.
Adicione the other string's length to the pedaço endereço de memória.
Copy pedaços from the third string's first to the pedaço endereço de memória por the third string's length.
Unassign the fourth string's first.
Put the endereço de memória into the fourth string's first.
Put the endereço de memória plus the length minus 1 into the fourth string's last.

Etapas necessárias para que se posponha um string to um buffer (with separator):
Posponha the string to the buffer.
Posponha "/" to the buffer.

Etapas necessárias para que se posponha um tag to um buffer (as um fragment tag string with separator):
Se the tag é the break tag, posponha "break" to the buffer (with separator); exit.
Se the tag é the call external tag, posponha "call external" to the buffer (with separator); exit.
Se the tag é the call indirect tag, posponha "call indirect" to the buffer (with separator); exit.
Se the tag é the call internal tag, posponha "call internal" to the buffer (with separator); exit.
Se the tag é the dereference tag, posponha "dereference" to the buffer (with separator); exit.
Se the tag é the end if tag, posponha "end if" to the buffer (with separator); exit.
Se the tag é the epilog tag, posponha "epilog" to the buffer (with separator); exit.
Se the tag é the exit tag, posponha "exit" to the buffer (with separator); exit.
Se the tag é the finalize tag, posponha "finalize" to the buffer (with separator); exit.
Se the tag é the increment tag, posponha "increment" to the buffer (with separator); exit.
Se the tag é the intel tag, posponha "intel" to the buffer (with separator); exit.
Se the tag é the jump false tag, posponha "jump false" to the buffer (with separator); exit.
Se the tag é the load address tag, posponha "load address" to the buffer (with separator); exit.
Se the tag é the load eax tag, posponha "load eax" to the buffer (with separator); exit.
Se the tag é the loop tag, posponha "loop" to the buffer (with separator); exit.
Se the tag é the not tag, posponha "not" to the buffer (with separator); exit.
Se the tag é the prolog tag, posponha "prolog" to the buffer (with separator); exit.
Se the tag é the push address tag, posponha "push address" to the buffer (with separator); exit.
Se the tag é the push value tag, posponha "push value" to the buffer (with separator); exit.
Se the tag é the save eax tag, posponha "save eax" to the buffer (with separator); exit.
Se the tag é the repeat tag, posponha "repeat" to the buffer (with separator); exit.
Se the tag é the routine address tag, posponha "routine address" to the buffer (with separator); exit.
Posponha "?" to the buffer (with separator).

Etapas necessárias para que se posponha um type to um buffer (with separator):
Se the type for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the type's name to the buffer (with separator).

Etapas necessárias para que se posponha um variable to um buffer (with separator):
Se the variable for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the variable's name to the buffer (with separator).

Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules):
\# contrações
Se the string for "ao", posponha "para o" to the other string; exit.
Se the string for "à", posponha "para a" to the other string; exit.
Se the string for "aos", posponha "para os" to the other string; exit.
Se the string for "às", posponha "para as" to the other string; exit.
Se the string for "do", posponha "de o" to the other string; exit.
Se the string for "da", posponha "de a" to the other string; exit.
Se the string for "dos", posponha "de os" to the other string; exit.
Se the string for "das", posponha "de as" to the other string; exit.
Se the string for "dum", posponha "de um" to the other string; exit.
Se the string for "duma", posponha "de uma" to the other string; exit.
Se the string for "dumas", posponha "de umas" to the other string; exit.
Se the string for "duns", posponha "de uns" to the other string; exit.
Se the string for "daqui", posponha "de aqui" to the other string; exit.
Se the string for "dali", posponha "de ali" to the other string; exit.
Se the string for "dele", posponha "de ele" to the other string; exit.
Se the string for "dela", posponha "de ela" to the other string; exit.
Se the string for "desse", posponha "de esse" to the other string; exit.
Se the string for "dessa", posponha "de essa" to the other string; exit.
Se the string for "desses", posponha "de esses" to the other string; exit.
Se the string for "dessas", posponha "de essas" to the other string; exit.
Se the string for "deste", posponha "de este" to the other string; exit.
Se the string for "desta", posponha "de esta" to the other string; exit.
Se the string for "destes", posponha "de estes" to the other string; exit.
Se the string for "destas", posponha "de estas" to the other string; exit.
Se the string for "disso", posponha "de isso" to the other string; exit.
Se the string for "disto", posponha "de isto" to the other string; exit.
Se the string for "nesse", posponha "em esse" to the other string; exit.
Se the string for "nesses", posponha "em esses" to the other string; exit.
Se the string for "neste", posponha "em este" to the other string; exit.
Se the string for "nestes", posponha "em estes" to the other string; exit.
Se the string for "nisso", posponha "em isso" to the other string; exit.
Se the string for "nisto", posponha "em isto" to the other string; exit.
Se the string for "nessa", posponha "em essa" to the other string; exit.
Se the string for "nessas", posponha "em essas" to the other string; exit.
Se the string for "nesta", posponha "em esta" to the other string; exit.
Se the string for "nestas", posponha "em estas" to the other string; exit.
Se the string for "donde", posponha "de onde" to the other string; exit.
Se the string for "dentre", posponha "de entre" to the other string; exit.
Se the string for "dantes", posponha "de antes" to the other string; exit.
Se the string for "dalguém", posponha "de alguém" to the other string; exit.
Se the string for "dalgum", posponha "de algum" to the other string; exit.
Se the string for "dalguma", posponha "de alguma" to the other string; exit.
Se the string for "dalguns", posponha "de alguns" to the other string; exit.
Se the string for "dalgumas", posponha "de algumas" to the other string; exit.
Se the string for "nalgum", posponha "em algum" to the other string; exit.
Se the string for "nalguma", posponha "em alguma" to the other string; exit.
Se the string for "nalguns", posponha "em alguns" to the other string; exit.
Se the string for "nalgumas", posponha "em algumas" to the other string; exit.
Se the string for "doutro", posponha "de outro" to the other string; exit.
Se the string for "doutra", posponha "de outra" to the other string; exit.
Se the string for "doutros", posponha "de outros" to the other string; exit.
Se the string for "doutras", posponha "de outras" to the other string; exit.
Se the string for "noutro", posponha "em outro" to the other string; exit.
Se the string for "noutra", posponha "em outra" to the other string; exit.
Se the string for "noutros", posponha "em outros" to the other string; exit.
Se the string for "noutras", posponha "em outras" to the other string; exit.
\# "no" pode ser uma negação em inglês.
Se the string é any contraction giving the third string (portuguese rules - "no"), posponha "em o" to the other string; exit.
Se the string for "na", posponha "em a" to the other string; exit.
Se the string for "nos", posponha "em os" to the other string; exit.
Se the string for "nas", posponha "em as" to the other string; exit.
\Se the string for "noutro", posponha "em outro" to the other string; exit.
\Se the string for "noutra", posponha "em outra" to the other string; exit.
\Se the string for "noutros", posponha "em outros" to the other string; exit.
\Se the string for "noutras", posponha "em outras" to the other string; exit.
Se the string for "num", posponha "em um" to the other string; exit.
Se the string for "numa", posponha "em uma" to the other string; exit.
Se the string for "nuns", posponha "em uns" to the other string; exit.
Se the string for "numas", posponha "em umas" to the other string; exit.
Se the string for "pelo", posponha "por o" to the other string; exit.
Se the string for "pela", posponha "por a" to the other string; exit.
Se the string for "pelos", posponha "por os" to the other string; exit.
Se the string for "pelas", posponha "por as" to the other string; exit.
\# sinônimos
Se the string for "adir", posponha "adicionar" to the other string; exit.
Se the string for "agregar", posponha "adicionar" to the other string; exit.
Se the string for "acrescentar", posponha "adicionar" to the other string; exit.
Se the string for "somar", posponha "adicionar" to the other string; exit.
Se the string for "começar", posponha "iniciar" to the other string; exit.
Se the string for "terminar", posponha "finalizar" to the other string; exit.
Se the string for "acabar", posponha "finalizar" to the other string; exit.
Se the string for "completar", posponha "finalizar" to the other string; exit.
Se the string for "colocar", posponha "pôr" to the other string; exit.
Se the string for "mudar", posponha "alterar" to the other string; exit.
Se the string for "limpar", posponha "apagar" to the other string; exit.
Se the string for "ampliar", posponha "aumentar" to the other string; exit.
Se the string for "expandir", posponha "aumentar" to the other string; exit.
Se the string for "alargar", posponha "aumentar" to the other string; exit.
Se the string for "dilatar", posponha "aumentar" to the other string; exit.
Se the string for "estender", posponha "aumentar" to the other string; exit.
Se the string for "prolongar", posponha "aumentar" to the other string; exit.
Se the string for "ampliar", posponha "aumentar" to the other string; exit.
Se the string for "achar", posponha "encontrar" to the other string; exit.
Se the string for "descobrir", posponha "encontrar" to the other string; exit.
Se the string for "buscar", posponha "encontrar" to the other string; exit.
Se the string for "manusear", posponha "manejar" to the other string; exit.
Se the string for "manipular", posponha "manejar" to the other string; exit.
Se the string for "enumerar", posponha "listar" to the other string; exit.
Se the string for "elencar", posponha "listar" to the other string; exit.
Se the string for "selecionar", posponha "escolher" to the other string; exit.
Se the string for "eliminar", posponha "remover" to the other string; exit.
Se the string for "excluir", posponha "remover" to the other string; exit.
Se the string for "retirar", posponha "remover" to the other string; exit.
Se the string for "rodar", posponha "girar" to the other string; exit.
Se the string for "começar", posponha "iniciar" to the other string; exit.
Se the string for "permutar", posponha "trocar" to the other string; exit.
Se the string for "esperar", posponha "aguardar" to the other string; exit.
Se the string for "rascunhar", posponha "esboçar" to the other string; exit.
Se the string for "antepor", posponha "prepor" to the other string; exit.
Posponha the string to the other string.

Etapas necessárias para que se attach address loading code to um texto hexadecimal usando um variable: \ loads into edx
Se the variable for inexistente, attach $C7C200000000 to the texto hexadecimal; exit. \ mov edx,0
Se the variable's kind for "global", attach $C7C2 e the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
Se the variable's kind for "literal", attach $C7C2 e the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
Se the variable's kind for "local", attach $8D95 e the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Se the variable's kind for "scratch", attach $8B95 e the variable's offset to the texto hexadecimal; exit. \ mov edx,[ebp+the variable's offset]
Se the variable's kind for not "parameter", abort with "Erro interno - attach address loading code to um texto hexadecimal usando um variable"; exit.
Se the variable's by-value flag estiver verde, attach $8D95 e the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Attach $8B95 e the variable's offset to the texto hexadecimal. \ mov edx,[ebp+the variable's offset]

Etapas necessárias para que se attach um texto hexadecimal e um address to um fragment: \ call or jump
Put the address into um número.
Subtract the fragment's address from the número.
Subtract the fragment's code's length from the número.
Subtract the texto hexadecimal's length from the número.
Subtract 4 from the número.
Attach the texto hexadecimal e the número to the fragment's code.

Etapas necessárias para que se attach um texto hexadecimal e um número e another texto hexadecimal to um third texto hexadecimal:
Posponha the texto hexadecimal to the third texto hexadecimal.
Convert the número to um fourth texto hexadecimal.
Posponha the fourth texto hexadecimal to the third texto hexadecimal.
Posponha the other texto hexadecimal to the third texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um número e another número to another texto hexadecimal:
Posponha the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Posponha the third texto hexadecimal to the other texto hexadecimal.
Convert the other número to um fourth texto hexadecimal.
Posponha the fourth texto hexadecimal to the other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um flag to another texto hexadecimal;
Etapas necessárias para que se attach um texto hexadecimal e um número to another texto hexadecimal:
Posponha the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Posponha the third texto hexadecimal to the other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal to another texto hexadecimal: employ posponha um string to another string.

Etapas necessárias para que se blurt pedaços usando um endereço de memória e um length e um buffer e um offset:
Put the buffer's first plus the offset into another endereço de memória.
Copy pedaços from the endereço de memória to the other endereço de memória por the length.

Etapas necessárias para que se blurt um dos header into um buffer:
Blurt pedaços usando the dos header's whereabouts e the dos header's magnitude e the buffer e 0.

Etapas necessárias para que se blurt some entries into um buffer:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
Blurt the entry into the buffer.
Repeat.

Etapas necessárias para que se blurt um entry into um buffer:
Blurt pedaços usando the entry's name address's whereabouts e 4 e the buffer e the entry's thunk address.
Put the entry's name address plus 2 into um address.
Blurt the entry's name into the buffer at the address.

Etapas necessárias para que se blurt um fragment into um buffer:
Se the fragment's code estiver blank, cancele.
Put the fragment's address minus the image base into um address.
Blurt the fragment's code into the buffer at the address.

Etapas necessárias para que se blurt some fragments into um buffer:
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Blurt the fragment into the buffer.
Repeat.

Etapas necessárias para que se blurt um import into um buffer:
Blurt pedaços usando the import's import header's whereabouts e the import's import header's magnitude e the buffer e the import's header address.
Blurt the import's name into the buffer at the import's name address.
Blurt the import's entries into the buffer.

Etapas necessárias para que se blurt some imports into um buffer:
Obtenha um import from the imports.
Se the import for inexistente, cancele.
Blurt the import into the buffer.
Repeat.

Etapas necessárias para que se blurt um pe header into um buffer:
Blurt pedaços usando the pe header's whereabouts e the pe header's magnitude e the buffer e 256.

Etapas necessárias para que se blurt um routine into um buffer:
Se the routine's compiled flag estiver not verde, cancele.
Blurt the routine's fragments into the buffer.

Etapas necessárias para que se blurt some routines into um buffer:
Obtenha um routine from the routines.
Se the routine for inexistente, cancele.
Blurt the routine into the buffer.
Repeat.

Etapas necessárias para que se blurt um string into um buffer at um address:
Blurt pedaços usando the string's first e the string's length e the buffer e the address.

Etapas necessárias para que se blurt um variable into um buffer:
Se the variable's compiled flag estiver not verde, cancele.
Se the variable's type can be reduced to "string", blurt the variable into the buffer (as um string); exit.
Put the variable's address minus the image base into um address.
Blurt the variable's data into the buffer at the address.

Etapas necessárias para que se blurt um variable into um buffer (as um string):
Put the variable's address minus the image base into um address.
Put the variable's data's length into um length.
Put the address into another address.
Adicione um prototype string's magnitude to the other address.
Adicione the image base to the other address.
Put 0 into the prototype string's first.
Put -1 into the prototype string's last.
Se the length for not 0, put the other address into the prototype string's first.
Se the length for not 0, put the prototype string's first plus the length minus 1 into the prototype string's last.
Blurt pedaços usando the prototype string's whereabouts e the prototype string's magnitude e the buffer e the address.
Adicione the prototype string's magnitude to the address.
Blurt the variable's data into the buffer at the address.

Etapas necessárias para que se blurt some variables into um buffer:
Obtenha um variable from the variables.
Se the variable for inexistente, cancele.
Blurt the variable into the buffer.
Repeat.

An borough é um conjunto with um base address, um length e um size.

The break tag é um tag equal to 1.

Etapas necessárias para que se bubble um monikette:
Se the monikette for inexistente, cancele.
Se the monikette's current substring estiver not blank, clear the monikette's current substring; exit.
Se the monikette's current type for inexistente, cancele.
Se the monikette's current type é any built-in type, put nil into the monikette's current type; exit.
Put the monikette's current type's base type into the monikette's current type.

An built-in type é um type.

Etapas necessárias para que se calculate the length of um type:
Se the type for inexistente, cancele.
Se the type's length for not -1, cancele.
Calculate the length of the type's base type.
Se the type's fields are empty, put the type's base type's length into the type's length; exit.
Put 0 into the type's length.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name estiver not blank, repeat.
Calculate the length of the field's type.
Adicione the field's type's length times the field's count to the type's length.
Repeat.

Etapas necessárias para que se calculate the lengths of some types:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the length of the type.
Repeat.

Etapas necessárias para que se calculate the offsets in um type:
Se the type for inexistente, cancele.
Put 0 into um offset.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name estiver not blank, repeat.
Put the offset into the field's offset.
Adicione the field's type's length times the field's count to the offset.
Repeat.

Etapas necessárias para que se calculate the offsets in some types:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the offsets in the type.
Repeat.

Etapas necessárias para que se calculate the redefinition offsets in um type:
Se the type for inexistente, cancele.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name estiver blank, repeat.
Find another field usando the field's redefinition target name e the type's fields.
Se the other field for inexistente, abort with "Redefine inválido. Eu não consigo encontrar o campo '" then the field's redefinition target name then "' field." e the field's locus; exit.
Put the other field's offset into the field's offset.
Repeat.

Etapas necessárias para que se calculate the redefinition offsets in some types:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the redefinition offsets in the type.
Repeat.

The calculating timer é um timer.

The call external tag é um tag equal to 2.

The call indirect tag é um tag equal to 3.

The call internal tag é um tag equal to 4.

Etapas necessárias para que se check por invalid optional info on um type:
Se the compiler's abort flag estiver verde, cancele.
Se the type for inexistente, cancele.
Se the type's target name estiver not blank, check por invalid optional info on the type (target).
Se the type's fields are not empty, check por invalid optional info on the type (fields).
Se the type's scale for not 0, check por invalid optional info on the type (scale).

Etapas necessárias para que se check por invalid optional info on um type (fields):
Se the compiler's abort flag estiver verde, cancele.
Se the type cannot be reduced to "conjunto", abort with "A palavra 'with' só é permitida em conjunto types." e the type's locus; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info on um type (scale):
Se the compiler's abort flag estiver verde, cancele.
Se the type cannot be reduced to "número", abort with "Escalas são permitidas apenas em tipos numéricos." e the type's locus; exit.

Etapas necessárias para que se check por invalid optional info on um type (target):
Se the compiler's abort flag estiver verde, cancele.
Se the type cannot be reduced to "endereço de memória", abort with "An palavra 'to' só é permitida em endereço de memória types." e the type's locus; exit.

Etapas necessárias para que se clear um field term:
Fill pedaços with the null pedaço starting at the field term's whereabouts por the field term's magnitude.

Etapas necessárias para que se clear um term:
Void the term's variable.
Clear the term's phrase.

The code borough é um borough.

Etapas necessárias para que se compile the bodies of the routines:
Compile the body of the routine called "initialize before run".
Compile the body of the routine called "execute nosso programa".
Compile the body of the routine called "finalize after run".

Etapas necessárias para que se compile the body of um routine:
Se the routine for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Se the routine's compiled flag estiver verde, cancele.
Abra the routine's compiled flag.
Slap um rider on the routine's routine body.
Move the rider (compiler rules).
Se the rider's token é the semi-colon pedaço, compile the body of the routine usando the rider (alternate wording); exit. \ *** alternate wording
Se the rider's token é any employ, compile the body of the routine usando the rider (employ); exit.
Put the current routine into um saved routine.
Put the routine into the current routine.
Create the routine's nickname index usando 101.
Eliminate duplicate nicknames from the routine's parameters usando the routine's nickname index.
Compile the body of the routine (prolog).
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, pare.
Compile the next statement usando the rider.
Repeat.
Compile the body of the routine (epilog).
Put the saved routine into the current routine.

Etapas necessárias para que se compile the body of um routine (epilog):
Se the routine for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Adicione um fragment usando the finalize tag.
Loop.
Obtenha um variable from the routine's locals.
Se the variable for inexistente, pare.
Se the variable's kind for "scratch", repeat.
Se the variable's type should not be finalized, repeat.
Adicione another fragment usando the push address tag e the variable.
Find another routine usando "~finalize" e the variable's type.
Se the other routine for inexistente, abort with "Erro interno - compile the body of um routine (epilog)"; exit.
Adicione um third fragment usando the call internal tag e the other routine.
Repeat.
Adicione um fourth fragment usando the epilog tag.

Etapas necessárias para que se compile the body of um routine (prolog):
Se the routine for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Adicione um fragment usando the prolog tag.
Adicione another fragment usando the loop tag.

Etapas necessárias para que se compile the body of the routine called um string:
Se the compiler's abort flag estiver verde, cancele.
Find um routine usando the string e the routine index.
Se the routine for inexistente, abort with "Eu preciso de uma função para fazer '" then the string then "'."; exit.
Compile the body of the routine.

Etapas necessárias para que se compile the body of um routine usando um rider (alternate wording): \ *** alternate wording
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules). \ *** do we need this?
Put the routine's next into um target routine.
Se the target routine for inexistente, abort with "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e the rider; exit.
Put the target routine's moniker into the routine's employs moniker.
Compile the body of the target routine.

Etapas necessárias para que se compile the body of um routine usando um rider (employ):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Compile um routine reference usando the rider.
Convert the routine reference to the routine's employs moniker.
Destroy the routine reference.
Se the rider's token for not ".", abort with "Employ statments devem terminar com um ponto, não com '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Se the rider's token estiver not blank, abort with "Somente um employ" e the rider; exit.
Find another routine usando the routine's employs moniker e the routine index.
Se the other routine for inexistente, abort with "Não consigo encontrar um rotina '" then the routine's employs moniker then "' que você está tentando empregar." e the routine's locus; exit.
Compile the body of the other routine.

Etapas necessárias para que se compile the call'd part usando um rider e um variable:
Se the compiler's abort flag estiver verde, cancele.
Se the variable for inexistente, cancele.
Put the variable's name into the variable's type name.
Move the rider (compiler rules).
Scan the variable's name usando the rider.

Etapas necessárias para que se compile um directory:
Compile the directory (start).
Compile the directory (load the source files).
Compile the directory (scan the source files).
Compile the directory (resolve the types).
Compile the directory (resolve the globals).
Compile the directory (compile the headers of the routines).
Compile the directory (calculate lengths e offsets of types).
Compile the directory (Adicione the built-in memory routines).
Compile the directory (index the routines por utility use).
Compile the directory (compile the bodies of the routines).
Compile the directory (Adicione e compile the built-in startup routine).
Compile the directory (offset parameters e variables).
Compile the directory (address).
Compile the directory (transmogrify).
Compile the directory (link).
Compile the directory (write the exe).
Compile the directory (stop).

Etapas necessárias para que se compile um directory (Adicione e compile the built-in startup routine):
Se the compiler's abort flag estiver verde, cancele.
Show status "Adicionando e agrupando um tarefa de inicialização padrão...".
Start the adding built-in startup routine timer.
Adicione e compile the initialize before run e run e finalize after run routine.
Stop the adding built-in startup routine timer.

Etapas necessárias para que se compile um directory (Adicione the built-in memory routines):
Se the compiler's abort flag estiver verde, cancele.
Show status "Adicionando como tarefas predefinidas na memória...".
Start the adding built-in memory routines timer.
Adicione the allocate e deallocate e finalize e destroy routines.
Stop the adding built-in memory routines timer.

Etapas necessárias para que se compile um directory (address):
Se the compiler's abort flag estiver verde, cancele.
Show status "Obtendo endereço dos itens...".
Start the addressing timer.
Put 4096 into um address.
Put the address into the import borough's base.
Address the imports usando the address.
Put the address minus the import borough's base into the import borough's length.
Round the address up to the nearest multiple of 4096.
Put the address into the data borough's base.
Address the globals usando the address.
Address the literals usando the address.
Put the address minus the data borough's base into the data borough's length.
Round the address up to the nearest multiple of 4096.
Put the address into the code borough's base.
Address the routines usando the address.
Put the address minus the code borough's base into the code borough's length.
Stop the addressing timer.

Etapas necessárias para que se compile um directory (calculate lengths e offsets of types):
Se the compiler's abort flag estiver verde, cancele.
Show status "Calculando tamanhos e deslocamentos...".
Start the calculating timer.
Calculate the lengths of the types.
Calculate the offsets in the types.
Calculate the redefinition offsets in the types.
Stop the calculating timer.

Etapas necessárias para que se compile um directory (compile the bodies of the routines):
Se the compiler's abort flag estiver verde, cancele.
Show status "Agrupando o conteúdo das tarefas...".
Start the compiling routine bodies timer.
Compile the bodies of the routines.
Stop the compiling routine bodies timer.

Etapas necessárias para que se compile um directory (compile the headers of the routines):
Se the compiler's abort flag estiver verde, cancele.
Show status "Agrupando os nomes das tarefas...".
Start the compiling routine headers timer.
Compile the headers of the routines.
Stop the compiling routine headers  timer.

Etapas necessárias para que se compile um directory (index the routines por utility use):
Se the compiler's abort flag estiver verde, cancele.
Show status "Catalogando tarefas...".
Start the indexing utilities timer.
Index the routines por utility use.
Scrub the utility index.
Reindex the utility index.
Stop the indexing utilities timer.

Etapas necessárias para que se compile um directory (link):
Se the compiler's abort flag estiver verde, cancele.
Show status "Elencando arquivos..".
Start the linking timer.
Link.
Stop the linking timer.

Etapas necessárias para que se compile um directory (offset parameters e variables):
Se the compiler's abort flag estiver verde, cancele.
Show status "Deslocando parâmetros e variáveis...".
Start the offsetting timer.
Offset the parameters in the routines.
Offset the locals in the routines.
Stop the offsetting timer.

Etapas necessárias para que se compile um directory (load the source files):
Se the compiler's abort flag estiver verde, cancele.
Show status "Carregando arquivos...".
Start the loading timer.
Load the source files.
Stop the loading timer.

Etapas necessárias para que se compile um directory (resolve the globals):
Se the compiler's abort flag estiver verde, cancele.
Show status "Resolvendo itens de escopo abrangente...".
Start the resolving globals timer.
Resolve the globals.
Stop the resolving globals timer.

Etapas necessárias para que se compile um directory (resolve the types):
Se the compiler's abort flag estiver verde, cancele.
Show status "Resolvendo tipos...".
Start the resolving types timer.
Resolve the types (expand coisas).
Resolve the types (index plurals).
Resolve the types (base types).
Resolve the types (optional info).
Stop the resolving types timer.

Etapas necessárias para que se compile um directory (scan the source files):
Se the compiler's abort flag estiver verde, cancele.
Show status "Analisando arquivos...".
Start the scanning timer.
Scan the source files.
Stop the scanning timer.

Etapas necessárias para que se compile um directory (start):
Show status "Iniciando...".
Finalize the compiler.
Start the compiler's timer.
Initialize the compiler usando the directory.
Adicione the built-in types.

Etapas necessárias para que se compile um directory (stop):
Stop the compiler's timer.
Show status "Interrompendo".

Etapas necessárias para que se compile um directory (transmogrify):
Se the compiler's abort flag estiver verde, cancele.
Show status "Modificando...".
Start the transmogrifying timer.
Transmogrify the routines.
Stop the transmogrifying timer.

Etapas necessárias para que se compile um directory (write the exe):
Se the compiler's abort flag estiver verde, cancele.
Show status "Gerando arquivo executável...".
Start the writing timer.
Write the compiler's exe to the compiler's exe path.
Se the i/o error estiver not blank, abort with the i/o error.
Stop the writing timer.

Etapas necessárias para que se compile um expression usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Compile um term usando the rider.
Put the term into the expression.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token for not any operator, cancele.
Se the rider's token é any divided, compile the expression usando the rider (divided); repeat.
Se the rider's token é any minus, compile the expression usando the rider (minus); repeat.
Se the rider's token é any plus, compile the expression usando the rider (plus); repeat.
Se the rider's token é any then, compile the expression usando the rider (then); repeat.
Se the rider's token é any times, compile the expression usando the rider (times); repeat.

Etapas necessárias para que se compile um expression usando um rider (divided):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Se the rider's token for not any by, abort with "Você deve usar o termo 'divided BY'." e the rider; exit.
Se the expression's variable for inexistente, abort with "Termo 'divided by' inválido, há um erro na variável: '" then the expression's phrase then "'." e the rider; exit.
Move the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "O seu 'divided by',está errado. Não dá pra dividir por '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando the expression's type name e the rider's token's first.
Adicione several fragments usando "put" e the expression's variable e "into" e the intermediate e the rider's token's first.
Adicione several fragments usando "divida" e the intermediate e "por" e the term's variable e the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile um expression usando um rider (minus):
Se the compiler's abort flag estiver verde, cancele.
Se the expression's variable for inexistente, abort with "O seu 'minus', está errado. Não consigo subtrair o(a) '" then the expression's phrase then "'." e the rider; exit.
Move the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "O seu 'minus', está errado. Não consigo diminuir do(a) '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando the expression's type name e the rider's token's first.
Adicione several fragments usando "put" e the expression's variable e "into" e the intermediate e the rider's token's first.
Adicione several fragments usando "subtract" e the term's variable e "from" e the intermediate e the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile um expression usando um rider (plus):
Se the compiler's abort flag estiver verde, cancele.
Se the expression's variable for inexistente, abort with "O seu 'plus', está errado. Não consigo somar o '" then the expression's phrase then "'." e the rider; exit.
Move the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "O seu 'plus',  está errado. Não consigo somar um '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando the expression's type name e the rider's token's first.
Adicione several fragments usando "put" e the expression's variable e "into" e the intermediate e the rider's token's first. \aqui muda o put
Adicione several fragments usando "adicione" e the term's variable e "to" e the intermediate e the rider's token's first. \ aqui muda o add
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile um expression usando um rider (then):
Se the compiler's abort flag estiver verde, cancele.
Se the expression's variable for inexistente, abort with "O seu 'then', está errado. Eu não entendi o que é o(a) '" then the expression's phrase then "'." e the rider; exit.
Move the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "O seu 'then', está errado. Eu não sei o que é o(a) '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando "string" e the rider's token's first.
Adicione the put or convert fragments usando the expression's variable e the intermediate e the rider's token's first.
Convert the term por concatenation usando the rider.
Adicione several fragments usando "posponha" e the term's variable e "to" e the intermediate e the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile um expression usando um rider (times):
Se the compiler's abort flag estiver verde, cancele.
Se the expression's variable for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar o '" then the expression's phrase then "'." e the rider; exit.
Move the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar um '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando the expression's type name e the rider's token's first.
Adicione several fragments usando "put" e the expression's variable e "into" e the intermediate e the rider's token's first.
Adicione several fragments usando "multiplique" e the intermediate e "por" e the term's variable e the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile the header of um routine:
Se the routine for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Slap um rider on the routine's routine header.
Move the rider (compiler rules).
Se the rider's token é any decide, compile the header of the routine usando the rider (decider); exit.
Se the rider é the start of any reverse-possessive function, compile the header of the routine usando the rider (reverse-possessive function); exit.
Se the rider é the start of any function, compile the header of the routine usando the rider (function); exit.
Se the rider's token for "compativelmente", compile the header of the routine usando the rider (callback); exit.
Compile the header of the routine usando the rider (procedure).

Etapas necessárias para que se compile the header of um routine usando um rider (callback):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Abra the routine's callback flag.
Compile the routine's monikettes e the routine's parameters usando the rider.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já tinha escrito um função '" then the routine's moniker then "'." e the routine's locus; exit.
Index the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the header of um routine usando um rider (decider):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Se the rider's token for not any conditional, abort with "It's 'Decide IF.' Sempre dizemos, 'Decide IF'. Certo?" e the rider; exit.
Move the rider (compiler rules).
Abra the routine's decider flag.
Compile the routine's monikettes e the routine's parameters usando the rider.
Se any of the routine's monikettes are negative words, abort with "Não consigo me dar bem com palavras negativas nos decider names." e the rider; exit.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já me contou como'" then the routine's moniker then "'." e the routine's locus; exit.
Index the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the header of um routine usando um rider (function):
Se the compiler's abort flag estiver verde, cancele.
Abra the routine's function flag.
Adicione um monikette to the routine's monikettes usando "put".
Move the rider (compiler rules).
Se the rider's token é any indefinite article, abra um flag.
Se the flag estiver verde, compile the routine's monikettes e the routine's parameters usando the rider (indefinite article).
Se the flag estiver not verde, compile the routine's monikettes e the routine's parameters usando the rider (definite article).
Se the rider's token for not any possessive, abort with "Tá faltando um 's por aqui (ou está no lugar errado)." e the rider; exit. \ not translated - no possessives in Spanish
Move the rider (compiler rules).
Scan um name usando the rider.
Adicione another monikette to the routine's monikettes usando "'s " then the name.
Se the rider's token for not "into", abort with "Eu estava esperando um palavra 'into', mas encontrei um palavra '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to the routine's monikettes usando "into".
Convert the routine's monikettes to um moniker.
Se the moniker estiver in the routine index, abort with "Eu já sei como '" then the moniker then "'." e the routine's locus; exit. \ not translated - no possessives in Spanish
Index the routine usando the routine's monikettes e the routine index.
Move the rider (compiler rules).
Se the rider's token for not any indefinite article, abort with "Estava esperando um artigo indefinido, mas achei isso aqui: '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Compile the routine's monikettes e the routine's parameters usando the rider (indefinite article).
Se the rider's token estiver not blank, abort with "Tem comandos extras no fim dessa função." e the rider; exit. \ not translated - no possessives in Spanish
Convert the routine's monikettes to the routine's moniker.
Index the routine usando the routine's monikettes e the routine index. \ por employs

Etapas necessárias para que se compile the header of um routine usando um rider (procedure):
Se the compiler's abort flag estiver verde, cancele.
Compile the routine's monikettes e the routine's parameters usando the rider.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já escreveu como fazer '" then the routine's moniker then "'." e the routine's locus; exit.
Index the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the headers of some routines:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um routine from the routines.
Se the routine for inexistente, cancele.
Compile the header of the routine.
Repeat.

Etapas necessárias para que se compile um literal usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Adicione the literal to the literals usando the rider's token's first.
\Se the rider's token é any flag literal, compile the literal usando the rider (flag); exit.
Se the rider's token é any hex literal, compile the literal usando the rider (hex); exit.
Se the rider's token é any numeric literal, compile the literal usando the rider (numeric); exit.
Se the rider's token é any endereço de memória literal, compile the literal usando the rider (endereço de memória); exit.
Se the rider's token é any string literal, compile the literal usando the rider (string); exit.
Abort with "Erro interno - compile um term usando um rider (literal)" e the rider.

Etapas necessárias para que se compile um literal usando um rider (flag):
Se the compiler's abort flag estiver verde, cancele.
Convert the rider's token to um flag.
Convert the flag to the literal's data.
Move the rider (compiler rules).
Put "flag" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal usando um rider (hex):
Se the compiler's abort flag estiver verde, cancele.
Put the rider's token into um nibble substring.
Adicione 1 to the nibble substring's first.
Convert the nibble substring to the literal's data.
Move the rider (compiler rules).
Put "texto hexadecimal" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal usando um rider (numeric - integer):
Se the compiler's abort flag estiver verde, cancele.
Convert the rider's token to um número.
Convert the número to the literal's data.
Move the rider (compiler rules).
Put "número" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal usando um rider (numeric - ratio):
Se the compiler's abort flag estiver verde, cancele.
Convert the rider's token to um ratio.
Convert the ratio to the literal's data.
Move the rider (compiler rules).
Put "ratio" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal usando um rider (numeric - with unit of measure):
Se the compiler's abort flag estiver verde, cancele.
Convert the rider's token to um ratio.
Move the rider (compiler rules).
Scan um name usando the rider.
Find um type usando the name e the type index.
Se the type for inexistente, abort with "'" then the name then "' é uma unidade de medida inexistente." e the literal's locus; exit.
Se the type cannot be reduced to "número", abort with "'" then the name then "' é uma unidade de medida inválida." e the literal's locus; exit.
Put the type's scale into um final ratio.
Se the type's scale for 0, put 1/1 into the final ratio.
Multiplique the final ratio por [via] the ratio.
Reduce the final ratio.
Se the final ratio's denominator for 0, abort with "Parece que essa é uma unidade de medida inválida." e the literal's locus.
Put the final ratio's numerator dividido por the final ratio's denominator into um número.
Put the type's name into the literal's type name.
Convert the número to the literal's data.
Resolve the literal.

Etapas necessárias para que se compile um literal usando um rider (numeric):
Se the compiler's abort flag estiver verde, cancele.
Se the rider é followed por [via] any unit of measure, compile the literal usando the rider (numeric - with unit of measure); exit.
Se the rider's token é any integer literal, compile the literal usando the rider (numeric - integer); exit.
Se the rider's token é any ratio literal, compile the literal usando the rider (numeric - ratio); exit.
Se the rider's token é any mixed literal, compile the literal usando the rider (numeric - ratio); exit.

Etapas necessárias para que se compile um literal usando um rider (endereço de memória):
Se the compiler's abort flag estiver verde, cancele.
Convert 0 to the literal's data. \ was nil
Move the rider (compiler rules).
Put "endereço de memória" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal usando um rider (string):
Se the compiler's abort flag estiver verde, cancele.
Put the rider's token into the literal's data.
Unquote the literal's data.
Move the rider (compiler rules).
Put "string" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile some monikettes e some parameters usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Se the rider's token é any definite article, compile the monikettes e the parameters usando the rider (definite article); repeat.
Se the rider está on any indefinite article, compile the monikettes e the parameters usando the rider (indefinite article); repeat.
Se the rider está on any monikette string, compile the monikettes e the parameters usando the rider (monikette string); repeat.
Abort with "'" then the rider's token then "' não é um nome de função que eu conheça." e the rider.

Etapas necessárias para que se compile some monikettes e some parameters usando um rider (definite article):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Scan um name usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Prepend "the " to the name.
Adicione um monikette to the monikettes usando the name.

Etapas necessárias para que se compile some monikettes e some parameters usando um rider (indefinite article):
Se the compiler's abort flag estiver verde, cancele.
Adicione um parameter to the parameters usando "parameter" e the rider's token's first.
\PAL
Se the rider's token for "outra", put "segunda" into the parameter's name.
Se the rider's token for "outro", put "segundo" into the parameter's name.
\CAL
Se the rider's token for "another", put "other" into the parameter's name.
Move the rider (compiler rules).
Scan um name usando the rider.
Extend the parameter's name with the name.
Se the rider's token é any called, compile the call'd part usando the rider e the parameter.
Resolve the parameter.
Se the parameter é duplicated in the parameters, abort with "Cara, você repetiu o parâmetro '" then the parameter's name then "'." e the parameter's locus; exit.
Adicione um monikette to the monikettes usando the parameter's type.

Etapas necessárias para que se compile some monikettes e some parameters usando um rider (monikette string):
Se the compiler's abort flag estiver verde, cancele.
Adicione um monikette to the monikettes usando the rider's token.
Move the rider (compiler rules).

Etapas necessárias para que se compile some monikettes usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider está on any monikette string, adicione um monikette to the monikettes usando the rider's token; move the rider (compiler rules); repeat.
Se the rider's token for not the start of any expression, cancele.
Compile um expression usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Adicione another monikette to the monikettes usando the expression.
Repeat.

\Etapas necessárias para que se compile some monikettes usando um rider:
\Se the compiler's abort flag estiver verde, cancele.
\Se the rider's token é any monikette string, adicione um monikette to the monikettes usando the rider's token; move the rider (compiler rules); repeat.
\Se the rider's token for not the start of any expression, cancele.
\Compile um expression usando the rider.
\Se the compiler's abort flag estiver verde, cancele.
\Adicione another monikette to the monikettes usando the expression.
\Repeat.

Etapas necessárias para que se compile the next statement usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token é any conditional, compile the next statement usando the rider (if); exit.
Se the rider's token é any loop, compile the next statement usando the rider (loop); exit.
Se the rider's token é any privatize, compile the next statement usando the rider (privatize); exit.
Se the rider's token for not the start of any statement, abort with "Eu esperava uma declaração aqui, mas encontrei: '" then the rider's token then "'." e the rider; exit.
Compile the next statement usando the rider (other).
Se the rider's token for not the period pedaço, abort with "Acho que tá faltando um pontinho por aqui." e the rider; exit.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (break):
Adicione um fragment usando the break tag.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (call - external):
Put the rider's token into um string.
Unquote the string.
Move the rider (compiler rules).
Se the rider's token for not any string literal, abort with "Cara, você precisa colocar os nomes entre aspas, mas você colocou '" then the rider's token then "'." e the rider; exit.
Put the rider's token into another string.
Unquote the other string.
Move the rider (compiler rules).
Adicione um entry to the imports usando the string e the other string.
Se the rider's token for "with", compile the next statement usando the rider (call - with clause).
Se the rider's token for "returning", compile the next statement usando the rider returning um term (call - returning part).
Adicione um fragment usando the call external tag e the entry.
Se the term é empty, cancele.
Se the term's variable for inexistente, abort with "Não entendi bem o que é '" then the term's phrase then "'." e the rider; exit.
Adicione another fragment usando the save eax tag e the term's variable.

Etapas necessárias para que se compile the next statement usando um rider (call - indirect):
Compile um expression usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the expression's variable for inexistente, abort with "Eu não sei o que é '" then the expression's phrase then "'." e the rider; exit.
Se the expression's type cannot be reduced to "endereço de memória", abort with "Eu preciso de um endereço de memória type nesse CALL statement." e the rider; exit.
Se the rider's token for "with", compile the next statement usando the rider (call - with clause).
Se the rider's token for "returning", compile the next statement usando the rider returning um term (call - returning part).
Adicione um fragment usando the call indirect tag e the expression's variable.
Se the term é empty, cancele.
Se the term's variable for inexistente, abort with "Acho que essa varíavel é inválida: '" then the term's phrase then "'." e the rider; exit.
Adicione another fragment usando the save eax tag e the term's variable.

Etapas necessárias para que se compile the next statement usando um rider (call - internal):
Compile some monikettes usando the rider.
Find um routine usando the monikettes.
Se the routine for not inexistente, adicione push fragments usando the monikettes.
Se the routine for not inexistente, destroy the monikettes; adicione um fragment usando the call internal tag e the routine; exit.
Convert the monikettes to um moniker.
Destroy the monikettes.
\Put "Eu ainda não aprendi como"  into a reply.
\Say the reply.
Put the moniker into a reply.
\Say the reply.
Abort with "Eu ainda não aprendi como '" then the moniker then "'." e the rider.

Etapas necessárias para que se compile the next statement usando um rider (call - with clause): \ this guy é recursise so parameters obtenha passed right to left
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Compile um expression usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the expression's variable for inexistente, abort with "Eu não entendo um variável: '" then the expression's phrase then "'." e the rider; exit.
Se the expression's type for not value pushable, abort with "'" then the expression's type's name then "' não pode ser processado corretamente." e the rider; exit.
Se the rider's token é any and, compile the next statement usando the rider (call - with clause).
Adicione um fragment usando the push value tag e the expression's variable.

Etapas necessárias para que se compile the next statement usando um rider (call):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Se the rider's token é any string literal, compile the next statement usando the rider (call - external); exit.
Compile the next statement usando the rider (call - indirect).  

Etapas necessárias para que se compile the next statement usando um rider (exit):
Se the current routine's decider flag estiver verde, abort with "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" e the rider; exit.
Adicione um fragment usando the exit tag.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (if):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Compile some monikettes usando the rider.
Remove any negatives from the monikettes returning um flag.
Find um routine usando the monikettes.
Se the routine for not inexistente, adicione push fragments usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Preciso de um decider que tenha como palavras: '" then the moniker then "'." e the rider; exit.
Se the routine's decider flag estiver not verde, abort with "Cara eu vou precisar de um decider aqui, blz?" e the rider; exit.
Se the rider's token for not the comma pedaço, abort with "Acho que você esqueceu de uma vírgula, eu achei isso aqui: '" then the rider's token then "'." e the rider; exit.
Adicione um fragment usando the call internal tag e the routine.
Se the flag estiver verde, adicione another fragment usando the not tag.
Adicione um third fragment usando the jump false tag.
Move the rider (compiler rules).
Loop.
Compile the next statement usando the rider (other).
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token é the semi-colon pedaço, move the rider (compiler rules); repeat.
Se the rider's token for not the period pedaço, abort with "Você precisa usar um ponto ao invés de usar o termo '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Adicione um fourth fragment usando the end if tag.

Etapas necessárias para que se compile the next statement usando um rider (intel):
Move the rider (compiler rules).
Se the rider's token for not any hex literal, abort with "Eu preciso de um pouco de machine code, mas o que eu achei foi '" then the rider's token then "'." e the rider; exit.
Adicione um fragment usando the intel tag.
Put the rider's token into um nibble substring.
Adicione 1 to the nibble substring's first.
Convert the nibble substring to the fragment's code.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (loop):
Se the compiler's abort flag estiver verde, cancele.
Adicione um fragment usando the loop tag.
Move the rider (compiler rules).
Se the rider's token for not the period pedaço, abort with "Parece que alguém esqueceu de colocar um ponto por aí." e the rider; exit.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (other):
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Se the rider's token é any exit, compile the next statement usando the rider (exit); exit.
Se the rider's token é any repeat, compile the next statement usando the rider (repeat); exit.
Se the rider's token é any break, compile the next statement usando the rider (break); exit.
Se the rider's token é any say, compile the next statement usando the rider (say); exit.
Se the rider's token for "intel", compile the next statement usando the rider (intel); exit.
Se the rider's token for "push", compile the next statement usando the rider (push); exit.
Se the rider's token é any call, compile the next statement usando the rider (call); exit.
Se the rider's token é any point, compile the next statement usando the rider (point); exit.
Se the rider's token é any conditional, abort with "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." e the rider; exit.
Se the rider's token é any privatize, abort with "A sentença 'privatizar' não pode ser usada aqui." e the rider; exit.
Se the rider's token é any loop, abort with "Usar um percorra deentro de um SE é uma ótima forma de arranjar problemas." e the rider; exit.
Se the rider's token é any employ, abort with "'Empregue' deve ser o único imperativo em uma rotina." e the rider; exit.
Compile the next statement usando the rider (call - internal).

Etapas necessárias para que se compile the next statement usando um rider (point):
Move the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Acho que o termo '" then the term's phrase then "' está vazio." e the rider; exit.
Se the term's kind for "literal", abort with "Você usou o tipo errado de variável aqui (literal)." e the rider.
Se the term's type's length for not 4, abort with "Você usou uma variável de comprimento errado (<>4)." e the rider.
Se the rider's token for not "to", abort with "Acho que faltou um 'to', mas você usou '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Se the rider's token for not "routine", abort with "Acho que faltou a palavra 'routine'. Você usou o termo '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Compile um routine reference usando the rider.
Convert the routine reference to um moniker.
Destroy the routine reference.
Find um routine usando the moniker e the routine index.
Se the routine for inexistente, abort with "Não achei a tarefa '" then the moniker then "' que você falou." e the rider; exit.
Adicione um fragment usando the routine address tag e the routine.
Put the term's variable into the fragment's variable.

Etapas necessárias para que se compile the next statement usando um rider (privatize):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Comando 'privatize', Inválido. Eu acho que o termo da variável '" then the term's phrase then "' está vazio." e the rider; exit.
Se the term's kind for not "parameter", abort with "Você só pode privatizar parâmetros." e the rider; exit.
Adicione um local to the current routine's locals usando "local" e the rider's token's first.
Put the term's name into the local's name.
Put the term's nickname into the local's nickname.
Put the term's type name into the local's type name.
Resolve the local.
Prepend "original " to the term's name.
Se the term's nickname estiver not blank, prepend "original " to the term's nickname.
Adicione several fragments usando "put" e the term's variable e "into" e the local e the rider's token's first.
Se the rider's token for not the period pedaço, abort with "Você vive esquecendo dos pontos né?." e the rider; exit.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (push):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Compile um expression usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the expression's variable for inexistente, abort with "Comando 'push' inválido, um expressão '" then the expression's phrase then "' parece estar vazia." e the rider; exit.
Se the expression's type for not value pushable, abort with "Valores do tipo '" then the expression's type's name then "' não podem ser pushed." e the rider; exit.
Adicione um fragment usando the push value tag e the expression's variable.

Etapas necessárias para que se compile the next statement usando um rider (repeat):
Adicione um fragment usando the repeat tag.
Move the rider (compiler rules).

\Etapas necessárias para que se compile the next statement usando um rider (say):
\Se the current routine's decider flag estiver not verde, compile the next statement usando the rider (call - internal); exit.
\Move the rider (compiler rules).
\Compile um expression usando the rider.
\Se the compiler's abort flag estiver verde, cancele.
\Se the expression's variable for inexistente, abort with "No es válido este 'diga', no entiendo la variable '" then the expression's phrase then "'." e the rider; exit.
\Se the expression's type cannot be reduced to "flag", abort with "Necesito un rotundo 'si' o 'no' aquí." e the rider; exit.
\Adicione um fragment usando the load eax tag e the expression's variable.
\Adicione another fragment usando the exit tag.

Etapas necessárias para que se compile the next statement usando um rider (say):
Se the current routine's decider flag estiver not verde, compile the next statement usando the rider (call - internal); exit.
Move the rider (compiler rules).
Se the rider's token for not any decider literal, abort with "Você precisa terminar com um yes ou no." e the rider; exit.
Feche um flag. Se the rider's token é any positive decider literal, abra the flag.
Move the rider (compiler rules).
Se the rider's token for not the period pedaço, abort with "Faltou um ponto. Você usou o termo: '" then the rider's token then "'." e the rider; exit.
Adicione um fragment usando the load eax tag e the flag.
Adicione another fragment usando the exit tag.

Etapas necessárias para que se compile the next statement usando um rider returning um term (call - returning part):
Move the rider (compiler rules).
Compile the term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Eu não compreendi o termo da variável '" then the term's phrase then "'. Ela parece estar vazia." e the rider; exit.
Se the term's type for not value pushable, abort with "Uma varíavel de 1, 2, ou 4-pedaços é necessária na 'returning' clause." e the rider.

Etapas necessárias para que se compile um routine reference usando um rider:
Se the rider's token for "to", move the rider (compiler rules).
Se the rider é the start of any function, compile the routine reference usando the rider (function); exit.
Se the rider's token é any decide, compile the routine reference usando the rider (decide).
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Se the rider's token for ".", cancele.
Se the rider's token é any definite article, compile the routine reference usando the rider (definite article); repeat.
Se the rider's token é any indefinite article, compile the routine reference usando the rider (indefinite article); repeat.
Se the rider está on any monikette string, compile the routine reference usando the rider (monikette string); repeat.
Abort with "'" then the rider's token then "' não é válido em  um employ statement." e the rider.

Etapas necessárias para que se compile um routine reference usando um rider (decide):
Move the rider (compiler rules).
Se the rider's token for not any conditional, abort with "Sempre use DECIDE IF, ao invés de apenas DECIDE com '" then the rider's token then "' logo em seguida." e the rider; exit.
Move the rider (compiler rules).

Etapas necessárias para que se compile um routine reference usando um rider (definite article):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Scan um name usando the rider.
Prepend "the " to the name.
Adicione um monikette to the routine reference usando the name.

Etapas necessárias para que se compile um routine reference usando um rider (function):
Se the compiler's abort flag estiver verde, cancele.
Adicione um monikette to the routine reference usando "put".
Move the rider (compiler rules).
Se the rider's token é any indefinite article, abra um flag.
Se the flag estiver verde, compile the routine reference usando the rider (indefinite article).
Se the flag estiver not verde, compile the routine reference usando the rider (definite article).
Se the rider's token for not any possessive, abort with "Eu estava esperando un 's, mas apareceu '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Move the rider (compiler rules).
Scan um name usando the rider.
Adicione another monikette to the routine reference usando "'s " then the name.
Se the rider's token for not "into", abort with "E estava esperando um palavra 'into', mas encontrei '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to the routine reference usando "into".
Move the rider (compiler rules).
Se the rider's token for not any indefinite article, abort with "Eu estava esperando um artigo indefinido mas encontrei isso: '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Compile the routine reference usando the rider (indefinite article).

Etapas necessárias para que se compile um routine reference usando um rider (indefinite article):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Scan um name usando the rider.
Find um type e um nickname usando the name.
Se the type for inexistente, abort with "Employ statement inválido, Eu não sei o que é '" then the name then "'." e the rider; exit.
Adicione um monikette to the routine reference usando the type.

Etapas necessárias para que se compile um routine reference usando um rider (monikette string):
Se the compiler's abort flag estiver verde, cancele.
Adicione um monikette to the routine reference usando the rider's token.
Move the rider (compiler rules).

Etapas necessárias para que se compile um term usando um rider:
Clear the term.
Se the compiler's abort flag estiver verde, cancele.
Compile the term usando the rider (common part).
Se the rider está on any simile, cancele. \ added por invisible turtle project ***
\Se the rider's token for "as", compile the term usando the rider (as part).  \preposição
\Se the rider's token for "tão", compile the term usando the rider (as part). \ me parece desnecessário por ser usado apenas em funções.
Se the rider's token for "quão", compile the term usando the rider (as part).
Se the rider's token for "quanto", compile the term usando the rider (as part).
Se the rider's token for "como", compile the term usando the rider (as part).
\Se the rider's token for "que nem", compile the term usando the rider (as part).
Se the rider's token for "/", compile the term usando the rider (runtime ratio).

Etapas necessárias para que se compile um term usando um rider (as part):
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Comando 'as'inválido. Eu acho que um variável '" then the term's phrase then "' está vaiza." e the rider; exit.
Move the rider (compiler rules).
Se the rider's token for not any indefinite article, abort with "Tá faltando um artigo indefinido depois do 'como', mas você escreveu '" then the rider's token then "' no lugar disso." e the rider; exit.
Move the rider (compiler rules).
Scan um type name usando the rider.
Find um type usando the type name e the type index.
Se the type for inexistente, abort with "Eu não sei em qual tipo o '" then the type name then "' se encaixa." e the rider; exit.
Adicione um scratch usando the type's name e the rider's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Put the scratch into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider (common part):
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token é the dash pedaço, compile the term usando the rider (negated term); exit.
Se the rider's token é the cross pedaço, compile the term usando the rider (posigated term); exit.
Se the rider's token é the start of any variable, compile the term usando the rider (variable); exit.
Se the rider's token é the start of any new local, compile the term usando the rider (new local); exit.
Se the rider's token é any literal, compile the term usando the rider (literal); exit.
Abort with "Faltou um termo por aqui. Só achei isso aqui: '" then the rider's token then "'." e the rider.

Etapas necessárias para que se compile um term usando um rider (dereference - in place):
Se the term's variable for inexistente, abort with "Erro interno na função - compile um term usando um rider (dereference - in place). Termo vazio" e the rider; exit.
Put the term's type's target type's name into the term's type name.
Put the term's type's target type into the term's type.
Adicione um fragment usando the dereference tag e the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider (dereference):
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Dereference inválido, um variável '" then the term's phrase then "' parece estar vazia." e the rider; exit.
Se the term's type's target type for inexistente, abort with "Não consegui identificar o tipo desse target." e the rider; exit.
Se the term's kind for "scratch", compile the term usando the rider (dereference - in place); exit.
Adicione um scratch usando the term's type's target type's name e the rider's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Adicione another fragment usando the dereference tag e the scratch.
Put the scratch into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider (literal):
Se the compiler's abort flag estiver verde, cancele.
Compile um literal usando the rider.
Put the literal into the term's variable.
Clear the term's phrase.
Compile the term usando the rider (possessives).

Etapas necessárias para que se compile um term usando um rider (negated term):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Compile another term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the other term's variable for inexistente, abort with "Negate inválido, um variável '" then the other term's phrase then "' parece estar vazia." e the rider; exit.
Adicione um intermediate usando the other term's type name e the rider's token's first.
Adicione several fragments usando "put" e the other term's variable e "into" e the intermediate e the other term's locus.
Adicione two fragments usando "negate" e the intermediate e the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider (new local):
Se the compiler's abort flag estiver verde, cancele.
Se the current routine for inexistente, abort with "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e the rider; exit.
Adicione um local to the current routine's locals usando "local" e the rider's token's first.
\PAL
Se the rider's token for "outra", put "segunda" into the local's name.
Se the rider's token for "outro", put "segundo" into the local's name.
\CAL
Se the rider's token for "another", put "other" into the local's name.
Move the rider (compiler rules).
Scan um name usando the rider.
Extend the local's name with the name.
Se the rider's token é any called, compile the call'd part usando the rider e the local.
Resolve the local.
Se the local é duplicated in the current routine's parameters, abort with "o parâmetro '" then the local's name then "' já está sendo usado como parâmetro." e the local's locus; exit.
Se the local é duplicated in the current routine's locals, abort with "Já existe uma variável local chamada'" then the local's name then "'. Você tem que dar um nome diferente." e the local's locus; exit.
Eliminate duplicate nicknames usando the local e the current routine's nickname index.
Put the local into the term's variable.
Clear the term's phrase.
Compile the term usando the rider (possessives).

Etapas necessárias para que se compile um term usando um rider (posigated term):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Compile the term usando the rider.
Se the term's variable for inexistente, abort with "Posigate inválido, o termo da variável'" then the term's phrase then "' parece estar vazio." e the rider; exit.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider (possessive - magnitude):
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Use da magnitude inválido. An variável '" then the term's phrase then "' parece estar vazia." e the rider; exit.
Adicione um literal to the literals usando the rider's token's first.
Convert the term's type's length to the literal's data.
Put "número" into the literal's type name.
Resolve the literal.
Put the literal into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider (possessive - target):
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Você usou o target de forma errada. O termo da variável '" then the term's phrase then "' parece estar vazio." e the rider; exit.
Se the term's type cannot be reduced to "endereço de memória", abort with "Você só pode usar target com tipos endereço de memória." e the rider; exit.
Compile the term usando the rider (dereference).

Etapas necessárias para que se compile um term usando um rider (possessive - whereabouts):
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Você usou whereabouts da forma errada, erro no termo da variável '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando "endereço de memória" e the rider's token's first. 
Adicione um fragment usando the load address tag e the term's variable e the intermediate.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider (possessive): \ similar to "compile um term usando um rider (reverse-possessive)
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Scan um name usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the name é any magnitude, compile the term usando the rider (possessive - magnitude); exit.
Se the name é any target, compile the term usando the rider (possessive - target); exit.
Se the name é any whereabouts, compile the term usando the rider (possessive - whereabouts); exit.
Compile the term usando the rider e the name (possessive - field).

Etapas necessárias para que se compile um term usando um rider (possessives):
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token for not any possessive, cancele.
Compile the term usando the rider (possessive).
Repeat.  

Etapas necessárias para que se compile um term usando um rider (runtime ratio):
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for inexistente, abort with "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável '" then the term's phrase then "'." e the rider; exit.
Move the rider (compiler rules).
Compile another term usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the other term's variable for inexistente, abort with "Uso inválido da /, termo vazio da variável: '" then the other term's phrase then "'." e the rider; exit.
Adicione um intermediate usando "ratio" e the rider's token's first.
Adicione several fragments usando "put" e the term's variable e "e" e the other term's variable e "into" e the intermediate e the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider (variable):
Se the compiler's abort flag estiver verde, cancele.
Se the current routine for inexistente, abort with "Erro de tarefa vazia, nada pra pull da pilha aqui." e the rider; exit.
Move the rider (compiler rules).
Scan um name usando the rider.
Se the rider está on any reverse-possessive, compile the term usando the rider e the name (reverse-possessive); exit.
Find um variable usando the name.
Put the variable into the term's variable.
Put "the " into the term's phrase.
Posponha the name to the term's phrase.
Compile the term usando the rider (possessives).

Etapas necessárias para que se compile um term usando um rider e um field name (reverse-possessive):  \ this é recursive \ dahn version 2
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules). \ past the reverse-possessive starter
\Se the rider's token for not "del", Move the rider (compiler rules). \ past the reverse-possessive starter \ gerry added "if" part
\Se the rider's token for "del", adicione 1 to the rider's token's first. \ makes "del" look like "de el"
Se the rider's token for not any article, abort with "Esperaba un artículo, pero encontré '" then the rider's token then "'."; exit.
Put the rider's token into um article token.
Move the rider (compiler rules).
Scan um name usando the rider. 
Se the rider está on any reverse-possessive, abra um reverse-possessive flag.
Se the reverse-possessive flag estiver verde, compile the term usando the rider e the name (reverse-possessive).
Se the reverse-possessive flag estiver not verde, compile the term usando the rider e the name e the article (reverse-possessive prepare to unwind).
Compile the term usando the field name e the rider (reverse-possessive).

Etapas necessárias para que se compile um term usando um rider e um variable name e um article token (reverse-possessive prepare to unwind): \ dahn version 2
Se the article é the start of any variable, compile the term usando the rider e the variable name e the article (reverse-possessive prepare to unwind existing variable); exit.
Compile the term usando the rider e the variable name (reverse-possessive prepare to unwind new local).

Etapas necessárias para que se compile um term usando um rider e um variable name e um article token (reverse-possessive prepare to unwind existing variable): \ dahn version 2
Find um variable usando the variable name.
Se the variable for inexistente, abort with "No se pudo encontrar una variable con el nombre '" then the variable name then "'.".
Put the variable into the term's variable.
Put "the " into the term's phrase.
Posponha the variable name to the term's phrase.

Etapas necessárias para que se compile um term usando um rider e um variable name (reverse-possessive prepare to unwind new local): \ dahn version 2
Se the compiler's abort flag estiver verde, cancele.
Adicione um local to the current routine's locals usando "local" e the rider's token's first.
\PAL
Se the rider's token for "outra", put "segunda" into the local's name.
Se the rider's token for "outro", put "segundo" into the local's name.
\CAL
Se the rider's token for "another", put "other" into the local's name.
Extend the local's name with the variable name.
Se the rider's token é any called, compile the call'd part usando the rider e the local.
Resolve the local.
Se the local é duplicated in the current routine's parameters, abort with "'" then the local's name then "' ya está en uso como parámetro." e the local's locus; exit.
Se the local é duplicated in the current routine's locals,abort with "'" then the local's name then "' ya está en uso como una variable local." e the local's locus; exit.
Eliminate duplicate nicknames usando the local e the current routine's nickname index.
Put the local into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um field name e um rider (reverse-possessive):  \ similar to "compile um term usando um rider (possessive)" \ dahn
Se the compiler's abort flag estiver verde, cancele.
Se the field name é any magnitude, compile the term usando the rider (possessive - magnitude); exit.
Se the field name é any target, compile the term usando the rider (possessive - target); exit.
Se the field name é any whereabouts, compile the term usando the rider (possessive - whereabouts); exit.
Compile the term usando the rider e the field name (possessive - field).

Etapas necessárias para que se compile um term usando um rider e um field term:
Se the compiler's abort flag estiver verde, cancele.
Se the field term's dereference flag estiver verde, compile the term usando the rider (dereference).  
Se the field term's function for not inexistente, compile the term usando the rider e the field term (function); exit.
Se the term's kind for "scratch", compile the term usando the rider e the field term (in place); exit.
Put the field term's field into um field.
Adicione um scratch usando the field's type's name e the rider's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Se the field's offset for not 0, adicione um third fragment usando the increment tag e the scratch e the field's offset.
Put the scratch into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider e um field term (function):
Se the compiler's abort flag estiver verde, cancele.
Put the field term's function into um routine.
Put the routine's parameters' last into um parameter.
Se the parameter for inexistente, abort with "Erro interno na função compile um term usando um rider e um field term (function) - parâmetro vazio." e the rider; exit.
Se the parameter's type for inexistente, abort with "Erro interno 2 na função compile um term usando um rider e um field term (function) - tipo do parâmetro inexistente." e the rider; exit.
Adicione um intermediate usando the parameter's type's name e the rider's token's first.
Adicione um fragment usando the push address tag e the intermediate.
Se the field term's push flag estiver verde, adicione another fragment usando the push address tag e the term's variable.
Adicione um third fragment usando the call internal tag e the routine.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider e um field term (in place):
Se the compiler's abort flag estiver verde, cancele.
Put the field term's field into um field.
Put the field's type's name into the term's type name.
Put the field's type into the term's type.
Se the field's offset for not 0, adicione um third fragment usando the increment tag e the term's variable e the field's offset.
Clear the term's phrase.

Etapas necessárias para que se compile um term usando um rider e um name (possessive - field):
Se the compiler's abort flag estiver verde, cancele.
Se the term's variable for not inexistente, put the term's type into um type.
Find um field term usando the term's phrase e the type e the name.
Se the field term for not empty, compile the term usando the rider e the field term; exit.
Se the term's variable for inexistente, abort with "Erro: variável vazia '" then the term's phrase then "'." e the rider; exit.
Se the type can be reduced to "endereço de memória", put the type's target type into the type.
Se the type for inexistente, abort with "Não existe o campo '" then the name then "' no tipo '" then the term's type's name then "'." e the rider; exit.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, abort with "Não tem nenhum campo '" then the name then "' no tipo '" then the term's type's name then "'." e the rider; exit.
Find um deep field term usando "" e the field's type e the name.
Se the deep field term é empty, repeat.
Put the field into um first field term's field.
Se the term's type can be reduced to "endereço de memória", abra the first field term's dereference flag.
Compile the term usando the rider e the first field term.
Compile the term usando the rider e the deep field term.

The compiler é um conjunto with
An directory,
An timer,
An abort flag,
An abort message,
An abort path,
An abort row#,
An name count,
An exe buffer,
An listing buffer.

The compiling routine bodies timer é um timer.

The compiling routine headers timer é um timer.

Etapas necessárias para que se convert some monikettes to um moniker:
Convert the monikettes to the moniker usando the monikettes' last.

Etapas necessárias para que se convert some monikettes to um moniker usando um monikette:
Clear the moniker.
Loop.
Obtenha um current monikette from the monikettes.
Se the current monikette for inexistente, cancele.
Posponha the current monikette to the moniker.
Se the current monikette é the monikette, cancele.
Repeat.

Etapas necessárias para que se convert um nibble substring to um string: employ convert um nibble string to um texto hexadecimal.

Etapas necessárias para que se convert um term por concatenation usando um rider: \ used por right-side THEN operand
Se the term's variable for inexistente, abort with "Erro: variável do termo está vazia '" then the term's phrase then "'." e the rider; exit.
Se the term's type can be reduced to "string", cancele.
Adicione um intermediate usando "string" e the rider's token's first.
Adicione the put or convert fragments usando the term's variable e the intermediate e the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se copy um field into another field:
Se the field for inexistente, void the other field; exit.
Allocate memory por the other field.
Put the field's locus into the other field's locus.
Put the field's name into the other field's name.
Put the field's nickname into the other field's nickname.
Put the field's type name into the other field's type name.
Put the field's type into the other field's type.
Put the field's count into the other field's count.
Put the field's redefinition target name into the other field's redefinition target name.
Put the field's reference flag into the other field's reference flag.
Put the field's offset into the other field's offset.

Etapas necessárias para que se copy some fields into some other fields:
Obtenha um field from the fields.
Se the field for inexistente, cancele.
Copy the field into another field.
Posponha the other field to the other fields.
Repeat.

Etapas necessárias para que se copy some fields into some other fields (data fields only):
Se the fields' count é less than 4, cancele. \ por english next e prev e spanish next e prev redefinitions
\Se the fields' first for inexistente, cancele.
\Se the fields' first's next for inexistente, cancele.
\Se the fields' first's next's next for inexistente, cancele.
\\Put the fields' first's next's next into um field. \ skip next e prev
\Se the fields' first's next's next's next for inexistente, cancele.
\Se the fields' first's next's next's next's next for inexistente, cancele.
\Se the fields' first's next's next's next's next's next for inexistente, cancele.
Put the fields' first's next's next's next's next into um field. \ english next e prev e spanish next e prev redefinitions
Loop.
Se the field for inexistente, cancele.
Copy the field into another field.
Posponha the other field to the other fields.
Obtenha the field from the fields.
Repeat.

Etapas necessárias para que se copy um monikette into another monikette:
Se the monikette for inexistente, void the other monikette; exit.
Allocate memory por the other monikette.
Put the monikette's string into the other monikette's string.
Put the monikette's type into the other monikette's type.
Put the monikette's variable into the other monikette's variable.
\ don't copy substring
Put the monikette's current type into the other monikette's current type.

Etapas necessárias para que se copy some monikettes into some other monikettes:
Destroy the other monikettes.
Loop.
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Copy the monikette into another monikette.
Posponha the other monikette to the other monikettes.
Repeat.

Etapas necessárias para que se create um entry:
Allocate memory por the entry.

Etapas necessárias para que se create um fragment usando um tag:
Allocate memory por the fragment.
Put the tag into the fragment's tag.

Etapas necessárias para que se create um import:
Allocate memory por the import.

Etapas necessárias para que se create um monikette:
Allocate memory por the monikette.

Etapas necessárias para que se create um routine:
Allocate memory por the routine.

Etapas necessárias para que se create um source file:
Allocate memory por the source file.

Etapas necessárias para que se create um type:
Allocate memory por the type.
Put 0/1 into the type's scale.
Put -1 into the type's length.

Etapas necessárias para que se create um variable usando um kind:
Allocate memory por the variable.
Put the kind into the variable's kind.
Put 1 into the variable's count.

The current header address é um address.

The current name address é um address.

The current routine é um routine.

The current thunk address é um address.

The data borough é um borough.

Etapas necessárias para que se determine se any of some monikettes are negative words:
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, say no.
Se the monikette's string é any negative word, say yes.
Repeat.

Etapas necessárias para que se determine se um pedaço é any glom pedaço:
Se the pedaço é any letter, say yes.
Se the pedaço é any digit, say yes.
Se the pedaço é the tilde pedaço, say yes.
Se the pedaço é the at-sign pedaço, say yes.
Se the pedaço é the número-sign pedaço, say yes.
Se the pedaço é the percent-sign pedaço, say yes.
Se the pedaço é the ampersand pedaço, say yes.
Se the pedaço é the underscore pedaço, say yes.
Se the pedaço é the single-quote pedaço, say yes.
Se the pedaço é the dash pedaço, say yes.
Se the pedaço é the cross pedaço, say yes.
Se the pedaço é the slash pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um pedaço é any mark:
Se the pedaço é the period pedaço, say yes.
Se the pedaço é the comma pedaço, say yes.
Se the pedaço é the semi-colon pedaço, say yes.
Se the pedaço é the colon pedaço, say yes.
Se the pedaço é the exclamation  pedaço, say yes.
Se the pedaço é the question-mark pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um pedaço é any stressed vowel:
Se the pedaço estiver in "áãâéêíóõôúü", say yes.
Say no.

Etapas necessárias para que se determine se um pedaço é any symbol:
Se the pedaço é the caret pedaço, say yes.
Se the pedaço é the bar pedaço, say yes.
Se the pedaço é the asterisk pedaço, say yes.
Se the pedaço é the cross pedaço, say yes.
Se the pedaço é the dash pedaço, say yes.
Se the pedaço é the slash pedaço, say yes.
Se the pedaço é the left-alligator pedaço, say yes.
Se the pedaço é the right-alligator pedaço, say yes.
Se the pedaço é the left-brace pedaço, say yes.
Se the pedaço é the right-brace pedaço, say yes.
Se the pedaço é the equal-sign pedaço, say yes.
Se the pedaço for 128, say yes.
Se the pedaço for 130, say yes.
Se the pedaço é between 132 e 137, say yes.
Se the pedaço for 139, say yes.
Se the pedaço é between 145 e 153, say yes.
Se the pedaço for 155, say yes.
Se the pedaço é between 161 e 180, say yes.
Se the pedaço é between 183 e 191, say yes.
Se the pedaço for 215, say yes.
Se the pedaço for 247, say yes.
Say no.

Etapas necessárias para que se determine se um field term é empty:
Se the field term's field for not inexistente, say no.
Se the field term's function for not inexistente, say no.
Say yes.

Etapas necessárias para que se determine se some fields should be finalized:
Obtenha um field from the fields.
Se the field for inexistente, say no.
Se the field's type should be finalized, say yes.
Repeat.

Etapas necessárias para que se determine se um item looks reamish:
Load the item's path into um buffer.
Se the buffer starts with "ream cal", say yes.
Say no.

Etapas necessárias para que se determine se um moniker estiver in um index:
Find um refer usando the moniker e the index.
Se the refer for inexistente, say no.
Se the refer's endereço de memória for inexistente, say no.
Say yes.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se the monikette for inexistente, say yes.
Se the monikette's current type for not inexistente, say no.
Se the monikette's current substring estiver not blank, say no.
Say yes.

Etapas necessárias para que se determine se um name é any magnitude:
\PAL
Se the name for "magnitude", say yes.
\CAL
Se the name for "magnitud", say yes.
Say no.

Etapas necessárias para que se determine se um name é any target:
\PAL
Se the name for "conteúdo", say yes.
Se the name for "alvo", say yes.
\CAL
Se the name for "target", say yes.
Se the name for "objetivo", say yes.
Say no.

Etapas necessárias para que se determine se um name é any whereabouts:
\PAL
Se the name for "paradeiro", say yes.
\CAL
Se the name for "whereabouts", say yes.
Say no.

Etapas necessárias para que se determine se um name é any valid field name:
Se the name é any magnitude, say no.
Se the name é any target, say no.
Se the name é any whereabouts, say no.
Say yes.

Etapas necessárias para que se determine se um rider é followed por [via] any unit of measure:
Privatize the rider.
Move the rider (compiler rules).
Se the rider for not on any name starter, say no.
Scan um name usando the rider.
Find um type usando the name e the type index.
Se the type for inexistente, say no.
Se the name for not "times", say yes. \ special because times é um infix operator e um unit of measure
Se the rider's token é the start of any expression, say no.
Say yes.

Etapas necessárias para que se determine se um rider está on any nested double-quote:
Se the rider's source starts with """""", say yes.
Say no.

Etapas necessárias para que se determine se um rider está on any possessive:
Se the rider's source estiver blank, say no.
Se the rider's source's first's target for not the single-quote pedaço, say no.
Se the rider está on any possessive (type 1 - single-quote, s, non-glom-byte), say yes.
Se the rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte), say yes.
Say no.

Etapas necessárias para que se determine se um rider está on any possessive (type 1 - single-quote, s, non-glom-byte):
Se the rider's source does not start with "'s", say no.
Privatize the rider.
Adicione 2 to the rider's source's first.
Se the rider's source estiver blank, say yes.
Se the rider's source's first's target for not any glom pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Privatize the rider.
Se the rider's source's first é the rider's original substring's first, say no.
Subtract 1 from the rider's source's first.
Se the rider's source's first's target for not the little-s pedaço or the big-s pedaço, say no.
Adicione 2 to the rider's source's first.
Se the rider's source estiver blank, say yes.
Se the rider's source's first's target for not any glom pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um rider está on any simile: \ added for invisible turtle project ***
Privatize the rider.
Se the rider's token for "LIKE", say yes.
Se the rider's token for not "AS", say no.
Move the rider (compiler rules).
Se the rider's token é any indefinite article, say no.
Say yes.

Etapas necessárias para que se determine se um rider é the start of any function:
Se the compiler's abort flag estiver verde, say no.
Se the rider's token for "Ponha", say yes.
\Se the rider's token for not any put, say no.
Se the rider's token for not "put", say no.
Privatize the rider.
Move the rider (compiler rules).
Se the rider's token for not any article, say no.
Move the rider (compiler rules).
Scan um name usando the rider.
Se the rider's token é any possessive, say yes.
Say no.

Etapas necessárias para que se determine se um string é any contraction giving another string (portuguese rules - "no"):
Se the string for not "no", say no.
Se the other string for "say", say no.
Se the other string for "diga", say no.
Se the other string for "dizer", say no.
Say yes.

Etapas necessárias para que se determine se um string ends with any consonant e another string:
Slap um substring on the string.
Subtract the other string's length from the substring's last.
Se the substring estiver blank, say no.
Se the substring's last's target for not any consonant, say no.
Se the string does not end with the other string, say no.
Say yes.

Etapas necessárias para que se determine se um string ends with any vowel e another string:
Slap um substring on the string.
Subtract the other string's length from the substring's last.
Se the substring estiver blank, say no.
Se the substring's last's target for not any vowel, say no.
Se the string does not end with the other string, say no.
Say yes.

Etapas necessárias para que se determine se um string ends with any consonant:
Se the string estiver blank, say no.
Se the string's last's target for not any consonant, say no.
Say yes.

Etapas necessárias para que se determine se um string ends with any vowel:
Se the string estiver blank, say no.
Se the string's last's target for not any vowel, say no.
Say yes.

Etapas necessárias para que se determine se um string é any plus:
\PAL
Se the string for "mais", say yes.
\CAL
Se the string for "plus", say yes.
Say no.

Etapas necessárias para que se determine se um string é any put:
\PAL
Se the string for "pôr", say yes.
\# Não precisa porque está como sinônimo: ver "Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules)"
\Se the string for "colocar", say yes. 
\CAL
Se the string for "put", say yes.
Say no.

Etapas necessárias para que se determine se um string é any minus:
\PAL
Se the string for "menos", say yes.
\CAL
Se the string for "minus", say yes.
Say no.

Etapas necessárias para que se determine se um string é any times:
\PAL
Se the string for "vezes", say yes.
\CAL
Se the string for "times", say yes.
Say no.

Etapas necessárias para que se determine se um string é any divided:
\PAL
Se the string for "dividido", say yes.
\CAL
Se the string for "divided", say yes.
Say no.

Etapas necessárias para que se determine se um string é any by:
\PAL
Se the string for "via", say yes.  \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se the string for "por", say yes.
\CAL
Se the string for "by", say yes.
Say no.

Etapas necessárias para que se determine se um string é any then:
\PAL
\# operador de concatenação de strings tipo: "abc" then "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida". 
Se the string for "depois", say yes.
Se the string for "então", say yes.
\CAL
Se the string for "then", say yes.
Say no.

Etapas necessárias para que se determine se um string é any has:
\PAL
Se the string for "tem", say yes.
Se the string for "têm", say yes.
Se the string for "possui", say yes.
Se the string for "possuem", say yes.
\CAL
Se the string for "has", say yes.
Se the string for "have", say yes.
Say no.

Etapas necessárias para que se determine se um string é any is:
\PAL
Se the string for "é", say yes.
Se the string for "está", say yes.
Se the string for "são", say yes.
Se the string for "estão", say yes.
\CAL
Se the string for "is", say yes.
Se the string for "are", say yes.
Say no.

Etapas necessárias para que se determine se um string é any equal:
\PAL
Se the string for "igual", say yes.
\CAL
Se the string for "equal", say yes.
Say no.

Etapas necessárias para que se determine se um string é any with:
\PAL
Se the string for "com", say yes.
\CAL
Se the string for "with", say yes.
Say no.

Etapas necessárias para que se determine se um string é any article:
Se the string é any indefinite article, say yes.
Se the string é any definite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se the string for "e", say yes.
Se the string for "ou", say yes.
Se the string for "nem", say yes.
\CAL
Se the string for "and", say yes.
Se the string for "both", say yes.
Se the string for "but", say yes.
Se the string for "either", say yes.
Se the string for "neither", say yes.
Se the string for "nor", say yes.
Se the string for "or", say yes.
Say no.

\Etapas necessárias para que se determine se um string é any flag literal:
\Se the string for "yes", say yes.
\Se the string for "no", say yes.
\Say no.

Etapas necessárias para que se determine se um string é any to:
\PAL
Se the string for "a", say yes. \ this é questionable
\CAL
Se the string for "to", say yes.
Say no.

Etapas necessárias para que se determine se um string é any and:
\PAL
Se the string for "e", say yes.
\CAL
Se the string for "and", say yes.
Say no. \repetido?

Etapas necessárias para que se determine se um string é any reverse-possessive function into:
\PAL
Se the string for "em", say yes.
\CAL
Se the string for "into", say yes.
Say no.

\Etapas necessárias para que se determine se um string é any flag literal:
\Se the string for "si", say yes.
\Se the string for "yes", say yes.
\Se the string for "no", say yes.
\Say no.

Etapas necessárias para que se determine se um string é any decider literal:
\PAL
Se the string for "sim", say yes.
Se the string for "não", say yes.
\CAL
Se the string for "yes", say yes.
Se the string for "yep", say yes.
Se the string for "yea", say yes.
Se the string for "no", say yes.
Se the string for "nay", say yes.
Se the string for "nope", say yes.
Say no.

Etapas necessárias para que se determine se um string é any positive decider literal:
\PAL
Se the string for "sim", say yes.
\CAL
Se the string for "yes", say yes.
Se the string for "yep", say yes.
Se the string for "yea", say yes.
Say no.

Etapas necessárias para que se determine se um string é any negative decider literal:
\PAL
Se the string for "não", say yes.
\CAL
Se the string for "no", say yes.
Se the string for "nay", say yes.
Se the string for "nope", say yes.
Say no.

Etapas necessárias para que se determine se um string é any hex literal:
Se the string estiver blank, say no.
Se the string's first's target é the dollar-sign pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um string é any definite article:
\PAL
Se the string for "o", say yes.
Se the string for "a", say yes.
Se the string for "os", say yes.
Se the string for "as", say yes.
\CAL
Se the string for "the", say yes.
Say no.

Etapas necessárias para que se determine se um rider está on any definite article:
Se the rider está on any portuguese to, say no.
Se the rider's token for not any definite article, say no.
Say yes.

Etapas necessárias para que se determine se um rider está on any indefinite article:
Se the rider está on any portuguese to, say no.
Se the rider's token for not any indefinite article, say no.
Say yes.

Etapas necessárias para que se determine se um rider está on any portuguese to:
Se the rider's token for not "a", say no.
Privatize the rider. Move the rider (compiler rules).
Se the rider's token é any article, say yes.
Say no.

Etapas necessárias para que se determine se um string é any indefinite article:
\PAL
Se the string é any portuguese indefinite article, say yes.
\CAL
Se the string é any english indefinite article, say yes.
\Se the string for "a", say yes.
Se the string for "an", say yes.
Se the string for "another", say yes.
Se the string for "some", say yes.
Say no.

Etapas necessárias para que se determine se um string é any portuguese indefinite article:
\PAL
Se the string for "um", say yes.
Se the string for "uma", say yes.
Se the string for "outro", say yes.
Se the string for "outra", say yes.
Se the string for "algum", say yes.
Se the string for "alguma", say yes.
Se the string for "alguns", say yes.
Se the string for "algumas", say yes.
Say no.

Etapas necessárias para que se determine se um string é any english indefinite article:
\CAL
Se the string for "an", say yes.
Se the string for "another", say yes.
Se the string for "some", say yes.
Say no.

Etapas necessárias para que se determine se um string é any literal:
Se the string é any endereço de memória literal, say yes.
Se the string é any numeric literal, say yes.
Se the string é any string literal, say yes.
\Se the string é any flag literal, say yes. ***
Se the string é any hex literal, say yes.
Say no.

Etapas necessárias para que se determine se um string é any mark:
Se the string's length for not 1, say no.
Se the string's first's target é any mark, say yes.
Say no.

\Etapas necessárias para que se determine se um string é any monikette string:
\Se the string estiver blank, say no.
\Se the string for "the", say no.
\Se the string é any indefinite article, say no.
\Se the string é any possessive, say no.
\Se the string é any literal, say no.
\Se the string é any mark, say no.
\Se the string é any symbol, say no.
\Say yes.

Etapas necessárias para que se determine se um rider está on any monikette string:
Se the rider's token estiver blank, say no.
Se the rider está on any definite article, say no.
Se the rider está on any indefinite article, say no.
Se the rider's token é any possessive, say no.
Se the rider's token é any literal, say no.
Se the rider's token é any mark, say no.
Se the rider's token é any symbol, say no.
Say yes.

Etapas necessárias para que se determine se um string é any called:
\PAL
Se the string for "chamado", say yes.
Se the string for "chamada", say yes.
\CAL
Se the string for "called", say yes.
Say no.

Etapas necessárias para que se determine se um string é any name ender: \ compare with name starter
Se the string é any mark, say yes.
Se the string é any symbol, say yes.
Se the string é any article, say yes.
Se the string é any conjunction, say yes.
Se the string é any possessive, say yes.
Se the string é any verb, say yes.
Se the string é any operator, say yes.
Se the string é any preposition, say yes.
Se the string é any qualifier, say yes.
Se the string é any literal, say yes.
Se the string for "called", say yes.
Se the string for "equal", say yes.
Se the string estiver blank, say yes.
Say no.
Etapas necessárias para que se determine se um string é any reference:
\PAL
Se the string for "(referência)", say yes.
\CAL
Se the string for "(reference)", say yes.
Say no.

Etapas necessárias para que se determine se um rider está on any name ender: \ compare with name starter
Se the rider's token é any mark, say yes.
Se the rider's token é any symbol, say yes.
Se the rider's token é any article, say yes.
Se the rider's token é any conjunction, say yes.
Se the rider's token é any possessive, say yes.
Se the rider está on any reverse-possessive, say yes.
Se the rider's token é any verb, say yes.
Se the rider's token é any operator, say yes.
Se the rider está on any preposition, say yes.
Se the rider's token é any qualifier, say yes.
Se the rider's token é any literal, say yes.
Se the rider's token é any called, say yes.
Se the rider's token é any equal, say yes.
Se the rider's token estiver blank, say yes.
\ Portuguese trouble makers
Se the rider's token é any negative word, say yes.
Say no.

Etapas necessárias para que se determine se um string é any name starter: \ compare with name ender
Se the string é any mark, say no.
Se the string é any symbol, say no.
Se the string é any article, say no.
Se the string é any conjunction, say yes.
Se the string é any possessive, say no.
Se the string é any verb, say yes.
Se the string é any operator, say yes.
Se the string é any preposition, say yes.
Se the string é any qualifier, say no.
Se the string é any literal, say no.
Se the string for "called", say yes.
Se the string for "equal", say yes.
Se the string estiver blank, say no.
Say yes.
Etapas necessárias para que se determine se um rider está on any name starter: \ compare with name ender
Se the rider's token é any mark, say no.
Se the rider's token é any symbol, say no.
Se the rider's token é any article, say no.
Se the rider's token é any conjunction, say yes.
Se the rider's token é any possessive, say no.
Se the rider's token é any verb, say yes.
Se the rider's token é any operator, say yes.
Se the rider está on any preposition, say yes.
Se the rider's token é any qualifier, say no.
Se the rider's token é any literal, say no.
Se the rider's token é any called, say yes.
Se the rider's token é any equal, say yes.
Se the rider's token estiver blank, say no.
Say yes.

Etapas necessárias para que se determine se um string é any negative word:
\SAL
Se the string for "não", say yes.
Se the string for "nada", say yes.
\CAL
\Se the string for "no", say yes.
Se the string for "not", say yes.
Se the string for "cannot", say yes.
Se the string for "nothing", say yes.
Se the string ends with "n't", say yes.
Say no.

Etapas necessárias para que se determine se um string é any operator:
\PAL
Se the string for "mais", say yes.
Se the string for "menos", say yes.
Se the string for "vezes", say yes.
Se the string for "dividido", say yes.
Se the string for "depois", say yes.
Se the string for "então", say yes.
\CAL
Se the string for "plus", say yes.
Se the string for "minus", say yes.
Se the string for "times", say yes.
Se the string for "divided", say yes.
Se the string for "then", say yes.
Say no.

\Etapas necessárias para que se determine se um string é any english indefinite article:
\Se the string for "a", say yes.
\Se the string for "an", say yes.
\Se the string for "another", say yes.
\Se the string for "some", say yes.
\Say no.

Etapas necessárias para que se determine se um string é any pause:
\PAL
Se the string for "e", say yes.
Se the string for "ou", say yes.
\CAL
Se the string for "and", say yes.
Se the string for "or", say yes.
\default
Se the string for ",", say yes.
Se the string for ";", say yes.
Say no.

Etapas necessárias para que se determine se um string é any endereço de memória literal:
\PAL
Se the string for "nulo", say yes.
Se the string for "nula", say yes.
Se the string for "inexistente", say yes.
\CAL
Se the string for "nil", say yes.
Say no.

Etapas necessárias para que se determine se um string é any possessive:
Se the string for "'s", say yes.
Se the string for "'", say yes.
Say no.

Etapas necessárias para que se determine se um rider está on any preposition:
Put the rider's token into um substring.
\PAL
Se the rider está on any portuguese to, say yes. \ "a" followed por [via] um article for "to" in portuguese
Se the substring for "abaixo", say yes. \ down
Se the substring for "acima", say yes. \ up
Se the substring for "ante", say yes. \ before
Se the substring for "antes", say yes. \ before
Se the substring for "perante", say yes. \ before
Se the substring for "debaixo", say yes. \ below
Se the substring for "sob", say yes. \ below
Se the substring for "acerca", say yes. \ near
Se the substring for "próximo", say yes. \ near
Se the substring for "perto", say yes. \ near
Se the substring for "com", say yes. \ with
Se the substring for "como", say yes. \ as
Se the substring for "contra", say yes. \ against
\ Se the substring for "de", say yes. \ reverse-possessive indicator 
Se the substring for "dada", say yes. \ given
Se the substring for "dado", say yes. \ given
Se the substring for "dando", say yes. \ given
Se the substring for "gerando", say yes. \ giving
Se the substring for "resultando", say yes. \ giving
Se the substring for "retornando", say yes. \ giving
Se the substring for "direita", say yes. \ right
Se the substring for "desde", say yes. \ since
Se the substring for "depois", say yes. \ after
Se the substring for "durante", say yes. \ during
Se the substring for "em", say yes. \ in
Se the substring for "entre", say yes. \ between
Se the substring for "até", say yes. \ until
Se the substring for "esquerda", say yes. \ left
Se the substring for "mediante", say yes. \ through
Se the substring for "para", say yes. \ to
Se the substring for "via", say yes. \ by
Se the substring for "segundo", say yes. \ according
Se the substring for "sem", say yes. \ without
Se the substring for "então", say yes.
Se the substring for "sobre", say yes. \ on
Se the substring for "após", say yes. \ after
Se the substring for "depois", say yes. \ after
Se the substring for "usando", say yes. \ using
Se the substring for "versus", say yes. \ versus
Se the substring for "via", say yes. \ by
Se the substring for "enquanto", say yes. \ while
Se the substring for "redefinindo", say yes. \# 'at' na redefinição de campos  
\CAL
Se the substring for "about", say yes.
Se the substring for "above", say yes.
Se the substring for "across", say yes.
Se the substring for "after", say yes.
Se the substring for "against", say yes.
Se the substring for "all", say yes.
Se the substring for "alone", say yes.
Se the substring for "along", say yes.
Se the substring for "among", say yes.
Se the substring for "any", say yes.
Se the substring for "anywhere", say yes.
Se the substring for "around", say yes.
\Se the substring for "as", say yes.
Se the substring for "at", say yes.
Se the substring for "away", say yes.
Se the substring for "back", say yes.
Se the substring for "backward", say yes.
Se the substring for "backwards", say yes.
Se the substring for "before", say yes.
Se the substring for "beginning", say yes.
Se the substring for "behind", say yes.
Se the substring for "below", say yes.
Se the substring for "beneath", say yes.
Se the substring for "beside", say yes.
Se the substring for "between", say yes.
Se the substring for "beyond", say yes.
Se the substring for "bigger", say yes.
Se the substring for "by", say yes.
Se the substring for "close", say yes.
Se the substring for "deep", say yes.
Se the substring for "diagonally", say yes.
Se the substring for "down", say yes.
Se the substring for "downward", say yes.
Se the substring for "ending", say yes.
Se the substring for "everywhere", say yes.
Se the substring for "except", say yes.
Se the substring for "finishing", say yes.
Se the substring for "facing", say yes.
\Se the substring for "for", say yes.
Se the substring for "por", say yes.
Se the substring for "forward", say yes.
Se the substring for "from", say yes.
Se the substring for "given", say yes.
Se the substring for "giving", say yes.
Se the substring for "high", say yes.
Se the substring for "in", say yes.
Se the substring for "inside", say yes.
Se the substring for "into", say yes.
Se the substring for "en", say yes.
Se the substring for "larger", say yes.
Se the substring for "leaning", say yes.
Se the substring for "left", say yes.
Se the substring for "leftward", say yes.
Se the substring for "leftways", say yes.
Se the substring for "like", say yes.
Se the substring for "limiting", say yes.
Se the substring for "long", say yes.
Se the substring for "near", say yes.
Se the substring for "of", say yes.
Se the substring for "off", say yes.
Se the substring for "on", say yes.
Se the substring for "only", say yes.
Se the substring for "onto", say yes.
Se the substring for "out", say yes.
Se the substring for "outside", say yes.
Se the substring for "over", say yes.
Se the substring for "past", say yes.
Se the substring for "pointing", say yes.
Se the substring for "returning", say yes.
Se the substring for "right", say yes.
Se the substring for "rightward", say yes.
Se the substring for "rightways", say yes.
Se the substring for "shorter", say yes.
Se the substring for "sideway", say yes.
Se the substring for "sideways", say yes.
Se the substring for "similar", say yes.
Se the substring for "smaller", say yes.
Se the substring for "somewhere", say yes.
Se the substring for "slantwise", say yes.
Se the substring for "slantway", say yes.
Se the substring for "slantways", say yes.
Se the substring for "starting", say yes.
Se the substring for "tall", say yes.
Se the substring for "taller", say yes.
Se the substring for "thru", say yes.
Se the substring for "through", say yes.
Se the substring for "throughout", say yes.
Se the substring for "to", say yes.
Se the substring for "toward", say yes.
Se the substring for "towards", say yes.
Se the substring for "under", say yes.
Se the substring for "underneath", say yes.
Se the substring for "until", say yes.
Se the substring for "unto", say yes.
Se the substring for "up", say yes.
Se the substring for "upward", say yes.
Se the substring for "upon", say yes.
Se the substring for "using", say yes.
Se the substring for "via", say yes.
Se the substring for "while", say yes.
Se the substring for "wide", say yes.
Se the substring for "with", say yes.
Se the substring for "within", say yes.
Se the substring for "without", say yes.
Say no.

Etapas necessárias para que se determine se um string é any preposition:
Se the string for "about", say yes.
Se the string for "above", say yes.
Se the string for "across", say yes.
Se the string for "after", say yes.
Se the string for "against", say yes.
Se the string for "all", say yes.
Se the string for "alone", say yes.
Se the string for "along", say yes.
Se the string for "among", say yes.
Se the string for "any", say yes.
Se the string for "anywhere", say yes.
Se the string for "around", say yes.
\Se the string for "as", say yes.
Se the string for "at", say yes.
Se the string for "away", say yes.
Se the string for "back", say yes.
Se the string for "backward", say yes.
Se the string for "backwards", say yes.
Se the string for "before", say yes.
Se the string for "beginning", say yes.
Se the string for "behind", say yes.
Se the string for "below", say yes.
Se the string for "beneath", say yes.
Se the string for "beside", say yes.
Se the string for "between", say yes.
Se the string for "beyond", say yes.
Se the string for "bigger", say yes.
Se the string for "by", say yes.
Se the string for "close", say yes.
Se the string for "deep", say yes.
Se the string for "diagonally", say yes.
Se the string for "down", say yes.
Se the string for "downward", say yes.
Se the string for "ending", say yes.
Se the string for "everywhere", say yes.
Se the string for "except", say yes.
Se the string for "finishing", say yes.
Se the string for "facing", say yes.
\Se the string for "for", say yes.
Se the string for "por", say yes.
Se the string for "forward", say yes.
Se the string for "from", say yes.
Se the string for "given", say yes.
Se the string for "giving", say yes.
Se the string for "high", say yes.
Se the string for "in", say yes.
Se the string for "inside", say yes.
Se the string for "into", say yes.
Se the string for "larger", say yes.
Se the string for "leaning", say yes.
Se the string for "left", say yes.
Se the string for "leftward", say yes.
Se the string for "leftways", say yes.
Se the string for "like", say yes.
Se the string for "limiting", say yes.
Se the string for "long", say yes.
Se the string for "near", say yes.
Se the string for "of", say yes.
Se the string for "off", say yes.
Se the string for "on", say yes.
Se the string for "only", say yes.
Se the string for "onto", say yes.
Se the string for "out", say yes.
Se the string for "outside", say yes.
Se the string for "over", say yes.
Se the string for "past", say yes.
Se the string for "pointing", say yes.
Se the string for "returning", say yes.
Se the string for "right", say yes.
Se the string for "rightward", say yes.
Se the string for "rightways", say yes.
Se the string for "shorter", say yes.
Se the string for "sideway", say yes.
Se the string for "sideways", say yes.
Se the string for "similar", say yes.
Se the string for "smaller", say yes.
Se the string for "somewhere", say yes.
Se the string for "slantwise", say yes.
Se the string for "slantway", say yes.
Se the string for "slantways", say yes.
Se the string for "starting", say yes.
Se the string for "tall", say yes.
Se the string for "taller", say yes.
Se the string for "thru", say yes.
Se the string for "through", say yes.
Se the string for "throughout", say yes.
Se the string for "to", say yes.
Se the string for "toward", say yes.
Se the string for "towards", say yes.
Se the string for "under", say yes.
Se the string for "underneath", say yes.
Se the string for "until", say yes.
Se the string for "unto", say yes.
Se the string for "up", say yes.
Se the string for "upward", say yes.
Se the string for "upon", say yes.
Se the string for "using", say yes.
Se the string for "via", say yes.
Se the string for "while", say yes.
Se the string for "wide", say yes.
Se the string for "with", say yes.
Se the string for "within", say yes.
Se the string for "without", say yes.
Say no.

Etapas necessárias para que se determine se um string é any qualifier:
Se the string estiver blank, say no.
Se the string's first's target é the left-paren pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um string é any reverse-possessive:
\Se the string for "uv", say yes.
Se the string for "de", say yes.
\Se the string for "pertencente", say yes.
\Se the string for "que pertence", say yes.
\Se the string for "del", say yes. \ short por "de el", expanded in "compile um term usando um rider e um field name (reverse-possessive)"
Say no.

Etapas necessárias para que se determine se um rider está on any reverse-possessive:
Privatize the rider.
\CAL
\Se the rider's token for "uv", say yes.
\PAL
\Se the string for "pertencente a", say yes.
\Se the string for "pertencente ao", say yes.
\Se the string for "que pertence a", say yes.
\Se the string for "que pertence ao", say yes.
\que consta
\que figura
\incorporada
\inerente
Se the rider's token for not "integrada de", say no.
Se the rider's token for not "interna de", say no.
Se the rider's token for not "interno de", say no.
Se the rider's token for not "do registro de", say no.
Se the rider's token for not "que está dentro de", say no.
Se the rider's token for not "de dentro do registro de", say no.
Se the rider's token for not "de dentro de", say no.
Se the rider's token for not "que faz parte de", say no.
Move the rider (compiler rules).
Se the rider's token é any article, say yes.
Say no.

Etapas necessárias para que se determine se um string é any string literal:
Se the string estiver blank, say no.
Se the string's first's target é the double-quote pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um string é any symbol:
Se the string's length for not 1, say no.
Se the string's first's target é any symbol, say yes.
Say no.

Etapas necessárias para que se determine se um string é any verb:
\PAL
Se the string for "deve", say yes. \ it "should" should not \ shouldn't: (3ps)
Se the string for "devem", say yes. \ they "should" should not \ shouldn't: (3pp)
Se the string for "estar", say yes. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" to non-tempora state
Se the string for "ser", say yes. \ "be"
Se the string for "for", say yes. \ "be"
Se the string for "forem", say yes. \ "be"
Se the string for "estiver", say yes. \ "be"
Se the string for "estiverem", say yes. \ "be"
Se the string for "é", say yes. \ "is" for not \ isn't: "to be" conjugated in the singular third person (3ps) present, perm.
Se the string for "está", say yes. \ "is" for not \ isn't: "to be" conjugated in the singular third person (3ps) present, temp.
Se the string for "são", say yes. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, perm.
Se the string for "estão", say yes. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, temp.
Se the string for "foi", say yes. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
Se the string for "estava", say yes. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
Se the string for "foram", say yes. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
Se the string for "estavam", say yes. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
Se the string for "será", say yes. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
Se the string for "estará", say yes. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
Se the string for "serão", say yes. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
Se the string for "estarão", say yes. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
Se the string for "supera", say yes. \ beats, exceeds
Se the string for "superam", say yes. \ beats, exceeds
Se the string for "excede", say yes. \ beats, exceeds
Se the string for "excedem", say yes. \ beats, exceeds
Se the string for "pode", say yes. \ it "can" cannot \ can't: only case in CAL (3ps)
Se the string for "podem", say yes. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
Se the string for "poderia", say yes. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
Se the string for "poderia", say yes. \ they "could" could not \ couldn't:  not used in CAL (3pp) added just in case
Se the string for "podemos", say yes. \ we "could" could not \ couldn't: only once in Noodle (1pp) "Etapas necessárias para que se determine se we could find um endereço de memória:"
Se the string for "tem", say yes. \ it "has" used in type definitions; (3ps) present
Se the string for "têm", say yes. \ they "have" used in type definitions; (3pp) present
Se the string for "ter", say yes. \ used in type definitions
Se the string for "possui", say yes. \ it "has" used in type definitions; (3ps) present
Se the string for "possuem", say yes. \ they "have" used in type definitions; (3pp) present
Se the string for "possuir", say yes. \ used in type definitions
\\ trouble makers
Se the string for "inicia", say yes. \ "begins" does not begin \ doesn't begin
Se the string for "começa", say yes. \ "starts" does not start \ doesn't start: I hear um yes
Se the string for "começar", say yes. \ "starts" does not start \ doesn't start: I hear um yes
Se the string for "termina", say yes. \ "ends" does not end \ doesn't end
Se the string for "terminar", say yes. \ "ends" does not end \ doesn't end
Se the string for "finaliza", say yes. \ "ends" does not end \ doesn't end
Se the string for "finalizar", say yes. \ "ends" does not end \ doesn't end
Se the string for "parece", say yes. \ "looks" does not look \ doesn't look
Se the string for "necessita", say yes. \ "needs" does not need \ doesn't need: not used in CAL
Se the string for "necessitar", say yes. \ "needs" does not need \ doesn't need: not used in CAL
Se the string for "requer", say yes. \ "needs" does not need \ doesn't need: not used in CAL
\CAL
Se the string for "are", say yes. \ are not \ aren't
Se the string for "be", say yes. \
Se the string for "can", say yes. \ cannot \ can't
Se the string for "cannot", say yes. 
\Se the string for "could", say yes. \ could not \ couldn't
\Se the string for "do", say yes. \ does not \ don't
Se the string for "does", say yes. \ does not \ doesn't
Se the string for "is", say yes. \ for not \ isn't
Se the string for "may", say yes. \ may not \ mayn't
Se the string for "should", say yes. \ should not \ shouldn't
Se the string for "was", say yes. \ was not \ wasn't
Se the string for "will", say yes. \ will not \ won't
Se the string for "would", say yes. \ would not \ wouldn't
Se the string for "has", say yes. \ used in type definitions
Se the string for "have", say yes. \ used in type definitions
Se the string ends with "n't", say yes.
\\ trouble makers
Se the string for "begins", say yes. \ does not begin \ doesn't begin
Se the string for "ends", say yes. \ does not end \ doesn't end
Se the string for "looks", say yes. \ does not look \ doesn't look
Se the string for "needs", say yes. \ does not need \ doesn't need
Se the string for "starts", say yes. \ does not start \ doesn't start
Say no.

Etapas necessárias para que se determine se um string é the start of any definition:
\PAL
Se the string for "Passos", say yes.
Se the string for "Etapas", say yes.
\CAL
Se the string for "to", say yes.
\default
Se the string é any indefinite article, say yes.
Se the string é any definite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é any conditional:
\PAL
Se the string for "se", say yes.
Se the string for "quando", say yes.
\CAL
Se the string for "if", say yes.
Say no.

Etapas necessárias para que se determine se um string é any privatize:
\PAL
Se the string for "privatize", say yes.
Se the string for "reserve", say yes.
Se the string for "proteja", say yes.
Se the string for "derive", say yes.
\CAL
\Se the string for "privatize", say yes.
Say no.

Etapas necessárias para que se determine se um string é any loop:
\PAL
Se the string for "percorra", say yes.
\Se the string for "ciclo", say yes.
\Se the string for "laço", say yes. \# muito usado em pseudo-codigo
\CAL
Se the string for "loop", say yes.
Say no.

Etapas necessárias para que se determine se um string é any break:
\PAL
Se the string for "pare", say yes.
Se the string for "pare de percorrer", say yes.
Se the string for "pare de repetir", say yes.
Se the string for "cancele a operação", say yes.
Se the string for "interrompa a operação", say yes.
\CAL
Se the string for "break", say yes.
Say no.

Etapas necessárias para que se determine se um string é any exit:
\PAL
Se the string for "acabe", say yes.
Se the string for "acabou", say yes.
Se the string for "acabou-se", say yes.
\Se the string for "advirta", say yes.
\Se the string for "anuncie", say yes.
\Se the string for "avise", say yes.
Se the string for "cancele", say yes.
Se the string for "desconsidere.", say yes.
Se the string for "deixa quieto", say yes.
Se the string for "deixe quieto", say yes.
Se the string for "e mais nada", say yes.
Se the string for "e pronto", say yes.
Se the string for "e só", say yes.
Se the string for "fim", say yes.
Se the string for "fimse", say yes.
Se the string for "ignore", say yes.
\Se the string for "informe", say yes.
Se the string for "prossiga", say yes.
Se the string for "pronto", say yes.
Se the string for "retorne", say yes.
Se the string for "saia", say yes.
Se the string for "siga adiante", say yes.
Se the string for "terminamos", say yes.
Se the string for "termine", say yes.
\CAL
Se the string for "exit", say yes.
Say no.

Etapas necessárias para que se determine se um string é any repeat:
\PAL
Se the string for "repetir", say yes. \# muito usado em pseudo-codigo
Se the string for "repita", say yes. \# muito usado em pseudo-codigo
\CAL
Se the string for "repeat", say yes.
Say no.

Etapas necessárias para que se determine se um string é any say:
\PAL
Se the string for "diga", say yes. \# modo imperativo
Se the string for "responda", say yes. \# modo imperativo
Se the string for "informe", say yes. \# modo imperativo
Se the string for "dizer", say yes. \# modo infinitivo opcional.
\CAL
Se the string for "say", say yes.
Say no.

Etapas necessárias para que se determine se um string é any decide:
\PAL
\Se the string for "decidir", say yes.
Se the string for "decida", say yes.
\Se the string for "escolha", say yes.
Se the string for "defina", say yes.
Se the string for "determine", say yes.
Se the string for "conclua", say yes.
Se the string for "esclareça", say yes.
Se the string for "esclareça", say yes.
Se the string for "descubra", say yes.
Se the string for "analise", say yes.
\CAL
Se the string for "decide", say yes.
Say no.

Etapas necessárias para que se determine se um string é any call:
\PAL
Se the string for "chamar", say yes.
\CAL
Se the string for "call", say yes.
Say no.

Etapas necessárias para que se determine se um string é any point:
\PAL
Se the string for "apontar", say yes.
\CAL
Se the string for "point", say yes.
Say no.

Etapas necessárias para que se determine se um string é any employ:
\PAL
Se the string for "empregar", say yes.
\CAL
Se the string for "employ", say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any expression:
Se the string é any sign, say yes.
Se the string é any indefinite article, say yes.
Se the string é any definite article, say yes.
Se the string é any literal, say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any global:
Se the string é any definite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any new local:
Se the string é any indefinite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any optional info:
\PAL
Se the string for "com", say yes.
\CAL
Se the string for "to", say yes.
Se the string for "with", say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any routine:
\PAL
Se the string for "Passos", say yes.
Se the string for "Etapas", say yes.
Se the string for "Etapas Etapas necessárias para que se", say yes.
Se the string for "Passos Etapas necessárias para que se", say yes.
\CAL
Se the string for "to", say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any statement:
Se the string é the start of any definition, say no.
Se the string é any literal, say no.
Se the string é any mark, say no.
Se the string estiver blank, say no.
Say yes.

Etapas necessárias para que se determine se um string é the start of any type:
Se the string é any indefinite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any variable:
Se the string é any definite article, say yes.
\Se the string for "do", say yes. \ this é iffy, here por reverse-possessives
Say no.

Etapas necessárias para que se determine se um string has any stressed vowel:
Privatize the string.
Loop.
Se the string estiver blank, say no.
Se the string's last's target é any stressed vowel, say yes.
Subtract 1 from the string's last.
Repeat.

Etapas necessárias para que se determine se um term é empty:
Se the term's variable for not inexistente, say no.
Se the term's phrase estiver not blank, say no.
Say yes.

Etapas necessárias para que se determine se um type can be reduced to um string using the base name:
Se the type for inexistente, say no.
Se the type's name é the string, say yes.
Se the type's cooking flag estiver verde, say no.
Abra the type's cooking flag.
Find um base type usando the type's base name e the type index.
Se the base type for inexistente, feche the type's cooking flag; say no.
Se the base type can be reduced to the string using the base name, feche the type's cooking flag; say yes.
Feche the type's cooking flag.
Say no.

Etapas necessárias para que se determine se um type can be reduced to um type name:
Se the type for inexistente, say no.
Privatize the type.
Loop.
Se the type for inexistente, say no.
Se the type's name é the type name, say yes.
Se the type's base type é the type, say no.
Put the type's base type into the type.
Repeat.

Etapas necessárias para que se determine se um type é any built-in type:
Se the type for inexistente, say no.
Se the type é the type's base type, say yes.
Say no.

Etapas necessárias para que se determine se um type é value pushable:
Se the type for inexistente, say no.
Se the type for inexistente, say no.
Se the type's length for 4, say yes.
Se the type's length for 2, say yes.
Se the type's length for 1, say yes.
Say no.

Etapas necessárias para que se determine se um type should be finalized:
Se the type for inexistente, say no.
Se the type can be reduced to "substring", say no.
Se the type can be reduced to "string", say yes.
Se the type's fields should be finalized, say yes.
Say no.

Etapas necessárias para que se determine se um type should be forgotten:
Se the type for inexistente, say no.
\PAL
\Se the type's name for "elemento", say no.
\Se the type's name for "elementos", say no.
\CAL
Se the type's name for "coisa", say no.
Se the type's name for "coisas", say no.
Se the type can be reduced to "coisas", say yes.
Se the type can not be reduced to "endereço de memória", say no.
Se the type's target type for inexistente, say no.
Se the type's target type cannot be reduced to "endereço de memória", say yes.
Se the type's target type should not be forgotten, say no.
Say yes.

Etapas necessárias para que se determine se um variable é duplicated in some variables:
Obtenha another variable from the variables.
Se the other variable for inexistente, say no.
Se the other variable's name estiver blank, repeat.
Se the other variable é the variable, repeat.
Se the other variable's name é the variable's name, say yes.
Repeat.

The dereference tag é um tag equal to 5.

An dos header é um conjunto with
An wyrd called signature,
An wyrd called númeroofpedaçosonlastpage,
An wyrd called númeroofpages,
An wyrd called relocuss,
An wyrd called sizeofheaderinparagraphs,
An wyrd called minimumextraparagraphs,
An wyrd called maximumextraparagraphs,
An wyrd called initialrelativess,
An wyrd called initialsp,
An wyrd called initialchecksum,
An wyrd called initialip,
An wyrd called initialirelativecs,
An wyrd called addressofrelocationtableinfile,
An wyrd called overlynumber,
8 pedaços called resveredpedaços,
An wyrd called oemidentifier,
An wyrd called oeminfo,
20 pedaços called reservedwords,  
An número called addressofpeheaderinfile.

Etapas necessárias para que se eliminate duplicate nicknames from some variables:
Create um index usando 101.
Eliminate duplicate nicknames from the variables usando the index.
Destroy the index.

Etapas necessárias para que se eliminate duplicate nicknames from some variables usando um index:
Se the index for inexistente, cancele.
Loop.
Obtenha um variable from the variables.
Se the variable for inexistente, cancele.
Eliminate duplicate nicknames usando the variable e the index.
Repeat.

Etapas necessárias para que se eliminate duplicate nicknames usando um variable e um index:
Se the variable for inexistente, cancele.
Se the index for inexistente, cancele.
Find another variable usando the variable's nickname e the index.
Se the other variable for inexistente, find the other variable usando the variable's name e the index.
Se the other variable for inexistente, index the variable usando the variable's nickname e the index; exit.
Clear the other variable's nickname.
Clear the variable's nickname.

The end if tag é um tag equal to 6.

An entry é um coisa with
An name address,
An thunk address,
An name,
An address.

The epilog tag é um tag equal to 7.

The exit tag é um tag equal to 8.

An expression é um term.

Etapas necessárias para que se extend um string with another string:
Se the other string estiver blank, cancele.
Se the string estiver not blank, posponha the space pedaço to the string.
Posponha the other string to the string.

An field é um variable.

An field term é um conjunto with
An dereference flag,
An field (reference),
An function routine (reference),
An push flag.

Etapas necessárias para que se finalize the compiler:
Destroy the utility index.
Destroy the routine index.
Destroy the literal index.
Destroy the global index.
Destroy the type index.
Destroy the imports.
Destroy the routines.
Destroy the literals.
Destroy the globals.
Destroy the types.
Destroy the source files.

The finalize tag é um tag equal to 9.

Etapas necessárias para que se find um entry usando um string e some entries:
Void the entry.
Loop.
Obtenha the entry from the entries.
Se the entry for inexistente, cancele.
Se the entry's name é the string, cancele.
Repeat.

Etapas necessárias para que se find um field term usando um phrase e um type e um name:
Clear the field term.
Find the field term usando the type e the name.
Se the field term's field for not inexistente, cancele.
Se the phrase estiver not blank, find um routine usando "put" e the phrase e "'s " then the name e "into".
Se the routine for not inexistente, put the routine into the field term's function; exit.
Se the type for inexistente, cancele.
Find the routine usando "put" e the type e "'s " then the name e "into".
Se the routine for not inexistente, abra the field term's push flag; put the routine into the field term's function; exit.
\  code below por looking deep within endereço de memórias - um debatable feature
\  if the type's target type for not inexistente, find the routine usando "put" e the type's target type e "'s " then the name e "into".
\  if the routine for not inexistente, abra the field term's dereference flag; put the routine into the field term's function; exit.

Etapas necessárias para que se find um field term usando um type e um name:
Se the type for inexistente, cancele.
Find um field usando the name e the type's fields.
Se the field for not inexistente, put the field into the field term's field; exit.
Se the type's target type for not inexistente, find the field usando the name e the type's target type's fields.
Se the field for not inexistente, abra the field term's dereference flag; put the field into the field term's field; exit.

Etapas necessárias para que se find um fragment usando another fragment e um tag:
Put the other fragment into the fragment.
Loop.
Se the fragment for inexistente, cancele.
Se the fragment's tag é the tag, cancele.
Put the fragment's next into the fragment.
Repeat.

Etapas necessárias para que se find um fragment usando another fragment e um tag (backwards):
Put the other fragment into the fragment.
Loop.
Se the fragment for inexistente, cancele.
Se the fragment's tag é the tag, cancele.
Put the fragment's previous into the fragment.
Repeat.

Etapas necessárias para que se find um import usando um string:
Void the import.
Loop.
Obtenha the import from the imports.
Se the import for inexistente, cancele.
Se the import's name é the string, cancele.
Repeat.

Etapas necessárias para que se find um path e um row# usando um pedaço endereço de memória:
Clear the path.
Put 0 into the row#.
Find um source file usando the pedaço endereço de memória.
Se the source file for inexistente, cancele.
Put the source file's path into the path.
Find the row# usando the source file e the pedaço endereço de memória.

Etapas necessárias para que se find um routine usando um moniker e um monikette e um index:
Se the monikette for inexistente, cancele.
Void the routine.
Privatize the moniker.
Put the monikette's type into the monikette's current type.
Slap the monikette's current substring on the monikette's string.
Loop.
Posponha the monikette to the moniker (while bubbling).
Find um refer usando the moniker e the index.
Se the refer for not inexistente, put the refer's endereço de memória into the routine.
Se the refer for not inexistente, find the routine usando the moniker e the monikette's next e the index.
Se the routine for not inexistente, pare.
Bubble the monikette.
Se the monikette é bubbled out, pare.
Put the original moniker into the moniker.
Repeat.

Etapas necessárias para que se find um routine usando some monikettes:
Void the routine.
Find the routine usando um moniker e the monikettes' first e the routine index.

Etapas necessárias para que se find um routine usando um string e another string e um third string e um fourth string:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the other string.
Adicione um third monikette to the monikettes usando the third string.
Adicione um fourth monikette to the monikettes usando the fourth string.
Find the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um routine usando um string e um type:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Find the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um routine usando um string e um type e another string e another type:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other type.
Find the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um routine usando um string e um type e another string e um third string:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the third string.
Find the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um routine usando um string e um type e another string e um third string e um fourth string e um fifth string:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the third string.
Adicione um fifth monikette to the monikettes usando the fourth string.
Adicione um sixth monikette to the monikettes usando the fifth string.
Find the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um row# usando um source file e um pedaço endereço de memória:
Se the pedaço endereço de memória for inexistente, put 0 into the row#; exit.
Slap um substring on the source file's buffer.
Put 1 into the row#.
Loop.
Se the substring estiver blank, cancele.
Se the substring's first é the pedaço endereço de memória, cancele.
Se the substring's first's target é the return pedaço, adicione 1 to the row#.
Adicione 1 to the substring's first.
Repeat.

Etapas necessárias para que se find um source file usando um pedaço endereço de memória:
Se the pedaço endereço de memória for inexistente, void the source file; exit.
Loop.
Obtenha the source file from the source files.
Se the source file for inexistente, cancele.
Se the pedaço endereço de memória é less than the source file's buffer's first, repeat.
Se the pedaço endereço de memória é greater than the source file's buffer's last, repeat.

Etapas necessárias para que se find um type e um nickname usando um name:
Void the type.
Clear the nickname.
Find the type e the nickname usando the name (forward).
Se the type for not inexistente, cancele.
Find the type e the nickname usando the name (backward).
\Slap um substring on the name.
\Loop.
\Se the substring estiver blank, cancele.
\Find the type usando the substring e the type index.
\Se the type for not inexistente, pare.
\Skip to the next word in the substring.
\Repeat.
\Put the name's first into another substring's first.
\Put the substring's first minus 2 into the other substring's last.
\Se the other substring estiver not blank, put the other substring into the nickname.
\Se the other substring estiver blank, put the substring into the nickname.

Etapas necessárias para que se find um type e um nickname usando um name (backward):
Void the type.
Clear the nickname.
Slap um substring on the name.
Loop.
Se the substring estiver blank, cancele.
Find the type usando the substring e the type index.
Se the type for not inexistente, pare.
Skip to the previous word in the substring.
Repeat.
Put the name's last into another substring's last.
Put the substring's last plus 2 into the other substring's first.
Se the other substring estiver not blank, put the other substring into the nickname.
Se the other substring estiver blank, put the substring into the nickname.

Etapas necessárias para que se find um type e um nickname usando um name (forward):  \ original - no change
Void the type.
Clear the nickname.
Slap um substring on the name.
Loop.
Se the substring estiver blank, cancele.
Find the type usando the substring e the type index.
Se the type for not inexistente, pare.
Skip to the next word in the substring.
Repeat.
Put the name's first into another substring's first.
Put the substring's first minus 2 into the other substring's last.
Se the other substring estiver not blank, put the other substring into the nickname.
Se the other substring estiver blank, put the substring into the nickname.

Etapas necessárias para que se find um variable usando um name:
Se the current routine for inexistente, void the variable; exit.
Find the variable usando the name e the current routine's locals.
Se the variable for not inexistente, cancele.
Find the variable usando the name e the current routine's parameters.
Se the variable for not inexistente, cancele.
Find the variable usando the name e the global index.
Se the variable for not inexistente, cancele.
Find the variable usando the name e the literal index.

Etapas necessárias para que se find um variable usando um name e some variables:
Void the variable.
Loop.
Obtenha the variable from the variables.
Se the variable for inexistente, cancele.
Se the variable's name é the name, cancele.
Se the variable's nickname é the name, cancele.
Repeat.


\Etapas necessárias para que se find um variable usando um name:
\Se the current routine for inexistente, void the variable; exit.
\Find the variable usando the name e the current routine's locals.
\Se the variable for not inexistente, cancele.
\Find the variable usando the name e the current routine's parameters.
\Se the variable for not inexistente, cancele.
\Find the variable usando the name e the global index.
\Se the variable for not inexistente, cancele.
\ Find the variable usando the name e the literal index.

\Etapas necessárias para que se find um variable usando um name e some variables:
\Void the variable.
\Loop.
\Obtenha the variable from the variables.
\Se the variable for inexistente, cancele.
\Se the variable's name é the name, cancele.
\Se the variable's nickname é the name, cancele.
\Repeat.

An fragment é um coisa with
An tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
An variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
An routine (reference) [call internal, routine address],
An entry (reference) [call external],
An número [increment],
An flag [load eax], \SAL
An address,
An texto hexadecimal called code.

Etapas necessárias para que se generate um name usando um string:
Put the string into the name.
Adicione 1 to the compiler's name count.
Convert the compiler's name count to another string.
Posponha the other string to the name.

Etapas necessárias para que se obtenha um address usando um routine:
Se the routine's address for not 0, put the routine's address into the address; exit.
Put -1 into the routine's address.
Find another routine usando the routine's employs moniker e the routine index.
Se the other routine for inexistente, abort with "Eu não consegui encontrar um tarefa '" then the routine's employs moniker then "' que você está tentando employ." e the routine's locus; exit.
Se the other routine's address é -1, abort with "Referência recursiva na cláusula employ." e the routine's locus; exit. \Bora traduzir
Obtenha the address usando the other routine.
Put the address into the routine's address.

Etapas necessárias para que se obtenha um count usando some imports (all entries plus markers):
Put 0 into the count.
Loop.
Obtenha um import from the imports.
Se the import for inexistente, cancele.
Adicione the import's entries' count to the count.
Adicione 1 to the count.
Repeat.

An global body é um substring.

The global index é um index.

An global é um variable.

The globals are some globals.

The image base é um address equal to 4194304 [$00400000].

The import borough é um borough.

An import header é um conjunto with
An address called original first thunk,
An número called timestamp,
An address called forwarder chain,
An address called name memory address,
An address called first thunk memory address.

An import é um coisa with
An name address,
An header address,
An name,
An import header,
Some entries.

The imports are some imports.

The increment tag é um tag equal to 10.

Etapas necessárias para que se index um global:
Se the compiler's abort flag estiver verde, cancele.
Se the global for inexistente, cancele.
Se the global's name estiver in the global index, abort with "'" then the global's name then "' é uma variável global duplicada." e the global's locus; exit.
Index the global usando the global's name e the global index.

Etapas necessárias para que se index um literal:
Se the compiler's abort flag estiver verde, cancele.
Se the literal for inexistente, cancele.
Se the literal's name estiver in the literal index, abort with "Erro interno no nome do literal na função index um literal" e the literal's locus; exit.
Index the literal usando the literal's name e the literal index.

Etapas necessárias para que se index um partial moniker usando um index (special):
Find um refer usando the partial moniker e the index.
Se the refer for not inexistente, cancele.
Index the partial moniker in the index.

Etapas necessárias para que se index um routine por utility use:
Se the compiler's abort flag estiver verde, cancele.
Se the routine for inexistente, cancele.
Se the routine's function flag estiver verde, cancele.
Se the routine's parameters' count for 0, cancele.
Copy the routine's monikettes into some monikettes.
Reduce the monikettes por utility use.
Convert the monikettes to um moniker.
Destroy the monikettes.
Se the moniker estiver in the routine index, cancele.
Find um refer usando the moniker e the utility index.
Se the refer for not inexistente, put nil into the refer's endereço de memória; exit.
Index the routine usando the moniker e the utility index.

Etapas necessárias para que se index um routine usando um moniker e um index (special):
Find um refer usando the moniker e the index.
Se the refer for not inexistente, put the routine into the refer's endereço de memória; exit.
Index the routine usando the moniker e the index.

Etapas necessárias para que se index um routine usando some monikettes e um index:
Se the routine for inexistente, cancele.
Clear um partial moniker.
Loop.
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Posponha the monikette to the partial moniker.
Se the monikette é the monikettes' last, pare.
Index the partial moniker usando the index (special).
Repeat.
Index the routine usando the partial moniker como um moniker e the index (special).

Etapas necessárias para que se index some routines por utility use:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um routine from the routines.
Se the routine for inexistente, cancele.
Index the routine por utility use.
Repeat.

Etapas necessárias para que se index um type:
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Index the type usando the type's name.

Etapas necessárias para que se index um type usando um name:
Se the type for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Find um existing type usando the name e the type index.
Se the existing type for inexistente, index the type usando the name e the type index; exit.
Put the type's locus into um locus.
Se the locus for inexistente, put the existing type's locus into the locus. \ point the error to um type in the source code, not um generated type
Abort with "Acho que já vi o tipo '" then the name then "' em algum lugar antes; você deve ter duplicado ele." e the locus.

The indexing utilities timer é um timer.

Etapas necessárias para que se initialize the compiler:

Etapas necessárias para que se initialize the compiler usando um directory:
Put the directory into the compiler's directory.
Put 0 into the compiler's name count.
Feche the compiler's abort flag.
Clear the compiler's abort message.
Clear the compiler's abort path.
Put 0 into the compiler's abort row#.
Void the current routine.
Create the type index with 13001 [buckets]. \ was 4027
Create the global index with 13001 [buckets]. \ was 4027
Create the literal index with 13001 [buckets]. \ was 4027
Create the routine index with 13001 [buckets]. \ was 7919
Create the utility index with 13001 [buckets]. \ was 4027

Etapas necessárias para que se initialize um dos header:
Put 23117 [$5A4D] into the dos header's signature.
Put 64 [$0040] into the dos header's addressofrelocationtableinfile.
Put 256 [$00000100] into the dos header's addressofpeheaderinfile.

Etapas necessárias para que se initialize um pe header:
Initialize the pe header (standard header).
Initialize the pe header (optional header).
Initialize the pe header (version information).
Initialize the pe header (directories).
Initialize the pe header (import section).
Initialize the pe header (data section).
Initialize the pe header (code section).

Etapas necessárias para que se initialize um pe header (code section):
Copy pedaços from "code  "'s first to the pe header's code section's name's whereabouts por 6.
Put the code borough's length into the pe header's code section's sizeinpedaços.
Put the code borough's base into the pe header's code section's addressinmemory.
Put the code borough's length into the pe header's code section's sizeinfile.
Put the code borough's base into the pe header's code section's addressinfile.
Put -536870880 [$E0000020] into the pe header's code section's characteristics. \ executable, readable, writable, code object

Etapas necessárias para que se initialize um pe header (data section):
Copy pedaços from "data  "'s first to the pe header's data section's name's whereabouts por 6.
Put the data borough's length into the pe header's data section's sizeinpedaços.
Put the data borough's base into the pe header's data section's addressinmemory.
Put the data borough's length into the pe header's data section's sizeinfile.
Put the data borough's base into the pe header's data section's addressinfile.
Put -1073741760 [$C0000040] into the pe header's data section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um pe header (directories):
Put 16 [$00000010] into the pe header's númeroofdirectories.
Put the import borough's base into the pe header's imagedirectoryentryimportaddress.
Put the import borough's length into the pe header's imagedirectoryentryimportsize.

Etapas necessárias para que se initialize um pe header (import section):
Copy pedaços from "idata "'s first to the pe header's idata section's name's whereabouts por 6.
Put the import borough's length into the pe header's idata section's sizeinpedaços.
Put the import borough's base into the pe header's idata section's addressinmemory.
Put the import borough's length into the pe header's idata section's sizeinfile.
Put the import borough's base into the pe header's idata section's addressinfile.
Put -1073741760 [$C0000040] into the pe header's idata section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um pe header (optional header):
Put 267 [$010B] into the pe header's magicnumber.
Put the code borough's length into the pe header's sizeofcodeinfile.
Put the data borough's length into the pe header's sizeofinitializeddatainfile.
Put 0 into the pe header's sizeofuninitializeddatainfile.
Find um routine usando "~initialize before run e run e finalize after run" e the routine index.
Se the routine for inexistente, abort with "Erro interno: não achei a tarefa de inicialização"; exit.
Put the routine's address minus the image base into the pe header's addressofentrypointinmemory.
Put the code borough's base into the pe header's addressofcodeinmemory.
Put the data borough's base into the pe header's addressofinitializeddatainmemory.
Put the image base into the pe header's imagebase.
Put 4096 [$00001000] into the pe header's memoryalignment.
Put 4096 [$00001000] into the pe header's filealignment.
Put 0 into the pe header's reserved.
Put the compiler's exe size into the pe header's sizeofimageinmemory.
Put 4096 [section base] into the pe header's sizeofallheadersinfile.
Put 0 into the pe header's checksum.
Put 0 into the pe header's dllcharacteristics.
Put 1048576 [$00100000] into the pe header's maxstack.
Put 16384 [$00004000] into the pe header's minstack.
Put 1048576 [$00100000] into the pe header's maxheap.
Put 16384 [$00004000] into the pe header's minheap.
Put 0 into the pe header's loaderflags.

Etapas necessárias para que se initialize um pe header (standard header):
Put 17744 [$00004550] into the pe header's signature.
Put 332 [$014C] into the pe header's machinetype.
Put 3 [$0003] into the pe header's númeroofsections.
Put 0 into the pe header's timestamp.
Put 0 into the pe header's endereço de memóriatosymboltable.
Put 0 into the pe header's númeroofsymbols.
Put 224 [$00E0] into the pe header's sizeofoptionalheaderinpedaços.
Put 33166 [$818E] into the pe header's characteristics.

Etapas necessárias para que se initialize um pe header (version information):
Put 0 into the pe header's majorlinkerversion.
Put 0 into the pe header's minorlinkerversion.
Put 4 [$0004] into the pe header's osmajorversion.
Put 0 [$0000] into the pe header's osminorversion.
Put 0 into the pe header's usermajorversion.
Put 0 into the pe header's userminorversion.
Put 4 [$0004] into the pe header's subsystemmajorversion.
Put 0 [$0000] into the pe header's subsystemminorversion.
Put 2 [$0002] into the pe header's subsystem.

The intel tag é um tag equal to 11.

An intermediate é um local.

The jump false tag é um tag equal to 12.

Etapas necessárias para que se link:
Round up borough sizes.
Initialize um dos header.
Initialize um pe header.
Fill the compiler's exe with the null pedaço usando the compiler's exe size.
Blurt the dos header into the compiler's exe.
Blurt the pe header into the compiler's exe.
Blurt the imports into the compiler's exe.
Blurt the globals into the compiler's exe.
Blurt the literals into the compiler's exe.
Blurt the routines into the compiler's exe.

The linking timer é um timer.

Etapas necessárias para que se list:
Clear the compiler's listing.
List the compiler's abort message in the compiler's listing.
List the types under "TYPES:" in the compiler's listing.
List the globals under "GLOBALS:" in the compiler's listing.
List the literals under "LITERALS:" in the compiler's listing.
List the routines under "ROUTINES:" in the compiler's listing.
List the type index under "TYPE INDEX:" in the compiler's listing.
List the global index under "GLOBAL INDEX:" in the compiler's listing.
List the literal index under "LITERAL INDEX:" in the compiler's listing.
List the routine index under "ROUTINE INDEX:" in the compiler's listing.
List the utility index under "UTILITY INDEX:" in the compiler's listing.
List the imports under "IMPORTS:" in the compiler's listing.
List the source files under "SOURCE FILES:" in the compiler's listing.
List the timers under "TIMERS:" in the compiler's listing.
Write the compiler's listing to the compiler's listing path.

Etapas necessárias para que se list um abort message in um buffer:
Se the abort message estiver blank, cancele.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" to the buffer.
Advance the buffer (twice).
Posponha the abort message to the buffer.
Advance the buffer (twice).

Etapas necessárias para que se list um bucket in um buffer:
Se the bucket's refers are empty, cancele.
Posponha "/bucket" to the buffer (with separator).
Advance the buffer.
List the bucket's refers in the buffer.
Advance the buffer.

Etapas necessárias para que se list some entries in um buffer:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
List the entry in the buffer.
Repeat.

Etapas necessárias para que se list um entry in um buffer:
Se the entry for inexistente, cancele.
Posponha "/entry" to the buffer (with separator).
Posponha the entry's name to the buffer (with separator).
Posponha the entry's address to the buffer (as hex with separator).
Advance the buffer.

Etapas necessárias para que se list um fragment in um buffer:
Posponha "/fragment" to the buffer (with separator).
Posponha the fragment's tag to the buffer (as um fragment tag string with separator).
Posponha the fragment's variable to the buffer (with separator).
Posponha the fragment's other variable to the buffer (with separator).
Posponha the fragment's routine to the buffer (with separator).
Posponha the fragment's entry to the buffer (with separator).
Posponha the fragment's número to the buffer (as hex with separator).
Posponha the fragment's address to the buffer (as hex with separator).
Convert the fragment's code to um nibble string.
Posponha the nibble string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some fragments in um buffer:
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
List the fragment in the buffer.
Repeat.

Etapas necessárias para que se list um import in um buffer:
Se the import for inexistente, cancele.
Posponha "/import" to the buffer (with separator).
Posponha the import's name to the buffer (with separator).
Advance the buffer.
List the import's entries in the buffer.
Advance the buffer.

Etapas necessárias para que se list some imports in um buffer:
Obtenha um import from the imports.
Se the import for inexistente, cancele.
List the import in the buffer.
Repeat.

Etapas necessárias para que se list some imports under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the imports are empty, cancele.
List the imports in the buffer.

Etapas necessárias para que se list um index in um buffer:
Posponha "/" then the index's used bucket count then " buckets" to the buffer (with separator).
Posponha the index's count then " refers" to the buffer (with separator).
Advance the buffer (twice).
Loop.
Obtenha um bucket usando the index.
Se the bucket for inexistente, cancele.
List the bucket in the buffer.
Repeat.

Etapas necessárias para que se list um index under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the index é empty, cancele.
List the index in the buffer.

Etapas necessárias para que se list um refer in um buffer:
Se the refer for inexistente, cancele.
Posponha "/refer" to the buffer (with separator).
Posponha the refer's string to the buffer.
Se the refer's endereço de memória for inexistente, posponha "..." to the buffer.
Posponha "/" to the buffer.
Advance the buffer.

Etapas necessárias para que se list some refers in um buffer:
Obtenha um refer from the refers.
Se the refer for inexistente, cancele.
List the refer in the buffer.
Repeat.

Etapas necessárias para que se list um routine in um buffer:
Se the routine for inexistente, cancele.
Posponha "/routine" to the buffer (with separator).
Posponha the routine's moniker to the buffer (with separator).
Posponha the routine's compiled flag to the buffer (with separator).
Posponha the routine's callback flag to the buffer (with separator).
Posponha the routine's decider flag to the buffer (with separator).
Posponha the routine's function flag to the buffer (with separator).
Posponha the routine's employs moniker to the buffer (with separator).
Posponha the routine's parameter size to the buffer (with separator).
Posponha the routine's local size to the buffer (with separator).
Posponha the routine's address to the buffer (as hex with separator).
Advance the buffer.
List the routine's parameters in the buffer.
List the routine's locals in the buffer.
List the routine's fragments in the buffer.
Advance the buffer.

Etapas necessárias para que se list some routines in um buffer:
Obtenha um routine from the routines.
Se the routine for inexistente, cancele.
List the routine in the buffer.
Repeat.

Etapas necessárias para que se list some routines under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the routines are empty, cancele.
List the routines in the buffer.

Etapas necessárias para que se list um source file in um buffer:
Se the source file for inexistente, cancele.
Posponha "/source file" to the buffer (with separator).
Posponha the source file's path to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some source files in um buffer:
Obtenha um source file from the source files.
Se the source file for inexistente, cancele.
List the source file in the buffer.
Repeat.

Etapas necessárias para que se list some source files under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the source files are empty, cancele.
List the source files in the buffer.
Advance the buffer.

Etapas necessárias para que se list um timer usando um string in um buffer:
Posponha "/timer" to the buffer (with separator).
Posponha the string to the buffer (with separator).
Posponha the timer's string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list the timers under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
List the loading timer usando "loading" in the buffer.
List the scanning timer usando "scanning" in the buffer.
List the resolving types timer usando "resolving types" in the buffer.
List the resolving globals timer usando "resolving globals" in the buffer.
List the compiling routine headers timer usando "compiling routine headers" in the buffer.
List the calculating timer usando "calculating" in the buffer.
List the adding built-in memory routines timer usando "adding built-in memory routines" in the buffer.
List the indexing utilities timer usando "indexing utilities" in the buffer.
List the compiling routine bodies timer usando "compiling routine bodies" in the buffer.
List the adding built-in startup routine timer usando "adding built-in startup routine" in the buffer.
List the offsetting timer usando "offsetting" in the buffer.
List the addressing timer usando "addressing" in the buffer.
List the transmogrifying timer usando "transmogrifying" in the buffer.
List the linking timer usando "linking" in the buffer.
List the writing timer usando "writing" in the buffer.
List the compiler's timer usando "total" in the buffer.
Advance the buffer.

Etapas necessárias para que se list um type in um buffer:
Se the type for inexistente, cancele.
Posponha "/type" to the buffer (with separator).
Posponha the type's name to the buffer (with separator).
Posponha the type's plural name to the buffer (with separator).
Posponha the type's length to the buffer (as hex with separator).
Posponha the type's base name to the buffer (with separator).
Posponha the type's base type to the buffer (with separator).
Posponha the type's target name to the buffer (with separator).
Posponha the type's target type to the buffer (with separator).
Posponha the type's scale to the buffer (with separator).
Advance the buffer.
List the type's fields in the buffer.
Advance the buffer.

Etapas necessárias para que se list some types in um buffer:
Obtenha um type from the types.
Se the type for inexistente, cancele.
List the type in the buffer.
Repeat.

Etapas necessárias para que se list some types under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the types are empty, cancele.
List the types in the buffer.

Etapas necessárias para que se list um variable in um buffer:
Se the variable for inexistente, cancele.
Posponha "/variable" to the buffer (with separator).
Posponha the variable's kind to the buffer (with separator).
Posponha the variable's compiled flag to the buffer (with separator).
Posponha the variable's name to the buffer (with separator).
Posponha the variable's nickname to the buffer (with separator).
Posponha the variable's type name to the buffer (with separator).
Posponha the variable's type to the buffer (with separator).
Posponha the variable's address [or offset] to the buffer (as hex with separator).
Posponha the variable's by-value flag to the buffer (with separator).
Posponha the variable's count to the buffer (with separator).
Posponha the variable's reference flag to the buffer (with separator).
Posponha the variable's redefinition target name to the buffer (with separator).
Posponha the variable's literal to the buffer (with separator).
Convert the variable's data to um nibble string.
Posponha the nibble string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some variables in um buffer:
Obtenha um variable from the variables.
Se the variable for inexistente, cancele.
List the variable in the buffer.
Repeat.

Etapas necessárias para que se list some variables under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the variables are empty, cancele.
List the variables in the buffer.
Advance the buffer.

The literal index é um index.

An literal é um variable.

The literals are some literals.

The load address tag é um tag equal to 13.

The load eax tag é um tag equal to 14.

An local é um variable.

An locus é um pedaço endereço de memória.

The loop tag é um tag equal to 15.

An moniker é um string.

An monikette é um coisa with
An string,
An type (reference),
An variable (reference),
\ por bubbling
An current type (reference),
An current substring.

Etapas necessárias para que se move um rider (code rules - comment):
Bump the rider.
Se the rider's source estiver blank, cancele.
Se the rider's source's first's target for not the return pedaço, repeat.

Etapas necessárias para que se move um rider (code rules - glom):
Bump the rider.
Se the rider's source estiver blank, cancele.
Se the rider está on any possessive, cancele.
Se the rider's source's first's target é any glom pedaço, repeat.

Etapas necessárias para que se move um rider (code rules - mark):
Bump the rider.

Etapas necessárias para que se move um rider (code rules - noise):
Bump the rider.
Se the rider's source estiver blank, cancele.
Se the rider's source's first's target é noise, repeat.

Etapas necessárias para que se move um rider (code rules - possessive):
Bump the rider.
Se the rider's source estiver blank, cancele.
Se the rider's source starts with "s", bump the rider.

Etapas necessárias para que se move um rider (code rules - qualifier):
Se the rider's source estiver blank, cancele.
Se the rider's source's first's target é the return pedaço, pare.
Se the rider's source's first's target é the left-paren pedaço, adicione 1 to um count.
Se the rider's source's first's target é the right-paren pedaço, subtract 1 from the count.
Bump the rider.
Se the count for 0, pare.
Repeat.

Etapas necessárias para que se move um rider (code rules - remark):
Se the rider's source estiver blank, cancele.
Se the rider's source's first's target é the return pedaço, pare.
Se the rider's source's first's target é the left-bracket pedaço, adicione 1 to um count.
Se the rider's source's first's target é the right-bracket pedaço, subtract 1 from the count.
Bump the rider.
Se the count for 0, pare.
Repeat.  

Etapas necessárias para que se move um rider (code rules - string):
Bump the rider.
Se the rider's source estiver blank, cancele.
Se the rider's source's first's target é the return pedaço, cancele.
Se the rider está on any nested double-quote, bump the rider; repeat.
Se the rider's source's first's target é the double-quote pedaço, bump the rider; exit.
Repeat.

Etapas necessárias para que se move um rider (code rules - symbol):
Bump the rider.

Etapas necessárias para que se move um rider (code rules):
Position the rider's token on the rider's source.
Se the rider's source estiver blank, cancele.
Se the rider's source's first's target é noise, move the rider (code rules - noise); exit.
Se the rider's source's first's target é the backslash pedaço, move the rider (code rules - comment); exit.
Se the rider's source's first's target é the left-bracket pedaço, move the rider (code rules - remark); exit.
Se the rider's source's first's target é the double-quote pedaço, move the rider (code rules - string); exit.
Se the rider's source's first's target é the left-paren pedaço, move the rider (code rules - qualifier); exit.
Se the rider's source's first's target é any mark, move the rider (code rules - mark); exit.
Se the rider está on any possessive, move the rider (code rules - possessive); exit.
Move the rider (code rules - glom).

Etapas necessárias para que se move um rider (compiler rules):
Se the compiler's abort flag estiver verde, clear the rider's token; exit.
Move the rider returning um error string (code rules).
Se the error string estiver not blank, abort with the error string e the rider's token's first; exit.
\Se the rider's token for "del", unbump the rider; exit. \ Spanish contraction "del"; fudged to "de l", short por "de el"
\Se the rider's token for "al", unbump the rider; exit. \ Spanish contraction "al"; fudged to "a l", short por "a el"
Se the rider's token estiver blank, cancele.
Se the rider's token's first's target é noise, repeat.
Se the rider's token's first's target é the backslash pedaço, repeat.
Se the rider's token's first's target é the left-bracket pedaço, repeat.

Etapas necessárias para que se move um rider returning um error string (code rules - validate qualifier):
Se the rider's token's length é less than 2, put "Qualifiers need to end with ')'." into the error string; exit.
Se the rider's token's last's target for not the right-paren pedaço, put "Qualifiers need to end with ')'." into the error string; exit.

Etapas necessárias para que se move um rider returning um error string (code rules - validate remark):
Se the rider's token's length é less than 2, put "Remarks need to end with ']'." into the error string; exit.
Se the rider's token's last's target for not the right-bracket pedaço, put "Remarks need to end with ']'." into the error string; exit.

Etapas necessárias para que se move um rider returning um error string (code rules - validate string):
Se the rider's token's length é less than 2, put "Strings need to end with '""'." into the error string; exit.
Se the rider's token's last's target for not the double-quote pedaço, put "Strings need to end with '""'." into the error string; exit.

Etapas necessárias para que se move um rider returning um error string (code rules):
Clear the error string.
Move the rider (code rules).
Se the rider's token estiver blank, cancele.
Se the rider's token's first's target é the left-bracket pedaço, move the rider returning the error string (code rules - validate remark); exit.
Se the rider's token's first's target é the double-quote pedaço, move the rider returning the error string (code rules - validate string); exit.
Se the rider's token's first's target é the left-paren pedaço, move the rider returning the error string (code rules - validate qualifier); exit.

An nibble substring é um substring.

An nickname é um name.

The not tag é um tag equal to 16.

Etapas necessárias para que se offset the locals in um routine:
Se the routine for inexistente, cancele.
Se the routine's compiled flag estiver not verde, cancele.
Clear the routine's local size.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Obtenha um local from the routine's locals.
Se the local for inexistente, cancele.
Se the local's previous for not inexistente, put the local's previous' offset into the local's offset.
Put the local's type's length into um length.
Se the local's kind for "scratch", put um endereço de memória's magnitude into the length.
Round the length up to the nearest multiple of 4.
Subtract the length from the local's offset.
Adicione the length to the routine's local size.
Repeat.

Etapas necessárias para que se offset the locals in some routines:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um routine from the routines.
Se the routine for inexistente, cancele.
Offset the locals in the routine.
Repeat.

Etapas necessárias para que se offset the parameters in um routine:
Se the routine for inexistente, cancele.
Se the routine's compiled flag estiver not verde, cancele.
Clear the routine's parameter size.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Obtenha um parameter from the routine's parameters.
Se the parameter for inexistente, cancele.
Se the routine's callback flag estiver verde, abra the parameter's by-value flag.
Se the parameter's previous for inexistente, put 8 into the parameter's offset. \ skip the return address e saved ebp
Se the parameter's previous for not inexistente, put the parameter's previous' offset plus 4 into the parameter's offset. \ all parameters are 4 pedaço endereço de memórias or 4 pedaço values por callbacks
Adicione 4 to the routine's parameter size.
Repeat.

Etapas necessárias para que se offset the parameters in some routines:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um routine from the routines.
Se the routine for inexistente, cancele.
Offset the parameters in the routine.
Repeat.

The offsetting timer é um timer.

An parameter é um variable.

An partial moniker é um moniker.

An pe header é um conjunto with
An número called signature,
An wyrd called machinetype,
An wyrd called númeroofsections,
An número called timestamp,
An número called endereço de memóriatosymboltable,
An número called númeroofsymbols,
An wyrd called sizeofoptionalheaderinpedaços,
An wyrd called characteristics,
\ optional header
An wyrd called magicnumber,
An pedaço called majorlinkerversion,
An pedaço called minorlinkerversion,
An número called sizeofcodeinfile,
An número called sizeofinitializeddatainfile,
An número called sizeofuninitializeddatainfile,
An número called addressofentrypointinmemory,
An número called addressofcodeinmemory,
An número called addressofinitializeddatainmemory,
An número called imagebase,
An número called memoryalignment,
An número called filealignment,
An wyrd called osmajorversion,
An wyrd called osminorversion,
An wyrd called usermajorversion,
An wyrd called userminorversion,
An wyrd called subsystemmajorversion,
An wyrd called subsystemminorversion,
An número called reserved,
An número called sizeofimageinmemory,
An número called sizeofallheadersinfile,
An número called checksum,
An wyrd called subsystem,
An wyrd called dllcharacteristics,
An número called maxstack,
An número called minstack,
An número called maxheap,
An número called minheap,
An número called loaderflags,
\ directories (16 address e size pairs)
An número called númeroofdirectories,
8 pedaços called directory0,
An número called imagedirectoryentryimportaddress,
An número called imagedirectoryentryimportsize,
112 pedaços called directories2-15,
An pe section header called idata section,
An pe section header called data section,
An pe section header called code section.

An pe section header é um conjunto with
8 pedaços called name,
An número called sizeinpedaços,
An número called addressinmemory,
An número called sizeinfile,
An número called addressinfile,
12 pedaços called reserved,
An número called characteristics.

An phrase é um string.

\Etapas necessárias para que se determine se um string looks like English:
\Load the lexicon.
\Se the lexicon for inexistente, show error "I can't find any lecksicon."; say no.
\Se the string estiver blank, say no.
\Slap um substring on the string.
\Put the substring's last into the substring's first.
\Loop.
\Se the substring's first é the string's first, pare.
\Se the substring's first's target é the space pedaço, adicione 1 to the substring's first; break.
\Subtract 1 from the substring's first.
\Repeat.
\Se the substring estiver in the lexicon's index, say yes.
\Say no.

Etapas necessárias para que se pluralize um string (portuguese rules):
Slap um rider on the string.
Loop.
Move the rider (spell checking rules).
Se the rider's token estiver blank, pare.
Se um plural string estiver not blank, posponha " " to the plural string.
Posponha the rider's token to the plural string.
Se the rider's token for "de", abra um flag; repeat.
Se the flag estiver not verde, pluralize the plural string (portuguese rules - each word).
Repeat.
Put the plural string into the string.

Etapas necessárias para que se pluralize um string (portuguese rules - each word):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se the string for "cidadão", posponha "s" to the string; exit.
Se the string for "irmão", posponha "s" to the string; exit.
Se the string for "cristão", posponha "s" to the string; exit.
Se the string for "refrão", posponha "s" to the string; exit.
Se the string for "pão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "capitão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "alemão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "charlatão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "caráter", put "carateres" into the string; exit.
Se the string for "júnior", put "juniores" into the string; exit.
Se the string for "sênior", put "seniores" into the string; exit.
Se the string for "mão", put "mãos" into the string; exit.
Se the string for "são", put "sãos" into the string; exit.
\# advérbios principais
Se the string for "muito", cancele.
Se the string for "pouco", cancele.
Se the string for "mais", cancele.
Se the string for "menos", cancele.
Se the string for "bastante", cancele.
Se the string for "quase", cancele.
Se the string for "demais", cancele.
Se the string for "bem", cancele.
Se the string for "deveras", cancele.
Se the string for "mal", cancele.
Se the string for "melhor", cancele.
Se the string for "pior", cancele.
\# palavras terminadas com "ão"
Se the string ends with "ão", pluralize the string (portuguese rules - ending words with "ão"); exit.
\# palavras terminadas com "l"
Se the string ends with "l", pluralize the string (portuguese rules - ending words with "l"); exit.
\# palavra terminadas com "m"
Se the string ends with "m", remove the last pedaço from the string; posponha "ns" to the string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se the string ends with "n", posponha "es" to the string; exit.
\# palavras terminadas com "r"
Se the string ends with "r", pluralize the string (portuguese rules - ending words with "r"); exit.
\# palavras terminadas com "s"
Se the string ends with "s", pluralize the string (portuguese rules - ending words with "s"); exit.
\# palavra terminadas com "x"
Se the string ends with "x", cancele.
\# palavras terminadas com "z"
Se the string ends with "z", pluralize the string (portuguese rules - ending words with "z"); exit.
\# regra padrão
Posponha "s" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "ão"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, posponha "s" to the string; exit.
\# regra padrão
Remove the last two pedaços from the string.
Posponha "ões" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "l"):
\# palavras terminadas com "al"
Se the string ends with "al", remove the last pedaço from the string; posponha "is" to the string; exit.
\# palavras terminadas com "el"
Se the string ends with "el", pluralize the string (portuguese rules - ending words with "el"); exit.
\# palavras terminadas com "il"
Se the string ends with "il", pluralize the string (portuguese rules - ending words with "il"); exit.
\# palavras terminadas com "ol"
Se the string ends with "ol", pluralize the string (portuguese rules - ending words with "ol"); exit.
\# palavras terminadas com "ul"
Se the string ends with "ul", remove the last pedaço from the string; posponha "is" to the string; exit.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "el"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, remove the last pedaço from the string; posponha "is" to the string; exit.
Remove the last two pedaços from the string.
Posponha "éis" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "il"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, remove the last two pedaços from the string; posponha "eis" to the string; exit.
Remove the last pedaço from the string.
Posponha "s" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "ol"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, remove the last pedaço from the string; posponha "is" to the string; exit.
Remove the last two pedaços from the string.
Posponha "óis" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "r"):
\# hiatos acentuados
\Se the string ends with "aír", posponha "es" to the string; exit.
\Se the string ends with "aúr", posponha "es" to the string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se the string ends with "ár", remove the last two pedaços from the string; posponha "ares" to the string; exit.
\Se the string ends with "âr", remove the last two pedaços from the string; posponha "ares" to the string; exit.
\Se the string ends with "ér", remove the last two pedaços from the string; posponha "eres" to the string; exit.
\Se the string ends with "êr", remove the last two pedaços from the string; posponha "eres" to the string; exit.
\Se the string ends with "ír", remove the last two pedaços from the string; posponha "ires" to the string; exit.
\Se the string ends with "ór", remove the last two pedaços from the string; posponha "ores" to the string; exit.
\Se the string ends with "ôr", remove the last two pedaços from the string; posponha "ores" to the string; exit.
\Se the string ends with "úr", remove the last two pedaços from the string; posponha "ures" to the string; exit.
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, posponha "es" to the string; exit.
\# hiatos
Se the string ends with "air", remove the last two pedaços from the string; posponha "íres" to the string; exit.
Se the string ends with "aur", remove the last two pedaços from the string; posponha "úres" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se the string ends with "as", cancele.
Se the string ends with "es", cancele.
Se the string ends with "os", cancele.
\# hiatos acentuados
Se the string ends with "aís", posponha "es" to the string; exit.
Se the string ends with "aús", posponha "es" to the string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se the string ends with "ás", remove the last two pedaços from the string; posponha "ases" to the string; exit.
Se the string ends with "âs", remove the last two pedaços from the string; posponha "ases" to the string; exit.
Se the string ends with "és", remove the last two pedaços from the string; posponha "eses" to the string; exit.
Se the string ends with "ês", remove the last two pedaços from the string; posponha "eses" to the string; exit.
Se the string ends with "ís", remove the last two pedaços from the string; posponha "ises" to the string; exit.
Se the string ends with "ós", remove the last two pedaços from the string; posponha "oses" to the string; exit.
Se the string ends with "ôs", remove the last two pedaços from the string; posponha "oses" to the string; exit.
Se the string ends with "ús", remove the last two pedaços from the string; posponha "uses" to the string; exit.
\# palavras terminadas com "is", "us"
Se the string ends with "is", pluralize the string (portuguese rules - ending words with "is/us"); exit.
Se the string ends with "us", pluralize the string (portuguese rules - ending words with "is/us"); exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "is/us"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, cancele.
\# hiatos
Se the string ends with "ais", remove the last two pedaços from the string; posponha "íses" to the string; exit.
Se the string ends with "aus", remove the last two pedaços from the string; posponha "úses" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "z"):
\# hiatos acentuados
Se the string ends with "aíz", posponha "es" to the string; exit.
Se the string ends with "aúz", posponha "es" to the string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se the string ends with "áz", remove the last two pedaços from the string; posponha "azes" to the string; exit.
Se the string ends with "âz", remove the last two pedaços from the string; posponha "azes" to the string; exit.
Se the string ends with "éz", remove the last two pedaços from the string; posponha "ezes" to the string; exit.
Se the string ends with "êz", remove the last two pedaços from the string; posponha "ezes" to the string; exit.
Se the string ends with "íz", remove the last two pedaços from the string; posponha "izes" to the string; exit.
Se the string ends with "óz", remove the last two pedaços from the string; posponha "ozes" to the string; exit.
Se the string ends with "ôz", remove the last two pedaços from the string; posponha "ozes" to the string; exit.
Se the string ends with "úz", remove the last two pedaços from the string; posponha "uzes" to the string; exit.
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, posponha "es" to the string; exit.
\# hiatos
Se the string ends with "aiz", remove the last two pedaços from the string; posponha "ízes" to the string; exit.
Se the string ends with "auz", remove the last two pedaços from the string; posponha "úzes" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (english rules);
Etapas necessárias para que se pluralize um string: \ nouns only
Se the string for "alumnus", put "alumni" into the string; exit.
Se the string for "auto", put "autos" into the string; exit.
Se the string for "cello", put "cellos" into the string; exit.
Se the string for "dwarf", put "dwarfs" into the string; exit.
Se the string for "foot", put "feet" into the string; exit.
Se the string for "genus", put "genera" into the string; exit.
Se the string for "goose", put "geese" into the string; exit.
Se the string for "hippo", put "hippos" into the string; exit.
Se the string for "louse", put "lice" into the string; exit.
Se the string for "memo", put "memos" into the string; exit.
Se the string for "mouse", put "mice" into the string; exit.
Se the string for "ox", put "oxen" into the string; exit.
Se the string for "phenomenon", put "phenomena" into the string; exit.
Se the string for "photo", put "photos" into the string; exit.
Se the string for "phylum", put "phyla" into the string; exit.
Se the string for "piano", put "pianos" into the string; exit.
Se the string for "pimento", put "pimentos" into the string; exit.
Se the string for "pro", put "pros" into the string; exit.
Se the string for "proof", put "proofs" into the string; exit.
Se the string for "radius", put "radii" into the string; exit.
Se the string for "rhinoceros", put "rhinoceri" into the string; exit.
Se the string for "roof", put "roofs" into the string; exit.
Se the string for "solo", put "solos" into the string; exit.
Se the string for "soprano", put "sopranos" into the string; exit.
Se the string for "staff", put "staffs" into the string; exit.
Se the string for "tooth", put "teeth" into the string; exit.
Se the string for "torus", put "tori" into the string; exit.
Se the string for "turf", put "turfs" into the string; exit.
Se the string for "virus", put "viruses" into the string; exit.
Se the string ends with "sh", posponha "es" to the string; exit.
Se the string ends with "ch", posponha "es" to the string; exit.
Se the string ends with "man", remove the last two pedaços from the string; posponha "en" to the string; exit.
Se the string ends with "child", posponha "ren" to the string; exit.
Se the string ends with "ex", remove the last two pedaços from the string; posponha "ices" to the string; exit. \ or adicione ES
Se the string ends with "fe", remove the last two pedaços from the string; posponha "ves" to the string; exit.
Se the string ends with "is", remove the last two pedaços from the string; posponha "es" to the string; exit.
Se the string ends with "ix", remove the last two pedaços from the string; posponha "ices" to the string; exit. \ or adicione ES
Se the string ends with "ma", posponha "ta" to the string; exit. \ or adicione S
Se the string ends with any consonant e "y", remove the last pedaço from the string; posponha "ies" to the string; exit.
Se the string ends with any vowel e "o", posponha "s" to the string; exit.
Se the string ends with any vowel e "y", posponha "s" to the string; exit.
Se the string ends with "f", remove the last pedaço from the string; posponha "ves" to the string; exit.
Se the string ends with "s", posponha "es" to the string; exit.
Se the string ends with "x", posponha "es" to the string; exit.
Se the string ends with "z", posponha "es" to the string; exit.
Posponha "s" to the string.

The prolog tag é um tag equal to 17.

An prototype string é um conjunto with um first pedaço endereço de memória e um last pedaço endereço de memória.

The push address tag é um tag equal to 18.

The push value tag é um tag equal to 19.

Etapas necessárias para que se put the compiler's exe path into um path:
Extract um designator from the compiler's directory.
Remove any trailing backslash from the designator.
Put the compiler's directory then the designator then ".exe" into the path.

Etapas necessárias para que se put the compiler's exe size into um size:
Put 4096 [section base] into the size.
Adicione the import borough's size to the size.
Adicione the data borough's size to the size.
Adicione the code borough's size to the size.

Etapas necessárias para que se put the compiler's listing path into um path:
Extract um designator from the compiler's directory.
Remove any trailing backslash from the designator.
Put the compiler's directory then the designator then ".lst" into the path.

Etapas necessárias para que se put um term into another term:
Put the term's variable into the other term's variable.
Put the term's phrase into the other term's phrase.

Etapas necessárias para que se load um source file:
Se the source file for inexistente, cancele.
Load the source file's path into the source file's buffer.
Se the i/o error estiver not blank, abort with "Não foi possível carregar o arquivo: '" then the source file's path then "'."; exit.
\Load the source file's path into um string.
\Se the i/o error estiver not blank, abort with "Não foi possível carregar o arquivo '" then the source file's path then "'."; exit.
\Parse the string to the source file's buffer (portuguese contractions e synonyms rules).

Etapas necessárias para que se load some source files:
Loop.
Se the compiler's abort flag estiver verde, cancele.
Obtenha um item from the compiler's directory.
Se the item for not found, pare.
Se the item's kind for not "file", repeat.
Se the item's extension estiver not blank, repeat.
Se the item looks reamish, repeat.
Adicione um source file to the source files usando the item's path.
Load the source file.
Repeat.

The loading timer é um timer.

Etapas necessárias para que se parse um string to another string (portuguese contractions e synonyms rules):
Clear the other string.
Clear um third string.
Slap um rider on the string.
Loop.
Se the rider's source estiver blank, cancele.
Position the rider's token on the rider's source.
Move the rider (code rules).
Se the rider's token's first's target for not any glom pedaço, posponha the rider's token to the other string; repeat.
Posponha the rider's token to the other string giving the third string (portuguese contractions e synonyms rules).
Put the rider's token into the third string.
Repeat.

Etapas necessárias para que se reduce some monikettes por utility use:
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Se the monikette's type for inexistente, repeat.
Reduce the monikette's type to um type por utility use.
Se the type for not inexistente, put the type into the monikette's type.
Repeat.

Etapas necessárias para que se reduce um type to another type por utility use:
Put the type into the other type.
Loop.
Se the other type for inexistente, cancele.
Se the other type's name for "texto hexadecimal", cancele.
Se the other type's name for "string", cancele.
Se the other type's name for "número", cancele.
Se the other type's name for "endereço de memória", cancele.
Se the other type's name for "coisa", void the other type; exit.
\PAL
\Se the other type's name for "elemento", void the other type; exit.
Se the other type's base type é the other type, void the other type; exit.
Put the other type's base type into the other type.
Repeat.

Etapas necessárias para que se reindex the utility index:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um bucket usando the utility index.
Se the bucket for inexistente, cancele.
Se the bucket's refers are empty, repeat.
Reindex the utility index usando the bucket's refers.
Repeat.

Etapas necessárias para que se reindex the utility index usando some refers:
Obtenha um refer from the refers.
Se the refer for inexistente, cancele.
Put the refer's endereço de memória into um routine.
Se the routine for inexistente, abort with "Erro interno na função: index the utility routines usando some refers"; exit.
Copy the routine's monikettes into some monikettes.
Reduce the monikettes por utility use.
Index the routine usando the monikettes e the routine index.
Destroy the monikettes.
Repeat.

Etapas necessárias para que se remove any negatives from some monikettes returning um flag:
Feche the flag.
Swap the monikettes with some other monikettes.
Loop.
Put the other monikettes' first into um monikette.
Se the monikette for inexistente, cancele.
Remove the monikette from the other monikettes.
\PAL
Se the monikette's string for "não", reverse the flag; destroy the monikette; repeat.
Se the monikette's string for "nada", reverse the flag; destroy the monikette; repeat.
\CAL
Se the monikette's string for "not", reverse the flag; destroy the monikette; repeat.
Se the monikette's string for "nada", reverse the flag; destroy the monikette; repeat.
Posponha the monikette to the monikettes.
Se the monikette's string for "can't", reverse the flag; put "can" into the monikette's string; repeat.
Se the monikette's string for "cannot", reverse the flag; put "can" into the monikette's string; repeat.
Se the monikette's string for "nothing", reverse the flag; put "something" into the monikette's string; repeat.
Se the monikette's string for "won't", reverse the flag; put "will" into the monikette's string; repeat.
Se the monikette's string ends with "n't", reverse the flag; remove trailing pedaços from the monikette's string usando 3; repeat.
Repeat.

The repeat tag é um tag equal to 21.

Etapas necessárias para que se resolve um field:
Se the compiler's abort flag estiver verde, cancele.
Se the field for inexistente, cancele.
Resolve the field como um variable.
Se the field's nickname for not any valid field name, clear the field's nickname.
Se the field's name for not any valid field name, abort with "'" then the field's name then "' é um field name inválido." e the field's locus; exit.

Etapas necessárias para que se resolve um global:
Se the global for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Se the global's global body estiver not blank, resolve the global (compile body).
Se the global's type name estiver blank, abort with "Tipo inválido: '" then the global's name then "' . O tipo da variável global está vazio." e the global's locus; exit.
Resolve the global como um variable.

Etapas necessárias para que se resolve um global (compile body):
Se the global for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Slap um rider on the global's global body.
Move the rider (compiler rules).
Se the rider's token for not any literal, abort with "Erro de tipo. O tipo: '" then the rider's token then "' tem que ser do tipo literal." e the rider; exit.
Compile um literal usando the rider.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver not blank, abort with "Acho que era bom colocar um ponto por aqui, né?" e the rider; exit.
Se the global's type name estiver blank, put the literal's type's name into the global's type name.
Put the literal into the global's literal.
Index the literal.

Etapas necessárias para que se resolve some globals:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Resolve the global.
Repeat.

Etapas necessárias para que se resolve um type (base type):
Se the compiler's abort flag estiver verde, cancele.
Se the type for inexistente, cancele.
Se the type's base type for not inexistente, cancele.
Find the type's base type usando the type's base name e the type index.
Se the type's base type for inexistente, abort with "Base type inválido:'" then the type's base name then "'." e the type's locus; exit.
Abra the type's cooking flag.
Se the type's base type's cooking flag estiver verde, abort with "Definição recursiva com '" then the type's base name then "'." e the type's locus; exit.
Resolve the type's base type (base type).
Feche the type's cooking flag.

Etapas necessárias para que se resolve um type (expand coisa): \ type's base type for not resolved yet
Se the compiler's abort flag estiver verde, cancele.
Se the type for inexistente, cancele.
Se the type's base type for not inexistente, cancele.
Se the type's name for "coisa", cancele.
\Se the type's name for "elemento", cancele.
Se the type cannot be reduced to "coisa" using the base name, cancele.
Find um base type usando the type's base name e the type index.
\  adicione coisa conjunto - the número of secret fields é hard coded in two places: search por "than 4" \ was 6
Put the type's name then " conjunto" into um name.
Put the type's name then " conjuntos" into um plural name.
Put the base type's name then " conjunto" into um base name.
Adicione um conjunto type to the types usando the name e the plural name e the base name.
Adicione um field to the conjunto type's fields usando "next " then the type's name e "next" e the type's name e the on flag.
\PAL
Adicione um portuguese field to the conjunto type's fields usando "seguinte " then the type's name e "seguinte" e the type's name e the on flag.
Put "next " then the type's name into the portuguese field's redefinition target name.
\Adicione um portuguese reverse field to the conjunto type's fields usando the type's name then " seguinte" e "seguinte" e the type's name e the on flag.
\Put "next " then the type's name into the portuguese reverse field's redefinition target name.
Adicione another field to the conjunto type's fields usando "previous " then the type's name e "previous" e the type's name e the on flag.
\Adicione another portuguese field to the conjunto type's fields usando "anterior " then the type's name e "anterior" e the type's name e the on flag.
\Put "previous " then the type's name into the other portuguese field's redefinition target name.
Adicione another portuguese reverse field to the conjunto type's fields usando the type's name then " anterior" e "anterior" e the type's name e the on flag.
Put "previous " then the type's name into the other portuguese reverse field's redefinition target name.
Se the type's fields are not empty, posponha the type's fields to the conjunto type's fields.
Index the conjunto type.
\ fix up original type to look like um endereço de memória
Put the conjunto type's name into the type's target name.
\ adicione chain type
Adicione um chain type to the types usando the type's plural name e "" e the base type's plural name.
Adicione um third field to the chain type's fields usando "first " then the type's name e "first" e the type's name e the on flag.
Adicione um third portuguese field to the chain type's fields usando "primeiro " then the type's name e "primeiro" e the type's name e the on flag.
Put "first " then the type's name into the third portuguese field's redefinition target name.
Adicione um third feminine portuguese field to the chain type's fields usando "primeira " then the type's name e "primeira" e the type's name e the on flag.
Put "first " then the type's name into the third feminine portuguese field's redefinition target name.
Adicione um fourth field to the chain type's fields usando "last " then the type's name e "last" e the type's name e the on flag.
Adicione um fourth portuguese field to the chain type's fields usando "último " then the type's name e "último" e the type's name e the on flag.
Put "last " then the type's name into the fourth portuguese field's redefinition target name.
Adicione um fourth portuguese feminine field to the chain type's fields usando "última " then the type's name e "última" e the type's name e the on flag.
Put "last " then the type's name into the fourth portuguese feminine field's redefinition target name.
Index the chain type.

Etapas necessárias para que se resolve um type (index plural):
Se the compiler's abort flag estiver verde, cancele.
Se the type for inexistente, cancele.
Se the type's plural name estiver blank, cancele.
Se the type can be reduced to "coisa" using the base name, cancele.
Index the type usando the type's plural name.

Etapas necessárias para que se resolve um type (optional info - endereço de memória):
Se the compiler's abort flag estiver verde, cancele.
Se the type's target type for not inexistente, cancele.
Se the type's target name estiver blank, put the type's base type's target type into the type's target type; exit.
Find the type's target type usando the type's target name e the type index.
Se the type's target type for inexistente, abort with "Não sei bem pra que coisa você está pointing at." e the type's locus; exit.

Etapas necessárias para que se resolve um type (optional info - conjunto):
Se the compiler's abort flag estiver verde, cancele.
Se the type's fields are empty, copy the type's base type's fields into the type's fields; exit.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Obtenha um field from the type's fields (backwards).
Se the field for inexistente, pare.
Se the field é duplicated in the type's fields, abort with "O campo '" then the field's name then "' está definido mais de uma vez." e the field's locus; exit.
Resolve the field.
Se the compiler's abort flag estiver verde, cancele.
Se the field's type's cooking flag estiver verde, abort with "Recursive definition no: '" then the field's type's name then "'." e the field's locus; exit.
Resolve the field's type (optional info). \ de novo
Se the field's reference flag estiver not verde, repeat.
Se the field's type cannot be reduced to "endereço de memória", abort with "Não entendi o parâmetro '(reference)' nesse campo '" then the field's name then "'..." e the field's locus; exit.
Repeat.
Eliminate duplicate nicknames from the type's fields.
Se the type cannot be reduced to "coisa conjunto", cancele.
Se the type's fields' count é greater than 4, cancele. \ already copied? was 2 por next e prev, now 6 to included Spanish redefiniions
Copy the type's base type's fields into the type's fields (data fields only).

Etapas necessárias para que se resolve um type (optional info - scale):
Se the compiler's abort flag estiver verde, cancele.
Put the type's base type into um base type.
Se the type's scale for 0, put the type's base type's scale into the type's scale; exit.
Se the base type's scale for 0, cancele.
Multiplique the type's scale por [via] the base type's scale.
Put the base type's base type into the type's base type.

Etapas necessárias para que se resolve um type (optional info):
Se the compiler's abort flag estiver verde, cancele.
Se the type for inexistente, cancele.
Se the type's optional info resolved flag estiver verde, cancele.
Se the type's base type é the type, cancele. \ por built in types
Check por invalid optional info on the type.
Abra the type's cooking flag.
Resolve the type's base type (optional info).
Se the type can be reduced to "endereço de memória", resolve the type (optional info - endereço de memória).
Se the type can be reduced to "conjunto", resolve the type (optional info - conjunto). \ mudar aqui
Se the type can be reduced to "número", resolve the type (optional info - scale).
Feche the type's cooking flag.
Abra the type's optional info resolved flag.

Etapas necessárias para que se resolve some types (base types):
Se the compiler's abort flag estiver verde, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolve the type (base type).
Repeat.

Etapas necessárias para que se resolve some types (expand coisas):
Se the compiler's abort flag estiver verde, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolve the type (expand coisa).
Repeat.

Etapas necessárias para que se resolve some types (index plurals):
Se the compiler's abort flag estiver verde, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolve the type (index plural).
Repeat.

Etapas necessárias para que se resolve some types (optional info):
Se the compiler's abort flag estiver verde, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolve the type (optional info).
Repeat.

Etapas necessárias para que se resolve um variable:
Se the compiler's abort flag estiver verde, cancele.
Se the variable for inexistente, cancele.
Se the variable's type for not inexistente, cancele.
Se the variable's type name estiver not blank, resolve the variable (explicit type name); exit.
Find the variable's type e the variable's nickname usando the variable's name.
Se the variable's type for not inexistente, put the variable's type's name into the variable's type name; exit.
Abort with "Não achei o tipo da variável '" then the variable's name then "'." e the variable's locus.

Etapas necessárias para que se resolve um variable (explicit type name):
Find the variable's type usando the variable's type name e the type index.
Se the variable's type for inexistente, abort with "Não achei o nome do tipo da variável '" then the variable's type name then "'." e the variable's locus; exit.

The resolving globals timer é um timer.

The resolving types timer é um timer.

Etapas necessárias para que se round up borough sizes:
Put the import borough's length into the import borough's size.
Round the import borough's size up to the nearest multiple of 4096.
Put the data borough's length into the data borough's size.
Round the data borough's size up to the nearest multiple of 4096.
Put the code borough's length into the code borough's size.
Round the code borough's size up to the nearest multiple of 4096.

The routine address tag é um tag equal to 22.

An routine body é um substring.

An routine header é um substring.

The routine index é um index.

An routine é um coisa with
An locus (reference),
An callback flag,
An decider flag,
An function flag,
An compiled flag,
An nickname index,
An moniker, some monikettes, some parameters, um parameter size,
An employs moniker,
Some locals, um local size,
An routine header, um header string,
An routine body, um body string,
Some fragments,
An address.

An routine reference é some monikettes.

The routines are some routines.

The save eax tag é um tag equal to 20.

Etapas necessárias para que se scan any optional info por um type usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token for "to", scan any optional info por the type usando the rider (endereço de memória); exit.
Se the rider's token for "para", scan any optional info por the type usando the rider (endereço de memória); exit.
Se the rider's token é any with, scan any optional info por the type usando the rider (conjunto); exit.

Etapas necessárias para que se scan any optional info por um type usando um rider (endereço de memória):
Move the rider (compiler rules).
Se the rider's token for not any indefinite article, abort with "A palavra 'to' precisa de um artigo indefinido depois dela, não de um '" then the rider's token then "'." e the rider; exit. 
Move the rider (compiler rules).
Scan the type's target name usando the rider.

Etapas necessárias para que se scan any optional info por um type usando um rider (conjunto):
Move the rider (compiler rules).
Scan the type's fields usando the rider.

Etapas necessárias para que se scan any pauses usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token for not any pause, cancele.
Move the rider (compiler rules).
Repeat.

Etapas necessárias para que se scan um field usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Scan the field usando the rider (type part).
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token é any called, scan the field usando the rider (called part); repeat.
Se the rider's token for "at", scan the field usando the rider (redefine part); repeat.
Se the rider's token for "em", scan the field usando the rider (redefine part); repeat.
Se the rider's token for "redefinindo", scan the field usando the rider (redefine part); repeat.
Se the rider's token é any reference, scan the field usando the rider (reference part); repeat.

Etapas necessárias para que se scan um field usando um rider (called part):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Se the field's type name estiver blank, put the field's name into the field's type name. \ pedaço array type name already filled in
Scan the field's name usando the rider.

Etapas necessárias para que se scan um field usando um rider (redefine part):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Se the rider's token for not any definite article, abort with "Eu estava esperando o artigo 'the', mas o que encontrei foi '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Scan the field's redefinition target name usando the rider.

Etapas necessárias para que se scan um field usando um rider (reference part):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Abra the field's reference flag.

Etapas necessárias para que se scan um field usando um rider (type part - pedaço array):
Se the compiler's abort flag estiver verde, cancele.
Convert the rider's token to um ratio.
Reduce the ratio.
Se the ratio's denominator for not 1, abort with "Você tem que especificar um número completo de pedaços para um pedaço array" e the rider; exit.
Put the ratio's numerator into the field's count.
Move the rider (compiler rules).
Se the rider's token for not "pedaço" or "pedaços", abort with "Você precisa usar a palavra 'pedaços' depois de um counted field designator." e the rider; exit.
Move the rider (compiler rules).
Put "pedaço" into the field's type name.

Etapas necessárias para que se scan um field usando um rider (type part - normal):
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token for not any indefinite article, abort with "Falta por um artigo idefinido aqui, mas você colocou isso: '" then the rider's token then "'." e the rider; exit.
Se the rider's token for "another", put "other" into the field's name.
\PAL
Se the rider's token for "outra", put "segunda" into the field's name.
Se the rider's token for "outro", put "segundo" into the field's name.
Move the rider (compiler rules).
Scan um name usando the rider.
Extend the field's name with the name.

Etapas necessárias para que se scan um field usando um rider (type part):
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token é any numeric literal, scan the field usando the rider (type part - pedaço array); exit.
Scan the field usando the rider (type part - normal).

Etapas necessárias para que se scan some fields usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Adicione um field to the fields usando "field" e the rider's token's first.
Scan the field usando the rider.
Se the rider's token for not any pause, cancele.
Scan any pauses usando the rider.
Repeat.

Etapas necessárias para que se scan um global body usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Put the rider's token's first into the global body's first.
Put -1 into the global body's last.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Se the rider's token é the colon pedaço, cancele.
Se the rider's token é the period pedaço, cancele.
Put the rider's token's last into the global body's last.
Move the rider (compiler rules).
Repeat.

Etapas necessárias para que se scan um global usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Adicione the global to the globals usando "global" e the rider's token's first.
Move the rider (compiler rules).
Scan the global's name usando the rider.
Se the rider's token é any has, scan the global usando the rider (has or have); exit.
Se the rider's token for not any is, abort with "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Se the rider's token for not any indefinite article, scan the global usando the rider (literal term); exit.
Move the rider (compiler rules).
Scan the global's type name usando the rider.  
Se the rider's token é the start of any optional info, scan the global usando the rider (optional info); exit.
Se the rider's token é any equal, scan the global usando the rider (data part); exit.
Se the rider's token for not the period pedaço, abort with "Toda definição precisa terminar com um ponto. Inclusive essa." e the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um global usando um rider (data part):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Se the rider's token for not any to, abort with "Depois da palavra 'equal' você precisa por um palavra  'to'. Você colocou ; '" then the rider's token then "'." e the rider; exit. 
Move the rider (compiler rules).
Scan the global's global body usando the rider.
Se the rider's token for not the period pedaço, abort with "Falta terminar um frase com um ponto." e the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um global usando um rider (has or have):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Put "~inline " then the global's name then " type" into um name.
Put the name then "s" into um plural name.
Adicione um type to the types usando the name e the plural name e "conjunto" e the global's locus. \mudar aqui
Index the type.
Put the type's name into the global's type name.
Scan the type's fields usando the rider.
Se the rider's token for not the period pedaço, abort with "Aprenda a escrever direito. Cadê o ponto?." e the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um global usando um rider (literal term):
Se the compiler's abort flag estiver verde, cancele.
Scan the global's global body usando the rider.
Se the rider's token for not the period pedaço, abort with "Aprenda a escrever corretamente. Cadê o ponto?." e the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um global usando um rider (optional info):
Se the compiler's abort flag estiver verde, cancele.
Put "~inline " then the global's name then " type" into um name.
Put the name then "s" into um plural name.
Adicione um type to the types usando the name e the plural name e the global's type name e the global's locus.
Index the type.
Put the type's name into the global's type name.
Scan any optional info por the type usando the rider.
Se the rider's token for not the period pedaço, abort with "Tá na hora de aprender a escrever direito. Cadê o ponto?." e the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um name usando um rider:
Clear the name.
Se the compiler's abort flag estiver verde, cancele.
Se the rider está on any name starter, extend the name with the rider's token; move the rider (compiler rules).
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider está on any name ender, pare.
Extend the name with the rider's token.
Move the rider (compiler rules).
Repeat.
Se the name estiver blank, abort with "Acho que faltou colocar um nome por aqui. Você escreveu '" then the rider's token then "'." e the rider; exit.

Etapas necessárias para que se scan um routine body usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Se the rider's token é the start of any definition, cancele.
Put the rider's token's first into the routine body's first.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Put the rider's token's last into the routine body's last.
Se the rider's token é the colon pedaço, abort with "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e the rider; exit.
Se the rider's token for not the period pedaço, move the rider (compiler rules); repeat.
Move the rider (compiler rules).
Se the rider's token é the start of any definition, cancele.
Repeat.

Etapas necessárias para que se scan um routine usando um rider:  \ Define o cabeçalho de rotina.
Se the compiler's abort flag estiver verde, cancele.
Adicione the routine to the routines usando the rider's token's first.
Move the rider (compiler rules). \ skip the "Passos" e obtenha the next token
Se the rider's token for "necessários" or "necessárias", move the rider (compiler rules). 
Se the rider's token for not "para", abort with "Você precisa escrever 'para' antes de '" then the rider's token then "' nesse tipo de rotina." e the rider; exit.
Move the rider (compiler rules). \ skip the "para" e obtenha the next token
Se the rider's token for not "que", abort with "Você precisa colocar um 'que' antes da palavra '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules). \ skip the "que" e obtenha the next token
Se the rider's token for not "se", abort with "Você precisa colocar um 'se' antes da palavra '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).  \ skip the "se" e obtenha the next token
Scan the routine's routine header usando the rider.
Se the rider's token é the semi-colon pedaço, scan the routine usando the rider (alternate wording); exit.  \ *** por alternate wordings
Se the rider's token for not the colon pedaço, abort with "O nome dessa função está escrito errado.." e the routine's locus; exit.
Move the rider (compiler rules).
Scan the routine's routine body usando the rider.

Etapas necessárias para que se scan um routine usando um rider (alternate wording):  \ *** por alternate wordings
Privatize the rider.
Move the rider (compiler rules).
Se the rider's token for not the start of any routine, abort with "Esse ponto e vírgula tá no lugar errado." e the original rider; exit.
Put the original rider's token's first into the routine's routine body's first.
Put the original rider's token's last into the routine's routine body's last.
Move the original rider (compiler rules).

Etapas necessárias para que se scan um routine header usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Put the rider's token's first into the routine header's first.
Put -1 into the routine header's last.
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Se the rider's token é the semi-colon pedaço, cancele. \ *** alternate wordings
Se the rider's token é the colon pedaço, cancele.
Se the rider's token é the period pedaço, cancele.
Put the rider's token's last into the routine header's last.
Move the rider (compiler rules).
Repeat.

Etapas necessárias para que se scan um source file:
Se the source file for inexistente, cancele.
Se the compiler's abort flag estiver verde, cancele.
Slap um rider on the source file's buffer.
Move the rider (compiler rules).
Loop.
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token estiver blank, cancele.
Se the rider's token é the start of any type, scan um type usando the rider; repeat.
Se the rider's token é the start of any global, scan um global usando the rider; repeat.
Se the rider's token é the start of any routine, scan um routine usando the rider; repeat.
Abort with "Faltou definir melhor o que é o '" then the rider's token then "'." e the rider.
Repeat.

Etapas necessárias para que se scan some source files:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um source file from the source files.
Se the source file for inexistente, cancele.
Scan the source file.
Repeat.

Etapas necessárias para que se scan um type usando um rider:
Se the compiler's abort flag estiver verde, cancele.
Se the rider's token é any portuguese indefinite article, abra um portuguese flag.
Se the rider's token é any english indefinite article, abra um english flag.
Adicione the type to the types usando the rider's token's first.
Move the rider (compiler rules).
Scan the type's name usando the rider.
Put the type's name into the type's plural name.
Se the portuguese flag estiver verde, pluralize the type's plural name (portuguese rules).
Se the english flag estiver verde, pluralize the type's plural name (english rules).
Se the english flag estiver not verde, pluralize the type's plural name (portuguese rules).
Se the rider's token é any has, scan the type usando the rider (has or have); exit.
Se the rider's token for not any is, abort with "Eu esperava um 'is' ou um 'are', mas só achei um : '" then the rider's token then "'." e the rider; exit.
\Pluralize the type's plural name.
\Se the rider's token for "has" or "have", scan the type usando the rider (has or have); exit.
\Se the rider's token for not "is" or "are", abort with "I was expecting um 'is' or 'are', but I found '" then the rider's token then "'." e the rider; exit.

Move the rider (compiler rules).
Se the rider's token é any numeric literal, scan the type usando the rider (unit of measure); exit.
Se the rider's token for not any indefinite article, abort with "Faltou um artigo indefinido, lembra? '" then the rider's token then "'." e the rider; exit. 
Move the rider (compiler rules).
Scan the type's base name usando the rider.
Scan any optional info por the type usando the rider.
Se the rider's token for not the period pedaço, abort with "Você precisa usar um ponto para definir um tipo, lembra? Você usou '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Index the type.

Etapas necessárias para que se scan um type usando um rider (has or have):
Se the compiler's abort flag estiver verde, cancele.
Move the rider (compiler rules).
Put "conjunto" into the type's base name. \\mudar aqui
Scan the type's fields usando the rider.
Se the rider's token for not the period pedaço, abort with "Ao invés de usar o ponto para definir  tipo, você usou '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Index the type.

Etapas necessárias para que se scan um type usando um rider (unit of measure):
Se the compiler's abort flag estiver verde, cancele.
Convert the rider's token to the type's scale.
Se the type's scale for 0, abort with "Zero é um tipo de escala inválido." e the type's locus; exit.
Move the rider (compiler rules).
Scan the type's base name usando the rider.
Se the rider's token for not the period pedaço, abort with "Os tipos precisam terminar com um ponto, não com '" then the rider's token then "'." e the rider; exit.
Move the rider (compiler rules).
Index the type.

The scanning timer é um timer.

An scratch é um local.

Etapas necessárias para que se scrub um index:
Obtenha um bucket usando the index.
Se the bucket for inexistente, cancele.
Se the bucket's refers are empty, repeat.
Scrub the bucket's refers.
Repeat.

Etapas necessárias para que se scrub some refers:
Swap the refers with some other refers.
Loop.
Put the other refers' first into um refer.
Se the refer for inexistente, cancele.
Remove the refer from the other refers.
Se the refer's endereço de memória for inexistente, destroy the refer; repeat.
Posponha the refer to the refers.
Repeat.

Etapas necessárias para que se abra the compiled flag in um variable:
Se the variable for inexistente, cancele.
Se the variable's compiled flag estiver verde, cancele.
Abra the variable's compiled flag.
Se the variable's kind for not "global", cancele.
Se the variable's literal for inexistente, cancele.
Find um routine usando "put" e the variable's literal's type e "into" e the variable's type.
Se the routine for inexistente, find the routine usando "convert" e the variable's literal's type e "to" e the variable's type; abra um flag.
Se the routine for inexistente, abort with "O tipo dessa variável global e desse literal não são compatíveis." e the variable's locus; exit.
Compile the body of the routine.
Se the flag estiver verde, put "convert the " then the variable's literal's name then " to the " then the variable's name then ". " into the variable's initializer string.
Se the flag estiver not verde, put "put the " then the variable's literal's name then " into the " then the variable's name then ". " into the variable's initializer string.

Etapas necessárias para que se skip to the next word in um substring:
Se the substring estiver blank, cancele.
Se the substring's first's target é noise, pare.
Adicione 1 to the substring's first.
Repeat.
Skip any leading noise in the substring.

Etapas necessárias para que se skip to the previous word in um substring:
Se the substring estiver blank, cancele.
Se the substring's last's target é noise, pare.
Subtract 1 from the substring's last.
Repeat.
Skip any trailing noise in the substring.

An source file é um coisa with um path e um buffer.

The source files are some source files.

An tag é um número.

An term é um conjunto with um variable e um phrase.

Etapas necessárias para que se transmogrify um fragment:
Se the compiler's abort flag estiver verde, cancele.
Se the fragment for inexistente, cancele.
Se the fragment's tag é the push address tag, transmogrify the fragment (push address); exit.
Se the fragment's tag é the call internal tag, transmogrify the fragment (call internal); exit.
Se the fragment's tag é the load address tag, transmogrify the fragment (load address); exit.
Se the fragment's tag é the increment tag, transmogrify the fragment (increment); exit.
Se the fragment's tag é the dereference tag, transmogrify the fragment (dereference); exit.
Se the fragment's tag é the jump false tag, transmogrify the fragment (jump false); exit.
Se the fragment's tag é the not tag, transmogrify the fragment (not); exit.
Se the fragment's tag é the exit tag, transmogrify the fragment (exit); exit.
Se the fragment's tag é the repeat tag, transmogrify the fragment (repeat); exit.
Se the fragment's tag é the break tag, transmogrify the fragment (break); exit.
Se the fragment's tag é the prolog tag, transmogrify the fragment (prolog); exit.
Se the fragment's tag é the epilog tag, transmogrify the fragment (epilog); exit.
Se the fragment's tag é the push value tag, transmogrify the fragment (push value); exit.
Se the fragment's tag é the call external tag, transmogrify the fragment (call external); exit.
Se the fragment's tag é the load eax tag, transmogrify the fragment (load eax); exit.
Se the fragment's tag é the save eax tag, transmogrify the fragment (save eax); exit.
Se the fragment's tag é the call indirect tag, transmogrify the fragment (call indirect); exit.
Se the fragment's tag é the routine address tag, transmogrify the fragment (routine address); exit.

Etapas necessárias para que se transmogrify um fragment (break):
Put the repeat tag into um tag.
Find another fragment usando the fragment e the tag.
Se the other fragment for inexistente, put the finalize tag into the tag. \ por break sem um loop or after um loop
Find um third fragment usando the current routine's fragments' last e the tag (backwards).
Se the third fragment for inexistente, abort with "Erro interno - transmogrify um fragment (break)"; exit.
Se the third fragment's next for inexistente, abort with "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 e the third fragment's next's address to the fragment. \ JMP the destination's address

Etapas necessárias para que se transmogrify um fragment (call external):
Attach $FF15 e the fragment's entry's address to the fragment's code. \ call [the fragment's entry's address]

Etapas necessárias para que se transmogrify um fragment (call indirect):
Attach address loading code to the fragment's code usando the fragment's variable. \ put address into edx
Attach $FF12 to the fragment's code. \ call [edx]

Etapas necessárias para que se transmogrify um fragment (call internal):
Obtenha um address usando the fragment's routine.
Attach $E8 e the address to the fragment. \ call the fragment's routine's address

Etapas necessárias para que se transmogrify um fragment (dereference):
Attach $8B95 e the fragment's variable's offset to the fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
Attach $8B12 to the fragment's code. \ mov edx,[edx]
Attach $8995 e the fragment's variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

Etapas necessárias para que se transmogrify um fragment (epilog):
Se the current routine's callback flag estiver verde, attach $5F5E5B to the fragment's code. \ pop edi, esi, ebx
Attach $8BE5 to the fragment's code. \ mov esp,ebp
Attach $5D to the fragment's code. \ pop ebp
Attach $C2 e the current routine's parameter size to the fragment's code. \ ret the current routine's parameter size

Etapas necessárias para que se transmogrify um fragment (exit):
Find another fragment usando the fragment e the finalize tag.
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 e the other fragment's address to the fragment. \ jmp the destination's address

Etapas necessárias para que se transmogrify um fragment (increment):
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (increment)"; exit.
Se the fragment's variable's kind for not "scratch", abort with "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 e the fragment's variable's offset e the fragment's número to the fragment's code. \ adicione [ebp+the fragment's variable's offset],the fragment's número

Etapas necessárias para que se transmogrify um fragment (jump false):
Find another fragment usando the fragment e the end if tag.
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 to the fragment's code. \ cmp eax,0
Attach $0F84 e the other fragment's address to the fragment. \ je the destination's address

Etapas necessárias para que se transmogrify um fragment (load address):
Attach address loading code to the fragment's code usando the fragment's variable. \ put address into edx
Attach $8995 e the fragment's other variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

\Etapas necessárias para que se transmogrify um fragment (load eax):
\Attach address loading code to the fragment's code usando the fragment's variable. \ put address into edx
\Se the fragment's variable for inexistente, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type for inexistente, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type's length for not 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (load eax):
Attach $B8 e the fragment's flag to the fragment's code. \ mov eax,flag
\Attach address loading code to the fragment's code usando the fragment's variable. \ put address into edx
\Se the fragment's variable for inexistente, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type for inexistente, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type's length for not 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (not):
Attach $83F001 to the fragment's code. \ xor eax,1

Etapas necessárias para que se transmogrify um fragment (prolog):
Attach $55 to the fragment's code. \ push ebp
Attach $8BEC to the fragment's code. \ mov ebp,esp
Put the current routine's local size dividido por 4 into um número.
Se the número for not 0, attach $B9 e the número e $6A004975FB to the fragment's code. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
Se the current routine's callback flag estiver verde, attach $535657 to the fragment's code. \ push ebx, esi, edi

Etapas necessárias para que se transmogrify um fragment (push address):
Attach address loading code to the fragment's code usando the fragment's variable. \ put address into edx
Attach $52 to the fragment's code. \ push edx

Etapas necessárias para que se transmogrify um fragment (push value):
Attach address loading code to the fragment's code usando the fragment's variable. \ put address into edx
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Put the fragment's variable's type's length into um length.
Se the length for 4, attach $FF32 to the fragment's code; exit. \ push [edx]
Se the length for 2, attach $66FF32 to the fragment's code; exit. \ push word ptr [edx]
Se the length for 1, attach $0FB61252 to the fragment's code; exit. \ movzxb edx,[edx]; push edx
Abort with "Erro interno 3 - transmogrify um fragment (push value)".

Etapas necessárias para que se transmogrify um fragment (repeat):
Find another fragment usando the fragment e the loop tag (backwards).
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 e the other fragment's address to the fragment. \ jmp the destination's address

Etapas necessárias para que se transmogrify um fragment (routine address):
Attach address loading code to the fragment's code usando the fragment's variable. \ put address into edx
Se the fragment's routine for inexistente, abort with "Erro interno - transmogrify um fragment (routine address)"; exit.
Obtenha um address usando the fragment's routine.
Attach $C702 e the address to the fragment's code. \ mov [edx],the address

Etapas necessárias para que se transmogrify um fragment (save eax):
Attach address loading code to the fragment's code usando the fragment's variable. \ put address into edx
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (save eax)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Put the fragment's variable's type's length into um length.
Se the length for 4, attach $8902 to the fragment's code; exit. \ mov [edx],eax
Se the length for 2, attach $668902 to the fragment's code; exit. \ mov [edx],ax
Se the length for 1, attach $8802 to the fragment's code; exit. \ mov [edx],al
Abort with "Erro interno 3 - transmogrify um fragment (save eax)".

Etapas necessárias para que se transmogrify some fragments:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Transmogrify the fragment.
Repeat.

Etapas necessárias para que se transmogrify um routine:
Se the compiler's abort flag estiver verde, cancele.
Se the routine for inexistente, cancele.
Se the routine's employs moniker estiver not blank, cancele.
Se the routine's compiled flag estiver not verde, cancele.
Put the routine into the current routine.
Transmogrify the routine's fragments.

Etapas necessárias para que se transmogrify some routines:
Se the compiler's abort flag estiver verde, cancele.
Obtenha um routine from the routines.
Se the routine for inexistente, pare.
Transmogrify the routine.
Repeat.

The transmogrifying timer é um timer.

The type index é um index.

An type é um coisa with
An locus (reference),
An name, um plural name,
An partial moniker,
An length,
An base name, um base type (reference),
An target name, um target type (reference) [endereço de memórias only],
An scale ratio,
Some fields [records only],
An cooking flag,
An optional info resolved flag.

An type name é um name.

The types are some types.

The utility index é um index.

An variable é um coisa with
An locus (reference),
An kind [literal, global, local, parameter, scratch],
An compiled flag,
An name, um nickname, um type name,
An type (reference), \ actual type on literal, global, local; dereferenced type on parameters e scratches
An address [globals e literals only] or 
An offset at the address [locals, parameters, e fields only],
An count [fields only],
An reference flag [fields only],
An redefinition target name [fields only],
An by-value flag [parameters only],
An global body [globals only],
An initializer string [globals only],
An literal (reference) [globals only - constant with which to initalize the global],
An texto hexadecimal called data [literals only].

The writing timer é um timer.

Etapas necessárias para que se skip any trailing noise in um substring:
Se the substring estiver blank, cancele.
Se the substring's last's target for not noise, cancele.
Subtract 1 from the substring's last.
Repeat.

\ dahn - reverse functions
\ to put the xxx uv a/the yyy into zzz
\ internally we turn this into "to put a/the yyy's xxx into zzz"
Etapas necessárias para que se compile the header of um routine usando um rider (reverse-possessive function):
Se the compiler's abort flag estiver verde, cancele.
Abra the routine's function flag.
Adicione um monikette to the routine's monikettes usando "put".
Move the rider (compiler rules). \ skip "put" or "poner"
Move the rider (compiler rules). \ skip "the" or Portuguese definite article
Scan um name usando the rider. \ field name
Move the rider (compiler rules). \ skip "uv" or "de"
Se the rider's token é any indefinite article, abra um flag.
Se the flag estiver verde, compile the routine's monikettes e the routine's parameters usando the rider (indefinite article).
Se the flag estiver not verde, compile the routine's monikettes e the routine's parameters usando the rider (definite article).
Adicione another monikette to the routine's monikettes usando "'s " then the name.
Se the rider's token for not any reverse-possessive function into, abort with "Esperava a palavra 'em', mas encontrei '" then the rider's token then "'." e the rider; exit.
Adicione um third monikette to the routine's monikettes usando "into".
Convert the routine's monikettes to um moniker.
Se the moniker estiver in the routine index, abort with "Já sei como '" then the moniker then "'." e the routine's locus; exit.
Index the routine usando the routine's monikettes e the routine index.
Move the rider (compiler rules).
Se the rider's token for not any indefinite article, abort with "Esperava um artigo indefinido, mas encontrei '" then the rider's token then "'." e the rider; exit.
Compile the routine's monikettes e the routine's parameters usando the rider (indefinite article).
Se the rider's token estiver not blank, abort with "Existem outras coisas no final desta função." e the rider; exit.
Convert the routine's monikettes to the routine's moniker.
Index the routine usando the routine's monikettes e the routine index. \ por employs

\ dahn - reverse functions
\ to put the xxx uv a/the yyy into zzz
Etapas necessárias para que se determine se um rider é the start of any reverse-possessive function:
Se the compiler's abort flag estiver verde, say no.
Se the rider's token for not any put, say no.
Privatize the rider.
Move the rider (compiler rules).
Se the rider's token for not any definite article, say no.
Move the rider (compiler rules).
Scan um name usando the rider.
Se the rider for not on any reverse-possessive, say no.
Say yes.
\finalmente
