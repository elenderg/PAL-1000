\ the compiler (el compilador) copyright © 2006, 2017, 2018 the osmosian order y Pablo Cayuela (SAL-1016)

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

An abort message é um string.

Etapas necessárias para que se abort with um string:
Se the compiler's abort flag estiver verde, exit.
Set the compiler's abort flag.
Put the string into the compiler's abort message.

Etapas necessárias para que se abort with um string and um pedaço endereço de memória:
Se the compiler's abort flag estiver verde, exit.
Set the compiler's abort flag.
Put the string into the compiler's abort message.
Find the compiler's abort path and the compiler's abort row# given the pedaço endereço de memória.
Se the compiler's abort path é blank, exit.
Extract um file name from the compiler's abort path.
Prepend "Erro no " then the file name then ". " to the compiler's abort message.

Etapas necessárias para que se abort with um string and um rider:
Se the rider's token é not blank, abort with the string and the rider's token's first; exit.
Abort with the string and the rider's source's last.

Etapas necessárias para que se adicione the allocate and deallocate and finalize and destroy routines:
Se the compiler's abort flag estiver verde, exit.
Get um type from the types.
Se the type é nil, exit.
Adicione the finalize routine por the type.
Adicione the allocate routine por the type.
Adicione the deallocate routine por the type.
Adicione the destroy routine por the type.
Repeat.

Etapas necessárias para que se adicione the allocate routine por um type:
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Se the type cannot be reduced to "endereço de memória", exit.
Se the type's target type é nil, exit.
Adicione um routine to the routines given nil.
Append "allocate memory por um " then the type's name to the routine's header string. \ traduzir aqui
Append "assign the " then the type's name then " given " to the routine's body string.
Append the type's target type's length then "." to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione and compile the initialize before run and run and finalize after run routine:
Se the compiler's abort flag estiver verde, exit.
Adicione um routine to the routines given nil.
Append "~initialize before run and run and finalize after run" to the routine's header string.
Append "initialize before run. " to the routine's body string.
Append the global initializers to the routine's body string.
Append "run. " to the routine's body string.
Append the global finalizers to the routine's body string.
Append "finalize after run. " to the routine's body string.
Append "call ""kernel32.dll"" ""ExitProcess"" with 0. " to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.
Compile the body of the routine.

Etapas necessárias para que se adicione the built-in types:
Adicione um built-in type given "byte" and "bytes" and 1.
Adicione another built-in type given "record" and "records" and 0.
Adicione um third built-in type given "pedaço" and "pedaços" and 1.
Adicione um fourth built-in type given "conjunto" and "conjuntos" and 0.

Etapas necessárias para que se adicione um built-in type given um name and um plural name and um length:
Adicione the built-in type to the types given the name and the plural name and the name.
Put the length into the built-in type's length.
Put the built-in type into the built-in type's base type.
Index the built-in type.

Etapas necessárias para que se adicione the deallocate routine por um type:
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Se the type cannot be reduced to "endereço de memória", exit.
Se the type's target type é nil, exit.
Adicione um routine to the routines given nil.
Append "deallocate um " then the type's name to the routine's header string.
Append "if the " then the type's name then " é nil, exit. " to the routine's body string.
Se the type's target type should be finalized, append "~finalize the " then the type's name then "'s target. " to the routine's body string.
Append "unassign the " then the type's name then "." to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the destroy routine por um type:
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Se the type should not be forgotten, exit.
Se the type can be reduced to "coisas", adicione the destroy routine por the type (coisas); exit.
Se the type can be reduced to "endereço de memória", adicione the destroy routine por the type (endereço de memória); exit.

Etapas necessárias para que se adicione the destroy routine por um type (endereço de memória):
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Put "destroy [" then the type's name then "]" into um moniker.
Se the moniker é in the routine index, exit.
Adicione um routine to the routines given nil.
Append "destroy um " then the type's name to the routine's header string.
Append "if the " then the type's name then " é nil, exit. " to the routine's body string.
Se the type's target type can be reduced to "endereço de memória", append "destroy the " then the type's name then "'s target. " to the routine's body string.
Se the type's target type can be reduced to "coisas", append "destroy the " then the type's name then "'s target. " to the routine's body string.
Loop.
Get um field from the type's target type's fields.
Se the field é nil, break.
Se the field's reference flag estiver verde, repeat.
Se the field's type should not be forgotten, repeat.
Append "destroy the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repeat.
Append "deallocate the " then the type's name then ". " to the routine's body string. \ traduzir aqui
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the destroy routine por um type (coisas):
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Put "Erro interno na hora de executar a tarefa de destruição de tipos"  into a reply.
Se the type's fields' first é nil, abort with "Erro interno - adicione um forget routine por um type (coisas)"; [Say the reply;] exit. \Adicionado Say the reply
Se the type's fields' first's type é nil, abort with "Erro interno 2 - adicione the forget routine por um type (coisas)"; exit.
Put "destroy [" then the type's name then "]" into um moniker.
Se the moniker é in the routine index, exit.
Adicione um routine to the routines given nil.
Append "destroy um " then the type's name to the routine's header string.
Append "if the " then the type's name then "'s first é nil, exit. " to the routine's body string.
Put the type's fields' first's type's name into um name.
Append "put the " then the type's name then "'s first into um " then the name then ". " to the routine's body string.
Append "remove the " then the name then " from the " then the type's name then ". " to the routine's body string.
Append "destroy the " then the name then ". " to the routine's body string.
Append "repeat. " to the routine's body string.
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione um entry to some imports given um import name and um entry name:
Find um import given the import name.
Se the import é nil, adicione the import to the imports given the import name.
Find the entry given the entry name and the import's entries.
Se the entry é not nil, exit.
Create the entry.
Append the entry to the import's entries.
Put the entry name into the entry's name.

Etapas necessárias para que se adicione um field to some fields given um name and um nickname and um type name and um reference flag:
Adicione the field to the fields given "field" and nil.
Put the name into the field's name.
Put the nickname into the field's nickname.
Put the type name into the field's type name.
Put the reference flag into the field's reference flag.

Etapas necessárias para que se adicione the finalize routine por um type:
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Se the type should not be finalized, exit.
Se the type's name é "string", adicione the finalize routine por the type (string); exit.
Se the type can be reduced to "string", exit. \ prevents generation of finalizer por derived string types
Adicione the finalize routine por the type (conjunto).

Etapas necessárias para que se adicione the finalize routine por um type (conjunto):
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Adicione um routine to the routines given nil.
Append "~finalize um " then the type's name to the routine's header string.
Append "intel $50. " to the routine's body string. \ push eax
Loop.
Get um field from the type's fields.
Se the field é nil, break.
Se the field's type should not be finalized, repeat.
Append "~finalize the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repeat.
Append "intel $58." to the routine's body string. \ pop eax
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the finalize routine por um type (string):
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Adicione um routine to the routines given nil.
Append "~finalize um " then the type's name to the routine's header string.
Append "intel $50. " to the routine's body string. \ push eax
Append "unassign the string's first. " to the routine's body string.
Append "intel $58." to the routine's body string. \ pop eax
Slap the routine's routine header on the routine's header string.
Slap the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione um fragment given um tag:
Se the current routine é nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.

Etapas necessárias para que se adicione um fragment given um tag and um entry:
Se the current routine é nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the entry into the fragment's entry.

Etapas necessárias para que se adicione um fragment given um tag and um flag:
Se the current routine é nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the flag into the fragment's flag.

Etapas necessárias para que se adicione um fragment given um tag and um routine:
Se the current routine é nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the routine into the fragment's routine.
Compile the body of the routine.

Etapas necessárias para que se adicione um fragment given um tag and um variable:
Se the current routine é nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Set the compiled flag in the variable.

Etapas necessárias para que se adicione um fragment given um tag and um variable and another variable:
Se the current routine é nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Put the other variable into the fragment's other variable.
Set the compiled flag in the variable.
Set the compiled flag in the other variable.

Etapas necessárias para que se adicione um fragment given um tag and um variable and um número:
Se the current routine é nil, void the fragment; exit.
Create the fragment given the tag.
Append the fragment to the current routine's fragments.
Put the variable into the fragment's variable.
Put the número into the fragment's número.
Set the compiled flag in the variable.

Etapas necessárias para que se adicione um import to some imports given um import name:
Create the import.
Append the import to the imports.
Put the import name into the import's name.

Etapas necessárias para que se adicione um intermediate given um type name and um locus:
Se the current routine é nil, void the intermediate; exit.
Adicione the intermediate to the current routine's locals given "local" and the locus.
Generate the intermediate's name given "~I".
Put the type name into the intermediate's type name.
Resolve the intermediate.

Etapas necessárias para que se adicione um literal to some variables given um locus:
Adicione the literal como um variable to the variables given "literal" and the locus.
Generate the literal's name given "~L".

Etapas necessárias para que se adicione um monikette to some monikettes given um expression:
Create the monikette.
Append the monikette to the monikettes.
Put the expression's phrase into the monikette's string.
Put the expression's variable into the monikette's variable.
Se the expression's variable é not nil, put the expression's type into the monikette's type.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette to some monikettes given um string:
Create the monikette.
Append the monikette to the monikettes.
\PAL
\\ conjunctions
Se the string é "e", put "and" into the monikette's string; exit. \ and
Se the string é "ou", put "or" into the monikette's string; exit. \ or
\ from/given/with/using
Se the string é "desde", put "from/given/with/using" into the monikette's string; exit.
Se the string é "a partir de", put "from/given/with/using" into the monikette's string; exit.
Se the string é "partindo de", put "from/given/with/using" into the monikette's string; exit.
Se the string é "de", put "from/given/with/using" into the monikette's string; exit.
Se the string é "dada", put "from/given/with/using" into the monikette's string; exit.
Se the string é "dado", put "from/given/with/using" into the monikette's string; exit.
Se the string é "dadas", put "from/given/with/using" into the monikette's string; exit.
Se the string é "dados", put "from/given/with/using" into the monikette's string; exit.
Se the string é "com", put "from/given/with/using" into the monikette's string; exit.
Se the string é "usando", put "from/given/with/using" into the monikette's string; exit.
\\ in/into/to
Se the string é "em", put "in/into/to" into the monikette's string; exit.
Se the string é "a", put "in/into/to" into the monikette's string; exit.
\\ is/are
Se the string é "é", put "is/are" into the monikette's string; exit.
Se the string é "está", put "is/are" into the monikette's string; exit.
Se the string é "for", put "is/are" into the monikette's string; exit. 
Se the string é "estiver", put "is/are" into the monikette's string; exit.
Se the string é "are", put "is/are" into the monikette's string; exit.
Se the string é "são", put "is/are" into the monikette's string; exit.
Se the string é "estão", put "is/are" into the monikette's string; exit.
Se the string é "is", put "is/are" into the monikette's string; exit.
Se the string é "forem", put "is/are" into the monikette's string; exit.
Se the string é "estiverem", put "is/are" into the monikette's string; exit.
\\ allocates and destroys
Se the string é "alojar", put "allocate" into the monikette's string; exit.
Se the string é "aloje", put "allocate" into the monikette's string; exit.
Se the string é "alocar", put "allocate" into the monikette's string; exit.
Se the string é "aloque", put "allocate" into the monikette's string; exit.
Se the string é "reservar", put "allocate" into the monikette's string; exit.
Se the string é "reserve", put "allocate" into the monikette's string; exit.
Se the string é "memória", put "memory" into the monikette's string; exit.
\Se the string é "for", put "por" into the monikette's string; exit. \\servia pra converter o "for" para "por"
Se the string é "pelo", put "por the" into the monikette's string; exit. 
Se the string é "pela", put "por the" into the monikette's string; exit. 
Se the string é "desalocar", put "deallocate" into the monikette's string; exit.
Se the string é "desaloque", put "deallocate" into the monikette's string; exit.
Se the string é "desalojar", put "deallocate" into the monikette's string; exit.
Se the string é "desaloje", put "deallocate" into the monikette's string; exit.
Se the string é "esvaziar", put "deallocate" into the monikette's string; exit.
Se the string é "esvazie", put "deallocate" into the monikette's string; exit.
Se the string é "destruir", put "destroy" into the monikette's string; exit.
\CAL
\\ from/given/with/using
Se the string é "from", put "from/given/with/using" into the monikette's string; exit.
Se the string é "given", put "from/given/with/using" into the monikette's string; exit.
Se the string é "with", put "from/given/with/using" into the monikette's string; exit.
Se the string é "using", put "from/given/with/using" into the monikette's string; exit.
\ in/into/to
Se the string é "in", put "in/into/to" into the monikette's string; exit.
Se the string é "into", put "in/into/to" into the monikette's string; exit.
Se the string é "to", put "in/into/to" into the monikette's string; exit.
\ is/are
Se the string é "are", put "is/are" into the monikette's string; exit.
Se the string é "is", put "is/are" into the monikette's string; exit.
\ aren't/isn't
Se the string é "isn't", put "is/aren't" into the monikette's string; exit.
Se the string é "aren't", put "is/aren't" into the monikette's string; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se the string é "backward", put "backward" into the monikette's string; exit.
Se the string é "backwards", put "backward" into the monikette's string; exit.
Se the string é "counterclockwise", put "backward" into the monikette's string; exit.
Se the string é "counter-clockwise", put "backward" into the monikette's string; exit.
Se the string é "anticlockwise", put "backward" into the monikette's string; exit.
Se the string é "anti-clockwise", put "backward" into the monikette's string; exit.
\ at/on
Se the string é "at", put "at/on" into the monikette's string; exit.
Se the string é "on", put "at/on" into the monikette's string; exit.
\ other
Put the string into the monikette's string.

Etapas necessárias para que se adicione um monikette to some monikettes given um type:
Create the monikette.
Append the monikette to the monikettes. 
Put the type into the monikette's type.

Etapas necessárias para que se adicione push fragments given some monikettes:
Se the current routine é nil, exit.
Loop.
Get um monikette from the monikettes (backwards).
Se the monikette é nil, exit.
Se the monikette's variable é nil, repeat.
Se the monikette's current substring é not blank, repeat.
Se the monikette's current type é nil, repeat.
Adicione um fragment given the push address tag and the monikette's variable.
Repeat.

Etapas necessárias para que se adicione the put or convert fragments given um variable and another variable and um locus:
Adicione um fragment given the push address tag and the other variable.
Adicione another fragment given the push address tag and the variable.
Find um routine given "put" and the variable's type and "into" and the other variable's type.
Se the routine é nil, find the routine given "convert" and the variable's type and "to" and the other variable's type.
Se the routine é not nil, adicione um third fragment given the call internal tag and the routine; exit.
\ error message
Adicione um monikette to some monikettes given "put/convert".
Adicione another monikette to the monikettes given the variable's type.
Adicione um third monikette to the monikettes given "into/to".
Adicione um fourth monikette to the monikettes given the other variable's type.
Convert the monikettes to um moniker.
Destroy the monikettes.
Abort with "Eu não sei como '" then the moniker then "'." and the locus.

Etapas necessárias para que se adicione um routine to some routines given um locus:
Create the routine.
Append the routine to the routines.
Put the locus into the routine's locus.

Etapas necessárias para que se adicione um scratch given um type name and um locus:
Se the current routine é nil, void the scratch; exit.
Adicione the scratch to the current routine's locals given "scratch" and the locus.
Generate the scratch's name given "~S".
Put the type name into the scratch's type name.
Resolve the scratch.

Etapas necessárias para que se adicione several fragments given um string and um variable and another string and another variable and um locus:
Adicione um fragment given the push address tag and the other variable.
Adicione another fragment given the push address tag and the variable.
Adicione um monikette to some monikettes given the string.
Adicione another monikette to the monikettes given the variable's type.
Adicione um third monikette to the monikettes given the other string.
Adicione um fourth monikette to the monikettes given the other variable's type.
Find um routine given the monikettes.
Se the routine é nil, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine é nil, abort with "Eu não sei como '" then the moniker then "'." and the locus; exit.
Adicione um third fragment given the call internal tag and the routine.

Etapas necessárias para que se adicione several fragments given um string and um variable and another string and another variable and um third string and um third variable and um pedaço endereço de memória:
Adicione um fragment given the push address tag and the third variable.
Adicione another fragment given the push address tag and the other variable.
Adicione um third fragment given the push address tag and the variable.
Adicione um monikette to some monikettes given the string.
Adicione another monikette to the monikettes given the variable's type.
Adicione um third monikette to the monikettes given the other string.
Adicione um fourth monikette to the monikettes given the other variable's type.
Adicione um fifth monikette to the monikettes given the third string.
Adicione um sixth monikette to the monikettes given the third variable's type.
Find um routine given the monikettes.
Se the routine é nil, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine é nil, abort with "Eu não sei como '" then the moniker then "'." and the pedaço endereço de memória; exit.
Adicione um fourth fragment given the call internal tag and the routine.

Etapas necessárias para que se adicione um source file to some source files given um path:
Create the source file.
Append the source file to the source files.
Put the path into the source file's path.

Etapas necessárias para que se adicione two fragments given um string and um variable and um locus:
Adicione um fragment given the push address tag and the variable.
Adicione um monikette to some monikettes given the string.
Adicione another monikette to the monikettes given the variable's type.
Find um routine given the monikettes.
Se the routine é nil, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine é nil, abort with "Eu não sei como '" then the moniker then "'." and the locus; exit.
Adicione another fragment given the call internal tag and the routine.

Etapas necessárias para que se adicione um type to some types given um locus:
Create the type.
Append the type to the types.
Put the locus into the type's locus.

Etapas necessárias para que se adicione um type to some types given um name and um plural name and um base name:
Adicione the type to the types given the name and the plural name and the base name and nil.

Etapas necessárias para que se adicione um type to some types given um name and um plural name and um base name and um locus:
Create the type.
Append the type to the types.
Put the locus into the type's locus.
Put the name into the type's name.
Put the plural name into the type's plural name.
Put the base name into the type's base name.

Etapas necessárias para que se adicione um variable to some variables given um kind and um locus:
Create the variable given the kind.
Append the variable to the variables.
Put the locus into the variable's locus.

The adding built-in memory routines timer é um timer.

The adding built-in startup routine timer é um timer.

Etapas necessárias para que se address some entries:
Get um entry from the entries.
Se the entry é nil, exit.
Address the entry.
Repeat.

Etapas necessárias para que se address um entry:
Put the current name address into the entry's name address.
Put the entry's name's length plus 3 into um número.
Round the número up to the nearest multiple of 2.
Adicione the número to the current name address.
Put the current thunk address into the entry's thunk address.
Put the image base plus the current thunk address into the entry's address.
Adicione 4 to the current thunk address.

Etapas necessárias para que se address um fragment given um address:
Se the compiler's abort flag estiver verde, exit.
Se the fragment é nil, exit.
Put the image base plus the address into the fragment's address.
Se the fragment's tag é the push address tag, adicione 7 to the address; exit.
Se the fragment's tag é the call internal tag, adicione 5 to the address; exit.
Se the fragment's tag é the load address tag, adicione 12 to the address; exit.
Se the fragment's tag é the increment tag, adicione 10 to the address; exit.
Se the fragment's tag é the dereference tag, adicione 14 to the address; exit.
Se the fragment's tag é the jump false tag, adicione 9 to the address; exit.
Se the fragment's tag é the not tag, adicione 3 to the address; exit.
Se the fragment's tag é the exit tag, adicione 5 to the address; exit.
Se the fragment's tag é the repeat tag, adicione 5 to the address; exit.
Se the fragment's tag é the break tag, adicione 5 to the address; exit.
Se the fragment's tag é the prolog tag, address the fragment given the address (prolog); exit.
Se the fragment's tag é the epilog tag, address the fragment given the address (epilog); exit.
Se the fragment's tag é the intel tag, adicione the fragment's code's length to the address; exit.
Se the fragment's tag é the push value tag, address the fragment given the address (push value); exit.
Se the fragment's tag é the call external tag, adicione 6 to the address; exit.
Se the fragment's tag é the load eax tag, adicione 5 to the address; exit. \ was 8 when "load eax" took in variables; now "load eax" only does um immediate value
Se the fragment's tag é the save eax tag, address the fragment given the address (save eax); exit.
Se the fragment's tag é the call indirect tag, adicione 8 to the address; exit.
Se the fragment's tag é the routine address tag, adicione 12 to the address; exit.

Etapas necessárias para que se address um fragment given um address (epilog):
Se the current routine's callback flag estiver verde, adicione 3 to the address.
Adicione 6 to the address.

Etapas necessárias para que se address um fragment given um address (prolog):
Adicione 3 to the address.
Se the current routine's local size é not 0, adicione 10 to the address.
Se the current routine's callback flag estiver verde, adicione 3 to the address.

Etapas necessárias para que se address um fragment given um address (push value):
Adicione 6 to the address.
Se the fragment's variable é nil, abort with "Erro interno - address um fragment given um address (push value)"; exit.
Se the fragment's variable's type é nil, abort with "Erro interno 2 - address um fragment given um address (push value)"; exit.
Put the fragment's variable's type's length into um length.
Se the length é 4, adicione 2 to the address; exit.
Se the length é 2, adicione 3 to the address; exit.
Se the length é 1, adicione 4 to the address; exit.
Abort with "Erro interno 3 - address um fragment given um address (push value)".

Etapas necessárias para que se address um fragment given um address (save eax):
Adicione 6 to the address.
Se the fragment's variable é nil, abort with "Erro interno - address um fragment given um address (push value)"; exit.
Se the fragment's variable's type é nil, abort with "Erro interno 2 - address um fragment given um address (push value)"; exit.
Put the fragment's variable's type's length into um length.
Se the length é 4, adicione 2 to the address; exit.
Se the length é 2, adicione 3 to the address; exit.
Se the length é 1, adicione 2 to the address; exit.
Abort with "Erro interno 3 - address um fragment given um address (push value)".

Etapas necessárias para que se address some fragments given um address:
Se the compiler's abort flag estiver verde, exit.
Get um fragment from the fragments.
Se the fragment é nil, exit.
Address the fragment given the address.
Repeat.

Etapas necessárias para que se address um import:
Put the current name address into the import's name address.
Put the current header address into the import's header address.
Put the current name address into the import's import header's name memory address.
Put the import's name's length plus 1 into um número.
Round the número up to the nearest multiple of 2.
Adicione the número to the current name address.
Adicione um import header's magnitude to the current header address.
Put the current thunk address into the import's import header's first thunk memory address.
Address the import's entries.
Adicione 4 to the current thunk address.

Etapas necessárias para que se address some imports given um address:
Put the address into the current header address.
Put the imports' count into um count.
Adicione 1 to the count.
Multiply the count by um import header's magnitude.
Put the address plus the count into the current thunk address.
Get another count given the imports (all entries plus markers).
Multiply the other count by 4.
Put the current thunk address plus the other count into the current name address.
Loop.
Get um import from the imports.
Se the import é nil, break.
Address the import.
Repeat.
Put the current name address minus the address into um número.
Adicione the número to the address.

An address é um número.

Etapas necessárias para que se address um routine given um address:
Se the compiler's abort flag estiver verde, exit.
Se the routine é nil, exit.
Se the routine's employs moniker é not blank, exit. \ employs are addressed later
Se the routine's compiled flag estiver not verde, exit.
Put the routine into the current routine.
Put the image base plus the address into the routine's address.
Address the routine's fragments given the address.
Round the address up to the nearest multiple of 4.

Etapas necessárias para que se address some routines given um address:
Se the compiler's abort flag estiver verde, exit.
Get um routine from the routines.
Se the routine é nil, break.
Address the routine given the address.
Repeat.

Etapas necessárias para que se address um variable given um address:
Se the compiler's abort flag estiver verde, exit.
Se the variable é nil, exit.
Se the variable's compiled flag estiver not verde, exit.
Put the image base plus the address into the variable's address.
Adicione the variable's type's length to the address.
Se the variable's type can be reduced to "string", adicione the variable's data's length plus 1 to the address.
Round the address up to the nearest multiple of 4.

Etapas necessárias para que se address some variables given um address:
Se the compiler's abort flag estiver verde, exit.
Get um variable from the variables.
Se the variable é nil, exit.
Address the variable given the address.
Repeat.

The addressing timer é um timer.

Etapas necessárias para que se advance um buffer:
Append the return pedaço to the buffer.
Append the linefeed pedaço to the buffer.

Etapas necessárias para que se advance um buffer (twice):
Advance the buffer. 
Advance the buffer.

Etapas necessárias para que se append um entry to um buffer (with separator):
Se the entry é nil, append "" to the buffer (with separator); exit.
Append the entry's name to the buffer (with separator).

Etapas necessárias para que se append um flag to um buffer (with separator):
Convert the flag to um string.
Append the string to the buffer (with separator).

Etapas necessárias para que se append the global finalizers to um string:
Get um global from the globals.
Se the global é nil, exit.
Se the global's compiled flag estiver not verde, repeat.
Se the global's type should not be finalized, repeat.
Append "~finalize the " then the global's name then ". " to the string.
Repeat.

Etapas necessárias para que se append the global initializers to um string:
Get um global from the globals.
Se the global é nil, exit.
Se the global's literal é nil, repeat.
Se the global's compiled flag estiver not verde, repeat.
Clear um flag.
Append the global's initializer string to the string.
Repeat.

Etapas necessárias para que se append um monikette to um moniker:
Se the monikette é nil, exit.
Se the moniker é not blank, append the space pedaço to the moniker.
Se the monikette's type é not nil, append "[" and the monikette's type's name and "]" to the moniker (fast); exit.
Se the monikette's string é not blank, append the monikette's string to the moniker; exit.

Etapas necessárias para que se append um monikette to um moniker (while bubbling):
Se the monikette é nil, exit.
Se the moniker é not blank, append the space pedaço to the moniker.
Se the monikette's current substring é not blank, append the monikette's current substring to the moniker; exit.
Se the monikette's current type é not nil, append "[" and the monikette's current type's name and "]" to the moniker (fast); exit.

Etapas necessárias para que se append um número to um buffer (as hex with separator):
Convert the número to um nibble string.
Append the nibble string to the buffer (with separator).

Etapas necessárias para que se append um número to um buffer (with separator):
Convert the número to um string.
Append the string to the buffer (with separator).

Etapas necessárias para que se append um ratio to um buffer (with separator):
Convert the ratio to um string.
Append the string to the buffer (with separator).

Etapas necessárias para que se append um routine to um buffer (with separator):
Se the routine é nil, append "" to the buffer (with separator); exit.
Append the routine's moniker to the buffer (with separator).

Etapas necessárias para que se append um string and another string and um third string to um fourth string (fast):
Put the fourth string's length into um length.
Adicione the string's length to the length.
Adicione the other string's length to the length.
Adicione the third string's length to the length.
Reassign um endereço de memória given the length.
Put the endereço de memória into um pedaço endereço de memória.
Copy pedaços from the fourth string's first to the pedaço endereço de memória por the fourth string's length.
Adicione the fourth string's length to the pedaço endereço de memória.
Copy pedaços from the string's first to the pedaço endereço de memória por the string's length.
Adicione the string's length to the pedaço endereço de memória.
Copy pedaços from the other string's first to the pedaço endereço de memória por the other string's length.
Adicione the other string's length to the pedaço endereço de memória.
Copy pedaços from the third string's first to the pedaço endereço de memória por the third string's length.
Unassign the fourth string's first.
Put the endereço de memória into the fourth string's first.
Put the endereço de memória plus the length minus 1 into the fourth string's last.

Etapas necessárias para que se append um string to um buffer (with separator):
Append the string to the buffer.
Append "/" to the buffer.

Etapas necessárias para que se append um tag to um buffer (as um fragment tag string with separator):
Se the tag é the break tag, append "break" to the buffer (with separator); exit.
Se the tag é the call external tag, append "call external" to the buffer (with separator); exit.
Se the tag é the call indirect tag, append "call indirect" to the buffer (with separator); exit.
Se the tag é the call internal tag, append "call internal" to the buffer (with separator); exit.
Se the tag é the dereference tag, append "dereference" to the buffer (with separator); exit.
Se the tag é the end if tag, append "end if" to the buffer (with separator); exit.
Se the tag é the epilog tag, append "epilog" to the buffer (with separator); exit.
Se the tag é the exit tag, append "exit" to the buffer (with separator); exit.
Se the tag é the finalize tag, append "finalize" to the buffer (with separator); exit.
Se the tag é the increment tag, append "increment" to the buffer (with separator); exit.
Se the tag é the intel tag, append "intel" to the buffer (with separator); exit.
Se the tag é the jump false tag, append "jump false" to the buffer (with separator); exit.
Se the tag é the load address tag, append "load address" to the buffer (with separator); exit.
Se the tag é the load eax tag, append "load eax" to the buffer (with separator); exit.
Se the tag é the loop tag, append "loop" to the buffer (with separator); exit.
Se the tag é the not tag, append "not" to the buffer (with separator); exit.
Se the tag é the prolog tag, append "prolog" to the buffer (with separator); exit.
Se the tag é the push address tag, append "push address" to the buffer (with separator); exit.
Se the tag é the push value tag, append "push value" to the buffer (with separator); exit.
Se the tag é the save eax tag, append "save eax" to the buffer (with separator); exit.
Se the tag é the repeat tag, append "repeat" to the buffer (with separator); exit.
Se the tag é the routine address tag, append "routine address" to the buffer (with separator); exit.
Append "?" to the buffer (with separator).

Etapas necessárias para que se append um type to um buffer (with separator):
Se the type é nil, append "" to the buffer (with separator); exit.
Append the type's name to the buffer (with separator).

Etapas necessárias para que se append um variable to um buffer (with separator):
Se the variable é nil, append "" to the buffer (with separator); exit.
Append the variable's name to the buffer (with separator).

Etapas necessárias para que se append um string to another string giving um third string (portuguese contractions and synonyms rules):
\# contrações
Se the string é "ao", append "para o" to the other string; exit.
Se the string é "à", append "para a" to the other string; exit.
Se the string é "aos", append "para os" to the other string; exit.
Se the string é "às", append "para as" to the other string; exit.
Se the string é "do", append "de o" to the other string; exit.
Se the string é "da", append "de a" to the other string; exit.
Se the string é "dos", append "de os" to the other string; exit.
Se the string é "das", append "de as" to the other string; exit.
Se the string é "dum", append "de um" to the other string; exit.
Se the string é "duma", append "de uma" to the other string; exit.
Se the string é "dumas", append "de umas" to the other string; exit.
Se the string é "duns", append "de uns" to the other string; exit.
Se the string é "daqui", append "de aqui" to the other string; exit.
Se the string é "dali", append "de ali" to the other string; exit.
Se the string é "dele", append "de ele" to the other string; exit.
Se the string é "dela", append "de ela" to the other string; exit.
Se the string é "desse", append "de esse" to the other string; exit.
Se the string é "dessa", append "de essa" to the other string; exit.
Se the string é "desses", append "de esses" to the other string; exit.
Se the string é "dessas", append "de essas" to the other string; exit.
Se the string é "deste", append "de este" to the other string; exit.
Se the string é "desta", append "de esta" to the other string; exit.
Se the string é "destes", append "de estes" to the other string; exit.
Se the string é "destas", append "de estas" to the other string; exit.
Se the string é "disso", append "de isso" to the other string; exit.
Se the string é "disto", append "de isto" to the other string; exit.
Se the string é "nesse", append "em esse" to the other string; exit.
Se the string é "nesses", append "em esses" to the other string; exit.
Se the string é "neste", append "em este" to the other string; exit.
Se the string é "nestes", append "em estes" to the other string; exit.
Se the string é "nisso", append "em isso" to the other string; exit.
Se the string é "nisto", append "em isto" to the other string; exit.
Se the string é "nessa", append "em essa" to the other string; exit.
Se the string é "nessas", append "em essas" to the other string; exit.
Se the string é "nesta", append "em esta" to the other string; exit.
Se the string é "nestas", append "em estas" to the other string; exit.
Se the string é "donde", append "de onde" to the other string; exit.
Se the string é "dentre", append "de entre" to the other string; exit.
Se the string é "dantes", append "de antes" to the other string; exit.
Se the string é "dalguém", append "de alguém" to the other string; exit.
Se the string é "dalgum", append "de algum" to the other string; exit.
Se the string é "dalguma", append "de alguma" to the other string; exit.
Se the string é "dalguns", append "de alguns" to the other string; exit.
Se the string é "dalgumas", append "de algumas" to the other string; exit.
Se the string é "nalgum", append "em algum" to the other string; exit.
Se the string é "nalguma", append "em alguma" to the other string; exit.
Se the string é "nalguns", append "em alguns" to the other string; exit.
Se the string é "nalgumas", append "em algumas" to the other string; exit.
Se the string é "doutro", append "de outro" to the other string; exit.
Se the string é "doutra", append "de outra" to the other string; exit.
Se the string é "doutros", append "de outros" to the other string; exit.
Se the string é "doutras", append "de outras" to the other string; exit.
Se the string é "noutro", append "em outro" to the other string; exit.
Se the string é "noutra", append "em outra" to the other string; exit.
Se the string é "noutros", append "em outros" to the other string; exit.
Se the string é "noutras", append "em outras" to the other string; exit.
\# "no" pode ser uma negação em inglês.
Se the string é any contraction giving the third string (portuguese rules - "no"), append "em o" to the other string; exit.
Se the string é "na", append "em a" to the other string; exit.
Se the string é "nos", append "em os" to the other string; exit.
Se the string é "nas", append "em as" to the other string; exit.
\Se the string é "noutro", append "em outro" to the other string; exit.
\Se the string é "noutra", append "em outra" to the other string; exit.
\Se the string é "noutros", append "em outros" to the other string; exit.
\Se the string é "noutras", append "em outras" to the other string; exit.
Se the string é "num", append "em um" to the other string; exit.
Se the string é "numa", append "em uma" to the other string; exit.
Se the string é "nuns", append "em uns" to the other string; exit.
Se the string é "numas", append "em umas" to the other string; exit.
Se the string é "pelo", append "por o" to the other string; exit.
Se the string é "pela", append "por a" to the other string; exit.
Se the string é "pelos", append "por os" to the other string; exit.
Se the string é "pelas", append "por as" to the other string; exit.
\# sinônimos
Se the string é "adir", append "adicionar" to the other string; exit.
Se the string é "agregar", append "adicionar" to the other string; exit.
Se the string é "acrescentar", append "adicionar" to the other string; exit.
Se the string é "somar", append "adicionar" to the other string; exit.
Se the string é "começar", append "iniciar" to the other string; exit.
Se the string é "terminar", append "finalizar" to the other string; exit.
Se the string é "acabar", append "finalizar" to the other string; exit.
Se the string é "completar", append "finalizar" to the other string; exit.
Se the string é "colocar", append "pôr" to the other string; exit.
Se the string é "mudar", append "alterar" to the other string; exit.
Se the string é "limpar", append "apagar" to the other string; exit.
Se the string é "ampliar", append "aumentar" to the other string; exit.
Se the string é "expandir", append "aumentar" to the other string; exit.
Se the string é "alargar", append "aumentar" to the other string; exit.
Se the string é "dilatar", append "aumentar" to the other string; exit.
Se the string é "estender", append "aumentar" to the other string; exit.
Se the string é "prolongar", append "aumentar" to the other string; exit.
Se the string é "ampliar", append "aumentar" to the other string; exit.
Se the string é "achar", append "encontrar" to the other string; exit.
Se the string é "descobrir", append "encontrar" to the other string; exit.
Se the string é "buscar", append "encontrar" to the other string; exit.
Se the string é "manusear", append "manejar" to the other string; exit.
Se the string é "manipular", append "manejar" to the other string; exit.
Se the string é "enumerar", append "listar" to the other string; exit.
Se the string é "elencar", append "listar" to the other string; exit.
Se the string é "selecionar", append "escolher" to the other string; exit.
Se the string é "eliminar", append "remover" to the other string; exit.
Se the string é "excluir", append "remover" to the other string; exit.
Se the string é "retirar", append "remover" to the other string; exit.
Se the string é "rodar", append "girar" to the other string; exit.
Se the string é "começar", append "iniciar" to the other string; exit.
Se the string é "permutar", append "trocar" to the other string; exit.
Se the string é "esperar", append "aguardar" to the other string; exit.
Se the string é "rascunhar", append "esboçar" to the other string; exit.
Se the string é "antepor", append "prepor" to the other string; exit.
Append the string to the other string.

Etapas necessárias para que se attach address loading code to um texto hexadecimal given um variable: \ loads into edx
Se the variable é nil, attach $C7C200000000 to the texto hexadecimal; exit. \ mov edx,0
Se the variable's kind é "global", attach $C7C2 and the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
Se the variable's kind é "literal", attach $C7C2 and the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
Se the variable's kind é "local", attach $8D95 and the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Se the variable's kind é "scratch", attach $8B95 and the variable's offset to the texto hexadecimal; exit. \ mov edx,[ebp+the variable's offset]
Se the variable's kind é not "parameter", abort with "Erro interno - attach address loading code to um texto hexadecimal given um variable"; exit.
Se the variable's by-value flag estiver verde, attach $8D95 and the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Attach $8B95 and the variable's offset to the texto hexadecimal. \ mov edx,[ebp+the variable's offset]

Etapas necessárias para que se attach um texto hexadecimal and um address to um fragment: \ call or jump
Put the address into um número.
Subtract the fragment's address from the número.
Subtract the fragment's code's length from the número.
Subtract the texto hexadecimal's length from the número.
Subtract 4 from the número.
Attach the texto hexadecimal and the número to the fragment's code.

Etapas necessárias para que se attach um texto hexadecimal and um número and another texto hexadecimal to um third texto hexadecimal:
Append the texto hexadecimal to the third texto hexadecimal.
Convert the número to um fourth texto hexadecimal.
Append the fourth texto hexadecimal to the third texto hexadecimal.
Append the other texto hexadecimal to the third texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal and um número and another número to another texto hexadecimal:
Append the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Append the third texto hexadecimal to the other texto hexadecimal.
Convert the other número to um fourth texto hexadecimal.
Append the fourth texto hexadecimal to the other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal and um flag to another texto hexadecimal;
Etapas necessárias para que se attach um texto hexadecimal and um número to another texto hexadecimal:
Append the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Append the third texto hexadecimal to the other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal to another texto hexadecimal: employ append um string to another string.

Etapas necessárias para que se blurt pedaços given um endereço de memória and um length and um buffer and um offset:
Put the buffer's first plus the offset into another endereço de memória.
Copy pedaços from the endereço de memória to the other endereço de memória por the length.

Etapas necessárias para que se blurt um dos header into um buffer:
Blurt pedaços given the dos header's whereabouts and the dos header's magnitude and the buffer and 0.

Etapas necessárias para que se blurt some entries into um buffer:
Get um entry from the entries.
Se the entry é nil, exit.
Blurt the entry into the buffer.
Repeat.

Etapas necessárias para que se blurt um entry into um buffer:
Blurt pedaços given the entry's name address's whereabouts and 4 and the buffer and the entry's thunk address.
Put the entry's name address plus 2 into um address.
Blurt the entry's name into the buffer at the address.

Etapas necessárias para que se blurt um fragment into um buffer:
Se the fragment's code é blank, exit.
Put the fragment's address minus the image base into um address.
Blurt the fragment's code into the buffer at the address.

Etapas necessárias para que se blurt some fragments into um buffer:
Get um fragment from the fragments.
Se the fragment é nil, exit.
Blurt the fragment into the buffer.
Repeat.

Etapas necessárias para que se blurt um import into um buffer:
Blurt pedaços given the import's import header's whereabouts and the import's import header's magnitude and the buffer and the import's header address.
Blurt the import's name into the buffer at the import's name address.
Blurt the import's entries into the buffer.

Etapas necessárias para que se blurt some imports into um buffer:
Get um import from the imports.
Se the import é nil, exit.
Blurt the import into the buffer.
Repeat.

Etapas necessárias para que se blurt um pe header into um buffer:
Blurt pedaços given the pe header's whereabouts and the pe header's magnitude and the buffer and 256.

Etapas necessárias para que se blurt um routine into um buffer:
Se the routine's compiled flag estiver not verde, exit.
Blurt the routine's fragments into the buffer.

Etapas necessárias para que se blurt some routines into um buffer:
Get um routine from the routines.
Se the routine é nil, exit.
Blurt the routine into the buffer.
Repeat.

Etapas necessárias para que se blurt um string into um buffer at um address:
Blurt pedaços given the string's first and the string's length and the buffer and the address.

Etapas necessárias para que se blurt um variable into um buffer:
Se the variable's compiled flag estiver not verde, exit.
Se the variable's type can be reduced to "string", blurt the variable into the buffer (as um string); exit.
Put the variable's address minus the image base into um address.
Blurt the variable's data into the buffer at the address.

Etapas necessárias para que se blurt um variable into um buffer (as um string):
Put the variable's address minus the image base into um address.
Put the variable's data's length into um length.
Put the address into another address.
Adicione um prototype string's magnitude to the other address.
Adicione the image base to the other address.
Put 0 into the prototype string's first.
Put -1 into the prototype string's last.
Se the length é not 0, put the other address into the prototype string's first.
Se the length é not 0, put the prototype string's first plus the length minus 1 into the prototype string's last.
Blurt pedaços given the prototype string's whereabouts and the prototype string's magnitude and the buffer and the address.
Adicione the prototype string's magnitude to the address.
Blurt the variable's data into the buffer at the address.

Etapas necessárias para que se blurt some variables into um buffer:
Get um variable from the variables.
Se the variable é nil, exit.
Blurt the variable into the buffer.
Repeat.

An borough é um conjunto with um base address, um length and um size.

The break tag é um tag equal to 1.

Etapas necessárias para que se bubble um monikette:
Se the monikette é nil, exit.
Se the monikette's current substring é not blank, clear the monikette's current substring; exit.
Se the monikette's current type é nil, exit.
Se the monikette's current type é any built-in type, put nil into the monikette's current type; exit.
Put the monikette's current type's base type into the monikette's current type.

An built-in type é um type.

Etapas necessárias para que se calculate the length of um type:
Se the type é nil, exit.
Se the type's length é not -1, exit.
Calculate the length of the type's base type.
Se the type's fields are empty, put the type's base type's length into the type's length; exit.
Put 0 into the type's length.
Loop.
Se the compiler's abort flag estiver verde, exit.
Get um field from the type's fields.
Se the field é nil, exit.
Se the field's redefinition target name é not blank, repeat.
Calculate the length of the field's type.
Adicione the field's type's length times the field's count to the type's length.
Repeat.

Etapas necessárias para que se calculate the lengths of some types:
Se the compiler's abort flag estiver verde, exit.
Get um type from the types.
Se the type é nil, exit.
Calculate the length of the type.
Repeat.

Etapas necessárias para que se calculate the offsets in um type:
Se the type é nil, exit.
Put 0 into um offset.
Loop.
Se the compiler's abort flag estiver verde, exit.
Get um field from the type's fields.
Se the field é nil, exit.
Se the field's redefinition target name é not blank, repeat.
Put the offset into the field's offset.
Adicione the field's type's length times the field's count to the offset.
Repeat.

Etapas necessárias para que se calculate the offsets in some types:
Se the compiler's abort flag estiver verde, exit.
Get um type from the types.
Se the type é nil, exit.
Calculate the offsets in the type.
Repeat.

Etapas necessárias para que se calculate the redefinition offsets in um type:
Se the type é nil, exit.
Loop.
Se the compiler's abort flag estiver verde, exit.
Get um field from the type's fields.
Se the field é nil, exit.
Se the field's redefinition target name é blank, repeat.
Find another field given the field's redefinition target name and the type's fields.
Se the other field é nil, abort with "Redefine inválido. Eu não consigo encontrar o campo '" then the field's redefinition target name then "' field." and the field's locus; exit.
Put the other field's offset into the field's offset.
Repeat.

Etapas necessárias para que se calculate the redefinition offsets in some types:
Se the compiler's abort flag estiver verde, exit.
Get um type from the types.
Se the type é nil, exit.
Calculate the redefinition offsets in the type.
Repeat.

The calculating timer é um timer.

The call external tag é um tag equal to 2.

The call indirect tag é um tag equal to 3.

The call internal tag é um tag equal to 4.

Etapas necessárias para que se check por invalid optional info on um type:
Se the compiler's abort flag estiver verde, exit.
Se the type é nil, exit.
Se the type's target name é not blank, check por invalid optional info on the type (target).
Se the type's fields are not empty, check por invalid optional info on the type (fields).
Se the type's scale é not 0, check por invalid optional info on the type (scale).

Etapas necessárias para que se check por invalid optional info on um type (fields):
Se the compiler's abort flag estiver verde, exit.
Se the type cannot be reduced to "conjunto", abort with "A palavra 'with' só é permitida em conjunto types." and the type's locus; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info on um type (scale):
Se the compiler's abort flag estiver verde, exit.
Se the type cannot be reduced to "número", abort with "Escalas são permitidas apenas em tipos numéricos." and the type's locus; exit.

Etapas necessárias para que se check por invalid optional info on um type (target):
Se the compiler's abort flag estiver verde, exit.
Se the type cannot be reduced to "endereço de memória", abort with "An palavra 'to' só é permitida em endereço de memória types." and the type's locus; exit.

Etapas necessárias para que se clear um field term:
Fill pedaços with the null pedaço starting at the field term's whereabouts por the field term's magnitude.

Etapas necessárias para que se clear um term:
Void the term's variable.
Clear the term's phrase.

The code borough é um borough.

Etapas necessárias para que se compile the bodies of the routines:
Compile the body of the routine called "initialize before run".
Compile the body of the routine called "execute nosso programa".
Compile the body of the routine called "finalize after run".

Etapas necessárias para que se compile the body of um routine:
Se the routine é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Se the routine's compiled flag estiver verde, exit.
Set the routine's compiled flag.
Slap um rider on the routine's routine body.
Move the rider (compiler rules).
Se the rider's token é the semi-colon pedaço, compile the body of the routine given the rider (alternate wording); exit. \ *** alternate wording
Se the rider's token é any employ, compile the body of the routine given the rider (employ); exit.
Put the current routine into um saved routine.
Put the routine into the current routine.
Create the routine's nickname index given 101.
Eliminate duplicate nicknames from the routine's parameters given the routine's nickname index.
Compile the body of the routine (prolog).
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, break.
Compile the next statement given the rider.
Repeat.
Compile the body of the routine (epilog).
Put the saved routine into the current routine.

Etapas necessárias para que se compile the body of um routine (epilog):
Se the routine é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Adicione um fragment given the finalize tag.
Loop.
Get um variable from the routine's locals.
Se the variable é nil, break.
Se the variable's kind é "scratch", repeat.
Se the variable's type should not be finalized, repeat.
Adicione another fragment given the push address tag and the variable.
Find another routine given "~finalize" and the variable's type.
Se the other routine é nil, abort with "Erro interno - compile the body of um routine (epilog)"; exit.
Adicione um third fragment given the call internal tag and the other routine.
Repeat.
Adicione um fourth fragment given the epilog tag.

Etapas necessárias para que se compile the body of um routine (prolog):
Se the routine é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Adicione um fragment given the prolog tag.
Adicione another fragment given the loop tag.

Etapas necessárias para que se compile the body of the routine called um string:
Se the compiler's abort flag estiver verde, exit.
Find um routine given the string and the routine index.
Se the routine é nil, abort with "Eu preciso de uma função para fazer '" then the string then "'."; exit.
Compile the body of the routine.

Etapas necessárias para que se compile the body of um routine given um rider (alternate wording): \ *** alternate wording
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules). \ *** do we need this?
Put the routine's next into um target routine.
Se the target routine é nil, abort with "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." and the rider; exit.
Put the target routine's moniker into the routine's employs moniker.
Compile the body of the target routine.

Etapas necessárias para que se compile the body of um routine given um rider (employ):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Compile um routine reference given the rider.
Convert the routine reference to the routine's employs moniker.
Destroy the routine reference.
Se the rider's token é not ".", abort with "Employ statments devem terminar com um ponto, não com '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Se the rider's token é not blank, abort with "Somente um employ" and the rider; exit.
Find another routine given the routine's employs moniker and the routine index.
Se the other routine é nil, abort with "Não consigo encontrar um rotina '" then the routine's employs moniker then "' que você está tentando empregar." and the routine's locus; exit.
Compile the body of the other routine.

Etapas necessárias para que se compile the call'd part given um rider and um variable:
Se the compiler's abort flag estiver verde, exit.
Se the variable é nil, exit.
Put the variable's name into the variable's type name.
Move the rider (compiler rules).
Scan the variable's name given the rider.

Etapas necessárias para que se compile um directory:
Compile the directory (start).
Compile the directory (load the source files).
Compile the directory (scan the source files).
Compile the directory (resolve the types).
Compile the directory (resolve the globals).
Compile the directory (compile the headers of the routines).
Compile the directory (calculate lengths and offsets of types).
Compile the directory (Adicione the built-in memory routines).
Compile the directory (index the routines por utility use).
Compile the directory (compile the bodies of the routines).
Compile the directory (Adicione and compile the built-in startup routine).
Compile the directory (offset parameters and variables).
Compile the directory (address).
Compile the directory (transmogrify).
Compile the directory (link).
Compile the directory (write the exe).
Compile the directory (stop).

Etapas necessárias para que se compile um directory (Adicione and compile the built-in startup routine):
Se the compiler's abort flag estiver verde, exit.
Show status "Adicionando e agrupando um tarefa de inicialização padrão...".
Start the adding built-in startup routine timer.
Adicione and compile the initialize before run and run and finalize after run routine.
Stop the adding built-in startup routine timer.

Etapas necessárias para que se compile um directory (Adicione the built-in memory routines):
Se the compiler's abort flag estiver verde, exit.
Show status "Adicionando como tarefas predefinidas na memória...".
Start the adding built-in memory routines timer.
Adicione the allocate and deallocate and finalize and destroy routines.
Stop the adding built-in memory routines timer.

Etapas necessárias para que se compile um directory (address):
Se the compiler's abort flag estiver verde, exit.
Show status "Obtendo endereço dos itens...".
Start the addressing timer.
Put 4096 into um address.
Put the address into the import borough's base.
Address the imports given the address.
Put the address minus the import borough's base into the import borough's length.
Round the address up to the nearest multiple of 4096.
Put the address into the data borough's base.
Address the globals given the address.
Address the literals given the address.
Put the address minus the data borough's base into the data borough's length.
Round the address up to the nearest multiple of 4096.
Put the address into the code borough's base.
Address the routines given the address.
Put the address minus the code borough's base into the code borough's length.
Stop the addressing timer.

Etapas necessárias para que se compile um directory (calculate lengths and offsets of types):
Se the compiler's abort flag estiver verde, exit.
Show status "Calculando tamanhos e deslocamentos...".
Start the calculating timer.
Calculate the lengths of the types.
Calculate the offsets in the types.
Calculate the redefinition offsets in the types.
Stop the calculating timer.

Etapas necessárias para que se compile um directory (compile the bodies of the routines):
Se the compiler's abort flag estiver verde, exit.
Show status "Agrupando o conteúdo das tarefas...".
Start the compiling routine bodies timer.
Compile the bodies of the routines.
Stop the compiling routine bodies timer.

Etapas necessárias para que se compile um directory (compile the headers of the routines):
Se the compiler's abort flag estiver verde, exit.
Show status "Agrupando os nomes das tarefas...".
Start the compiling routine headers timer.
Compile the headers of the routines.
Stop the compiling routine headers  timer.

Etapas necessárias para que se compile um directory (index the routines por utility use):
Se the compiler's abort flag estiver verde, exit.
Show status "Catalogando tarefas...".
Start the indexing utilities timer.
Index the routines por utility use.
Scrub the utility index.
Reindex the utility index.
Stop the indexing utilities timer.

Etapas necessárias para que se compile um directory (link):
Se the compiler's abort flag estiver verde, exit.
Show status "Elencando arquivos..".
Start the linking timer.
Link.
Stop the linking timer.

Etapas necessárias para que se compile um directory (offset parameters and variables):
Se the compiler's abort flag estiver verde, exit.
Show status "Deslocando parâmetros e variáveis...".
Start the offsetting timer.
Offset the parameters in the routines.
Offset the locals in the routines.
Stop the offsetting timer.

Etapas necessárias para que se compile um directory (load the source files):
Se the compiler's abort flag estiver verde, exit.
Show status "Carregando arquivos...".
Start the loading timer.
Load the source files.
Stop the loading timer.

Etapas necessárias para que se compile um directory (resolve the globals):
Se the compiler's abort flag estiver verde, exit.
Show status "Resolvendo itens de escopo abrangente...".
Start the resolving globals timer.
Resolve the globals.
Stop the resolving globals timer.

Etapas necessárias para que se compile um directory (resolve the types):
Se the compiler's abort flag estiver verde, exit.
Show status "Resolvendo tipos...".
Start the resolving types timer.
Resolve the types (expand coisas).
Resolve the types (index plurals).
Resolve the types (base types).
Resolve the types (optional info).
Stop the resolving types timer.

Etapas necessárias para que se compile um directory (scan the source files):
Se the compiler's abort flag estiver verde, exit.
Show status "Analisando arquivos...".
Start the scanning timer.
Scan the source files.
Stop the scanning timer.

Etapas necessárias para que se compile um directory (start):
Show status "Iniciando...".
Finalize the compiler.
Start the compiler's timer.
Initialize the compiler given the directory.
Adicione the built-in types.

Etapas necessárias para que se compile um directory (stop):
Stop the compiler's timer.
Show status "Interrompendo".

Etapas necessárias para que se compile um directory (transmogrify):
Se the compiler's abort flag estiver verde, exit.
Show status "Modificando...".
Start the transmogrifying timer.
Transmogrify the routines.
Stop the transmogrifying timer.

Etapas necessárias para que se compile um directory (write the exe):
Se the compiler's abort flag estiver verde, exit.
Show status "Gerando arquivo executável...".
Start the writing timer.
Write the compiler's exe to the compiler's exe path.
Se the i/o error é not blank, abort with the i/o error.
Stop the writing timer.

Etapas necessárias para que se compile um expression given um rider:
Se the compiler's abort flag estiver verde, exit.
Compile um term given the rider.
Put the term into the expression.
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é not any operator, exit.
Se the rider's token é any divided, compile the expression given the rider (divided); repeat.
Se the rider's token é any minus, compile the expression given the rider (minus); repeat.
Se the rider's token é any plus, compile the expression given the rider (plus); repeat.
Se the rider's token é any then, compile the expression given the rider (then); repeat.
Se the rider's token é any times, compile the expression given the rider (times); repeat.

Etapas necessárias para que se compile um expression given um rider (divided):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Se the rider's token é not any by, abort with "Você deve usar o termo 'divided BY'." and the rider; exit.
Se the expression's variable é nil, abort with "Termo 'divided by' inválido, há um erro na variável: '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "O seu 'divided by',está errado. Não dá pra dividir por '" then the term's phrase then "'." and the rider; exit.
Adicione um intermediate given the expression's type name and the rider's token's first.
Adicione several fragments given "put" and the expression's variable and "into" and the intermediate and the rider's token's first.
Adicione several fragments given "divide" and the intermediate and "by" and the term's variable and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile um expression given um rider (minus):
Se the compiler's abort flag estiver verde, exit.
Se the expression's variable é nil, abort with "O seu 'minus', está errado. Não consigo subtrair o(a) '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "O seu 'minus', está errado. Não consigo diminuir do(a) '" then the term's phrase then "'." and the rider; exit.
Adicione um intermediate given the expression's type name and the rider's token's first.
Adicione several fragments given "put" and the expression's variable and "into" and the intermediate and the rider's token's first.
Adicione several fragments given "subtract" and the term's variable and "from" and the intermediate and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile um expression given um rider (plus):
Se the compiler's abort flag estiver verde, exit.
Se the expression's variable é nil, abort with "O seu 'plus', está errado. Não consigo somar o '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "O seu 'plus',  está errado. Não consigo somar um '" then the term's phrase then "'." and the rider; exit.
Adicione um intermediate given the expression's type name and the rider's token's first.
Adicione several fragments given "put" and the expression's variable and "into" and the intermediate and the rider's token's first. \aqui muda o put
Adicione several fragments given "adicione" and the term's variable and "to" and the intermediate and the rider's token's first. \ aqui muda o add
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile um expression given um rider (then):
Se the compiler's abort flag estiver verde, exit.
Se the expression's variable é nil, abort with "O seu 'then', está errado. Eu não entendi o que é o(a) '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "O seu 'then', está errado. Eu não sei o que é o(a) '" then the term's phrase then "'." and the rider; exit.
Adicione um intermediate given "string" and the rider's token's first.
Adicione the put or convert fragments given the expression's variable and the intermediate and the rider's token's first.
Convert the term por concatenation given the rider.
Adicione several fragments given "append" and the term's variable and "to" and the intermediate and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile um expression given um rider (times):
Se the compiler's abort flag estiver verde, exit.
Se the expression's variable é nil, abort with "O seu 'times', está errado. Eu não sei como multiplicar o '" then the expression's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "O seu 'times', está errado. Eu não sei como multiplicar um '" then the term's phrase then "'." and the rider; exit.
Adicione um intermediate given the expression's type name and the rider's token's first.
Adicione several fragments given "put" and the expression's variable and "into" and the intermediate and the rider's token's first.
Adicione several fragments given "multiply" and the intermediate and "by" and the term's variable and the rider's token's first.
Put the intermediate into the expression's variable.
Clear the expression's phrase.

Etapas necessárias para que se compile the header of um routine:
Se the routine é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Slap um rider on the routine's routine header.
Move the rider (compiler rules).
Se the rider's token é any decide, compile the header of the routine given the rider (decider); exit.
Se the rider é the start of any reverse-possessive function, compile the header of the routine given the rider (reverse-possessive function); exit.
Se the rider é the start of any function, compile the header of the routine given the rider (function); exit.
Se the rider's token é "compativelmente", compile the header of the routine given the rider (callback); exit.
Compile the header of the routine given the rider (procedure).

Etapas necessárias para que se compile the header of um routine given um rider (callback):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Set the routine's callback flag.
Compile the routine's monikettes and the routine's parameters given the rider.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker é in the routine index, abort with "Você já tinha escrito um função '" then the routine's moniker then "'." and the routine's locus; exit.
Index the routine given the routine's monikettes and the routine index.

Etapas necessárias para que se compile the header of um routine given um rider (decider):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Se the rider's token é not any conditional, abort with "It's 'Decide IF.' Sempre dizemos, 'Decide IF'. Certo?" and the rider; exit.
Move the rider (compiler rules).
Set the routine's decider flag.
Compile the routine's monikettes and the routine's parameters given the rider.
Se any of the routine's monikettes are negative words, abort with "Não consigo me dar bem com palavras negativas nos decider names." and the rider; exit.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker é in the routine index, abort with "Você já me contou como'" then the routine's moniker then "'." and the routine's locus; exit.
Index the routine given the routine's monikettes and the routine index.

Etapas necessárias para que se compile the header of um routine given um rider (function):
Se the compiler's abort flag estiver verde, exit.
Set the routine's function flag.
Adicione um monikette to the routine's monikettes given "put".
Move the rider (compiler rules).
Se the rider's token é any indefinite article, set um flag.
Se the flag estiver verde, compile the routine's monikettes and the routine's parameters given the rider (indefinite article).
Se the flag estiver not verde, compile the routine's monikettes and the routine's parameters given the rider (definite article).
Se the rider's token é not any possessive, abort with "Tá faltando um 's por aqui (ou está no lugar errado)." and the rider; exit. \ not translated - no possessives in Spanish
Move the rider (compiler rules).
Scan um name given the rider.
Adicione another monikette to the routine's monikettes given "'s " then the name.
Se the rider's token é not "into", abort with "Eu estava esperando um palavra 'into', mas encontrei um palavra '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to the routine's monikettes given "into".
Convert the routine's monikettes to um moniker.
Se the moniker é in the routine index, abort with "Eu já sei como '" then the moniker then "'." and the routine's locus; exit. \ not translated - no possessives in Spanish
Index the routine given the routine's monikettes and the routine index.
Move the rider (compiler rules).
Se the rider's token é not any indefinite article, abort with "Estava esperando um artigo indefinido, mas achei isso aqui: '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Compile the routine's monikettes and the routine's parameters given the rider (indefinite article).
Se the rider's token é not blank, abort with "Tem comandos extras no fim dessa função." and the rider; exit. \ not translated - no possessives in Spanish
Convert the routine's monikettes to the routine's moniker.
Index the routine given the routine's monikettes and the routine index. \ por employs

Etapas necessárias para que se compile the header of um routine given um rider (procedure):
Se the compiler's abort flag estiver verde, exit.
Compile the routine's monikettes and the routine's parameters given the rider.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker é in the routine index, abort with "Você já escreveu como fazer '" then the routine's moniker then "'." and the routine's locus; exit.
Index the routine given the routine's monikettes and the routine index.

Etapas necessárias para que se compile the headers of some routines:
Se the compiler's abort flag estiver verde, exit.
Get um routine from the routines.
Se the routine é nil, exit.
Compile the header of the routine.
Repeat.

Etapas necessárias para que se compile um literal given um rider:
Se the compiler's abort flag estiver verde, exit.
Adicione the literal to the literals given the rider's token's first.
\Se the rider's token é any flag literal, compile the literal given the rider (flag); exit.
Se the rider's token é any hex literal, compile the literal given the rider (hex); exit.
Se the rider's token é any numeric literal, compile the literal given the rider (numeric); exit.
Se the rider's token é any endereço de memória literal, compile the literal given the rider (endereço de memória); exit.
Se the rider's token é any string literal, compile the literal given the rider (string); exit.
Abort with "Erro interno - compile um term given um rider (literal)" and the rider.

Etapas necessárias para que se compile um literal given um rider (flag):
Se the compiler's abort flag estiver verde, exit.
Convert the rider's token to um flag.
Convert the flag to the literal's data.
Move the rider (compiler rules).
Put "flag" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal given um rider (hex):
Se the compiler's abort flag estiver verde, exit.
Put the rider's token into um nibble substring.
Adicione 1 to the nibble substring's first.
Convert the nibble substring to the literal's data.
Move the rider (compiler rules).
Put "texto hexadecimal" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal given um rider (numeric - integer):
Se the compiler's abort flag estiver verde, exit.
Convert the rider's token to um número.
Convert the número to the literal's data.
Move the rider (compiler rules).
Put "número" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal given um rider (numeric - ratio):
Se the compiler's abort flag estiver verde, exit.
Convert the rider's token to um ratio.
Convert the ratio to the literal's data.
Move the rider (compiler rules).
Put "ratio" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal given um rider (numeric - with unit of measure):
Se the compiler's abort flag estiver verde, exit.
Convert the rider's token to um ratio.
Move the rider (compiler rules).
Scan um name given the rider.
Find um type given the name and the type index.
Se the type é nil, abort with "'" then the name then "' é uma unidade de medida inexistente." and the literal's locus; exit.
Se the type cannot be reduced to "número", abort with "'" then the name then "' é uma unidade de medida inválida." and the literal's locus; exit.
Put the type's scale into um final ratio.
Se the type's scale é 0, put 1/1 into the final ratio.
Multiply the final ratio by the ratio.
Reduce the final ratio.
Se the final ratio's denominator é 0, abort with "Parece que essa é uma unidade de medida inválida." and the literal's locus.
Put the final ratio's numerator divided by the final ratio's denominator into um número.
Put the type's name into the literal's type name.
Convert the número to the literal's data.
Resolve the literal.

Etapas necessárias para que se compile um literal given um rider (numeric):
Se the compiler's abort flag estiver verde, exit.
Se the rider é followed by any unit of measure, compile the literal given the rider (numeric - with unit of measure); exit.
Se the rider's token é any integer literal, compile the literal given the rider (numeric - integer); exit.
Se the rider's token é any ratio literal, compile the literal given the rider (numeric - ratio); exit.
Se the rider's token é any mixed literal, compile the literal given the rider (numeric - ratio); exit.

Etapas necessárias para que se compile um literal given um rider (endereço de memória):
Se the compiler's abort flag estiver verde, exit.
Convert 0 to the literal's data. \ was nil
Move the rider (compiler rules).
Put "endereço de memória" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile um literal given um rider (string):
Se the compiler's abort flag estiver verde, exit.
Put the rider's token into the literal's data.
Unquote the literal's data.
Move the rider (compiler rules).
Put "string" into the literal's type name.
Resolve the literal.

Etapas necessárias para que se compile some monikettes and some parameters given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Se the rider's token é any definite article, compile the monikettes and the parameters given the rider (definite article); repeat.
Se the rider é on any indefinite article, compile the monikettes and the parameters given the rider (indefinite article); repeat.
Se the rider é on any monikette string, compile the monikettes and the parameters given the rider (monikette string); repeat.
Abort with "'" then the rider's token then "' não é um nome de função que eu conheça." and the rider.

Etapas necessárias para que se compile some monikettes and some parameters given um rider (definite article):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Scan um name given the rider.
Se the compiler's abort flag estiver verde, exit.
Prepend "the " to the name.
Adicione um monikette to the monikettes given the name.

Etapas necessárias para que se compile some monikettes and some parameters given um rider (indefinite article):
Se the compiler's abort flag estiver verde, exit.
Adicione um parameter to the parameters given "parameter" and the rider's token's first.
\PAL
Se the rider's token é "outra", put "segunda" into the parameter's name.
Se the rider's token é "outro", put "segundo" into the parameter's name.
\CAL
Se the rider's token é "another", put "other" into the parameter's name.
Move the rider (compiler rules).
Scan um name given the rider.
Extend the parameter's name with the name.
Se the rider's token é any called, compile the call'd part given the rider and the parameter.
Resolve the parameter.
Se the parameter é duplicated in the parameters, abort with "Cara, você repetiu o parâmetro '" then the parameter's name then "'." and the parameter's locus; exit.
Adicione um monikette to the monikettes given the parameter's type.

Etapas necessárias para que se compile some monikettes and some parameters given um rider (monikette string):
Se the compiler's abort flag estiver verde, exit.
Adicione um monikette to the monikettes given the rider's token.
Move the rider (compiler rules).

Etapas necessárias para que se compile some monikettes given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider é on any monikette string, adicione um monikette to the monikettes given the rider's token; move the rider (compiler rules); repeat.
Se the rider's token é not the start of any expression, exit.
Compile um expression given the rider.
Se the compiler's abort flag estiver verde, exit.
Adicione another monikette to the monikettes given the expression.
Repeat.

\Etapas necessárias para que se compile some monikettes given um rider:
\Se the compiler's abort flag estiver verde, exit.
\Se the rider's token é any monikette string, adicione um monikette to the monikettes given the rider's token; move the rider (compiler rules); repeat.
\Se the rider's token é not the start of any expression, exit.
\Compile um expression given the rider.
\Se the compiler's abort flag estiver verde, exit.
\Adicione another monikette to the monikettes given the expression.
\Repeat.

Etapas necessárias para que se compile the next statement given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é any conditional, compile the next statement given the rider (if); exit.
Se the rider's token é any loop, compile the next statement given the rider (loop); exit.
Se the rider's token é any privatize, compile the next statement given the rider (privatize); exit.
Se the rider's token é not the start of any statement, abort with "Eu esperava uma declaração aqui, mas encontrei: '" then the rider's token then "'." and the rider; exit.
Compile the next statement given the rider (other).
Se the rider's token é not the period pedaço, abort with "Acho que tá faltando um pontinho por aqui." and the rider; exit.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement given um rider (break):
Adicione um fragment given the break tag.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement given um rider (call - external):
Put the rider's token into um string.
Unquote the string.
Move the rider (compiler rules).
Se the rider's token é not any string literal, abort with "Cara, você precisa colocar os nomes entre aspas, mas você colocou '" then the rider's token then "'." and the rider; exit.
Put the rider's token into another string.
Unquote the other string.
Move the rider (compiler rules).
Adicione um entry to the imports given the string and the other string.
Se the rider's token é "with", compile the next statement given the rider (call - with clause).
Se the rider's token é "returning", compile the next statement given the rider returning um term (call - returning part).
Adicione um fragment given the call external tag and the entry.
Se the term é empty, exit.
Se the term's variable é nil, abort with "Não entendi bem o que é '" then the term's phrase then "'." and the rider; exit.
Adicione another fragment given the save eax tag and the term's variable.

Etapas necessárias para que se compile the next statement given um rider (call - indirect):
Compile um expression given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the expression's variable é nil, abort with "Eu não sei o que é '" then the expression's phrase then "'." and the rider; exit.
Se the expression's type cannot be reduced to "endereço de memória", abort with "Eu preciso de um endereço de memória type nesse CALL statement." and the rider; exit.
Se the rider's token é "with", compile the next statement given the rider (call - with clause).
Se the rider's token é "returning", compile the next statement given the rider returning um term (call - returning part).
Adicione um fragment given the call indirect tag and the expression's variable.
Se the term é empty, exit.
Se the term's variable é nil, abort with "Acho que essa varíavel é inválida: '" then the term's phrase then "'." and the rider; exit.
Adicione another fragment given the save eax tag and the term's variable.

Etapas necessárias para que se compile the next statement given um rider (call - internal):
Compile some monikettes given the rider.
Find um routine given the monikettes.
Se the routine é not nil, adicione push fragments given the monikettes.
Se the routine é not nil, destroy the monikettes; adicione um fragment given the call internal tag and the routine; exit.
Convert the monikettes to um moniker.
Destroy the monikettes.
\Put "Eu ainda não aprendi como"  into a reply.
\Say the reply.
Put the moniker into a reply.
\Say the reply.
Abort with "Eu ainda não aprendi como '" then the moniker then "'." and the rider.

Etapas necessárias para que se compile the next statement given um rider (call - with clause): \ this guy é recursise so parameters get passed right to left
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Compile um expression given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the expression's variable é nil, abort with "Eu não entendo um variável: '" then the expression's phrase then "'." and the rider; exit.
Se the expression's type é not value pushable, abort with "'" then the expression's type's name then "' não pode ser processado corretamente." and the rider; exit.
Se the rider's token é any and, compile the next statement given the rider (call - with clause).
Adicione um fragment given the push value tag and the expression's variable.

Etapas necessárias para que se compile the next statement given um rider (call):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Se the rider's token é any string literal, compile the next statement given the rider (call - external); exit.
Compile the next statement given the rider (call - indirect).  

Etapas necessárias para que se compile the next statement given um rider (exit):
Se the current routine's decider flag estiver verde, abort with "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" and the rider; exit.
Adicione um fragment given the exit tag.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement given um rider (if):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Compile some monikettes given the rider.
Remove any negatives from the monikettes returning um flag.
Find um routine given the monikettes.
Se the routine é not nil, adicione push fragments given the monikettes.
Se the routine é nil, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine é nil, abort with "Preciso de um decider que tenha como palavras: '" then the moniker then "'." and the rider; exit.
Se the routine's decider flag estiver not verde, abort with "Cara eu vou precisar de um decider aqui, blz?" and the rider; exit.
Se the rider's token é not the comma pedaço, abort with "Acho que você esqueceu de uma vírgula, eu achei isso aqui: '" then the rider's token then "'." and the rider; exit.
Adicione um fragment given the call internal tag and the routine.
Se the flag estiver verde, adicione another fragment given the not tag.
Adicione um third fragment given the jump false tag.
Move the rider (compiler rules).
Loop.
Compile the next statement given the rider (other).
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é the semi-colon pedaço, move the rider (compiler rules); repeat.
Se the rider's token é not the period pedaço, abort with "Você precisa usar um ponto ao invés de usar o termo '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Adicione um fourth fragment given the end if tag.

Etapas necessárias para que se compile the next statement given um rider (intel):
Move the rider (compiler rules).
Se the rider's token é not any hex literal, abort with "Eu preciso de um pouco de machine code, mas o que eu achei foi '" then the rider's token then "'." and the rider; exit.
Adicione um fragment given the intel tag.
Put the rider's token into um nibble substring.
Adicione 1 to the nibble substring's first.
Convert the nibble substring to the fragment's code.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement given um rider (loop):
Se the compiler's abort flag estiver verde, exit.
Adicione um fragment given the loop tag.
Move the rider (compiler rules).
Se the rider's token é not the period pedaço, abort with "Parece que alguém esqueceu de colocar um ponto por aí." and the rider; exit.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement given um rider (other):
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Se the rider's token é any exit, compile the next statement given the rider (exit); exit.
Se the rider's token é any repeat, compile the next statement given the rider (repeat); exit.
Se the rider's token é any break, compile the next statement given the rider (break); exit.
Se the rider's token é any say, compile the next statement given the rider (say); exit.
Se the rider's token é "intel", compile the next statement given the rider (intel); exit.
Se the rider's token é "push", compile the next statement given the rider (push); exit.
Se the rider's token é any call, compile the next statement given the rider (call); exit.
Se the rider's token é any point, compile the next statement given the rider (point); exit.
Se the rider's token é any conditional, abort with "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." and the rider; exit.
Se the rider's token é any privatize, abort with "A sentença 'privatizar' não pode ser usada aqui." and the rider; exit.
Se the rider's token é any loop, abort with "Usar um percorra deentro de um SE é uma ótima forma de arranjar problemas." and the rider; exit.
Se the rider's token é any employ, abort with "'Empregue' deve ser o único imperativo em uma rotina." and the rider; exit.
Compile the next statement given the rider (call - internal).

Etapas necessárias para que se compile the next statement given um rider (point):
Move the rider (compiler rules).
Compile um term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Acho que o termo '" then the term's phrase then "' está vazio." and the rider; exit.
Se the term's kind é "literal", abort with "Você usou o tipo errado de variável aqui (literal)." and the rider.
Se the term's type's length é not 4, abort with "Você usou uma variável de comprimento errado (<>4)." and the rider.
Se the rider's token é not "to", abort with "Acho que faltou um 'to', mas você usou '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Se the rider's token é not "routine", abort with "Acho que faltou a palavra 'routine'. Você usou o termo '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Compile um routine reference given the rider.
Convert the routine reference to um moniker.
Destroy the routine reference.
Find um routine given the moniker and the routine index.
Se the routine é nil, abort with "Não achei a tarefa '" then the moniker then "' que você falou." and the rider; exit.
Adicione um fragment given the routine address tag and the routine.
Put the term's variable into the fragment's variable.

Etapas necessárias para que se compile the next statement given um rider (privatize):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Compile um term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Comando 'privatize', Inválido. Eu acho que o termo da variável '" then the term's phrase then "' está vazio." and the rider; exit.
Se the term's kind é not "parameter", abort with "Você só pode privatizar parâmetros." and the rider; exit.
Adicione um local to the current routine's locals given "local" and the rider's token's first.
Put the term's name into the local's name.
Put the term's nickname into the local's nickname.
Put the term's type name into the local's type name.
Resolve the local.
Prepend "original " to the term's name.
Se the term's nickname é not blank, prepend "original " to the term's nickname.
Adicione several fragments given "put" and the term's variable and "into" and the local and the rider's token's first.
Se the rider's token é not the period pedaço, abort with "Você vive esquecendo dos pontos né?." and the rider; exit.
Move the rider (compiler rules).

Etapas necessárias para que se compile the next statement given um rider (push):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Compile um expression given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the expression's variable é nil, abort with "Comando 'push' inválido, um expressão '" then the expression's phrase then "' parece estar vazia." and the rider; exit.
Se the expression's type é not value pushable, abort with "Valores do tipo '" then the expression's type's name then "' não podem ser pushed." and the rider; exit.
Adicione um fragment given the push value tag and the expression's variable.

Etapas necessárias para que se compile the next statement given um rider (repeat):
Adicione um fragment given the repeat tag.
Move the rider (compiler rules).

\Etapas necessárias para que se compile the next statement given um rider (say):
\Se the current routine's decider flag estiver not verde, compile the next statement given the rider (call - internal); exit.
\Move the rider (compiler rules).
\Compile um expression given the rider.
\Se the compiler's abort flag estiver verde, exit.
\Se the expression's variable é nil, abort with "No es válido este 'diga', no entiendo la variable '" then the expression's phrase then "'." and the rider; exit.
\Se the expression's type cannot be reduced to "flag", abort with "Necesito un rotundo 'si' o 'no' aquí." and the rider; exit.
\Adicione um fragment given the load eax tag and the expression's variable.
\Adicione another fragment given the exit tag.

Etapas necessárias para que se compile the next statement given um rider (say):
Se the current routine's decider flag estiver not verde, compile the next statement given the rider (call - internal); exit.
Move the rider (compiler rules).
Se the rider's token é not any decider literal, abort with "Você precisa terminar com um yes ou no." and the rider; exit.
Clear um flag. Se the rider's token é any positive decider literal, set the flag.
Move the rider (compiler rules).
Se the rider's token é not the period pedaço, abort with "Faltou um ponto. Você usou o termo: '" then the rider's token then "'." and the rider; exit.
Adicione um fragment given the load eax tag and the flag.
Adicione another fragment given the exit tag.

Etapas necessárias para que se compile the next statement given um rider returning um term (call - returning part):
Move the rider (compiler rules).
Compile the term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Eu não compreendi o termo da variável '" then the term's phrase then "'. Ela parece estar vazia." and the rider; exit.
Se the term's type é not value pushable, abort with "Uma varíavel de 1, 2, ou 4-pedaços é necessária na 'returning' clause." and the rider.

Etapas necessárias para que se compile um routine reference given um rider:
Se the rider's token é "to", move the rider (compiler rules).
Se the rider é the start of any function, compile the routine reference given the rider (function); exit.
Se the rider's token é any decide, compile the routine reference given the rider (decide).
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Se the rider's token é ".", exit.
Se the rider's token é any definite article, compile the routine reference given the rider (definite article); repeat.
Se the rider's token é any indefinite article, compile the routine reference given the rider (indefinite article); repeat.
Se the rider é on any monikette string, compile the routine reference given the rider (monikette string); repeat.
Abort with "'" then the rider's token then "' não é válido em  um employ statement." and the rider.

Etapas necessárias para que se compile um routine reference given um rider (decide):
Move the rider (compiler rules).
Se the rider's token é not any conditional, abort with "Sempre use DECIDE IF, ao invés de apenas DECIDE com '" then the rider's token then "' logo em seguida." and the rider; exit.
Move the rider (compiler rules).

Etapas necessárias para que se compile um routine reference given um rider (definite article):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Scan um name given the rider.
Prepend "the " to the name.
Adicione um monikette to the routine reference given the name.

Etapas necessárias para que se compile um routine reference given um rider (function):
Se the compiler's abort flag estiver verde, exit.
Adicione um monikette to the routine reference given "put".
Move the rider (compiler rules).
Se the rider's token é any indefinite article, set um flag.
Se the flag estiver verde, compile the routine reference given the rider (indefinite article).
Se the flag estiver not verde, compile the routine reference given the rider (definite article).
Se the rider's token é not any possessive, abort with "Eu estava esperando un 's, mas apareceu '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Move the rider (compiler rules).
Scan um name given the rider.
Adicione another monikette to the routine reference given "'s " then the name.
Se the rider's token é not "into", abort with "E estava esperando um palavra 'into', mas encontrei '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to the routine reference given "into".
Move the rider (compiler rules).
Se the rider's token é not any indefinite article, abort with "Eu estava esperando um artigo indefinido mas encontrei isso: '" then the rider's token then "'." and the rider; exit. \ not translated - no possessives in Spanish
Compile the routine reference given the rider (indefinite article).

Etapas necessárias para que se compile um routine reference given um rider (indefinite article):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Scan um name given the rider.
Find um type and um nickname given the name.
Se the type é nil, abort with "Employ statement inválido, Eu não sei o que é '" then the name then "'." and the rider; exit.
Adicione um monikette to the routine reference given the type.

Etapas necessárias para que se compile um routine reference given um rider (monikette string):
Se the compiler's abort flag estiver verde, exit.
Adicione um monikette to the routine reference given the rider's token.
Move the rider (compiler rules).

Etapas necessárias para que se compile um term given um rider:
Clear the term.
Se the compiler's abort flag estiver verde, exit.
Compile the term given the rider (common part).
Se the rider é on any simile, exit. \ added por invisible turtle project ***
\Se the rider's token é "as", compile the term given the rider (as part).  \preposição
\Se the rider's token é "tão", compile the term given the rider (as part). \ me parece desnecessário por ser usado apenas em funções.
Se the rider's token é "quão", compile the term given the rider (as part).
Se the rider's token é "quanto", compile the term given the rider (as part).
Se the rider's token é "como", compile the term given the rider (as part).
\Se the rider's token é "que nem", compile the term given the rider (as part).
Se the rider's token é "/", compile the term given the rider (runtime ratio).

Etapas necessárias para que se compile um term given um rider (as part):
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Comando 'as'inválido. Eu acho que um variável '" then the term's phrase then "' está vaiza." and the rider; exit.
Move the rider (compiler rules).
Se the rider's token é not any indefinite article, abort with "Tá faltando um artigo indefinido depois do 'como', mas você escreveu '" then the rider's token then "' no lugar disso." and the rider; exit.
Move the rider (compiler rules).
Scan um type name given the rider.
Find um type given the type name and the type index.
Se the type é nil, abort with "Eu não sei em qual tipo o '" then the type name then "' se encaixa." and the rider; exit.
Adicione um scratch given the type's name and the rider's token's first.
Adicione um fragment given the load address tag and the term's variable and the scratch.
Put the scratch into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider (common part):
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é the dash pedaço, compile the term given the rider (negated term); exit.
Se the rider's token é the cross pedaço, compile the term given the rider (posigated term); exit.
Se the rider's token é the start of any variable, compile the term given the rider (variable); exit.
Se the rider's token é the start of any new local, compile the term given the rider (new local); exit.
Se the rider's token é any literal, compile the term given the rider (literal); exit.
Abort with "Faltou um termo por aqui. Só achei isso aqui: '" then the rider's token then "'." and the rider.

Etapas necessárias para que se compile um term given um rider (dereference - in place):
Se the term's variable é nil, abort with "Erro interno na função - compile um term given um rider (dereference - in place). Termo vazio" and the rider; exit.
Put the term's type's target type's name into the term's type name.
Put the term's type's target type into the term's type.
Adicione um fragment given the dereference tag and the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider (dereference):
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Dereference inválido, um variável '" then the term's phrase then "' parece estar vazia." and the rider; exit.
Se the term's type's target type é nil, abort with "Não consegui identificar o tipo desse target." and the rider; exit.
Se the term's kind é "scratch", compile the term given the rider (dereference - in place); exit.
Adicione um scratch given the term's type's target type's name and the rider's token's first.
Adicione um fragment given the load address tag and the term's variable and the scratch.
Adicione another fragment given the dereference tag and the scratch.
Put the scratch into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider (literal):
Se the compiler's abort flag estiver verde, exit.
Compile um literal given the rider.
Put the literal into the term's variable.
Clear the term's phrase.
Compile the term given the rider (possessives).

Etapas necessárias para que se compile um term given um rider (negated term):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Compile another term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the other term's variable é nil, abort with "Negate inválido, um variável '" then the other term's phrase then "' parece estar vazia." and the rider; exit.
Adicione um intermediate given the other term's type name and the rider's token's first.
Adicione several fragments given "put" and the other term's variable and "into" and the intermediate and the other term's locus.
Adicione two fragments given "negate" and the intermediate and the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider (new local):
Se the compiler's abort flag estiver verde, exit.
Se the current routine é nil, abort with "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." and the rider; exit.
Adicione um local to the current routine's locals given "local" and the rider's token's first.
\PAL
Se the rider's token é "outra", put "segunda" into the local's name.
Se the rider's token é "outro", put "segundo" into the local's name.
\CAL
Se the rider's token é "another", put "other" into the local's name.
Move the rider (compiler rules).
Scan um name given the rider.
Extend the local's name with the name.
Se the rider's token é any called, compile the call'd part given the rider and the local.
Resolve the local.
Se the local é duplicated in the current routine's parameters, abort with "o parâmetro '" then the local's name then "' já está sendo usado como parâmetro." and the local's locus; exit.
Se the local é duplicated in the current routine's locals, abort with "Já existe uma variável local chamada'" then the local's name then "'. Você tem que dar um nome diferente." and the local's locus; exit.
Eliminate duplicate nicknames given the local and the current routine's nickname index.
Put the local into the term's variable.
Clear the term's phrase.
Compile the term given the rider (possessives).

Etapas necessárias para que se compile um term given um rider (posigated term):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Compile the term given the rider.
Se the term's variable é nil, abort with "Posigate inválido, o termo da variável'" then the term's phrase then "' parece estar vazio." and the rider; exit.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider (possessive - magnitude):
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Use da magnitude inválido. An variável '" then the term's phrase then "' parece estar vazia." and the rider; exit.
Adicione um literal to the literals given the rider's token's first.
Convert the term's type's length to the literal's data.
Put "número" into the literal's type name.
Resolve the literal.
Put the literal into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider (possessive - target):
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Você usou o target de forma errada. O termo da variável '" then the term's phrase then "' parece estar vazio." and the rider; exit.
Se the term's type cannot be reduced to "endereço de memória", abort with "Você só pode usar target com tipos endereço de memória." and the rider; exit.
Compile the term given the rider (dereference).

Etapas necessárias para que se compile um term given um rider (possessive - whereabouts):
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Você usou whereabouts da forma errada, erro no termo da variável '" then the term's phrase then "'." and the rider; exit.
Adicione um intermediate given "endereço de memória" and the rider's token's first. 
Adicione um fragment given the load address tag and the term's variable and the intermediate.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider (possessive): \ similar to "compile um term given um rider (reverse-possessive)
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Scan um name given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the name é any magnitude, compile the term given the rider (possessive - magnitude); exit.
Se the name é any target, compile the term given the rider (possessive - target); exit.
Se the name é any whereabouts, compile the term given the rider (possessive - whereabouts); exit.
Compile the term given the rider and the name (possessive - field).

Etapas necessárias para que se compile um term given um rider (possessives):
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é not any possessive, exit.
Compile the term given the rider (possessive).
Repeat.  

Etapas necessárias para que se compile um term given um rider (runtime ratio):
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é nil, abort with "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável '" then the term's phrase then "'." and the rider; exit.
Move the rider (compiler rules).
Compile another term given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the other term's variable é nil, abort with "Uso inválido da /, termo vazio da variável: '" then the other term's phrase then "'." and the rider; exit.
Adicione um intermediate given "ratio" and the rider's token's first.
Adicione several fragments given "put" and the term's variable and "and" and the other term's variable and "into" and the intermediate and the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider (variable):
Se the compiler's abort flag estiver verde, exit.
Se the current routine é nil, abort with "Erro de tarefa vazia, nada pra pull da pilha aqui." and the rider; exit.
Move the rider (compiler rules).
Scan um name given the rider.
Se the rider é on any reverse-possessive, compile the term given the rider and the name (reverse-possessive); exit.
Find um variable given the name.
Put the variable into the term's variable.
Put "the " into the term's phrase.
Append the name to the term's phrase.
Compile the term given the rider (possessives).

Etapas necessárias para que se compile um term given um rider and um field name (reverse-possessive):  \ this é recursive \ dahn version 2
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules). \ past the reverse-possessive starter
\Se the rider's token é not "del", Move the rider (compiler rules). \ past the reverse-possessive starter \ gerry added "if" part
\Se the rider's token é "del", adicione 1 to the rider's token's first. \ makes "del" look like "de el"
Se the rider's token é not any article, abort with "Esperaba un artículo, pero encontré '" then the rider's token then "'."; exit.
Put the rider's token into um article token.
Move the rider (compiler rules).
Scan um name given the rider. 
Se the rider é on any reverse-possessive, set um reverse-possessive flag.
Se the reverse-possessive flag estiver verde, compile the term given the rider and the name (reverse-possessive).
Se the reverse-possessive flag estiver not verde, compile the term given the rider and the name and the article (reverse-possessive prepare to unwind).
Compile the term given the field name and the rider (reverse-possessive).

Etapas necessárias para que se compile um term given um rider and um variable name and um article token (reverse-possessive prepare to unwind): \ dahn version 2
Se the article é the start of any variable, compile the term given the rider and the variable name and the article (reverse-possessive prepare to unwind existing variable); exit.
Compile the term given the rider and the variable name (reverse-possessive prepare to unwind new local).

Etapas necessárias para que se compile um term given um rider and um variable name and um article token (reverse-possessive prepare to unwind existing variable): \ dahn version 2
Find um variable given the variable name.
Se the variable é nil, abort with "No se pudo encontrar una variable con el nombre '" then the variable name then "'.".
Put the variable into the term's variable.
Put "the " into the term's phrase.
Append the variable name to the term's phrase.

Etapas necessárias para que se compile um term given um rider and um variable name (reverse-possessive prepare to unwind new local): \ dahn version 2
Se the compiler's abort flag estiver verde, exit.
Adicione um local to the current routine's locals given "local" and the rider's token's first.
\PAL
Se the rider's token é "outra", put "segunda" into the local's name.
Se the rider's token é "outro", put "segundo" into the local's name.
\CAL
Se the rider's token é "another", put "other" into the local's name.
Extend the local's name with the variable name.
Se the rider's token é any called, compile the call'd part given the rider and the local.
Resolve the local.
Se the local é duplicated in the current routine's parameters, abort with "'" then the local's name then "' ya está en uso como parámetro." and the local's locus; exit.
Se the local é duplicated in the current routine's locals,abort with "'" then the local's name then "' ya está en uso como una variable local." and the local's locus; exit.
Eliminate duplicate nicknames given the local and the current routine's nickname index.
Put the local into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um field name and um rider (reverse-possessive):  \ similar to "compile um term given um rider (possessive)" \ dahn
Se the compiler's abort flag estiver verde, exit.
Se the field name é any magnitude, compile the term given the rider (possessive - magnitude); exit.
Se the field name é any target, compile the term given the rider (possessive - target); exit.
Se the field name é any whereabouts, compile the term given the rider (possessive - whereabouts); exit.
Compile the term given the rider and the field name (possessive - field).

Etapas necessárias para que se compile um term given um rider and um field term:
Se the compiler's abort flag estiver verde, exit.
Se the field term's dereference flag estiver verde, compile the term given the rider (dereference).  
Se the field term's function é not nil, compile the term given the rider and the field term (function); exit.
Se the term's kind é "scratch", compile the term given the rider and the field term (in place); exit.
Put the field term's field into um field.
Adicione um scratch given the field's type's name and the rider's token's first.
Adicione um fragment given the load address tag and the term's variable and the scratch.
Se the field's offset é not 0, adicione um third fragment given the increment tag and the scratch and the field's offset.
Put the scratch into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider and um field term (function):
Se the compiler's abort flag estiver verde, exit.
Put the field term's function into um routine.
Put the routine's parameters' last into um parameter.
Se the parameter é nil, abort with "Erro interno na função compile um term given um rider and um field term (function) - parâmetro vazio." and the rider; exit.
Se the parameter's type é nil, abort with "Erro interno 2 na função compile um term given um rider and um field term (function) - tipo do parâmetro inexistente." and the rider; exit.
Adicione um intermediate given the parameter's type's name and the rider's token's first.
Adicione um fragment given the push address tag and the intermediate.
Se the field term's push flag estiver verde, adicione another fragment given the push address tag and the term's variable.
Adicione um third fragment given the call internal tag and the routine.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider and um field term (in place):
Se the compiler's abort flag estiver verde, exit.
Put the field term's field into um field.
Put the field's type's name into the term's type name.
Put the field's type into the term's type.
Se the field's offset é not 0, adicione um third fragment given the increment tag and the term's variable and the field's offset.
Clear the term's phrase.

Etapas necessárias para que se compile um term given um rider and um name (possessive - field):
Se the compiler's abort flag estiver verde, exit.
Se the term's variable é not nil, put the term's type into um type.
Find um field term given the term's phrase and the type and the name.
Se the field term é not empty, compile the term given the rider and the field term; exit.
Se the term's variable é nil, abort with "Erro: variável vazia '" then the term's phrase then "'." and the rider; exit.
Se the type can be reduced to "endereço de memória", put the type's target type into the type.
Se the type é nil, abort with "Não existe o campo '" then the name then "' no tipo '" then the term's type's name then "'." and the rider; exit.
Loop.
Se the compiler's abort flag estiver verde, exit.
Get um field from the type's fields.
Se the field é nil, abort with "Não tem nenhum campo '" then the name then "' no tipo '" then the term's type's name then "'." and the rider; exit.
Find um deep field term given "" and the field's type and the name.
Se the deep field term é empty, repeat.
Put the field into um first field term's field.
Se the term's type can be reduced to "endereço de memória", set the first field term's dereference flag.
Compile the term given the rider and the first field term.
Compile the term given the rider and the deep field term.

The compiler é um conjunto with
An directory,
An timer,
An abort flag,
An abort message,
An abort path,
An abort row#,
An name count,
An exe buffer,
An listing buffer.

The compiling routine bodies timer é um timer.

The compiling routine headers timer é um timer.

Etapas necessárias para que se convert some monikettes to um moniker:
Convert the monikettes to the moniker given the monikettes' last.

Etapas necessárias para que se convert some monikettes to um moniker given um monikette:
Clear the moniker.
Loop.
Get um current monikette from the monikettes.
Se the current monikette é nil, exit.
Append the current monikette to the moniker.
Se the current monikette é the monikette, exit.
Repeat.

Etapas necessárias para que se convert um nibble substring to um string: employ convert um nibble string to um texto hexadecimal.

Etapas necessárias para que se convert um term por concatenation given um rider: \ used por right-side THEN operand
Se the term's variable é nil, abort with "Erro: variável do termo está vazia '" then the term's phrase then "'." and the rider; exit.
Se the term's type can be reduced to "string", exit.
Adicione um intermediate given "string" and the rider's token's first.
Adicione the put or convert fragments given the term's variable and the intermediate and the rider's token's first.
Put the intermediate into the term's variable.
Clear the term's phrase.

Etapas necessárias para que se copy um field into another field:
Se the field é nil, void the other field; exit.
Allocate memory por the other field.
Put the field's locus into the other field's locus.
Put the field's name into the other field's name.
Put the field's nickname into the other field's nickname.
Put the field's type name into the other field's type name.
Put the field's type into the other field's type.
Put the field's count into the other field's count.
Put the field's redefinition target name into the other field's redefinition target name.
Put the field's reference flag into the other field's reference flag.
Put the field's offset into the other field's offset.

Etapas necessárias para que se copy some fields into some other fields:
Get um field from the fields.
Se the field é nil, exit.
Copy the field into another field.
Append the other field to the other fields.
Repeat.

Etapas necessárias para que se copy some fields into some other fields (data fields only):
Se the fields' count é less than 4, exit. \ por english next and prev and spanish next and prev redefinitions
\Se the fields' first é nil, exit.
\Se the fields' first's next é nil, exit.
\Se the fields' first's next's next é nil, exit.
\\Put the fields' first's next's next into um field. \ skip next and prev
\Se the fields' first's next's next's next é nil, exit.
\Se the fields' first's next's next's next's next é nil, exit.
\Se the fields' first's next's next's next's next's next é nil, exit.
Put the fields' first's next's next's next's next into um field. \ english next and prev and spanish next and prev redefinitions
Loop.
Se the field é nil, exit.
Copy the field into another field.
Append the other field to the other fields.
Get the field from the fields.
Repeat.

Etapas necessárias para que se copy um monikette into another monikette:
Se the monikette é nil, void the other monikette; exit.
Allocate memory por the other monikette.
Put the monikette's string into the other monikette's string.
Put the monikette's type into the other monikette's type.
Put the monikette's variable into the other monikette's variable.
\ don't copy substring
Put the monikette's current type into the other monikette's current type.

Etapas necessárias para que se copy some monikettes into some other monikettes:
Destroy the other monikettes.
Loop.
Get um monikette from the monikettes.
Se the monikette é nil, exit.
Copy the monikette into another monikette.
Append the other monikette to the other monikettes.
Repeat.

Etapas necessárias para que se create um entry:
Allocate memory por the entry.

Etapas necessárias para que se create um fragment given um tag:
Allocate memory por the fragment.
Put the tag into the fragment's tag.

Etapas necessárias para que se create um import:
Allocate memory por the import.

Etapas necessárias para que se create um monikette:
Allocate memory por the monikette.

Etapas necessárias para que se create um routine:
Allocate memory por the routine.

Etapas necessárias para que se create um source file:
Allocate memory por the source file.

Etapas necessárias para que se create um type:
Allocate memory por the type.
Put 0/1 into the type's scale.
Put -1 into the type's length.

Etapas necessárias para que se create um variable given um kind:
Allocate memory por the variable.
Put the kind into the variable's kind.
Put 1 into the variable's count.

The current header address é um address.

The current name address é um address.

The current routine é um routine.

The current thunk address é um address.

The data borough é um borough.

Etapas necessárias para que se determine se any of some monikettes are negative words:
Get um monikette from the monikettes.
Se the monikette é nil, say no.
Se the monikette's string é any negative word, say yes.
Repeat.

Etapas necessárias para que se determine se um pedaço é any glom pedaço:
Se the pedaço é any letter, say yes.
Se the pedaço é any digit, say yes.
Se the pedaço é the tilde pedaço, say yes.
Se the pedaço é the at-sign pedaço, say yes.
Se the pedaço é the número-sign pedaço, say yes.
Se the pedaço é the percent-sign pedaço, say yes.
Se the pedaço é the ampersand pedaço, say yes.
Se the pedaço é the underscore pedaço, say yes.
Se the pedaço é the single-quote pedaço, say yes.
Se the pedaço é the dash pedaço, say yes.
Se the pedaço é the cross pedaço, say yes.
Se the pedaço é the slash pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um pedaço é any mark:
Se the pedaço é the period pedaço, say yes.
Se the pedaço é the comma pedaço, say yes.
Se the pedaço é the semi-colon pedaço, say yes.
Se the pedaço é the colon pedaço, say yes.
Se the pedaço é the exclamation  pedaço, say yes.
Se the pedaço é the question-mark pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um pedaço é any stressed vowel:
Se the pedaço é in "áãâéêíóõôúü", say yes.
Say no.

Etapas necessárias para que se determine se um pedaço é any symbol:
Se the pedaço é the caret pedaço, say yes.
Se the pedaço é the bar pedaço, say yes.
Se the pedaço é the asterisk pedaço, say yes.
Se the pedaço é the cross pedaço, say yes.
Se the pedaço é the dash pedaço, say yes.
Se the pedaço é the slash pedaço, say yes.
Se the pedaço é the left-alligator pedaço, say yes.
Se the pedaço é the right-alligator pedaço, say yes.
Se the pedaço é the left-brace pedaço, say yes.
Se the pedaço é the right-brace pedaço, say yes.
Se the pedaço é the equal-sign pedaço, say yes.
Se the pedaço é 128, say yes.
Se the pedaço é 130, say yes.
Se the pedaço é between 132 and 137, say yes.
Se the pedaço é 139, say yes.
Se the pedaço é between 145 and 153, say yes.
Se the pedaço é 155, say yes.
Se the pedaço é between 161 and 180, say yes.
Se the pedaço é between 183 and 191, say yes.
Se the pedaço é 215, say yes.
Se the pedaço é 247, say yes.
Say no.

Etapas necessárias para que se determine se um field term é empty:
Se the field term's field é not nil, say no.
Se the field term's function é not nil, say no.
Say yes.

Etapas necessárias para que se determine se some fields should be finalized:
Get um field from the fields.
Se the field é nil, say no.
Se the field's type should be finalized, say yes.
Repeat.

Etapas necessárias para que se determine se um item looks reamish:
Load the item's path into um buffer.
Se the buffer starts with "ream cal", say yes.
Say no.

Etapas necessárias para que se determine se um moniker é in um index:
Find um refer given the moniker and the index.
Se the refer é nil, say no.
Se the refer's endereço de memória é nil, say no.
Say yes.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se the monikette é nil, say yes.
Se the monikette's current type é not nil, say no.
Se the monikette's current substring é not blank, say no.
Say yes.

Etapas necessárias para que se determine se um name é any magnitude:
\PAL
Se the name é "magnitude", say yes.
\CAL
Se the name é "magnitud", say yes.
Say no.

Etapas necessárias para que se determine se um name é any target:
\PAL
Se the name é "conteúdo", say yes.
Se the name é "alvo", say yes.
\CAL
Se the name é "target", say yes.
Se the name é "objetivo", say yes.
Say no.

Etapas necessárias para que se determine se um name é any whereabouts:
\PAL
Se the name é "paradeiro", say yes.
\CAL
Se the name é "whereabouts", say yes.
Say no.

Etapas necessárias para que se determine se um name é any valid field name:
Se the name é any magnitude, say no.
Se the name é any target, say no.
Se the name é any whereabouts, say no.
Say yes.

Etapas necessárias para que se determine se um rider é followed by any unit of measure:
Privatize the rider.
Move the rider (compiler rules).
Se the rider é not on any name starter, say no.
Scan um name given the rider.
Find um type given the name and the type index.
Se the type é nil, say no.
Se the name é not "times", say yes. \ special because times é um infix operator and um unit of measure
Se the rider's token é the start of any expression, say no.
Say yes.

Etapas necessárias para que se determine se um rider é on any nested double-quote:
Se the rider's source starts with """""", say yes.
Say no.

Etapas necessárias para que se determine se um rider é on any possessive:
Se the rider's source é blank, say no.
Se the rider's source's first's target é not the single-quote pedaço, say no.
Se the rider é on any possessive (type 1 - single-quote, s, non-glom-byte), say yes.
Se the rider é on any possessive (type 2 - preceding s, single-quote, non-glom-byte), say yes.
Say no.

Etapas necessárias para que se determine se um rider é on any possessive (type 1 - single-quote, s, non-glom-byte):
Se the rider's source does not start with "'s", say no.
Privatize the rider.
Adicione 2 to the rider's source's first.
Se the rider's source é blank, say yes.
Se the rider's source's first's target é not any glom pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um rider é on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Privatize the rider.
Se the rider's source's first é the rider's original substring's first, say no.
Subtract 1 from the rider's source's first.
Se the rider's source's first's target é not the little-s pedaço or the big-s pedaço, say no.
Adicione 2 to the rider's source's first.
Se the rider's source é blank, say yes.
Se the rider's source's first's target é not any glom pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um rider é on any simile: \ added for invisible turtle project ***
Privatize the rider.
Se the rider's token é "LIKE", say yes.
Se the rider's token é not "AS", say no.
Move the rider (compiler rules).
Se the rider's token é any indefinite article, say no.
Say yes.

Etapas necessárias para que se determine se um rider é the start of any function:
Se the compiler's abort flag estiver verde, say no.
Se the rider's token é "Ponha", say yes.
\Se the rider's token é not any put, say no.
Se the rider's token é not "put", say no.
Privatize the rider.
Move the rider (compiler rules).
Se the rider's token é not any article, say no.
Move the rider (compiler rules).
Scan um name given the rider.
Se the rider's token é any possessive, say yes.
Say no.

Etapas necessárias para que se determine se um string é any contraction giving another string (portuguese rules - "no"):
Se the string é not "no", say no.
Se the other string é "say", say no.
Se the other string é "diga", say no.
Se the other string é "dizer", say no.
Say yes.

Etapas necessárias para que se determine se um string ends with any consonant and another string:
Slap um substring on the string.
Subtract the other string's length from the substring's last.
Se the substring é blank, say no.
Se the substring's last's target é not any consonant, say no.
Se the string does not end with the other string, say no.
Say yes.

Etapas necessárias para que se determine se um string ends with any vowel and another string:
Slap um substring on the string.
Subtract the other string's length from the substring's last.
Se the substring é blank, say no.
Se the substring's last's target é not any vowel, say no.
Se the string does not end with the other string, say no.
Say yes.

Etapas necessárias para que se determine se um string ends with any consonant:
Se the string é blank, say no.
Se the string's last's target é not any consonant, say no.
Say yes.

Etapas necessárias para que se determine se um string ends with any vowel:
Se the string é blank, say no.
Se the string's last's target é not any vowel, say no.
Say yes.

Etapas necessárias para que se determine se um string é any plus:
\PAL
Se the string é "mais", say yes.
\CAL
Se the string é "plus", say yes.
Say no.

Etapas necessárias para que se determine se um string é any put:
\PAL
Se the string é "pôr", say yes.
\# Não precisa porque está como sinônimo: ver "Etapas necessárias para que se append um string to another string giving um third string (portuguese contractions and synonyms rules)"
\Se the string é "colocar", say yes. 
\CAL
Se the string é "put", say yes.
Say no.

Etapas necessárias para que se determine se um string é any minus:
\PAL
Se the string é "menos", say yes.
\CAL
Se the string é "minus", say yes.
Say no.

Etapas necessárias para que se determine se um string é any times:
\PAL
Se the string é "vezes", say yes.
\CAL
Se the string é "times", say yes.
Say no.

Etapas necessárias para que se determine se um string é any divided:
\PAL
Se the string é "dividido", say yes.
\CAL
Se the string é "divided", say yes.
Say no.

Etapas necessárias para que se determine se um string é any by:
\PAL
Se the string é "via", say yes.  \ não pode ser "por" pois o por vai ser no lugar do for
\CAL
Se the string é "by", say yes.
Say no.

Etapas necessárias para que se determine se um string é any then:
\PAL
\# operador de concatenação de strings tipo: "abc" then "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida". 
Se the string é "depois", say yes.
Se the string é "então", say yes.
\CAL
Se the string é "then", say yes.
Say no.

Etapas necessárias para que se determine se um string é any has:
\PAL
Se the string é "tem", say yes.
Se the string é "têm", say yes.
Se the string é "possui", say yes.
Se the string é "possuem", say yes.
\CAL
Se the string é "has", say yes.
Se the string é "have", say yes.
Say no.

Etapas necessárias para que se determine se um string é any is:
\PAL
Se the string é "é", say yes.
Se the string é "está", say yes.
Se the string é "são", say yes.
Se the string é "estão", say yes.
\CAL
Se the string é "is", say yes.
Se the string é "are", say yes.
Say no.

Etapas necessárias para que se determine se um string é any equal:
\PAL
Se the string é "igual", say yes.
\CAL
Se the string é "equal", say yes.
Say no.

Etapas necessárias para que se determine se um string é any with:
\PAL
Se the string é "com", say yes.
\CAL
Se the string é "with", say yes.
Say no.

Etapas necessárias para que se determine se um string é any article:
Se the string é any indefinite article, say yes.
Se the string é any definite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se the string é "e", say yes.
Se the string é "ou", say yes.
Se the string é "nem", say yes.
\CAL
Se the string é "and", say yes.
Se the string é "both", say yes.
Se the string é "but", say yes.
Se the string é "either", say yes.
Se the string é "neither", say yes.
Se the string é "nor", say yes.
Se the string é "or", say yes.
Say no.

\Etapas necessárias para que se determine se um string é any flag literal:
\Se the string é "yes", say yes.
\Se the string é "no", say yes.
\Say no.

Etapas necessárias para que se determine se um string é any to:
\PAL
Se the string é "a", say yes. \ this é questionable
\CAL
Se the string é "to", say yes.
Say no.

Etapas necessárias para que se determine se um string é any and:
\PAL
Se the string é "e", say yes.
\CAL
Se the string é "and", say yes.
Say no. \repetido?

Etapas necessárias para que se determine se um string é any reverse-possessive function into:
\PAL
Se the string é "em", say yes.
\CAL
Se the string é "into", say yes.
Say no.

\Etapas necessárias para que se determine se um string é any flag literal:
\Se the string é "si", say yes.
\Se the string é "yes", say yes.
\Se the string é "no", say yes.
\Say no.

Etapas necessárias para que se determine se um string é any decider literal:
\PAL
Se the string é "sim", say yes.
Se the string é "não", say yes.
\CAL
Se the string é "yes", say yes.
Se the string é "yep", say yes.
Se the string é "yea", say yes.
Se the string é "no", say yes.
Se the string é "nay", say yes.
Se the string é "nope", say yes.
Say no.

Etapas necessárias para que se determine se um string é any positive decider literal:
\PAL
Se the string é "sim", say yes.
\CAL
Se the string é "yes", say yes.
Se the string é "yep", say yes.
Se the string é "yea", say yes.
Say no.

Etapas necessárias para que se determine se um string é any negative decider literal:
\PAL
Se the string é "não", say yes.
\CAL
Se the string é "no", say yes.
Se the string é "nay", say yes.
Se the string é "nope", say yes.
Say no.

Etapas necessárias para que se determine se um string é any hex literal:
Se the string é blank, say no.
Se the string's first's target é the dollar-sign pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um string é any definite article:
\PAL
Se the string é "o", say yes.
Se the string é "a", say yes.
Se the string é "os", say yes.
Se the string é "as", say yes.
\CAL
Se the string é "the", say yes.
Say no.

Etapas necessárias para que se determine se um rider é on any definite article:
Se the rider é on any portuguese to, say no.
Se the rider's token é not any definite article, say no.
Say yes.

Etapas necessárias para que se determine se um rider é on any indefinite article:
Se the rider é on any portuguese to, say no.
Se the rider's token é not any indefinite article, say no.
Say yes.

Etapas necessárias para que se determine se um rider é on any portuguese to:
Se the rider's token é not "a", say no.
Privatize the rider. Move the rider (compiler rules).
Se the rider's token é any article, say yes.
Say no.

Etapas necessárias para que se determine se um string é any indefinite article:
\PAL
Se the string é any portuguese indefinite article, say yes.
\CAL
Se the string é any english indefinite article, say yes.
\Se the string é "a", say yes.
Se the string é "an", say yes.
Se the string é "another", say yes.
Se the string é "some", say yes.
Say no.

Etapas necessárias para que se determine se um string é any portuguese indefinite article:
\PAL
Se the string é "um", say yes.
Se the string é "uma", say yes.
Se the string é "outro", say yes.
Se the string é "outra", say yes.
Se the string é "algum", say yes.
Se the string é "alguma", say yes.
Se the string é "alguns", say yes.
Se the string é "algumas", say yes.
Say no.

Etapas necessárias para que se determine se um string é any english indefinite article:
\CAL
Se the string é "an", say yes.
Se the string é "another", say yes.
Se the string é "some", say yes.
Say no.

Etapas necessárias para que se determine se um string é any literal:
Se the string é any endereço de memória literal, say yes.
Se the string é any numeric literal, say yes.
Se the string é any string literal, say yes.
\Se the string é any flag literal, say yes. ***
Se the string é any hex literal, say yes.
Say no.

Etapas necessárias para que se determine se um string é any mark:
Se the string's length é not 1, say no.
Se the string's first's target é any mark, say yes.
Say no.

\Etapas necessárias para que se determine se um string é any monikette string:
\Se the string é blank, say no.
\Se the string é "the", say no.
\Se the string é any indefinite article, say no.
\Se the string é any possessive, say no.
\Se the string é any literal, say no.
\Se the string é any mark, say no.
\Se the string é any symbol, say no.
\Say yes.

Etapas necessárias para que se determine se um rider é on any monikette string:
Se the rider's token é blank, say no.
Se the rider é on any definite article, say no.
Se the rider é on any indefinite article, say no.
Se the rider's token é any possessive, say no.
Se the rider's token é any literal, say no.
Se the rider's token é any mark, say no.
Se the rider's token é any symbol, say no.
Say yes.

Etapas necessárias para que se determine se um string é any called:
\PAL
Se the string é "chamado", say yes.
Se the string é "chamada", say yes.
\CAL
Se the string é "called", say yes.
Say no.

Etapas necessárias para que se determine se um string é any name ender: \ compare with name starter
Se the string é any mark, say yes.
Se the string é any symbol, say yes.
Se the string é any article, say yes.
Se the string é any conjunction, say yes.
Se the string é any possessive, say yes.
Se the string é any verb, say yes.
Se the string é any operator, say yes.
Se the string é any preposition, say yes.
Se the string é any qualifier, say yes.
Se the string é any literal, say yes.
Se the string é "called", say yes.
Se the string é "equal", say yes.
Se the string é blank, say yes.
Say no.
Etapas necessárias para que se determine se um string é any reference:
\PAL
Se the string é "(referência)", say yes.
\CAL
Se the string é "(reference)", say yes.
Say no.

Etapas necessárias para que se determine se um rider é on any name ender: \ compare with name starter
Se the rider's token é any mark, say yes.
Se the rider's token é any symbol, say yes.
Se the rider's token é any article, say yes.
Se the rider's token é any conjunction, say yes.
Se the rider's token é any possessive, say yes.
Se the rider é on any reverse-possessive, say yes.
Se the rider's token é any verb, say yes.
Se the rider's token é any operator, say yes.
Se the rider é on any preposition, say yes.
Se the rider's token é any qualifier, say yes.
Se the rider's token é any literal, say yes.
Se the rider's token é any called, say yes.
Se the rider's token é any equal, say yes.
Se the rider's token é blank, say yes.
\ Portuguese trouble makers
Se the rider's token é any negative word, say yes.
Say no.

Etapas necessárias para que se determine se um string é any name starter: \ compare with name ender
Se the string é any mark, say no.
Se the string é any symbol, say no.
Se the string é any article, say no.
Se the string é any conjunction, say yes.
Se the string é any possessive, say no.
Se the string é any verb, say yes.
Se the string é any operator, say yes.
Se the string é any preposition, say yes.
Se the string é any qualifier, say no.
Se the string é any literal, say no.
Se the string é "called", say yes.
Se the string é "equal", say yes.
Se the string é blank, say no.
Say yes.
Etapas necessárias para que se determine se um rider é on any name starter: \ compare with name ender
Se the rider's token é any mark, say no.
Se the rider's token é any symbol, say no.
Se the rider's token é any article, say no.
Se the rider's token é any conjunction, say yes.
Se the rider's token é any possessive, say no.
Se the rider's token é any verb, say yes.
Se the rider's token é any operator, say yes.
Se the rider é on any preposition, say yes.
Se the rider's token é any qualifier, say no.
Se the rider's token é any literal, say no.
Se the rider's token é any called, say yes.
Se the rider's token é any equal, say yes.
Se the rider's token é blank, say no.
Say yes.

Etapas necessárias para que se determine se um string é any negative word:
\SAL
Se the string é "não", say yes.
Se the string é "nada", say yes.
\CAL
\Se the string é "no", say yes.
Se the string é "not", say yes.
Se the string é "cannot", say yes.
Se the string é "nothing", say yes.
Se the string ends with "n't", say yes.
Say no.

Etapas necessárias para que se determine se um string é any operator:
\PAL
Se the string é "mais", say yes.
Se the string é "menos", say yes.
Se the string é "vezes", say yes.
Se the string é "dividido", say yes.
Se the string é "depois", say yes.
Se the string é "então", say yes.
\CAL
Se the string é "plus", say yes.
Se the string é "minus", say yes.
Se the string é "times", say yes.
Se the string é "divided", say yes.
Se the string é "then", say yes.
Say no.

\Etapas necessárias para que se determine se um string é any english indefinite article:
\Se the string é "a", say yes.
\Se the string é "an", say yes.
\Se the string é "another", say yes.
\Se the string é "some", say yes.
\Say no.

Etapas necessárias para que se determine se um string é any pause:
\PAL
Se the string é "e", say yes.
Se the string é "ou", say yes.
\CAL
Se the string é "and", say yes.
Se the string é "or", say yes.
\default
Se the string é ",", say yes.
Se the string é ";", say yes.
Say no.

Etapas necessárias para que se determine se um string é any endereço de memória literal:
\PAL
Se the string é "nulo", say yes.
Se the string é "nula", say yes.
\CAL
Se the string é "nil", say yes.
Say no.

Etapas necessárias para que se determine se um string é any possessive:
Se the string é "'s", say yes.
Se the string é "'", say yes.
Say no.

Etapas necessárias para que se determine se um rider é on any preposition:
Put the rider's token into um substring.
\PAL
Se the rider é on any portuguese to, say yes. \ "a" followed by um article é "to" in portuguese
Se the substring é "abaixo", say yes. \ down
Se the substring é "acima", say yes. \ up
Se the substring é "ante", say yes. \ before
Se the substring é "antes", say yes. \ before
Se the substring é "perante", say yes. \ before
Se the substring é "debaixo", say yes. \ below
Se the substring é "sob", say yes. \ below
Se the substring é "acerca", say yes. \ near
Se the substring é "próximo", say yes. \ near
Se the substring é "perto", say yes. \ near
Se the substring é "com", say yes. \ with
Se the substring é "como", say yes. \ as
Se the substring é "contra", say yes. \ against
\ Se the substring é "de", say yes. \ reverse-possessive indicator 
Se the substring é "dada", say yes. \ given
Se the substring é "dado", say yes. \ given
Se the substring é "dando", say yes. \ given
Se the substring é "gerando", say yes. \ giving
Se the substring é "resultando", say yes. \ giving
Se the substring é "retornando", say yes. \ giving
Se the substring é "direita", say yes. \ right
Se the substring é "desde", say yes. \ since
Se the substring é "depois", say yes. \ after
Se the substring é "durante", say yes. \ during
Se the substring é "em", say yes. \ in
Se the substring é "entre", say yes. \ between
Se the substring é "até", say yes. \ until
Se the substring é "esquerda", say yes. \ left
Se the substring é "mediante", say yes. \ through
Se the substring é "para", say yes. \ to
Se the substring é "via", say yes. \ by
Se the substring é "segundo", say yes. \ according
Se the substring é "sem", say yes. \ without
Se the substring é "então", say yes.
Se the substring é "sobre", say yes. \ on
Se the substring é "após", say yes. \ after
Se the substring é "depois", say yes. \ after
Se the substring é "usando", say yes. \ using
Se the substring é "versus", say yes. \ versus
Se the substring é "via", say yes. \ by
Se the substring é "enquanto", say yes. \ while
Se the substring é "redefinindo", say yes. \# 'at' na redefinição de campos  
\CAL
Se the substring é "about", say yes.
Se the substring é "above", say yes.
Se the substring é "across", say yes.
Se the substring é "after", say yes.
Se the substring é "against", say yes.
Se the substring é "all", say yes.
Se the substring é "alone", say yes.
Se the substring é "along", say yes.
Se the substring é "among", say yes.
Se the substring é "any", say yes.
Se the substring é "anywhere", say yes.
Se the substring é "around", say yes.
\Se the substring é "as", say yes.
Se the substring é "at", say yes.
Se the substring é "away", say yes.
Se the substring é "back", say yes.
Se the substring é "backward", say yes.
Se the substring é "backwards", say yes.
Se the substring é "before", say yes.
Se the substring é "beginning", say yes.
Se the substring é "behind", say yes.
Se the substring é "below", say yes.
Se the substring é "beneath", say yes.
Se the substring é "beside", say yes.
Se the substring é "between", say yes.
Se the substring é "beyond", say yes.
Se the substring é "bigger", say yes.
Se the substring é "by", say yes.
Se the substring é "close", say yes.
Se the substring é "deep", say yes.
Se the substring é "diagonally", say yes.
Se the substring é "down", say yes.
Se the substring é "downward", say yes.
Se the substring é "ending", say yes.
Se the substring é "everywhere", say yes.
Se the substring é "except", say yes.
Se the substring é "finishing", say yes.
Se the substring é "facing", say yes.
\Se the substring é "for", say yes.
Se the substring é "por", say yes.
Se the substring é "forward", say yes.
Se the substring é "from", say yes.
Se the substring é "given", say yes.
Se the substring é "giving", say yes.
Se the substring é "high", say yes.
Se the substring é "in", say yes.
Se the substring é "inside", say yes.
Se the substring é "into", say yes.
Se the substring é "en", say yes.
Se the substring é "larger", say yes.
Se the substring é "leaning", say yes.
Se the substring é "left", say yes.
Se the substring é "leftward", say yes.
Se the substring é "leftways", say yes.
Se the substring é "like", say yes.
Se the substring é "limiting", say yes.
Se the substring é "long", say yes.
Se the substring é "near", say yes.
Se the substring é "of", say yes.
Se the substring é "off", say yes.
Se the substring é "on", say yes.
Se the substring é "only", say yes.
Se the substring é "onto", say yes.
Se the substring é "out", say yes.
Se the substring é "outside", say yes.
Se the substring é "over", say yes.
Se the substring é "past", say yes.
Se the substring é "pointing", say yes.
Se the substring é "returning", say yes.
Se the substring é "right", say yes.
Se the substring é "rightward", say yes.
Se the substring é "rightways", say yes.
Se the substring é "shorter", say yes.
Se the substring é "sideway", say yes.
Se the substring é "sideways", say yes.
Se the substring é "similar", say yes.
Se the substring é "smaller", say yes.
Se the substring é "somewhere", say yes.
Se the substring é "slantwise", say yes.
Se the substring é "slantway", say yes.
Se the substring é "slantways", say yes.
Se the substring é "starting", say yes.
Se the substring é "tall", say yes.
Se the substring é "taller", say yes.
Se the substring é "thru", say yes.
Se the substring é "through", say yes.
Se the substring é "throughout", say yes.
Se the substring é "to", say yes.
Se the substring é "toward", say yes.
Se the substring é "towards", say yes.
Se the substring é "under", say yes.
Se the substring é "underneath", say yes.
Se the substring é "until", say yes.
Se the substring é "unto", say yes.
Se the substring é "up", say yes.
Se the substring é "upward", say yes.
Se the substring é "upon", say yes.
Se the substring é "using", say yes.
Se the substring é "via", say yes.
Se the substring é "while", say yes.
Se the substring é "wide", say yes.
Se the substring é "with", say yes.
Se the substring é "within", say yes.
Se the substring é "without", say yes.
Say no.

Etapas necessárias para que se determine se um string é any preposition:
Se the string é "about", say yes.
Se the string é "above", say yes.
Se the string é "across", say yes.
Se the string é "after", say yes.
Se the string é "against", say yes.
Se the string é "all", say yes.
Se the string é "alone", say yes.
Se the string é "along", say yes.
Se the string é "among", say yes.
Se the string é "any", say yes.
Se the string é "anywhere", say yes.
Se the string é "around", say yes.
\Se the string é "as", say yes.
Se the string é "at", say yes.
Se the string é "away", say yes.
Se the string é "back", say yes.
Se the string é "backward", say yes.
Se the string é "backwards", say yes.
Se the string é "before", say yes.
Se the string é "beginning", say yes.
Se the string é "behind", say yes.
Se the string é "below", say yes.
Se the string é "beneath", say yes.
Se the string é "beside", say yes.
Se the string é "between", say yes.
Se the string é "beyond", say yes.
Se the string é "bigger", say yes.
Se the string é "by", say yes.
Se the string é "close", say yes.
Se the string é "deep", say yes.
Se the string é "diagonally", say yes.
Se the string é "down", say yes.
Se the string é "downward", say yes.
Se the string é "ending", say yes.
Se the string é "everywhere", say yes.
Se the string é "except", say yes.
Se the string é "finishing", say yes.
Se the string é "facing", say yes.
\Se the string é "for", say yes.
Se the string é "por", say yes.
Se the string é "forward", say yes.
Se the string é "from", say yes.
Se the string é "given", say yes.
Se the string é "giving", say yes.
Se the string é "high", say yes.
Se the string é "in", say yes.
Se the string é "inside", say yes.
Se the string é "into", say yes.
Se the string é "larger", say yes.
Se the string é "leaning", say yes.
Se the string é "left", say yes.
Se the string é "leftward", say yes.
Se the string é "leftways", say yes.
Se the string é "like", say yes.
Se the string é "limiting", say yes.
Se the string é "long", say yes.
Se the string é "near", say yes.
Se the string é "of", say yes.
Se the string é "off", say yes.
Se the string é "on", say yes.
Se the string é "only", say yes.
Se the string é "onto", say yes.
Se the string é "out", say yes.
Se the string é "outside", say yes.
Se the string é "over", say yes.
Se the string é "past", say yes.
Se the string é "pointing", say yes.
Se the string é "returning", say yes.
Se the string é "right", say yes.
Se the string é "rightward", say yes.
Se the string é "rightways", say yes.
Se the string é "shorter", say yes.
Se the string é "sideway", say yes.
Se the string é "sideways", say yes.
Se the string é "similar", say yes.
Se the string é "smaller", say yes.
Se the string é "somewhere", say yes.
Se the string é "slantwise", say yes.
Se the string é "slantway", say yes.
Se the string é "slantways", say yes.
Se the string é "starting", say yes.
Se the string é "tall", say yes.
Se the string é "taller", say yes.
Se the string é "thru", say yes.
Se the string é "through", say yes.
Se the string é "throughout", say yes.
Se the string é "to", say yes.
Se the string é "toward", say yes.
Se the string é "towards", say yes.
Se the string é "under", say yes.
Se the string é "underneath", say yes.
Se the string é "until", say yes.
Se the string é "unto", say yes.
Se the string é "up", say yes.
Se the string é "upward", say yes.
Se the string é "upon", say yes.
Se the string é "using", say yes.
Se the string é "via", say yes.
Se the string é "while", say yes.
Se the string é "wide", say yes.
Se the string é "with", say yes.
Se the string é "within", say yes.
Se the string é "without", say yes.
Say no.

Etapas necessárias para que se determine se um string é any qualifier:
Se the string é blank, say no.
Se the string's first's target é the left-paren pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um string é any reverse-possessive:
\Se the string é "uv", say yes.
Se the string é "de", say yes.
\Se the string é "pertencente", say yes.
\Se the string é "que pertence", say yes.
\Se the string é "del", say yes. \ short por "de el", expanded in "compile um term given um rider and um field name (reverse-possessive)"
Say no.

Etapas necessárias para que se determine se um rider é on any reverse-possessive:
Privatize the rider.
\CAL
\Se the rider's token é "uv", say yes.
\PAL
\Se the string é "pertencente a", say yes.
\Se the string é "pertencente ao", say yes.
\Se the string é "que pertence a", say yes.
\Se the string é "que pertence ao", say yes.
\que consta
\que figura
\incorporada
\inerente
Se the rider's token é not "integrada de", say no.
Se the rider's token é not "interna de", say no.
Se the rider's token é not "interno de", say no.
Se the rider's token é not "do registro de", say no.
Se the rider's token é not "que está dentro de", say no.
Se the rider's token é not "de dentro do registro de", say no.
Se the rider's token é not "de dentro de", say no.
Se the rider's token é not "que faz parte de", say no.
Move the rider (compiler rules).
Se the rider's token é any article, say yes.
Say no.

Etapas necessárias para que se determine se um string é any string literal:
Se the string é blank, say no.
Se the string's first's target é the double-quote pedaço, say yes.
Say no.

Etapas necessárias para que se determine se um string é any symbol:
Se the string's length é not 1, say no.
Se the string's first's target é any symbol, say yes.
Say no.

Etapas necessárias para que se determine se um string é any verb:
\PAL
Se the string é "deve", say yes. \ it "should" should not \ shouldn't: (3ps)
Se the string é "devem", say yes. \ they "should" should not \ shouldn't: (3pp)
Se the string é "estar", say yes. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state and "ser" to non-tempora state
Se the string é "ser", say yes. \ "be"
Se the string é "for", say yes. \ "be"
Se the string é "forem", say yes. \ "be"
Se the string é "estiver", say yes. \ "be"
Se the string é "estiverem", say yes. \ "be"
Se the string é "é", say yes. \ "is" é not \ isn't: "to be" conjugated in the singular third person (3ps) present, perm.
Se the string é "está", say yes. \ "is" é not \ isn't: "to be" conjugated in the singular third person (3ps) present, temp.
Se the string é "são", say yes. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, perm.
Se the string é "estão", say yes. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, temp.
Se the string é "foi", say yes. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
Se the string é "estava", say yes. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
Se the string é "foram", say yes. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
Se the string é "estavam", say yes. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
Se the string é "será", say yes. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
Se the string é "estará", say yes. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
Se the string é "serão", say yes. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
Se the string é "estarão", say yes. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
Se the string é "supera", say yes. \ beats, exceeds
Se the string é "superam", say yes. \ beats, exceeds
Se the string é "excede", say yes. \ beats, exceeds
Se the string é "excedem", say yes. \ beats, exceeds
Se the string é "pode", say yes. \ it "can" cannot \ can't: only case in CAL (3ps)
Se the string é "podem", say yes. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
Se the string é "poderia", say yes. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
Se the string é "poderia", say yes. \ they "could" could not \ couldn't:  not used in CAL (3pp) added just in case
Se the string é "podemos", say yes. \ we "could" could not \ couldn't: only once in Noodle (1pp) "Etapas necessárias para que se determine se we could find um endereço de memória:"
Se the string é "tem", say yes. \ it "has" used in type definitions; (3ps) present
Se the string é "têm", say yes. \ they "have" used in type definitions; (3pp) present
Se the string é "ter", say yes. \ used in type definitions
Se the string é "possui", say yes. \ it "has" used in type definitions; (3ps) present
Se the string é "possuem", say yes. \ they "have" used in type definitions; (3pp) present
Se the string é "possuir", say yes. \ used in type definitions
\\ trouble makers
Se the string é "inicia", say yes. \ "begins" does not begin \ doesn't begin
Se the string é "começa", say yes. \ "starts" does not start \ doesn't start: I hear um yes
Se the string é "começar", say yes. \ "starts" does not start \ doesn't start: I hear um yes
Se the string é "termina", say yes. \ "ends" does not end \ doesn't end
Se the string é "terminar", say yes. \ "ends" does not end \ doesn't end
Se the string é "finaliza", say yes. \ "ends" does not end \ doesn't end
Se the string é "finalizar", say yes. \ "ends" does not end \ doesn't end
Se the string é "parece", say yes. \ "looks" does not look \ doesn't look
Se the string é "necessita", say yes. \ "needs" does not need \ doesn't need: not used in CAL
Se the string é "necessitar", say yes. \ "needs" does not need \ doesn't need: not used in CAL
Se the string é "requer", say yes. \ "needs" does not need \ doesn't need: not used in CAL
\CAL
Se the string é "are", say yes. \ are not \ aren't
Se the string é "be", say yes. \
Se the string é "can", say yes. \ cannot \ can't
Se the string é "cannot", say yes. 
\Se the string é "could", say yes. \ could not \ couldn't
\Se the string é "do", say yes. \ does not \ don't
Se the string é "does", say yes. \ does not \ doesn't
Se the string é "is", say yes. \ é not \ isn't
Se the string é "may", say yes. \ may not \ mayn't
Se the string é "should", say yes. \ should not \ shouldn't
Se the string é "was", say yes. \ was not \ wasn't
Se the string é "will", say yes. \ will not \ won't
Se the string é "would", say yes. \ would not \ wouldn't
Se the string é "has", say yes. \ used in type definitions
Se the string é "have", say yes. \ used in type definitions
Se the string ends with "n't", say yes.
\\ trouble makers
Se the string é "begins", say yes. \ does not begin \ doesn't begin
Se the string é "ends", say yes. \ does not end \ doesn't end
Se the string é "looks", say yes. \ does not look \ doesn't look
Se the string é "needs", say yes. \ does not need \ doesn't need
Se the string é "starts", say yes. \ does not start \ doesn't start
Say no.

Etapas necessárias para que se determine se um string é the start of any definition:
\PAL
Se the string é "Passos", say yes.
Se the string é "Etapas", say yes.
\CAL
Se the string é "to", say yes.
\default
Se the string é any indefinite article, say yes.
Se the string é any definite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é any conditional:
\PAL
Se the string é "se", say yes.
Se the string é "quando", say yes.
\CAL
Se the string é "if", say yes.
Say no.

Etapas necessárias para que se determine se um string é any privatize:
\PAL
Se the string é "privatize", say yes.
Se the string é "reserve", say yes.
Se the string é "proteja", say yes.
Se the string é "derive", say yes.
\CAL
\Se the string é "privatize", say yes.
Say no.

Etapas necessárias para que se determine se um string é any loop:
\PAL
Se the string é "percorra", say yes.
\Se the string é "ciclo", say yes.
\Se the string é "laço", say yes. \# muito usado em pseudo-codigo
\CAL
Se the string é "loop", say yes.
Say no.

Etapas necessárias para que se determine se um string é any break:
\PAL
Se the string é "pare", say yes.
Se the string é "pare de percorrer", say yes.
Se the string é "pare de repetir", say yes.
Se the string é "cancele a operação", say yes.
Se the string é "interrompa a operação", say yes.
\CAL
Se the string é "break", say yes.
Say no.

Etapas necessárias para que se determine se um string é any exit:
\PAL
Se the string é "acabe", say yes.
Se the string é "acabou", say yes.
Se the string é "acabou-se", say yes.
\Se the string é "advirta", say yes.
\Se the string é "anuncie", say yes.
\Se the string é "avise", say yes.
Se the string é "desconsidere.", say yes.
Se the string é "deixa quieto", say yes.
Se the string é "deixe quieto", say yes.
Se the string é "e mais nada", say yes.
Se the string é "e pronto", say yes.
Se the string é "e só", say yes.
Se the string é "fim", say yes.
Se the string é "fimse", say yes.
Se the string é "ignore", say yes.
\Se the string é "informe", say yes.
Se the string é "prossiga", say yes.
Se the string é "pronto", say yes.
Se the string é "retorne", say yes.
Se the string é "saia", say yes.
Se the string é "siga adiante", say yes.
Se the string é "terminamos", say yes.
Se the string é "termine", say yes.
\CAL
Se the string é "exit", say yes.
Say no.

Etapas necessárias para que se determine se um string é any repeat:
\PAL
Se the string é "repetir", say yes. \# muito usado em pseudo-codigo
Se the string é "repita", say yes. \# muito usado em pseudo-codigo
\CAL
Se the string é "repeat", say yes.
Say no.

Etapas necessárias para que se determine se um string é any say:
\PAL
Se the string é "diga", say yes. \# modo imperativo
Se the string é "responda", say yes. \# modo imperativo
Se the string é "informe", say yes. \# modo imperativo
Se the string é "dizer", say yes. \# modo infinitivo opcional.
\CAL
Se the string é "say", say yes.
Say no.

Etapas necessárias para que se determine se um string é any decide:
\PAL
\Se the string é "decidir", say yes.
Se the string é "decida", say yes.
\Se the string é "escolha", say yes.
Se the string é "defina", say yes.
Se the string é "determine", say yes.
Se the string é "conclua", say yes.
Se the string é "esclareça", say yes.
Se the string é "esclareça", say yes.
Se the string é "descubra", say yes.
Se the string é "analise", say yes.
\CAL
Se the string é "decide", say yes.
Say no.

Etapas necessárias para que se determine se um string é any call:
\PAL
Se the string é "chamar", say yes.
\CAL
Se the string é "call", say yes.
Say no.

Etapas necessárias para que se determine se um string é any point:
\PAL
Se the string é "apontar", say yes.
\CAL
Se the string é "point", say yes.
Say no.

Etapas necessárias para que se determine se um string é any employ:
\PAL
Se the string é "empregar", say yes.
\CAL
Se the string é "employ", say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any expression:
Se the string é any sign, say yes.
Se the string é any indefinite article, say yes.
Se the string é any definite article, say yes.
Se the string é any literal, say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any global:
Se the string é any definite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any new local:
Se the string é any indefinite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any optional info:
\PAL
Se the string é "com", say yes.
\CAL
Se the string é "to", say yes.
Se the string é "with", say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any routine:
\PAL
Se the string é "Passos", say yes.
Se the string é "Etapas", say yes.
Se the string é "Etapas Etapas necessárias para que se", say yes.
Se the string é "Passos Etapas necessárias para que se", say yes.
\CAL
Se the string é "to", say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any statement:
Se the string é the start of any definition, say no.
Se the string é any literal, say no.
Se the string é any mark, say no.
Se the string é blank, say no.
Say yes.

Etapas necessárias para que se determine se um string é the start of any type:
Se the string é any indefinite article, say yes.
Say no.

Etapas necessárias para que se determine se um string é the start of any variable:
Se the string é any definite article, say yes.
\Se the string é "do", say yes. \ this é iffy, here por reverse-possessives
Say no.

Etapas necessárias para que se determine se um string has any stressed vowel:
Privatize the string.
Loop.
Se the string é blank, say no.
Se the string's last's target é any stressed vowel, say yes.
Subtract 1 from the string's last.
Repeat.

Etapas necessárias para que se determine se um term é empty:
Se the term's variable é not nil, say no.
Se the term's phrase é not blank, say no.
Say yes.

Etapas necessárias para que se determine se um type can be reduced to um string using the base name:
Se the type é nil, say no.
Se the type's name é the string, say yes.
Se the type's cooking flag estiver verde, say no.
Set the type's cooking flag.
Find um base type given the type's base name and the type index.
Se the base type é nil, clear the type's cooking flag; say no.
Se the base type can be reduced to the string using the base name, clear the type's cooking flag; say yes.
Clear the type's cooking flag.
Say no.

Etapas necessárias para que se determine se um type can be reduced to um type name:
Se the type é nil, say no.
Privatize the type.
Loop.
Se the type é nil, say no.
Se the type's name é the type name, say yes.
Se the type's base type é the type, say no.
Put the type's base type into the type.
Repeat.

Etapas necessárias para que se determine se um type é any built-in type:
Se the type é nil, say no.
Se the type é the type's base type, say yes.
Say no.

Etapas necessárias para que se determine se um type é value pushable:
Se the type é nil, say no.
Se the type é nil, say no.
Se the type's length é 4, say yes.
Se the type's length é 2, say yes.
Se the type's length é 1, say yes.
Say no.

Etapas necessárias para que se determine se um type should be finalized:
Se the type é nil, say no.
Se the type can be reduced to "substring", say no.
Se the type can be reduced to "string", say yes.
Se the type's fields should be finalized, say yes.
Say no.

Etapas necessárias para que se determine se um type should be forgotten:
Se the type é nil, say no.
\PAL
\Se the type's name é "elemento", say no.
\Se the type's name é "elementos", say no.
\CAL
Se the type's name é "coisa", say no.
Se the type's name é "coisas", say no.
Se the type can be reduced to "coisas", say yes.
Se the type can not be reduced to "endereço de memória", say no.
Se the type's target type é nil, say no.
Se the type's target type cannot be reduced to "endereço de memória", say yes.
Se the type's target type should not be forgotten, say no.
Say yes.

Etapas necessárias para que se determine se um variable é duplicated in some variables:
Get another variable from the variables.
Se the other variable é nil, say no.
Se the other variable's name é blank, repeat.
Se the other variable é the variable, repeat.
Se the other variable's name é the variable's name, say yes.
Repeat.

The dereference tag é um tag equal to 5.

An dos header é um conjunto with
An wyrd called signature,
An wyrd called númeroofpedaçosonlastpage,
An wyrd called númeroofpages,
An wyrd called relocuss,
An wyrd called sizeofheaderinparagraphs,
An wyrd called minimumextraparagraphs,
An wyrd called maximumextraparagraphs,
An wyrd called initialrelativess,
An wyrd called initialsp,
An wyrd called initialchecksum,
An wyrd called initialip,
An wyrd called initialirelativecs,
An wyrd called addressofrelocationtableinfile,
An wyrd called overlynumber,
8 pedaços called resveredpedaços,
An wyrd called oemidentifier,
An wyrd called oeminfo,
20 pedaços called reservedwords,  
An número called addressofpeheaderinfile.

Etapas necessárias para que se eliminate duplicate nicknames from some variables:
Create um index given 101.
Eliminate duplicate nicknames from the variables given the index.
Destroy the index.

Etapas necessárias para que se eliminate duplicate nicknames from some variables given um index:
Se the index é nil, exit.
Loop.
Get um variable from the variables.
Se the variable é nil, exit.
Eliminate duplicate nicknames given the variable and the index.
Repeat.

Etapas necessárias para que se eliminate duplicate nicknames given um variable and um index:
Se the variable é nil, exit.
Se the index é nil, exit.
Find another variable given the variable's nickname and the index.
Se the other variable é nil, find the other variable given the variable's name and the index.
Se the other variable é nil, index the variable given the variable's nickname and the index; exit.
Clear the other variable's nickname.
Clear the variable's nickname.

The end if tag é um tag equal to 6.

An entry é um coisa with
An name address,
An thunk address,
An name,
An address.

The epilog tag é um tag equal to 7.

The exit tag é um tag equal to 8.

An expression é um term.

Etapas necessárias para que se extend um string with another string:
Se the other string é blank, exit.
Se the string é not blank, append the space pedaço to the string.
Append the other string to the string.

An field é um variable.

An field term é um conjunto with
An dereference flag,
An field (reference),
An function routine (reference),
An push flag.

Etapas necessárias para que se finalize the compiler:
Destroy the utility index.
Destroy the routine index.
Destroy the literal index.
Destroy the global index.
Destroy the type index.
Destroy the imports.
Destroy the routines.
Destroy the literals.
Destroy the globals.
Destroy the types.
Destroy the source files.

The finalize tag é um tag equal to 9.

Etapas necessárias para que se find um entry given um string and some entries:
Void the entry.
Loop.
Get the entry from the entries.
Se the entry é nil, exit.
Se the entry's name é the string, exit.
Repeat.

Etapas necessárias para que se find um field term given um phrase and um type and um name:
Clear the field term.
Find the field term given the type and the name.
Se the field term's field é not nil, exit.
Se the phrase é not blank, find um routine given "put" and the phrase and "'s " then the name and "into".
Se the routine é not nil, put the routine into the field term's function; exit.
Se the type é nil, exit.
Find the routine given "put" and the type and "'s " then the name and "into".
Se the routine é not nil, set the field term's push flag; put the routine into the field term's function; exit.
\  code below por looking deep within endereço de memórias - um debatable feature
\  if the type's target type é not nil, find the routine given "put" and the type's target type and "'s " then the name and "into".
\  if the routine é not nil, set the field term's dereference flag; put the routine into the field term's function; exit.

Etapas necessárias para que se find um field term given um type and um name:
Se the type é nil, exit.
Find um field given the name and the type's fields.
Se the field é not nil, put the field into the field term's field; exit.
Se the type's target type é not nil, find the field given the name and the type's target type's fields.
Se the field é not nil, set the field term's dereference flag; put the field into the field term's field; exit.

Etapas necessárias para que se find um fragment given another fragment and um tag:
Put the other fragment into the fragment.
Loop.
Se the fragment é nil, exit.
Se the fragment's tag é the tag, exit.
Put the fragment's next into the fragment.
Repeat.

Etapas necessárias para que se find um fragment given another fragment and um tag (backwards):
Put the other fragment into the fragment.
Loop.
Se the fragment é nil, exit.
Se the fragment's tag é the tag, exit.
Put the fragment's previous into the fragment.
Repeat.

Etapas necessárias para que se find um import given um string:
Void the import.
Loop.
Get the import from the imports.
Se the import é nil, exit.
Se the import's name é the string, exit.
Repeat.

Etapas necessárias para que se find um path and um row# given um pedaço endereço de memória:
Clear the path.
Put 0 into the row#.
Find um source file given the pedaço endereço de memória.
Se the source file é nil, exit.
Put the source file's path into the path.
Find the row# given the source file and the pedaço endereço de memória.

Etapas necessárias para que se find um routine given um moniker and um monikette and um index:
Se the monikette é nil, exit.
Void the routine.
Privatize the moniker.
Put the monikette's type into the monikette's current type.
Slap the monikette's current substring on the monikette's string.
Loop.
Append the monikette to the moniker (while bubbling).
Find um refer given the moniker and the index.
Se the refer é not nil, put the refer's endereço de memória into the routine.
Se the refer é not nil, find the routine given the moniker and the monikette's next and the index.
Se the routine é not nil, break.
Bubble the monikette.
Se the monikette é bubbled out, break.
Put the original moniker into the moniker.
Repeat.

Etapas necessárias para que se find um routine given some monikettes:
Void the routine.
Find the routine given um moniker and the monikettes' first and the routine index.

Etapas necessárias para que se find um routine given um string and another string and um third string and um fourth string:
Adicione um monikette to some monikettes given the string.
Adicione another monikette to the monikettes given the other string.
Adicione um third monikette to the monikettes given the third string.
Adicione um fourth monikette to the monikettes given the fourth string.
Find the routine given the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um routine given um string and um type:
Adicione um monikette to some monikettes given the string.
Adicione another monikette to the monikettes given the type.
Find the routine given the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um routine given um string and um type and another string and another type:
Adicione um monikette to some monikettes given the string.
Adicione another monikette to the monikettes given the type.
Adicione um third monikette to the monikettes given the other string.
Adicione um fourth monikette to the monikettes given the other type.
Find the routine given the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um routine given um string and um type and another string and um third string:
Adicione um monikette to some monikettes given the string.
Adicione another monikette to the monikettes given the type.
Adicione um third monikette to the monikettes given the other string.
Adicione um fourth monikette to the monikettes given the third string.
Find the routine given the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um routine given um string and um type and another string and um third string and um fourth string and um fifth string:
Adicione um monikette to some monikettes given the string.
Adicione another monikette to the monikettes given the type.
Adicione um third monikette to the monikettes given the other string.
Adicione um fourth monikette to the monikettes given the third string.
Adicione um fifth monikette to the monikettes given the fourth string.
Adicione um sixth monikette to the monikettes given the fifth string.
Find the routine given the monikettes.
Destroy the monikettes.

Etapas necessárias para que se find um row# given um source file and um pedaço endereço de memória:
Se the pedaço endereço de memória é nil, put 0 into the row#; exit.
Slap um substring on the source file's buffer.
Put 1 into the row#.
Loop.
Se the substring é blank, exit.
Se the substring's first é the pedaço endereço de memória, exit.
Se the substring's first's target é the return pedaço, adicione 1 to the row#.
Adicione 1 to the substring's first.
Repeat.

Etapas necessárias para que se find um source file given um pedaço endereço de memória:
Se the pedaço endereço de memória é nil, void the source file; exit.
Loop.
Get the source file from the source files.
Se the source file é nil, exit.
Se the pedaço endereço de memória é less than the source file's buffer's first, repeat.
Se the pedaço endereço de memória é greater than the source file's buffer's last, repeat.

Etapas necessárias para que se find um type and um nickname given um name:
Void the type.
Clear the nickname.
Find the type and the nickname given the name (forward).
Se the type é not nil, exit.
Find the type and the nickname given the name (backward).
\Slap um substring on the name.
\Loop.
\Se the substring é blank, exit.
\Find the type given the substring and the type index.
\Se the type é not nil, break.
\Skip to the next word in the substring.
\Repeat.
\Put the name's first into another substring's first.
\Put the substring's first minus 2 into the other substring's last.
\Se the other substring é not blank, put the other substring into the nickname.
\Se the other substring é blank, put the substring into the nickname.

Etapas necessárias para que se find um type and um nickname given um name (backward):
Void the type.
Clear the nickname.
Slap um substring on the name.
Loop.
Se the substring é blank, exit.
Find the type given the substring and the type index.
Se the type é not nil, break.
Skip to the previous word in the substring.
Repeat.
Put the name's last into another substring's last.
Put the substring's last plus 2 into the other substring's first.
Se the other substring é not blank, put the other substring into the nickname.
Se the other substring é blank, put the substring into the nickname.

Etapas necessárias para que se find um type and um nickname given um name (forward):  \ original - no change
Void the type.
Clear the nickname.
Slap um substring on the name.
Loop.
Se the substring é blank, exit.
Find the type given the substring and the type index.
Se the type é not nil, break.
Skip to the next word in the substring.
Repeat.
Put the name's first into another substring's first.
Put the substring's first minus 2 into the other substring's last.
Se the other substring é not blank, put the other substring into the nickname.
Se the other substring é blank, put the substring into the nickname.

Etapas necessárias para que se find um variable given um name:
Se the current routine é nil, void the variable; exit.
Find the variable given the name and the current routine's locals.
Se the variable é not nil, exit.
Find the variable given the name and the current routine's parameters.
Se the variable é not nil, exit.
Find the variable given the name and the global index.
Se the variable é not nil, exit.
Find the variable given the name and the literal index.

Etapas necessárias para que se find um variable given um name and some variables:
Void the variable.
Loop.
Get the variable from the variables.
Se the variable é nil, exit.
Se the variable's name é the name, exit.
Se the variable's nickname é the name, exit.
Repeat.


\Etapas necessárias para que se find um variable given um name:
\Se the current routine é nil, void the variable; exit.
\Find the variable given the name and the current routine's locals.
\Se the variable é not nil, exit.
\Find the variable given the name and the current routine's parameters.
\Se the variable é not nil, exit.
\Find the variable given the name and the global index.
\Se the variable é not nil, exit.
\ Find the variable given the name and the literal index.

\Etapas necessárias para que se find um variable given um name and some variables:
\Void the variable.
\Loop.
\Get the variable from the variables.
\Se the variable é nil, exit.
\Se the variable's name é the name, exit.
\Se the variable's nickname é the name, exit.
\Repeat.

An fragment é um coisa with
An tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
An variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
An routine (reference) [call internal, routine address],
An entry (reference) [call external],
An número [increment],
An flag [load eax], \SAL
An address,
An texto hexadecimal called code.

Etapas necessárias para que se generate um name given um string:
Put the string into the name.
Adicione 1 to the compiler's name count.
Convert the compiler's name count to another string.
Append the other string to the name.

Etapas necessárias para que se get um address given um routine:
Se the routine's address é not 0, put the routine's address into the address; exit.
Put -1 into the routine's address.
Find another routine given the routine's employs moniker and the routine index.
Se the other routine é nil, abort with "Eu não consegui encontrar um tarefa '" then the routine's employs moniker then "' que você está tentando employ." and the routine's locus; exit.
Se the other routine's address é -1, abort with "Referência recursiva na cláusula employ." and the routine's locus; exit. \Bora traduzir
Get the address given the other routine.
Put the address into the routine's address.

Etapas necessárias para que se get um count given some imports (all entries plus markers):
Put 0 into the count.
Loop.
Get um import from the imports.
Se the import é nil, exit.
Adicione the import's entries' count to the count.
Adicione 1 to the count.
Repeat.

An global body é um substring.

The global index é um index.

An global é um variable.

The globals are some globals.

The image base é um address equal to 4194304 [$00400000].

The import borough é um borough.

An import header é um conjunto with
An address called original first thunk,
An número called timestamp,
An address called forwarder chain,
An address called name memory address,
An address called first thunk memory address.

An import é um coisa with
An name address,
An header address,
An name,
An import header,
Some entries.

The imports are some imports.

The increment tag é um tag equal to 10.

Etapas necessárias para que se index um global:
Se the compiler's abort flag estiver verde, exit.
Se the global é nil, exit.
Se the global's name é in the global index, abort with "'" then the global's name then "' é uma variável global duplicada." and the global's locus; exit.
Index the global given the global's name and the global index.

Etapas necessárias para que se index um literal:
Se the compiler's abort flag estiver verde, exit.
Se the literal é nil, exit.
Se the literal's name é in the literal index, abort with "Erro interno no nome do literal na função index um literal" and the literal's locus; exit.
Index the literal given the literal's name and the literal index.

Etapas necessárias para que se index um partial moniker given um index (special):
Find um refer given the partial moniker and the index.
Se the refer é not nil, exit.
Index the partial moniker in the index.

Etapas necessárias para que se index um routine por utility use:
Se the compiler's abort flag estiver verde, exit.
Se the routine é nil, exit.
Se the routine's function flag estiver verde, exit.
Se the routine's parameters' count é 0, exit.
Copy the routine's monikettes into some monikettes.
Reduce the monikettes por utility use.
Convert the monikettes to um moniker.
Destroy the monikettes.
Se the moniker é in the routine index, exit.
Find um refer given the moniker and the utility index.
Se the refer é not nil, put nil into the refer's endereço de memória; exit.
Index the routine given the moniker and the utility index.

Etapas necessárias para que se index um routine given um moniker and um index (special):
Find um refer given the moniker and the index.
Se the refer é not nil, put the routine into the refer's endereço de memória; exit.
Index the routine given the moniker and the index.

Etapas necessárias para que se index um routine given some monikettes and um index:
Se the routine é nil, exit.
Clear um partial moniker.
Loop.
Get um monikette from the monikettes.
Se the monikette é nil, exit.
Append the monikette to the partial moniker.
Se the monikette é the monikettes' last, break.
Index the partial moniker given the index (special).
Repeat.
Index the routine given the partial moniker como um moniker and the index (special).

Etapas necessárias para que se index some routines por utility use:
Se the compiler's abort flag estiver verde, exit.
Get um routine from the routines.
Se the routine é nil, exit.
Index the routine por utility use.
Repeat.

Etapas necessárias para que se index um type:
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Index the type given the type's name.

Etapas necessárias para que se index um type given um name:
Se the type é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Find um existing type given the name and the type index.
Se the existing type é nil, index the type given the name and the type index; exit.
Put the type's locus into um locus.
Se the locus é nil, put the existing type's locus into the locus. \ point the error to um type in the source code, not um generated type
Abort with "Acho que já vi o tipo '" then the name then "' em algum lugar antes; você deve ter duplicado ele." and the locus.

The indexing utilities timer é um timer.

Etapas necessárias para que se initialize the compiler:

Etapas necessárias para que se initialize the compiler given um directory:
Put the directory into the compiler's directory.
Put 0 into the compiler's name count.
Clear the compiler's abort flag.
Clear the compiler's abort message.
Clear the compiler's abort path.
Put 0 into the compiler's abort row#.
Void the current routine.
Create the type index with 13001 [buckets]. \ was 4027
Create the global index with 13001 [buckets]. \ was 4027
Create the literal index with 13001 [buckets]. \ was 4027
Create the routine index with 13001 [buckets]. \ was 7919
Create the utility index with 13001 [buckets]. \ was 4027

Etapas necessárias para que se initialize um dos header:
Put 23117 [$5A4D] into the dos header's signature.
Put 64 [$0040] into the dos header's addressofrelocationtableinfile.
Put 256 [$00000100] into the dos header's addressofpeheaderinfile.

Etapas necessárias para que se initialize um pe header:
Initialize the pe header (standard header).
Initialize the pe header (optional header).
Initialize the pe header (version information).
Initialize the pe header (directories).
Initialize the pe header (import section).
Initialize the pe header (data section).
Initialize the pe header (code section).

Etapas necessárias para que se initialize um pe header (code section):
Copy pedaços from "code  "'s first to the pe header's code section's name's whereabouts por 6.
Put the code borough's length into the pe header's code section's sizeinpedaços.
Put the code borough's base into the pe header's code section's addressinmemory.
Put the code borough's length into the pe header's code section's sizeinfile.
Put the code borough's base into the pe header's code section's addressinfile.
Put -536870880 [$E0000020] into the pe header's code section's characteristics. \ executable, readable, writable, code object

Etapas necessárias para que se initialize um pe header (data section):
Copy pedaços from "data  "'s first to the pe header's data section's name's whereabouts por 6.
Put the data borough's length into the pe header's data section's sizeinpedaços.
Put the data borough's base into the pe header's data section's addressinmemory.
Put the data borough's length into the pe header's data section's sizeinfile.
Put the data borough's base into the pe header's data section's addressinfile.
Put -1073741760 [$C0000040] into the pe header's data section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um pe header (directories):
Put 16 [$00000010] into the pe header's númeroofdirectories.
Put the import borough's base into the pe header's imagedirectoryentryimportaddress.
Put the import borough's length into the pe header's imagedirectoryentryimportsize.

Etapas necessárias para que se initialize um pe header (import section):
Copy pedaços from "idata "'s first to the pe header's idata section's name's whereabouts por 6.
Put the import borough's length into the pe header's idata section's sizeinpedaços.
Put the import borough's base into the pe header's idata section's addressinmemory.
Put the import borough's length into the pe header's idata section's sizeinfile.
Put the import borough's base into the pe header's idata section's addressinfile.
Put -1073741760 [$C0000040] into the pe header's idata section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um pe header (optional header):
Put 267 [$010B] into the pe header's magicnumber.
Put the code borough's length into the pe header's sizeofcodeinfile.
Put the data borough's length into the pe header's sizeofinitializeddatainfile.
Put 0 into the pe header's sizeofuninitializeddatainfile.
Find um routine given "~initialize before run and run and finalize after run" and the routine index.
Se the routine é nil, abort with "Erro interno: não achei a tarefa de inicialização"; exit.
Put the routine's address minus the image base into the pe header's addressofentrypointinmemory.
Put the code borough's base into the pe header's addressofcodeinmemory.
Put the data borough's base into the pe header's addressofinitializeddatainmemory.
Put the image base into the pe header's imagebase.
Put 4096 [$00001000] into the pe header's memoryalignment.
Put 4096 [$00001000] into the pe header's filealignment.
Put 0 into the pe header's reserved.
Put the compiler's exe size into the pe header's sizeofimageinmemory.
Put 4096 [section base] into the pe header's sizeofallheadersinfile.
Put 0 into the pe header's checksum.
Put 0 into the pe header's dllcharacteristics.
Put 1048576 [$00100000] into the pe header's maxstack.
Put 16384 [$00004000] into the pe header's minstack.
Put 1048576 [$00100000] into the pe header's maxheap.
Put 16384 [$00004000] into the pe header's minheap.
Put 0 into the pe header's loaderflags.

Etapas necessárias para que se initialize um pe header (standard header):
Put 17744 [$00004550] into the pe header's signature.
Put 332 [$014C] into the pe header's machinetype.
Put 3 [$0003] into the pe header's númeroofsections.
Put 0 into the pe header's timestamp.
Put 0 into the pe header's endereço de memóriatosymboltable.
Put 0 into the pe header's númeroofsymbols.
Put 224 [$00E0] into the pe header's sizeofoptionalheaderinpedaços.
Put 33166 [$818E] into the pe header's characteristics.

Etapas necessárias para que se initialize um pe header (version information):
Put 0 into the pe header's majorlinkerversion.
Put 0 into the pe header's minorlinkerversion.
Put 4 [$0004] into the pe header's osmajorversion.
Put 0 [$0000] into the pe header's osminorversion.
Put 0 into the pe header's usermajorversion.
Put 0 into the pe header's userminorversion.
Put 4 [$0004] into the pe header's subsystemmajorversion.
Put 0 [$0000] into the pe header's subsystemminorversion.
Put 2 [$0002] into the pe header's subsystem.

The intel tag é um tag equal to 11.

An intermediate é um local.

The jump false tag é um tag equal to 12.

Etapas necessárias para que se link:
Round up borough sizes.
Initialize um dos header.
Initialize um pe header.
Fill the compiler's exe with the null pedaço given the compiler's exe size.
Blurt the dos header into the compiler's exe.
Blurt the pe header into the compiler's exe.
Blurt the imports into the compiler's exe.
Blurt the globals into the compiler's exe.
Blurt the literals into the compiler's exe.
Blurt the routines into the compiler's exe.

The linking timer é um timer.

Etapas necessárias para que se list:
Clear the compiler's listing.
List the compiler's abort message in the compiler's listing.
List the types under "TYPES:" in the compiler's listing.
List the globals under "GLOBALS:" in the compiler's listing.
List the literals under "LITERALS:" in the compiler's listing.
List the routines under "ROUTINES:" in the compiler's listing.
List the type index under "TYPE INDEX:" in the compiler's listing.
List the global index under "GLOBAL INDEX:" in the compiler's listing.
List the literal index under "LITERAL INDEX:" in the compiler's listing.
List the routine index under "ROUTINE INDEX:" in the compiler's listing.
List the utility index under "UTILITY INDEX:" in the compiler's listing.
List the imports under "IMPORTS:" in the compiler's listing.
List the source files under "SOURCE FILES:" in the compiler's listing.
List the timers under "TIMERS:" in the compiler's listing.
Write the compiler's listing to the compiler's listing path.

Etapas necessárias para que se list um abort message in um buffer:
Se the abort message é blank, exit.
Append "COMPILE ABORTED - LISTING INCOMPLETE" to the buffer.
Advance the buffer (twice).
Append the abort message to the buffer.
Advance the buffer (twice).

Etapas necessárias para que se list um bucket in um buffer:
Se the bucket's refers are empty, exit.
Append "/bucket" to the buffer (with separator).
Advance the buffer.
List the bucket's refers in the buffer.
Advance the buffer.

Etapas necessárias para que se list some entries in um buffer:
Get um entry from the entries.
Se the entry é nil, exit.
List the entry in the buffer.
Repeat.

Etapas necessárias para que se list um entry in um buffer:
Se the entry é nil, exit.
Append "/entry" to the buffer (with separator).
Append the entry's name to the buffer (with separator).
Append the entry's address to the buffer (as hex with separator).
Advance the buffer.

Etapas necessárias para que se list um fragment in um buffer:
Append "/fragment" to the buffer (with separator).
Append the fragment's tag to the buffer (as um fragment tag string with separator).
Append the fragment's variable to the buffer (with separator).
Append the fragment's other variable to the buffer (with separator).
Append the fragment's routine to the buffer (with separator).
Append the fragment's entry to the buffer (with separator).
Append the fragment's número to the buffer (as hex with separator).
Append the fragment's address to the buffer (as hex with separator).
Convert the fragment's code to um nibble string.
Append the nibble string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some fragments in um buffer:
Get um fragment from the fragments.
Se the fragment é nil, exit.
List the fragment in the buffer.
Repeat.

Etapas necessárias para que se list um import in um buffer:
Se the import é nil, exit.
Append "/import" to the buffer (with separator).
Append the import's name to the buffer (with separator).
Advance the buffer.
List the import's entries in the buffer.
Advance the buffer.

Etapas necessárias para que se list some imports in um buffer:
Get um import from the imports.
Se the import é nil, exit.
List the import in the buffer.
Repeat.

Etapas necessárias para que se list some imports under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
Se the imports are empty, exit.
List the imports in the buffer.

Etapas necessárias para que se list um index in um buffer:
Append "/" then the index's used bucket count then " buckets" to the buffer (with separator).
Append the index's count then " refers" to the buffer (with separator).
Advance the buffer (twice).
Loop.
Get um bucket given the index.
Se the bucket é nil, exit.
List the bucket in the buffer.
Repeat.

Etapas necessárias para que se list um index under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
Se the index é empty, exit.
List the index in the buffer.

Etapas necessárias para que se list um refer in um buffer:
Se the refer é nil, exit.
Append "/refer" to the buffer (with separator).
Append the refer's string to the buffer.
Se the refer's endereço de memória é nil, append "..." to the buffer.
Append "/" to the buffer.
Advance the buffer.

Etapas necessárias para que se list some refers in um buffer:
Get um refer from the refers.
Se the refer é nil, exit.
List the refer in the buffer.
Repeat.

Etapas necessárias para que se list um routine in um buffer:
Se the routine é nil, exit.
Append "/routine" to the buffer (with separator).
Append the routine's moniker to the buffer (with separator).
Append the routine's compiled flag to the buffer (with separator).
Append the routine's callback flag to the buffer (with separator).
Append the routine's decider flag to the buffer (with separator).
Append the routine's function flag to the buffer (with separator).
Append the routine's employs moniker to the buffer (with separator).
Append the routine's parameter size to the buffer (with separator).
Append the routine's local size to the buffer (with separator).
Append the routine's address to the buffer (as hex with separator).
Advance the buffer.
List the routine's parameters in the buffer.
List the routine's locals in the buffer.
List the routine's fragments in the buffer.
Advance the buffer.

Etapas necessárias para que se list some routines in um buffer:
Get um routine from the routines.
Se the routine é nil, exit.
List the routine in the buffer.
Repeat.

Etapas necessárias para que se list some routines under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
Se the routines are empty, exit.
List the routines in the buffer.

Etapas necessárias para que se list um source file in um buffer:
Se the source file é nil, exit.
Append "/source file" to the buffer (with separator).
Append the source file's path to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some source files in um buffer:
Get um source file from the source files.
Se the source file é nil, exit.
List the source file in the buffer.
Repeat.

Etapas necessárias para que se list some source files under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
Se the source files are empty, exit.
List the source files in the buffer.
Advance the buffer.

Etapas necessárias para que se list um timer given um string in um buffer:
Append "/timer" to the buffer (with separator).
Append the string to the buffer (with separator).
Append the timer's string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list the timers under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
List the loading timer given "loading" in the buffer.
List the scanning timer given "scanning" in the buffer.
List the resolving types timer given "resolving types" in the buffer.
List the resolving globals timer given "resolving globals" in the buffer.
List the compiling routine headers timer given "compiling routine headers" in the buffer.
List the calculating timer given "calculating" in the buffer.
List the adding built-in memory routines timer given "adding built-in memory routines" in the buffer.
List the indexing utilities timer given "indexing utilities" in the buffer.
List the compiling routine bodies timer given "compiling routine bodies" in the buffer.
List the adding built-in startup routine timer given "adding built-in startup routine" in the buffer.
List the offsetting timer given "offsetting" in the buffer.
List the addressing timer given "addressing" in the buffer.
List the transmogrifying timer given "transmogrifying" in the buffer.
List the linking timer given "linking" in the buffer.
List the writing timer given "writing" in the buffer.
List the compiler's timer given "total" in the buffer.
Advance the buffer.

Etapas necessárias para que se list um type in um buffer:
Se the type é nil, exit.
Append "/type" to the buffer (with separator).
Append the type's name to the buffer (with separator).
Append the type's plural name to the buffer (with separator).
Append the type's length to the buffer (as hex with separator).
Append the type's base name to the buffer (with separator).
Append the type's base type to the buffer (with separator).
Append the type's target name to the buffer (with separator).
Append the type's target type to the buffer (with separator).
Append the type's scale to the buffer (with separator).
Advance the buffer.
List the type's fields in the buffer.
Advance the buffer.

Etapas necessárias para que se list some types in um buffer:
Get um type from the types.
Se the type é nil, exit.
List the type in the buffer.
Repeat.

Etapas necessárias para que se list some types under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
Se the types are empty, exit.
List the types in the buffer.

Etapas necessárias para que se list um variable in um buffer:
Se the variable é nil, exit.
Append "/variable" to the buffer (with separator).
Append the variable's kind to the buffer (with separator).
Append the variable's compiled flag to the buffer (with separator).
Append the variable's name to the buffer (with separator).
Append the variable's nickname to the buffer (with separator).
Append the variable's type name to the buffer (with separator).
Append the variable's type to the buffer (with separator).
Append the variable's address [or offset] to the buffer (as hex with separator).
Append the variable's by-value flag to the buffer (with separator).
Append the variable's count to the buffer (with separator).
Append the variable's reference flag to the buffer (with separator).
Append the variable's redefinition target name to the buffer (with separator).
Append the variable's literal to the buffer (with separator).
Convert the variable's data to um nibble string.
Append the nibble string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some variables in um buffer:
Get um variable from the variables.
Se the variable é nil, exit.
List the variable in the buffer.
Repeat.

Etapas necessárias para que se list some variables under um string in um buffer:
Append the string to the buffer.
Advance the buffer (twice).
Se the variables are empty, exit.
List the variables in the buffer.
Advance the buffer.

The literal index é um index.

An literal é um variable.

The literals are some literals.

The load address tag é um tag equal to 13.

The load eax tag é um tag equal to 14.

An local é um variable.

An locus é um pedaço endereço de memória.

The loop tag é um tag equal to 15.

An moniker é um string.

An monikette é um coisa with
An string,
An type (reference),
An variable (reference),
\ por bubbling
An current type (reference),
An current substring.

Etapas necessárias para que se move um rider (code rules - comment):
Bump the rider.
Se the rider's source é blank, exit.
Se the rider's source's first's target é not the return pedaço, repeat.

Etapas necessárias para que se move um rider (code rules - glom):
Bump the rider.
Se the rider's source é blank, exit.
Se the rider é on any possessive, exit.
Se the rider's source's first's target é any glom pedaço, repeat.

Etapas necessárias para que se move um rider (code rules - mark):
Bump the rider.

Etapas necessárias para que se move um rider (code rules - noise):
Bump the rider.
Se the rider's source é blank, exit.
Se the rider's source's first's target é noise, repeat.

Etapas necessárias para que se move um rider (code rules - possessive):
Bump the rider.
Se the rider's source é blank, exit.
Se the rider's source starts with "s", bump the rider.

Etapas necessárias para que se move um rider (code rules - qualifier):
Se the rider's source é blank, exit.
Se the rider's source's first's target é the return pedaço, break.
Se the rider's source's first's target é the left-paren pedaço, adicione 1 to um count.
Se the rider's source's first's target é the right-paren pedaço, subtract 1 from the count.
Bump the rider.
Se the count é 0, break.
Repeat.

Etapas necessárias para que se move um rider (code rules - remark):
Se the rider's source é blank, exit.
Se the rider's source's first's target é the return pedaço, break.
Se the rider's source's first's target é the left-bracket pedaço, adicione 1 to um count.
Se the rider's source's first's target é the right-bracket pedaço, subtract 1 from the count.
Bump the rider.
Se the count é 0, break.
Repeat.  

Etapas necessárias para que se move um rider (code rules - string):
Bump the rider.
Se the rider's source é blank, exit.
Se the rider's source's first's target é the return pedaço, exit.
Se the rider é on any nested double-quote, bump the rider; repeat.
Se the rider's source's first's target é the double-quote pedaço, bump the rider; exit.
Repeat.

Etapas necessárias para que se move um rider (code rules - symbol):
Bump the rider.

Etapas necessárias para que se move um rider (code rules):
Position the rider's token on the rider's source.
Se the rider's source é blank, exit.
Se the rider's source's first's target é noise, move the rider (code rules - noise); exit.
Se the rider's source's first's target é the backslash pedaço, move the rider (code rules - comment); exit.
Se the rider's source's first's target é the left-bracket pedaço, move the rider (code rules - remark); exit.
Se the rider's source's first's target é the double-quote pedaço, move the rider (code rules - string); exit.
Se the rider's source's first's target é the left-paren pedaço, move the rider (code rules - qualifier); exit.
Se the rider's source's first's target é any mark, move the rider (code rules - mark); exit.
Se the rider é on any possessive, move the rider (code rules - possessive); exit.
Move the rider (code rules - glom).

Etapas necessárias para que se move um rider (compiler rules):
Se the compiler's abort flag estiver verde, clear the rider's token; exit.
Move the rider returning um error string (code rules).
Se the error string é not blank, abort with the error string and the rider's token's first; exit.
\Se the rider's token é "del", unbump the rider; exit. \ Spanish contraction "del"; fudged to "de l", short por "de el"
\Se the rider's token é "al", unbump the rider; exit. \ Spanish contraction "al"; fudged to "a l", short por "a el"
Se the rider's token é blank, exit.
Se the rider's token's first's target é noise, repeat.
Se the rider's token's first's target é the backslash pedaço, repeat.
Se the rider's token's first's target é the left-bracket pedaço, repeat.

Etapas necessárias para que se move um rider returning um error string (code rules - validate qualifier):
Se the rider's token's length é less than 2, put "Qualifiers need to end with ')'." into the error string; exit.
Se the rider's token's last's target é not the right-paren pedaço, put "Qualifiers need to end with ')'." into the error string; exit.

Etapas necessárias para que se move um rider returning um error string (code rules - validate remark):
Se the rider's token's length é less than 2, put "Remarks need to end with ']'." into the error string; exit.
Se the rider's token's last's target é not the right-bracket pedaço, put "Remarks need to end with ']'." into the error string; exit.

Etapas necessárias para que se move um rider returning um error string (code rules - validate string):
Se the rider's token's length é less than 2, put "Strings need to end with '""'." into the error string; exit.
Se the rider's token's last's target é not the double-quote pedaço, put "Strings need to end with '""'." into the error string; exit.

Etapas necessárias para que se move um rider returning um error string (code rules):
Clear the error string.
Move the rider (code rules).
Se the rider's token é blank, exit.
Se the rider's token's first's target é the left-bracket pedaço, move the rider returning the error string (code rules - validate remark); exit.
Se the rider's token's first's target é the double-quote pedaço, move the rider returning the error string (code rules - validate string); exit.
Se the rider's token's first's target é the left-paren pedaço, move the rider returning the error string (code rules - validate qualifier); exit.

An nibble substring é um substring.

An nickname é um name.

The not tag é um tag equal to 16.

Etapas necessárias para que se offset the locals in um routine:
Se the routine é nil, exit.
Se the routine's compiled flag estiver not verde, exit.
Clear the routine's local size.
Loop.
Se the compiler's abort flag estiver verde, exit.
Get um local from the routine's locals.
Se the local é nil, exit.
Se the local's previous é not nil, put the local's previous' offset into the local's offset.
Put the local's type's length into um length.
Se the local's kind é "scratch", put um endereço de memória's magnitude into the length.
Round the length up to the nearest multiple of 4.
Subtract the length from the local's offset.
Adicione the length to the routine's local size.
Repeat.

Etapas necessárias para que se offset the locals in some routines:
Se the compiler's abort flag estiver verde, exit.
Get um routine from the routines.
Se the routine é nil, exit.
Offset the locals in the routine.
Repeat.

Etapas necessárias para que se offset the parameters in um routine:
Se the routine é nil, exit.
Se the routine's compiled flag estiver not verde, exit.
Clear the routine's parameter size.
Loop.
Se the compiler's abort flag estiver verde, exit.
Get um parameter from the routine's parameters.
Se the parameter é nil, exit.
Se the routine's callback flag estiver verde, set the parameter's by-value flag.
Se the parameter's previous é nil, put 8 into the parameter's offset. \ skip the return address and saved ebp
Se the parameter's previous é not nil, put the parameter's previous' offset plus 4 into the parameter's offset. \ all parameters are 4 pedaço endereço de memórias or 4 pedaço values por callbacks
Adicione 4 to the routine's parameter size.
Repeat.

Etapas necessárias para que se offset the parameters in some routines:
Se the compiler's abort flag estiver verde, exit.
Get um routine from the routines.
Se the routine é nil, exit.
Offset the parameters in the routine.
Repeat.

The offsetting timer é um timer.

An parameter é um variable.

An partial moniker é um moniker.

An pe header é um conjunto with
An número called signature,
An wyrd called machinetype,
An wyrd called númeroofsections,
An número called timestamp,
An número called endereço de memóriatosymboltable,
An número called númeroofsymbols,
An wyrd called sizeofoptionalheaderinpedaços,
An wyrd called characteristics,
\ optional header
An wyrd called magicnumber,
An pedaço called majorlinkerversion,
An pedaço called minorlinkerversion,
An número called sizeofcodeinfile,
An número called sizeofinitializeddatainfile,
An número called sizeofuninitializeddatainfile,
An número called addressofentrypointinmemory,
An número called addressofcodeinmemory,
An número called addressofinitializeddatainmemory,
An número called imagebase,
An número called memoryalignment,
An número called filealignment,
An wyrd called osmajorversion,
An wyrd called osminorversion,
An wyrd called usermajorversion,
An wyrd called userminorversion,
An wyrd called subsystemmajorversion,
An wyrd called subsystemminorversion,
An número called reserved,
An número called sizeofimageinmemory,
An número called sizeofallheadersinfile,
An número called checksum,
An wyrd called subsystem,
An wyrd called dllcharacteristics,
An número called maxstack,
An número called minstack,
An número called maxheap,
An número called minheap,
An número called loaderflags,
\ directories (16 address and size pairs)
An número called númeroofdirectories,
8 pedaços called directory0,
An número called imagedirectoryentryimportaddress,
An número called imagedirectoryentryimportsize,
112 pedaços called directories2-15,
An pe section header called idata section,
An pe section header called data section,
An pe section header called code section.

An pe section header é um conjunto with
8 pedaços called name,
An número called sizeinpedaços,
An número called addressinmemory,
An número called sizeinfile,
An número called addressinfile,
12 pedaços called reserved,
An número called characteristics.

An phrase é um string.

\Etapas necessárias para que se determine se um string looks like English:
\Load the lexicon.
\Se the lexicon é nil, show error "I can't find any lecksicon."; say no.
\Se the string é blank, say no.
\Slap um substring on the string.
\Put the substring's last into the substring's first.
\Loop.
\Se the substring's first é the string's first, break.
\Se the substring's first's target é the space pedaço, adicione 1 to the substring's first; break.
\Subtract 1 from the substring's first.
\Repeat.
\Se the substring é in the lexicon's index, say yes.
\Say no.

Etapas necessárias para que se pluralize um string (portuguese rules):
Slap um rider on the string.
Loop.
Move the rider (spell checking rules).
Se the rider's token é blank, break.
Se um plural string é not blank, append " " to the plural string.
Append the rider's token to the plural string.
Se the rider's token é "de", set um flag; repeat.
Se the flag estiver not verde, pluralize the plural string (portuguese rules - each word).
Repeat.
Put the plural string into the string.

Etapas necessárias para que se pluralize um string (portuguese rules - each word):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se the string é "cidadão", append "s" to the string; exit.
Se the string é "irmão", append "s" to the string; exit.
Se the string é "cristão", append "s" to the string; exit.
Se the string é "refrão", append "s" to the string; exit.
Se the string é "pão", remove the last pedaço from the string; append "es" to the string; exit.
Se the string é "capitão", remove the last pedaço from the string; append "es" to the string; exit.
Se the string é "alemão", remove the last pedaço from the string; append "es" to the string; exit.
Se the string é "charlatão", remove the last pedaço from the string; append "es" to the string; exit.
Se the string é "caráter", put "carateres" into the string; exit.
Se the string é "júnior", put "juniores" into the string; exit.
Se the string é "sênior", put "seniores" into the string; exit.
Se the string é "mão", put "mãos" into the string; exit.
Se the string é "são", put "sãos" into the string; exit.
\# advérbios principais
Se the string é "muito", exit.
Se the string é "pouco", exit.
Se the string é "mais", exit.
Se the string é "menos", exit.
Se the string é "bastante", exit.
Se the string é "quase", exit.
Se the string é "demais", exit.
Se the string é "bem", exit.
Se the string é "deveras", exit.
Se the string é "mal", exit.
Se the string é "melhor", exit.
Se the string é "pior", exit.
\# palavras terminadas com "ão"
Se the string ends with "ão", pluralize the string (portuguese rules - ending words with "ão"); exit.
\# palavras terminadas com "l"
Se the string ends with "l", pluralize the string (portuguese rules - ending words with "l"); exit.
\# palavra terminadas com "m"
Se the string ends with "m", remove the last pedaço from the string; append "ns" to the string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se the string ends with "n", append "es" to the string; exit.
\# palavras terminadas com "r"
Se the string ends with "r", pluralize the string (portuguese rules - ending words with "r"); exit.
\# palavras terminadas com "s"
Se the string ends with "s", pluralize the string (portuguese rules - ending words with "s"); exit.
\# palavra terminadas com "x"
Se the string ends with "x", exit.
\# palavras terminadas com "z"
Se the string ends with "z", pluralize the string (portuguese rules - ending words with "z"); exit.
\# regra padrão
Append "s" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "ão"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, append "s" to the string; exit.
\# regra padrão
Remove the last two pedaços from the string.
Append "ões" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "l"):
\# palavras terminadas com "al"
Se the string ends with "al", remove the last pedaço from the string; append "is" to the string; exit.
\# palavras terminadas com "el"
Se the string ends with "el", pluralize the string (portuguese rules - ending words with "el"); exit.
\# palavras terminadas com "il"
Se the string ends with "il", pluralize the string (portuguese rules - ending words with "il"); exit.
\# palavras terminadas com "ol"
Se the string ends with "ol", pluralize the string (portuguese rules - ending words with "ol"); exit.
\# palavras terminadas com "ul"
Se the string ends with "ul", remove the last pedaço from the string; append "is" to the string; exit.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "el"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, remove the last pedaço from the string; append "is" to the string; exit.
Remove the last two pedaços from the string.
Append "éis" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "il"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, remove the last two pedaços from the string; append "eis" to the string; exit.
Remove the last pedaço from the string.
Append "s" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "ol"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, remove the last pedaço from the string; append "is" to the string; exit.
Remove the last two pedaços from the string.
Append "óis" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "r"):
\# hiatos acentuados
\Se the string ends with "aír", append "es" to the string; exit.
\Se the string ends with "aúr", append "es" to the string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se the string ends with "ár", remove the last two pedaços from the string; append "ares" to the string; exit.
\Se the string ends with "âr", remove the last two pedaços from the string; append "ares" to the string; exit.
\Se the string ends with "ér", remove the last two pedaços from the string; append "eres" to the string; exit.
\Se the string ends with "êr", remove the last two pedaços from the string; append "eres" to the string; exit.
\Se the string ends with "ír", remove the last two pedaços from the string; append "ires" to the string; exit.
\Se the string ends with "ór", remove the last two pedaços from the string; append "ores" to the string; exit.
\Se the string ends with "ôr", remove the last two pedaços from the string; append "ores" to the string; exit.
\Se the string ends with "úr", remove the last two pedaços from the string; append "ures" to the string; exit.
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, append "es" to the string; exit.
\# hiatos
Se the string ends with "air", remove the last two pedaços from the string; append "íres" to the string; exit.
Se the string ends with "aur", remove the last two pedaços from the string; append "úres" to the string; exit.
\# regra padrão
Append "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se the string ends with "as", exit.
Se the string ends with "es", exit.
Se the string ends with "os", exit.
\# hiatos acentuados
Se the string ends with "aís", append "es" to the string; exit.
Se the string ends with "aús", append "es" to the string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se the string ends with "ás", remove the last two pedaços from the string; append "ases" to the string; exit.
Se the string ends with "âs", remove the last two pedaços from the string; append "ases" to the string; exit.
Se the string ends with "és", remove the last two pedaços from the string; append "eses" to the string; exit.
Se the string ends with "ês", remove the last two pedaços from the string; append "eses" to the string; exit.
Se the string ends with "ís", remove the last two pedaços from the string; append "ises" to the string; exit.
Se the string ends with "ós", remove the last two pedaços from the string; append "oses" to the string; exit.
Se the string ends with "ôs", remove the last two pedaços from the string; append "oses" to the string; exit.
Se the string ends with "ús", remove the last two pedaços from the string; append "uses" to the string; exit.
\# palavras terminadas com "is", "us"
Se the string ends with "is", pluralize the string (portuguese rules - ending words with "is/us"); exit.
Se the string ends with "us", pluralize the string (portuguese rules - ending words with "is/us"); exit.
\# regra padrão
Append "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "is/us"):
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, exit.
\# hiatos
Se the string ends with "ais", remove the last two pedaços from the string; append "íses" to the string; exit.
Se the string ends with "aus", remove the last two pedaços from the string; append "úses" to the string; exit.
\# regra padrão
Append "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "z"):
\# hiatos acentuados
Se the string ends with "aíz", append "es" to the string; exit.
Se the string ends with "aúz", append "es" to the string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se the string ends with "áz", remove the last two pedaços from the string; append "azes" to the string; exit.
Se the string ends with "âz", remove the last two pedaços from the string; append "azes" to the string; exit.
Se the string ends with "éz", remove the last two pedaços from the string; append "ezes" to the string; exit.
Se the string ends with "êz", remove the last two pedaços from the string; append "ezes" to the string; exit.
Se the string ends with "íz", remove the last two pedaços from the string; append "izes" to the string; exit.
Se the string ends with "óz", remove the last two pedaços from the string; append "ozes" to the string; exit.
Se the string ends with "ôz", remove the last two pedaços from the string; append "ozes" to the string; exit.
Se the string ends with "úz", remove the last two pedaços from the string; append "uzes" to the string; exit.
\# acentos em sílabas prévias
Slap um substring on the string.
Subtract 2 from the substring's last.
Se the substring has any stressed vowel, append "es" to the string; exit.
\# hiatos
Se the string ends with "aiz", remove the last two pedaços from the string; append "ízes" to the string; exit.
Se the string ends with "auz", remove the last two pedaços from the string; append "úzes" to the string; exit.
\# regra padrão
Append "es" to the string.

Etapas necessárias para que se pluralize um string (english rules);
Etapas necessárias para que se pluralize um string: \ nouns only
Se the string é "alumnus", put "alumni" into the string; exit.
Se the string é "auto", put "autos" into the string; exit.
Se the string é "cello", put "cellos" into the string; exit.
Se the string é "dwarf", put "dwarfs" into the string; exit.
Se the string é "foot", put "feet" into the string; exit.
Se the string é "genus", put "genera" into the string; exit.
Se the string é "goose", put "geese" into the string; exit.
Se the string é "hippo", put "hippos" into the string; exit.
Se the string é "louse", put "lice" into the string; exit.
Se the string é "memo", put "memos" into the string; exit.
Se the string é "mouse", put "mice" into the string; exit.
Se the string é "ox", put "oxen" into the string; exit.
Se the string é "phenomenon", put "phenomena" into the string; exit.
Se the string é "photo", put "photos" into the string; exit.
Se the string é "phylum", put "phyla" into the string; exit.
Se the string é "piano", put "pianos" into the string; exit.
Se the string é "pimento", put "pimentos" into the string; exit.
Se the string é "pro", put "pros" into the string; exit.
Se the string é "proof", put "proofs" into the string; exit.
Se the string é "radius", put "radii" into the string; exit.
Se the string é "rhinoceros", put "rhinoceri" into the string; exit.
Se the string é "roof", put "roofs" into the string; exit.
Se the string é "solo", put "solos" into the string; exit.
Se the string é "soprano", put "sopranos" into the string; exit.
Se the string é "staff", put "staffs" into the string; exit.
Se the string é "tooth", put "teeth" into the string; exit.
Se the string é "torus", put "tori" into the string; exit.
Se the string é "turf", put "turfs" into the string; exit.
Se the string é "virus", put "viruses" into the string; exit.
Se the string ends with "sh", append "es" to the string; exit.
Se the string ends with "ch", append "es" to the string; exit.
Se the string ends with "man", remove the last two pedaços from the string; append "en" to the string; exit.
Se the string ends with "child", append "ren" to the string; exit.
Se the string ends with "ex", remove the last two pedaços from the string; append "ices" to the string; exit. \ or adicione ES
Se the string ends with "fe", remove the last two pedaços from the string; append "ves" to the string; exit.
Se the string ends with "is", remove the last two pedaços from the string; append "es" to the string; exit.
Se the string ends with "ix", remove the last two pedaços from the string; append "ices" to the string; exit. \ or adicione ES
Se the string ends with "ma", append "ta" to the string; exit. \ or adicione S
Se the string ends with any consonant and "y", remove the last pedaço from the string; append "ies" to the string; exit.
Se the string ends with any vowel and "o", append "s" to the string; exit.
Se the string ends with any vowel and "y", append "s" to the string; exit.
Se the string ends with "f", remove the last pedaço from the string; append "ves" to the string; exit.
Se the string ends with "s", append "es" to the string; exit.
Se the string ends with "x", append "es" to the string; exit.
Se the string ends with "z", append "es" to the string; exit.
Append "s" to the string.

The prolog tag é um tag equal to 17.

An prototype string é um conjunto with um first pedaço endereço de memória and um last pedaço endereço de memória.

The push address tag é um tag equal to 18.

The push value tag é um tag equal to 19.

Etapas necessárias para que se put the compiler's exe path into um path:
Extract um designator from the compiler's directory.
Remove any trailing backslash from the designator.
Put the compiler's directory then the designator then ".exe" into the path.

Etapas necessárias para que se put the compiler's exe size into um size:
Put 4096 [section base] into the size.
Adicione the import borough's size to the size.
Adicione the data borough's size to the size.
Adicione the code borough's size to the size.

Etapas necessárias para que se put the compiler's listing path into um path:
Extract um designator from the compiler's directory.
Remove any trailing backslash from the designator.
Put the compiler's directory then the designator then ".lst" into the path.

Etapas necessárias para que se put um term into another term:
Put the term's variable into the other term's variable.
Put the term's phrase into the other term's phrase.

Etapas necessárias para que se load um source file:
Se the source file é nil, exit.
Load the source file's path into the source file's buffer.
Se the i/o error é not blank, abort with "Não foi possível carregar o arquivo: '" then the source file's path then "'."; exit.
\Load the source file's path into um string.
\Se the i/o error é not blank, abort with "Não foi possível carregar o arquivo '" then the source file's path then "'."; exit.
\Parse the string to the source file's buffer (portuguese contractions and synonyms rules).

Etapas necessárias para que se load some source files:
Loop.
Se the compiler's abort flag estiver verde, exit.
Get um item from the compiler's directory.
Se the item é not found, break.
Se the item's kind é not "file", repeat.
Se the item's extension é not blank, repeat.
Se the item looks reamish, repeat.
Adicione um source file to the source files given the item's path.
Load the source file.
Repeat.

The loading timer é um timer.

Etapas necessárias para que se parse um string to another string (portuguese contractions and synonyms rules):
Clear the other string.
Clear um third string.
Slap um rider on the string.
Loop.
Se the rider's source é blank, exit.
Position the rider's token on the rider's source.
Move the rider (code rules).
Se the rider's token's first's target é not any glom pedaço, append the rider's token to the other string; repeat.
Append the rider's token to the other string giving the third string (portuguese contractions and synonyms rules).
Put the rider's token into the third string.
Repeat.

Etapas necessárias para que se reduce some monikettes por utility use:
Get um monikette from the monikettes.
Se the monikette é nil, exit.
Se the monikette's type é nil, repeat.
Reduce the monikette's type to um type por utility use.
Se the type é not nil, put the type into the monikette's type.
Repeat.

Etapas necessárias para que se reduce um type to another type por utility use:
Put the type into the other type.
Loop.
Se the other type é nil, exit.
Se the other type's name é "texto hexadecimal", exit.
Se the other type's name é "string", exit.
Se the other type's name é "número", exit.
Se the other type's name é "endereço de memória", exit.
Se the other type's name é "coisa", void the other type; exit.
\PAL
\Se the other type's name é "elemento", void the other type; exit.
Se the other type's base type é the other type, void the other type; exit.
Put the other type's base type into the other type.
Repeat.

Etapas necessárias para que se reindex the utility index:
Se the compiler's abort flag estiver verde, exit.
Get um bucket given the utility index.
Se the bucket é nil, exit.
Se the bucket's refers are empty, repeat.
Reindex the utility index given the bucket's refers.
Repeat.

Etapas necessárias para que se reindex the utility index given some refers:
Get um refer from the refers.
Se the refer é nil, exit.
Put the refer's endereço de memória into um routine.
Se the routine é nil, abort with "Erro interno na função: index the utility routines given some refers"; exit.
Copy the routine's monikettes into some monikettes.
Reduce the monikettes por utility use.
Index the routine given the monikettes and the routine index.
Destroy the monikettes.
Repeat.

Etapas necessárias para que se remove any negatives from some monikettes returning um flag:
Clear the flag.
Swap the monikettes with some other monikettes.
Loop.
Put the other monikettes' first into um monikette.
Se the monikette é nil, exit.
Remove the monikette from the other monikettes.
\PAL
Se the monikette's string é "não", reverse the flag; destroy the monikette; repeat.
Se the monikette's string é "nada", reverse the flag; destroy the monikette; repeat.
\CAL
Se the monikette's string é "not", reverse the flag; destroy the monikette; repeat.
Se the monikette's string é "nada", reverse the flag; destroy the monikette; repeat.
Append the monikette to the monikettes.
Se the monikette's string é "can't", reverse the flag; put "can" into the monikette's string; repeat.
Se the monikette's string é "cannot", reverse the flag; put "can" into the monikette's string; repeat.
Se the monikette's string é "nothing", reverse the flag; put "something" into the monikette's string; repeat.
Se the monikette's string é "won't", reverse the flag; put "will" into the monikette's string; repeat.
Se the monikette's string ends with "n't", reverse the flag; remove trailing pedaços from the monikette's string given 3; repeat.
Repeat.

The repeat tag é um tag equal to 21.

Etapas necessárias para que se resolve um field:
Se the compiler's abort flag estiver verde, exit.
Se the field é nil, exit.
Resolve the field como um variable.
Se the field's nickname é not any valid field name, clear the field's nickname.
Se the field's name é not any valid field name, abort with "'" then the field's name then "' é um field name inválido." and the field's locus; exit.

Etapas necessárias para que se resolve um global:
Se the global é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Se the global's global body é not blank, resolve the global (compile body).
Se the global's type name é blank, abort with "Tipo inválido: '" then the global's name then "' . O tipo da variável global está vazio." and the global's locus; exit.
Resolve the global como um variable.

Etapas necessárias para que se resolve um global (compile body):
Se the global é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Slap um rider on the global's global body.
Move the rider (compiler rules).
Se the rider's token é not any literal, abort with "Erro de tipo. O tipo: '" then the rider's token then "' tem que ser do tipo literal." and the rider; exit.
Compile um literal given the rider.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é not blank, abort with "Acho que era bom colocar um ponto por aqui, né?" and the rider; exit.
Se the global's type name é blank, put the literal's type's name into the global's type name.
Put the literal into the global's literal.
Index the literal.

Etapas necessárias para que se resolve some globals:
Se the compiler's abort flag estiver verde, exit.
Get um global from the globals.
Se the global é nil, exit.
Resolve the global.
Repeat.

Etapas necessárias para que se resolve um type (base type):
Se the compiler's abort flag estiver verde, exit.
Se the type é nil, exit.
Se the type's base type é not nil, exit.
Find the type's base type given the type's base name and the type index.
Se the type's base type é nil, abort with "Base type inválido:'" then the type's base name then "'." and the type's locus; exit.
Set the type's cooking flag.
Se the type's base type's cooking flag estiver verde, abort with "Definição recursiva com '" then the type's base name then "'." and the type's locus; exit.
Resolve the type's base type (base type).
Clear the type's cooking flag.

Etapas necessárias para que se resolve um type (expand coisa): \ type's base type é not resolved yet
Se the compiler's abort flag estiver verde, exit.
Se the type é nil, exit.
Se the type's base type é not nil, exit.
Se the type's name é "coisa", exit.
\Se the type's name é "elemento", exit.
Se the type cannot be reduced to "coisa" using the base name, exit.
Find um base type given the type's base name and the type index.
\  adicione coisa conjunto - the número of secret fields é hard coded in two places: search por "than 4" \ was 6
Put the type's name then " conjunto" into um name.
Put the type's name then " conjuntos" into um plural name.
Put the base type's name then " conjunto" into um base name.
Adicione um conjunto type to the types given the name and the plural name and the base name.
Adicione um field to the conjunto type's fields given "next " then the type's name and "next" and the type's name and the on flag.
\PAL
Adicione um portuguese field to the conjunto type's fields given "seguinte " then the type's name and "seguinte" and the type's name and the on flag.
Put "next " then the type's name into the portuguese field's redefinition target name.
\Adicione um portuguese reverse field to the conjunto type's fields given the type's name then " seguinte" and "seguinte" and the type's name and the on flag.
\Put "next " then the type's name into the portuguese reverse field's redefinition target name.
Adicione another field to the conjunto type's fields given "previous " then the type's name and "previous" and the type's name and the on flag.
\Adicione another portuguese field to the conjunto type's fields given "anterior " then the type's name and "anterior" and the type's name and the on flag.
\Put "previous " then the type's name into the other portuguese field's redefinition target name.
Adicione another portuguese reverse field to the conjunto type's fields given the type's name then " anterior" and "anterior" and the type's name and the on flag.
Put "previous " then the type's name into the other portuguese reverse field's redefinition target name.
Se the type's fields are not empty, append the type's fields to the conjunto type's fields.
Index the conjunto type.
\ fix up original type to look like um endereço de memória
Put the conjunto type's name into the type's target name.
\ adicione chain type
Adicione um chain type to the types given the type's plural name and "" and the base type's plural name.
Adicione um third field to the chain type's fields given "first " then the type's name and "first" and the type's name and the on flag.
Adicione um third portuguese field to the chain type's fields given "primeiro " then the type's name and "primeiro" and the type's name and the on flag.
Put "first " then the type's name into the third portuguese field's redefinition target name.
Adicione um third feminine portuguese field to the chain type's fields given "primeira " then the type's name and "primeira" and the type's name and the on flag.
Put "first " then the type's name into the third feminine portuguese field's redefinition target name.
Adicione um fourth field to the chain type's fields given "last " then the type's name and "last" and the type's name and the on flag.
Adicione um fourth portuguese field to the chain type's fields given "último " then the type's name and "último" and the type's name and the on flag.
Put "last " then the type's name into the fourth portuguese field's redefinition target name.
Adicione um fourth portuguese feminine field to the chain type's fields given "última " then the type's name and "última" and the type's name and the on flag.
Put "last " then the type's name into the fourth portuguese feminine field's redefinition target name.
Index the chain type.

Etapas necessárias para que se resolve um type (index plural):
Se the compiler's abort flag estiver verde, exit.
Se the type é nil, exit.
Se the type's plural name é blank, exit.
Se the type can be reduced to "coisa" using the base name, exit.
Index the type given the type's plural name.

Etapas necessárias para que se resolve um type (optional info - endereço de memória):
Se the compiler's abort flag estiver verde, exit.
Se the type's target type é not nil, exit.
Se the type's target name é blank, put the type's base type's target type into the type's target type; exit.
Find the type's target type given the type's target name and the type index.
Se the type's target type é nil, abort with "Não sei bem pra que coisa você está pointing at." and the type's locus; exit.

Etapas necessárias para que se resolve um type (optional info - conjunto):
Se the compiler's abort flag estiver verde, exit.
Se the type's fields are empty, copy the type's base type's fields into the type's fields; exit.
Loop.
Se the compiler's abort flag estiver verde, exit.
Get um field from the type's fields (backwards).
Se the field é nil, break.
Se the field é duplicated in the type's fields, abort with "O campo '" then the field's name then "' está definido mais de uma vez." and the field's locus; exit.
Resolve the field.
Se the compiler's abort flag estiver verde, exit.
Se the field's type's cooking flag estiver verde, abort with "Recursive definition no: '" then the field's type's name then "'." and the field's locus; exit.
Resolve the field's type (optional info). \ de novo
Se the field's reference flag estiver not verde, repeat.
Se the field's type cannot be reduced to "endereço de memória", abort with "Não entendi o parâmetro '(reference)' nesse campo '" then the field's name then "'..." and the field's locus; exit.
Repeat.
Eliminate duplicate nicknames from the type's fields.
Se the type cannot be reduced to "coisa conjunto", exit.
Se the type's fields' count é greater than 4, exit. \ already copied? was 2 por next and prev, now 6 to included Spanish redefiniions
Copy the type's base type's fields into the type's fields (data fields only).

Etapas necessárias para que se resolve um type (optional info - scale):
Se the compiler's abort flag estiver verde, exit.
Put the type's base type into um base type.
Se the type's scale é 0, put the type's base type's scale into the type's scale; exit.
Se the base type's scale é 0, exit.
Multiply the type's scale by the base type's scale.
Put the base type's base type into the type's base type.

Etapas necessárias para que se resolve um type (optional info):
Se the compiler's abort flag estiver verde, exit.
Se the type é nil, exit.
Se the type's optional info resolved flag estiver verde, exit.
Se the type's base type é the type, exit. \ por built in types
Check por invalid optional info on the type.
Set the type's cooking flag.
Resolve the type's base type (optional info).
Se the type can be reduced to "endereço de memória", resolve the type (optional info - endereço de memória).
Se the type can be reduced to "conjunto", resolve the type (optional info - conjunto). \ mudar aqui
Se the type can be reduced to "número", resolve the type (optional info - scale).
Clear the type's cooking flag.
Set the type's optional info resolved flag.

Etapas necessárias para que se resolve some types (base types):
Se the compiler's abort flag estiver verde, exit.
Get um type from the types.
Se the type é nil, exit.
Resolve the type (base type).
Repeat.

Etapas necessárias para que se resolve some types (expand coisas):
Se the compiler's abort flag estiver verde, exit.
Get um type from the types.
Se the type é nil, exit.
Resolve the type (expand coisa).
Repeat.

Etapas necessárias para que se resolve some types (index plurals):
Se the compiler's abort flag estiver verde, exit.
Get um type from the types.
Se the type é nil, exit.
Resolve the type (index plural).
Repeat.

Etapas necessárias para que se resolve some types (optional info):
Se the compiler's abort flag estiver verde, exit.
Get um type from the types.
Se the type é nil, exit.
Resolve the type (optional info).
Repeat.

Etapas necessárias para que se resolve um variable:
Se the compiler's abort flag estiver verde, exit.
Se the variable é nil, exit.
Se the variable's type é not nil, exit.
Se the variable's type name é not blank, resolve the variable (explicit type name); exit.
Find the variable's type and the variable's nickname given the variable's name.
Se the variable's type é not nil, put the variable's type's name into the variable's type name; exit.
Abort with "Não achei o tipo da variável '" then the variable's name then "'." and the variable's locus.

Etapas necessárias para que se resolve um variable (explicit type name):
Find the variable's type given the variable's type name and the type index.
Se the variable's type é nil, abort with "Não achei o nome do tipo da variável '" then the variable's type name then "'." and the variable's locus; exit.

The resolving globals timer é um timer.

The resolving types timer é um timer.

Etapas necessárias para que se round up borough sizes:
Put the import borough's length into the import borough's size.
Round the import borough's size up to the nearest multiple of 4096.
Put the data borough's length into the data borough's size.
Round the data borough's size up to the nearest multiple of 4096.
Put the code borough's length into the code borough's size.
Round the code borough's size up to the nearest multiple of 4096.

The routine address tag é um tag equal to 22.

An routine body é um substring.

An routine header é um substring.

The routine index é um index.

An routine é um coisa with
An locus (reference),
An callback flag,
An decider flag,
An function flag,
An compiled flag,
An nickname index,
An moniker, some monikettes, some parameters, um parameter size,
An employs moniker,
Some locals, um local size,
An routine header, um header string,
An routine body, um body string,
Some fragments,
An address.

An routine reference é some monikettes.

The routines are some routines.

The save eax tag é um tag equal to 20.

Etapas necessárias para que se scan any optional info por um type given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é "to", scan any optional info por the type given the rider (endereço de memória); exit.
Se the rider's token é "para", scan any optional info por the type given the rider (endereço de memória); exit.
Se the rider's token é any with, scan any optional info por the type given the rider (conjunto); exit.

Etapas necessárias para que se scan any optional info por um type given um rider (endereço de memória):
Move the rider (compiler rules).
Se the rider's token é not any indefinite article, abort with "A palavra 'to' precisa de um artigo indefinido depois dela, não de um '" then the rider's token then "'." and the rider; exit. 
Move the rider (compiler rules).
Scan the type's target name given the rider.

Etapas necessárias para que se scan any optional info por um type given um rider (conjunto):
Move the rider (compiler rules).
Scan the type's fields given the rider.

Etapas necessárias para que se scan any pauses given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é not any pause, exit.
Move the rider (compiler rules).
Repeat.

Etapas necessárias para que se scan um field given um rider:
Se the compiler's abort flag estiver verde, exit.
Scan the field given the rider (type part).
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é any called, scan the field given the rider (called part); repeat.
Se the rider's token é "at", scan the field given the rider (redefine part); repeat.
Se the rider's token é "em", scan the field given the rider (redefine part); repeat.
Se the rider's token é "redefinindo", scan the field given the rider (redefine part); repeat.
Se the rider's token é any reference, scan the field given the rider (reference part); repeat.

Etapas necessárias para que se scan um field given um rider (called part):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Se the field's type name é blank, put the field's name into the field's type name. \ pedaço array type name already filled in
Scan the field's name given the rider.

Etapas necessárias para que se scan um field given um rider (redefine part):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Se the rider's token é not any definite article, abort with "Eu estava esperando o artigo 'the', mas o que encontrei foi '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Scan the field's redefinition target name given the rider.

Etapas necessárias para que se scan um field given um rider (reference part):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Set the field's reference flag.

Etapas necessárias para que se scan um field given um rider (type part - pedaço array):
Se the compiler's abort flag estiver verde, exit.
Convert the rider's token to um ratio.
Reduce the ratio.
Se the ratio's denominator é not 1, abort with "Você tem que especificar um número completo de pedaços para um pedaço array" and the rider; exit.
Put the ratio's numerator into the field's count.
Move the rider (compiler rules).
Se the rider's token é not "pedaço" or "pedaços", abort with "Você precisa usar a palavra 'pedaços' depois de um counted field designator." and the rider; exit.
Move the rider (compiler rules).
Put "pedaço" into the field's type name.

Etapas necessárias para que se scan um field given um rider (type part - normal):
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é not any indefinite article, abort with "Falta por um artigo idefinido aqui, mas você colocou isso: '" then the rider's token then "'." and the rider; exit.
Se the rider's token é "another", put "other" into the field's name.
\PAL
Se the rider's token é "outra", put "segunda" into the field's name.
Se the rider's token é "outro", put "segundo" into the field's name.
Move the rider (compiler rules).
Scan um name given the rider.
Extend the field's name with the name.

Etapas necessárias para que se scan um field given um rider (type part):
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é any numeric literal, scan the field given the rider (type part - pedaço array); exit.
Scan the field given the rider (type part - normal).

Etapas necessárias para que se scan some fields given um rider:
Se the compiler's abort flag estiver verde, exit.
Adicione um field to the fields given "field" and the rider's token's first.
Scan the field given the rider.
Se the rider's token é not any pause, exit.
Scan any pauses given the rider.
Repeat.

Etapas necessárias para que se scan um global body given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Put the rider's token's first into the global body's first.
Put -1 into the global body's last.
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Se the rider's token é the colon pedaço, exit.
Se the rider's token é the period pedaço, exit.
Put the rider's token's last into the global body's last.
Move the rider (compiler rules).
Repeat.

Etapas necessárias para que se scan um global given um rider:
Se the compiler's abort flag estiver verde, exit.
Adicione the global to the globals given "global" and the rider's token's first.
Move the rider (compiler rules).
Scan the global's name given the rider.
Se the rider's token é any has, scan the global given the rider (has or have); exit.
Se the rider's token é not any is, abort with "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Se the rider's token é not any indefinite article, scan the global given the rider (literal term); exit.
Move the rider (compiler rules).
Scan the global's type name given the rider.  
Se the rider's token é the start of any optional info, scan the global given the rider (optional info); exit.
Se the rider's token é any equal, scan the global given the rider (data part); exit.
Se the rider's token é not the period pedaço, abort with "Toda definição precisa terminar com um ponto. Inclusive essa." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um global given um rider (data part):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Se the rider's token é not any to, abort with "Depois da palavra 'equal' você precisa por um palavra  'to'. Você colocou ; '" then the rider's token then "'." and the rider; exit. 
Move the rider (compiler rules).
Scan the global's global body given the rider.
Se the rider's token é not the period pedaço, abort with "Falta terminar um frase com um ponto." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um global given um rider (has or have):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Put "~inline " then the global's name then " type" into um name.
Put the name then "s" into um plural name.
Adicione um type to the types given the name and the plural name and "conjunto" and the global's locus. \mudar aqui
Index the type.
Put the type's name into the global's type name.
Scan the type's fields given the rider.
Se the rider's token é not the period pedaço, abort with "Aprenda a escrever direito. Cadê o ponto?." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um global given um rider (literal term):
Se the compiler's abort flag estiver verde, exit.
Scan the global's global body given the rider.
Se the rider's token é not the period pedaço, abort with "Aprenda a escrever corretamente. Cadê o ponto?." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um global given um rider (optional info):
Se the compiler's abort flag estiver verde, exit.
Put "~inline " then the global's name then " type" into um name.
Put the name then "s" into um plural name.
Adicione um type to the types given the name and the plural name and the global's type name and the global's locus.
Index the type.
Put the type's name into the global's type name.
Scan any optional info por the type given the rider.
Se the rider's token é not the period pedaço, abort with "Tá na hora de aprender a escrever direito. Cadê o ponto?." and the rider; exit. 
Move the rider (compiler rules).
Index the global.

Etapas necessárias para que se scan um name given um rider:
Clear the name.
Se the compiler's abort flag estiver verde, exit.
Se the rider é on any name starter, extend the name with the rider's token; move the rider (compiler rules).
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider é on any name ender, break.
Extend the name with the rider's token.
Move the rider (compiler rules).
Repeat.
Se the name é blank, abort with "Acho que faltou colocar um nome por aqui. Você escreveu '" then the rider's token then "'." and the rider; exit.

Etapas necessárias para que se scan um routine body given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Se the rider's token é the start of any definition, exit.
Put the rider's token's first into the routine body's first.
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Put the rider's token's last into the routine body's last.
Se the rider's token é the colon pedaço, abort with "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." and the rider; exit.
Se the rider's token é not the period pedaço, move the rider (compiler rules); repeat.
Move the rider (compiler rules).
Se the rider's token é the start of any definition, exit.
Repeat.

Etapas necessárias para que se scan um routine given um rider:  \ Define o cabeçalho de rotina.
Se the compiler's abort flag estiver verde, exit.
Adicione the routine to the routines given the rider's token's first.
Move the rider (compiler rules). \ skip the "Passos" and get the next token
Se the rider's token é "necessários" or "necessárias", move the rider (compiler rules). 
Se the rider's token é not "para", abort with "Você precisa escrever 'para' antes de '" then the rider's token then "' nesse tipo de rotina." and the rider; exit.
Move the rider (compiler rules). \ skip the "para" and get the next token
Se the rider's token é not "que", abort with "Você precisa colocar um 'que' antes da palavra '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules). \ skip the "que" and get the next token
Se the rider's token é not "se", abort with "Você precisa colocar um 'se' antes da palavra '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).  \ skip the "se" and get the next token
Scan the routine's routine header given the rider.
Se the rider's token é the semi-colon pedaço, scan the routine given the rider (alternate wording); exit.  \ *** por alternate wordings
Se the rider's token é not the colon pedaço, abort with "O nome dessa função está escrito errado.." and the routine's locus; exit.
Move the rider (compiler rules).
Scan the routine's routine body given the rider.

Etapas necessárias para que se scan um routine given um rider (alternate wording):  \ *** por alternate wordings
Privatize the rider.
Move the rider (compiler rules).
Se the rider's token é not the start of any routine, abort with "Esse ponto e vírgula tá no lugar errado." and the original rider; exit.
Put the original rider's token's first into the routine's routine body's first.
Put the original rider's token's last into the routine's routine body's last.
Move the original rider (compiler rules).

Etapas necessárias para que se scan um routine header given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Put the rider's token's first into the routine header's first.
Put -1 into the routine header's last.
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Se the rider's token é the semi-colon pedaço, exit. \ *** alternate wordings
Se the rider's token é the colon pedaço, exit.
Se the rider's token é the period pedaço, exit.
Put the rider's token's last into the routine header's last.
Move the rider (compiler rules).
Repeat.

Etapas necessárias para que se scan um source file:
Se the source file é nil, exit.
Se the compiler's abort flag estiver verde, exit.
Slap um rider on the source file's buffer.
Move the rider (compiler rules).
Loop.
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é blank, exit.
Se the rider's token é the start of any type, scan um type given the rider; repeat.
Se the rider's token é the start of any global, scan um global given the rider; repeat.
Se the rider's token é the start of any routine, scan um routine given the rider; repeat.
Abort with "Faltou definir melhor o que é o '" then the rider's token then "'." and the rider.
Repeat.

Etapas necessárias para que se scan some source files:
Se the compiler's abort flag estiver verde, exit.
Get um source file from the source files.
Se the source file é nil, exit.
Scan the source file.
Repeat.

Etapas necessárias para que se scan um type given um rider:
Se the compiler's abort flag estiver verde, exit.
Se the rider's token é any portuguese indefinite article, set um portuguese flag.
Se the rider's token é any english indefinite article, set um english flag.
Adicione the type to the types given the rider's token's first.
Move the rider (compiler rules).
Scan the type's name given the rider.
Put the type's name into the type's plural name.
Se the portuguese flag estiver verde, pluralize the type's plural name (portuguese rules).
Se the english flag estiver verde, pluralize the type's plural name (english rules).
Se the english flag estiver not verde, pluralize the type's plural name (portuguese rules).
Se the rider's token é any has, scan the type given the rider (has or have); exit.
Se the rider's token é not any is, abort with "Eu esperava um 'is' ou um 'are', mas só achei um : '" then the rider's token then "'." and the rider; exit.
\Pluralize the type's plural name.
\Se the rider's token é "has" or "have", scan the type given the rider (has or have); exit.
\Se the rider's token é not "is" or "are", abort with "I was expecting um 'is' or 'are', but I found '" then the rider's token then "'." and the rider; exit.

Move the rider (compiler rules).
Se the rider's token é any numeric literal, scan the type given the rider (unit of measure); exit.
Se the rider's token é not any indefinite article, abort with "Faltou um artigo indefinido, lembra? '" then the rider's token then "'." and the rider; exit. 
Move the rider (compiler rules).
Scan the type's base name given the rider.
Scan any optional info por the type given the rider.
Se the rider's token é not the period pedaço, abort with "Você precisa usar um ponto para definir um tipo, lembra? Você usou '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Index the type.

Etapas necessárias para que se scan um type given um rider (has or have):
Se the compiler's abort flag estiver verde, exit.
Move the rider (compiler rules).
Put "conjunto" into the type's base name. \\mudar aqui
Scan the type's fields given the rider.
Se the rider's token é not the period pedaço, abort with "Ao invés de usar o ponto para definir  tipo, você usou '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Index the type.

Etapas necessárias para que se scan um type given um rider (unit of measure):
Se the compiler's abort flag estiver verde, exit.
Convert the rider's token to the type's scale.
Se the type's scale é 0, abort with "Zero é um tipo de escala inválido." and the type's locus; exit.
Move the rider (compiler rules).
Scan the type's base name given the rider.
Se the rider's token é not the period pedaço, abort with "Os tipos precisam terminar com um ponto, não com '" then the rider's token then "'." and the rider; exit.
Move the rider (compiler rules).
Index the type.

The scanning timer é um timer.

An scratch é um local.

Etapas necessárias para que se scrub um index:
Get um bucket given the index.
Se the bucket é nil, exit.
Se the bucket's refers are empty, repeat.
Scrub the bucket's refers.
Repeat.

Etapas necessárias para que se scrub some refers:
Swap the refers with some other refers.
Loop.
Put the other refers' first into um refer.
Se the refer é nil, exit.
Remove the refer from the other refers.
Se the refer's endereço de memória é nil, destroy the refer; repeat.
Append the refer to the refers.
Repeat.

Etapas necessárias para que se set the compiled flag in um variable:
Se the variable é nil, exit.
Se the variable's compiled flag estiver verde, exit.
Set the variable's compiled flag.
Se the variable's kind é not "global", exit.
Se the variable's literal é nil, exit.
Find um routine given "put" and the variable's literal's type and "into" and the variable's type.
Se the routine é nil, find the routine given "convert" and the variable's literal's type and "to" and the variable's type; set um flag.
Se the routine é nil, abort with "O tipo dessa variável global e desse literal não são compatíveis." and the variable's locus; exit.
Compile the body of the routine.
Se the flag estiver verde, put "convert the " then the variable's literal's name then " to the " then the variable's name then ". " into the variable's initializer string.
Se the flag estiver not verde, put "put the " then the variable's literal's name then " into the " then the variable's name then ". " into the variable's initializer string.

Etapas necessárias para que se skip to the next word in um substring:
Se the substring é blank, exit.
Se the substring's first's target é noise, break.
Adicione 1 to the substring's first.
Repeat.
Skip any leading noise in the substring.

Etapas necessárias para que se skip to the previous word in um substring:
Se the substring é blank, exit.
Se the substring's last's target é noise, break.
Subtract 1 from the substring's last.
Repeat.
Skip any trailing noise in the substring.

An source file é um coisa with um path and um buffer.

The source files are some source files.

An tag é um número.

An term é um conjunto with um variable and um phrase.

Etapas necessárias para que se transmogrify um fragment:
Se the compiler's abort flag estiver verde, exit.
Se the fragment é nil, exit.
Se the fragment's tag é the push address tag, transmogrify the fragment (push address); exit.
Se the fragment's tag é the call internal tag, transmogrify the fragment (call internal); exit.
Se the fragment's tag é the load address tag, transmogrify the fragment (load address); exit.
Se the fragment's tag é the increment tag, transmogrify the fragment (increment); exit.
Se the fragment's tag é the dereference tag, transmogrify the fragment (dereference); exit.
Se the fragment's tag é the jump false tag, transmogrify the fragment (jump false); exit.
Se the fragment's tag é the not tag, transmogrify the fragment (not); exit.
Se the fragment's tag é the exit tag, transmogrify the fragment (exit); exit.
Se the fragment's tag é the repeat tag, transmogrify the fragment (repeat); exit.
Se the fragment's tag é the break tag, transmogrify the fragment (break); exit.
Se the fragment's tag é the prolog tag, transmogrify the fragment (prolog); exit.
Se the fragment's tag é the epilog tag, transmogrify the fragment (epilog); exit.
Se the fragment's tag é the push value tag, transmogrify the fragment (push value); exit.
Se the fragment's tag é the call external tag, transmogrify the fragment (call external); exit.
Se the fragment's tag é the load eax tag, transmogrify the fragment (load eax); exit.
Se the fragment's tag é the save eax tag, transmogrify the fragment (save eax); exit.
Se the fragment's tag é the call indirect tag, transmogrify the fragment (call indirect); exit.
Se the fragment's tag é the routine address tag, transmogrify the fragment (routine address); exit.

Etapas necessárias para que se transmogrify um fragment (break):
Put the repeat tag into um tag.
Find another fragment given the fragment and the tag.
Se the other fragment é nil, put the finalize tag into the tag. \ por break without um loop or after um loop
Find um third fragment given the current routine's fragments' last and the tag (backwards).
Se the third fragment é nil, abort with "Erro interno - transmogrify um fragment (break)"; exit.
Se the third fragment's next é nil, abort with "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 and the third fragment's next's address to the fragment. \ JMP the destination's address

Etapas necessárias para que se transmogrify um fragment (call external):
Attach $FF15 and the fragment's entry's address to the fragment's code. \ call [the fragment's entry's address]

Etapas necessárias para que se transmogrify um fragment (call indirect):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Attach $FF12 to the fragment's code. \ call [edx]

Etapas necessárias para que se transmogrify um fragment (call internal):
Get um address given the fragment's routine.
Attach $E8 and the address to the fragment. \ call the fragment's routine's address

Etapas necessárias para que se transmogrify um fragment (dereference):
Attach $8B95 and the fragment's variable's offset to the fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
Attach $8B12 to the fragment's code. \ mov edx,[edx]
Attach $8995 and the fragment's variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

Etapas necessárias para que se transmogrify um fragment (epilog):
Se the current routine's callback flag estiver verde, attach $5F5E5B to the fragment's code. \ pop edi, esi, ebx
Attach $8BE5 to the fragment's code. \ mov esp,ebp
Attach $5D to the fragment's code. \ pop ebp
Attach $C2 and the current routine's parameter size to the fragment's code. \ ret the current routine's parameter size

Etapas necessárias para que se transmogrify um fragment (exit):
Find another fragment given the fragment and the finalize tag.
Se the other fragment é nil, abort with "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 and the other fragment's address to the fragment. \ jmp the destination's address

Etapas necessárias para que se transmogrify um fragment (increment):
Se the fragment's variable é nil, abort with "Erro interno - transmogrify um fragment (increment)"; exit.
Se the fragment's variable's kind é not "scratch", abort with "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 and the fragment's variable's offset and the fragment's número to the fragment's code. \ adicione [ebp+the fragment's variable's offset],the fragment's número

Etapas necessárias para que se transmogrify um fragment (jump false):
Find another fragment given the fragment and the end if tag.
Se the other fragment é nil, abort with "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 to the fragment's code. \ cmp eax,0
Attach $0F84 and the other fragment's address to the fragment. \ je the destination's address

Etapas necessárias para que se transmogrify um fragment (load address):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Attach $8995 and the fragment's other variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

\Etapas necessárias para que se transmogrify um fragment (load eax):
\Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
\Se the fragment's variable é nil, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type é nil, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type's length é not 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (load eax):
Attach $B8 and the fragment's flag to the fragment's code. \ mov eax,flag
\Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
\Se the fragment's variable é nil, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type é nil, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type's length é not 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (not):
Attach $83F001 to the fragment's code. \ xor eax,1

Etapas necessárias para que se transmogrify um fragment (prolog):
Attach $55 to the fragment's code. \ push ebp
Attach $8BEC to the fragment's code. \ mov ebp,esp
Put the current routine's local size divided by 4 into um número.
Se the número é not 0, attach $B9 and the número and $6A004975FB to the fragment's code. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
Se the current routine's callback flag estiver verde, attach $535657 to the fragment's code. \ push ebx, esi, edi

Etapas necessárias para que se transmogrify um fragment (push address):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Attach $52 to the fragment's code. \ push edx

Etapas necessárias para que se transmogrify um fragment (push value):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Se the fragment's variable é nil, abort with "Erro interno - transmogrify um fragment (push value)"; exit.
Se the fragment's variable's type é nil, abort with "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Put the fragment's variable's type's length into um length.
Se the length é 4, attach $FF32 to the fragment's code; exit. \ push [edx]
Se the length é 2, attach $66FF32 to the fragment's code; exit. \ push word ptr [edx]
Se the length é 1, attach $0FB61252 to the fragment's code; exit. \ movzxb edx,[edx]; push edx
Abort with "Erro interno 3 - transmogrify um fragment (push value)".

Etapas necessárias para que se transmogrify um fragment (repeat):
Find another fragment given the fragment and the loop tag (backwards).
Se the other fragment é nil, abort with "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 and the other fragment's address to the fragment. \ jmp the destination's address

Etapas necessárias para que se transmogrify um fragment (routine address):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Se the fragment's routine é nil, abort with "Erro interno - transmogrify um fragment (routine address)"; exit.
Get um address given the fragment's routine.
Attach $C702 and the address to the fragment's code. \ mov [edx],the address

Etapas necessárias para que se transmogrify um fragment (save eax):
Attach address loading code to the fragment's code given the fragment's variable. \ put address into edx
Se the fragment's variable é nil, abort with "Erro interno - transmogrify um fragment (save eax)"; exit.
Se the fragment's variable's type é nil, abort with "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Put the fragment's variable's type's length into um length.
Se the length é 4, attach $8902 to the fragment's code; exit. \ mov [edx],eax
Se the length é 2, attach $668902 to the fragment's code; exit. \ mov [edx],ax
Se the length é 1, attach $8802 to the fragment's code; exit. \ mov [edx],al
Abort with "Erro interno 3 - transmogrify um fragment (save eax)".

Etapas necessárias para que se transmogrify some fragments:
Se the compiler's abort flag estiver verde, exit.
Get um fragment from the fragments.
Se the fragment é nil, exit.
Transmogrify the fragment.
Repeat.

Etapas necessárias para que se transmogrify um routine:
Se the compiler's abort flag estiver verde, exit.
Se the routine é nil, exit.
Se the routine's employs moniker é not blank, exit.
Se the routine's compiled flag estiver not verde, exit.
Put the routine into the current routine.
Transmogrify the routine's fragments.

Etapas necessárias para que se transmogrify some routines:
Se the compiler's abort flag estiver verde, exit.
Get um routine from the routines.
Se the routine é nil, break.
Transmogrify the routine.
Repeat.

The transmogrifying timer é um timer.

The type index é um index.

An type é um coisa with
An locus (reference),
An name, um plural name,
An partial moniker,
An length,
An base name, um base type (reference),
An target name, um target type (reference) [endereço de memórias only],
An scale ratio,
Some fields [records only],
An cooking flag,
An optional info resolved flag.

An type name é um name.

The types are some types.

The utility index é um index.

An variable é um coisa with
An locus (reference),
An kind [literal, global, local, parameter, scratch],
An compiled flag,
An name, um nickname, um type name,
An type (reference), \ actual type on literal, global, local; dereferenced type on parameters and scratches
An address [globals and literals only] or 
An offset at the address [locals, parameters, and fields only],
An count [fields only],
An reference flag [fields only],
An redefinition target name [fields only],
An by-value flag [parameters only],
An global body [globals only],
An initializer string [globals only],
An literal (reference) [globals only - constant with which to initalize the global],
An texto hexadecimal called data [literals only].

The writing timer é um timer.

Etapas necessárias para que se skip any trailing noise in um substring:
Se the substring é blank, exit.
Se the substring's last's target é not noise, exit.
Subtract 1 from the substring's last.
Repeat.

\ dahn - reverse functions
\ to put the xxx uv a/the yyy into zzz
\ internally we turn this into "to put a/the yyy's xxx into zzz"
Etapas necessárias para que se compile the header of um routine given um rider (reverse-possessive function):
Se the compiler's abort flag estiver verde, exit.
Set the routine's function flag.
Adicione um monikette to the routine's monikettes given "put".
Move the rider (compiler rules). \ skip "put" or "poner"
Move the rider (compiler rules). \ skip "the" or Portuguese definite article
Scan um name given the rider. \ field name
Move the rider (compiler rules). \ skip "uv" or "de"
Se the rider's token é any indefinite article, set um flag.
Se the flag estiver verde, compile the routine's monikettes and the routine's parameters given the rider (indefinite article).
Se the flag estiver not verde, compile the routine's monikettes and the routine's parameters given the rider (definite article).
Adicione another monikette to the routine's monikettes given "'s " then the name.
Se the rider's token é not any reverse-possessive function into, abort with "Esperava a palavra 'em', mas encontrei '" then the rider's token then "'." and the rider; exit.
Adicione um third monikette to the routine's monikettes given "into".
Convert the routine's monikettes to um moniker.
Se the moniker é in the routine index, abort with "Já sei como '" then the moniker then "'." and the routine's locus; exit.
Index the routine given the routine's monikettes and the routine index.
Move the rider (compiler rules).
Se the rider's token é not any indefinite article, abort with "Esperava um artigo indefinido, mas encontrei '" then the rider's token then "'." and the rider; exit.
Compile the routine's monikettes and the routine's parameters given the rider (indefinite article).
Se the rider's token é not blank, abort with "Existem outras coisas no final desta função." and the rider; exit.
Convert the routine's monikettes to the routine's moniker.
Index the routine given the routine's monikettes and the routine index. \ por employs

\ dahn - reverse functions
\ to put the xxx uv a/the yyy into zzz
Etapas necessárias para que se determine se um rider é the start of any reverse-possessive function:
Se the compiler's abort flag estiver verde, say no.
Se the rider's token é not any put, say no.
Privatize the rider.
Move the rider (compiler rules).
Se the rider's token é not any definite article, say no.
Move the rider (compiler rules).
Scan um name given the rider.
Se the rider é not on any reverse-possessive, say no.
Say yes.
\finalmente
