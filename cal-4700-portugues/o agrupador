\ the compiler (el compilador) copyright © 2006-2021 the osmosian order

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

An mensagem de erro é um string.

Etapas necessárias para que se abort with um string:
Se the compiler's sinal de alerta estiver presente, cancele.
Abra the compiler's sinal de alerta.
Coloque the string into the compiler's mensagem de erro.

Etapas necessárias para que se abort with um string e um pedaço endereço de memória:
Se the compiler's sinal de alerta estiver presente, cancele.
Abra the compiler's sinal de alerta.
Coloque the string into the compiler's mensagem de erro.
Encontre the compiler's abort path e the compiler's abort row# usando the pedaço endereço de memória.
Se the compiler's abort path estiver em branco, cancele.
Extract um file name from the compiler's abort path.
Anteponha "Erro no " then the file name then ". " to the compiler's mensagem de erro.

Etapas necessárias para que se abort with um string e um rider:
Se the rider's token não estiver em branco, abort with the string e the rider's token's first; exit.
Abort with the string e the rider's source's last.

Etapas necessárias para que se adicione the allocate e deallocate e finalize e destroy routines:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Adicione the finalize routine por the type.
Adicione the allocate routine por the type.
Adicione the deallocate routine por the type.
Adicione the destroy routine por the type.
Repita.

Etapas necessárias para que se adicione the allocate routine por um type:
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type não pode ser reduzido para "endereço de memória", cancele.
Se the type's target type for inexistente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "allocate memory por um " then the type's name to the routine's header string. \ traduzir aqui
Posponha "assign the " then the type's name then " usando " to the routine's body string.
Posponha the type's target type's length then "." to the routine's body string.
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione e compile the initialize before run e run e finalize after run routine:
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "~initialize before run e run e finalize after run" to the routine's header string.
Posponha "initialize before run. " to the routine's body string.
Posponha the global initializers to the routine's body string.
Posponha "nosso programa seja executado. " to the routine's body string. \ traduzir
Posponha the global finalizers to the routine's body string.
Posponha "finalize after run. " to the routine's body string.
Posponha "call ""kernel32.dll"" ""ExitProcess"" with 0. " to the routine's body string.
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.
Compile the body of the routine.

Etapas necessárias para que se adicione the built-in types:
Adicione um built-in type usando "byte" e "bytes" e 1.
Adicione another built-in type usando "record" e "records" e 0.
Adicione um third built-in type usando "pedaço" e "pedaços" e 1.
Adicione um fourth built-in type usando "conjunto" e "conjuntos" e 0.

Etapas necessárias para que se adicione um built-in type usando um name e um plural name e um length:
Adicione the built-in type to the types usando the name e the plural name e the name.
Coloque the length into the built-in type's length.
Coloque the built-in type into the built-in type's base type.
Catalogue the built-in type.

Etapas necessárias para que se adicione the deallocate routine por um type:
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type não pode ser reduzido para "endereço de memória", cancele.
Se the type's target type for inexistente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "deallocate um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then " for inexistente, cancele. " to the routine's body string.
Se the type's target type deveria ser finalizado, posponha "~finalize the " then the type's name then "'s target. " to the routine's body string.
Posponha "unassign the " then the type's name then "." to the routine's body string.
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the destroy routine por um type:
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type não deveria ser ignorado, cancele.
Se the type pode ser reduzido para "coisas", adicione the destroy routine por the type (coisas); exit.
Se the type pode ser reduzido para "endereço de memória", adicione the destroy routine por the type (endereço de memória); exit.

Etapas necessárias para que se adicione the destroy routine por um type (endereço de memória):
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Coloque "destroy [" then the type's name then "]" into um moniker.
Se the moniker estiver in the routine index, cancele.
Adicione uma routine to the routines usando nil.
Posponha "destroy um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then " for inexistente, cancele. " to the routine's body string.
Se the type's target type pode ser reduzido para "endereço de memória", posponha "destroy the " then the type's name then "'s target. " to the routine's body string.
Se the type's target type pode ser reduzido para "coisas", posponha "destroy the " then the type's name then "'s target. " to the routine's body string.
Percorra.
Obtenha um field from the type's target type's fields.
Se the field for inexistente, pare.
Se the field's reference sinal estiver verde, repita.
Se the field's type não deveria ser ignorado, repita.
Posponha "destroy the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repita.
Posponha "deallocate the " then the type's name then ". " to the routine's body string. \ traduzir aqui
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the destroy routine por um type (coisas):
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Coloque "Erro interno na hora de executar a tarefa de destruição de tipos"  into a reply.
Se the type's fields' first for inexistente, abort with "Erro interno  na rotina 'adicione um forget routine por um type (coisas)'"; [Say the reply;] exit. \Adicionado Say the reply
Se the type's fields' first's type for inexistente, abort with "Erro interno 2 na rotina 'adicione the forget routine por um type (coisas)'"; exit.
Coloque "destroy [" then the type's name then "]" into um moniker.
Se the moniker estiver in the routine index, cancele.
Adicione uma routine to the routines usando nil.
Posponha "destroy um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then "'s first for inexistente, cancele. " to the routine's body string.
Coloque the type's fields' first's type's name into um name.
Posponha "coloque the " then the type's name then "'s first into um " then the name then ". " to the routine's body string.
Posponha "remove the " then the name then " from the " then the type's name then ". " to the routine's body string.
Posponha "destroy the " then the name then ". " to the routine's body string.
Posponha "repeat. " to the routine's body string.
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione um entry to some imports usando um import name e um entry name:
Encontre um import usando the import name.
Se the import for inexistente, adicione the import to the imports usando the import name.
Encontre the entry usando the entry name e the import's entries.
Se the entry não for inexistente, cancele.
Crie the entry.
Posponha the entry to the import's entries.
Coloque the entry name into the entry's name.

Etapas necessárias para que se adicione um field to some fields usando um name e um nickname e um type name e um reference sinal:
Adicione the field to the fields usando "field" e nil.
Coloque the name into the field's name.
Coloque the nickname into the field's nickname.
Coloque the type name into the field's type name.
Coloque the reference sinal into the field's reference sinal.

Etapas necessárias para que se adicione the finalize routine por um type:
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type não deveria ser finalizado, cancele.
Se the type's name for "string", adicione the finalize routine por the type (string); exit.
Se the type pode ser reduzido para "string", cancele. \ prevents generation of finalizer por derived string types
Adicione the finalize routine por the type (conjunto).

Etapas necessárias para que se adicione the finalize routine por um type (conjunto):
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "~finalize um " then the type's name to the routine's header string.
Posponha "intel $50. " to the routine's body string. \ push eax
Percorra.
Obtenha um field from the type's fields.
Se the field for inexistente, pare.
Se the field's type não deveria ser finalizado, repita.
Posponha "~finalize the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repita.
Posponha "intel $58." to the routine's body string. \ pop eax
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the finalize routine por um type (string):
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "~finalize um " then the type's name to the routine's header string.
Posponha "intel $50. " to the routine's body string. \ push eax
Posponha "unassign the string's first. " to the routine's body string.
Posponha "intel $58." to the routine's body string. \ pop eax
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione um fragment usando uma tag:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.

Etapas necessárias para que se adicione um fragment usando uma tag e um entry:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the entry into the fragment's entry.

Etapas necessárias para que se adicione um fragment usando uma tag e um sinal:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the sinal into the fragment's sinal.

Etapas necessárias para que se adicione um fragment usando uma tag e uma routine:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the routine into the fragment's routine.
Compile the body of the routine.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the variable into the fragment's variable.
Abra the compiled sinal in the variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e another variable:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the variable into the fragment's variable.
Coloque the other variable into the fragment's other variable.
Abra the compiled sinal in the variable.
Abra the compiled sinal in the other variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e um número:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the variable into the fragment's variable.
Coloque the número into the fragment's número.
Abra the compiled sinal in the variable.

Etapas necessárias para que se adicione um import to some imports usando um import name:
Crie the import.
Posponha the import to the imports.
Coloque the import name into the import's name.

Etapas necessárias para que se adicione um intermediate usando um type name e um locus:
Se the current routine for inexistente, esvazie the intermediate; exit.
Adicione the intermediate to the current routine's locals usando "local" e the locus.
Gere the intermediate's name usando "~I".
Coloque the type name into the intermediate's type name.
Resolva the intermediate.

Etapas necessárias para que se adicione um literal to some variables usando um locus:
Adicione the literal como uma variable to the variables usando "literal" e the locus.
Gere the literal's name usando "~L".

Etapas necessárias para que se adicione um monikette to some monikettes usando um expression:
Crie the monikette.
Posponha the monikette to the monikettes.
Coloque the expression's phrase into the monikette's string.
Coloque the expression's variable into the monikette's variable.
Se the expression's variable não for inexistente, coloque the expression's type into the monikette's type.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette to some monikettes usando um string:
Crie the monikette.
Posponha the monikette to the monikettes.
\PAL
\\ conjunctions
Se the string for "e", coloque "e" into the monikette's string; exit. \ and
Se the string for "ou", coloque "or" into the monikette's string; exit. \ or
\ from/given/with/using
Se the string for "desde", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "a partir de", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "partindo de", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "de", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "dada", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "dado", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "dadas", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "dados", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "com", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "usando", coloque "from/given/with/using" into the monikette's string; exit.
\\ in/into/to
Se the string for "em", coloque "in/into/to" into the monikette's string; exit.
Se the string for "a", coloque "in/into/to" into the monikette's string; exit.
\\ is/are
Se the string for "é", coloque "is/are" into the monikette's string; exit.
Se the string for "está", coloque "is/are" into the monikette's string; exit.
Se the string for "for", coloque "is/are" into the monikette's string; exit. 
Se the string for "foi", coloque "is/are" into the monikette's string; exit. 
Se the string for "foram", coloque "is/are" into the monikette's string; exit. 
Se the string for "forem", coloque "is/are" into the monikette's string; exit. 
Se the string for "estiver", coloque "is/are" into the monikette's string; exit.
Se the string for "estiverem", coloque "is/are" into the monikette's string; exit.
\Se the string for "tem", coloque "is/are" into the monikette's string; exit.
\Se the string for "tiver", coloque "is/are" into the monikette's string; exit.
Se the string for "are", coloque "is/are" into the monikette's string; exit.
Se the string for "são", coloque "is/are" into the monikette's string; exit.
Se the string for "estão", coloque "is/are" into the monikette's string; exit.
Se the string for "is", coloque "is/are" into the monikette's string; exit.
Se the string for "forem", coloque "is/are" into the monikette's string; exit.
Se the string for "estiverem", coloque "is/are" into the monikette's string; exit.
Se the string for "puder", coloque "pode" into the monikette's string; exit.
Se the string for "puderem", coloque "pode" into the monikette's string; exit.
Se the string for "existir", coloque "existe" into the monikette's string; exit.
\\ allocates e destroys
\Se the string for "alojar", coloque "allocate" into the monikette's string; exit.
Se the string for "aloje", coloque "allocate" into the monikette's string; exit.
\Se the string for "alocar", coloque "allocate" into the monikette's string; exit.
Se the string for "aloque", coloque "allocate" into the monikette's string; exit.
\Se the string for "reservar", coloque "allocate" into the monikette's string; exit.
Se the string for "reserve", coloque "allocate" into the monikette's string; exit.
Se the string for "memória", coloque "memory" into the monikette's string; exit.
\Se the string for "for", coloque "por" into the monikette's string; exit. \\servia pra converter o "for" para "por"
Se the string for "pelo", coloque "por the" into the monikette's string; exit. 
Se the string for "pela", coloque "por the" into the monikette's string; exit. 
\Se the string for "desalocar", coloque "deallocate" into the monikette's string; exit.
Se the string for "desaloque", coloque "deallocate" into the monikette's string; exit.
\Se the string for "desalojar", coloque "deallocate" into the monikette's string; exit.
Se the string for "desaloje", coloque "deallocate" into the monikette's string; exit.
\Se the string for "esvaziar", coloque "deallocate" into the monikette's string; exit.
\Se the string for "esvazie", coloque "deallocate" into the monikette's string; exit.
Se the string for "destruir", coloque "destroy" into the monikette's string; exit.
\CAL
\\ from/given/with/using
Se the string for "from", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "given", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "with", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "using", coloque "from/given/with/using" into the monikette's string; exit.
\ in/into/to
Se the string for "in", coloque "in/into/to" into the monikette's string; exit.
Se the string for "into", coloque "in/into/to" into the monikette's string; exit.
Se the string for "to", coloque "in/into/to" into the monikette's string; exit.
\ is/are
Se the string for "are", coloque "is/are" into the monikette's string; exit.
Se the string for "is", coloque "is/are" into the monikette's string; exit.
\ aren't/isn't
Se the string for "isn't", coloque "is/aren't" into the monikette's string; exit.
Se the string for "aren't", coloque "is/aren't" into the monikette's string; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se the string for "backward", coloque "backward" into the monikette's string; exit.
Se the string for "backwards", coloque "backward" into the monikette's string; exit.
Se the string for "counterclockwise", coloque "backward" into the monikette's string; exit.
Se the string for "counter-clockwise", coloque "backward" into the monikette's string; exit.
Se the string for "anticlockwise", coloque "backward" into the monikette's string; exit.
Se the string for "anti-clockwise", coloque "backward" into the monikette's string; exit.
\ at/on
Se the string for "at", coloque "at/on" into the monikette's string; exit.
Se the string for "on", coloque "at/on" into the monikette's string; exit.
\ other
Coloque the string into the monikette's string.

Etapas necessárias para que se adicione um monikette to some monikettes usando um type:
Crie the monikette.
Posponha the monikette to the monikettes. 
Coloque the type into the monikette's type.

Etapas necessárias para que se adicione push fragments usando some monikettes:
Se the current routine for inexistente, cancele.
Percorra.
Obtenha um monikette from the monikettes (backwards).
Se the monikette for inexistente, cancele.
Se the monikette's variable for inexistente, repita.
Se the monikette's current substring não estiver em branco, repita.
Se the monikette's current type for inexistente, repita.
Adicione um fragment usando the push address tag e the monikette's variable.
Repita.

Etapas necessárias para que se adicione the coloque ou convert fragments usando uma variable e another variable e um locus:
Adicione um fragment usando the push address tag e the other variable.
Adicione another fragment usando the push address tag e the variable.
Encontre uma routine usando "coloque" e the variable's type e "into" e the other variable's type.
Se the routine for inexistente, encontre the routine usando "convert" e the variable's type e "to" e the other variable's type.
Se the routine não for inexistente, adicione um third fragment usando the call internal tag e the routine; exit.
\ error message
Adicione um monikette to some monikettes usando "coloque/convert".
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando "into/to".
Adicione um fourth monikette to the monikettes usando the other variable's type.
Convert the monikettes to um moniker.
Destroy the monikettes.
Abort with "Eu não sei como '" then the moniker then "'." e the locus.

Etapas necessárias para que se adicione uma routine to some routines usando um locus:
Crie the routine.
Posponha the routine to the routines.
Coloque the locus into the routine's locus.

Etapas necessárias para que se adicione um scratch usando um type name e um locus:
Se the current routine for inexistente, esvazie the scratch; exit.
Adicione the scratch to the current routine's locals usando "scratch" e the locus.
Gere the scratch's name usando "~S".
Coloque the type name into the scratch's type name.
Resolva the scratch.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um locus:
Adicione um fragment usando the push address tag e the other variable.
Adicione another fragment usando the push address tag e the variable.
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other variable's type.
Encontre uma routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the locus; exit.
Adicione um third fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um third string e um third variable e um pedaço endereço de memória:
Adicione um fragment usando the push address tag e the third variable.
Adicione another fragment usando the push address tag e the other variable.
Adicione um third fragment usando the push address tag e the variable.
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other variable's type.
Adicione um fifth monikette to the monikettes usando the third string.
Adicione um sixth monikette to the monikettes usando the third variable's type.
Encontre uma routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the pedaço endereço de memória; exit.
Adicione um fourth fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione um source file to some source files usando um path:
Crie the source file.
Posponha the source file to the source files.
Coloque the path into the source file's path.

Etapas necessárias para que se adicione two fragments usando um string e uma variable e um locus:
Adicione um fragment usando the push address tag e the variable.
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Encontre uma routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the locus; exit.
Adicione another fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione um type to some types usando um locus:
Crie the type.
Posponha the type to the types.
Coloque the locus into the type's locus.

Etapas necessárias para que se adicione um type to some types usando um name e um plural name e um base name:
Adicione the type to the types usando the name e the plural name e the base name e nil.

Etapas necessárias para que se adicione um type to some types usando um name e um plural name e um base name e um locus:
Crie the type.
Posponha the type to the types.
Coloque the locus into the type's locus.
Coloque the name into the type's name.
Coloque the plural name into the type's plural name.
Coloque the base name into the type's base name.

Etapas necessárias para que se adicione uma variable to some variables usando um kind e um locus:
Crie the variable usando the kind.
Posponha the variable to the variables.
Coloque the locus into the variable's locus.

The adding built-in memory routines timer é um timer.

The adding built-in startup routine timer é um timer.

Etapas necessárias para que se address some entries:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
Address the entry.
Repita.

Etapas necessárias para que se address um entry:
Coloque the current name address into the entry's name address.
Coloque the entry's name's length plus 3 into um número.
Round the número up to the nearest multiple of 2.
Adicione the número to the current name address.
Coloque the current thunk address into the entry's thunk address.
Coloque the image base plus the current thunk address into the entry's address.
Adicione 4 to the current thunk address.

Etapas necessárias para que se address um fragment usando um address:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the fragment for inexistente, cancele.
Coloque the image base plus the address into the fragment's address.
Se the fragment's tag é the push address tag, adicione 7 to the address; exit.
Se the fragment's tag é the call internal tag, adicione 5 to the address; exit.
Se the fragment's tag é the load address tag, adicione 12 to the address; exit.
Se the fragment's tag é the increment tag, adicione 10 to the address; exit.
Se the fragment's tag é the dereference tag, adicione 14 to the address; exit.
Se the fragment's tag é the jump false tag, adicione 9 to the address; exit.
Se the fragment's tag é the not tag, adicione 3 to the address; exit.
Se the fragment's tag é the exit tag, adicione 5 to the address; exit.
Se the fragment's tag é the repeat tag, adicione 5 to the address; exit.
Se the fragment's tag é the break tag, adicione 5 to the address; exit.
Se the fragment's tag é the prolog tag, address the fragment usando the address (prolog); exit.
Se the fragment's tag é the epilog tag, address the fragment usando the address (epilog); exit.
Se the fragment's tag é the intel tag, adicione the fragment's code's length to the address; exit.
Se the fragment's tag é the push value tag, address the fragment usando the address (push value); exit.
Se the fragment's tag é the call external tag, adicione 6 to the address; exit.
Se the fragment's tag é the load eax tag, adicione 5 to the address; exit. \ was 8 when "load eax" took in variables; now "load eax" only does um immediate value
Se the fragment's tag é the save eax tag, address the fragment usando the address (save eax); exit.
Se the fragment's tag é the call indirect tag, adicione 8 to the address; exit.
Se the fragment's tag é the routine address tag, adicione 12 to the address; exit.

Etapas necessárias para que se address um fragment usando um address (epilog):
Se the current routine's callback sinal estiver verde, adicione 3 to the address.
Adicione 6 to the address.

Etapas necessárias para que se address um fragment usando um address (prolog):
Adicione 3 to the address.
Se the current routine's local size não for 0, adicione 10 to the address.
Se the current routine's callback sinal estiver verde, adicione 3 to the address.

Etapas necessárias para que se address um fragment usando um address (push value):
Adicione 6 to the address.
Se the fragment's variable for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Coloque the fragment's variable's type's length into um length.
Se the length for 4, adicione 2 to the address; exit.
Se the length for 2, adicione 3 to the address; exit.
Se the length for 1, adicione 4 to the address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address um fragment usando um address (save eax):
Adicione 6 to the address.
Se the fragment's variable for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Coloque the fragment's variable's type's length into um length.
Se the length for 4, adicione 2 to the address; exit.
Se the length for 2, adicione 3 to the address; exit.
Se the length for 1, adicione 2 to the address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address some fragments usando um address:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Address the fragment usando the address.
Repita.

Etapas necessárias para que se address um import:
Coloque the current name address into the import's name address.
Coloque the current header address into the import's header address.
Coloque the current name address into the import's import header's name memory address.
Coloque the import's name's length plus 1 into um número.
Round the número up to the nearest multiple of 2.
Adicione the número to the current name address.
Adicione um import header's magnitude to the current header address.
Coloque the current thunk address into the import's import header's first thunk memory address.
Address the import's entries.
Adicione 4 to the current thunk address.

Etapas necessárias para que se address some imports usando um address:
Coloque the address into the current header address.
Coloque the imports' count into um count.
Adicione 1 to the count.
Multiplique the count por um import header's magnitude.
Coloque the address plus the count into the current thunk address.
Obtenha another count usando the imports (all entries plus markers).
Multiplique the other count por 4.
Coloque the current thunk address plus the other count into the current name address.
Percorra.
Obtenha um import from the imports.
Se the import for inexistente, pare.
Address the import.
Repita.
Coloque the current name address minus the address into um número.
Adicione the número to the address.

An address é um número.

Etapas necessárias para que se address uma routine usando um address:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the routine for inexistente, cancele.
Se the routine's employs moniker não estiver em branco, cancele. \ employs are addressed later
Se the routine's compiled sinal não estiver verde, cancele.
Coloque the routine into the current routine.
Coloque the image base plus the address into the routine's address.
Address the routine's fragments usando the address.
Round the address up to the nearest multiple of 4.

Etapas necessárias para que se address some routines usando um address:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, pare.
Address the routine usando the address.
Repita.

Etapas necessárias para que se address uma variable usando um address:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the variable for inexistente, cancele.
Se the variable's compiled sinal não estiver verde, cancele.
Coloque the image base plus the address into the variable's address.
Adicione the variable's type's length to the address.
Se the variable's type pode ser reduzido para "string", adicione the variable's data's length plus 1 to the address.
Round the address up to the nearest multiple of 4.

Etapas necessárias para que se address some variables usando um address:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha uma variable from the variables.
Se the variable for inexistente, cancele.
Address the variable usando the address.
Repita.

The addressing timer é um timer.

Etapas necessárias para que se advance um buffer:
Posponha the return pedaço to the buffer.
Posponha the linefeed pedaço to the buffer.

Etapas necessárias para que se advance um buffer (twice):
Advance the buffer. 
Advance the buffer.

Etapas necessárias para que se posponha um entry to um buffer (with separator):
Se the entry for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the entry's name to the buffer (with separator).

Etapas necessárias para que se posponha um sinal to um buffer (with separator):
Convert the sinal to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha the global finalizers to um string:
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Se the global's compiled sinal não estiver verde, repita.
Se the global's type não deveria ser finalizado, repita.
Posponha "~finalize the " then the global's name then ". " to the string.
Repita.

Etapas necessárias para que se posponha the global initializers to um string:
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Se the global's literal for inexistente, repita.
Se the global's compiled sinal não estiver verde, repita.
Feche um sinal.
Posponha the global's initializer string to the string.
Repita.

Etapas necessárias para que se posponha um monikette to um moniker:
Se the monikette for inexistente, cancele.
Se the moniker não estiver em branco, posponha the space pedaço to the moniker.
Se the monikette's type não for inexistente, posponha "[" e the monikette's type's name e "]" to the moniker (fast); exit.
Se the monikette's string não estiver em branco, posponha the monikette's string to the moniker; exit.

Etapas necessárias para que se posponha um monikette to um moniker (while bubbling):
Se the monikette for inexistente, cancele.
Se the moniker não estiver em branco, posponha the space pedaço to the moniker.
Se the monikette's current substring não estiver em branco, posponha the monikette's current substring to the moniker; exit.
Se the monikette's current type não for inexistente, posponha "[" e the monikette's current type's name e "]" to the moniker (fast); exit.

Etapas necessárias para que se posponha um número to um buffer (as hex with separator):
Convert the número to um nibble string.
Posponha the nibble string to the buffer (with separator).

Etapas necessárias para que se posponha um número to um buffer (with separator):
Convert the número to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha um ratio to um buffer (with separator):
Convert the ratio to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha uma routine to um buffer (with separator):
Se the routine for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the routine's moniker to the buffer (with separator).

Etapas necessárias para que se posponha um string e another string e um third string to um fourth string (fast):
Coloque the fourth string's length into um length.
Adicione the string's length to the length.
Adicione the other string's length to the length.
Adicione the third string's length to the length.
Reassign um endereço de memória usando the length.
Coloque the endereço de memória into um pedaço endereço de memória.
Copy pedaços from the fourth string's first to the pedaço endereço de memória por the fourth string's length.
Adicione the fourth string's length to the pedaço endereço de memória.
Copy pedaços from the string's first to the pedaço endereço de memória por the string's length.
Adicione the string's length to the pedaço endereço de memória.
Copy pedaços from the other string's first to the pedaço endereço de memória por the other string's length.
Adicione the other string's length to the pedaço endereço de memória.
Copy pedaços from the third string's first to the pedaço endereço de memória por the third string's length.
Unassign the fourth string's first.
Coloque the endereço de memória into the fourth string's first.
Coloque the endereço de memória plus the length minus 1 into the fourth string's last.

Etapas necessárias para que se posponha um string to um buffer (with separator):
Posponha the string to the buffer.
Posponha "/" to the buffer.

Etapas necessárias para que se posponha uma tag to um buffer (as um fragment tag string with separator):
Se the tag é the break tag, posponha "break" to the buffer (with separator); exit.
Se the tag é the call external tag, posponha "call external" to the buffer (with separator); exit.
Se the tag é the call indirect tag, posponha "call indirect" to the buffer (with separator); exit.
Se the tag é the call internal tag, posponha "call internal" to the buffer (with separator); exit.
Se the tag é the dereference tag, posponha "dereference" to the buffer (with separator); exit.
Se the tag é the end if tag, posponha "end if" to the buffer (with separator); exit.
Se the tag é the epilog tag, posponha "epilog" to the buffer (with separator); exit.
Se the tag é the exit tag, posponha "exit" to the buffer (with separator); exit.
Se the tag é the finalize tag, posponha "finalize" to the buffer (with separator); exit.
Se the tag é the increment tag, posponha "increment" to the buffer (with separator); exit.
Se the tag é the intel tag, posponha "intel" to the buffer (with separator); exit.
Se the tag é the jump false tag, posponha "jump false" to the buffer (with separator); exit.
Se the tag é the load address tag, posponha "load address" to the buffer (with separator); exit.
Se the tag é the load eax tag, posponha "load eax" to the buffer (with separator); exit.
Se the tag é the loop tag, posponha "loop" to the buffer (with separator); exit.
Se the tag é the not tag, posponha "not" to the buffer (with separator); exit.
Se the tag é the prolog tag, posponha "prolog" to the buffer (with separator); exit.
Se the tag é the push address tag, posponha "push address" to the buffer (with separator); exit.
Se the tag é the push value tag, posponha "push value" to the buffer (with separator); exit.
Se the tag é the save eax tag, posponha "save eax" to the buffer (with separator); exit.
Se the tag é the repeat tag, posponha "repeat" to the buffer (with separator); exit.
Se the tag é the routine address tag, posponha "routine address" to the buffer (with separator); exit.
Posponha "?" to the buffer (with separator).

Etapas necessárias para que se posponha um type to um buffer (with separator):
Se the type for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the type's name to the buffer (with separator).

Etapas necessárias para que se posponha uma variable to um buffer (with separator):
Se the variable for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the variable's name to the buffer (with separator).

Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules):
\# contrações
Se the string for "ao", posponha "para o" to the other string; exit.
Se the string for "à", posponha "para a" to the other string; exit.
Se the string for "aos", posponha "para os" to the other string; exit.
Se the string for "às", posponha "para as" to the other string; exit.
Se the string for "do", posponha "de o" to the other string; exit.
Se the string for "da", posponha "de a" to the other string; exit.
Se the string for "dos", posponha "de os" to the other string; exit.
Se the string for "das", posponha "de as" to the other string; exit.
Se the string for "dum", posponha "de um" to the other string; exit.
Se the string for "duma", posponha "de uma" to the other string; exit.
Se the string for "dumas", posponha "de umas" to the other string; exit.
Se the string for "duns", posponha "de uns" to the other string; exit.
Se the string for "daqui", posponha "de aqui" to the other string; exit.
Se the string for "dali", posponha "de ali" to the other string; exit.
Se the string for "dele", posponha "de ele" to the other string; exit.
Se the string for "dela", posponha "de ela" to the other string; exit.
Se the string for "desse", posponha "de esse" to the other string; exit.
Se the string for "dessa", posponha "de essa" to the other string; exit.
Se the string for "desses", posponha "de esses" to the other string; exit.
Se the string for "dessas", posponha "de essas" to the other string; exit.
Se the string for "deste", posponha "de este" to the other string; exit.
Se the string for "desta", posponha "de esta" to the other string; exit.
Se the string for "destes", posponha "de estes" to the other string; exit.
Se the string for "destas", posponha "de estas" to the other string; exit.
Se the string for "disso", posponha "de isso" to the other string; exit.
Se the string for "disto", posponha "de isto" to the other string; exit.
Se the string for "nesse", posponha "em esse" to the other string; exit.
Se the string for "nesses", posponha "em esses" to the other string; exit.
Se the string for "neste", posponha "em este" to the other string; exit.
Se the string for "nestes", posponha "em estes" to the other string; exit.
Se the string for "nisso", posponha "em isso" to the other string; exit.
Se the string for "nisto", posponha "em isto" to the other string; exit.
Se the string for "nessa", posponha "em essa" to the other string; exit.
Se the string for "nessas", posponha "em essas" to the other string; exit.
Se the string for "nesta", posponha "em esta" to the other string; exit.
Se the string for "nestas", posponha "em estas" to the other string; exit.
Se the string for "donde", posponha "de onde" to the other string; exit.
Se the string for "dentre", posponha "de entre" to the other string; exit.
Se the string for "dantes", posponha "de antes" to the other string; exit.
Se the string for "dalguém", posponha "de alguém" to the other string; exit.
Se the string for "dalgum", posponha "de algum" to the other string; exit.
Se the string for "dalguma", posponha "de alguma" to the other string; exit.
Se the string for "dalguns", posponha "de alguns" to the other string; exit.
Se the string for "dalgumas", posponha "de algumas" to the other string; exit.
Se the string for "nalgum", posponha "em algum" to the other string; exit.
Se the string for "nalguma", posponha "em alguma" to the other string; exit.
Se the string for "nalguns", posponha "em alguns" to the other string; exit.
Se the string for "nalgumas", posponha "em algumas" to the other string; exit.
Se the string for "doutro", posponha "de outro" to the other string; exit.
Se the string for "doutra", posponha "de outra" to the other string; exit.
Se the string for "doutros", posponha "de outros" to the other string; exit.
Se the string for "doutras", posponha "de outras" to the other string; exit.
Se the string for "noutro", posponha "em outro" to the other string; exit.
Se the string for "noutra", posponha "em outra" to the other string; exit.
Se the string for "noutros", posponha "em outros" to the other string; exit.
Se the string for "noutras", posponha "em outras" to the other string; exit.
\# "no" pode ser uma negação em inglês.
Se the string é any contraction giving the third string (portuguese rules - "no"), posponha "em o" to the other string; exit.
Se the string for "na", posponha "em a" to the other string; exit.
Se the string for "nos", posponha "em os" to the other string; exit.
Se the string for "nas", posponha "em as" to the other string; exit.
\Se the string for "noutro", posponha "em outro" to the other string; exit.
\Se the string for "noutra", posponha "em outra" to the other string; exit.
\Se the string for "noutros", posponha "em outros" to the other string; exit.
\Se the string for "noutras", posponha "em outras" to the other string; exit.
Se the string for "num", posponha "em um" to the other string; exit.
Se the string for "numa", posponha "em uma" to the other string; exit.
Se the string for "nuns", posponha "em uns" to the other string; exit.
Se the string for "numas", posponha "em umas" to the other string; exit.
Se the string for "pelo", posponha "por o" to the other string; exit.
Se the string for "pela", posponha "por a" to the other string; exit.
Se the string for "pelos", posponha "por os" to the other string; exit.
Se the string for "pelas", posponha "por as" to the other string; exit.
\# sinônimos
Se the string for "adir", posponha "adicionar" to the other string; exit.
Se the string for "agregar", posponha "adicionar" to the other string; exit.
Se the string for "acrescentar", posponha "adicionar" to the other string; exit.
Se the string for "somar", posponha "adicionar" to the other string; exit.
Se the string for "começar", posponha "iniciar" to the other string; exit.
Se the string for "terminar", posponha "finalizar" to the other string; exit.
Se the string for "acabar", posponha "finalizar" to the other string; exit.
Se the string for "completar", posponha "finalizar" to the other string; exit.
Se the string for "colocar", posponha "pôr" to the other string; exit.
Se the string for "mudar", posponha "alterar" to the other string; exit.
Se the string for "limpar", posponha "apagar" to the other string; exit.
Se the string for "ampliar", posponha "aumentar" to the other string; exit.
Se the string for "expandir", posponha "aumentar" to the other string; exit.
Se the string for "alargar", posponha "aumentar" to the other string; exit.
Se the string for "dilatar", posponha "aumentar" to the other string; exit.
Se the string for "estender", posponha "aumentar" to the other string; exit.
Se the string for "prolongar", posponha "aumentar" to the other string; exit.
Se the string for "ampliar", posponha "aumentar" to the other string; exit.
Se the string for "achar", posponha "encontrar" to the other string; exit.
Se the string for "descobrir", posponha "encontrar" to the other string; exit.
Se the string for "buscar", posponha "encontrar" to the other string; exit.
Se the string for "manusear", posponha "manejar" to the other string; exit.
Se the string for "manipular", posponha "manejar" to the other string; exit.
Se the string for "enumerar", posponha "listar" to the other string; exit.
Se the string for "elencar", posponha "listar" to the other string; exit.
Se the string for "selecionar", posponha "escolher" to the other string; exit.
Se the string for "eliminar", posponha "remover" to the other string; exit.
Se the string for "excluir", posponha "remover" to the other string; exit.
Se the string for "retirar", posponha "remover" to the other string; exit.
Se the string for "rodar", posponha "girar" to the other string; exit.
Se the string for "começar", posponha "iniciar" to the other string; exit.
Se the string for "permutar", posponha "trocar" to the other string; exit.
Se the string for "esperar", posponha "aguardar" to the other string; exit.
Se the string for "rascunhar", posponha "esboçar" to the other string; exit.
Se the string for "antepor", posponha "prepor" to the other string; exit.
Posponha the string to the other string.

Etapas necessárias para que se attach address loading code to um texto hexadecimal usando uma variable: \ loads into edx
Se the variable for inexistente, attach $C7C200000000 to the texto hexadecimal; exit. \ mov edx,0
Se the variable's kind for "global", attach $C7C2 e the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
Se the variable's kind for "literal", attach $C7C2 e the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
Se the variable's kind for "local", attach $8D95 e the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Se the variable's kind for "scratch", attach $8B95 e the variable's offset to the texto hexadecimal; exit. \ mov edx,[ebp+the variable's offset]
Se the variable's kind não for "parameter", abort with "Erro interno - attach address loading code to um texto hexadecimal usando uma variable"; exit.
Se the variable's by-value sinal estiver verde, attach $8D95 e the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Attach $8B95 e the variable's offset to the texto hexadecimal. \ mov edx,[ebp+the variable's offset]

Etapas necessárias para que se attach um texto hexadecimal e um address to um fragment: \ call ou jump
Coloque the address into um número.
Subtraia the fragment's address from the número.
Subtraia the fragment's code's length from the número.
Subtraia the texto hexadecimal's length from the número.
Subtraia 4 from the número.
Attach the texto hexadecimal e the número to the fragment's code.

Etapas necessárias para que se attach um texto hexadecimal e um número e another texto hexadecimal to um third texto hexadecimal:
Posponha the texto hexadecimal to the third texto hexadecimal.
Convert the número to um fourth texto hexadecimal.
Posponha the fourth texto hexadecimal to the third texto hexadecimal.
Posponha the other texto hexadecimal to the third texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um número e another número to another texto hexadecimal:
Posponha the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Posponha the third texto hexadecimal to the other texto hexadecimal.
Convert the other número to um fourth texto hexadecimal.
Posponha the fourth texto hexadecimal to the other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um sinal to another texto hexadecimal;
Etapas necessárias para que se attach um texto hexadecimal e um número to another texto hexadecimal:
Posponha the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Posponha the third texto hexadecimal to the other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal to another texto hexadecimal: employ posponha um string to another string.

Etapas necessárias para que se blurt pedaços usando um endereço de memória e um length e um buffer e um offset:
Coloque the buffer's first plus the offset into another endereço de memória.
Copy pedaços from the endereço de memória to the other endereço de memória por the length.

Etapas necessárias para que se blurt um dos header into um buffer:
Blurt pedaços usando the dos header's whereabouts e the dos header's magnitude e the buffer e 0.

Etapas necessárias para que se blurt some entries into um buffer:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
Blurt the entry into the buffer.
Repita.

Etapas necessárias para que se blurt um entry into um buffer:
Blurt pedaços usando the entry's name address's whereabouts e 4 e the buffer e the entry's thunk address.
Coloque the entry's name address plus 2 into um address.
Blurt the entry's name into the buffer at the address.

Etapas necessárias para que se blurt um fragment into um buffer:
Se the fragment's code estiver em branco, cancele.
Coloque the fragment's address minus the image base into um address.
Blurt the fragment's code into the buffer at the address.

Etapas necessárias para que se blurt some fragments into um buffer:
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Blurt the fragment into the buffer.
Repita.

Etapas necessárias para que se blurt um import into um buffer:
Blurt pedaços usando the import's import header's whereabouts e the import's import header's magnitude e the buffer e the import's header address.
Blurt the import's name into the buffer at the import's name address.
Blurt the import's entries into the buffer.

Etapas necessárias para que se blurt some imports into um buffer:
Obtenha um import from the imports.
Se the import for inexistente, cancele.
Blurt the import into the buffer.
Repita.

Etapas necessárias para que se blurt um pe header into um buffer:
Blurt pedaços usando the pe header's whereabouts e the pe header's magnitude e the buffer e 256.

Etapas necessárias para que se blurt uma routine into um buffer:
Se the routine's compiled sinal não estiver verde, cancele.
Blurt the routine's fragments into the buffer.

Etapas necessárias para que se blurt some routines into um buffer:
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Blurt the routine into the buffer.
Repita.

Etapas necessárias para que se blurt um string into um buffer at um address:
Blurt pedaços usando the string's first e the string's length e the buffer e the address.

Etapas necessárias para que se blurt uma variable into um buffer:
Se the variable's compiled sinal não estiver verde, cancele.
Se the variable's type pode ser reduzido para "string", blurt the variable into the buffer (as um string); exit.
Coloque the variable's address minus the image base into um address.
Blurt the variable's data into the buffer at the address.

Etapas necessárias para que se blurt uma variable into um buffer (as um string):
Coloque the variable's address minus the image base into um address.
Coloque the variable's data's length into um length.
Coloque the address into another address.
Adicione um prototype string's magnitude to the other address.
Adicione the image base to the other address.
Coloque 0 into the prototype string's first.
Coloque -1 into the prototype string's last.
Se the length não for 0, coloque the other address into the prototype string's first.
Se the length não for 0, coloque the prototype string's first plus the length minus 1 into the prototype string's last.
Blurt pedaços usando the prototype string's whereabouts e the prototype string's magnitude e the buffer e the address.
Adicione the prototype string's magnitude to the address.
Blurt the variable's data into the buffer at the address.

Etapas necessárias para que se blurt some variables into um buffer:
Obtenha uma variable from the variables.
Se the variable for inexistente, cancele.
Blurt the variable into the buffer.
Repita.

An borough é um conjunto with um base address, um length e um size.

The break tag é uma tag igual a 1.

Etapas necessárias para que se bubble um monikette:
Se the monikette for inexistente, cancele.
Se the monikette's current substring não estiver em branco, limpe o monikette's current substring; exit.
Se the monikette's current type for inexistente, cancele.
Se the monikette's current type é any built-in type, coloque nil into the monikette's current type; exit.
Coloque the monikette's current type's base type into the monikette's current type.

An built-in type é um type.

Etapas necessárias para que se calculate the length of um type:
Se the type for inexistente, cancele.
Se the type's length não for -1, cancele.
Calculate the length of the type's base type.
Se the type's fields estiverem vazio, coloque the type's base type's length into the type's length; exit.
Coloque 0 into the type's length.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name não estiver em branco, repita.
Calculate the length of the field's type.
Adicione the field's type's length times the field's count to the type's length.
Repita.

Etapas necessárias para que se calculate the lengths of some types:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the length of the type.
Repita.

Etapas necessárias para que se calculate the offsets in um type:
Se the type for inexistente, cancele.
Coloque 0 into um offset.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name não estiver em branco, repita.
Coloque the offset into the field's offset.
Adicione the field's type's length times the field's count to the offset.
Repita.

Etapas necessárias para que se calculate the offsets in some types:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the offsets in the type.
Repita.

Etapas necessárias para que se calculate the redefinition offsets in um type:
Se the type for inexistente, cancele.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name estiver em branco, repita.
Encontre another field usando the field's redefinition target name e the type's fields.
Se the other field for inexistente, abort with "Redefine inválido. Eu não consigo encontrar o campo '" then the field's redefinition target name then "' field." e the field's locus; exit.
Coloque the other field's offset into the field's offset.
Repita.

Etapas necessárias para que se calculate the redefinition offsets in some types:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the redefinition offsets in the type.
Repita.

The calculating timer é um timer.

The call external tag é uma tag igual a 2.

The call indirect tag é uma tag igual a 3.

The call internal tag é uma tag igual a 4.

Etapas necessárias para que se check por invalid optional info on um type:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's target name não estiver em branco, check por invalid optional info on the type (target).
Se the type's fields não estiverem vazio, check por invalid optional info on the type (fields).
Se the type's scale não for 0, check por invalid optional info on the type (scale).

Etapas necessárias para que se check por invalid optional info on um type (fields):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type não pode ser reduzido para "conjunto", abort with "A palavra 'with' só é permitida em conjunto types." e the type's locus; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info on um type (scale):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type não pode ser reduzido para "número", abort with "Escalas são permitidas apenas em tipos numéricos." e the type's locus; exit.

Etapas necessárias para que se check por invalid optional info on um type (target):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type não pode ser reduzido para "endereço de memória", abort with "An palavra 'to' só é permitida em endereço de memória types." e the type's locus; exit.

Etapas necessárias para que se limpe um field term:
Fill pedaços with the null pedaço starting at the field term's whereabouts por the field term's magnitude.

Etapas necessárias para que se limpe um term:
Esvazie the term's variable.
Limpe the term's phrase.

The code borough é um borough.

Etapas necessárias para que se compile the bodies of the routines:
Compile the body of the routine called "initialize before run".
Compile the body of the routine called "nosso programa seja executado".
Compile the body of the routine called "finalize after run".

Etapas necessárias para que se compile the body of uma routine:
Se the routine for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the routine's compiled sinal estiver verde, cancele.
Abra the routine's compiled sinal.
Lance um rider on the routine's routine body.
Mova the rider (compiler rules).
Se the rider's token é the semi-colon pedaço, compile the body of the routine usando the rider (alternate wording); exit. \ *** alternate wording
Se the rider's token é any employ, compile the body of the routine usando the rider (employ); exit.
Coloque the current routine into um saved routine.
Coloque the routine into the current routine.
Crie the routine's nickname index usando 101.
Eliminate duplicate nicknames from the routine's parameters usando the routine's nickname index.
Compile the body of the routine (prolog).
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, pare.
Compile the next statement usando the rider.
Repita.
Compile the body of the routine (epilog).
Coloque the saved routine into the current routine.

Etapas necessárias para que se compile the body of uma routine (epilog):
Se the routine for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um fragment usando the finalize tag.
Percorra.
Obtenha uma variable from the routine's locals.
Se the variable for inexistente, pare.
Se the variable's kind for "scratch", repita.
Se the variable's type não deveria ser finalizado, repita.
Adicione another fragment usando the push address tag e the variable.
Encontre another routine usando "~finalize" e the variable's type.
Se the other routine for inexistente, abort with "Erro interno - compile the body of uma routine (epilog)"; exit.
Adicione um third fragment usando the call internal tag e the other routine.
Repita.
Adicione um fourth fragment usando the epilog tag.

Etapas necessárias para que se compile the body of uma routine (prolog):
Se the routine for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um fragment usando the prolog tag.
Adicione another fragment usando the loop tag.

Etapas necessárias para que se compile the body of the routine called um string:
Se the compiler's sinal de alerta estiver presente, cancele.
Encontre uma routine usando the string e the routine index.
Se the routine for inexistente, abort with "Eu preciso de uma função para fazer '" then the string then "'."; exit.
Compile the body of the routine.

Etapas necessárias para que se compile the body of uma routine usando um rider (alternate wording): \ *** alternate wording
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules). \ *** do we need this?
Coloque the routine's next into um target routine.
Se the target routine for inexistente, abort with "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e the rider; exit.
Coloque the target routine's moniker into the routine's employs moniker.
Compile the body of the target routine.

Etapas necessárias para que se compile the body of uma routine usando um rider (employ):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Compile uma routine reference usando the rider.
Convert the routine reference to the routine's employs moniker.
Destroy the routine reference.
Se the rider's token não for ".", abort with "Employ statments devem terminar com um ponto, não com '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Se the rider's token não estiver em branco, abort with "Somente um employ" e the rider; exit.
Encontre another routine usando the routine's employs moniker e the routine index.
Se the other routine for inexistente, abort with "Não consigo encontrar um rotina '" then the routine's employs moniker then "' que você está tentando empregar." e the routine's locus; exit.
Compile the body of the other routine.

Etapas necessárias para que se compile the call'd part usando um rider e uma variable:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the variable for inexistente, cancele.
Coloque the variable's name into the variable's type name.
Mova the rider (compiler rules).
Examine the variable's name usando the rider.

Etapas necessárias para que se compile um directory:
Compile the directory (start).
Compile the directory (load the source files).
Compile the directory (examine the source files).
Compile the directory (resolva the types).
Compile the directory (resolva the globals).
Compile the directory (compile the headers of the routines).
Compile the directory (calculate lengths e offsets of types).
Compile the directory (Adicione the built-in memory routines).
Compile the directory (catalogue the routines por utility use).
Compile the directory (compile the bodies of the routines).
Compile the directory (Adicione e compile the built-in startup routine).
Compile the directory (offset parameters e variables).
Compile the directory (address).
Compile the directory (transmogrify).
Compile the directory (link).
Compile the directory (write the exe).
Compile the directory (stop).

Etapas necessárias para que se compile um directory (Adicione e compile the built-in startup routine):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Adicionando e agrupando um tarefa de inicialização padrão...".
Start the adding built-in startup routine timer.
Adicione e compile the initialize before run e run e finalize after run routine.
Suspenda the adding built-in startup routine timer.

Etapas necessárias para que se compile um directory (Adicione the built-in memory routines):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Adicionando como tarefas predefinidas na memória...".
Start the adding built-in memory routines timer.
Adicione the allocate e deallocate e finalize e destroy routines.
Suspenda the adding built-in memory routines timer.

Etapas necessárias para que se compile um directory (address):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Obtendo endereço dos itens...".
Start the addressing timer.
Coloque 4096 into um address.
Coloque the address into the import borough's base.
Address the imports usando the address.
Coloque the address minus the import borough's base into the import borough's length.
Round the address up to the nearest multiple of 4096.
Coloque the address into the data borough's base.
Address the globals usando the address.
Address the literals usando the address.
Coloque the address minus the data borough's base into the data borough's length.
Round the address up to the nearest multiple of 4096.
Coloque the address into the code borough's base.
Address the routines usando the address.
Coloque the address minus the code borough's base into the code borough's length.
Suspenda the addressing timer.

Etapas necessárias para que se compile um directory (calculate lengths e offsets of types):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Calculando tamanhos e deslocamentos...".
Start the calculating timer.
Calculate the lengths of the types.
Calculate the offsets in the types.
Calculate the redefinition offsets in the types.
Suspenda the calculating timer.

Etapas necessárias para que se compile um directory (compile the bodies of the routines):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Agrupando o conteúdo das tarefas...".
Start the compiling routine bodies timer.
Compile the bodies of the routines.
Suspenda the compiling routine bodies timer.

Etapas necessárias para que se compile um directory (compile the headers of the routines):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Agrupando os nomes das tarefas...".
Start the compiling routine headers timer.
Compile the headers of the routines.
Suspenda the compiling routine headers  timer.

Etapas necessárias para que se compile um directory (catalogue the routines por utility use):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Catalogando tarefas...".
Start the indexing utilities timer.
Catalogue the routines por utility use.
Scrub the utility index.
Catalogue novamente the utility index.
Suspenda the indexing utilities timer.

Etapas necessárias para que se compile um directory (link):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Elencando arquivos..".
Start the linking timer.
Link.
Suspenda the linking timer.

Etapas necessárias para que se compile um directory (offset parameters e variables):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Deslocando parâmetros e variáveis...".
Start the offsetting timer.
Offset the parameters in the routines.
Offset the locals in the routines.
Suspenda the offsetting timer.

Etapas necessárias para que se compile um directory (load the source files):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Carregando arquivos...".
Start the loading timer.
Load the source files.
Suspenda the loading timer.

Etapas necessárias para que se compile um directory (resolva the globals):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Resolvendo itens de escopo abrangente...".
Start the resolving globals timer.
Resolva the globals.
Suspenda the resolving globals timer.

Etapas necessárias para que se compile um directory (resolva the types):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Resolvendo tipos...".
Start the resolving types timer.
Resolva the types (expand coisas).
Resolva the types (registro de plurais).
Resolva the types (base types).
Resolva the types (optional info).
Suspenda the resolving types timer.

Etapas necessárias para que se compile um directory (examine the source files):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Analisando arquivos...".
Start the scanning timer.
Examine the source files.
Suspenda the scanning timer.

Etapas necessárias para que se compile um directory (start):
Mostre status "Iniciando...".
Finalize the compiler.
Start the compiler's timer.
Initialize the compiler usando the directory.
Adicione the built-in types.

Etapas necessárias para que se compile um directory (stop):
Suspenda the compiler's timer.
Mostre status "Interrompendo".

Etapas necessárias para que se compile um directory (transmogrify):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Modificando...".
Start the transmogrifying timer.
Transmogrify the routines.
Suspenda the transmogrifying timer.

Etapas necessárias para que se compile um directory (write the exe):
Se the compiler's sinal de alerta estiver presente, cancele.
Mostre status "Gerando arquivo executável...".
Start the writing timer.
Escreva the compiler's exe to the compiler's exe path.
Se the i/o error não estiver em branco, abort with the i/o error.
Suspenda the writing timer.

Etapas necessárias para que se compile um expression usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Compile um term usando the rider.
Coloque the term into the expression.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token não for any operator, cancele.
Se the rider's token é any divided, compile the expression usando the rider (divided); repeat.
Se the rider's token é any minus, compile the expression usando the rider (minus); repeat.
Se the rider's token é any plus, compile the expression usando the rider (plus); repeat.
Se the rider's token é any then, compile the expression usando the rider (then); repeat.
Se the rider's token é any times, compile the expression usando the rider (times); repeat.

Etapas necessárias para que se compile um expression usando um rider (divided):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Se the rider's token não for any by, abort with "Você deve usar o termo 'divided BY'." e the rider; exit.
Se the expression's variable for inexistente, abort with "Termo 'divided by' inválido, há um erro na variável: '" then the expression's phrase then "'." e the rider; exit.
Mova the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'divided by',está errado. Não dá pra dividir por '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando the expression's type name e the rider's token's first.
Adicione several fragments usando "coloque" e the expression's variable e "into" e the intermediate e the rider's token's first.
Adicione several fragments usando "divida" e the intermediate e "por" e the term's variable e the rider's token's first.
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile um expression usando um rider (minus):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "O seu 'minus', está errado. Não consigo subtrair o(a) '" then the expression's phrase then "'." e the rider; exit.
Mova the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'minus', está errado. Não consigo diminuir do(a) '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando the expression's type name e the rider's token's first.
Adicione several fragments usando "coloque" e the expression's variable e "into" e the intermediate e the rider's token's first.
Adicione several fragments usando "subtraia" e the term's variable e "from" e the intermediate e the rider's token's first.
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile um expression usando um rider (plus):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "O seu 'plus', está errado. Não consigo somar o '" then the expression's phrase then "'." e the rider; exit.
Mova the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'plus',  está errado. Não consigo somar um '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando the expression's type name e the rider's token's first.
Adicione several fragments usando "coloque" e the expression's variable e "into" e the intermediate e the rider's token's first. \aqui muda o coloque
Adicione several fragments usando "adicione" e the term's variable e "to" e the intermediate e the rider's token's first. \ aqui muda o add
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile um expression usando um rider (then):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "O seu 'then', está errado. Eu não entendi o que é o(a) '" then the expression's phrase then "'." e the rider; exit.
Mova the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'then', está errado. Eu não sei o que é o(a) '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando "string" e the rider's token's first.
Adicione the coloque ou convert fragments usando the expression's variable e the intermediate e the rider's token's first.
Convert the term por concatenation usando the rider.
Adicione several fragments usando "posponha" e the term's variable e "to" e the intermediate e the rider's token's first.
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile um expression usando um rider (times):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar o '" then the expression's phrase then "'." e the rider; exit.
Mova the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar um '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando the expression's type name e the rider's token's first.
Adicione several fragments usando "coloque" e the expression's variable e "into" e the intermediate e the rider's token's first.
Adicione several fragments usando "multiplique" e the intermediate e "por" e the term's variable e the rider's token's first.
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile the header of uma routine:
Se the routine for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Lance um rider on the routine's routine header.
Mova the rider (compiler rules).
Se the rider's token é any decide, compile the header of the routine usando the rider (decider); exit.
Se the rider é the start of any reverse-possessive function, compile the header of the routine usando the rider (reverse-possessive function); exit.
Se the rider é the start of any function, compile the header of the routine usando the rider (function); exit.
Se the rider's token for "compativelmente", compile the header of the routine usando the rider (callback); exit.
Compile the header of the routine usando the rider (procedure).

Etapas necessárias para que se compile the header of uma routine usando um rider (callback):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Abra the routine's callback sinal.
Compile the routine's monikettes e the routine's parameters usando the rider.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já tinha escrito um função '" then the routine's moniker then "'." e the routine's locus; exit.
Catalogue the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the header of uma routine usando um rider (decider):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Se the rider's token não for any conditional, abort with "It's 'Decide IF.' Sempre dizemos, 'Decide IF'. Certo?" e the rider; exit.
Mova the rider (compiler rules).
Abra the routine's decider sinal.
Compile the routine's monikettes e the routine's parameters usando the rider.
Se any of the routine's monikettes are negative words, abort with "Não consigo me dar bem com palavras negativas nos decider names." e the rider; exit.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já me contou como'" then the routine's moniker then "'." e the routine's locus; exit.
Catalogue the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the header of uma routine usando um rider (function):
Se the compiler's sinal de alerta estiver presente, cancele.
Abra the routine's function sinal.
Adicione um monikette to the routine's monikettes usando "coloque".
Mova the rider (compiler rules).
Se the rider's token é any indefinite article, abra um sinal.
Se the sinal estiver verde, compile the routine's monikettes e the routine's parameters usando the rider (indefinite article).
Se the sinal não estiver verde, compile the routine's monikettes e the routine's parameters usando the rider (definite article).
Se the rider's token não for any possessive, abort with "Tá faltando um 's por aqui (ou está no lugar errado)." e the rider; exit. \ not translated - no possessives in Spanish
Mova the rider (compiler rules).
Examine um name usando the rider.
Adicione another monikette to the routine's monikettes usando "'s " then the name.
Se the rider's token não for "into", abort with "Eu estava esperando um palavra 'into', mas encontrei um palavra '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to the routine's monikettes usando "into".
Convert the routine's monikettes to um moniker.
Se the moniker estiver in the routine index, abort with "Eu já sei como '" then the moniker then "'." e the routine's locus; exit. \ not translated - no possessives in Spanish
Catalogue the routine usando the routine's monikettes e the routine index.
Mova the rider (compiler rules).
Se the rider's token não for any indefinite article, abort with "Estava esperando um artigo indefinido, mas achei isso aqui: '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Compile the routine's monikettes e the routine's parameters usando the rider (indefinite article).
Se the rider's token não estiver em branco, abort with "Tem comandos extras no fim dessa função." e the rider; exit. \ not translated - no possessives in Spanish
Convert the routine's monikettes to the routine's moniker.
Catalogue the routine usando the routine's monikettes e the routine index. \ por employs

Etapas necessárias para que se compile the header of uma routine usando um rider (procedure):
Se the compiler's sinal de alerta estiver presente, cancele.
Compile the routine's monikettes e the routine's parameters usando the rider.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já escreveu como fazer '" then the routine's moniker then "'." e the routine's locus; exit.
Catalogue the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the headers of some routines:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Compile the header of the routine.
Repita.

Etapas necessárias para que se compile um literal usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione the literal to the literals usando the rider's token's first.
\Se the rider's token é any sinal literal, compile the literal usando the rider (sinal); exit.
Se the rider's token é any hex literal, compile the literal usando the rider (hex); exit.
Se the rider's token é any numeric literal, compile the literal usando the rider (numeric); exit.
Se the rider's token é any endereço de memória literal, compile the literal usando the rider (endereço de memória); exit.
Se the rider's token é any string literal, compile the literal usando the rider (string); exit.
Abort with "Erro interno - compile um term usando um rider (literal)" e the rider.

Etapas necessárias para que se compile um literal usando um rider (sinal):
Se the compiler's sinal de alerta estiver presente, cancele.
Convert the rider's token to um sinal.
Convert the sinal to the literal's data.
Mova the rider (compiler rules).
Coloque "sinal" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um rider (hex):
Se the compiler's sinal de alerta estiver presente, cancele.
Coloque the rider's token into um nibble substring.
Adicione 1 to the nibble substring's first.
Convert the nibble substring to the literal's data.
Mova the rider (compiler rules).
Coloque "texto hexadecimal" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um rider (numeric - integer):
Se the compiler's sinal de alerta estiver presente, cancele.
Convert the rider's token to um número.
Convert the número to the literal's data.
Mova the rider (compiler rules).
Coloque "número" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um rider (numeric - ratio):
Se the compiler's sinal de alerta estiver presente, cancele.
Convert the rider's token to um ratio.
Convert the ratio to the literal's data.
Mova the rider (compiler rules).
Coloque "ratio" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um rider (numeric - with unit of measure):
Se the compiler's sinal de alerta estiver presente, cancele.
Convert the rider's token to um ratio.
Mova the rider (compiler rules).
Examine um name usando the rider.
Encontre um type usando the name e the type index.
Se the type for inexistente, abort with "'" then the name then "' é uma unidade de medida inexistente." e the literal's locus; exit.
Se the type não pode ser reduzido para "número", abort with "'" then the name then "' é uma unidade de medida inválida." e the literal's locus; exit.
Coloque the type's scale into um final ratio.
Se the type's scale for 0, coloque 1/1 into the final ratio.
Multiplique the final ratio por the ratio.
Reduce the final ratio.
Se the final ratio's denominator for 0, abort with "Parece que essa é uma unidade de medida inválida." e the literal's locus.
Coloque the final ratio's numerator dividido por the final ratio's denominator into um número.
Coloque the type's name into the literal's type name.
Convert the número to the literal's data.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um rider (numeric):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider é followed por any unit of measure, compile the literal usando the rider (numeric - with unit of measure); exit.
Se the rider's token é any integer literal, compile the literal usando the rider (numeric - integer); exit.
Se the rider's token é any ratio literal, compile the literal usando the rider (numeric - ratio); exit.
Se the rider's token é any mixed literal, compile the literal usando the rider (numeric - ratio); exit.

Etapas necessárias para que se compile um literal usando um rider (endereço de memória):
Se the compiler's sinal de alerta estiver presente, cancele.
Convert 0 to the literal's data. \ was nil
Mova the rider (compiler rules).
Coloque "endereço de memória" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um rider (string):
Se the compiler's sinal de alerta estiver presente, cancele.
Coloque the rider's token into the literal's data.
Unquote the literal's data.
Mova the rider (compiler rules).
Coloque "string" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile some monikettes e some parameters usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Se the rider's token é any definite article, compile the monikettes e the parameters usando the rider (definite article); repeat.
Se the rider está on any indefinite article, compile the monikettes e the parameters usando the rider (indefinite article); repeat.
Se the rider está on any monikette string, compile the monikettes e the parameters usando the rider (monikette string); repeat.
Abort with "'" then the rider's token then "' não é um nome de função que eu conheça." e the rider.

Etapas necessárias para que se compile some monikettes e some parameters usando um rider (definite article):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Examine um name usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Anteponha "the " to the name.
Adicione um monikette to the monikettes usando the name.

Etapas necessárias para que se compile some monikettes e some parameters usando um rider (indefinite article):
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um parameter to the parameters usando "parameter" e the rider's token's first.
\PAL
Se the rider's token for "outra", coloque "segunda" into the parameter's name.
Se the rider's token for "outro", coloque "segundo" into the parameter's name.
\CAL
Se the rider's token for "another", coloque "other" into the parameter's name.
Mova the rider (compiler rules).
Examine um name usando the rider.
Extend the parameter's name with the name.
Se the rider's token é any called, compile the call'd part usando the rider e the parameter.
Resolva the parameter.
Se the parameter é duplicated in the parameters, abort with "Cara, você repetiu o parâmetro '" then the parameter's name then "'." e the parameter's locus; exit.
Adicione um monikette to the monikettes usando the parameter's type.

Etapas necessárias para que se compile some monikettes e some parameters usando um rider (monikette string):
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um monikette to the monikettes usando the rider's token.
Mova the rider (compiler rules).

Etapas necessárias para que se compile some monikettes usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider está on any monikette string, adicione um monikette to the monikettes usando the rider's token; mova the rider (compiler rules); repeat.
Se the rider's token não for the start of any expression, cancele.
Compile um expression usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione another monikette to the monikettes usando the expression.
Repita.

\Etapas necessárias para que se compile some monikettes usando um rider:
\Se the compiler's sinal de alerta estiver presente, cancele.
\Se the rider's token é any monikette string, adicione um monikette to the monikettes usando the rider's token; mova the rider (compiler rules); repeat.
\Se the rider's token não for the start of any expression, cancele.
\Compile um expression usando the rider.
\Se the compiler's sinal de alerta estiver presente, cancele.
\Adicione another monikette to the monikettes usando the expression.
\Repita.

Etapas necessárias para que se compile the next statement usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token é any conditional, compile the next statement usando the rider (if); exit.
Se the rider's token é any loop, compile the next statement usando the rider (loop); exit.
Se the rider's token é any privatize, compile the next statement usando the rider (privatize); exit.
Se the rider's token não for the start of any statement, abort with "Eu esperava uma declaração aqui, mas encontrei: '" then the rider's token then "'." e the rider; exit.
Compile the next statement usando the rider (other).
Se the rider's token não for the period pedaço, abort with "Acho que tá faltando um pontinho por aqui." e the rider; exit.
Mova the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (break):
Adicione um fragment usando the break tag.
Mova the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (call - external):
Coloque the rider's token into um string.
Unquote the string.
Mova the rider (compiler rules).
Se the rider's token não for any string literal, abort with "Cara, você precisa colocar os nomes entre aspas, mas você colocou '" then the rider's token then "'." e the rider; exit.
Coloque the rider's token into another string.
Unquote the other string.
Mova the rider (compiler rules).
Adicione um entry to the imports usando the string e the other string.
Se the rider's token for "with", compile the next statement usando the rider (call - with clause).
Se the rider's token for "returning", compile the next statement usando the rider returning um term (call - returning part).
Adicione um fragment usando the call external tag e the entry.
Se the term estiver vazio, cancele.
Se the term's variable for inexistente, abort with "Não entendi bem o que é '" then the term's phrase then "'." e the rider; exit.
Adicione another fragment usando the save eax tag e the term's variable.

Etapas necessárias para que se compile the next statement usando um rider (call - indirect):
Compile um expression usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "Eu não sei o que é '" then the expression's phrase then "'." e the rider; exit.
Se the expression's type não pode ser reduzido para "endereço de memória", abort with "Eu preciso de um endereço de memória type nesse CALL statement." e the rider; exit.
Se the rider's token for "with", compile the next statement usando the rider (call - with clause).
Se the rider's token for "returning", compile the next statement usando the rider returning um term (call - returning part).
Adicione um fragment usando the call indirect tag e the expression's variable.
Se the term estiver vazio, cancele.
Se the term's variable for inexistente, abort with "Acho que essa varíavel é inválida: '" then the term's phrase then "'." e the rider; exit.
Adicione another fragment usando the save eax tag e the term's variable.

Etapas necessárias para que se compile the next statement usando um rider (call - internal):
Compile some monikettes usando the rider.
Encontre uma routine usando the monikettes.
Se the routine não for inexistente, adicione push fragments usando the monikettes.
Se the routine não for inexistente, destroy the monikettes; adicione um fragment usando the call internal tag e the routine; exit.
Convert the monikettes to um moniker.
Destroy the monikettes.
\Coloque "Eu ainda não aprendi como"  into a reply.
\Say the reply.
Coloque the moniker into a reply.
\Say the reply.
Abort with "Eu ainda não aprendi como '" then the moniker then "'." e the rider.

Etapas necessárias para que se compile the next statement usando um rider (call - with clause): \ this guy é recursise so parameters obtenha passed right to left
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Compile um expression usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "Eu não entendo um variável: '" then the expression's phrase then "'." e the rider; exit.
Se the expression's type não for value pushable, abort with "'" then the expression's type's name then "' não pode ser processado corretamente." e the rider; exit.
Se the rider's token é any and, compile the next statement usando the rider (call - with clause).
Adicione um fragment usando the push value tag e the expression's variable.

Etapas necessárias para que se compile the next statement usando um rider (call):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Se the rider's token é any string literal, compile the next statement usando the rider (call - external); exit.
Compile the next statement usando the rider (call - indirect).  

Etapas necessárias para que se compile the next statement usando um rider (exit):
Se the current routine's decider sinal estiver verde, abort with "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" e the rider; exit.
Adicione um fragment usando the exit tag.
Mova the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (if):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Compile some monikettes usando the rider.
Remove any negatives from the monikettes returning um sinal.
Encontre uma routine usando the monikettes.
Se the routine não for inexistente, adicione push fragments usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Preciso de um decider que tenha como palavras: '" then the moniker then "'." e the rider; exit.
Se the routine's decider sinal não estiver verde, abort with "Cara eu vou precisar de um decider aqui, blz?" e the rider; exit.
Se the rider's token não for the comma pedaço, abort with "Acho que você esqueceu de uma vírgula, eu achei isso aqui: '" then the rider's token then "'." e the rider; exit.
Adicione um fragment usando the call internal tag e the routine.
Se the sinal estiver verde, adicione another fragment usando the not tag.
Adicione um third fragment usando the jump false tag.
Mova the rider (compiler rules).
Percorra.
Compile the next statement usando the rider (other).
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token é the semi-colon pedaço, mova the rider (compiler rules); repeat.
Se the rider's token não for the period pedaço, abort with "Você precisa usar um ponto ao invés de usar o termo '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Adicione um fourth fragment usando the end if tag.

Etapas necessárias para que se compile the next statement usando um rider (intel):
Mova the rider (compiler rules).
Se the rider's token não for any hex literal, abort with "Eu preciso de um pouco de machine code, mas o que eu achei foi '" then the rider's token then "'." e the rider; exit.
Adicione um fragment usando the intel tag.
Coloque the rider's token into um nibble substring.
Adicione 1 to the nibble substring's first.
Convert the nibble substring to the fragment's code.
Mova the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (loop):
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um fragment usando the loop tag.
Mova the rider (compiler rules).
Se the rider's token não for the period pedaço, abort with "Parece que alguém esqueceu de colocar um ponto por aí." e the rider; exit.
Mova the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (other):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Se the rider's token é any exit, compile the next statement usando the rider (exit); exit.
Se the rider's token é any repeat, compile the next statement usando the rider (repeat); exit.
Se the rider's token é any break, compile the next statement usando the rider (break); exit.
Se the rider's token é any say, compile the next statement usando the rider (say); exit.
Se the rider's token for "intel", compile the next statement usando the rider (intel); exit.
Se the rider's token for "push", compile the next statement usando the rider (push); exit.
Se the rider's token é any call, compile the next statement usando the rider (call); exit.
Se the rider's token é any point, compile the next statement usando the rider (point); exit.
Se the rider's token é any conditional, abort with "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." e the rider; exit.
Se the rider's token é any privatize, abort with "A sentença 'privatizar' não pode ser usada aqui." e the rider; exit.
Se the rider's token é any loop, abort with "Usar um percorra deentro de um SE é uma ótima forma de arranjar problemas." e the rider; exit.
Se the rider's token é any employ, abort with "'Empregue' deve ser o único imperativo em uma rotina." e the rider; exit.
Compile the next statement usando the rider (call - internal).

Etapas necessárias para que se compile the next statement usando um rider (point):
Mova the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Acho que o termo '" then the term's phrase then "' está vazio." e the rider; exit.
Se the term's kind for "literal", abort with "Você usou o tipo errado de variável aqui (literal)." e the rider.
Se the term's type's length não for 4, abort with "Você usou uma variável de comprimento errado (<>4)." e the rider.
Se the rider's token não for "to", abort with "Acho que faltou um 'to', mas você usou '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Se the rider's token não for "routine", abort with "Acho que faltou a palavra 'routine'. Você usou o termo '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Compile uma routine reference usando the rider.
Convert the routine reference to um moniker.
Destroy the routine reference.
Encontre uma routine usando the moniker e the routine index.
Se the routine for inexistente, abort with "Não achei a tarefa '" then the moniker then "' que você falou." e the rider; exit.
Adicione um fragment usando the routine address tag e the routine.
Coloque the term's variable into the fragment's variable.

Etapas necessárias para que se compile the next statement usando um rider (privatize):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Compile um term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Comando 'privatize', Inválido. Eu acho que o termo da variável '" then the term's phrase then "' está vazio." e the rider; exit.
Se the term's kind não for "parameter", abort with "Você só pode privatizar parâmetros." e the rider; exit.
Adicione um local to the current routine's locals usando "local" e the rider's token's first.
Coloque the term's name into the local's name.
Coloque the term's nickname into the local's nickname.
Coloque the term's type name into the local's type name.
Resolva the local.
Anteponha "original " to the term's name.
Se the term's nickname não estiver em branco, Anteponha "original " to the term's nickname.
Adicione several fragments usando "coloque" e the term's variable e "into" e the local e the rider's token's first.
Se the rider's token não for the period pedaço, abort with "Você vive esquecendo dos pontos né?." e the rider; exit.
Mova the rider (compiler rules).

Etapas necessárias para que se compile the next statement usando um rider (push):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Compile um expression usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "Comando 'push' inválido, um expressão '" then the expression's phrase then "' parece estar vazia." e the rider; exit.
Se the expression's type não for value pushable, abort with "Valores do tipo '" then the expression's type's name then "' não podem ser pushed." e the rider; exit.
Adicione um fragment usando the push value tag e the expression's variable.

Etapas necessárias para que se compile the next statement usando um rider (repeat):
Adicione um fragment usando the repeat tag.
Mova the rider (compiler rules).

\Etapas necessárias para que se compile the next statement usando um rider (say):
\Se the current routine's decider sinal não estiver verde, compile the next statement usando the rider (call - internal); exit.
\Mova the rider (compiler rules).
\Compile um expression usando the rider.
\Se the compiler's sinal de alerta estiver presente, cancele.
\Se the expression's variable for inexistente, abort with "No es válido este 'diga', no entiendo la variable '" then the expression's phrase then "'." e the rider; exit.
\Se the expression's type não pode ser reduzido para "sinal", abort with "Necesito un rotundo 'si' o 'no' aquí." e the rider; exit.
\Adicione um fragment usando the load eax tag e the expression's variable.
\Adicione another fragment usando the exit tag.

Etapas necessárias para que se compile the next statement usando um rider (say):
Se the current routine's decider sinal não estiver verde, compile the next statement usando the rider (call - internal); exit.
Mova the rider (compiler rules).
Se the rider's token não for any decider literal, abort with "Você precisa terminar com um yes ou no." e the rider; exit.
Feche um sinal. Se the rider's token é any positive decider literal, abra the sinal.
Mova the rider (compiler rules).
Se the rider's token não for the period pedaço, abort with "Faltou um ponto. Você usou o termo: '" then the rider's token then "'." e the rider; exit.
Adicione um fragment usando the load eax tag e the sinal.
Adicione another fragment usando the exit tag.

Etapas necessárias para que se compile the next statement usando um rider returning um term (call - returning part):
Mova the rider (compiler rules).
Compile the term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Eu não compreendi o termo da variável '" then the term's phrase then "'. Ela parece estar vazia." e the rider; exit.
Se the term's type não for value pushable, abort with "Uma varíavel de 1, 2, ou 4-pedaços é necessária na 'returning' clause." e the rider.

Etapas necessárias para que se compile uma routine reference usando um rider:
Se the rider's token for "to", mova the rider (compiler rules).
Se the rider é the start of any function, compile the routine reference usando the rider (function); exit.
Se the rider's token é any decide, compile the routine reference usando the rider (decide).
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Se the rider's token for ".", cancele.
Se the rider's token é any definite article, compile the routine reference usando the rider (definite article); repeat.
Se the rider's token é any indefinite article, compile the routine reference usando the rider (indefinite article); repeat.
Se the rider está on any monikette string, compile the routine reference usando the rider (monikette string); repeat.
Abort with "'" then the rider's token then "' não é válido em  um employ statement." e the rider.

Etapas necessárias para que se compile uma routine reference usando um rider (decide):
Mova the rider (compiler rules).
Se the rider's token não for any conditional, abort with "Sempre use DECIDE IF, ao invés de apenas DECIDE com '" then the rider's token then "' logo em seguida." e the rider; exit.
Mova the rider (compiler rules).

Etapas necessárias para que se compile uma routine reference usando um rider (definite article):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Examine um name usando the rider.
Anteponha "the " to the name.
Adicione um monikette to the routine reference usando the name.

Etapas necessárias para que se compile uma routine reference usando um rider (function):
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um monikette to the routine reference usando "coloque".
Mova the rider (compiler rules).
Se the rider's token é any indefinite article, abra um sinal.
Se the sinal estiver verde, compile the routine reference usando the rider (indefinite article).
Se the sinal não estiver verde, compile the routine reference usando the rider (definite article).
Se the rider's token não for any possessive, abort with "Eu estava esperando un 's, mas apareceu '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Mova the rider (compiler rules).
Examine um name usando the rider.
Adicione another monikette to the routine reference usando "'s " then the name.
Se the rider's token não for "into", abort with "E estava esperando um palavra 'into', mas encontrei '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to the routine reference usando "into".
Mova the rider (compiler rules).
Se the rider's token não for any indefinite article, abort with "Eu estava esperando um artigo indefinido mas encontrei isso: '" then the rider's token then "'." e the rider; exit. \ not translated - no possessives in Spanish
Compile the routine reference usando the rider (indefinite article).

Etapas necessárias para que se compile uma routine reference usando um rider (indefinite article):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Examine um name usando the rider.
Encontre um type e um nickname usando the name.
Se the type for inexistente, abort with "Employ statement inválido, Eu não sei o que é '" then the name then "'." e the rider; exit.
Adicione um monikette to the routine reference usando the type.

Etapas necessárias para que se compile uma routine reference usando um rider (monikette string):
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um monikette to the routine reference usando the rider's token.
Mova the rider (compiler rules).

Etapas necessárias para que se compile um term usando um rider:
Limpe the term.
Se the compiler's sinal de alerta estiver presente, cancele.
Compile the term usando the rider (common part).
Se the rider está on any simile, cancele. \ added por invisible turtle project ***
\Se the rider's token for "as", compile the term usando the rider (as part).  \preposição
\Se the rider's token for "tão", compile the term usando the rider (as part). \ me parece desnecessário por ser usado apenas em funções.
Se the rider's token for "quão", compile the term usando the rider (as part).
Se the rider's token for "quanto", compile the term usando the rider (as part).
Se the rider's token for "como", compile the term usando the rider (as part).
\Se the rider's token for "que nem", compile the term usando the rider (as part).
Se the rider's token for "/", compile the term usando the rider (runtime ratio).

Etapas necessárias para que se compile um term usando um rider (as part):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Comando 'as'inválido. Eu acho que um variável '" then the term's phrase then "' está vaiza." e the rider; exit.
Mova the rider (compiler rules).
Se the rider's token não for any indefinite article, abort with "Tá faltando um artigo indefinido depois do 'como', mas você escreveu '" then the rider's token then "' no lugar disso." e the rider; exit.
Mova the rider (compiler rules).
Examine um type name usando the rider.
Encontre um type usando the type name e the type index.
Se the type for inexistente, abort with "Eu não sei em qual tipo o '" then the type name then "' se encaixa." e the rider; exit.
Adicione um scratch usando the type's name e the rider's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Coloque the scratch into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider (common part):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token é the dash pedaço, compile the term usando the rider (negated term); exit.
Se the rider's token é the cross pedaço, compile the term usando the rider (posigated term); exit.
Se the rider's token é the start of any variable, compile the term usando the rider (variable); exit.
Se the rider's token é the start of any new local, compile the term usando the rider (new local); exit.
Se the rider's token é any literal, compile the term usando the rider (literal); exit.
Abort with "Faltou um termo por aqui. Só achei isso aqui: '" then the rider's token then "'." e the rider.

Etapas necessárias para que se compile um term usando um rider (dereference - in place):
Se the term's variable for inexistente, abort with "Erro interno na função - compile um term usando um rider (dereference - in place). Termo vazio" e the rider; exit.
Coloque the term's type's target type's name into the term's type name.
Coloque the term's type's target type into the term's type.
Adicione um fragment usando the dereference tag e the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider (dereference):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Dereference inválido, um variável '" then the term's phrase then "' parece estar vazia." e the rider; exit.
Se the term's type's target type for inexistente, abort with "Não consegui identificar o tipo desse target." e the rider; exit.
Se the term's kind for "scratch", compile the term usando the rider (dereference - in place); exit.
Adicione um scratch usando the term's type's target type's name e the rider's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Adicione another fragment usando the dereference tag e the scratch.
Coloque the scratch into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider (literal):
Se the compiler's sinal de alerta estiver presente, cancele.
Compile um literal usando the rider.
Coloque the literal into the term's variable.
Limpe the term's phrase.
Compile the term usando the rider (possessives).

Etapas necessárias para que se compile um term usando um rider (negated term):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Compile another term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the other term's variable for inexistente, abort with "Negate inválido, um variável '" then the other term's phrase then "' parece estar vazia." e the rider; exit.
Adicione um intermediate usando the other term's type name e the rider's token's first.
Adicione several fragments usando "coloque" e the other term's variable e "into" e the intermediate e the other term's locus.
Adicione two fragments usando "negate" e the intermediate e the rider's token's first.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider (new local):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the current routine for inexistente, abort with "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e the rider; exit.
Adicione um local to the current routine's locals usando "local" e the rider's token's first.
\PAL
Se the rider's token for "outra", coloque "segunda" into the local's name.
Se the rider's token for "outro", coloque "segundo" into the local's name.
\CAL
Se the rider's token for "another", coloque "other" into the local's name.
Mova the rider (compiler rules).
Examine um name usando the rider.
Extend the local's name with the name.
Se the rider's token é any called, compile the call'd part usando the rider e the local.
Resolva the local.
Se the local é duplicated in the current routine's parameters, abort with "o parâmetro '" then the local's name then "' já está sendo usado como parâmetro." e the local's locus; exit.
Se the local é duplicated in the current routine's locals, abort with "Já existe uma variável local chamada'" then the local's name then "'. Você tem que dar um nome diferente." e the local's locus; exit.
Eliminate duplicate nicknames usando the local e the current routine's nickname index.
Coloque the local into the term's variable.
Limpe the term's phrase.
Compile the term usando the rider (possessives).

Etapas necessárias para que se compile um term usando um rider (posigated term):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Compile the term usando the rider.
Se the term's variable for inexistente, abort with "Posigate inválido, o termo da variável'" then the term's phrase then "' parece estar vazio." e the rider; exit.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider (possessive - magnitude):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Use da magnitude inválido. An variável '" then the term's phrase then "' parece estar vazia." e the rider; exit.
Adicione um literal to the literals usando the rider's token's first.
Convert the term's type's length to the literal's data.
Coloque "número" into the literal's type name.
Resolva the literal.
Coloque the literal into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider (possessive - target):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Você usou o target de forma errada. O termo da variável '" then the term's phrase then "' parece estar vazio." e the rider; exit.
Se the term's type não pode ser reduzido para "endereço de memória", abort with "Você só pode usar target com tipos endereço de memória." e the rider; exit.
Compile the term usando the rider (dereference).

Etapas necessárias para que se compile um term usando um rider (possessive - whereabouts):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Você usou whereabouts da forma errada, erro no termo da variável '" then the term's phrase then "'." e the rider; exit.
Adicione um intermediate usando "endereço de memória" e the rider's token's first. 
Adicione um fragment usando the load address tag e the term's variable e the intermediate.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider (possessive): \ similar to "compile um term usando um rider (reverse-possessive)
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Examine um name usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the name é any magnitude, compile the term usando the rider (possessive - magnitude); exit.
Se the name é any target, compile the term usando the rider (possessive - target); exit.
Se the name é any whereabouts, compile the term usando the rider (possessive - whereabouts); exit.
Compile the term usando the rider e the name (possessive - field).

Etapas necessárias para que se compile um term usando um rider (possessives):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token não for any possessive, cancele.
Compile the term usando the rider (possessive).
Repita.  

Etapas necessárias para que se compile um term usando um rider (runtime ratio):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável '" then the term's phrase then "'." e the rider; exit.
Mova the rider (compiler rules).
Compile another term usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the other term's variable for inexistente, abort with "Uso inválido da /, termo vazio da variável: '" then the other term's phrase then "'." e the rider; exit.
Adicione um intermediate usando "ratio" e the rider's token's first.
Adicione several fragments usando "coloque" e the term's variable e "e" e the other term's variable e "into" e the intermediate e the rider's token's first.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider (variable):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the current routine for inexistente, abort with "Erro de tarefa vazia, nada pra pull da pilha aqui." e the rider; exit.
Mova the rider (compiler rules).
Examine um name usando the rider.
Se the rider está on any reverse-possessive, compile the term usando the rider e the name (reverse-possessive); exit.
Encontre uma variable usando the name.
Coloque the variable into the term's variable.
Coloque "the " into the term's phrase.
Posponha the name to the term's phrase.
Compile the term usando the rider (possessives).

Etapas necessárias para que se compile um term usando um rider e um field name (reverse-possessive):  \ this é recursive \ dahn version 2
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules). \ past the reverse-possessive starter
\Se the rider's token não for "del", Mova the rider (compiler rules). \ past the reverse-possessive starter \ gerry added "if" part
\Se the rider's token for "del", adicione 1 to the rider's token's first. \ makes "del" look like "de el"
Se the rider's token não for any article, abort with "Esperaba un artículo, pero encontré '" then the rider's token then "'."; exit.
Coloque the rider's token into um article token.
Mova the rider (compiler rules).
Examine um name usando the rider. 
Se the rider está on any reverse-possessive, abra um reverse-possessive sinal.
Se the reverse-possessive sinal estiver verde, compile the term usando the rider e the name (reverse-possessive).
Se the reverse-possessive sinal não estiver verde, compile the term usando the rider e the name e the article (reverse-possessive preSuspenda to unwind).
Compile the term usando the field name e the rider (reverse-possessive).

Etapas necessárias para que se compile um term usando um rider e uma variable name e um article token (reverse-possessive preSuspenda to unwind): \ dahn version 2
Se the article é the start of any variable, compile the term usando the rider e the variable name e the article (reverse-possessive preSuspenda to unwind existing variable); exit.
Compile the term usando the rider e the variable name (reverse-possessive preSuspenda to unwind new local).

Etapas necessárias para que se compile um term usando um rider e uma variable name e um article token (reverse-possessive preSuspenda to unwind existing variable): \ dahn version 2
Encontre uma variable usando the variable name.
Se the variable for inexistente, abort with "No se pudo encontrar una variable con el nombre '" then the variable name then "'.".
Coloque the variable into the term's variable.
Coloque "the " into the term's phrase.
Posponha the variable name to the term's phrase.

Etapas necessárias para que se compile um term usando um rider e uma variable name (reverse-possessive preSuspenda to unwind new local): \ dahn version 2
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um local to the current routine's locals usando "local" e the rider's token's first.
\PAL
Se the rider's token for "outra", coloque "segunda" into the local's name.
Se the rider's token for "outro", coloque "segundo" into the local's name.
\CAL
Se the rider's token for "another", coloque "other" into the local's name.
Extend the local's name with the variable name.
Se the rider's token é any called, compile the call'd part usando the rider e the local.
Resolva the local.
Se the local é duplicated in the current routine's parameters, abort with "'" then the local's name then "' ya está en uso como parámetro." e the local's locus; exit.
Se the local é duplicated in the current routine's locals,abort with "'" then the local's name then "' ya está en uso como una variable local." e the local's locus; exit.
Eliminate duplicate nicknames usando the local e the current routine's nickname index.
Coloque the local into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um field name e um rider (reverse-possessive):  \ similar to "compile um term usando um rider (possessive)" \ dahn
Se the compiler's sinal de alerta estiver presente, cancele.
Se the field name é any magnitude, compile the term usando the rider (possessive - magnitude); exit.
Se the field name é any target, compile the term usando the rider (possessive - target); exit.
Se the field name é any whereabouts, compile the term usando the rider (possessive - whereabouts); exit.
Compile the term usando the rider e the field name (possessive - field).

Etapas necessárias para que se compile um term usando um rider e um field term:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the field term's dereference sinal estiver verde, compile the term usando the rider (dereference).  
Se the field term's function não for inexistente, compile the term usando the rider e the field term (function); exit.
Se the term's kind for "scratch", compile the term usando the rider e the field term (in place); exit.
Coloque the field term's field into um field.
Adicione um scratch usando the field's type's name e the rider's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Se the field's offset não for 0, adicione um third fragment usando the increment tag e the scratch e the field's offset.
Coloque the scratch into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider e um field term (function):
Se the compiler's sinal de alerta estiver presente, cancele.
Coloque the field term's function into uma routine.
Coloque the routine's parameters' last into um parameter.
Se the parameter for inexistente, abort with "Erro interno na função compile um term usando um rider e um field term (function) - parâmetro vazio." e the rider; exit.
Se the parameter's type for inexistente, abort with "Erro interno 2 na função compile um term usando um rider e um field term (function) - tipo do parâmetro inexistente." e the rider; exit.
Adicione um intermediate usando the parameter's type's name e the rider's token's first.
Adicione um fragment usando the push address tag e the intermediate.
Se the field term's push sinal estiver verde, adicione another fragment usando the push address tag e the term's variable.
Adicione um third fragment usando the call internal tag e the routine.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider e um field term (in place):
Se the compiler's sinal de alerta estiver presente, cancele.
Coloque the field term's field into um field.
Coloque the field's type's name into the term's type name.
Coloque the field's type into the term's type.
Se the field's offset não for 0, adicione um third fragment usando the increment tag e the term's variable e the field's offset.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um rider e um name (possessive - field):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the term's variable não for inexistente, coloque the term's type into um type.
Encontre um field term usando the term's phrase e the type e the name.
Se the field term não for vazio, compile the term usando the rider e the field term; exit.
Se the term's variable for inexistente, abort with "Erro: variável vazia '" then the term's phrase then "'." e the rider; exit.
Se the type pode ser reduzido para "endereço de memória", coloque the type's target type into the type.
Se the type for inexistente, abort with "Não existe o campo '" then the name then "' no tipo '" then the term's type's name then "'." e the rider; exit.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, abort with "Não tem nenhum campo '" then the name then "' no tipo '" then the term's type's name then "'." e the rider; exit.
Encontre um deep field term usando "" e the field's type e the name.
Se the deep field term estiver vazio, repita.
Coloque the field into um first field term's field.
Se the term's type pode ser reduzido para "endereço de memória", abra the first field term's dereference sinal.
Compile the term usando the rider e the first field term.
Compile the term usando the rider e the deep field term.

The compiler é um conjunto with
An directory,
An timer,
An abort sinal,
An sinal de alerta, \new line
An mensagem de erro,
An abort path,
An abort row#,
An name count,
An exe buffer,
An listing buffer.

The compiling routine bodies timer é um timer.

The compiling routine headers timer é um timer.

Etapas necessárias para que se convert some monikettes to um moniker:
Convert the monikettes to the moniker usando the monikettes' last.

Etapas necessárias para que se convert some monikettes to um moniker usando um monikette:
Limpe the moniker.
Percorra.
Obtenha um current monikette from the monikettes.
Se the current monikette for inexistente, cancele.
Posponha the current monikette to the moniker.
Se the current monikette é the monikette, cancele.
Repita.

Etapas necessárias para que se convert um nibble substring to um string: employ convert um nibble string to um texto hexadecimal.

Etapas necessárias para que se convert um term por concatenation usando um rider: \ used por right-side THEN operand
Se the term's variable for inexistente, abort with "Erro: variável do termo está vazia '" then the term's phrase then "'." e the rider; exit.
Se the term's type pode ser reduzido para "string", cancele.
Adicione um intermediate usando "string" e the rider's token's first.
Adicione the coloque ou convert fragments usando the term's variable e the intermediate e the rider's token's first.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se copy um field into another field:
Se the field for inexistente, esvazie the other field; exit.
Allocate memory por the other field.
Coloque the field's locus into the other field's locus.
Coloque the field's name into the other field's name.
Coloque the field's nickname into the other field's nickname.
Coloque the field's type name into the other field's type name.
Coloque the field's type into the other field's type.
Coloque the field's count into the other field's count.
Coloque the field's redefinition target name into the other field's redefinition target name.
Coloque the field's reference sinal into the other field's reference sinal.
Coloque the field's offset into the other field's offset.

Etapas necessárias para que se copy some fields into some other fields:
Obtenha um field from the fields.
Se the field for inexistente, cancele.
Copy the field into another field.
Posponha the other field to the other fields.
Repita.

Etapas necessárias para que se copy some fields into some other fields (data fields only):
Se the fields' count for menor do que 4, cancele. \ por english next e prev e spanish next e prev redefinitions
\Se the fields' first for inexistente, cancele.
\Se the fields' first's next for inexistente, cancele.
\Se the fields' first's next's next for inexistente, cancele.
\\Coloque the fields' first's next's next into um field. \ skip next e prev
\Se the fields' first's next's next's next for inexistente, cancele.
\Se the fields' first's next's next's next's next for inexistente, cancele.
\Se the fields' first's next's next's next's next's next for inexistente, cancele.
Coloque the fields' first's next's next's next's next into um field. \ english next e prev e spanish next e prev redefinitions
Percorra.
Se the field for inexistente, cancele.
Copy the field into another field.
Posponha the other field to the other fields.
Obtenha the field from the fields.
Repita.

Etapas necessárias para que se copy um monikette into another monikette:
Se the monikette for inexistente, esvazie the other monikette; exit.
Allocate memory por the other monikette.
Coloque the monikette's string into the other monikette's string.
Coloque the monikette's type into the other monikette's type.
Coloque the monikette's variable into the other monikette's variable.
\ don't copy substring
Coloque the monikette's current type into the other monikette's current type.

Etapas necessárias para que se copy some monikettes into some other monikettes:
Destroy the other monikettes.
Percorra.
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Copy the monikette into another monikette.
Posponha the other monikette to the other monikettes.
Repita.

Etapas necessárias para que se crie um entry:
Allocate memory por the entry.

Etapas necessárias para que se crie um fragment usando uma tag:
Allocate memory por the fragment.
Coloque the tag into the fragment's tag.

Etapas necessárias para que se crie um import:
Allocate memory por the import.

Etapas necessárias para que se crie um monikette:
Allocate memory por the monikette.

Etapas necessárias para que se crie uma routine:
Allocate memory por the routine.

Etapas necessárias para que se crie um source file:
Allocate memory por the source file.

Etapas necessárias para que se crie um type:
Allocate memory por the type.
Coloque 0/1 into the type's scale.
Coloque -1 into the type's length.

Etapas necessárias para que se crie uma variable usando um kind:
Allocate memory por the variable.
Coloque the kind into the variable's kind.
Coloque 1 into the variable's count.

The current header address é um address.

The current name address é um address.

The current routine é uma routine.

The current thunk address é um address.

The data borough é um borough.

Etapas necessárias para que se determine se any of some monikettes are negative words:
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, diga não.
Se the monikette's string é any negative word, diga sim.
Repita.

Etapas necessárias para que se determine se um pedaço é any glom pedaço:
Se the pedaço é any letter, diga sim.
Se the pedaço é any digit, diga sim.
Se the pedaço é the tilde pedaço, diga sim.
Se the pedaço é the at-sign pedaço, diga sim.
Se the pedaço é the número-sign pedaço, diga sim.
Se the pedaço é the percent-sign pedaço, diga sim.
Se the pedaço é the ampersand pedaço, diga sim.
Se the pedaço é the underscore pedaço, diga sim.
Se the pedaço é the single-quote pedaço, diga sim.
Se the pedaço é the dash pedaço, diga sim.
Se the pedaço é the cross pedaço, diga sim.
Se the pedaço é the slash pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any mark:
Se the pedaço é the period pedaço, diga sim.
Se the pedaço é the comma pedaço, diga sim.
Se the pedaço é the semi-colon pedaço, diga sim.
Se the pedaço é the colon pedaço, diga sim.
Se the pedaço é the exclamation  pedaço, diga sim.
Se the pedaço é the question-mark pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any stressed vowel:
Se the pedaço estiver in "áãâéêíóõôúü", diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any symbol:
Se the pedaço é the caret pedaço, diga sim.
Se the pedaço é the bar pedaço, diga sim.
Se the pedaço é the asterisk pedaço, diga sim.
Se the pedaço é the cross pedaço, diga sim.
Se the pedaço é the dash pedaço, diga sim.
Se the pedaço é the slash pedaço, diga sim.
Se the pedaço é the left-alligator pedaço, diga sim.
Se the pedaço é the right-alligator pedaço, diga sim.
Se the pedaço é the left-brace pedaço, diga sim.
Se the pedaço é the right-brace pedaço, diga sim.
Se the pedaço é the equal-sign pedaço, diga sim.
Se the pedaço for 128, diga sim.
Se the pedaço for 130, diga sim.
Se the pedaço é between 132 e 137, diga sim.
Se the pedaço for 139, diga sim.
Se the pedaço é between 145 e 153, diga sim.
Se the pedaço for 155, diga sim.
Se the pedaço é between 161 e 180, diga sim.
Se the pedaço é between 183 e 191, diga sim.
Se the pedaço for 215, diga sim.
Se the pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um field term é vazio:
Se the field term's field não for inexistente, diga não.
Se the field term's function não for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se some fields deveria ser finalizado:
Obtenha um field from the fields.
Se the field for inexistente, diga não.
Se the field's type deveria ser finalizado, diga sim.
Repita.

Etapas necessárias para que se determine se um item looks reamish:
Load the item's path into um buffer.
Se the buffer starts with "ream cal", diga sim.
Diga não.

Etapas necessárias para que se determine se um moniker estiver in um index:
Encontre um refer usando the moniker e the index.
Se the refer for inexistente, diga não.
Se the refer's endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se the monikette for inexistente, diga sim.
Se the monikette's current type não for inexistente, diga não.
Se the monikette's current substring não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um name é any magnitude:
\PAL
Se the name for "magnitude", diga sim.
\CAL
Se the name for "magnitud", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any target:
\PAL
Se the name for "conteúdo", diga sim.
Se the name for "alvo", diga sim.
\CAL
Se the name for "target", diga sim.
Se the name for "objetivo", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any whereabouts:
\PAL
Se the name for "paradeiro", diga sim.
\CAL
Se the name for "whereabouts", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any valid field name:
Se the name é any magnitude, diga não.
Se the name é any target, diga não.
Se the name é any whereabouts, diga não.
Diga sim.

Etapas necessárias para que se determine se um rider é followed por any unit of measure:
Privatize the rider.
Mova the rider (compiler rules).
Se the rider não for on any name starter, diga não.
Examine um name usando the rider.
Encontre um type usando the name e the type index.
Se the type for inexistente, diga não.
Se the name não for "times", diga sim. \ special because times é um infix operator e um unit of measure
Se the rider's token é the start of any expression, diga não.
Diga sim.

Etapas necessárias para que se determine se um rider está on any nested double-quote:
Se the rider's source starts with """""", diga sim.
Diga não.

Etapas necessárias para que se determine se um rider está on any possessive:
Se the rider's source estiver em branco, diga não.
Se the rider's source's first's target não for the single-quote pedaço, diga não.
Se the rider está on any possessive (type 1 - single-quote, s, non-glom-byte), diga sim.
Se the rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sim.
Diga não.

Etapas necessárias para que se determine se um rider está on any possessive (type 1 - single-quote, s, non-glom-byte):
Se the rider's source does not start with "'s", diga não.
Privatize the rider.
Adicione 2 to the rider's source's first.
Se the rider's source estiver em branco, diga sim.
Se the rider's source's first's target não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um rider está on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Privatize the rider.
Se the rider's source's first é the rider's original substring's first, diga não.
Subtraia 1 from the rider's source's first.
Se the rider's source's first's target não for the little-s pedaço ou the big-s pedaço, diga não.
Adicione 2 to the rider's source's first.
Se the rider's source estiver em branco, diga sim.
Se the rider's source's first's target não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um rider está on any simile: \ added for invisible turtle project ***
Privatize the rider.
Se the rider's token for "LIKE", diga sim.
Se the rider's token não for "AS", diga não.
Mova the rider (compiler rules).
Se the rider's token é any indefinite article, diga não.
Diga sim.

Etapas necessárias para que se determine se um rider é the start of any function:
Se the compiler's sinal de alerta estiver presente, diga não.
Se the rider's token for "Ponha", diga sim.
\Se the rider's token não for any coloque, diga não.
Se the rider's token não for "coloque", diga não.
Privatize the rider.
Mova the rider (compiler rules).
Se the rider's token não for any article, diga não.
Mova the rider (compiler rules).
Examine um name usando the rider.
Se the rider's token é any possessive, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any contraction giving another string (portuguese rules - "no"):
Se the string não for "no", diga não.
Se the other string for "say", diga não.
Se the other string for "diga", diga não.
\Se the other string for "dizer", diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant e another string:
Lance um substring on the string.
Subtraia the other string's length from the substring's last.
Se the substring estiver em branco, diga não.
Se the substring's last's target não for any consonant, diga não.
Se the string does not end with the other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel e another string:
Lance um substring on the string.
Subtraia the other string's length from the substring's last.
Se the substring estiver em branco, diga não.
Se the substring's last's target não for any vowel, diga não.
Se the string does not end with the other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant:
Se the string estiver em branco, diga não.
Se the string's last's target não for any consonant, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel:
Se the string estiver em branco, diga não.
Se the string's last's target não for any vowel, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any plus:
\PAL
Se the string for "mais", diga sim.
\CAL
Se the string for "plus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any coloque:
\PAL
Se the string for "pôr", diga sim.
\# Não precisa porque está como sinônimo: ver "Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules)"
\Se the string for "colocar", diga sim. 
\CAL
Se the string for "coloque", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any minus:
\PAL
Se the string for "menos", diga sim.
\CAL
Se the string for "minus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any times:
\PAL
Se the string for "vezes", diga sim.
\CAL
Se the string for "times", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any divided:
\PAL
Se the string for "dividido", diga sim.
\CAL
Se the string for "divided", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any by:
\PAL
Se the string for "via", diga sim.  \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se the string for "por", diga sim.
\CAL
Se the string for "by", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any then:
\PAL
\# operador de concatenação de strings tipo: "abc" then "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida". 
Se the string for "depois", diga sim.
Se the string for "então", diga sim.
\CAL
Se the string for "then", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any has:
\PAL
Se the string for "tem", diga sim.
Se the string for "têm", diga sim.
Se the string for "possui", diga sim.
Se the string for "possuem", diga sim.
\CAL
Se the string for "has", diga sim.
Se the string for "have", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any is:
\PAL
Se the string for "é", diga sim.
Se the string for "está", diga sim.
Se the string for "são", diga sim.
Se the string for "estão", diga sim.
Se the string for "for", diga sim.
Se the string for "forem", diga sim.
Se the string for "estiverem", diga sim.
Se the string for "estarem", diga sim.
\CAL
Se the string for "is", diga sim.
Se the string for "are", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operador de atribuição:
\PAL
Se the string for "igual", diga sim.
\CAL
Se the string for "equal", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any with:
\PAL
Se the string for "com", diga sim.
\CAL
Se the string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any article:
Se the string é any indefinite article, diga sim.
Se the string é any definite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se the string for "e", diga sim.
Se the string for "ou", diga sim.
Se the string for "nem", diga sim.
\CAL
Se the string for "and", diga sim.
Se the string for "both", diga sim.
Se the string for "but", diga sim.
Se the string for "either", diga sim.
Se the string for "neither", diga sim.
Se the string for "nor", diga sim.
Se the string for "or", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any sinal literal:
\Se the string for "yes", diga sim.
\Se the string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any to:
\PAL
Se the string for "a", diga sim. \ this é questionable
\CAL
Se the string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any and:
\PAL
Se the string for "e", diga sim.
\CAL
Se the string for "and", diga sim.
Diga não. \repetido?

Etapas necessárias para que se determine se um string é any reverse-possessive function into:
\PAL
Se the string for "em", diga sim.
\CAL
Se the string for "into", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any sinal literal:
\Se the string for "si", diga sim.
\Se the string for "yes", diga sim.
\Se the string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any decider literal:
\PAL
Se the string for "sim", diga sim.
Se the string for "positivo", diga sim.
Se the string for "positivamente", diga sim.
Se the string for "não", diga sim.
Se the string for "negativo", diga sim.
Se the string for "negativamente", diga sim.
\CAL
Se the string for "yes", diga sim.
\Se the string for "yep", diga sim.
\Se the string for "yea", diga sim.
Se the string for "no", diga sim.
\Se the string for "nay", diga sim.
\Se the string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any positive decider literal:
\PAL
Se the string for "sim", diga sim.
Se the string for "positivo", diga sim.
Se the string for "positivamente", diga sim.
\CAL
Se the string for "yes", diga sim.
\Se the string for "yep", diga sim.
\Se the string for "yea", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any negative decider literal:
\PAL
Se the string for "não", diga sim.
Se the string for "negativo", diga sim.
Se the string for "negativamente", diga sim.
\CAL
Se the string for "no", diga sim.
\Se the string for "nay", diga sim.
\Se the string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any hex literal:
Se the string estiver em branco, diga não.
Se the string's first's target é the dollar-sign pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any definite article:
\PAL
Se the string for "o", diga sim.
Se the string for "a", diga sim.
Se the string for "os", diga sim.
Se the string for "as", diga sim.
\CAL
Se the string for "the", diga sim.
Diga não.

Etapas necessárias para que se determine se um rider está on any definite article:
Se the rider está on any portuguese to, diga não.
Se the rider's token não for any definite article, diga não.
Diga sim.

Etapas necessárias para que se determine se um rider está on any indefinite article:
Se the rider está on any portuguese to, diga não.
Se the rider's token não for any indefinite article, diga não.
Diga sim.

Etapas necessárias para que se determine se um rider está on any portuguese to:
Se the rider's token não for "a", diga não.
Privatize the rider. Mova the rider (compiler rules).
Se the rider's token é any article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any indefinite article:
\PAL
Se the string é any portuguese indefinite article, diga sim.
\CAL
Se the string é any english indefinite article, diga sim.
\Se the string for "a", diga sim.
Se the string for "an", diga sim.
Se the string for "another", diga sim.
Se the string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any portuguese indefinite article:
\PAL
Se the string for "um", diga sim.
Se the string for "uma", diga sim.
Se the string for "outro", diga sim.
Se the string for "outra", diga sim.
Se the string for "algum", diga sim.
Se the string for "alguma", diga sim.
Se the string for "alguns", diga sim.
Se the string for "algumas", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any english indefinite article:
\CAL
Se the string for "an", diga sim.
Se the string for "another", diga sim.
Se the string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any literal:
Se the string é any endereço de memória literal, diga sim.
Se the string é any numeric literal, diga sim.
Se the string é any string literal, diga sim.
\Se the string é any sinal literal, diga sim. ***
Se the string é any hex literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any mark:
Se the string's length não for 1, diga não.
Se the string's first's target é any mark, diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any monikette string:
\Se the string estiver em branco, diga não.
\Se the string for "the", diga não.
\Se the string é any indefinite article, diga não.
\Se the string é any possessive, diga não.
\Se the string é any literal, diga não.
\Se the string é any mark, diga não.
\Se the string é any symbol, diga não.
\Diga sim.

Etapas necessárias para que se determine se um rider está on any monikette string:
Se the rider's token estiver em branco, diga não.
Se the rider está on any definite article, diga não.
Se the rider está on any indefinite article, diga não.
Se the rider's token é any possessive, diga não.
Se the rider's token é any literal, diga não.
Se the rider's token é any mark, diga não.
Se the rider's token é any symbol, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any called:
\PAL
Se the string for "chamado", diga sim.
Se the string for "chamada", diga sim.
\CAL
Se the string for "called", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name ender: \ compare with name starter
Se the string é any mark, diga sim.
Se the string é any symbol, diga sim.
Se the string é any article, diga sim.
Se the string é any conjunction, diga sim.
Se the string é any possessive, diga sim.
Se the string é any verb, diga sim.
Se the string é any operator, diga sim.
Se the string é any preposition, diga sim.
Se the string é any qualifier, diga sim.
Se the string é any literal, diga sim.
Se the string for "called", diga sim.
Se the string for "equal", diga sim.
Se the string estiver em branco, diga sim.
Diga não.
Etapas necessárias para que se determine se um string é any reference:
\PAL
Se the string for "(referência)", diga sim.
\CAL
Se the string for "(reference)", diga sim.
Diga não.

Etapas necessárias para que se determine se um rider está on any name ender: \ compare with name starter
Se the rider's token é any mark, diga sim.
Se the rider's token é any symbol, diga sim.
Se the rider's token é any article, diga sim.
Se the rider's token é any conjunction, diga sim.
Se the rider's token é any possessive, diga sim.
Se the rider está on any reverse-possessive, diga sim.
Se the rider's token é any verb, diga sim.
Se the rider's token é any operator, diga sim.
Se the rider está on any preposition, diga sim.
Se the rider's token é any qualifier, diga sim.
Se the rider's token é any literal, diga sim.
Se the rider's token é any called, diga sim.
Se the rider's token for any operador de atribuição, diga sim.
Se the rider's token estiver em branco, diga sim.
\ Portuguese trouble makers
Se the rider's token é any negative word, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name starter: \ compare with name ender
Se the string é any mark, diga não.
Se the string é any symbol, diga não.
Se the string é any article, diga não.
Se the string é any conjunction, diga sim.
Se the string é any possessive, diga não.
Se the string é any verb, diga sim.
Se the string é any operator, diga sim.
Se the string é any preposition, diga sim.
Se the string é any qualifier, diga não.
Se the string é any literal, diga não.
Se the string for "called", diga sim.
Se the string for "equal", diga sim.
Se the string estiver em branco, diga não.
Diga sim.
Etapas necessárias para que se determine se um rider está on any name starter: \ compare with name ender
Se the rider's token é any mark, diga não.
Se the rider's token é any symbol, diga não.
Se the rider's token é any article, diga não.
Se the rider's token é any conjunction, diga sim.
Se the rider's token é any possessive, diga não.
Se the rider's token é any verb, diga sim.
Se the rider's token é any operator, diga sim.
Se the rider está on any preposition, diga sim.
Se the rider's token é any qualifier, diga não.
Se the rider's token é any literal, diga não.
Se the rider's token é any called, diga sim.
Se the rider's token for any operador de atribuição, diga sim.
Se the rider's token estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any negative word:
\SAL
Se the string for "não", diga sim.
Se the string for "nada", diga sim.
\CAL
\Se the string for "no", diga sim.
Se the string for "not", diga sim.
Se the string for "cannot", diga sim.
Se the string for "nothing", diga sim.
Se the string ends with "n't", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operator:
\PAL
Se the string for "mais", diga sim.
Se the string for "menos", diga sim.
Se the string for "vezes", diga sim.
Se the string for "dividido", diga sim.
Se the string for "depois", diga sim.
Se the string for "então", diga sim.
\CAL
Se the string for "plus", diga sim.
Se the string for "minus", diga sim.
Se the string for "times", diga sim.
Se the string for "divided", diga sim.
Se the string for "then", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any english indefinite article:
\Se the string for "a", diga sim.
\Se the string for "an", diga sim.
\Se the string for "another", diga sim.
\Se the string for "some", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any pause:
\PAL
Se the string for "e", diga sim.
Se the string for "ou", diga sim.
\CAL
Se the string for "and", diga sim.
Se the string for "or", diga sim.
\default
Se the string for ",", diga sim.
Se the string for ";", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any endereço de memória literal:
\PAL
Se the string for "nulo", diga sim.
Se the string for "nula", diga sim.
Se the string for "inexistente", diga sim.
\CAL
Se the string for "nil", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any possessive:
Se the string for "'s", diga sim.
Se the string for "'", diga sim.
Diga não.

Etapas necessárias para que se determine se um rider está on any preposition:
Coloque the rider's token into um substring.
\PAL
Se the rider está on any portuguese to, diga sim. \ "a" followed por um article for "to" in portuguese
Se the substring for "abaixo", diga sim. \ down
Se the substring for "acima", diga sim. \ up
Se the substring for "ante", diga sim. \ before
Se the substring for "antes", diga sim. \ before
Se the substring for "perante", diga sim. \ before
Se the substring for "debaixo", diga sim. \ below
Se the substring for "sob", diga sim. \ below
Se the substring for "acerca", diga sim. \ near
Se the substring for "próximo", diga sim. \ near
Se the substring for "perto", diga sim. \ near
Se the substring for "com", diga sim. \ with
Se the substring for "como", diga sim. \ as
Se the substring for "contra", diga sim. \ against
\ Se the substring for "de", diga sim. \ reverse-possessive indicator 
Se the substring for "dada", diga sim. \ given
Se the substring for "dado", diga sim. \ given
Se the substring for "dando", diga sim. \ given
Se the substring for "gerando", diga sim. \ giving
Se the substring for "resultando", diga sim. \ giving
Se the substring for "retornando", diga sim. \ giving
Se the substring for "direita", diga sim. \ right
Se the substring for "desde", diga sim. \ since
Se the substring for "depois", diga sim. \ after
Se the substring for "durante", diga sim. \ during
Se the substring for "em", diga sim. \ in
Se the substring for "entre", diga sim. \ between
Se the substring for "até", diga sim. \ until
Se the substring for "esquerda", diga sim. \ left
Se the substring for "mediante", diga sim. \ through
Se the substring for "para", diga sim. \ to
Se the substring for "via", diga sim. \ by
Se the substring for "segundo", diga sim. \ according
Se the substring for "sem", diga sim. \ without
Se the substring for "então", diga sim.
Se the substring for "sobre", diga sim. \ on
Se the substring for "após", diga sim. \ after
Se the substring for "depois", diga sim. \ after
Se the substring for "usando", diga sim. \ using
Se the substring for "versus", diga sim. \ versus
Se the substring for "via", diga sim. \ by
Se the substring for "enquanto", diga sim. \ while
Se the substring for "redefinindo", diga sim. \# 'at' na redefinição de campos  
\CAL
Se the substring for "about", diga sim.
Se the substring for "above", diga sim.
Se the substring for "across", diga sim.
Se the substring for "after", diga sim.
Se the substring for "against", diga sim.
Se the substring for "all", diga sim.
Se the substring for "alone", diga sim.
Se the substring for "along", diga sim.
Se the substring for "among", diga sim.
Se the substring for "any", diga sim.
Se the substring for "anywhere", diga sim.
Se the substring for "around", diga sim.
\Se the substring for "as", diga sim.
Se the substring for "at", diga sim.
Se the substring for "away", diga sim.
Se the substring for "back", diga sim.
Se the substring for "backward", diga sim.
Se the substring for "backwards", diga sim.
Se the substring for "before", diga sim.
Se the substring for "beginning", diga sim.
Se the substring for "behind", diga sim.
Se the substring for "below", diga sim.
Se the substring for "beneath", diga sim.
Se the substring for "beside", diga sim.
Se the substring for "between", diga sim.
Se the substring for "beyond", diga sim.
Se the substring for "bigger", diga sim.
Se the substring for "by", diga sim.
Se the substring for "close", diga sim.
Se the substring for "deep", diga sim.
Se the substring for "diagonally", diga sim.
Se the substring for "down", diga sim.
Se the substring for "downward", diga sim.
Se the substring for "ending", diga sim.
Se the substring for "everywhere", diga sim.
Se the substring for "except", diga sim.
Se the substring for "finishing", diga sim.
Se the substring for "facing", diga sim.
\Se the substring for "for", diga sim.
Se the substring for "por", diga sim.
Se the substring for "forward", diga sim.
Se the substring for "from", diga sim.
Se the substring for "given", diga sim.
Se the substring for "giving", diga sim.
Se the substring for "high", diga sim.
Se the substring for "in", diga sim.
Se the substring for "inside", diga sim.
Se the substring for "into", diga sim.
Se the substring for "en", diga sim.
Se the substring for "larger", diga sim.
Se the substring for "leaning", diga sim.
Se the substring for "left", diga sim.
Se the substring for "leftward", diga sim.
Se the substring for "leftways", diga sim.
Se the substring for "like", diga sim.
Se the substring for "limiting", diga sim.
Se the substring for "long", diga sim.
Se the substring for "near", diga sim.
Se the substring for "of", diga sim.
Se the substring for "off", diga sim.
Se the substring for "on", diga sim.
Se the substring for "only", diga sim.
Se the substring for "onto", diga sim.
Se the substring for "out", diga sim.
Se the substring for "outside", diga sim.
Se the substring for "over", diga sim.
Se the substring for "past", diga sim.
Se the substring for "pointing", diga sim.
Se the substring for "returning", diga sim.
Se the substring for "right", diga sim.
Se the substring for "rightward", diga sim.
Se the substring for "rightways", diga sim.
Se the substring for "shorter", diga sim.
Se the substring for "sideway", diga sim.
Se the substring for "sideways", diga sim.
Se the substring for "similar", diga sim.
Se the substring for "smaller", diga sim.
Se the substring for "somewhere", diga sim.
Se the substring for "slantwise", diga sim.
Se the substring for "slantway", diga sim.
Se the substring for "slantways", diga sim.
Se the substring for "starting", diga sim.
Se the substring for "tall", diga sim.
Se the substring for "taller", diga sim.
Se the substring for "thru", diga sim.
Se the substring for "through", diga sim.
Se the substring for "throughout", diga sim.
Se the substring for "to", diga sim.
Se the substring for "toward", diga sim.
Se the substring for "towards", diga sim.
Se the substring for "under", diga sim.
Se the substring for "underneath", diga sim.
Se the substring for "until", diga sim.
Se the substring for "unto", diga sim.
Se the substring for "up", diga sim.
Se the substring for "upward", diga sim.
Se the substring for "upon", diga sim.
Se the substring for "using", diga sim.
Se the substring for "via", diga sim.
Se the substring for "while", diga sim.
Se the substring for "wide", diga sim.
Se the substring for "with", diga sim.
Se the substring for "within", diga sim.
Se the substring for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any preposition:
Se the string for "about", diga sim.
Se the string for "above", diga sim.
Se the string for "across", diga sim.
Se the string for "after", diga sim.
Se the string for "against", diga sim.
Se the string for "all", diga sim.
Se the string for "alone", diga sim.
Se the string for "along", diga sim.
Se the string for "among", diga sim.
Se the string for "any", diga sim.
Se the string for "anywhere", diga sim.
Se the string for "around", diga sim.
\Se the string for "as", diga sim.
Se the string for "at", diga sim.
Se the string for "away", diga sim.
Se the string for "back", diga sim.
Se the string for "backward", diga sim.
Se the string for "backwards", diga sim.
Se the string for "before", diga sim.
Se the string for "beginning", diga sim.
Se the string for "behind", diga sim.
Se the string for "below", diga sim.
Se the string for "beneath", diga sim.
Se the string for "beside", diga sim.
Se the string for "between", diga sim.
Se the string for "beyond", diga sim.
Se the string for "bigger", diga sim.
Se the string for "by", diga sim.
Se the string for "close", diga sim.
Se the string for "deep", diga sim.
Se the string for "diagonally", diga sim.
Se the string for "down", diga sim.
Se the string for "downward", diga sim.
Se the string for "ending", diga sim.
Se the string for "everywhere", diga sim.
Se the string for "except", diga sim.
Se the string for "finishing", diga sim.
Se the string for "facing", diga sim.
\Se the string for "for", diga sim.
Se the string for "por", diga sim.
Se the string for "forward", diga sim.
Se the string for "from", diga sim.
Se the string for "given", diga sim.
Se the string for "giving", diga sim.
Se the string for "high", diga sim.
Se the string for "in", diga sim.
Se the string for "inside", diga sim.
Se the string for "into", diga sim.
Se the string for "larger", diga sim.
Se the string for "leaning", diga sim.
Se the string for "left", diga sim.
Se the string for "leftward", diga sim.
Se the string for "leftways", diga sim.
Se the string for "like", diga sim.
Se the string for "limiting", diga sim.
Se the string for "long", diga sim.
Se the string for "near", diga sim.
Se the string for "of", diga sim.
Se the string for "off", diga sim.
Se the string for "on", diga sim.
Se the string for "only", diga sim.
Se the string for "onto", diga sim.
Se the string for "out", diga sim.
Se the string for "outside", diga sim.
Se the string for "over", diga sim.
Se the string for "past", diga sim.
Se the string for "pointing", diga sim.
Se the string for "returning", diga sim.
Se the string for "right", diga sim.
Se the string for "rightward", diga sim.
Se the string for "rightways", diga sim.
Se the string for "shorter", diga sim.
Se the string for "sideway", diga sim.
Se the string for "sideways", diga sim.
Se the string for "similar", diga sim.
Se the string for "smaller", diga sim.
Se the string for "somewhere", diga sim.
Se the string for "slantwise", diga sim.
Se the string for "slantway", diga sim.
Se the string for "slantways", diga sim.
Se the string for "starting", diga sim.
Se the string for "tall", diga sim.
Se the string for "taller", diga sim.
Se the string for "thru", diga sim.
Se the string for "through", diga sim.
Se the string for "throughout", diga sim.
Se the string for "to", diga sim.
Se the string for "toward", diga sim.
Se the string for "towards", diga sim.
Se the string for "under", diga sim.
Se the string for "underneath", diga sim.
Se the string for "until", diga sim.
Se the string for "unto", diga sim.
Se the string for "up", diga sim.
Se the string for "upward", diga sim.
Se the string for "upon", diga sim.
Se the string for "using", diga sim.
Se the string for "via", diga sim.
Se the string for "while", diga sim.
Se the string for "wide", diga sim.
Se the string for "with", diga sim.
Se the string for "within", diga sim.
Se the string for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any qualifier:
Se the string estiver em branco, diga não.
Se the string's first's target é the left-paren pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any reverse-possessive:
\Se the string for "uv", diga sim.
Se the string for "de", diga sim.
\Se the string for "pertencente", diga sim.
\Se the string for "que pertence", diga sim.
\Se the string for "del", diga sim. \ short por "de el", expanded in "compile um term usando um rider e um field name (reverse-possessive)"
Diga não.

Etapas necessárias para que se determine se um rider está on any reverse-possessive:
Privatize the rider.
\CAL
\Se the rider's token for "uv", diga sim.
\PAL
\Se the string for "pertencente a", diga sim.
\Se the string for "pertencente ao", diga sim.
\Se the string for "que pertence a", diga sim.
\Se the string for "que pertence ao", diga sim.
\que consta
\que figura
\incorporada
\inerente
Se the rider's token não for "integrada de", diga não.
Se the rider's token não for "interna de", diga não.
Se the rider's token não for "interno de", diga não.
Se the rider's token não for "do registro de", diga não.
Se the rider's token não for "que está dentro de", diga não.
Se the rider's token não for "de dentro do registro de", diga não.
Se the rider's token não for "de dentro de", diga não.
Se the rider's token não for "que faz parte de", diga não.
Mova the rider (compiler rules).
Se the rider's token é any article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any string literal:
Se the string estiver em branco, diga não.
Se the string's first's target é the double-quote pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any symbol:
Se the string's length não for 1, diga não.
Se the string's first's target é any symbol, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any verb:
\PAL
Se the string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se the string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se the string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se the string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
Se the string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" to non-tempora state
Se the string for "ser", diga sim. \ "be"
Se the string for "for", diga sim. \ "be"
Se the string for "forem", diga sim. \ "be"
Se the string for "estiver", diga sim. \ "be"
Se the string for "estiverem", diga sim. \ "be"
Se the string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated in the singular third person (3ps) present, perm.
Se the string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated in the singular third person (3ps) present, temp.
Se the string for "são", diga sim. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, perm.
Se the string for "estão", diga sim. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, temp.
Se the string for "foi", diga sim. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
Se the string for "estava", diga sim. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
Se the string for "foram", diga sim. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
Se the string for "estavam", diga sim. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
Se the string for "será", diga sim. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
Se the string for "estará", diga sim. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
Se the string for "serão", diga sim. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
Se the string for "estarão", diga sim. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
Se the string for "supera", diga sim. \ beats, exceeds
Se the string for "superam", diga sim. \ beats, exceeds
Se the string for "excede", diga sim. \ beats, exceeds
Se the string for "excedem", diga sim. \ beats, exceeds
Se the string for "pode", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se the string for "puder", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se the string for "puderem", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se the string for "podem", diga sim. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
Se the string for "poderia", diga sim. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
Se the string for "poderia", diga sim. \ they "could" could not \ couldn't:  not used in CAL (3pp) added just in case
Se the string for "podemos", diga sim. \ we "could" could not \ couldn't: only once in Noodle (1pp) "Etapas necessárias para que se determine se we could encontre um endereço de memória:"
Se the string for "tem", diga sim. \ it "has" used in type definitions; (3ps) present
Se the string for "têm", diga sim. \ they "have" used in type definitions; (3pp) present
Se the string for "ter", diga sim. \ used in type definitions
Se the string for "possui", diga sim. \ it "has" used in type definitions; (3ps) present
Se the string for "possuem", diga sim. \ they "have" used in type definitions; (3pp) present
Se the string for "possuir", diga sim. \ used in type definitions
\\ trouble makers
Se the string for "inicia", diga sim. \ "begins" does not begin \ doesn't begin
Se the string for "começa", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se the string for "começar", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se the string for "termina", diga sim. \ "ends" does not end \ doesn't end
Se the string for "terminar", diga sim. \ "ends" does not end \ doesn't end
Se the string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
Se the string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
Se the string for "parece", diga sim. \ "looks" does not look \ doesn't look
Se the string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
Se the string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
Se the string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
\CAL
Se the string for "are", diga sim. \ are not \ aren't
Se the string for "be", diga sim. \
Se the string for "can", diga sim. \ cannot \ can't
Se the string for "cannot", diga sim. 
\Se the string for "could", diga sim. \ could not \ couldn't
\Se the string for "do", diga sim. \ does not \ don't
Se the string for "does", diga sim. \ does not \ doesn't
Se the string for "is", diga sim. \ não for \ isn't
Se the string for "may", diga sim. \ may not \ mayn't
Se the string for "should", diga sim. \ não deveria \ shouldn't
Se the string for "was", diga sim. \ was not \ wasn't
Se the string for "will", diga sim. \ will not \ won't
Se the string for "would", diga sim. \ would not \ wouldn't
Se the string for "has", diga sim. \ used in type definitions
Se the string for "have", diga sim. \ used in type definitions
Se the string ends with "n't", diga sim.
\\ trouble makers
Se the string for "begins", diga sim. \ does not begin \ doesn't begin
Se the string for "ends", diga sim. \ does not end \ doesn't end
Se the string for "looks", diga sim. \ does not look \ doesn't look
Se the string for "needs", diga sim. \ does not need \ doesn't need
Se the string for "starts", diga sim. \ does not start \ doesn't start
Diga não.

Etapas necessárias para que se determine se um string é the start of any definition:
\PAL
Se the string for "Passos", diga sim.
Se the string for "Etapas", diga sim.
\CAL
Se the string for "to", diga sim.
\default
Se the string é any indefinite article, diga sim.
Se the string é any definite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conditional:
\PAL
Se the string for "se", diga sim.
Se the string for "quando", diga sim.
\CAL
Se the string for "if", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any privatize:
\PAL
Se the string for "privatize", diga sim.
Se the string for "reserve", diga sim.
Se the string for "proteja", diga sim.
Se the string for "derive", diga sim.
\CAL
\Se the string for "privatize", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any loop:
\PAL
Se the string for "percorra", diga sim.
\Se the string for "ciclo", diga sim.
\Se the string for "laço", diga sim. \# muito usado em pseudo-codigo
\CAL
Se the string for "loop", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any break:
\PAL
Se the string for "pare", diga sim.
Se the string for "Suspenda de percorrer", diga sim.
Se the string for "Suspenda de repetir", diga sim.
Se the string for "cancele a operação", diga sim.
Se the string for "interrompa a operação", diga sim.
\CAL
Se the string for "break", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any exit:
\PAL
Se the string for "acabe", diga sim.
Se the string for "acabou", diga sim.
Se the string for "acabou-se", diga sim.
\Se the string for "advirta", diga sim.
\Se the string for "anuncie", diga sim.
\Se the string for "avise", diga sim.
Se the string for "cancele", diga sim.
Se the string for "desconsidere.", diga sim.
Se the string for "deixa quieto", diga sim.
Se the string for "deixe quieto", diga sim.
Se the string for "e mais nada", diga sim.
Se the string for "e pronto", diga sim.
Se the string for "e só", diga sim.
Se the string for "fim", diga sim.
Se the string for "fimse", diga sim.
Se the string for "ignore", diga sim.
\Se the string for "informe", diga sim.
Se the string for "prossiga", diga sim.
Se the string for "pronto", diga sim.
Se the string for "retorne", diga sim.
Se the string for "saia", diga sim.
Se the string for "siga adiante", diga sim.
Se the string for "terminamos", diga sim.
Se the string for "termine", diga sim.
\CAL
Se the string for "exit", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any repeat:
\PAL
Se the string for "repetir", diga sim. \# muito usado em pseudo-codigo
Se the string for "repita", diga sim. \# muito usado em pseudo-codigo
\CAL
Se the string for "repeat", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any say:
\PAL
Se the string for "diga", diga sim. \# modo imperativo
Se the string for "responda", diga sim. \# modo imperativo
Se the string for "informe", diga sim. \# modo imperativo
Se the string for "dizer", diga sim. \# modo infinitivo opcional.
\CAL
Se the string for "say", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any decide:
\PAL
\Se the string for "decidir", diga sim.
Se the string for "decida", diga sim.
\Se the string for "escolha", diga sim.
Se the string for "defina", diga sim.
Se the string for "determine", diga sim.
Se the string for "conclua", diga sim.
Se the string for "esclareça", diga sim.
Se the string for "esclareça", diga sim.
Se the string for "descubra", diga sim.
Se the string for "analise", diga sim.
\CAL
Se the string for "decide", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any call:
\PAL
Se the string for "chamar", diga sim.
\CAL
Se the string for "call", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any point:
\PAL
Se the string for "apontar", diga sim.
\CAL
Se the string for "point", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any employ:
\PAL
Se the string for "empregar", diga sim.
\CAL
Se the string for "employ", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any expression:
Se the string é any sign, diga sim.
Se the string é any indefinite article, diga sim.
Se the string é any definite article, diga sim.
Se the string é any literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any global:
Se the string é any definite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any new local:
Se the string é any indefinite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any optional info:
\PAL
Se the string for "com", diga sim.
\CAL
Se the string for "to", diga sim.
Se the string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any routine:
\PAL
Se the string for "Passos", diga sim.
Se the string for "Etapas", diga sim.
Se the string for "Etapas Etapas necessárias para que se", diga sim.
Se the string for "Passos Etapas necessárias para que se", diga sim.
\CAL
Se the string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any statement:
Se the string é the start of any definition, diga não.
Se the string é any literal, diga não.
Se the string é any mark, diga não.
Se the string estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é the start of any type:
Se the string é any indefinite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any variable:
Se the string é any definite article, diga sim.
\Se the string for "do", diga sim. \ this é iffy, here por reverse-possessives
Diga não.

Etapas necessárias para que se determine se um string has any stressed vowel:
Privatize the string.
Percorra.
Se the string estiver em branco, diga não.
Se the string's last's target é any stressed vowel, diga sim.
Subtraia 1 from the string's last.
Repita.

Etapas necessárias para que se determine se um term é vazio:
Se the term's variable não for inexistente, diga não.
Se the term's phrase não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um type pode ser reduzido para um string using the base name:
Se the type for inexistente, diga não.
Se the type's name é the string, diga sim.
Se the type's cooking sinal estiver verde, diga não.
Abra the type's cooking sinal.
Encontre um base type usando the type's base name e the type index.
Se the base type for inexistente, feche the type's cooking sinal; Diga não.
Se the base type pode ser reduzido para the string using the base name, feche the type's cooking sinal; say yes.
Feche the type's cooking sinal.
Diga não.

Etapas necessárias para que se determine se um type pode ser reduzido para um type name:
Se the type for inexistente, diga não.
Privatize the type.
Percorra.
Se the type for inexistente, diga não.
Se the type's name é the type name, diga sim.
Se the type's base type é the type, diga não.
Coloque the type's base type into the type.
Repita.

Etapas necessárias para que se determine se um type é any built-in type:
Se the type for inexistente, diga não.
Se the type é the type's base type, diga sim.
Diga não.

Etapas necessárias para que se determine se um type é value pushable:
Se the type for inexistente, diga não.
Se the type for inexistente, diga não.
Se the type's length for 4, diga sim.
Se the type's length for 2, diga sim.
Se the type's length for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser finalizado:
Se the type for inexistente, diga não.
Se the type pode ser reduzido para "substring", diga não.
Se the type pode ser reduzido para "string", diga sim.
Se the type's fields deveria ser finalizado, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser ignorado:
Se the type for inexistente, diga não.
\PAL
\Se the type's name for "elemento", diga não.
\Se the type's name for "elementos", diga não.
\CAL
Se the type's name for "coisa", diga não.
Se the type's name for "coisas", diga não.
Se the type pode ser reduzido para "coisas", diga sim.
Se the type não pode ser reduzido para "endereço de memória", diga não.
Se the type's target type for inexistente, diga não.
Se the type's target type não pode ser reduzido para "endereço de memória", diga sim.
Se the type's target type não deveria ser ignorado, diga não.
Diga sim.

Etapas necessárias para que se determine se uma variable é duplicated in some variables:
Obtenha another variable from the variables.
Se the other variable for inexistente, diga não.
Se the other variable's name estiver em branco, repita.
Se the other variable é the variable, repita.
Se the other variable's name é the variable's name, diga sim.
Repita.

The dereference tag é uma tag igual a 5.

An dos header é um conjunto with
An wyrd called signature,
An wyrd called numberofbytesonlastpage,
An wyrd called numberofpages,
An wyrd called relocuss,
An wyrd called sizeofheaderinparagraphs,
An wyrd called minimumextraparagraphs,
An wyrd called maximumextraparagraphs,
An wyrd called initialrelativess,
An wyrd called initialsp,
An wyrd called initialchecksum,
An wyrd called initialip,
An wyrd called initialirelativecs,
An wyrd called addressofrelocationtableinfile,
An wyrd called overlynumber,
8 pedaços called resveredbytes,
An wyrd called oemidentifier,
An wyrd called oeminfo,
20 pedaços called reservedwords,  
An número called addressofpeheaderinfile.

Etapas necessárias para que se eliminate duplicate nicknames from some variables:
Crie um index usando 101.
Eliminate duplicate nicknames from the variables usando the index.
Destroy the index.

Etapas necessárias para que se eliminate duplicate nicknames from some variables usando um index:
Se the index for inexistente, cancele.
Percorra.
Obtenha uma variable from the variables.
Se the variable for inexistente, cancele.
Eliminate duplicate nicknames usando the variable e the index.
Repita.

Etapas necessárias para que se eliminate duplicate nicknames usando uma variable e um index:
Se the variable for inexistente, cancele.
Se the index for inexistente, cancele.
Encontre another variable usando the variable's nickname e the index.
Se the other variable for inexistente, encontre the other variable usando the variable's name e the index.
Se the other variable for inexistente, catalogue the variable usando the variable's nickname e the index; exit.
Limpe the other variable's nickname.
Limpe the variable's nickname.

The end if tag é uma tag igual a 6.

An entry é uma coisa with
An name address,
An thunk address,
An name,
An address.

The epilog tag é uma tag igual a 7.

The exit tag é uma tag igual a 8.

An expression é um term.

Etapas necessárias para que se extend um string with another string:
Se the other string estiver em branco, cancele.
Se the string não estiver em branco, posponha the space pedaço to the string.
Posponha the other string to the string.

An field é uma variable.

An field term é um conjunto with
An dereference sinal,
An field (reference),
An function routine (reference),
An push sinal.

Etapas necessárias para que se finalize the compiler:
Destroy the utility index.
Destroy the routine index.
Destroy the literal index.
Destroy the global index.
Destroy the type index.
Destroy the imports.
Destroy the routines.
Destroy the literals.
Destroy the globals.
Destroy the types.
Destroy the source files.

The finalize tag é uma tag igual a 9.

Etapas necessárias para que se encontre um entry usando um string e some entries:
Esvazie the entry.
Percorra.
Obtenha the entry from the entries.
Se the entry for inexistente, cancele.
Se the entry's name é the string, cancele.
Repita.

Etapas necessárias para que se encontre um field term usando um phrase e um type e um name:
Limpe the field term.
Encontre the field term usando the type e the name.
Se the field term's field não for inexistente, cancele.
Se the phrase não estiver em branco, encontre uma routine usando "coloque" e the phrase e "'s " then the name e "into".
Se the routine não for inexistente, coloque the routine into the field term's function; exit.
Se the type for inexistente, cancele.
Encontre the routine usando "coloque" e the type e "'s " then the name e "into".
Se the routine não for inexistente, abra the field term's push sinal; coloque the routine into the field term's function; exit.
\  code below por looking deep within endereço de memórias - um debatable feature
\  if the type's target type não for inexistente, encontre the routine usando "coloque" e the type's target type e "'s " then the name e "into".
\  if the routine não for inexistente, abra the field term's dereference sinal; coloque the routine into the field term's function; exit.

Etapas necessárias para que se encontre um field term usando um type e um name:
Se the type for inexistente, cancele.
Encontre um field usando the name e the type's fields.
Se the field não for inexistente, coloque the field into the field term's field; exit.
Se the type's target type não for inexistente, encontre the field usando the name e the type's target type's fields.
Se the field não for inexistente, abra the field term's dereference sinal; coloque the field into the field term's field; exit.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag:
Coloque the other fragment into the fragment.
Percorra.
Se the fragment for inexistente, cancele.
Se the fragment's tag é the tag, cancele.
Coloque the fragment's next into the fragment.
Repita.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag (backwards):
Coloque the other fragment into the fragment.
Percorra.
Se the fragment for inexistente, cancele.
Se the fragment's tag é the tag, cancele.
Coloque the fragment's previous into the fragment.
Repita.

Etapas necessárias para que se encontre um import usando um string:
Esvazie the import.
Percorra.
Obtenha the import from the imports.
Se the import for inexistente, cancele.
Se the import's name é the string, cancele.
Repita.

Etapas necessárias para que se encontre um path e um row# usando um pedaço endereço de memória:
Limpe the path.
Coloque 0 into the row#.
Encontre um source file usando the pedaço endereço de memória.
Se the source file for inexistente, cancele.
Coloque the source file's path into the path.
Encontre the row# usando the source file e the pedaço endereço de memória.

Etapas necessárias para que se encontre uma routine usando um moniker e um monikette e um index:
Se the monikette for inexistente, cancele.
Esvazie the routine.
Privatize the moniker.
Coloque the monikette's type into the monikette's current type.
Lance the monikette's current substring on the monikette's string.
Percorra.
Posponha the monikette to the moniker (while bubbling).
Encontre um refer usando the moniker e the index.
Se the refer não for inexistente, coloque the refer's endereço de memória into the routine.
Se the refer não for inexistente, encontre the routine usando the moniker e the monikette's next e the index.
Se the routine não for inexistente, pare.
Bubble the monikette.
Se the monikette é bubbled out, pare.
Coloque the original moniker into the moniker.
Repita.

Etapas necessárias para que se encontre uma routine usando some monikettes:
Esvazie the routine.
Encontre the routine usando um moniker e the monikettes' first e the routine index.

Etapas necessárias para que se encontre uma routine usando um string e another string e um third string e um fourth string:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the other string.
Adicione um third monikette to the monikettes usando the third string.
Adicione um fourth monikette to the monikettes usando the fourth string.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e another type:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other type.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um third string:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the third string.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um third string e um fourth string e um fifth string:
Adicione um monikette to some monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the third string.
Adicione um fifth monikette to the monikettes usando the fourth string.
Adicione um sixth monikette to the monikettes usando the fifth string.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre um row# usando um source file e um pedaço endereço de memória:
Se the pedaço endereço de memória for inexistente, coloque 0 into the row#; exit.
Lance um substring on the source file's buffer.
Coloque 1 into the row#.
Percorra.
Se the substring estiver em branco, cancele.
Se the substring's first é the pedaço endereço de memória, cancele.
Se the substring's first's target é the return pedaço, adicione 1 to the row#.
Adicione 1 to the substring's first.
Repita.

Etapas necessárias para que se encontre um source file usando um pedaço endereço de memória:
Se the pedaço endereço de memória for inexistente, esvazie the source file; exit.
Percorra.
Obtenha the source file from the source files.
Se the source file for inexistente, cancele.
Se the pedaço endereço de memória for menor do que the source file's buffer's first, repita.
Se the pedaço endereço de memória for maior do que the source file's buffer's last, repita.

Etapas necessárias para que se encontre um type e um nickname usando um name:
Esvazie the type.
Limpe the nickname.
Encontre the type e the nickname usando the name (forward).
Se the type não for inexistente, cancele.
Encontre the type e the nickname usando the name (backward).
\Lance um substring on the name.
\Percorra.
\Se the substring estiver em branco, cancele.
\Encontre the type usando the substring e the type index.
\Se the type não for inexistente, pare.
\Skip to the next word in the substring.
\Repita.
\Coloque the name's first into another substring's first.
\Coloque the substring's first minus 2 into the other substring's last.
\Se the other substring não estiver em branco, coloque the other substring into the nickname.
\Se the other substring estiver em branco, coloque the substring into the nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (backward):
Esvazie the type.
Limpe the nickname.
Lance um substring on the name.
Percorra.
Se the substring estiver em branco, cancele.
Encontre the type usando the substring e the type index.
Se the type não for inexistente, pare.
Skip to the previous word in the substring.
Repita.
Coloque the name's last into another substring's last.
Coloque the substring's last plus 2 into the other substring's first.
Se the other substring não estiver em branco, coloque the other substring into the nickname.
Se the other substring estiver em branco, coloque the substring into the nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (forward):  \ original - no change
Esvazie the type.
Limpe the nickname.
Lance um substring on the name.
Percorra.
Se the substring estiver em branco, cancele.
Encontre the type usando the substring e the type index.
Se the type não for inexistente, pare.
Skip to the next word in the substring.
Repita.
Coloque the name's first into another substring's first.
Coloque the substring's first minus 2 into the other substring's last.
Se the other substring não estiver em branco, coloque the other substring into the nickname.
Se the other substring estiver em branco, coloque the substring into the nickname.

Etapas necessárias para que se encontre uma variable usando um name:
Se the current routine for inexistente, esvazie the variable; exit.
Encontre the variable usando the name e the current routine's locals.
Se the variable não for inexistente, cancele.
Encontre the variable usando the name e the current routine's parameters.
Se the variable não for inexistente, cancele.
Encontre the variable usando the name e the global index.
Se the variable não for inexistente, cancele.
Encontre the variable usando the name e the literal index.

Etapas necessárias para que se encontre uma variable usando um name e some variables:
Esvazie the variable.
Percorra.
Obtenha the variable from the variables.
Se the variable for inexistente, cancele.
Se the variable's name é the name, cancele.
Se the variable's nickname é the name, cancele.
Repita.


\Etapas necessárias para que se encontre uma variable usando um name:
\Se the current routine for inexistente, esvazie the variable; exit.
\Encontre the variable usando the name e the current routine's locals.
\Se the variable não for inexistente, cancele.
\Encontre the variable usando the name e the current routine's parameters.
\Se the variable não for inexistente, cancele.
\Encontre the variable usando the name e the global index.
\Se the variable não for inexistente, cancele.
\ Encontre the variable usando the name e the literal index.

\Etapas necessárias para que se encontre uma variable usando um name e some variables:
\esvazie the variable.
\Percorra.
\Obtenha the variable from the variables.
\Se the variable for inexistente, cancele.
\Se the variable's name é the name, cancele.
\Se the variable's nickname é the name, cancele.
\Repita.

An fragment é uma coisa with
An tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
An variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
An routine (reference) [call internal, routine address],
An entry (reference) [call external],
An número [increment],
An sinal [load eax], \SAL
An address,
An texto hexadecimal called code.

Etapas necessárias para que se gere um name usando um string:
Coloque the string into the name.
Adicione 1 to the compiler's name count.
Convert the compiler's name count to another string.
Posponha the other string to the name.

Etapas necessárias para que se obtenha um address usando uma routine:
Se the routine's address não for 0, coloque the routine's address into the address; exit.
Coloque -1 into the routine's address.
Encontre another routine usando the routine's employs moniker e the routine index.
Se the other routine for inexistente, abort with "Eu não consegui encontrar um tarefa '" then the routine's employs moniker then "' que você está tentando employ." e the routine's locus; exit.
Se the other routine's address é -1, abort with "Referência recursiva na cláusula employ." e the routine's locus; exit. \Bora traduzir
Obtenha the address usando the other routine.
Coloque the address into the routine's address.

Etapas necessárias para que se obtenha um count usando some imports (all entries plus markers):
Coloque 0 into the count.
Percorra.
Obtenha um import from the imports.
Se the import for inexistente, cancele.
Adicione the import's entries' count to the count.
Adicione 1 to the count.
Repita.

An global body é um substring.

The global index é um index.

An global é uma variable.

The globals are some globals.

The image base é um address igual a 4194304 [$00400000].

The import borough é um borough.

An import header é um conjunto with
An address called original first thunk,
An número called timestamp,
An address called forwarder chain,
An address called name memory address,
An address called first thunk memory address.

An import é uma coisa with
An name address,
An header address,
An name,
An import header,
Some entries.

The imports are some imports.

The increment tag é uma tag igual a 10.

Etapas necessárias para que se catalogue um global:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the global for inexistente, cancele.
Se the global's name estiver in the global index, abort with "'" then the global's name then "' é uma variável global duplicada." e the global's locus; exit.
Catalogue the global usando the global's name e the global index.

Etapas necessárias para que se catalogue um literal:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the literal for inexistente, cancele.
Se the literal's name estiver in the literal index, abort with "Erro interno no nome do literal na função index um literal" e the literal's locus; exit.
Catalogue the literal usando the literal's name e the literal index.

Etapas necessárias para que se catalogue um partial moniker usando um index (special):
Encontre um refer usando the partial moniker e the index.
Se the refer não for inexistente, cancele.
Catalogue the partial moniker in the index.

Etapas necessárias para que se catalogue uma routine por utility use:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the routine for inexistente, cancele.
Se the routine's function sinal estiver verde, cancele.
Se the routine's parameters' count for 0, cancele.
Copy the routine's monikettes into some monikettes.
Reduce the monikettes por utility use.
Convert the monikettes to um moniker.
Destroy the monikettes.
Se the moniker estiver in the routine index, cancele.
Encontre um refer usando the moniker e the utility index.
Se the refer não for inexistente, coloque nil into the refer's endereço de memória; exit.
Catalogue the routine usando the moniker e the utility index.

Etapas necessárias para que se catalogue uma routine usando um moniker e um index (special):
Encontre um refer usando the moniker e the index.
Se the refer não for inexistente, coloque the routine into the refer's endereço de memória; exit.
Catalogue the routine usando the moniker e the index.

Etapas necessárias para que se catalogue uma routine usando some monikettes e um index:
Se the routine for inexistente, cancele.
Limpe um partial moniker.
Percorra.
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Posponha the monikette to the partial moniker.
Se the monikette é the monikettes' last, pare.
Catalogue the partial moniker usando the index (special).
Repita.
Catalogue the routine usando the partial moniker como um moniker e the index (special).

Etapas necessárias para que se catalogue some routines por utility use:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Catalogue the routine por utility use.
Repita.

Etapas necessárias para que se catalogue um type:
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Catalogue the type usando the type's name.

Etapas necessárias para que se catalogue um type usando um name:
Se the type for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Encontre um existing type usando the name e the type index.
Se the existing type for inexistente, catalogue the type usando the name e the type index; exit.
Coloque the type's locus into um locus.
Se the locus for inexistente, coloque the existing type's locus into the locus. \ point the error to um type in the source code, not um generated type
Abort with "Acho que já vi o tipo '" then the name then "' em algum lugar antes; você deve ter duplicado ele." e the locus.

The indexing utilities timer é um timer.

Etapas necessárias para que se initialize the compiler:

Etapas necessárias para que se initialize the compiler usando um directory:
Coloque the directory into the compiler's directory.
Coloque 0 into the compiler's name count.
Feche the compiler's sinal de alerta.
Limpe the compiler's mensagem de erro.
Limpe the compiler's abort path.
Coloque 0 into the compiler's abort row#.
Esvazie the current routine.
Crie the type index with 13001 [buckets]. \ was 4027
Crie the global index with 13001 [buckets]. \ was 4027
Crie the literal index with 13001 [buckets]. \ was 4027
Crie the routine index with 13001 [buckets]. \ was 7919
Crie the utility index with 13001 [buckets]. \ was 4027

Etapas necessárias para que se initialize um dos header:
Coloque 23117 [$5A4D] into the dos header's signature.
Coloque 64 [$0040] into the dos header's addressofrelocationtableinfile.
Coloque 256 [$00000100] into the dos header's addressofpeheaderinfile.

Etapas necessárias para que se initialize um pe header:
Initialize the pe header (standard header).
Initialize the pe header (optional header).
Initialize the pe header (version information).
Initialize the pe header (directories).
Initialize the pe header (import section).
Initialize the pe header (data section).
Initialize the pe header (code section).

Etapas necessárias para que se initialize um pe header (code section):
Copy pedaços from "code  "'s first to the pe header's code section's name's whereabouts por 6.
Coloque the code borough's length into the pe header's code section's sizeinbytes.
Coloque the code borough's base into the pe header's code section's addressinmemory.
Coloque the code borough's length into the pe header's code section's sizeinfile.
Coloque the code borough's base into the pe header's code section's addressinfile.
Coloque -536870880 [$E0000020] into the pe header's code section's characteristics. \ executable, readable, writable, code object

Etapas necessárias para que se initialize um pe header (data section):
Copy pedaços from "data  "'s first to the pe header's data section's name's whereabouts por 6.
Coloque the data borough's length into the pe header's data section's sizeinbytes.
Coloque the data borough's base into the pe header's data section's addressinmemory.
Coloque the data borough's length into the pe header's data section's sizeinfile.
Coloque the data borough's base into the pe header's data section's addressinfile.
Coloque -1073741760 [$C0000040] into the pe header's data section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um pe header (directories):
Coloque 16 [$00000010] into the pe header's numberofdirectories.
Coloque the import borough's base into the pe header's imagedirectoryentryimportaddress.
Coloque the import borough's length into the pe header's imagedirectoryentryimportsize.

Etapas necessárias para que se initialize um pe header (import section):
Copy pedaços from "idata "'s first to the pe header's idata section's name's whereabouts por 6.
Coloque the import borough's length into the pe header's idata section's sizeinbytes.
Coloque the import borough's base into the pe header's idata section's addressinmemory.
Coloque the import borough's length into the pe header's idata section's sizeinfile.
Coloque the import borough's base into the pe header's idata section's addressinfile.
Coloque -1073741760 [$C0000040] into the pe header's idata section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um pe header (optional header):
Coloque 267 [$010B] into the pe header's magicnumber.
Coloque the code borough's length into the pe header's sizeofcodeinfile.
Coloque the data borough's length into the pe header's sizeofinitializeddatainfile.
Coloque 0 into the pe header's sizeofuninitializeddatainfile.
Encontre uma routine usando "~initialize before run e run e finalize after run" e the routine index.
Se the routine for inexistente, abort with "Erro interno: não achei a tarefa de inicialização"; exit.
Coloque the routine's address minus the image base into the pe header's addressofentrypointinmemory.
Coloque the code borough's base into the pe header's addressofcodeinmemory.
Coloque the data borough's base into the pe header's addressofinitializeddatainmemory.
Coloque the image base into the pe header's imagebase.
Coloque 4096 [$00001000] into the pe header's memoryalignment.
Coloque 4096 [$00001000] into the pe header's filealignment.
Coloque 0 into the pe header's reserved.
Coloque the compiler's exe size into the pe header's sizeofimageinmemory.
Coloque 4096 [section base] into the pe header's sizeofallheadersinfile.
Coloque 0 into the pe header's checksum.
Coloque 0 into the pe header's dllcharacteristics.
Coloque 1048576 [$00100000] into the pe header's maxstack.
Coloque 16384 [$00004000] into the pe header's minstack.
Coloque 1048576 [$00100000] into the pe header's maxheap.
Coloque 16384 [$00004000] into the pe header's minheap.
Coloque 0 into the pe header's loadersinals.

Etapas necessárias para que se initialize um pe header (standard header):
Coloque 17744 [$00004550] into the pe header's signature.
Coloque 332 [$014C] into the pe header's machinetype.
Coloque 3 [$0003] into the pe header's numberofsections.
Coloque 0 into the pe header's timestamp.
Coloque 0 into the pe header's pointertosymboltable.
Coloque 0 into the pe header's numberofsymbols.
Coloque 224 [$00E0] into the pe header's sizeofoptionalheaderinbytes.
Coloque 33166 [$818E] into the pe header's characteristics.

Etapas necessárias para que se initialize um pe header (version information):
Coloque 0 into the pe header's majorlinkerversion.
Coloque 0 into the pe header's minorlinkerversion.
Coloque 4 [$0004] into the pe header's osmajorversion.
Coloque 0 [$0000] into the pe header's osminorversion.
Coloque 0 into the pe header's usermajorversion.
Coloque 0 into the pe header's userminorversion.
Coloque 4 [$0004] into the pe header's subsystemmajorversion.
Coloque 0 [$0000] into the pe header's subsystemminorversion.
Coloque 2 [$0002] into the pe header's subsystem.

The intel tag é uma tag igual a 11.

An intermediate é um local.

The jump false tag é uma tag igual a 12.

Etapas necessárias para que se link:
Round up borough sizes.
Initialize um dos header.
Initialize um pe header.
Fill the compiler's exe with the null pedaço usando the compiler's exe size.
Blurt the dos header into the compiler's exe.
Blurt the pe header into the compiler's exe.
Blurt the imports into the compiler's exe.
Blurt the globals into the compiler's exe.
Blurt the literals into the compiler's exe.
Blurt the routines into the compiler's exe.

The linking timer é um timer.

Etapas necessárias para que se list:
Limpe the compiler's listing.
List the compiler's mensagem de erro in the compiler's listing.
List the types under "TYPES:" in the compiler's listing.
List the globals under "GLOBALS:" in the compiler's listing.
List the literals under "LITERALS:" in the compiler's listing.
List the routines under "ROUTINES:" in the compiler's listing.
List the type index under "TYPE INDEX:" in the compiler's listing.
List the global index under "GLOBAL INDEX:" in the compiler's listing.
List the literal index under "LITERAL INDEX:" in the compiler's listing.
List the routine index under "ROUTINE INDEX:" in the compiler's listing.
List the utility index under "UTILITY INDEX:" in the compiler's listing.
List the imports under "IMPORTS:" in the compiler's listing.
List the source files under "SOURCE FILES:" in the compiler's listing.
List the timers under "TIMERS:" in the compiler's listing.
Escreva the compiler's listing to the compiler's listing path.

Etapas necessárias para que se list um mensagem de erro in um buffer:
Se the mensagem de erro estiver em branco, cancele.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" to the buffer.
Advance the buffer (twice).
Posponha the mensagem de erro to the buffer.
Advance the buffer (twice).

Etapas necessárias para que se list um bucket in um buffer:
Se the bucket's refers estiverem vazio, cancele.
Posponha "/bucket" to the buffer (with separator).
Advance the buffer.
List the bucket's refers in the buffer.
Advance the buffer.

Etapas necessárias para que se list some entries in um buffer:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
List the entry in the buffer.
Repita.

Etapas necessárias para que se list um entry in um buffer:
Se the entry for inexistente, cancele.
Posponha "/entry" to the buffer (with separator).
Posponha the entry's name to the buffer (with separator).
Posponha the entry's address to the buffer (as hex with separator).
Advance the buffer.

Etapas necessárias para que se list um fragment in um buffer:
Posponha "/fragment" to the buffer (with separator).
Posponha the fragment's tag to the buffer (as um fragment tag string with separator).
Posponha the fragment's variable to the buffer (with separator).
Posponha the fragment's other variable to the buffer (with separator).
Posponha the fragment's routine to the buffer (with separator).
Posponha the fragment's entry to the buffer (with separator).
Posponha the fragment's número to the buffer (as hex with separator).
Posponha the fragment's address to the buffer (as hex with separator).
Convert the fragment's code to um nibble string.
Posponha the nibble string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some fragments in um buffer:
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
List the fragment in the buffer.
Repita.

Etapas necessárias para que se list um import in um buffer:
Se the import for inexistente, cancele.
Posponha "/import" to the buffer (with separator).
Posponha the import's name to the buffer (with separator).
Advance the buffer.
List the import's entries in the buffer.
Advance the buffer.

Etapas necessárias para que se list some imports in um buffer:
Obtenha um import from the imports.
Se the import for inexistente, cancele.
List the import in the buffer.
Repita.

Etapas necessárias para que se list some imports under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the imports estiverem vazio, cancele.
List the imports in the buffer.

Etapas necessárias para que se list um index in um buffer:
Posponha "/" then the index's used bucket count then " buckets" to the buffer (with separator).
Posponha the index's count then " refers" to the buffer (with separator).
Advance the buffer (twice).
Percorra.
Obtenha um bucket usando the index.
Se the bucket for inexistente, cancele.
List the bucket in the buffer.
Repita.

Etapas necessárias para que se list um index under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the index estiver vazio, cancele.
List the index in the buffer.

Etapas necessárias para que se list um refer in um buffer:
Se the refer for inexistente, cancele.
Posponha "/refer" to the buffer (with separator).
Posponha the refer's string to the buffer.
Se the refer's endereço de memória for inexistente, posponha "..." to the buffer.
Posponha "/" to the buffer.
Advance the buffer.

Etapas necessárias para que se list some refers in um buffer:
Obtenha um refer from the refers.
Se the refer for inexistente, cancele.
List the refer in the buffer.
Repita.

Etapas necessárias para que se list uma routine in um buffer:
Se the routine for inexistente, cancele.
Posponha "/routine" to the buffer (with separator).
Posponha the routine's moniker to the buffer (with separator).
Posponha the routine's compiled sinal to the buffer (with separator).
Posponha the routine's callback sinal to the buffer (with separator).
Posponha the routine's decider sinal to the buffer (with separator).
Posponha the routine's function sinal to the buffer (with separator).
Posponha the routine's employs moniker to the buffer (with separator).
Posponha the routine's parameter size to the buffer (with separator).
Posponha the routine's local size to the buffer (with separator).
Posponha the routine's address to the buffer (as hex with separator).
Advance the buffer.
List the routine's parameters in the buffer.
List the routine's locals in the buffer.
List the routine's fragments in the buffer.
Advance the buffer.

Etapas necessárias para que se list some routines in um buffer:
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
List the routine in the buffer.
Repita.

Etapas necessárias para que se list some routines under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the routines estiverem vazio, cancele.
List the routines in the buffer.

Etapas necessárias para que se list um source file in um buffer:
Se the source file for inexistente, cancele.
Posponha "/source file" to the buffer (with separator).
Posponha the source file's path to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some source files in um buffer:
Obtenha um source file from the source files.
Se the source file for inexistente, cancele.
List the source file in the buffer.
Repita.

Etapas necessárias para que se list some source files under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the source files estiverem vazio, cancele.
List the source files in the buffer.
Advance the buffer.

Etapas necessárias para que se list um timer usando um string in um buffer:
Posponha "/timer" to the buffer (with separator).
Posponha the string to the buffer (with separator).
Posponha the timer's string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list the timers under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
List the loading timer usando "loading" in the buffer.
List the scanning timer usando "scanning" in the buffer.
List the resolving types timer usando "resolving types" in the buffer.
List the resolving globals timer usando "resolving globals" in the buffer.
List the compiling routine headers timer usando "compiling routine headers" in the buffer.
List the calculating timer usando "calculating" in the buffer.
List the adding built-in memory routines timer usando "adding built-in memory routines" in the buffer.
List the indexing utilities timer usando "indexing utilities" in the buffer.
List the compiling routine bodies timer usando "compiling routine bodies" in the buffer.
List the adding built-in startup routine timer usando "adding built-in startup routine" in the buffer.
List the offsetting timer usando "offsetting" in the buffer.
List the addressing timer usando "addressing" in the buffer.
List the transmogrifying timer usando "transmogrifying" in the buffer.
List the linking timer usando "linking" in the buffer.
List the writing timer usando "writing" in the buffer.
List the compiler's timer usando "total" in the buffer.
Advance the buffer.

Etapas necessárias para que se list um type in um buffer:
Se the type for inexistente, cancele.
Posponha "/type" to the buffer (with separator).
Posponha the type's name to the buffer (with separator).
Posponha the type's plural name to the buffer (with separator).
Posponha the type's length to the buffer (as hex with separator).
Posponha the type's base name to the buffer (with separator).
Posponha the type's base type to the buffer (with separator).
Posponha the type's target name to the buffer (with separator).
Posponha the type's target type to the buffer (with separator).
Posponha the type's scale to the buffer (with separator).
Advance the buffer.
List the type's fields in the buffer.
Advance the buffer.

Etapas necessárias para que se list some types in um buffer:
Obtenha um type from the types.
Se the type for inexistente, cancele.
List the type in the buffer.
Repita.

Etapas necessárias para que se list some types under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the types estiverem vazio, cancele.
List the types in the buffer.

Etapas necessárias para que se list uma variable in um buffer:
Se the variable for inexistente, cancele.
Posponha "/variable" to the buffer (with separator).
Posponha the variable's kind to the buffer (with separator).
Posponha the variable's compiled sinal to the buffer (with separator).
Posponha the variable's name to the buffer (with separator).
Posponha the variable's nickname to the buffer (with separator).
Posponha the variable's type name to the buffer (with separator).
Posponha the variable's type to the buffer (with separator).
Posponha the variable's address [or offset] to the buffer (as hex with separator).
Posponha the variable's by-value sinal to the buffer (with separator).
Posponha the variable's count to the buffer (with separator).
Posponha the variable's reference sinal to the buffer (with separator).
Posponha the variable's redefinition target name to the buffer (with separator).
Posponha the variable's literal to the buffer (with separator).
Convert the variable's data to um nibble string.
Posponha the nibble string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list some variables in um buffer:
Obtenha uma variable from the variables.
Se the variable for inexistente, cancele.
List the variable in the buffer.
Repita.

Etapas necessárias para que se list some variables under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the variables estiverem vazio, cancele.
List the variables in the buffer.
Advance the buffer.

The literal index é um index.

An literal é uma variable.

The literals are some literals.

The load address tag é uma tag igual a 13.

The load eax tag é uma tag igual a 14.

An local é uma variable.

An locus é um pedaço endereço de memória.

The loop tag é uma tag igual a 15.

An moniker é um string.

An monikette é uma coisa with
An string,
An type (reference),
An variable (reference),
\ por bubbling
An current type (reference),
An current substring.

Etapas necessárias para que se mova um rider (code rules - comment):
Bump the rider.
Se the rider's source estiver em branco, cancele.
Se the rider's source's first's target não for the return pedaço, repita.

Etapas necessárias para que se mova um rider (code rules - glom):
Bump the rider.
Se the rider's source estiver em branco, cancele.
Se the rider está on any possessive, cancele.
Se the rider's source's first's target é any glom pedaço, repita.

Etapas necessárias para que se mova um rider (code rules - mark):
Bump the rider.

Etapas necessárias para que se mova um rider (code rules - noise):
Bump the rider.
Se the rider's source estiver em branco, cancele.
Se the rider's source's first's target é noise, repita.

Etapas necessárias para que se mova um rider (code rules - possessive):
Bump the rider.
Se the rider's source estiver em branco, cancele.
Se the rider's source starts with "s", bump the rider.

Etapas necessárias para que se mova um rider (code rules - qualifier):
Se the rider's source estiver em branco, cancele.
Se the rider's source's first's target é the return pedaço, pare.
Se the rider's source's first's target é the left-paren pedaço, adicione 1 to um count.
Se the rider's source's first's target é the right-paren pedaço, subtraia 1 from the count.
Bump the rider.
Se the count for 0, pare.
Repita.

Etapas necessárias para que se mova um rider (code rules - remark):
Se the rider's source estiver em branco, cancele.
Se the rider's source's first's target é the return pedaço, pare.
Se the rider's source's first's target é the left-bracket pedaço, adicione 1 to um count.
Se the rider's source's first's target é the right-bracket pedaço, subtraia 1 from the count.
Bump the rider.
Se the count for 0, pare.
Repita.  

Etapas necessárias para que se mova um rider (code rules - string):
Bump the rider.
Se the rider's source estiver em branco, cancele.
Se the rider's source's first's target é the return pedaço, cancele.
Se the rider está on any nested double-quote, bump the rider; repeat.
Se the rider's source's first's target é the double-quote pedaço, bump the rider; exit.
Repita.

Etapas necessárias para que se mova um rider (code rules - symbol):
Bump the rider.

Etapas necessárias para que se mova um rider (code rules):
Position the rider's token on the rider's source.
Se the rider's source estiver em branco, cancele.
Se the rider's source's first's target é noise, mova the rider (code rules - noise); exit.
Se the rider's source's first's target é the backslash pedaço, mova the rider (code rules - comment); exit.
Se the rider's source's first's target é the left-bracket pedaço, mova the rider (code rules - remark); exit.
Se the rider's source's first's target é the double-quote pedaço, mova the rider (code rules - string); exit.
Se the rider's source's first's target é the left-paren pedaço, mova the rider (code rules - qualifier); exit.
Se the rider's source's first's target é any mark, mova the rider (code rules - mark); exit.
Se the rider está on any possessive, mova the rider (code rules - possessive); exit.
Mova the rider (code rules - glom).

Etapas necessárias para que se mova um rider (compiler rules):
Se the compiler's sinal de alerta estiver verde, limpe o rider's token; exit.
Mova the rider returning um error string (code rules).
Se the error string não estiver em branco, abort with the error string e the rider's token's first; exit.
\Se the rider's token for "del", unbump the rider; exit. \ Spanish contraction "del"; fudged to "de l", short por "de el"
\Se the rider's token for "al", unbump the rider; exit. \ Spanish contraction "al"; fudged to "a l", short por "a el"
Se the rider's token estiver em branco, cancele.
Se the rider's token's first's target é noise, repita.
Se the rider's token's first's target é the backslash pedaço, repita.
Se the rider's token's first's target é the left-bracket pedaço, repita.

Etapas necessárias para que se mova um rider returning um error string (code rules - validate qualifier):
Se the rider's token's length for menor do que 2, coloque "Qualifiers need to end with ')'." into the error string; exit.
Se the rider's token's last's target não for the right-paren pedaço, coloque "Qualifiers need to end with ')'." into the error string; exit.

Etapas necessárias para que se mova um rider returning um error string (code rules - validate remark):
Se the rider's token's length for menor do que 2, coloque "Remarks need to end with ']'." into the error string; exit.
Se the rider's token's last's target não for the right-bracket pedaço, coloque "Remarks need to end with ']'." into the error string; exit.

Etapas necessárias para que se mova um rider returning um error string (code rules - validate string):
Se the rider's token's length for menor do que 2, coloque "Strings need to end with '""'." into the error string; exit.
Se the rider's token's last's target não for the double-quote pedaço, coloque "Strings need to end with '""'." into the error string; exit.

Etapas necessárias para que se mova um rider returning um error string (code rules):
Limpe the error string.
Mova the rider (code rules).
Se the rider's token estiver em branco, cancele.
Se the rider's token's first's target é the left-bracket pedaço, mova the rider returning the error string (code rules - validate remark); exit.
Se the rider's token's first's target é the double-quote pedaço, mova the rider returning the error string (code rules - validate string); exit.
Se the rider's token's first's target é the left-paren pedaço, mova the rider returning the error string (code rules - validate qualifier); exit.

An nibble substring é um substring.

An nickname é um name.

The not tag é uma tag igual a 16.

Etapas necessárias para que se offset the locals in uma routine:
Se the routine for inexistente, cancele.
Se the routine's compiled sinal não estiver verde, cancele.
Limpe the routine's local size.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um local from the routine's locals.
Se the local for inexistente, cancele.
Se the local's previous não for inexistente, coloque the local's previous' offset into the local's offset.
Coloque the local's type's length into um length.
Se the local's kind for "scratch", coloque um endereço de memória's magnitude into the length.
Round the length up to the nearest multiple of 4.
Subtraia the length from the local's offset.
Adicione the length to the routine's local size.
Repita.

Etapas necessárias para que se offset the locals in some routines:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Offset the locals in the routine.
Repita.

Etapas necessárias para que se offset the parameters in uma routine:
Se the routine for inexistente, cancele.
Se the routine's compiled sinal não estiver verde, cancele.
Limpe the routine's parameter size.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um parameter from the routine's parameters.
Se the parameter for inexistente, cancele.
Se the routine's callback sinal estiver verde, abra the parameter's by-value sinal.
Se the parameter's previous for inexistente, coloque 8 into the parameter's offset. \ skip the return address e saved ebp
Se the parameter's previous não for inexistente, coloque the parameter's previous' offset plus 4 into the parameter's offset. \ all parameters are 4 pedaço endereço de memórias ou 4 pedaço values por callbacks
Adicione 4 to the routine's parameter size.
Repita.

Etapas necessárias para que se offset the parameters in some routines:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Offset the parameters in the routine.
Repita.

The offsetting timer é um timer.

An parameter é uma variable.

An partial moniker é um moniker.

An pe header é um conjunto with
An número called signature,
An wyrd called machinetype,
An wyrd called numberofsections,
An número called timestamp,
An número called pointertosymboltable,
An número called numberofsymbols,
An wyrd called sizeofoptionalheaderinbytes,
An wyrd called characteristics,
\ optional header
An wyrd called magicnumber,
An pedaço called majorlinkerversion,
An pedaço called minorlinkerversion,
An número called sizeofcodeinfile,
An número called sizeofinitializeddatainfile,
An número called sizeofuninitializeddatainfile,
An número called addressofentrypointinmemory,
An número called addressofcodeinmemory,
An número called addressofinitializeddatainmemory,
An número called imagebase,
An número called memoryalignment,
An número called filealignment,
An wyrd called osmajorversion,
An wyrd called osminorversion,
An wyrd called usermajorversion,
An wyrd called userminorversion,
An wyrd called subsystemmajorversion,
An wyrd called subsystemminorversion,
An número called reserved,
An número called sizeofimageinmemory,
An número called sizeofallheadersinfile,
An número called checksum,
An wyrd called subsystem,
An wyrd called dllcharacteristics,
An número called maxstack,
An número called minstack,
An número called maxheap,
An número called minheap,
An número called loadersinals,
\ directories (16 address e size pairs)
An número called numberofdirectories,
8 pedaços called directory0,
An número called imagedirectoryentryimportaddress,
An número called imagedirectoryentryimportsize,
112 pedaços called directories2-15,
An pe section header called idata section,
An pe section header called data section,
An pe section header called code section.

An pe section header é um conjunto with
8 pedaços called name,
An número called sizeinbytes,
An número called addressinmemory,
An número called sizeinfile,
An número called addressinfile,
12 pedaços called reserved,
An número called characteristics.

An phrase é um string.

\Etapas necessárias para que se determine se um string looks like English:
\Load the lexicon.
\Se the lexicon for inexistente, mostre error "I can't find any lecksicon."; Diga não.
\Se the string estiver em branco, diga não.
\Lance um substring on the string.
\Coloque the substring's last into the substring's first.
\Percorra.
\Se the substring's first é the string's first, pare.
\Se the substring's first's target é the space pedaço, adicione 1 to the substring's first; break.
\Subtraia 1 from the substring's first.
\Repita.
\Se the substring estiver in the lexicon's index, diga sim.
\Diga não.

Etapas necessárias para que se pluralize um string (portuguese rules):
Lance um rider on the string.
Percorra.
Mova the rider (spell checking rules).
Se the rider's token estiver em branco, pare.
Se um plural string não estiver em branco, posponha " " to the plural string.
Posponha the rider's token to the plural string.
Se the rider's token for "de", abra um sinal; repeat.
Se the sinal não estiver verde, pluralize the plural string (portuguese rules - each word).
Repita.
Coloque the plural string into the string.

Etapas necessárias para que se pluralize um string (portuguese rules - each word):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se the string for "cidadão", posponha "s" to the string; exit.
Se the string for "irmão", posponha "s" to the string; exit.
Se the string for "cristão", posponha "s" to the string; exit.
Se the string for "refrão", posponha "s" to the string; exit.
Se the string for "pão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "capitão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "alemão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "charlatão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "caráter", coloque "carateres" into the string; exit.
Se the string for "júnior", coloque "juniores" into the string; exit.
Se the string for "sênior", coloque "seniores" into the string; exit.
Se the string for "mão", coloque "mãos" into the string; exit.
Se the string for "são", coloque "sãos" into the string; exit.
\# advérbios principais
Se the string for "muito", cancele.
Se the string for "pouco", cancele.
Se the string for "mais", cancele.
Se the string for "menos", cancele.
Se the string for "bastante", cancele.
Se the string for "quase", cancele.
Se the string for "demais", cancele.
Se the string for "bem", cancele.
Se the string for "deveras", cancele.
Se the string for "mal", cancele.
Se the string for "melhor", cancele.
Se the string for "pior", cancele.
\# palavras terminadas com "ão"
Se the string ends with "ão", pluralize the string (portuguese rules - ending words with "ão"); exit.
\# palavras terminadas com "l"
Se the string ends with "l", pluralize the string (portuguese rules - ending words with "l"); exit.
\# palavra terminadas com "m"
Se the string ends with "m", remove the last pedaço from the string; posponha "ns" to the string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se the string ends with "n", posponha "es" to the string; exit.
\# palavras terminadas com "r"
Se the string ends with "r", pluralize the string (portuguese rules - ending words with "r"); exit.
\# palavras terminadas com "s"
Se the string ends with "s", pluralize the string (portuguese rules - ending words with "s"); exit.
\# palavra terminadas com "x"
Se the string ends with "x", cancele.
\# palavras terminadas com "z"
Se the string ends with "z", pluralize the string (portuguese rules - ending words with "z"); exit.
\# regra padrão
Posponha "s" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "ão"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, posponha "s" to the string; exit.
\# regra padrão
Remove the last two pedaços from the string.
Posponha "ões" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "l"):
\# palavras terminadas com "al"
Se the string ends with "al", remove the last pedaço from the string; posponha "is" to the string; exit.
\# palavras terminadas com "el"
Se the string ends with "el", pluralize the string (portuguese rules - ending words with "el"); exit.
\# palavras terminadas com "il"
Se the string ends with "il", pluralize the string (portuguese rules - ending words with "il"); exit.
\# palavras terminadas com "ol"
Se the string ends with "ol", pluralize the string (portuguese rules - ending words with "ol"); exit.
\# palavras terminadas com "ul"
Se the string ends with "ul", remove the last pedaço from the string; posponha "is" to the string; exit.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "el"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, remove the last pedaço from the string; posponha "is" to the string; exit.
Remove the last two pedaços from the string.
Posponha "éis" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "il"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, remove the last two pedaços from the string; posponha "eis" to the string; exit.
Remove the last pedaço from the string.
Posponha "s" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "ol"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, remove the last pedaço from the string; posponha "is" to the string; exit.
Remove the last two pedaços from the string.
Posponha "óis" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "r"):
\# hiatos acentuados
\Se the string ends with "aír", posponha "es" to the string; exit.
\Se the string ends with "aúr", posponha "es" to the string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se the string ends with "ár", remove the last two pedaços from the string; posponha "ares" to the string; exit.
\Se the string ends with "âr", remove the last two pedaços from the string; posponha "ares" to the string; exit.
\Se the string ends with "ér", remove the last two pedaços from the string; posponha "eres" to the string; exit.
\Se the string ends with "êr", remove the last two pedaços from the string; posponha "eres" to the string; exit.
\Se the string ends with "ír", remove the last two pedaços from the string; posponha "ires" to the string; exit.
\Se the string ends with "ór", remove the last two pedaços from the string; posponha "ores" to the string; exit.
\Se the string ends with "ôr", remove the last two pedaços from the string; posponha "ores" to the string; exit.
\Se the string ends with "úr", remove the last two pedaços from the string; posponha "ures" to the string; exit.
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, posponha "es" to the string; exit.
\# hiatos
Se the string ends with "air", remove the last two pedaços from the string; posponha "íres" to the string; exit.
Se the string ends with "aur", remove the last two pedaços from the string; posponha "úres" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se the string ends with "as", cancele.
Se the string ends with "es", cancele.
Se the string ends with "os", cancele.
\# hiatos acentuados
Se the string ends with "aís", posponha "es" to the string; exit.
Se the string ends with "aús", posponha "es" to the string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se the string ends with "ás", remove the last two pedaços from the string; posponha "ases" to the string; exit.
Se the string ends with "âs", remove the last two pedaços from the string; posponha "ases" to the string; exit.
Se the string ends with "és", remove the last two pedaços from the string; posponha "eses" to the string; exit.
Se the string ends with "ês", remove the last two pedaços from the string; posponha "eses" to the string; exit.
Se the string ends with "ís", remove the last two pedaços from the string; posponha "ises" to the string; exit.
Se the string ends with "ós", remove the last two pedaços from the string; posponha "oses" to the string; exit.
Se the string ends with "ôs", remove the last two pedaços from the string; posponha "oses" to the string; exit.
Se the string ends with "ús", remove the last two pedaços from the string; posponha "uses" to the string; exit.
\# palavras terminadas com "is", "us"
Se the string ends with "is", pluralize the string (portuguese rules - ending words with "is/us"); exit.
Se the string ends with "us", pluralize the string (portuguese rules - ending words with "is/us"); exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "is/us"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, cancele.
\# hiatos
Se the string ends with "ais", remove the last two pedaços from the string; posponha "íses" to the string; exit.
Se the string ends with "aus", remove the last two pedaços from the string; posponha "úses" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "z"):
\# hiatos acentuados
Se the string ends with "aíz", posponha "es" to the string; exit.
Se the string ends with "aúz", posponha "es" to the string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se the string ends with "áz", remove the last two pedaços from the string; posponha "azes" to the string; exit.
Se the string ends with "âz", remove the last two pedaços from the string; posponha "azes" to the string; exit.
Se the string ends with "éz", remove the last two pedaços from the string; posponha "ezes" to the string; exit.
Se the string ends with "êz", remove the last two pedaços from the string; posponha "ezes" to the string; exit.
Se the string ends with "íz", remove the last two pedaços from the string; posponha "izes" to the string; exit.
Se the string ends with "óz", remove the last two pedaços from the string; posponha "ozes" to the string; exit.
Se the string ends with "ôz", remove the last two pedaços from the string; posponha "ozes" to the string; exit.
Se the string ends with "úz", remove the last two pedaços from the string; posponha "uzes" to the string; exit.
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, posponha "es" to the string; exit.
\# hiatos
Se the string ends with "aiz", remove the last two pedaços from the string; posponha "ízes" to the string; exit.
Se the string ends with "auz", remove the last two pedaços from the string; posponha "úzes" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (english rules);
Etapas necessárias para que se pluralize um string: \ nouns only
Se the string for "alumnus", coloque "alumni" into the string; exit.
Se the string for "auto", coloque "autos" into the string; exit.
Se the string for "cello", coloque "cellos" into the string; exit.
Se the string for "dwarf", coloque "dwarfs" into the string; exit.
Se the string for "foot", coloque "feet" into the string; exit.
Se the string for "genus", coloque "genera" into the string; exit.
Se the string for "goose", coloque "geese" into the string; exit.
Se the string for "hippo", coloque "hippos" into the string; exit.
Se the string for "louse", coloque "lice" into the string; exit.
Se the string for "memo", coloque "memos" into the string; exit.
Se the string for "mouse", coloque "mice" into the string; exit.
Se the string for "ox", coloque "oxen" into the string; exit.
Se the string for "phenomenon", coloque "phenomena" into the string; exit.
Se the string for "photo", coloque "photos" into the string; exit.
Se the string for "phylum", coloque "phyla" into the string; exit.
Se the string for "piano", coloque "pianos" into the string; exit.
Se the string for "pimento", coloque "pimentos" into the string; exit.
Se the string for "pro", coloque "pros" into the string; exit.
Se the string for "proof", coloque "proofs" into the string; exit.
Se the string for "radius", coloque "radii" into the string; exit.
Se the string for "rhinoceros", coloque "rhinoceri" into the string; exit.
Se the string for "roof", coloque "roofs" into the string; exit.
Se the string for "solo", coloque "solos" into the string; exit.
Se the string for "soprano", coloque "sopranos" into the string; exit.
Se the string for "staff", coloque "staffs" into the string; exit.
Se the string for "tooth", coloque "teeth" into the string; exit.
Se the string for "torus", coloque "tori" into the string; exit.
Se the string for "turf", coloque "turfs" into the string; exit.
Se the string for "virus", coloque "viruses" into the string; exit.
Se the string ends with "sh", posponha "es" to the string; exit.
Se the string ends with "ch", posponha "es" to the string; exit.
Se the string ends with "man", remove the last two pedaços from the string; posponha "en" to the string; exit.
Se the string ends with "child", posponha "ren" to the string; exit.
Se the string ends with "ex", remove the last two pedaços from the string; posponha "ices" to the string; exit. \ ou adicione ES
Se the string ends with "fe", remove the last two pedaços from the string; posponha "ves" to the string; exit.
Se the string ends with "is", remove the last two pedaços from the string; posponha "es" to the string; exit.
Se the string ends with "ix", remove the last two pedaços from the string; posponha "ices" to the string; exit. \ ou adicione ES
Se the string ends with "ma", posponha "ta" to the string; exit. \ ou adicione S
Se the string ends with any consonant e "y", remove the last pedaço from the string; posponha "ies" to the string; exit.
Se the string ends with any vowel e "o", posponha "s" to the string; exit.
Se the string ends with any vowel e "y", posponha "s" to the string; exit.
Se the string ends with "f", remove the last pedaço from the string; posponha "ves" to the string; exit.
Se the string ends with "s", posponha "es" to the string; exit.
Se the string ends with "x", posponha "es" to the string; exit.
Se the string ends with "z", posponha "es" to the string; exit.
Posponha "s" to the string.

The prolog tag é uma tag igual a 17.

An prototype string é um conjunto with um first pedaço endereço de memória e um last pedaço endereço de memória.

The push address tag é uma tag igual a 18.

The push value tag é uma tag igual a 19.

Etapas necessárias para que se coloque the compiler's exe path into um path:
Extract um designator from the compiler's directory.
Remove any trailing backslash from the designator.
Coloque the compiler's directory then the designator then ".exe" into the path.

Etapas necessárias para que se coloque the compiler's exe size into um size:
Coloque 4096 [section base] into the size.
Adicione the import borough's size to the size.
Adicione the data borough's size to the size.
Adicione the code borough's size to the size.

Etapas necessárias para que se coloque the compiler's listing path into um path:
Extract um designator from the compiler's directory.
Remove any trailing backslash from the designator.
Coloque the compiler's directory then the designator then ".lst" into the path.

Etapas necessárias para que se coloque um term into another term:
Coloque the term's variable into the other term's variable.
Coloque the term's phrase into the other term's phrase.

Etapas necessárias para que se load um source file:
Se the source file for inexistente, cancele.
Load the source file's path into the source file's buffer.
Se the i/o error não estiver em branco, abort with "Não foi possível carregar o arquivo: '" then the source file's path then "'."; exit.
\Load the source file's path into um string.
\Se the i/o error não estiver em branco, abort with "Não foi possível carregar o arquivo '" then the source file's path then "'."; exit.
\Parse the string to the source file's buffer (portuguese contractions e synonyms rules).

Etapas necessárias para que se load some source files:
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um item from the compiler's directory.
Se the item não for found, pare.
Se the item's kind não for "file", repita.
Se the item's extension não estiver em branco, repita.
Se the item looks reamish, repita.
Adicione um source file to the source files usando the item's path.
Load the source file.
Repita.

The loading timer é um timer.

Etapas necessárias para que se parse um string to another string (portuguese contractions e synonyms rules):
Limpe the other string.
Limpe um third string.
Lance um rider on the string.
Percorra.
Se the rider's source estiver em branco, cancele.
Position the rider's token on the rider's source.
Mova the rider (code rules).
Se the rider's token's first's target não for any glom pedaço, posponha the rider's token to the other string; repeat.
Posponha the rider's token to the other string giving the third string (portuguese contractions e synonyms rules).
Coloque the rider's token into the third string.
Repita.

Etapas necessárias para que se reduce some monikettes por utility use:
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Se the monikette's type for inexistente, repita.
Reduce the monikette's type to um type por utility use.
Se the type não for inexistente, coloque the type into the monikette's type.
Repita.

Etapas necessárias para que se reduce um type to another type por utility use:
Coloque the type into the other type.
Percorra.
Se the other type for inexistente, cancele.
Se the other type's name for "texto hexadecimal", cancele.
Se the other type's name for "string", cancele.
Se the other type's name for "número", cancele.
Se the other type's name for "endereço de memória", cancele.
Se the other type's name for "coisa", esvazie the other type; exit.
\PAL
\Se the other type's name for "elemento", esvazie the other type; exit.
Se the other type's base type é the other type, esvazie the other type; exit.
Coloque the other type's base type into the other type.
Repita.

Etapas necessárias para que se catalogue novamente the utility index:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um bucket usando the utility index.
Se the bucket for inexistente, cancele.
Se the bucket's refers estiverem vazio, repita.
Catalogue novamente the utility index usando the bucket's refers.
Repita.

Etapas necessárias para que se catalogue novamente the utility index usando some refers:
Obtenha um refer from the refers.
Se the refer for inexistente, cancele.
Coloque the refer's endereço de memória into uma routine.
Se the routine for inexistente, abort with "Erro interno na função: index the utility routines usando some refers"; exit.
Copy the routine's monikettes into some monikettes.
Reduce the monikettes por utility use.
Catalogue the routine usando the monikettes e the routine index.
Destroy the monikettes.
Repita.

Etapas necessárias para que se remove any negatives from some monikettes returning um sinal:
Feche the sinal.
Swap the monikettes with some other monikettes.
Percorra.
Coloque the other monikettes' first into um monikette.
Se the monikette for inexistente, cancele.
Remove the monikette from the other monikettes.
\PAL
Se the monikette's string for "não", reverse the sinal; destroy the monikette; repeat.
Se the monikette's string for "nada", reverse the sinal; destroy the monikette; repeat.
\CAL
Se the monikette's string for "not", reverse the sinal; destroy the monikette; repeat.
Se the monikette's string for "nada", reverse the sinal; destroy the monikette; repeat.
Posponha the monikette to the monikettes.
Se the monikette's string for "can't", reverse the sinal; coloque "can" into the monikette's string; repeat.
Se the monikette's string for "cannot", reverse the sinal; coloque "can" into the monikette's string; repeat.
Se the monikette's string for "nothing", reverse the sinal; coloque "something" into the monikette's string; repeat.
Se the monikette's string for "won't", reverse the sinal; coloque "will" into the monikette's string; repeat.
Se the monikette's string ends with "n't", reverse the sinal; remove trailing pedaços from the monikette's string usando 3; repeat.
Repita.

The repeat tag é uma tag igual a 21.

Etapas necessárias para que se resolva um field:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the field for inexistente, cancele.
Resolva the field como uma variable.
Se the field's nickname não for any valid field name, limpe o field's nickname.
Se the field's name não for any valid field name, abort with "'" then the field's name then "' é um field name inválido." e the field's locus; exit.

Etapas necessárias para que se resolva um global:
Se the global for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the global's global body não estiver em branco, resolva the global (compile body).
Se the global's type name estiver em branco, abort with "Tipo inválido: '" then the global's name then "' . O tipo da variável global está vazio." e the global's locus; exit.
Resolva the global como uma variable.

Etapas necessárias para que se resolva um global (compile body):
Se the global for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Lance um rider on the global's global body.
Mova the rider (compiler rules).
Se the rider's token não for any literal, abort with "Erro de tipo. O tipo: '" then the rider's token then "' tem que ser do tipo literal." e the rider; exit.
Compile um literal usando the rider.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token não estiver em branco, abort with "Acho que era bom colocar um ponto por aqui, né?" e the rider; exit.
Se the global's type name estiver em branco, coloque the literal's type's name into the global's type name.
Coloque the literal into the global's literal.
Catalogue the literal.

Etapas necessárias para que se resolva some globals:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Resolva the global.
Repita.

Etapas necessárias para que se resolva um type (base type):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's base type não for inexistente, cancele.
Encontre the type's base type usando the type's base name e the type index.
Se the type's base type for inexistente, abort with "Base type inválido:'" then the type's base name then "'." e the type's locus; exit.
Abra the type's cooking sinal.
Se the type's base type's cooking sinal estiver verde, abort with "Definição recursiva com '" then the type's base name then "'." e the type's locus; exit.
Resolva the type's base type (base type).
Feche the type's cooking sinal.

Etapas necessárias para que se resolva um type (expand coisa): \ type's base type não for resolved yet
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's base type não for inexistente, cancele.
Se the type's name for "coisa", cancele.
\Se the type's name for "elemento", cancele.
Se the type não pode ser reduzido para "coisa" using the base name, cancele.
Encontre um base type usando the type's base name e the type index.
\  adicione coisa conjunto - the número of secret fields é hard coded in two places: search por "do que 4" \ was 6
Coloque the type's name then " conjunto" into um name.
Coloque the type's name then " conjuntos" into um plural name.
Coloque the base type's name then " conjunto" into um base name.
Adicione um conjunto type to the types usando the name e the plural name e the base name.
Adicione um field to the conjunto type's fields usando "next " then the type's name e "next" e the type's name e the on sinal.
\PAL
Adicione um portuguese field to the conjunto type's fields usando "seguinte " then the type's name e "seguinte" e the type's name e the on sinal.
Coloque "next " then the type's name into the portuguese field's redefinition target name.
\Adicione um portuguese reverse field to the conjunto type's fields usando the type's name then " seguinte" e "seguinte" e the type's name e the on sinal.
\Coloque "next " then the type's name into the portuguese reverse field's redefinition target name.
Adicione another field to the conjunto type's fields usando "previous " then the type's name e "previous" e the type's name e the on sinal.
\Adicione another portuguese field to the conjunto type's fields usando "anterior " then the type's name e "anterior" e the type's name e the on sinal.
\Coloque "previous " then the type's name into the other portuguese field's redefinition target name.
Adicione another portuguese reverse field to the conjunto type's fields usando the type's name then " anterior" e "anterior" e the type's name e the on sinal.
Coloque "previous " then the type's name into the other portuguese reverse field's redefinition target name.
Se the type's fields não estiverem vazio, posponha the type's fields to the conjunto type's fields.
Catalogue the conjunto type.
\ fix up original type to look like um endereço de memória
Coloque the conjunto type's name into the type's target name.
\ adicione chain type
Adicione um chain type to the types usando the type's plural name e "" e the base type's plural name.
Adicione um third field to the chain type's fields usando "first " then the type's name e "first" e the type's name e the on sinal.
Adicione um third portuguese field to the chain type's fields usando "primeiro " then the type's name e "primeiro" e the type's name e the on sinal.
Coloque "first " then the type's name into the third portuguese field's redefinition target name.
Adicione um third feminine portuguese field to the chain type's fields usando "primeira " then the type's name e "primeira" e the type's name e the on sinal.
Coloque "first " then the type's name into the third feminine portuguese field's redefinition target name.
Adicione um fourth field to the chain type's fields usando "last " then the type's name e "last" e the type's name e the on sinal.
Adicione um fourth portuguese field to the chain type's fields usando "último " then the type's name e "último" e the type's name e the on sinal.
Coloque "last " then the type's name into the fourth portuguese field's redefinition target name.
Adicione um fourth portuguese feminine field to the chain type's fields usando "última " then the type's name e "última" e the type's name e the on sinal.
Coloque "last " then the type's name into the fourth portuguese feminine field's redefinition target name.
Catalogue the chain type.

Etapas necessárias para que se resolva um type (registro de plurais):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's plural name estiver em branco, cancele.
Se the type pode ser reduzido para "coisa" using the base name, cancele.
Catalogue the type usando the type's plural name.

Etapas necessárias para que se resolva um type (optional info - endereço de memória):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type's target type não for inexistente, cancele.
Se the type's target name estiver em branco, coloque the type's base type's target type into the type's target type; exit.
Encontre the type's target type usando the type's target name e the type index.
Se the type's target type for inexistente, abort with "Não sei bem pra que coisa você está pointing at." e the type's locus; exit.

Etapas necessárias para que se resolva um type (optional info - conjunto):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type's fields estiverem vazio, copy the type's base type's fields into the type's fields; exit.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields (backwards).
Se the field for inexistente, pare.
Se the field é duplicated in the type's fields, abort with "O campo '" then the field's name then "' está definido mais de uma vez." e the field's locus; exit.
Resolva the field.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the field's type's cooking sinal estiver verde, abort with "Recursive definition no: '" then the field's type's name then "'." e the field's locus; exit.
Resolva the field's type (optional info). \ de novo
Se the field's reference sinal não estiver verde, repita.
Se the field's type não pode ser reduzido para "endereço de memória", abort with "Não entendi o parâmetro '(reference)' nesse campo '" then the field's name then "'..." e the field's locus; exit.
Repita.
Eliminate duplicate nicknames from the type's fields.
Se the type não pode ser reduzido para "coisa conjunto", cancele.
Se the type's fields' count for maior do que 4, cancele. \ already copied? was 2 por next e prev, now 6 to included Spanish redefiniions
Copy the type's base type's fields into the type's fields (data fields only).

Etapas necessárias para que se resolva um type (optional info - scale):
Se the compiler's sinal de alerta estiver presente, cancele.
Coloque the type's base type into um base type.
Se the type's scale for 0, coloque the type's base type's scale into the type's scale; exit.
Se the base type's scale for 0, cancele.
Multiplique the type's scale por the base type's scale.
Coloque the base type's base type into the type's base type.

Etapas necessárias para que se resolva um type (optional info):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's optional info resolved sinal estiver verde, cancele.
Se the type's base type é the type, cancele. \ por built in types
Check por invalid optional info on the type.
Abra the type's cooking sinal.
Resolva the type's base type (optional info).
Se the type pode ser reduzido para "endereço de memória", resolva the type (optional info - endereço de memória).
Se the type pode ser reduzido para "conjunto", resolva the type (optional info - conjunto). \ mudar aqui
Se the type pode ser reduzido para "número", resolva the type (optional info - scale).
Feche the type's cooking sinal.
Abra the type's optional info resolved sinal.

Etapas necessárias para que se resolva some types (base types):
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolva the type (base type).
Repita.

Etapas necessárias para que se resolva some types (expand coisas):
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolva the type (expand coisa).
Repita.

Etapas necessárias para que se resolva some types (registro de plurais):
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolva the type (registro de plurais).
Repita.

Etapas necessárias para que se resolva some types (optional info):
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolva the type (optional info).
Repita.

Etapas necessárias para que se resolva uma variable:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the variable for inexistente, cancele.
Se the variable's type não for inexistente, cancele.
Se the variable's type name não estiver em branco, resolva the variable (explicit type name); exit.
Encontre the variable's type e the variable's nickname usando the variable's name.
Se the variable's type não for inexistente, coloque the variable's type's name into the variable's type name; exit.
Abort with "Não achei o tipo da variável '" then the variable's name then "'." e the variable's locus.

Etapas necessárias para que se resolva uma variable (explicit type name):
Encontre the variable's type usando the variable's type name e the type index.
Se the variable's type for inexistente, abort with "Não achei o nome do tipo da variável '" then the variable's type name then "'." e the variable's locus; exit.

The resolving globals timer é um timer.

The resolving types timer é um timer.

Etapas necessárias para que se round up borough sizes:
Coloque the import borough's length into the import borough's size.
Round the import borough's size up to the nearest multiple of 4096.
Coloque the data borough's length into the data borough's size.
Round the data borough's size up to the nearest multiple of 4096.
Coloque the code borough's length into the code borough's size.
Round the code borough's size up to the nearest multiple of 4096.

The routine address tag é uma tag igual a 22.

An routine body é um substring.

An routine header é um substring.

The routine index é um index.

An routine é uma coisa with
An locus (reference),
An callback sinal,
An decider sinal,
An function sinal,
An compiled sinal,
An nickname index,
An moniker, some monikettes, some parameters, um parameter size,
An employs moniker,
Some locals, um local size,
An routine header, um header string,
An routine body, um body string,
Some fragments,
An address.

An routine reference é some monikettes.

The routines are some routines.

The save eax tag é uma tag igual a 20.

Etapas necessárias para que se examine any optional info por um type usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token for "to", examine any optional info por the type usando the rider (endereço de memória); exit.
Se the rider's token for "para", examine any optional info por the type usando the rider (endereço de memória); exit.
Se the rider's token é any with, examine any optional info por the type usando the rider (conjunto); exit.

Etapas necessárias para que se examine any optional info por um type usando um rider (endereço de memória):
Mova the rider (compiler rules).
Se the rider's token não for any indefinite article, abort with "A palavra 'to' precisa de um artigo indefinido depois dela, não de um '" then the rider's token then "'." e the rider; exit. 
Mova the rider (compiler rules).
Examine the type's target name usando the rider.

Etapas necessárias para que se examine any optional info por um type usando um rider (conjunto):
Mova the rider (compiler rules).
Examine the type's fields usando the rider.

Etapas necessárias para que se examine any pauses usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token não for any pause, cancele.
Mova the rider (compiler rules).
Repita.

Etapas necessárias para que se examine um field usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Examine the field usando the rider (type part).
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token é any called, examine the field usando the rider (called part); repeat.
Se the rider's token for "at", examine the field usando the rider (redefine part); repeat.
Se the rider's token for "em", examine the field usando the rider (redefine part); repeat.
Se the rider's token for "redefinindo", examine the field usando the rider (redefine part); repeat.
Se the rider's token é any reference, examine the field usando the rider (reference part); repeat.

Etapas necessárias para que se examine um field usando um rider (called part):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Se the field's type name estiver em branco, coloque the field's name into the field's type name. \ pedaço array type name already filled in
Examine the field's name usando the rider.

Etapas necessárias para que se examine um field usando um rider (redefine part):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Se the rider's token não for any definite article, abort with "Eu estava esperando o artigo 'the', mas o que encontrei foi '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Examine the field's redefinition target name usando the rider.

Etapas necessárias para que se examine um field usando um rider (reference part):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Abra the field's reference sinal.

Etapas necessárias para que se examine um field usando um rider (type part - pedaço array):
Se the compiler's sinal de alerta estiver presente, cancele.
Convert the rider's token to um ratio.
Reduce the ratio.
Se the ratio's denominator não for 1, abort with "Você tem que especificar um número completo de pedaços para um pedaço array" e the rider; exit.
Coloque the ratio's numerator into the field's count.
Mova the rider (compiler rules).
Se the rider's token não for "pedaço" ou "pedaços", abort with "Você precisa usar a palavra 'pedaços' depois de um counted field designator." e the rider; exit.
Mova the rider (compiler rules).
Coloque "pedaço" into the field's type name.

Etapas necessárias para que se examine um field usando um rider (type part - normal):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token não for any indefinite article, abort with "Falta por um artigo idefinido aqui, mas você colocou isso: '" then the rider's token then "'." e the rider; exit.
Se the rider's token for "another", coloque "other" into the field's name.
\PAL
Se the rider's token for "outra", coloque "segunda" into the field's name.
Se the rider's token for "outro", coloque "segundo" into the field's name.
Mova the rider (compiler rules).
Examine um name usando the rider.
Extend the field's name with the name.

Etapas necessárias para que se examine um field usando um rider (type part):
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token é any numeric literal, examine the field usando the rider (type part - pedaço array); exit.
Examine the field usando the rider (type part - normal).

Etapas necessárias para que se examine some fields usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione um field to the fields usando "field" e the rider's token's first.
Examine the field usando the rider.
Se the rider's token não for any pause, cancele.
Examine any pauses usando the rider.
Repita.

Etapas necessárias para que se examine um global body usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Coloque the rider's token's first into the global body's first.
Coloque -1 into the global body's last.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Se the rider's token é the colon pedaço, cancele.
Se the rider's token é the period pedaço, cancele.
Coloque the rider's token's last into the global body's last.
Mova the rider (compiler rules).
Repita.

Etapas necessárias para que se examine um global usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione the global to the globals usando "global" e the rider's token's first.
Mova the rider (compiler rules).
Examine the global's name usando the rider.
Se the rider's token é any has, examine the global usando the rider (has ou have); exit.
Se the rider's token não for any is, abort with "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Se the rider's token não for any indefinite article, examine the global usando the rider (literal term); exit.
Mova the rider (compiler rules).
Examine the global's type name usando the rider.  
Se the rider's token é the start of any optional info, examine the global usando the rider (optional info); exit.
Se the rider's token for any operador de atribuição, examine the global usando the rider (data part); exit.
Se the rider's token não for the period pedaço, abort with "Toda definição precisa terminar com um ponto. Inclusive essa." e the rider; exit. 
Mova the rider (compiler rules).
Catalogue the global.

Etapas necessárias para que se examine um global usando um rider (data part):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Se the rider's token não for any to, abort with "Depois da palavra 'equal' você precisa por um palavra  'to'. Você colocou ; '" then the rider's token then "'." e the rider; exit. 
Mova the rider (compiler rules).
Examine the global's global body usando the rider.
Se the rider's token não for the period pedaço, abort with "Falta terminar um frase com um ponto." e the rider; exit. 
Mova the rider (compiler rules).
Catalogue the global.

Etapas necessárias para que se examine um global usando um rider (has ou have):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Coloque "~inline " then the global's name then " type" into um name.
Coloque the name then "s" into um plural name.
Adicione um type to the types usando the name e the plural name e "conjunto" e the global's locus. \mudar aqui
Catalogue the type.
Coloque the type's name into the global's type name.
Examine the type's fields usando the rider.
Se the rider's token não for the period pedaço, abort with "Aprenda a escrever direito. Cadê o ponto?." e the rider; exit. 
Mova the rider (compiler rules).
Catalogue the global.

Etapas necessárias para que se examine um global usando um rider (literal term):
Se the compiler's sinal de alerta estiver presente, cancele.
Examine the global's global body usando the rider.
Se the rider's token não for the period pedaço, abort with "Aprenda a escrever corretamente. Cadê o ponto?." e the rider; exit. 
Mova the rider (compiler rules).
Catalogue the global.

Etapas necessárias para que se examine um global usando um rider (optional info):
Se the compiler's sinal de alerta estiver presente, cancele.
Coloque "~inline " then the global's name then " type" into um name.
Coloque the name then "s" into um plural name.
Adicione um type to the types usando the name e the plural name e the global's type name e the global's locus.
Catalogue the type.
Coloque the type's name into the global's type name.
Examine any optional info por the type usando the rider.
Se the rider's token não for the period pedaço, abort with "Tá na hora de aprender a escrever direito. Cadê o ponto?." e the rider; exit. 
Mova the rider (compiler rules).
Catalogue the global.

Etapas necessárias para que se examine um name usando um rider:
Limpe the name.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider está on any name starter, extend the name with the rider's token; mova the rider (compiler rules).
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider está on any name ender, pare.
Extend the name with the rider's token.
Mova the rider (compiler rules).
Repita.
Se the name estiver em branco, abort with "Acho que faltou colocar um nome por aqui. Você escreveu '" then the rider's token then "'." e the rider; exit.

Etapas necessárias para que se examine uma routine body usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Se the rider's token é the start of any definition, cancele.
Coloque the rider's token's first into the routine body's first.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Coloque the rider's token's last into the routine body's last.
Se the rider's token é the colon pedaço, abort with "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e the rider; exit.
Se the rider's token não for the period pedaço, mova the rider (compiler rules); repeat.
Mova the rider (compiler rules).
Se the rider's token é the start of any definition, cancele.
Repita.

Etapas necessárias para que se examine uma routine usando um rider:  \ Define o cabeçalho de rotina.
Se the compiler's sinal de alerta estiver presente, cancele.
Adicione the routine to the routines usando the rider's token's first.
Mova the rider (compiler rules). \ skip the "Passos" e obtenha the next token
Se the rider's token for "necessários" ou "necessárias", mova the rider (compiler rules). 
Se the rider's token não for "para", abort with "Você precisa escrever 'para' antes de '" then the rider's token then "' nesse tipo de rotina." e the rider; exit.
Mova the rider (compiler rules). \ skip the "para" e obtenha the next token
Se the rider's token for "que", mova the rider (compiler rules). 
\Se the rider's token não for "que", abort with "Você precisa colocar um 'que' antes da palavra '" then the rider's token then "'." e the rider; exit.
\Mova the rider (compiler rules). \ skip the "que" e obtenha the next token
Se the rider's token for "se", mova the rider (compiler rules). 
\Se the rider's token não for "se", abort with "Você precisa colocar um 'se' antes da palavra '" then the rider's token then "'." e the rider; exit.
\Mova the rider (compiler rules).  \ skip the "se" e obtenha the next token
Examine the routine's routine header usando the rider.
Se the rider's token é the semi-colon pedaço, examine the routine usando the rider (alternate wording); exit.  \ *** por alternate wordings
Se the rider's token não for the colon pedaço, abort with "O nome dessa função está escrito errado.." e the routine's locus; exit.
Mova the rider (compiler rules).
Examine the routine's routine body usando the rider.

Etapas necessárias para que se examine uma routine usando um rider (alternate wording):  \ *** por alternate wordings
Privatize the rider.
Mova the rider (compiler rules).
Se the rider's token não for the start of any routine, abort with "Esse ponto e vírgula tá no lugar errado." e the original rider; exit.
Coloque the original rider's token's first into the routine's routine body's first.
Coloque the original rider's token's last into the routine's routine body's last.
Mova the original rider (compiler rules).

Etapas necessárias para que se examine uma routine header usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Coloque the rider's token's first into the routine header's first.
Coloque -1 into the routine header's last.
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Se the rider's token é the semi-colon pedaço, cancele. \ *** alternate wordings
Se the rider's token é the colon pedaço, cancele.
Se the rider's token é the period pedaço, cancele.
Coloque the rider's token's last into the routine header's last.
Mova the rider (compiler rules).
Repita.

Etapas necessárias para que se examine um source file:
Se the source file for inexistente, cancele.
Se the compiler's sinal de alerta estiver presente, cancele.
Lance um rider on the source file's buffer.
Mova the rider (compiler rules).
Percorra.
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token estiver em branco, cancele.
Se the rider's token é the start of any type, examine um type usando the rider; repeat.
Se the rider's token é the start of any global, examine um global usando the rider; repeat.
Se the rider's token é the start of any routine, examine uma routine usando the rider; repeat.
Abort with "Faltou definir melhor o que é o '" then the rider's token then "'." e the rider.
Repita.

Etapas necessárias para que se examine some source files:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um source file from the source files.
Se the source file for inexistente, cancele.
Examine the source file.
Repita.

Etapas necessárias para que se examine um type usando um rider:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the rider's token é any portuguese indefinite article, abra um portuguese sinal.
Se the rider's token é any english indefinite article, abra um english sinal.
Adicione the type to the types usando the rider's token's first.
Mova the rider (compiler rules).
Examine the type's name usando the rider.
Coloque the type's name into the type's plural name.
Se the portuguese sinal estiver verde, pluralize the type's plural name (portuguese rules).
Se the english sinal estiver verde, pluralize the type's plural name (english rules).
Se the english sinal não estiver verde, pluralize the type's plural name (portuguese rules).
Se the rider's token é any has, examine the type usando the rider (has ou have); exit.
Se the rider's token não for any is, abort with "Eu esperava um 'is' ou um 'are', mas só achei um : '" then the rider's token then "'." e the rider; exit.
\Pluralize the type's plural name.
\Se the rider's token for "has" ou "have", examine the type usando the rider (has ou have); exit.
\Se the rider's token não for "is" ou "are", abort with "I was expecting um 'is' ou 'are', but I found '" then the rider's token then "'." e the rider; exit.

Mova the rider (compiler rules).
Se the rider's token é any numeric literal, examine the type usando the rider (unit of measure); exit.
Se the rider's token não for any indefinite article, abort with "Faltou um artigo indefinido, lembra? '" then the rider's token then "'." e the rider; exit. 
Mova the rider (compiler rules).
Examine the type's base name usando the rider.
Examine any optional info por the type usando the rider.
Se the rider's token não for the period pedaço, abort with "Você precisa usar um ponto para definir um tipo, lembra? Você usou '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Catalogue the type.

Etapas necessárias para que se examine um type usando um rider (has ou have):
Se the compiler's sinal de alerta estiver presente, cancele.
Mova the rider (compiler rules).
Coloque "conjunto" into the type's base name. \\mudar aqui
Examine the type's fields usando the rider.
Se the rider's token não for the period pedaço, abort with "Ao invés de usar o ponto para definir  tipo, você usou '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Catalogue the type.

Etapas necessárias para que se examine um type usando um rider (unit of measure):
Se the compiler's sinal de alerta estiver presente, cancele.
Convert the rider's token to the type's scale.
Se the type's scale for 0, abort with "Zero é um tipo de escala inválido." e the type's locus; exit.
Mova the rider (compiler rules).
Examine the type's base name usando the rider.
Se the rider's token não for the period pedaço, abort with "Os tipos precisam terminar com um ponto, não com '" then the rider's token then "'." e the rider; exit.
Mova the rider (compiler rules).
Catalogue the type.

The scanning timer é um timer.

An scratch é um local.

Etapas necessárias para que se scrub um index:
Obtenha um bucket usando the index.
Se the bucket for inexistente, cancele.
Se the bucket's refers estiverem vazio, repita.
Scrub the bucket's refers.
Repita.

Etapas necessárias para que se scrub some refers:
Swap the refers with some other refers.
Percorra.
Coloque the other refers' first into um refer.
Se the refer for inexistente, cancele.
Remove the refer from the other refers.
Se the refer's endereço de memória for inexistente, destroy the refer; repeat.
Posponha the refer to the refers.
Repita.

Etapas necessárias para que se abra the compiled sinal in uma variable:
Se the variable for inexistente, cancele.
Se the variable's compiled sinal estiver verde, cancele.
Abra the variable's compiled sinal.
Se the variable's kind não for "global", cancele.
Se the variable's literal for inexistente, cancele.
Encontre uma routine usando "coloque" e the variable's literal's type e "into" e the variable's type.
Se the routine for inexistente, encontre the routine usando "convert" e the variable's literal's type e "to" e the variable's type; abra um sinal.
Se the routine for inexistente, abort with "O tipo dessa variável global e desse literal não são compatíveis." e the variable's locus; exit.
Compile the body of the routine.
Se the sinal estiver verde, coloque "convert the " then the variable's literal's name then " to the " then the variable's name then ". " into the variable's initializer string.
Se the sinal não estiver verde, coloque "coloque the " then the variable's literal's name then " into the " then the variable's name then ". " into the variable's initializer string.

Etapas necessárias para que se skip to the next word in um substring:
Se the substring estiver em branco, cancele.
Se the substring's first's target é noise, pare.
Adicione 1 to the substring's first.
Repita.
Skip any leading noise in the substring.

Etapas necessárias para que se skip to the previous word in um substring:
Se the substring estiver em branco, cancele.
Se the substring's last's target é noise, pare.
Subtraia 1 from the substring's last.
Repita.
Skip any trailing noise in the substring.

An source file é uma coisa with um path e um buffer.

The source files are some source files.

An tag é um número.

An term é um conjunto with uma variable e um phrase.

Etapas necessárias para que se transmogrify um fragment:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the fragment for inexistente, cancele.
Se the fragment's tag é the push address tag, transmogrify the fragment (push address); exit.
Se the fragment's tag é the call internal tag, transmogrify the fragment (call internal); exit.
Se the fragment's tag é the load address tag, transmogrify the fragment (load address); exit.
Se the fragment's tag é the increment tag, transmogrify the fragment (increment); exit.
Se the fragment's tag é the dereference tag, transmogrify the fragment (dereference); exit.
Se the fragment's tag é the jump false tag, transmogrify the fragment (jump false); exit.
Se the fragment's tag é the not tag, transmogrify the fragment (not); exit.
Se the fragment's tag é the exit tag, transmogrify the fragment (exit); exit.
Se the fragment's tag é the repeat tag, transmogrify the fragment (repeat); exit.
Se the fragment's tag é the break tag, transmogrify the fragment (break); exit.
Se the fragment's tag é the prolog tag, transmogrify the fragment (prolog); exit.
Se the fragment's tag é the epilog tag, transmogrify the fragment (epilog); exit.
Se the fragment's tag é the push value tag, transmogrify the fragment (push value); exit.
Se the fragment's tag é the call external tag, transmogrify the fragment (call external); exit.
Se the fragment's tag é the load eax tag, transmogrify the fragment (load eax); exit.
Se the fragment's tag é the save eax tag, transmogrify the fragment (save eax); exit.
Se the fragment's tag é the call indirect tag, transmogrify the fragment (call indirect); exit.
Se the fragment's tag é the routine address tag, transmogrify the fragment (routine address); exit.

Etapas necessárias para que se transmogrify um fragment (break):
Coloque the repeat tag into uma tag.
Encontre another fragment usando the fragment e the tag.
Se the other fragment for inexistente, coloque the finalize tag into the tag. \ por break sem um loop ou after um loop
Encontre um third fragment usando the current routine's fragments' last e the tag (backwards).
Se the third fragment for inexistente, abort with "Erro interno - transmogrify um fragment (break)"; exit.
Se the third fragment's next for inexistente, abort with "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 e the third fragment's next's address to the fragment. \ JMP the destination's address

Etapas necessárias para que se transmogrify um fragment (call external):
Attach $FF15 e the fragment's entry's address to the fragment's code. \ call [the fragment's entry's address]

Etapas necessárias para que se transmogrify um fragment (call indirect):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Attach $FF12 to the fragment's code. \ call [edx]

Etapas necessárias para que se transmogrify um fragment (call internal):
Obtenha um address usando the fragment's routine.
Attach $E8 e the address to the fragment. \ call the fragment's routine's address

Etapas necessárias para que se transmogrify um fragment (dereference):
Attach $8B95 e the fragment's variable's offset to the fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
Attach $8B12 to the fragment's code. \ mov edx,[edx]
Attach $8995 e the fragment's variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

Etapas necessárias para que se transmogrify um fragment (epilog):
Se the current routine's callback sinal estiver verde, attach $5F5E5B to the fragment's code. \ pop edi, esi, ebx
Attach $8BE5 to the fragment's code. \ mov esp,ebp
Attach $5D to the fragment's code. \ pop ebp
Attach $C2 e the current routine's parameter size to the fragment's code. \ ret the current routine's parameter size

Etapas necessárias para que se transmogrify um fragment (exit):
Encontre another fragment usando the fragment e the finalize tag.
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 e the other fragment's address to the fragment. \ jmp the destination's address

Etapas necessárias para que se transmogrify um fragment (increment):
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (increment)"; exit.
Se the fragment's variable's kind não for "scratch", abort with "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 e the fragment's variable's offset e the fragment's número to the fragment's code. \ adicione [ebp+the fragment's variable's offset],the fragment's número

Etapas necessárias para que se transmogrify um fragment (jump false):
Encontre another fragment usando the fragment e the end if tag.
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 to the fragment's code. \ cmp eax,0
Attach $0F84 e the other fragment's address to the fragment. \ je the destination's address

Etapas necessárias para que se transmogrify um fragment (load address):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Attach $8995 e the fragment's other variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

\Etapas necessárias para que se transmogrify um fragment (load eax):
\Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
\Se the fragment's variable for inexistente, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type for inexistente, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type's length não for 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (load eax):
Attach $B8 e the fragment's sinal to the fragment's code. \ mov eax,sinal
\Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
\Se the fragment's variable for inexistente, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type for inexistente, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type's length não for 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (not):
Attach $83F001 to the fragment's code. \ xor eax,1

Etapas necessárias para que se transmogrify um fragment (prolog):
Attach $55 to the fragment's code. \ push ebp
Attach $8BEC to the fragment's code. \ mov ebp,esp
Coloque the current routine's local size dividido por 4 into um número.
Se the número não for 0, attach $B9 e the número e $6A004975FB to the fragment's code. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
Se the current routine's callback sinal estiver verde, attach $535657 to the fragment's code. \ push ebx, esi, edi

Etapas necessárias para que se transmogrify um fragment (push address):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Attach $52 to the fragment's code. \ push edx

Etapas necessárias para que se transmogrify um fragment (push value):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Coloque the fragment's variable's type's length into um length.
Se the length for 4, attach $FF32 to the fragment's code; exit. \ push [edx]
Se the length for 2, attach $66FF32 to the fragment's code; exit. \ push word ptr [edx]
Se the length for 1, attach $0FB61252 to the fragment's code; exit. \ movzxb edx,[edx]; push edx
Abort with "Erro interno 3 - transmogrify um fragment (push value)".

Etapas necessárias para que se transmogrify um fragment (repeat):
Encontre another fragment usando the fragment e the loop tag (backwards).
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 e the other fragment's address to the fragment. \ jmp the destination's address

Etapas necessárias para que se transmogrify um fragment (routine address):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Se the fragment's routine for inexistente, abort with "Erro interno - transmogrify um fragment (routine address)"; exit.
Obtenha um address usando the fragment's routine.
Attach $C702 e the address to the fragment's code. \ mov [edx],the address

Etapas necessárias para que se transmogrify um fragment (save eax):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (save eax)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Coloque the fragment's variable's type's length into um length.
Se the length for 4, attach $8902 to the fragment's code; exit. \ mov [edx],eax
Se the length for 2, attach $668902 to the fragment's code; exit. \ mov [edx],ax
Se the length for 1, attach $8802 to the fragment's code; exit. \ mov [edx],al
Abort with "Erro interno 3 - transmogrify um fragment (save eax)".

Etapas necessárias para que se transmogrify some fragments:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Transmogrify the fragment.
Repita.

Etapas necessárias para que se transmogrify uma routine:
Se the compiler's sinal de alerta estiver presente, cancele.
Se the routine for inexistente, cancele.
Se the routine's employs moniker não estiver em branco, cancele.
Se the routine's compiled sinal não estiver verde, cancele.
Coloque the routine into the current routine.
Transmogrify the routine's fragments.

Etapas necessárias para que se transmogrify some routines:
Se the compiler's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, pare.
Transmogrify the routine.
Repita.

The transmogrifying timer é um timer.

The type index é um index.

An type é uma coisa with
An locus (reference),
An name, um plural name,
An partial moniker,
An length,
An base name, um base type (reference),
An target name, um target type (reference) [endereço de memórias only],
An scale ratio,
Some fields [records only],
An cooking sinal,
An optional info resolved sinal.

An type name é um name.

The types are some types.

The utility index é um index.

An variable é uma coisa with
An locus (reference),
An kind [literal, global, local, parameter, scratch],
An compiled sinal,
An name, um nickname, um type name,
An type (reference), \ actual type on literal, global, local; dereferenced type on parameters e scratches
An address [globals e literals only] ou 
An offset at the address [locals, parameters, e fields only],
An count [fields only],
An reference sinal [fields only],
An redefinition target name [fields only],
An by-value sinal [parameters only],
An global body [globals only],
An initializer string [globals only],
An literal (reference) [globals only - constant with which to initalize the global],
An texto hexadecimal called data [literals only].

The writing timer é um timer.

Etapas necessárias para que se skip any trailing noise in um substring:
Se the substring estiver em branco, cancele.
Se the substring's last's target não for noise, cancele.
Subtraia 1 from the substring's last.
Repita.

\ dahn - reverse functions
\ to coloque the xxx uv a/the yyy into zzz
\ internally we vire this into "to coloque a/the yyy's xxx into zzz"
Etapas necessárias para que se compile the header of uma routine usando um rider (reverse-possessive function):
Se the compiler's sinal de alerta estiver presente, cancele.
Abra the routine's function sinal.
Adicione um monikette to the routine's monikettes usando "coloque".
Mova the rider (compiler rules). \ skip "coloque" ou "poner"
Mova the rider (compiler rules). \ skip "the" ou Portuguese definite article
Examine um name usando the rider. \ field name
Mova the rider (compiler rules). \ skip "uv" ou "de"
Se the rider's token é any indefinite article, abra um sinal.
Se the sinal estiver verde, compile the routine's monikettes e the routine's parameters usando the rider (indefinite article).
Se the sinal não estiver verde, compile the routine's monikettes e the routine's parameters usando the rider (definite article).
Adicione another monikette to the routine's monikettes usando "'s " then the name.
Se the rider's token não for any reverse-possessive function into, abort with "Esperava a palavra 'em', mas encontrei '" then the rider's token then "'." e the rider; exit.
Adicione um third monikette to the routine's monikettes usando "into".
Convert the routine's monikettes to um moniker.
Se the moniker estiver in the routine index, abort with "Já sei como '" then the moniker then "'." e the routine's locus; exit.
Catalogue the routine usando the routine's monikettes e the routine index.
Mova the rider (compiler rules).
Se the rider's token não for any indefinite article, abort with "Esperava um artigo indefinido, mas encontrei '" then the rider's token then "'." e the rider; exit.
Compile the routine's monikettes e the routine's parameters usando the rider (indefinite article).
Se the rider's token não estiver em branco, abort with "Existem outras coisas no final desta função." e the rider; exit.
Convert the routine's monikettes to the routine's moniker.
Catalogue the routine usando the routine's monikettes e the routine index. \ por employs

\ dahn - reverse functions
\ to coloque the xxx uv a/the yyy into zzz
Etapas necessárias para que se determine se um rider é the start of any reverse-possessive function:
Se the compiler's sinal de alerta estiver verde, diga não.
Se the rider's token não for any coloque, diga não.
Privatize the rider.
Mova the rider (compiler rules).
Se the rider's token não for any definite article, diga não.
Mova the rider (compiler rules).
Examine um name usando the rider.
Se the rider não for on any reverse-possessive, diga não.
Diga sim.
\finalmente