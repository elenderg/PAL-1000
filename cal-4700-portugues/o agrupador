\ the compilador (el compilador) copyright © 2006-2021 the osmosian order

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

An mensagem de erro é um string.

Etapas necessárias para que se abort with um string:
Se the compilador's sinal de alerta estiver presente, cancele.
Abra the compilador's sinal de alerta.
Coloque the string into the compilador's mensagem de erro.

Etapas necessárias para que se abort with um string e um pedaço endereço de memória:
Se the compilador's sinal de alerta estiver presente, cancele.
Abra the compilador's sinal de alerta.
Coloque the string into the compilador's mensagem de erro.
Encontre the compilador's abort path e the compilador's abort row# usando the pedaço endereço de memória.
Se the compilador's abort path estiver em branco, cancele.
Extract um file name from the compilador's abort path.
Anteponha "Erro no " then the file name then ". " to the compilador's mensagem de erro.

Etapas necessárias para que se abort with um string e um percorredor:
Se the percorredor's token não estiver em branco, abort with the string e the percorredor's token's first; exit.
Abort with the string e the percorredor's source's last.

Etapas necessárias para que se adicione the allocate e deallocate e finalize e destroy routines:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Adicione the finalize routine por the type.
Adicione the allocate routine por the type.
Adicione the deallocate routine por the type.
Adicione the destroy routine por the type.
Repita.

Etapas necessárias para que se adicione the allocate routine por um type:
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type não puder ser reduzido para "endereço de memória", cancele.
Se the type's target type for inexistente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "allocate memory por um " then the type's name to the routine's header string. \ traduzir aqui
Posponha "assign the " then the type's name then " usando " to the routine's body string.
Posponha the type's target type's length then "." to the routine's body string.
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione e compile the initialize before run e run e finalize after run routine:
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "~initialize before run e run e finalize after run" to the routine's header string.
Posponha "initialize before run. " to the routine's body string.
Posponha the global initializers to the routine's body string.
Posponha "nosso programa seja executado. " to the routine's body string. \ traduzir
Posponha the global finalizers to the routine's body string.
Posponha "finalize after run. " to the routine's body string.
Posponha "call ""kernel32.dll"" ""ExitProcess"" with 0. " to the routine's body string.
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.
Compile the body of the routine.

Etapas necessárias para que se adicione the built-in types:
Adicione um built-in type usando "byte" e "bytes" e 1.
Adicione another built-in type usando "record" e "records" e 0.
Adicione um third built-in type usando "pedaço" e "pedaços" e 1.
Adicione um fourth built-in type usando "conjunto" e "conjuntos" e 0.

Etapas necessárias para que se adicione um built-in type usando um name e um plural name e um length:
Adicione the built-in type to the types usando the name e the plural name e the name.
Coloque the length into the built-in type's length.
Coloque the built-in type into the built-in type's base type.
Catalogue the built-in type.

Etapas necessárias para que se adicione the deallocate routine por um type:
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type não puder ser reduzido para "endereço de memória", cancele.
Se the type's target type for inexistente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "deallocate um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then " for inexistente, cancele. " to the routine's body string.
Se the type's target type deveria ser [estar] finalizado, posponha "~finalize the " then the type's name then "'s target. " to the routine's body string.
Posponha "unassign the " then the type's name then "." to the routine's body string.
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the destroy routine por um type:
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type não deveria ser ignorado, cancele.
Se the type puder ser reduzido para "coisas", adicione the destroy routine por the type (coisas); exit.
Se the type puder ser reduzido para "endereço de memória", adicione the destroy routine por the type (endereço de memória); exit.

Etapas necessárias para que se adicione the destroy routine por um type (endereço de memória):
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Coloque "destroy [" then the type's name then "]" into um moniker.
Se the moniker estiver in the routine index, cancele.
Adicione uma routine to the routines usando nil.
Posponha "destroy um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then " for inexistente, cancele. " to the routine's body string.
Se the type's target type puder ser reduzido para "endereço de memória", posponha "destroy the " then the type's name then "'s target. " to the routine's body string.
Se the type's target type puder ser reduzido para "coisas", posponha "destroy the " then the type's name then "'s target. " to the routine's body string.
Percorra.
Obtenha um field from the type's target type's fields.
Se the field for inexistente, pare.
Se the field's reference sinal estiver verde, repita.
Se the field's type não deveria ser ignorado, repita.
Posponha "destroy the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repita.
Posponha "deallocate the " then the type's name then ". " to the routine's body string. \ traduzir aqui
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the destroy routine por um type (coisas):
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Coloque "Erro interno na hora de executar a tarefa de destruição de tipos"  into a reply.
Se the type's fields' first for inexistente, abort with "Erro interno  na rotina 'adicione um forget routine por um type (coisas)'"; [Say the reply;] exit. \Adicionado Say the reply
Se the type's fields' first's type for inexistente, abort with "Erro interno 2 na rotina 'adicione the forget routine por um type (coisas)'"; exit.
Coloque "destroy [" then the type's name then "]" into um moniker.
Se the moniker estiver in the routine index, cancele.
Adicione uma routine to the routines usando nil.
Posponha "destroy um " then the type's name to the routine's header string.
Posponha "if the " then the type's name then "'s first for inexistente, cancele. " to the routine's body string.
Coloque the type's fields' first's type's name into um name.
Posponha "coloque the " then the type's name then "'s first into um " then the name then ". " to the routine's body string.
Posponha "remove the " then the name then " from the " then the type's name then ". " to the routine's body string.
Posponha "destroy the " then the name then ". " to the routine's body string.
Posponha "repeat. " to the routine's body string.
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione um entry to alguns imports usando um import name e um entry name:
Encontre um import usando the import name.
Se the import for inexistente, adicione the import to the imports usando the import name.
Encontre the entry usando the entry name e the import's entries.
Se the entry não for inexistente, cancele.
Crie the entry.
Posponha the entry to the import's entries.
Coloque the entry name into the entry's name.

Etapas necessárias para que se adicione um field to alguns fields usando um name e um nickname e um type name e um reference sinal:
Adicione the field to the fields usando "field" e nil.
Coloque the name into the field's name.
Coloque the nickname into the field's nickname.
Coloque the type name into the field's type name.
Coloque the reference sinal into the field's reference sinal.

Etapas necessárias para que se adicione the finalize routine por um type:
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type não deveria ser finalizado, cancele.
Se the type's name for "string", adicione the finalize routine por the type (string); exit.
Se the type puder ser reduzido para "string", cancele. \ prevents generation of finalizer por derived string types
Adicione the finalize routine por the type (conjunto).

Etapas necessárias para que se adicione the finalize routine por um type (conjunto):
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "~finalize um " then the type's name to the routine's header string.
Posponha "intel $50. " to the routine's body string. \ push eax
Percorra.
Obtenha um field from the type's fields.
Se the field for inexistente, pare.
Se the field's type não deveria ser finalizado, repita.
Posponha "~finalize the " then the type's name then "'s " then the field's name then ". " to the routine's body string.
Repita.
Posponha "intel $58." to the routine's body string. \ pop eax
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione the finalize routine por um type (string):
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione uma routine to the routines usando nil.
Posponha "~finalize um " then the type's name to the routine's header string.
Posponha "intel $50. " to the routine's body string. \ push eax
Posponha "unassign the string's first. " to the routine's body string.
Posponha "intel $58." to the routine's body string. \ pop eax
Lance the routine's routine header on the routine's header string.
Lance the routine's routine body on the routine's body string.
Compile the header of the routine.

Etapas necessárias para que se adicione um fragment usando uma tag:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.

Etapas necessárias para que se adicione um fragment usando uma tag e um entry:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the entry into the fragment's entry.

Etapas necessárias para que se adicione um fragment usando uma tag e um sinal:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the sinal into the fragment's sinal.

Etapas necessárias para que se adicione um fragment usando uma tag e uma routine:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the routine into the fragment's routine.
Compile the body of the routine.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the variable into the fragment's variable.
Abra the compiled sinal in the variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e another variable:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the variable into the fragment's variable.
Coloque the other variable into the fragment's other variable.
Abra the compiled sinal in the variable.
Abra the compiled sinal in the other variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e um número:
Se the current routine for inexistente, esvazie the fragment; exit.
Crie the fragment usando the tag.
Posponha the fragment to the current routine's fragments.
Coloque the variable into the fragment's variable.
Coloque the número into the fragment's número.
Abra the compiled sinal in the variable.

Etapas necessárias para que se adicione um import to alguns imports usando um import name:
Crie the import.
Posponha the import to the imports.
Coloque the import name into the import's name.

Etapas necessárias para que se adicione um intermediate usando um type name e um locus:
Se the current routine for inexistente, esvazie the intermediate; exit.
Adicione the intermediate to the current routine's locals usando "local" e the locus.
Gere the intermediate's name usando "~I".
Coloque the type name into the intermediate's type name.
Resolva the intermediate.

Etapas necessárias para que se adicione um literal to alguns variables usando um locus:
Adicione the literal como uma variable to the variables usando "literal" e the locus.
Gere the literal's name usando "~L".

Etapas necessárias para que se adicione um monikette to alguns monikettes usando um expression:
Crie the monikette.
Posponha the monikette to the monikettes.
Coloque the expression's phrase into the monikette's string.
Coloque the expression's variable into the monikette's variable.
Se the expression's variable não for inexistente, coloque the expression's type into the monikette's type.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette to alguns monikettes usando um string:
Crie the monikette.
Posponha the monikette to the monikettes.
\PAL
\\ conjunctions
Se the string for "e", coloque "e" into the monikette's string; exit. \ and
Se the string for "ou", coloque "or" into the monikette's string; exit. \ or
\ from/given/with/using
Se the string for "desde", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "a partir de", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "partindo de", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "de", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "dada", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "dado", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "dadas", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "dados", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "com", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "usando", coloque "from/given/with/using" into the monikette's string; exit.
\\ in/into/to
Se the string for "em", coloque "in/into/to" into the monikette's string; exit.
Se the string for "a", coloque "in/into/to" into the monikette's string; exit.
\\ is/are
Se the string for "é", coloque "is/are" into the monikette's string; exit.
Se the string for "está", coloque "is/are" into the monikette's string; exit.
Se the string for "for", coloque "is/are" into the monikette's string; exit. 
Se the string for "foi", coloque "is/are" into the monikette's string; exit. 
Se the string for "foram", coloque "is/are" into the monikette's string; exit. 
Se the string for "forem", coloque "is/are" into the monikette's string; exit. 
Se the string for "estiver", coloque "is/are" into the monikette's string; exit.
Se the string for "estiverem", coloque "is/are" into the monikette's string; exit.
\Se the string for "tem", coloque "is/are" into the monikette's string; exit.
\Se the string for "tiver", coloque "is/are" into the monikette's string; exit.
Se the string for "are", coloque "is/are" into the monikette's string; exit.
Se the string for "são", coloque "is/are" into the monikette's string; exit.
Se the string for "estão", coloque "is/are" into the monikette's string; exit.
Se the string for "is", coloque "is/are" into the monikette's string; exit.
Se the string for "forem", coloque "is/are" into the monikette's string; exit.
Se the string for "estiverem", coloque "is/are" into the monikette's string; exit.
Se the string for "puder", coloque "pode" into the monikette's string; exit.
Se the string for "puderem", coloque "pode" into the monikette's string; exit.
Se the string for "existir", coloque "existe" into the monikette's string; exit.
\Se the string for "decide", coloque "decidir" into the monikette's string; exit.
\Se the string for "decidiu", coloque "decidir" into the monikette's string; exit.
\Se the string for "decidindo", coloque "decidir" into the monikette's string; exit. \melhor não por gerúndio ou verbos compostos
\Se the string for "decidiu-se", coloque "decidir" into the monikette's string; exit.
Se the string for "existir", coloque "existe" into the monikette's string; exit.
\\ allocates e destroys
\Se the string for "alojar", coloque "allocate" into the monikette's string; exit.
Se the string for "aloje", coloque "allocate" into the monikette's string; exit.
\Se the string for "alocar", coloque "allocate" into the monikette's string; exit.
Se the string for "aloque", coloque "allocate" into the monikette's string; exit.
\Se the string for "reservar", coloque "allocate" into the monikette's string; exit.
Se the string for "reserve", coloque "allocate" into the monikette's string; exit.
Se the string for "memória", coloque "memory" into the monikette's string; exit.
\Se the string for "for", coloque "por" into the monikette's string; exit. \\servia pra converter o "for" para "por"
Se the string for "pelo", coloque "por the" into the monikette's string; exit. 
Se the string for "pela", coloque "por the" into the monikette's string; exit. 
\Se the string for "desalocar", coloque "deallocate" into the monikette's string; exit.
Se the string for "desaloque", coloque "deallocate" into the monikette's string; exit.
\Se the string for "desalojar", coloque "deallocate" into the monikette's string; exit.
Se the string for "desaloje", coloque "deallocate" into the monikette's string; exit.
\Se the string for "esvaziar", coloque "deallocate" into the monikette's string; exit.
\Se the string for "esvazie", coloque "deallocate" into the monikette's string; exit.
Se the string for "destruir", coloque "destroy" into the monikette's string; exit.
\CAL
\\ from/given/with/using
Se the string for "from", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "given", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "with", coloque "from/given/with/using" into the monikette's string; exit.
Se the string for "using", coloque "from/given/with/using" into the monikette's string; exit.
\ in/into/to
Se the string for "in", coloque "in/into/to" into the monikette's string; exit.
Se the string for "into", coloque "in/into/to" into the monikette's string; exit.
Se the string for "to", coloque "in/into/to" into the monikette's string; exit.
\ is/are
Se the string for "are", coloque "is/are" into the monikette's string; exit.
Se the string for "is", coloque "is/are" into the monikette's string; exit.
\ aren't/isn't
Se the string for "isn't", coloque "is/aren't" into the monikette's string; exit.
Se the string for "aren't", coloque "is/aren't" into the monikette's string; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se the string for "backward", coloque "backward" into the monikette's string; exit.
Se the string for "backwards", coloque "backward" into the monikette's string; exit.
Se the string for "counterclockwise", coloque "backward" into the monikette's string; exit.
Se the string for "counter-clockwise", coloque "backward" into the monikette's string; exit.
Se the string for "anticlockwise", coloque "backward" into the monikette's string; exit.
Se the string for "anti-clockwise", coloque "backward" into the monikette's string; exit.
\ at/on
Se the string for "at", coloque "at/on" into the monikette's string; exit.
Se the string for "on", coloque "at/on" into the monikette's string; exit.
\ other
Coloque the string into the monikette's string.

Etapas necessárias para que se adicione um monikette to alguns monikettes usando um type:
Crie the monikette.
Posponha the monikette to the monikettes. 
Coloque the type into the monikette's type.

Etapas necessárias para que se adicione push fragments usando alguns monikettes:
Se the current routine for inexistente, cancele.
Percorra.
Obtenha um monikette from the monikettes (backwards).
Se the monikette for inexistente, cancele.
Se the monikette's variable for inexistente, repita.
Se the monikette's current substring não estiver em branco, repita.
Se the monikette's current type for inexistente, repita.
Adicione um fragment usando the push address tag e the monikette's variable.
Repita.

Etapas necessárias para que se adicione the coloque ou convert fragments usando uma variable e another variable e um locus:
Adicione um fragment usando the push address tag e the other variable.
Adicione another fragment usando the push address tag e the variable.
Encontre uma routine usando "coloque" e the variable's type e "into" e the other variable's type.
Se the routine for inexistente, encontre the routine usando "convert" e the variable's type e "to" e the other variable's type.
Se the routine não for inexistente, adicione um third fragment usando the call internal tag e the routine; exit.
\ error message
Adicione um monikette to alguns monikettes usando "coloque/convert".
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando "into/to".
Adicione um fourth monikette to the monikettes usando the other variable's type.
Convert the monikettes to um moniker.
Destroy the monikettes.
Abort with "Eu não sei como '" then the moniker then "'." e the locus.

Etapas necessárias para que se adicione uma routine to alguns routines usando um locus:
Crie the routine.
Posponha the routine to the routines.
Coloque the locus into the routine's locus.

Etapas necessárias para que se adicione um scratch usando um type name e um locus:
Se the current routine for inexistente, esvazie the scratch; exit.
Adicione the scratch to the current routine's locals usando "scratch" e the locus.
Gere the scratch's name usando "~S".
Coloque the type name into the scratch's type name.
Resolva the scratch.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um locus:
Adicione um fragment usando the push address tag e the other variable.
Adicione another fragment usando the push address tag e the variable.
Adicione um monikette to alguns monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other variable's type.
Encontre uma routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the locus; exit.
Adicione um third fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um third string e um third variable e um pedaço endereço de memória:
Adicione um fragment usando the push address tag e the third variable.
Adicione another fragment usando the push address tag e the other variable.
Adicione um third fragment usando the push address tag e the variable.
Adicione um monikette to alguns monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other variable's type.
Adicione um fifth monikette to the monikettes usando the third string.
Adicione um sixth monikette to the monikettes usando the third variable's type.
Encontre uma routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the pedaço endereço de memória; exit.
Adicione um fourth fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione um source file to alguns source files usando um path:
Crie the source file.
Posponha the source file to the source files.
Coloque the path into the source file's path.

Etapas necessárias para que se adicione two fragments usando um string e uma variable e um locus:
Adicione um fragment usando the push address tag e the variable.
Adicione um monikette to alguns monikettes usando the string.
Adicione another monikette to the monikettes usando the variable's type.
Encontre uma routine usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Eu não sei como '" then the moniker then "'." e the locus; exit.
Adicione another fragment usando the call internal tag e the routine.

Etapas necessárias para que se adicione um type to alguns types usando um locus:
Crie the type.
Posponha the type to the types.
Coloque the locus into the type's locus.

Etapas necessárias para que se adicione um type to alguns types usando um name e um plural name e um base name:
Adicione the type to the types usando the name e the plural name e the base name e nil.

Etapas necessárias para que se adicione um type to alguns types usando um name e um plural name e um base name e um locus:
Crie the type.
Posponha the type to the types.
Coloque the locus into the type's locus.
Coloque the name into the type's name.
Coloque the plural name into the type's plural name.
Coloque the base name into the type's base name.

Etapas necessárias para que se adicione uma variable to alguns variables usando um kind e um locus:
Crie the variable usando the kind.
Posponha the variable to the variables.
Coloque the locus into the variable's locus.

The adding built-in memory routines timer é um timer.

The adding built-in startup routine timer é um timer.

Etapas necessárias para que se address alguns entries:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
Address the entry.
Repita.

Etapas necessárias para que se address um entry:
Coloque the current name address into the entry's name address.
Coloque the entry's name's length plus 3 into um número.
Round the número up to the nearest multiple of 2.
Adicione the número to the current name address.
Coloque the current thunk address into the entry's thunk address.
Coloque the image base plus the current thunk address into the entry's address.
Adicione 4 to the current thunk address.

Etapas necessárias para que se address um fragment usando um address:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the fragment for inexistente, cancele.
Coloque the image base plus the address into the fragment's address.
Se the fragment's tag for the push address tag, adicione 7 to the address; exit.
Se the fragment's tag for the call internal tag, adicione 5 to the address; exit.
Se the fragment's tag for the load address tag, adicione 12 to the address; exit.
Se the fragment's tag for the increment tag, adicione 10 to the address; exit.
Se the fragment's tag for the dereference tag, adicione 14 to the address; exit.
Se the fragment's tag for the jump false tag, adicione 9 to the address; exit.
Se the fragment's tag for the not tag, adicione 3 to the address; exit.
Se the fragment's tag for the exit tag, adicione 5 to the address; exit.
Se the fragment's tag for the repeat tag, adicione 5 to the address; exit.
Se the fragment's tag for the break tag, adicione 5 to the address; exit.
Se the fragment's tag for the prolog tag, address the fragment usando the address (prolog); exit.
Se the fragment's tag for the epilog tag, address the fragment usando the address (epilog); exit.
Se the fragment's tag for the intel tag, adicione the fragment's code's length to the address; exit.
Se the fragment's tag for the push value tag, address the fragment usando the address (push value); exit.
Se the fragment's tag for the call external tag, adicione 6 to the address; exit.
Se the fragment's tag for the load eax tag, adicione 5 to the address; exit. \ was 8 when "load eax" took in variables; now "load eax" only does um immediate value
Se the fragment's tag for the save eax tag, address the fragment usando the address (save eax); exit.
Se the fragment's tag for the call indirect tag, adicione 8 to the address; exit.
Se the fragment's tag for the routine address tag, adicione 12 to the address; exit.

Etapas necessárias para que se address um fragment usando um address (epilog):
Se the current routine's callback sinal estiver verde, adicione 3 to the address.
Adicione 6 to the address.

Etapas necessárias para que se address um fragment usando um address (prolog):
Adicione 3 to the address.
Se the current routine's local size não for 0, adicione 10 to the address.
Se the current routine's callback sinal estiver verde, adicione 3 to the address.

Etapas necessárias para que se address um fragment usando um address (push value):
Adicione 6 to the address.
Se the fragment's variable for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Coloque the fragment's variable's type's length into um length.
Se the length for 4, adicione 2 to the address; exit.
Se the length for 2, adicione 3 to the address; exit.
Se the length for 1, adicione 4 to the address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address um fragment usando um address (save eax):
Adicione 6 to the address.
Se the fragment's variable for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Coloque the fragment's variable's type's length into um length.
Se the length for 4, adicione 2 to the address; exit.
Se the length for 2, adicione 3 to the address; exit.
Se the length for 1, adicione 2 to the address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address alguns fragments usando um address:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Address the fragment usando the address.
Repita.

Etapas necessárias para que se address um import:
Coloque the current name address into the import's name address.
Coloque the current header address into the import's header address.
Coloque the current name address into the import's import header's name memory address.
Coloque the import's name's length plus 1 into um número.
Round the número up to the nearest multiple of 2.
Adicione the número to the current name address.
Adicione um import header's magnitude to the current header address.
Coloque the current thunk address into the import's import header's first thunk memory address.
Address the import's entries.
Adicione 4 to the current thunk address.

Etapas necessárias para que se address alguns imports usando um address:
Coloque the address into the current header address.
Coloque the imports' count into um count.
Adicione 1 to the count.
Multiplique the count por um import header's magnitude.
Coloque the address plus the count into the current thunk address.
Obtenha another count usando the imports (all entries plus markers).
Multiplique the other count por 4.
Coloque the current thunk address plus the other count into the current name address.
Percorra.
Obtenha um import from the imports.
Se the import for inexistente, pare.
Address the import.
Repita.
Coloque the current name address minus the address into um número.
Adicione the número to the address.

An address é um número.

Etapas necessárias para que se address uma routine usando um address:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the routine for inexistente, cancele.
Se the routine's employs moniker não estiver em branco, cancele. \ employs are addressed later
Se the routine's compiled sinal não estiver verde, cancele.
Coloque the routine into the current routine.
Coloque the image base plus the address into the routine's address.
Address the routine's fragments usando the address.
Round the address up to the nearest multiple of 4.

Etapas necessárias para que se address alguns routines usando um address:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, pare.
Address the routine usando the address.
Repita.

Etapas necessárias para que se address uma variable usando um address:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the variable for inexistente, cancele.
Se the variable's compiled sinal não estiver verde, cancele.
Coloque the image base plus the address into the variable's address.
Adicione the variable's type's length to the address.
Se the variable's type puder ser reduzido para "string", adicione the variable's data's length plus 1 to the address.
Round the address up to the nearest multiple of 4.

Etapas necessárias para que se address alguns variables usando um address:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha uma variable from the variables.
Se the variable for inexistente, cancele.
Address the variable usando the address.
Repita.

The addressing timer é um timer.

Etapas necessárias para que se advance um buffer:
Posponha the return pedaço to the buffer.
Posponha the linefeed pedaço to the buffer.

Etapas necessárias para que se advance um buffer (twice):
Advance the buffer. 
Advance the buffer.

Etapas necessárias para que se posponha um entry to um buffer (with separator):
Se the entry for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the entry's name to the buffer (with separator).

Etapas necessárias para que se posponha um sinal to um buffer (with separator):
Convert the sinal to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha the global finalizers to um string:
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Se the global's compiled sinal não estiver verde, repita.
Se the global's type não deveria ser finalizado, repita.
Posponha "~finalize the " then the global's name then ". " to the string.
Repita.

Etapas necessárias para que se posponha the global initializers to um string:
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Se the global's literal for inexistente, repita.
Se the global's compiled sinal não estiver verde, repita.
Feche um sinal.
Posponha the global's initializer string to the string.
Repita.

Etapas necessárias para que se posponha um monikette to um moniker:
Se the monikette for inexistente, cancele.
Se the moniker não estiver em branco, posponha the space pedaço to the moniker.
Se the monikette's type não for inexistente, posponha "[" e the monikette's type's name e "]" to the moniker (fast); exit.
Se the monikette's string não estiver em branco, posponha the monikette's string to the moniker; exit.

Etapas necessárias para que se posponha um monikette to um moniker (while bubbling):
Se the monikette for inexistente, cancele.
Se the moniker não estiver em branco, posponha the space pedaço to the moniker.
Se the monikette's current substring não estiver em branco, posponha the monikette's current substring to the moniker; exit.
Se the monikette's current type não for inexistente, posponha "[" e the monikette's current type's name e "]" to the moniker (fast); exit.

Etapas necessárias para que se posponha um número to um buffer (as hex with separator):
Convert the número to um nibble string.
Posponha the nibble string to the buffer (with separator).

Etapas necessárias para que se posponha um número to um buffer (with separator):
Convert the número to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha um ratio to um buffer (with separator):
Convert the ratio to um string.
Posponha the string to the buffer (with separator).

Etapas necessárias para que se posponha uma routine to um buffer (with separator):
Se the routine for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the routine's moniker to the buffer (with separator).

Etapas necessárias para que se posponha um string e another string e um third string to um fourth string (fast):
Coloque the fourth string's length into um length.
Adicione the string's length to the length.
Adicione the other string's length to the length.
Adicione the third string's length to the length.
Reassign um endereço de memória usando the length.
Coloque the endereço de memória into um pedaço endereço de memória.
Copy pedaços from the fourth string's first to the pedaço endereço de memória por the fourth string's length.
Adicione the fourth string's length to the pedaço endereço de memória.
Copy pedaços from the string's first to the pedaço endereço de memória por the string's length.
Adicione the string's length to the pedaço endereço de memória.
Copy pedaços from the other string's first to the pedaço endereço de memória por the other string's length.
Adicione the other string's length to the pedaço endereço de memória.
Copy pedaços from the third string's first to the pedaço endereço de memória por the third string's length.
Unassign the fourth string's first.
Coloque the endereço de memória into the fourth string's first.
Coloque the endereço de memória plus the length minus 1 into the fourth string's last.

Etapas necessárias para que se posponha um string to um buffer (with separator):
Posponha the string to the buffer.
Posponha "/" to the buffer.

Etapas necessárias para que se posponha uma tag to um buffer (as um fragment tag string with separator):
Se the tag for the break tag, posponha "break" to the buffer (with separator); exit.
Se the tag for the call external tag, posponha "call external" to the buffer (with separator); exit.
Se the tag for the call indirect tag, posponha "call indirect" to the buffer (with separator); exit.
Se the tag for the call internal tag, posponha "call internal" to the buffer (with separator); exit.
Se the tag for the dereference tag, posponha "dereference" to the buffer (with separator); exit.
Se the tag for the end if tag, posponha "end if" to the buffer (with separator); exit.
Se the tag for the epilog tag, posponha "epilog" to the buffer (with separator); exit.
Se the tag for the exit tag, posponha "exit" to the buffer (with separator); exit.
Se the tag for the finalize tag, posponha "finalize" to the buffer (with separator); exit.
Se the tag for the increment tag, posponha "increment" to the buffer (with separator); exit.
Se the tag for the intel tag, posponha "intel" to the buffer (with separator); exit.
Se the tag for the jump false tag, posponha "jump false" to the buffer (with separator); exit.
Se the tag for the load address tag, posponha "load address" to the buffer (with separator); exit.
Se the tag for the load eax tag, posponha "load eax" to the buffer (with separator); exit.
Se the tag for the loop tag, posponha "loop" to the buffer (with separator); exit.
Se the tag for the not tag, posponha "not" to the buffer (with separator); exit.
Se the tag for the prolog tag, posponha "prolog" to the buffer (with separator); exit.
Se the tag for the push address tag, posponha "push address" to the buffer (with separator); exit.
Se the tag for the push value tag, posponha "push value" to the buffer (with separator); exit.
Se the tag for the save eax tag, posponha "save eax" to the buffer (with separator); exit.
Se the tag for the repeat tag, posponha "repeat" to the buffer (with separator); exit.
Se the tag for the routine address tag, posponha "routine address" to the buffer (with separator); exit.
Posponha "?" to the buffer (with separator).

Etapas necessárias para que se posponha um type to um buffer (with separator):
Se the type for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the type's name to the buffer (with separator).

Etapas necessárias para que se posponha uma variable to um buffer (with separator):
Se the variable for inexistente, posponha "" to the buffer (with separator); exit.
Posponha the variable's name to the buffer (with separator).

Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules):
\# contrações
Se the string for "ao", posponha "para o" to the other string; exit.
Se the string for "à", posponha "para a" to the other string; exit.
Se the string for "aos", posponha "para os" to the other string; exit.
Se the string for "às", posponha "para as" to the other string; exit.
Se the string for "do", posponha "de o" to the other string; exit.
Se the string for "da", posponha "de a" to the other string; exit.
Se the string for "dos", posponha "de os" to the other string; exit.
Se the string for "das", posponha "de as" to the other string; exit.
Se the string for "dum", posponha "de um" to the other string; exit.
Se the string for "duma", posponha "de uma" to the other string; exit.
Se the string for "dumas", posponha "de umas" to the other string; exit.
Se the string for "duns", posponha "de uns" to the other string; exit.
Se the string for "daqui", posponha "de aqui" to the other string; exit.
Se the string for "dali", posponha "de ali" to the other string; exit.
Se the string for "dele", posponha "de ele" to the other string; exit.
Se the string for "dela", posponha "de ela" to the other string; exit.
Se the string for "desse", posponha "de esse" to the other string; exit.
Se the string for "dessa", posponha "de essa" to the other string; exit.
Se the string for "desses", posponha "de esses" to the other string; exit.
Se the string for "dessas", posponha "de essas" to the other string; exit.
Se the string for "deste", posponha "de este" to the other string; exit.
Se the string for "desta", posponha "de esta" to the other string; exit.
Se the string for "destes", posponha "de estes" to the other string; exit.
Se the string for "destas", posponha "de estas" to the other string; exit.
Se the string for "disso", posponha "de isso" to the other string; exit.
Se the string for "disto", posponha "de isto" to the other string; exit.
Se the string for "nesse", posponha "em esse" to the other string; exit.
Se the string for "nesses", posponha "em esses" to the other string; exit.
Se the string for "neste", posponha "em este" to the other string; exit.
Se the string for "nestes", posponha "em estes" to the other string; exit.
Se the string for "nisso", posponha "em isso" to the other string; exit.
Se the string for "nisto", posponha "em isto" to the other string; exit.
Se the string for "nessa", posponha "em essa" to the other string; exit.
Se the string for "nessas", posponha "em essas" to the other string; exit.
Se the string for "nesta", posponha "em esta" to the other string; exit.
Se the string for "nestas", posponha "em estas" to the other string; exit.
Se the string for "donde", posponha "de onde" to the other string; exit.
Se the string for "dentre", posponha "de entre" to the other string; exit.
Se the string for "dantes", posponha "de antes" to the other string; exit.
Se the string for "dalguém", posponha "de alguém" to the other string; exit.
Se the string for "dalgum", posponha "de algum" to the other string; exit.
Se the string for "dalguma", posponha "de alguma" to the other string; exit.
Se the string for "dalguns", posponha "de alguns" to the other string; exit.
Se the string for "dalgumas", posponha "de algumas" to the other string; exit.
Se the string for "nalgum", posponha "em algum" to the other string; exit.
Se the string for "nalguma", posponha "em alguma" to the other string; exit.
Se the string for "nalguns", posponha "em alguns" to the other string; exit.
Se the string for "nalgumas", posponha "em algumas" to the other string; exit.
Se the string for "doutro", posponha "de outro" to the other string; exit.
Se the string for "doutra", posponha "de outra" to the other string; exit.
Se the string for "doutros", posponha "de outros" to the other string; exit.
Se the string for "doutras", posponha "de outras" to the other string; exit.
Se the string for "noutro", posponha "em outro" to the other string; exit.
Se the string for "noutra", posponha "em outra" to the other string; exit.
Se the string for "noutros", posponha "em outros" to the other string; exit.
Se the string for "noutras", posponha "em outras" to the other string; exit.
\# "no" pode ser uma negação em inglês.
Se the string for any contraction giving the third string (portuguese rules - "no"), posponha "em o" to the other string; exit.
Se the string for "na", posponha "em a" to the other string; exit.
Se the string for "nos", posponha "em os" to the other string; exit.
Se the string for "nas", posponha "em as" to the other string; exit.
\Se the string for "noutro", posponha "em outro" to the other string; exit.
\Se the string for "noutra", posponha "em outra" to the other string; exit.
\Se the string for "noutros", posponha "em outros" to the other string; exit.
\Se the string for "noutras", posponha "em outras" to the other string; exit.
Se the string for "num", posponha "em um" to the other string; exit.
Se the string for "numa", posponha "em uma" to the other string; exit.
Se the string for "nuns", posponha "em uns" to the other string; exit.
Se the string for "numas", posponha "em umas" to the other string; exit.
Se the string for "pelo", posponha "por o" to the other string; exit.
Se the string for "pela", posponha "por a" to the other string; exit.
Se the string for "pelos", posponha "por os" to the other string; exit.
Se the string for "pelas", posponha "por as" to the other string; exit.
\# sinônimos
Se the string for "adir", posponha "adicionar" to the other string; exit.
Se the string for "agregar", posponha "adicionar" to the other string; exit.
Se the string for "acrescentar", posponha "adicionar" to the other string; exit.
Se the string for "somar", posponha "adicionar" to the other string; exit.
Se the string for "começar", posponha "iniciar" to the other string; exit.
Se the string for "terminar", posponha "finalizar" to the other string; exit.
Se the string for "acabar", posponha "finalizar" to the other string; exit.
Se the string for "completar", posponha "finalizar" to the other string; exit.
Se the string for "colocar", posponha "pôr" to the other string; exit.
Se the string for "mudar", posponha "alterar" to the other string; exit.
Se the string for "limpar", posponha "apagar" to the other string; exit.
Se the string for "ampliar", posponha "aumentar" to the other string; exit.
Se the string for "expandir", posponha "aumentar" to the other string; exit.
Se the string for "alargar", posponha "aumentar" to the other string; exit.
Se the string for "dilatar", posponha "aumentar" to the other string; exit.
Se the string for "estender", posponha "aumentar" to the other string; exit.
Se the string for "prolongar", posponha "aumentar" to the other string; exit.
Se the string for "ampliar", posponha "aumentar" to the other string; exit.
Se the string for "achar", posponha "encontrar" to the other string; exit.
Se the string for "descobrir", posponha "encontrar" to the other string; exit.
Se the string for "buscar", posponha "encontrar" to the other string; exit.
Se the string for "manusear", posponha "manejar" to the other string; exit.
Se the string for "manipular", posponha "manejar" to the other string; exit.
Se the string for "enumerar", posponha "listar" to the other string; exit.
Se the string for "elencar", posponha "listar" to the other string; exit.
Se the string for "selecionar", posponha "escolher" to the other string; exit.
Se the string for "eliminar", posponha "remover" to the other string; exit.
Se the string for "excluir", posponha "remover" to the other string; exit.
Se the string for "retirar", posponha "remover" to the other string; exit.
Se the string for "rodar", posponha "girar" to the other string; exit.
Se the string for "começar", posponha "iniciar" to the other string; exit.
Se the string for "permutar", posponha "trocar" to the other string; exit.
Se the string for "esperar", posponha "aguardar" to the other string; exit.
Se the string for "rascunhar", posponha "esboçar" to the other string; exit.
Se the string for "antepor", posponha "prepor" to the other string; exit.
Posponha the string to the other string.

Etapas necessárias para que se attach address loading code to um texto hexadecimal usando uma variable: \ loads into edx
Se the variable for inexistente, attach $C7C200000000 to the texto hexadecimal; exit. \ mov edx,0
Se the variable's kind for "global", attach $C7C2 e the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
Se the variable's kind for "literal", attach $C7C2 e the variable's address to the texto hexadecimal; exit. \ mov edx,the variable's address
Se the variable's kind for "local", attach $8D95 e the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Se the variable's kind for "scratch", attach $8B95 e the variable's offset to the texto hexadecimal; exit. \ mov edx,[ebp+the variable's offset]
Se the variable's kind não for "parameter", abort with "Erro interno - attach address loading code to um texto hexadecimal usando uma variable"; exit.
Se the variable's by-value sinal estiver verde, attach $8D95 e the variable's offset to the texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Attach $8B95 e the variable's offset to the texto hexadecimal. \ mov edx,[ebp+the variable's offset]

Etapas necessárias para que se attach um texto hexadecimal e um address to um fragment: \ call ou jump
Coloque the address into um número.
Subtraia the fragment's address from the número.
Subtraia the fragment's code's length from the número.
Subtraia the texto hexadecimal's length from the número.
Subtraia 4 from the número.
Attach the texto hexadecimal e the número to the fragment's code.

Etapas necessárias para que se attach um texto hexadecimal e um número e another texto hexadecimal to um third texto hexadecimal:
Posponha the texto hexadecimal to the third texto hexadecimal.
Convert the número to um fourth texto hexadecimal.
Posponha the fourth texto hexadecimal to the third texto hexadecimal.
Posponha the other texto hexadecimal to the third texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um número e another número to another texto hexadecimal:
Posponha the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Posponha the third texto hexadecimal to the other texto hexadecimal.
Convert the other número to um fourth texto hexadecimal.
Posponha the fourth texto hexadecimal to the other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um sinal to another texto hexadecimal;
Etapas necessárias para que se attach um texto hexadecimal e um número to another texto hexadecimal:
Posponha the texto hexadecimal to the other texto hexadecimal.
Convert the número to um third texto hexadecimal.
Posponha the third texto hexadecimal to the other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal to another texto hexadecimal: employ posponha um string to another string.

Etapas necessárias para que se blurt pedaços usando um endereço de memória e um length e um buffer e um offset:
Coloque the buffer's first plus the offset into another endereço de memória.
Copy pedaços from the endereço de memória to the other endereço de memória por the length.

Etapas necessárias para que se blurt um dos header into um buffer:
Blurt pedaços usando the dos header's whereabouts e the dos header's magnitude e the buffer e 0.

Etapas necessárias para que se blurt alguns entries into um buffer:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
Blurt the entry into the buffer.
Repita.

Etapas necessárias para que se blurt um entry into um buffer:
Blurt pedaços usando the entry's name address's whereabouts e 4 e the buffer e the entry's thunk address.
Coloque the entry's name address plus 2 into um address.
Blurt the entry's name into the buffer at the address.

Etapas necessárias para que se blurt um fragment into um buffer:
Se the fragment's code estiver em branco, cancele.
Coloque the fragment's address minus the image base into um address.
Blurt the fragment's code into the buffer at the address.

Etapas necessárias para que se blurt alguns fragments into um buffer:
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Blurt the fragment into the buffer.
Repita.

Etapas necessárias para que se blurt um import into um buffer:
Blurt pedaços usando the import's import header's whereabouts e the import's import header's magnitude e the buffer e the import's header address.
Blurt the import's name into the buffer at the import's name address.
Blurt the import's entries into the buffer.

Etapas necessárias para que se blurt alguns imports into um buffer:
Obtenha um import from the imports.
Se the import for inexistente, cancele.
Blurt the import into the buffer.
Repita.

Etapas necessárias para que se blurt um pe header into um buffer:
Blurt pedaços usando the pe header's whereabouts e the pe header's magnitude e the buffer e 256.

Etapas necessárias para que se blurt uma routine into um buffer:
Se the routine's compiled sinal não estiver verde, cancele.
Blurt the routine's fragments into the buffer.

Etapas necessárias para que se blurt alguns routines into um buffer:
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Blurt the routine into the buffer.
Repita.

Etapas necessárias para que se blurt um string into um buffer at um address:
Blurt pedaços usando the string's first e the string's length e the buffer e the address.

Etapas necessárias para que se blurt uma variable into um buffer:
Se the variable's compiled sinal não estiver verde, cancele.
Se the variable's type puder ser reduzido para "string", blurt the variable into the buffer (as um string); exit.
Coloque the variable's address minus the image base into um address.
Blurt the variable's data into the buffer at the address.

Etapas necessárias para que se blurt uma variable into um buffer (as um string):
Coloque the variable's address minus the image base into um address.
Coloque the variable's data's length into um length.
Coloque the address into another address.
Adicione um prototype string's magnitude to the other address.
Adicione the image base to the other address.
Coloque 0 into the prototype string's first.
Coloque -1 into the prototype string's last.
Se the length não for 0, coloque the other address into the prototype string's first.
Se the length não for 0, coloque the prototype string's first plus the length minus 1 into the prototype string's last.
Blurt pedaços usando the prototype string's whereabouts e the prototype string's magnitude e the buffer e the address.
Adicione the prototype string's magnitude to the address.
Blurt the variable's data into the buffer at the address.

Etapas necessárias para que se blurt alguns variables into um buffer:
Obtenha uma variable from the variables.
Se the variable for inexistente, cancele.
Blurt the variable into the buffer.
Repita.

An borough é um conjunto with um base address, um length e um size.

The break tag é uma tag igual a 1.

Etapas necessárias para que se bubble um monikette:
Se the monikette for inexistente, cancele.
Se the monikette's current substring não estiver em branco, limpe o monikette's current substring; exit.
Se the monikette's current type for inexistente, cancele.
Se the monikette's current type for any built-in type, coloque nil into the monikette's current type; exit.
Coloque the monikette's current type's base type into the monikette's current type.

An built-in type é um type.

Etapas necessárias para que se calculate the length of um type:
Se the type for inexistente, cancele.
Se the type's length não for -1, cancele.
Calculate the length of the type's base type.
Se the type's fields estiverem vazio, coloque the type's base type's length into the type's length; exit.
Coloque 0 into the type's length.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name não estiver em branco, repita.
Calculate the length of the field's type.
Adicione the field's type's length times the field's count to the type's length.
Repita.

Etapas necessárias para que se calculate the lengths of alguns types:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the length of the type.
Repita.

Etapas necessárias para que se calculate the offsets in um type:
Se the type for inexistente, cancele.
Coloque 0 into um offset.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name não estiver em branco, repita.
Coloque the offset into the field's offset.
Adicione the field's type's length times the field's count to the offset.
Repita.

Etapas necessárias para que se calculate the offsets in alguns types:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the offsets in the type.
Repita.

Etapas necessárias para que se calculate the redefinition offsets in um type:
Se the type for inexistente, cancele.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, cancele.
Se the field's redefinition target name estiver em branco, repita.
Encontre another field usando the field's redefinition target name e the type's fields.
Se the other field for inexistente, abort with "Redefine inválido. Eu não consigo encontrar o campo '" then the field's redefinition target name then "' field." e the field's locus; exit.
Coloque the other field's offset into the field's offset.
Repita.

Etapas necessárias para que se calculate the redefinition offsets in alguns types:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Calculate the redefinition offsets in the type.
Repita.

The calculating timer é um timer.

The call external tag é uma tag igual a 2.

The call indirect tag é uma tag igual a 3.

The call internal tag é uma tag igual a 4.

Etapas necessárias para que se check por invalid optional info on um type:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's target name não estiver em branco, check por invalid optional info on the type (target).
Se the type's fields não estiverem vazio, check por invalid optional info on the type (fields).
Se the type's scale não for 0, check por invalid optional info on the type (scale).

Etapas necessárias para que se check por invalid optional info on um type (fields):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type não puder ser reduzido para "conjunto", abort with "A palavra 'with' só é permitida em conjunto types." e the type's locus; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info on um type (scale):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type não puder ser reduzido para "número", abort with "Escalas são permitidas apenas em tipos numéricos." e the type's locus; exit.

Etapas necessárias para que se check por invalid optional info on um type (target):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type não puder ser reduzido para "endereço de memória", abort with "An palavra 'to' só é permitida em endereço de memória types." e the type's locus; exit.

Etapas necessárias para que se limpe um field term:
Fill pedaços with the null pedaço starting at the field term's whereabouts por the field term's magnitude.

Etapas necessárias para que se limpe um term:
Esvazie the term's variable.
Limpe the term's phrase.

The code borough é um borough.

Etapas necessárias para que se compile the bodies of the routines:
Compile the body of the routine called "initialize before run".
Compile the body of the routine called "nosso programa seja executado".
Compile the body of the routine called "finalize after run".

Etapas necessárias para que se compile the body of uma routine:
Se the routine for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the routine's compiled sinal estiver verde, cancele.
Abra the routine's compiled sinal.
Lance um percorredor on the routine's routine body.
Mova the percorredor (compilador rules).
Se the percorredor's token for the semi-colon pedaço, compile the body of the routine usando the percorredor (alternate wording); exit. \ *** alternate wording
Se the percorredor's token for any employ, compile the body of the routine usando the percorredor (employ); exit.
Coloque the current routine into um saved routine.
Coloque the routine into the current routine.
Crie the routine's nickname index usando 101.
Eliminate duplicate nicknames from the routine's parameters usando the routine's nickname index.
Compile the body of the routine (prolog).
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, pare.
Compile the next statement usando the percorredor.
Repita.
Compile the body of the routine (epilog).
Coloque the saved routine into the current routine.

Etapas necessárias para que se compile the body of uma routine (epilog):
Se the routine for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um fragment usando the finalize tag.
Percorra.
Obtenha uma variable from the routine's locals.
Se the variable for inexistente, pare.
Se the variable's kind for "scratch", repita.
Se the variable's type não deveria ser finalizado, repita.
Adicione another fragment usando the push address tag e the variable.
Encontre another routine usando "~finalize" e the variable's type.
Se the other routine for inexistente, abort with "Erro interno - compile the body of uma routine (epilog)"; exit.
Adicione um third fragment usando the call internal tag e the other routine.
Repita.
Adicione um fourth fragment usando the epilog tag.

Etapas necessárias para que se compile the body of uma routine (prolog):
Se the routine for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um fragment usando the prolog tag.
Adicione another fragment usando the loop tag.

Etapas necessárias para que se compile the body of the routine called um string:
Se the compilador's sinal de alerta estiver presente, cancele.
Encontre uma routine usando the string e the routine index.
Se the routine for inexistente, abort with "Eu preciso de uma função para fazer '" then the string then "'."; exit.
Compile the body of the routine.

Etapas necessárias para que se compile the body of uma routine usando um percorredor (alternate wording): \ *** alternate wording
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules). \ *** do we need this?
Coloque the routine's next into um target routine.
Se the target routine for inexistente, abort with "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e the percorredor; exit.
Coloque the target routine's moniker into the routine's employs moniker.
Compile the body of the target routine.

Etapas necessárias para que se compile the body of uma routine usando um percorredor (employ):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Compile uma routine reference usando the percorredor.
Convert the routine reference to the routine's employs moniker.
Destroy the routine reference.
Se the percorredor's token não for ".", abort with "Employ statments devem terminar com um ponto, não com '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Se the percorredor's token não estiver em branco, abort with "Somente um employ" e the percorredor; exit.
Encontre another routine usando the routine's employs moniker e the routine index.
Se the other routine for inexistente, abort with "Não consigo encontrar um rotina '" then the routine's employs moniker then "' que você está tentando empregar." e the routine's locus; exit.
Compile the body of the other routine.

Etapas necessárias para que se compile the call'd part usando um percorredor e uma variable:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the variable for inexistente, cancele.
Coloque the variable's name into the variable's type name.
Mova the percorredor (compilador rules).
Examine the variable's name usando the percorredor.

Etapas necessárias para que se compile um directory:
Compile the directory (start).
Compile the directory (load the source files).
Compile the directory (examine the source files).
Compile the directory (resolva the types).
Compile the directory (resolva the globals).
Compile the directory (compile the headers of the routines).
Compile the directory (calculate lengths e offsets of types).
Compile the directory (Adicione the built-in memory routines).
Compile the directory (catalogue the routines por utility use).
Compile the directory (compile the bodies of the routines).
Compile the directory (Adicione e compile the built-in startup routine).
Compile the directory (offset parameters e variables).
Compile the directory (address).
Compile the directory (transmogrify).
Compile the directory (link).
Compile the directory (write the exe).
Compile the directory (stop).

Etapas necessárias para que se compile um directory (Adicione e compile the built-in startup routine):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Adicionando e agrupando um tarefa de inicialização padrão...".
Start the adding built-in startup routine timer.
Adicione e compile the initialize before run e run e finalize after run routine.
Suspenda the adding built-in startup routine timer.

Etapas necessárias para que se compile um directory (Adicione the built-in memory routines):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Adicionando como tarefas predefinidas na memória...".
Start the adding built-in memory routines timer.
Adicione the allocate e deallocate e finalize e destroy routines.
Suspenda the adding built-in memory routines timer.

Etapas necessárias para que se compile um directory (address):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Obtendo endereço dos itens...".
Start the addressing timer.
Coloque 4096 into um address.
Coloque the address into the import borough's base.
Address the imports usando the address.
Coloque the address minus the import borough's base into the import borough's length.
Round the address up to the nearest multiple of 4096.
Coloque the address into the data borough's base.
Address the globals usando the address.
Address the literals usando the address.
Coloque the address minus the data borough's base into the data borough's length.
Round the address up to the nearest multiple of 4096.
Coloque the address into the code borough's base.
Address the routines usando the address.
Coloque the address minus the code borough's base into the code borough's length.
Suspenda the addressing timer.

Etapas necessárias para que se compile um directory (calculate lengths e offsets of types):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Calculando tamanhos e deslocamentos...".
Start the calculating timer.
Calculate the lengths of the types.
Calculate the offsets in the types.
Calculate the redefinition offsets in the types.
Suspenda the calculating timer.

Etapas necessárias para que se compile um directory (compile the bodies of the routines):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Agrupando o conteúdo das tarefas...".
Start the compiling routine bodies timer.
Compile the bodies of the routines.
Suspenda the compiling routine bodies timer.

Etapas necessárias para que se compile um directory (compile the headers of the routines):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Agrupando os nomes das tarefas...".
Start the compiling routine headers timer.
Compile the headers of the routines.
Suspenda the compiling routine headers  timer.

Etapas necessárias para que se compile um directory (catalogue the routines por utility use):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Catalogando tarefas...".
Start the indexing utilities timer.
Catalogue the routines por utility use.
Scrub the utility index.
Catalogue novamente the utility index.
Suspenda the indexing utilities timer.

Etapas necessárias para que se compile um directory (link):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Elencando arquivos..".
Start the linking timer.
Link.
Suspenda the linking timer.

Etapas necessárias para que se compile um directory (offset parameters e variables):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Deslocando parâmetros e variáveis...".
Start the offsetting timer.
Offset the parameters in the routines.
Offset the locals in the routines.
Suspenda the offsetting timer.

Etapas necessárias para que se compile um directory (load the source files):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Carregando arquivos...".
Start the loading timer.
Load the source files.
Suspenda the loading timer.

Etapas necessárias para que se compile um directory (resolva the globals):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Resolvendo itens de escopo abrangente...".
Start the resolving globals timer.
Resolva the globals.
Suspenda the resolving globals timer.

Etapas necessárias para que se compile um directory (resolva the types):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Resolvendo tipos...".
Start the resolving types timer.
Resolva the types (expand coisas).
Resolva the types (registro de plurais).
Resolva the types (base types).
Resolva the types (optional info).
Suspenda the resolving types timer.

Etapas necessárias para que se compile um directory (examine the source files):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Analisando arquivos...".
Start the scanning timer.
Examine the source files.
Suspenda the scanning timer.

Etapas necessárias para que se compile um directory (start):
Mostre status "Iniciando...".
Finalize the compilador.
Start the compilador's timer.
Initialize the compilador usando the directory.
Adicione the built-in types.

Etapas necessárias para que se compile um directory (stop):
Suspenda the compilador's timer.
Mostre status "Interrompendo".

Etapas necessárias para que se compile um directory (transmogrify):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Modificando...".
Start the transmogrifying timer.
Transmogrify the routines.
Suspenda the transmogrifying timer.

Etapas necessárias para que se compile um directory (write the exe):
Se the compilador's sinal de alerta estiver presente, cancele.
Mostre status "Gerando arquivo executável...".
Start the writing timer.
Escreva the compilador's exe to the compilador's exe path.
Se the i/o error não estiver em branco, abort with the i/o error.
Suspenda the writing timer.

Etapas necessárias para que se compile um expression usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Compile um term usando the percorredor.
Coloque the term into the expression.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token não for any operator, cancele.
Se the percorredor's token for any divided, compile the expression usando the percorredor (divided); repeat.
Se the percorredor's token for any minus, compile the expression usando the percorredor (minus); repeat.
Se the percorredor's token for any plus, compile the expression usando the percorredor (plus); repeat.
Se the percorredor's token for any then, compile the expression usando the percorredor (then); repeat.
Se the percorredor's token for any times, compile the expression usando the percorredor (times); repeat.

Etapas necessárias para que se compile um expression usando um percorredor (divided):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any by, abort with "Você deve usar o termo 'divided BY'." e the percorredor; exit.
Se the expression's variable for inexistente, abort with "Termo 'divided by' inválido, há um erro na variável: '" then the expression's phrase then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Compile um term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'divided by',está errado. Não dá pra dividir por '" then the term's phrase then "'." e the percorredor; exit.
Adicione um intermediate usando the expression's type name e the percorredor's token's first.
Adicione several fragments usando "coloque" e the expression's variable e "into" e the intermediate e the percorredor's token's first.
Adicione several fragments usando "divida" e the intermediate e "por" e the term's variable e the percorredor's token's first.
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile um expression usando um percorredor (minus):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "O seu 'minus', está errado. Não consigo subtrair o(a) '" then the expression's phrase then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Compile um term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'minus', está errado. Não consigo diminuir do(a) '" then the term's phrase then "'." e the percorredor; exit.
Adicione um intermediate usando the expression's type name e the percorredor's token's first.
Adicione several fragments usando "coloque" e the expression's variable e "into" e the intermediate e the percorredor's token's first.
Adicione several fragments usando "subtraia" e the term's variable e "from" e the intermediate e the percorredor's token's first.
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile um expression usando um percorredor (plus):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "O seu 'plus', está errado. Não consigo somar o '" then the expression's phrase then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Compile um term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'plus',  está errado. Não consigo somar um '" then the term's phrase then "'." e the percorredor; exit.
Adicione um intermediate usando the expression's type name e the percorredor's token's first.
Adicione several fragments usando "coloque" e the expression's variable e "into" e the intermediate e the percorredor's token's first. \aqui muda o coloque
Adicione several fragments usando "adicione" e the term's variable e "to" e the intermediate e the percorredor's token's first. \ aqui muda o add
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile um expression usando um percorredor (then):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "O seu 'then', está errado. Eu não entendi o que é o(a) '" then the expression's phrase then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Compile um term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'then', está errado. Eu não sei o que é o(a) '" then the term's phrase then "'." e the percorredor; exit.
Adicione um intermediate usando "string" e the percorredor's token's first.
Adicione the coloque ou convert fragments usando the expression's variable e the intermediate e the percorredor's token's first.
Convert the term por concatenation usando the percorredor.
Adicione several fragments usando "posponha" e the term's variable e "to" e the intermediate e the percorredor's token's first.
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile um expression usando um percorredor (times):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar o '" then the expression's phrase then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Compile um term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar um '" then the term's phrase then "'." e the percorredor; exit.
Adicione um intermediate usando the expression's type name e the percorredor's token's first.
Adicione several fragments usando "coloque" e the expression's variable e "into" e the intermediate e the percorredor's token's first.
Adicione several fragments usando "multiplique" e the intermediate e "por" e the term's variable e the percorredor's token's first.
Coloque the intermediate into the expression's variable.
Limpe the expression's phrase.

Etapas necessárias para que se compile the header of uma routine:
Se the routine for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Lance um percorredor on the routine's routine header.
Mova the percorredor (compilador rules).
Se the percorredor's token for any decide, compile the header of the routine usando the percorredor (decider); exit.
Se the percorredor for the start of any reverse-possessive function, compile the header of the routine usando the percorredor (reverse-possessive function); exit.
Se the percorredor for the start of any function, compile the header of the routine usando the percorredor (function); exit.
Se the percorredor's token for "compativelmente", compile the header of the routine usando the percorredor (callback); exit.
Compile the header of the routine usando the percorredor (procedure).

Etapas necessárias para que se compile the header of uma routine usando um percorredor (callback):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Abra the routine's callback sinal.
Compile the routine's monikettes e the routine's parameters usando the percorredor.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já tinha escrito um função '" then the routine's moniker then "'." e the routine's locus; exit.
Catalogue the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the header of uma routine usando um percorredor (decider):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any conditional, abort with "Erro na sintaxe do comando 'Para que se determine se'" e the percorredor; exit.
Mova the percorredor (compilador rules).
Abra the routine's decider sinal.
Compile the routine's monikettes e the routine's parameters usando the percorredor.
Se any of the routine's monikettes forem negative words, abort with "Não consigo me dar bem com palavras negativas em nomes de funções decisoras." e the percorredor; exit.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já me contou como'" then the routine's moniker then "'." e the routine's locus; exit.
Catalogue the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the header of uma routine usando um percorredor (function):
Se the compilador's sinal de alerta estiver presente, cancele.
Abra the routine's function sinal.
Adicione um monikette to the routine's monikettes usando "coloque".
Mova the percorredor (compilador rules).
Se the percorredor's token for any indefinite article, abra um sinal.
Se the sinal estiver verde, compile the routine's monikettes e the routine's parameters usando the percorredor (indefinite article).
Se the sinal não estiver verde, compile the routine's monikettes e the routine's parameters usando the percorredor (definite article).
Se the percorredor's token não for any possessive, abort with "Tá faltando um 's por aqui (ou está no lugar errado)." e the percorredor; exit. \ not translated - no possessives in Spanish
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Adicione another monikette to the routine's monikettes usando "'s " then the name.
Se the percorredor's token não for "into", abort with "Eu estava esperando um palavra 'into', mas encontrei um palavra '" then the percorredor's token then "'." e the percorredor; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to the routine's monikettes usando "into".
Convert the routine's monikettes to um moniker.
Se the moniker estiver in the routine index, abort with "Eu já sei como '" then the moniker then "'." e the routine's locus; exit. \ not translated - no possessives in Spanish
Catalogue the routine usando the routine's monikettes e the routine index.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any indefinite article, abort with "Estava esperando um artigo indefinido, mas achei isso aqui: '" then the percorredor's token then "'." e the percorredor; exit. \ not translated - no possessives in Spanish
Compile the routine's monikettes e the routine's parameters usando the percorredor (indefinite article).
Se the percorredor's token não estiver em branco, abort with "Tem comandos extras no fim dessa função." e the percorredor; exit. \ not translated - no possessives in Spanish
Convert the routine's monikettes to the routine's moniker.
Catalogue the routine usando the routine's monikettes e the routine index. \ por employs

Etapas necessárias para que se compile the header of uma routine usando um percorredor (procedure):
Se the compilador's sinal de alerta estiver presente, cancele.
Compile the routine's monikettes e the routine's parameters usando the percorredor.
Convert the routine's monikettes to the routine's moniker.
Se the routine's moniker estiver in the routine index, abort with "Você já escreveu como fazer '" then the routine's moniker then "'." e the routine's locus; exit.
Catalogue the routine usando the routine's monikettes e the routine index.

Etapas necessárias para que se compile the headers of alguns routines:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Compile the header of the routine.
Repita.

Etapas necessárias para que se compile um literal usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione the literal to the literals usando the percorredor's token's first.
\Se the percorredor's token for any sinal literal, compile the literal usando the percorredor (sinal); exit.
Se the percorredor's token for any hex literal, compile the literal usando the percorredor (hex); exit.
Se the percorredor's token for any numeric literal, compile the literal usando the percorredor (numeric); exit.
Se the percorredor's token for any endereço de memória literal, compile the literal usando the percorredor (endereço de memória); exit.
Se the percorredor's token for any string literal, compile the literal usando the percorredor (string); exit.
Abort with "Erro interno - compile um term usando um percorredor (literal)" e the percorredor.

Etapas necessárias para que se compile um literal usando um percorredor (sinal):
Se the compilador's sinal de alerta estiver presente, cancele.
Convert the percorredor's token to um sinal.
Convert the sinal to the literal's data.
Mova the percorredor (compilador rules).
Coloque "sinal" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um percorredor (hex):
Se the compilador's sinal de alerta estiver presente, cancele.
Coloque the percorredor's token into um nibble substring.
Adicione 1 to the nibble substring's first.
Convert the nibble substring to the literal's data.
Mova the percorredor (compilador rules).
Coloque "texto hexadecimal" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - integer):
Se the compilador's sinal de alerta estiver presente, cancele.
Convert the percorredor's token to um número.
Convert the número to the literal's data.
Mova the percorredor (compilador rules).
Coloque "número" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - ratio):
Se the compilador's sinal de alerta estiver presente, cancele.
Convert the percorredor's token to um ratio.
Convert the ratio to the literal's data.
Mova the percorredor (compilador rules).
Coloque "ratio" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - with unit of measure):
Se the compilador's sinal de alerta estiver presente, cancele.
Convert the percorredor's token to um ratio.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Encontre um type usando the name e the type index.
Se the type for inexistente, abort with "'" then the name then "' é uma unidade de medida inexistente." e the literal's locus; exit.
Se the type não puder ser reduzido para "número", abort with "'" then the name then "' é uma unidade de medida inválida." e the literal's locus; exit.
Coloque the type's scale into um final ratio.
Se the type's scale for 0, coloque 1/1 into the final ratio.
Multiplique the final ratio por the ratio.
Reduce the final ratio.
Se the final ratio's denominator for 0, abort with "Parece que essa é uma unidade de medida inválida." e the literal's locus.
Coloque the final ratio's numerator dividido por the final ratio's denominator into um número.
Coloque the type's name into the literal's type name.
Convert the número to the literal's data.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor estiver followed por any unit of measure, compile the literal usando the percorredor (numeric - with unit of measure); exit.
Se the percorredor's token for any integer literal, compile the literal usando the percorredor (numeric - integer); exit.
Se the percorredor's token for any ratio literal, compile the literal usando the percorredor (numeric - ratio); exit.
Se the percorredor's token for any mixed literal, compile the literal usando the percorredor (numeric - ratio); exit.

Etapas necessárias para que se compile um literal usando um percorredor (endereço de memória):
Se the compilador's sinal de alerta estiver presente, cancele.
Convert 0 to the literal's data. \ was nil
Mova the percorredor (compilador rules).
Coloque "endereço de memória" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile um literal usando um percorredor (string):
Se the compilador's sinal de alerta estiver presente, cancele.
Coloque the percorredor's token into the literal's data.
Unquote the literal's data.
Mova the percorredor (compilador rules).
Coloque "string" into the literal's type name.
Resolva the literal.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token for any definite article, compile the monikettes e the parameters usando the percorredor (definite article); repeat.
Se the percorredor estiver on any indefinite article, compile the monikettes e the parameters usando the percorredor (indefinite article); repeat.
Se the percorredor estiver on any monikette string, compile the monikettes e the parameters usando the percorredor (monikette string); repeat.
Abort with "'" then the percorredor's token then "' não é um nome de função que eu conheça." e the percorredor.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (definite article):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Anteponha "the " to the name.
Adicione um monikette to the monikettes usando the name.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (indefinite article):
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um parameter to the parameters usando "parameter" e the percorredor's token's first.
\PAL
Se the percorredor's token for "outra", coloque "segunda" into the parameter's name.
Se the percorredor's token for "outro", coloque "segundo" into the parameter's name.
\CAL
Se the percorredor's token for "another", coloque "other" into the parameter's name.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Extend the parameter's name with the name.
Se the percorredor's token for any called, compile the call'd part usando the percorredor e the parameter.
Resolva the parameter.
Se the parameter estiver duplicated in the parameters, abort with "Cara, você repetiu o parâmetro '" then the parameter's name then "'." e the parameter's locus; exit.
Adicione um monikette to the monikettes usando the parameter's type.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (monikette string):
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um monikette to the monikettes usando the percorredor's token.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile alguns monikettes usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor está on any monikette string, adicione um monikette to the monikettes usando the percorredor's token; mova the percorredor (compilador rules); repeat.
Se the percorredor's token não for the start of any expression, cancele.
Compile um expression usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione another monikette to the monikettes usando the expression.
Repita.

\Etapas necessárias para que se compile alguns monikettes usando um percorredor:
\Se the compilador's sinal de alerta estiver presente, cancele.
\Se the percorredor's token for any monikette string, adicione um monikette to the monikettes usando the percorredor's token; mova the percorredor (compilador rules); repeat.
\Se the percorredor's token não for the start of any expression, cancele.
\Compile um expression usando the percorredor.
\Se the compilador's sinal de alerta estiver presente, cancele.
\Adicione another monikette to the monikettes usando the expression.
\Repita.

Etapas necessárias para que se compile the next statement usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token for any conditional, compile the next statement usando the percorredor (if); exit.
Se the percorredor's token for any loop, compile the next statement usando the percorredor (loop); exit.
Se the percorredor's token for any privatize, compile the next statement usando the percorredor (privatize); exit.
Se the percorredor's token não for the start of any statement, abort with "Eu esperava uma declaração aqui, mas encontrei: '" then the percorredor's token then "'." e the percorredor; exit.
Compile the next statement usando the percorredor (other).
Se the percorredor's token não for the period pedaço, abort with "Acho que tá faltando um pontinho por aqui." e the percorredor; exit.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile the next statement usando um percorredor (break):
Adicione um fragment usando the break tag.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile the next statement usando um percorredor (call - external):
Coloque the percorredor's token into um string.
Unquote the string.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any string literal, abort with "Cara, você precisa colocar os nomes entre aspas, mas você colocou '" then the percorredor's token then "'." e the percorredor; exit.
Coloque the percorredor's token into another string.
Unquote the other string.
Mova the percorredor (compilador rules).
Adicione um entry to the imports usando the string e the other string.
Se the percorredor's token for "with", compile the next statement usando the percorredor (call - with clause).
Se the percorredor's token for "returning", compile the next statement usando the percorredor returning um term (call - returning part).
Adicione um fragment usando the call external tag e the entry.
Se the term estiver vazio, cancele.
Se the term's variable for inexistente, abort with "Não entendi bem o que é '" then the term's phrase then "'." e the percorredor; exit.
Adicione another fragment usando the save eax tag e the term's variable.

Etapas necessárias para que se compile the next statement usando um percorredor (call - indirect):
Compile um expression usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "Eu não sei o que é '" then the expression's phrase then "'." e the percorredor; exit.
Se the expression's type não puder ser reduzido para "endereço de memória", abort with "Eu preciso de um endereço de memória type nesse CALL statement." e the percorredor; exit.
Se the percorredor's token for "with", compile the next statement usando the percorredor (call - with clause).
Se the percorredor's token for "returning", compile the next statement usando the percorredor returning um term (call - returning part).
Adicione um fragment usando the call indirect tag e the expression's variable.
Se the term estiver vazio, cancele.
Se the term's variable for inexistente, abort with "Acho que essa varíavel é inválida: '" then the term's phrase then "'." e the percorredor; exit.
Adicione another fragment usando the save eax tag e the term's variable.

Etapas necessárias para que se compile the next statement usando um percorredor (call - internal):
Compile alguns monikettes usando the percorredor.
Encontre uma routine usando the monikettes.
Se the routine não for inexistente, adicione push fragments usando the monikettes.
Se the routine não for inexistente, destroy the monikettes; adicione um fragment usando the call internal tag e the routine; exit.
Convert the monikettes to um moniker.
Destroy the monikettes.
\Coloque "Eu ainda não aprendi como"  into a reply.
\Say the reply.
Coloque the moniker into a reply.
\Say the reply.
Abort with "Eu ainda não aprendi como '" then the moniker then "'." e the percorredor.

Etapas necessárias para que se compile the next statement usando um percorredor (call - with clause): \ this guy é recursise so parameters obtenha passed right to left
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Compile um expression usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "Eu não entendo um variável: '" then the expression's phrase then "'." e the percorredor; exit.
Se the expression's type não for value pushable, abort with "'" then the expression's type's name then "' não pode ser processado corretamente." e the percorredor; exit.
Se the percorredor's token for any and, compile the next statement usando the percorredor (call - with clause).
Adicione um fragment usando the push value tag e the expression's variable.

Etapas necessárias para que se compile the next statement usando um percorredor (call):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Se the percorredor's token for any string literal, compile the next statement usando the percorredor (call - external); exit.
Compile the next statement usando the percorredor (call - indirect).  

Etapas necessárias para que se compile the next statement usando um percorredor (exit):
Se the current routine's decider sinal estiver verde, abort with "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" e the percorredor; exit.
Adicione um fragment usando the exit tag.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile the next statement usando um percorredor (if):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Compile alguns monikettes usando the percorredor.
Remove any negatives from the monikettes returning um sinal.
Encontre uma routine usando the monikettes.
Se the routine não for inexistente, adicione push fragments usando the monikettes.
Se the routine for inexistente, convert the monikettes to um moniker.
Destroy the monikettes.
Se the routine for inexistente, abort with "Preciso de um decider que tenha como palavras: '" then the moniker then "'." e the percorredor; exit.
Se the routine's decider sinal não estiver verde, abort with "Cara eu vou precisar de um decider aqui, blz?" e the percorredor; exit.
Se the percorredor's token não for the comma pedaço, abort with "Acho que você esqueceu de uma vírgula, eu achei isso aqui: '" then the percorredor's token then "'." e the percorredor; exit.
Adicione um fragment usando the call internal tag e the routine.
Se the sinal estiver verde, adicione another fragment usando the not tag.
Adicione um third fragment usando the jump false tag.
Mova the percorredor (compilador rules).
Percorra.
Compile the next statement usando the percorredor (other).
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token for the semi-colon pedaço, mova the percorredor (compilador rules); repeat.
Se the percorredor's token não for the period pedaço, abort with "Você precisa usar um ponto ao invés de usar o termo '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Adicione um fourth fragment usando the end if tag.

Etapas necessárias para que se compile the next statement usando um percorredor (intel):
Mova the percorredor (compilador rules).
Se the percorredor's token não for any hex literal, abort with "Eu preciso de um pouco de machine code, mas o que eu achei foi '" then the percorredor's token then "'." e the percorredor; exit.
Adicione um fragment usando the intel tag.
Coloque the percorredor's token into um nibble substring.
Adicione 1 to the nibble substring's first.
Convert the nibble substring to the fragment's code.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile the next statement usando um percorredor (loop):
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um fragment usando the loop tag.
Mova the percorredor (compilador rules).
Se the percorredor's token não for the period pedaço, abort with "Parece que alguém esqueceu de colocar um ponto por aí." e the percorredor; exit.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile the next statement usando um percorredor (other):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token for any exit, compile the next statement usando the percorredor (exit); exit.
Se the percorredor's token for any repeat, compile the next statement usando the percorredor (repeat); exit.
Se the percorredor's token for any break, compile the next statement usando the percorredor (break); exit.
Se the percorredor's token for any say, compile the next statement usando the percorredor (say); exit.
Se the percorredor's token for "intel", compile the next statement usando the percorredor (intel); exit.
Se the percorredor's token for "push", compile the next statement usando the percorredor (push); exit.
Se the percorredor's token for any call, compile the next statement usando the percorredor (call); exit.
Se the percorredor's token for any point, compile the next statement usando the percorredor (point); exit.
Se the percorredor's token for any conditional, abort with "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." e the percorredor; exit.
Se the percorredor's token for any privatize, abort with "A sentença 'privatizar' não pode ser usada aqui." e the percorredor; exit.
Se the percorredor's token for any loop, abort with "Usar um percorra deentro de um SE for uma ótima forma de arranjar problemas." e the percorredor; exit.
Se the percorredor's token for any employ, abort with "'Empregue' deve ser o único imperativo em uma rotina." e the percorredor; exit.
Compile the next statement usando the percorredor (call - internal).

Etapas necessárias para que se compile the next statement usando um percorredor (point):
Mova the percorredor (compilador rules).
Compile um term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Acho que o termo '" then the term's phrase then "' está vazio." e the percorredor; exit.
Se the term's kind for "literal", abort with "Você usou o tipo errado de variável aqui (literal)." e the percorredor.
Se the term's type's length não for 4, abort with "Você usou uma variável de comprimento errado (<>4)." e the percorredor.
Se the percorredor's token não for "to", abort with "Acho que faltou um 'to', mas você usou '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Se the percorredor's token não for "routine", abort with "Acho que faltou a palavra 'routine'. Você usou o termo '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Compile uma routine reference usando the percorredor.
Convert the routine reference to um moniker.
Destroy the routine reference.
Encontre uma routine usando the moniker e the routine index.
Se the routine for inexistente, abort with "Não achei a tarefa '" then the moniker then "' que você falou." e the percorredor; exit.
Adicione um fragment usando the routine address tag e the routine.
Coloque the term's variable into the fragment's variable.

Etapas necessárias para que se compile the next statement usando um percorredor (privatize):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Compile um term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Comando 'privatize', Inválido. Eu acho que o termo da variável '" then the term's phrase then "' está vazio." e the percorredor; exit.
Se the term's kind não for "parameter", abort with "Você só pode privatizar parâmetros." e the percorredor; exit.
Adicione um local to the current routine's locals usando "local" e the percorredor's token's first.
Coloque the term's name into the local's name.
Coloque the term's nickname into the local's nickname.
Coloque the term's type name into the local's type name.
Resolva the local.
Anteponha "original " to the term's name.
Se the term's nickname não estiver em branco, Anteponha "original " to the term's nickname.
Adicione several fragments usando "coloque" e the term's variable e "into" e the local e the percorredor's token's first.
Se the percorredor's token não for the period pedaço, abort with "Você vive esquecendo dos pontos né?." e the percorredor; exit.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile the next statement usando um percorredor (push):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Compile um expression usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the expression's variable for inexistente, abort with "Comando 'push' inválido, um expressão '" then the expression's phrase then "' parece estar vazia." e the percorredor; exit.
Se the expression's type não for value pushable, abort with "Valores do tipo '" then the expression's type's name then "' não podem ser pushed." e the percorredor; exit.
Adicione um fragment usando the push value tag e the expression's variable.

Etapas necessárias para que se compile the next statement usando um percorredor (repeat):
Adicione um fragment usando the repeat tag.
Mova the percorredor (compilador rules).

\Etapas necessárias para que se compile the next statement usando um percorredor (say):
\Se the current routine's decider sinal não estiver verde, compile the next statement usando the percorredor (call - internal); exit.
\Mova the percorredor (compilador rules).
\Compile um expression usando the percorredor.
\Se the compilador's sinal de alerta estiver presente, cancele.
\Se the expression's variable for inexistente, abort with "No es válido este 'diga', no entiendo la variable '" then the expression's phrase then "'." e the percorredor; exit.
\Se the expression's type não puder ser reduzido para "sinal", abort with "Necesito un rotundo 'si' o 'no' aquí." e the percorredor; exit.
\Adicione um fragment usando the load eax tag e the expression's variable.
\Adicione another fragment usando the exit tag.

Etapas necessárias para que se compile the next statement usando um percorredor (say):
Se the current routine's decider sinal não estiver verde, compile the next statement usando the percorredor (call - internal); exit.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any decider literal, abort with "Você precisa terminar com um yes ou no." e the percorredor; exit.
Feche um sinal. Se the percorredor's token for any positive decider literal, abra the sinal.
Mova the percorredor (compilador rules).
Se the percorredor's token não for the period pedaço, abort with "Faltou um ponto. Você usou o termo: '" then the percorredor's token then "'." e the percorredor; exit.
Adicione um fragment usando the load eax tag e the sinal.
Adicione another fragment usando the exit tag.

Etapas necessárias para que se compile the next statement usando um percorredor returning um term (call - returning part):
Mova the percorredor (compilador rules).
Compile the term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Eu não compreendi o termo da variável '" then the term's phrase then "'. Ela parece estar vazia." e the percorredor; exit.
Se the term's type não for value pushable, abort with "Uma varíavel de 1, 2, ou 4-pedaços é necessária na 'returning' clause." e the percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor:
Se the percorredor's token for "to", mova the percorredor (compilador rules).
Se the percorredor for the start of any function, compile the routine reference usando the percorredor (function); exit.
Se the percorredor's token for any decide, compile the routine reference usando the percorredor (decide).
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token for ".", cancele.
Se the percorredor's token for any definite article, compile the routine reference usando the percorredor (definite article); repeat.
Se the percorredor's token for any indefinite article, compile the routine reference usando the percorredor (indefinite article); repeat.
Se the percorredor está on any monikette string, compile the routine reference usando the percorredor (monikette string); repeat.
Abort with "'" then the percorredor's token then "' não é válido em  um employ statement." e the percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor (decide):
Mova the percorredor (compilador rules).
Se the percorredor's token não for any conditional, abort with "Sempre use DECIDE IF, ao invés de apenas DECIDE com '" then the percorredor's token then "' logo em seguida." e the percorredor; exit.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile uma routine reference usando um percorredor (definite article):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Anteponha "the " to the name.
Adicione um monikette to the routine reference usando the name.

Etapas necessárias para que se compile uma routine reference usando um percorredor (function):
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um monikette to the routine reference usando "coloque".
Mova the percorredor (compilador rules).
Se the percorredor's token for any indefinite article, abra um sinal.
Se the sinal estiver verde, compile the routine reference usando the percorredor (indefinite article).
Se the sinal não estiver verde, compile the routine reference usando the percorredor (definite article).
Se the percorredor's token não for any possessive, abort with "Eu estava esperando un 's, mas apareceu '" then the percorredor's token then "'." e the percorredor; exit. \ not translated - no possessives in Spanish
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Adicione another monikette to the routine reference usando "'s " then the name.
Se the percorredor's token não for "into", abort with "E estava esperando um palavra 'into', mas encontrei '" then the percorredor's token then "'." e the percorredor; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to the routine reference usando "into".
Mova the percorredor (compilador rules).
Se the percorredor's token não for any indefinite article, abort with "Eu estava esperando um artigo indefinido mas encontrei isso: '" then the percorredor's token then "'." e the percorredor; exit. \ not translated - no possessives in Spanish
Compile the routine reference usando the percorredor (indefinite article).

Etapas necessárias para que se compile uma routine reference usando um percorredor (indefinite article):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Encontre um type e um nickname usando the name.
Se the type for inexistente, abort with "Employ statement inválido, Eu não sei o que é '" then the name then "'." e the percorredor; exit.
Adicione um monikette to the routine reference usando the type.

Etapas necessárias para que se compile uma routine reference usando um percorredor (monikette string):
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um monikette to the routine reference usando the percorredor's token.
Mova the percorredor (compilador rules).

Etapas necessárias para que se compile um term usando um percorredor:
Limpe the term.
Se the compilador's sinal de alerta estiver presente, cancele.
Compile the term usando the percorredor (common part).
Se the percorredor está on any simile, cancele. \ added por invisible turtle project ***
\Se the percorredor's token for "as", compile the term usando the percorredor (as part).  \preposição
\Se the percorredor's token for "tão", compile the term usando the percorredor (as part). \ me parece desnecessário por ser usado apenas em funções.
Se the percorredor's token for "quão", compile the term usando the percorredor (as part).
Se the percorredor's token for "quanto", compile the term usando the percorredor (as part).
Se the percorredor's token for "como", compile the term usando the percorredor (as part).
\Se the percorredor's token for "que nem", compile the term usando the percorredor (as part).
Se the percorredor's token for "/", compile the term usando the percorredor (runtime ratio).

Etapas necessárias para que se compile um term usando um percorredor (as part):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Comando 'as'inválido. Eu acho que um variável '" then the term's phrase then "' está vaiza." e the percorredor; exit.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any indefinite article, abort with "Tá faltando um artigo indefinido depois do 'como', mas você escreveu '" then the percorredor's token then "' no lugar disso." e the percorredor; exit.
Mova the percorredor (compilador rules).
Examine um type name usando the percorredor.
Encontre um type usando the type name e the type index.
Se the type for inexistente, abort with "Eu não sei em qual tipo o '" then the type name then "' se encaixa." e the percorredor; exit.
Adicione um scratch usando the type's name e the percorredor's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Coloque the scratch into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (common part):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token for the dash pedaço, compile the term usando the percorredor (negated term); exit.
Se the percorredor's token for the cross pedaço, compile the term usando the percorredor (posigated term); exit.
Se the percorredor's token for the start of any variable, compile the term usando the percorredor (variable); exit.
Se the percorredor's token for the start of any new local, compile the term usando the percorredor (new local); exit.
Se the percorredor's token for any literal, compile the term usando the percorredor (literal); exit.
Abort with "Faltou um termo por aqui. Só achei isso aqui: '" then the percorredor's token then "'." e the percorredor.

Etapas necessárias para que se compile um term usando um percorredor (dereference - in place):
Se the term's variable for inexistente, abort with "Erro interno na função - compile um term usando um percorredor (dereference - in place). Termo vazio" e the percorredor; exit.
Coloque the term's type's target type's name into the term's type name.
Coloque the term's type's target type into the term's type.
Adicione um fragment usando the dereference tag e the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (dereference):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Dereference inválido, um variável '" then the term's phrase then "' parece estar vazia." e the percorredor; exit.
Se the term's type's target type for inexistente, abort with "Não consegui identificar o tipo desse target." e the percorredor; exit.
Se the term's kind for "scratch", compile the term usando the percorredor (dereference - in place); exit.
Adicione um scratch usando the term's type's target type's name e the percorredor's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Adicione another fragment usando the dereference tag e the scratch.
Coloque the scratch into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (literal):
Se the compilador's sinal de alerta estiver presente, cancele.
Compile um literal usando the percorredor.
Coloque the literal into the term's variable.
Limpe the term's phrase.
Compile the term usando the percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor (negated term):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Compile another term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the other term's variable for inexistente, abort with "Negate inválido, um variável '" then the other term's phrase then "' parece estar vazia." e the percorredor; exit.
Adicione um intermediate usando the other term's type name e the percorredor's token's first.
Adicione several fragments usando "coloque" e the other term's variable e "into" e the intermediate e the other term's locus.
Adicione two fragments usando "negate" e the intermediate e the percorredor's token's first.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (new local):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the current routine for inexistente, abort with "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e the percorredor; exit.
Adicione um local to the current routine's locals usando "local" e the percorredor's token's first.
\PAL
Se the percorredor's token for "outra", coloque "segunda" into the local's name.
Se the percorredor's token for "outro", coloque "segundo" into the local's name.
\CAL
Se the percorredor's token for "another", coloque "other" into the local's name.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Extend the local's name with the name.
Se the percorredor's token for any called, compile the call'd part usando the percorredor e the local.
Resolva the local.
Se the local estiver duplicated in the current routine's parameters, abort with "o parâmetro '" then the local's name then "' já está sendo usado como parâmetro." e the local's locus; exit.
Se the local estiver duplicated in the current routine's locals, abort with "Já existe uma variável local chamada'" then the local's name then "'. Você tem que dar um nome diferente." e the local's locus; exit.
Eliminate duplicate nicknames usando the local e the current routine's nickname index.
Coloque the local into the term's variable.
Limpe the term's phrase.
Compile the term usando the percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor (posigated term):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Compile the term usando the percorredor.
Se the term's variable for inexistente, abort with "Posigate inválido, o termo da variável'" then the term's phrase then "' parece estar vazio." e the percorredor; exit.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (possessive - magnitude):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Use da magnitude inválido. An variável '" then the term's phrase then "' parece estar vazia." e the percorredor; exit.
Adicione um literal to the literals usando the percorredor's token's first.
Convert the term's type's length to the literal's data.
Coloque "número" into the literal's type name.
Resolva the literal.
Coloque the literal into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (possessive - target):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Você usou o target de forma errada. O termo da variável '" then the term's phrase then "' parece estar vazio." e the percorredor; exit.
Se the term's type não puder ser reduzido para "endereço de memória", abort with "Você só pode usar target com tipos endereço de memória." e the percorredor; exit.
Compile the term usando the percorredor (dereference).

Etapas necessárias para que se compile um term usando um percorredor (possessive - whereabouts):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Você usou whereabouts da forma errada, erro no termo da variável '" then the term's phrase then "'." e the percorredor; exit.
Adicione um intermediate usando "endereço de memória" e the percorredor's token's first. 
Adicione um fragment usando the load address tag e the term's variable e the intermediate.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (possessive): \ similar to "compile um term usando um percorredor (reverse-possessive)
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the name for any magnitude, compile the term usando the percorredor (possessive - magnitude); exit.
Se the name for any target, compile the term usando the percorredor (possessive - target); exit.
Se the name for any whereabouts, compile the term usando the percorredor (possessive - whereabouts); exit.
Compile the term usando the percorredor e the name (possessive - field).

Etapas necessárias para que se compile um term usando um percorredor (possessives):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token não for any possessive, cancele.
Compile the term usando the percorredor (possessive).
Repita.  

Etapas necessárias para que se compile um term usando um percorredor (runtime ratio):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable for inexistente, abort with "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável '" then the term's phrase then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Compile another term usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the other term's variable for inexistente, abort with "Uso inválido da /, termo vazio da variável: '" then the other term's phrase then "'." e the percorredor; exit.
Adicione um intermediate usando "ratio" e the percorredor's token's first.
Adicione several fragments usando "coloque" e the term's variable e "e" e the other term's variable e "into" e the intermediate e the percorredor's token's first.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (variable):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the current routine for inexistente, abort with "Erro de tarefa vazia, nada pra pull da pilha aqui." e the percorredor; exit.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Se the percorredor está on any reverse-possessive, compile the term usando the percorredor e the name (reverse-possessive); exit.
Encontre uma variable usando the name.
Coloque the variable into the term's variable.
Coloque "the " into the term's phrase.
Posponha the name to the term's phrase.
Compile the term usando the percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor e um field name (reverse-possessive):  \ this é recursive \ dahn version 2
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules). \ past the reverse-possessive starter
\Se the percorredor's token não for "del", Mova the percorredor (compilador rules). \ past the reverse-possessive starter \ gerry added "if" part
\Se the percorredor's token for "del", adicione 1 to the percorredor's token's first. \ makes "del" look like "de el"
Se the percorredor's token não for any article, abort with "Esperaba un artículo, pero encontré '" then the percorredor's token then "'."; exit.
Coloque the percorredor's token into um article token.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor. 
Se the percorredor está on any reverse-possessive, abra um reverse-possessive sinal.
Se the reverse-possessive sinal estiver verde, compile the term usando the percorredor e the name (reverse-possessive).
Se the reverse-possessive sinal não estiver verde, compile the term usando the percorredor e the name e the article (reverse-possessive preSuspenda to unwind).
Compile the term usando the field name e the percorredor (reverse-possessive).

Etapas necessárias para que se compile um term usando um percorredor e uma variable name e um article token (reverse-possessive preSuspenda to unwind): \ dahn version 2
Se the article for the start of any variable, compile the term usando the percorredor e the variable name e the article (reverse-possessive preSuspenda to unwind existing variable); exit.
Compile the term usando the percorredor e the variable name (reverse-possessive preSuspenda to unwind new local).

Etapas necessárias para que se compile um term usando um percorredor e uma variable name e um article token (reverse-possessive preSuspenda to unwind existing variable): \ dahn version 2
Encontre uma variable usando the variable name.
Se the variable for inexistente, abort with "No se pudo encontrar una variable con el nombre '" then the variable name then "'.".
Coloque the variable into the term's variable.
Coloque "the " into the term's phrase.
Posponha the variable name to the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor e uma variable name (reverse-possessive preSuspenda to unwind new local): \ dahn version 2
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um local to the current routine's locals usando "local" e the percorredor's token's first.
\PAL
Se the percorredor's token for "outra", coloque "segunda" into the local's name.
Se the percorredor's token for "outro", coloque "segundo" into the local's name.
\CAL
Se the percorredor's token for "another", coloque "other" into the local's name.
Extend the local's name with the variable name.
Se the percorredor's token for any called, compile the call'd part usando the percorredor e the local.
Resolva the local.
Se the local estiver duplicated in the current routine's parameters, abort with "O termo '" then the local's name then "' já está sendo usado como parâmetro." e the local's locus; exit.
Se the local estiver duplicated in the current routine's locals,abort with "O termo '" then the local's name then "' já está sendo usado como variável local." e the local's locus; exit.
Eliminate duplicate nicknames usando the local e the current routine's nickname index.
Coloque the local into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um field name e um percorredor (reverse-possessive):  \ similar to "compile um term usando um percorredor (possessive)" \ dahn
Se the compilador's sinal de alerta estiver presente, cancele.
Se the field name for any magnitude, compile the term usando the percorredor (possessive - magnitude); exit.
Se the field name for any target, compile the term usando the percorredor (possessive - target); exit.
Se the field name for any whereabouts, compile the term usando the percorredor (possessive - whereabouts); exit.
Compile the term usando the percorredor e the field name (possessive - field).

Etapas necessárias para que se compile um term usando um percorredor e um field term:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the field term's dereference sinal estiver verde, compile the term usando the percorredor (dereference).  
Se the field term's function não for inexistente, compile the term usando the percorredor e the field term (function); exit.
Se the term's kind for "scratch", compile the term usando the percorredor e the field term (in place); exit.
Coloque the field term's field into um field.
Adicione um scratch usando the field's type's name e the percorredor's token's first.
Adicione um fragment usando the load address tag e the term's variable e the scratch.
Se the field's offset não for 0, adicione um third fragment usando the increment tag e the scratch e the field's offset.
Coloque the scratch into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor e um field term (function):
Se the compilador's sinal de alerta estiver presente, cancele.
Coloque the field term's function into uma routine.
Coloque the routine's parameters' last into um parameter.
Se the parameter for inexistente, abort with "Erro interno na função compile um term usando um percorredor e um field term (function) - parâmetro vazio." e the percorredor; exit.
Se the parameter's type for inexistente, abort with "Erro interno 2 na função compile um term usando um percorredor e um field term (function) - tipo do parâmetro inexistente." e the percorredor; exit.
Adicione um intermediate usando the parameter's type's name e the percorredor's token's first.
Adicione um fragment usando the push address tag e the intermediate.
Se the field term's push sinal estiver verde, adicione another fragment usando the push address tag e the term's variable.
Adicione um third fragment usando the call internal tag e the routine.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor e um field term (in place):
Se the compilador's sinal de alerta estiver presente, cancele.
Coloque the field term's field into um field.
Coloque the field's type's name into the term's type name.
Coloque the field's type into the term's type.
Se the field's offset não for 0, adicione um third fragment usando the increment tag e the term's variable e the field's offset.
Limpe the term's phrase.

Etapas necessárias para que se compile um term usando um percorredor e um name (possessive - field):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the term's variable não for inexistente, coloque the term's type into um type.
Encontre um field term usando the term's phrase e the type e the name.
Se the field term não for vazio, compile the term usando the percorredor e the field term; exit.
Se the term's variable for inexistente, abort with "Erro: variável vazia '" then the term's phrase then "'." e the percorredor; exit.
Se the type puder ser reduzido para "endereço de memória", coloque the type's target type into the type.
Se the type for inexistente, abort with "Não existe o campo '" then the name then "' no tipo '" then the term's type's name then "'." e the percorredor; exit.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields.
Se the field for inexistente, abort with "Não tem nenhum campo '" then the name then "' no tipo '" then the term's type's name then "'." e the percorredor; exit.
Encontre um deep field term usando "" e the field's type e the name.
Se the deep field term estiver vazio, repita.
Coloque the field into um first field term's field.
Se the term's type puder ser reduzido para "endereço de memória", abra the first field term's dereference sinal.
Compile the term usando the percorredor e the first field term.
Compile the term usando the percorredor e the deep field term.

The compilador é um conjunto with
An directory,
An timer,
An abort sinal,
An sinal de alerta, \new line
An mensagem de erro,
An abort path,
An abort row#,
An name count,
An exe buffer,
An listing buffer.

The compiling routine bodies timer é um timer.

The compiling routine headers timer é um timer.

Etapas necessárias para que se convert alguns monikettes to um moniker:
Convert the monikettes to the moniker usando the monikettes' last.

Etapas necessárias para que se convert alguns monikettes to um moniker usando um monikette:
Limpe the moniker.
Percorra.
Obtenha um current monikette from the monikettes.
Se the current monikette for inexistente, cancele.
Posponha the current monikette to the moniker.
Se the current monikette for the monikette, cancele.
Repita.

Etapas necessárias para que se convert um nibble substring to um string: employ convert um nibble string to um texto hexadecimal.

Etapas necessárias para que se convert um term por concatenation usando um percorredor: \ used por right-side THEN operand
Se the term's variable for inexistente, abort with "Erro: variável do termo está vazia '" then the term's phrase then "'." e the percorredor; exit.
Se the term's type puder ser reduzido para "string", cancele.
Adicione um intermediate usando "string" e the percorredor's token's first.
Adicione the coloque ou convert fragments usando the term's variable e the intermediate e the percorredor's token's first.
Coloque the intermediate into the term's variable.
Limpe the term's phrase.

Etapas necessárias para que se copy um field into another field:
Se the field for inexistente, esvazie the other field; exit.
Allocate memory por the other field.
Coloque the field's locus into the other field's locus.
Coloque the field's name into the other field's name.
Coloque the field's nickname into the other field's nickname.
Coloque the field's type name into the other field's type name.
Coloque the field's type into the other field's type.
Coloque the field's count into the other field's count.
Coloque the field's redefinition target name into the other field's redefinition target name.
Coloque the field's reference sinal into the other field's reference sinal.
Coloque the field's offset into the other field's offset.

Etapas necessárias para que se copy alguns fields into alguns other fields:
Obtenha um field from the fields.
Se the field for inexistente, cancele.
Copy the field into another field.
Posponha the other field to the other fields.
Repita.

Etapas necessárias para que se copy alguns fields into alguns other fields (data fields only):
Se the fields' count for menor do que 4, cancele. \ por english next e prev e spanish next e prev redefinitions
\Se the fields' first for inexistente, cancele.
\Se the fields' first's next for inexistente, cancele.
\Se the fields' first's next's next for inexistente, cancele.
\\Coloque the fields' first's next's next into um field. \ skip next e prev
\Se the fields' first's next's next's next for inexistente, cancele.
\Se the fields' first's next's next's next's next for inexistente, cancele.
\Se the fields' first's next's next's next's next's next for inexistente, cancele.
Coloque the fields' first's next's next's next's next into um field. \ english next e prev e spanish next e prev redefinitions
Percorra.
Se the field for inexistente, cancele.
Copy the field into another field.
Posponha the other field to the other fields.
Obtenha the field from the fields.
Repita.

Etapas necessárias para que se copy um monikette into another monikette:
Se the monikette for inexistente, esvazie the other monikette; exit.
Allocate memory por the other monikette.
Coloque the monikette's string into the other monikette's string.
Coloque the monikette's type into the other monikette's type.
Coloque the monikette's variable into the other monikette's variable.
\ don't copy substring
Coloque the monikette's current type into the other monikette's current type.

Etapas necessárias para que se copy alguns monikettes into alguns other monikettes:
Destroy the other monikettes.
Percorra.
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Copy the monikette into another monikette.
Posponha the other monikette to the other monikettes.
Repita.

Etapas necessárias para que se crie um entry:
Allocate memory por the entry.

Etapas necessárias para que se crie um fragment usando uma tag:
Allocate memory por the fragment.
Coloque the tag into the fragment's tag.

Etapas necessárias para que se crie um import:
Allocate memory por the import.

Etapas necessárias para que se crie um monikette:
Allocate memory por the monikette.

Etapas necessárias para que se crie uma routine:
Allocate memory por the routine.

Etapas necessárias para que se crie um source file:
Allocate memory por the source file.

Etapas necessárias para que se crie um type:
Allocate memory por the type.
Coloque 0/1 into the type's scale.
Coloque -1 into the type's length.

Etapas necessárias para que se crie uma variable usando um kind:
Allocate memory por the variable.
Coloque the kind into the variable's kind.
Coloque 1 into the variable's count.

The current header address é um address.

The current name address é um address.

The current routine é uma routine.

The current thunk address é um address.

The data borough é um borough.

Etapas necessárias para que se determine se any of alguns monikettes are negative words:
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, diga não.
Se the monikette's string for any negative word, diga sim.
Repita.

Etapas necessárias para que se determine se um pedaço é any glom pedaço:
Se the pedaço for any letter, diga sim.
Se the pedaço for any digit, diga sim.
Se the pedaço for the tilde pedaço, diga sim.
Se the pedaço for the at-sign pedaço, diga sim.
Se the pedaço for the número-sign pedaço, diga sim.
Se the pedaço for the percent-sign pedaço, diga sim.
Se the pedaço for the ampersand pedaço, diga sim.
Se the pedaço for the underscore pedaço, diga sim.
Se the pedaço for the single-quote pedaço, diga sim.
Se the pedaço for the dash pedaço, diga sim.
Se the pedaço for the cross pedaço, diga sim.
Se the pedaço for the slash pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any mark:
Se the pedaço for the period pedaço, diga sim.
Se the pedaço for the comma pedaço, diga sim.
Se the pedaço for the semi-colon pedaço, diga sim.
Se the pedaço for the colon pedaço, diga sim.
Se the pedaço for the exclamation  pedaço, diga sim.
Se the pedaço for the question-mark pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any stressed vowel:
Se the pedaço estiver in "áãâàéèêëíîìïóõôöúùüûý", diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any symbol:
Se the pedaço for the caret pedaço, diga sim.
Se the pedaço for the bar pedaço, diga sim.
Se the pedaço for the asterisk pedaço, diga sim.
Se the pedaço for the cross pedaço, diga sim.
Se the pedaço for the dash pedaço, diga sim.
Se the pedaço for the slash pedaço, diga sim.
Se the pedaço for the left-alligator pedaço, diga sim.
Se the pedaço for the right-alligator pedaço, diga sim.
Se the pedaço for the left-brace pedaço, diga sim.
Se the pedaço for the right-brace pedaço, diga sim.
Se the pedaço for the equal-sign pedaço, diga sim.
Se the pedaço for 128, diga sim.
Se the pedaço for 130, diga sim.
Se the pedaço for between 132 e 137, diga sim.
Se the pedaço for 139, diga sim.
Se the pedaço estiver between 145 e 153, diga sim.
Se the pedaço for 155, diga sim.
Se the pedaço estiver between 161 e 180, diga sim.
Se the pedaço estiver between 183 e 191, diga sim.
Se the pedaço for 215, diga sim.
Se the pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um field term é vazio:
Se the field term's field não for inexistente, diga não.
Se the field term's function não for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se alguns fields deveria ser finalizado:
Obtenha um field from the fields.
Se the field for inexistente, diga não.
Se the field's type deveria ser finalizado, diga sim.
Repita.

Etapas necessárias para que se determine se um item looks reamish:
Load the item's path into um buffer.
Se the buffer starts with "ream cal", diga sim.
Diga não.

Etapas necessárias para que se determine se um moniker estiver in um index:
Encontre um refer usando the moniker e the index.
Se the refer for inexistente, diga não.
Se the refer's endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se the monikette for inexistente, diga sim.
Se the monikette's current type não for inexistente, diga não.
Se the monikette's current substring não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um name é any magnitude:
\PAL
Se the name for "magnitude", diga sim.
\CAL
Se the name for "magnitud", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any target:
\PAL
Se the name for "conteúdo", diga sim.
Se the name for "alvo", diga sim.
\CAL
Se the name for "target", diga sim.
Se the name for "objetivo", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any whereabouts:
\PAL
Se the name for "paradeiro", diga sim.
\CAL
Se the name for "whereabouts", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any valid field name:
Se the name for any magnitude, diga não.
Se the name for any target, diga não.
Se the name for any whereabouts, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor é followed por any unit of measure:
Privatize the percorredor.
Mova the percorredor (compilador rules).
Se the percorredor não for on any name starter, diga não.
Examine um name usando the percorredor.
Encontre um type usando the name e the type index.
Se the type for inexistente, diga não.
Se the name não for "times", diga sim. \ special because times é um infix operator e um unit of measure
Se the percorredor's token for the start of any expression, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any nested double-quote:
Se the percorredor's source starts with """""", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive:
Se the percorredor's source estiver em branco, diga não.
Se the percorredor's source's first's target não for the single-quote pedaço, diga não.
Se the percorredor está on any possessive (type 1 - single-quote, s, non-glom-byte), diga sim.
Se the percorredor está on any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive (type 1 - single-quote, s, non-glom-byte):
Se the percorredor's source does not start with "'s", diga não.
Privatize the percorredor.
Adicione 2 to the percorredor's source's first.
Se the percorredor's source estiver em branco, diga sim.
Se the percorredor's source's first's target não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Privatize the percorredor.
Se the percorredor's source's first for the percorredor's original substring's first, diga não.
Subtraia 1 from the percorredor's source's first.
Se the percorredor's source's first's target não for the little-s pedaço ou the big-s pedaço, diga não.
Adicione 2 to the percorredor's source's first.
Se the percorredor's source estiver em branco, diga sim.
Se the percorredor's source's first's target não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any simile: \ added for invisible turtle project ***
Privatize the percorredor.
Se the percorredor's token for "LIKE", diga sim.
Se the percorredor's token não for "AS", diga não.
Mova the percorredor (compilador rules).
Se the percorredor's token for any indefinite article, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor é the start of any function:
Se the compilador's sinal de alerta estiver presente, diga não.
Se the percorredor's token for "Ponha", diga sim.
\Se the percorredor's token não for any coloque, diga não.
Se the percorredor's token não for "coloque", diga não.
Privatize the percorredor.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any article, diga não.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Se the percorredor's token for any possessive, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any contraction giving another string (portuguese rules - "no"):
Se the string não for "no", diga não.
Se the other string for "say", diga não.
Se the other string for "diga", diga não.
\Se the other string for "dizer", diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant e another string:
Lance um substring on the string.
Subtraia the other string's length from the substring's last.
Se the substring estiver em branco, diga não.
Se the substring's last's target não for any consonant, diga não.
Se the string does not end with the other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel e another string:
Lance um substring on the string.
Subtraia the other string's length from the substring's last.
Se the substring estiver em branco, diga não.
Se the substring's last's target não for any vowel, diga não.
Se the string does not end with the other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant:
Se the string estiver em branco, diga não.
Se the string's last's target não for any consonant, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel:
Se the string estiver em branco, diga não.
Se the string's last's target não for any vowel, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any plus:
\PAL
Se the string for "mais", diga sim.
\CAL
Se the string for "plus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any coloque:
\PAL
Se the string for "pôr", diga sim.
\# Não precisa porque está como sinônimo: ver "Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules)"
\Se the string for "colocar", diga sim. 
\CAL
Se the string for "coloque", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any minus:
\PAL
Se the string for "menos", diga sim.
\CAL
Se the string for "minus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any times:
\PAL
Se the string for "vezes", diga sim.
\CAL
Se the string for "times", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any divided:
\PAL
Se the string for "dividido", diga sim.
\CAL
Se the string for "divided", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any by:
\PAL
Se the string for "via", diga sim.  \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se the string for "por", diga sim.
\CAL
Se the string for "by", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any then:
\PAL
\# operador de concatenação de strings tipo: "abc" then "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida". 
Se the string for "depois", diga sim.
Se the string for "então", diga sim.
\CAL
Se the string for "then", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any has:
\PAL
Se the string for "tem", diga sim.
Se the string for "têm", diga sim.
Se the string for "possui", diga sim.
Se the string for "possuem", diga sim.
\CAL
Se the string for "has", diga sim.
Se the string for "have", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any is:
\PAL
Se the string for "é", diga sim.
Se the string for "está", diga sim.
Se the string for "são", diga sim.
Se the string for "estão", diga sim.
Se the string for "for", diga sim.
Se the string for "forem", diga sim.
Se the string for "estiverem", diga sim.
Se the string for "estarem", diga sim.
\CAL
Se the string for "is", diga sim.
Se the string for "are", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operador de atribuição:
\PAL
Se the string for "igual", diga sim.
\CAL
Se the string for "equal", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any with:
\PAL
Se the string for "com", diga sim.
\CAL
Se the string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any article:
Se the string for any indefinite article, diga sim.
Se the string for any definite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se the string for "e", diga sim.
Se the string for "ou", diga sim.
Se the string for "nem", diga sim.
\CAL
Se the string for "and", diga sim.
Se the string for "both", diga sim.
Se the string for "but", diga sim.
Se the string for "either", diga sim.
Se the string for "neither", diga sim.
Se the string for "nor", diga sim.
Se the string for "or", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any sinal literal:
\Se the string for "yes", diga sim.
\Se the string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any to:
\PAL
Se the string for "a", diga sim. \ this é questionable
\CAL
Se the string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any and:
\PAL
Se the string for "e", diga sim.
\CAL
Se the string for "and", diga sim.
Diga não. \repetido?

Etapas necessárias para que se determine se um string é any reverse-possessive function into:
\PAL
Se the string for "em", diga sim.
\CAL
Se the string for "into", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any sinal literal:
\Se the string for "si", diga sim.
\Se the string for "yes", diga sim.
\Se the string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any decider literal:
\PAL
Se the string for "sim", diga sim.
Se the string for "positivo", diga sim.
Se the string for "positivamente", diga sim.
Se the string for "não", diga sim.
Se the string for "negativo", diga sim.
Se the string for "negativamente", diga sim.
\CAL
Se the string for "yes", diga sim.
\Se the string for "yep", diga sim.
\Se the string for "yea", diga sim.
Se the string for "no", diga sim.
\Se the string for "nay", diga sim.
\Se the string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any positive decider literal:
\PAL
Se the string for "sim", diga sim.
Se the string for "positivo", diga sim.
Se the string for "positivamente", diga sim.
\CAL
Se the string for "yes", diga sim.
\Se the string for "yep", diga sim.
\Se the string for "yea", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any negative decider literal:
\PAL
Se the string for "não", diga sim.
Se the string for "negativo", diga sim.
Se the string for "negativamente", diga sim.
\CAL
Se the string for "no", diga sim.
\Se the string for "nay", diga sim.
\Se the string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any hex literal:
Se the string estiver em branco, diga não.
Se the string's first's target for the dollar-sign pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any definite article:
\PAL
Se the string for "o", diga sim.
Se the string for "a", diga sim.
Se the string for "os", diga sim.
Se the string for "as", diga sim.
\CAL
Se the string for "the", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any definite article:
Se the percorredor está on any portuguese to, diga não.
Se the percorredor's token não for any definite article, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any indefinite article:
Se the percorredor está on any portuguese to, diga não.
Se the percorredor's token não for any indefinite article, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any portuguese to:
Se the percorredor's token não for "a", diga não.
Privatize the percorredor. Mova the percorredor (compilador rules).
Se the percorredor's token for any article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any indefinite article:
\PAL
Se the string for any portuguese indefinite article, diga sim.
\CAL
Se the string for any english indefinite article, diga sim.
\Se the string for "a", diga sim.
Se the string for "an", diga sim.
Se the string for "another", diga sim.
Se the string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any portuguese indefinite article:
\PAL
Se the string for "um", diga sim.
Se the string for "uma", diga sim.
Se the string for "outro", diga sim.
Se the string for "outra", diga sim.
Se the string for "algum", diga sim.
Se the string for "alguma", diga sim.
Se the string for "alguns", diga sim.
Se the string for "algumas", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any english indefinite article:
\CAL
Se the string for "an", diga sim.
Se the string for "another", diga sim.
Se the string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any literal:
Se the string for any endereço de memória literal, diga sim.
Se the string for any numeric literal, diga sim.
Se the string for any string literal, diga sim.
\Se the string for any sinal literal, diga sim. ***
Se the string for any hex literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any mark:
Se the string's length não for 1, diga não.
Se the string's first's target for any mark, diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any monikette string:
\Se the string estiver em branco, diga não.
\Se the string for "the", diga não.
\Se the string é any indefinite article, diga não.
\Se the string é any possessive, diga não.
\Se the string é any literal, diga não.
\Se the string é any mark, diga não.
\Se the string é any symbol, diga não.
\Diga sim.

Etapas necessárias para que se determine se um percorredor está on any monikette string:
Se the percorredor's token estiver em branco, diga não.
Se the percorredor estiver on any definite article, diga não.
Se the percorredor estiver on any indefinite article, diga não.
Se the percorredor's token for any possessive, diga não.
Se the percorredor's token for any literal, diga não.
Se the percorredor's token for any mark, diga não.
Se the percorredor's token for any symbol, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any called:
\PAL
Se the string for "chamado", diga sim.
Se the string for "chamada", diga sim.
\CAL
Se the string for "called", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name ender: \ compare with name starter
Se the string for any mark, diga sim.
Se the string for any symbol, diga sim.
Se the string for any article, diga sim.
Se the string for any conjunction, diga sim.
Se the string for any possessive, diga sim.
Se the string for any verb, diga sim.
Se the string for any operator, diga sim.
Se the string for any preposition, diga sim.
Se the string for any qualifier, diga sim.
Se the string for any literal, diga sim.
Se the string for "called", diga sim.
Se the string for "equal", diga sim.
Se the string estiver em branco, diga sim.
Diga não.
Etapas necessárias para que se determine se um string é any reference:
\PAL
Se the string for "(referência)", diga sim.
\CAL
Se the string for "(reference)", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any name ender: \ compare with name starter
Se the percorredor's token for any mark, diga sim.
Se the percorredor's token for any symbol, diga sim.
Se the percorredor's token for any article, diga sim.
Se the percorredor's token for any conjunction, diga sim.
Se the percorredor's token for any possessive, diga sim.
Se the percorredor está on any reverse-possessive, diga sim.
Se the percorredor's token for any verb, diga sim.
Se the percorredor's token for any operator, diga sim.
Se the percorredor está on any preposition, diga sim.
Se the percorredor's token for any qualifier, diga sim.
Se the percorredor's token for any literal, diga sim.
Se the percorredor's token for any called, diga sim.
Se the percorredor's token for any operador de atribuição, diga sim.
Se the percorredor's token estiver em branco, diga sim.
\ Portuguese trouble makers
Se the percorredor's token for any negative word, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name starter: \ compare with name ender
Se the string for any mark, diga não.
Se the string for any symbol, diga não.
Se the string for any article, diga não.
Se the string for any conjunction, diga sim.
Se the string for any possessive, diga não.
Se the string for any verb, diga sim.
Se the string for any operator, diga sim.
Se the string for any preposition, diga sim.
Se the string for any qualifier, diga não.
Se the string for any literal, diga não.
Se the string for "called", diga sim.
Se the string for "equal", diga sim.
Se the string estiver em branco, diga não.
Diga sim.
Etapas necessárias para que se determine se um percorredor está on any name starter: \ compare with name ender
Se the percorredor's token for any mark, diga não.
Se the percorredor's token for any symbol, diga não.
Se the percorredor's token for any article, diga não.
Se the percorredor's token for any conjunction, diga sim.
Se the percorredor's token for any possessive, diga não.
Se the percorredor's token for any verb, diga sim.
Se the percorredor's token for any operator, diga sim.
Se the percorredor estiver on any preposition, diga sim.
Se the percorredor's token for any qualifier, diga não.
Se the percorredor's token for any literal, diga não.
Se the percorredor's token for any called, diga sim.
Se the percorredor's token for any operador de atribuição, diga sim.
Se the percorredor's token estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any negative word:
\SAL
Se the string for "não", diga sim.
\Se the string for "nada", diga sim.
\Se the string for "ainda", diga sim.
\CAL
\Se the string for "no", diga sim.
Se the string for "not", diga sim.
Se the string for "cannot", diga sim.
Se the string for "nothing", diga sim.
Se the string ends with "n't", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operator:
\PAL
Se the string for "mais", diga sim.
Se the string for "menos", diga sim.
Se the string for "vezes", diga sim.
Se the string for "dividido", diga sim.
Se the string for "depois", diga sim.
Se the string for "então", diga sim.
\CAL
Se the string for "plus", diga sim.
Se the string for "minus", diga sim.
Se the string for "times", diga sim.
Se the string for "divided", diga sim.
Se the string for "then", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any english indefinite article:
\Se the string for "a", diga sim.
\Se the string for "an", diga sim.
\Se the string for "another", diga sim.
\Se the string for "some", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any pause:
\PAL
Se the string for "e", diga sim.
Se the string for "ou", diga sim.
\CAL
Se the string for "and", diga sim.
Se the string for "or", diga sim.
\default
Se the string for ",", diga sim.
Se the string for ";", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any endereço de memória literal:
\PAL
Se the string for "nulo", diga sim.
Se the string for "nula", diga sim.
Se the string for "inexistente", diga sim.
\CAL
Se the string for "nil", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any possessive:
Se the string for "'s", diga sim.
Se the string for "'", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any preposition:
Coloque the percorredor's token into um substring.
\PAL
Se the percorredor está on any portuguese to, diga sim. \ "a" followed por um article for "to" in portuguese
Se the substring for "abaixo", diga sim. \ down
Se the substring for "acima", diga sim. \ up
Se the substring for "ante", diga sim. \ before
Se the substring for "antes", diga sim. \ before
Se the substring for "perante", diga sim. \ before
Se the substring for "debaixo", diga sim. \ below
Se the substring for "sob", diga sim. \ below
Se the substring for "acerca", diga sim. \ near
Se the substring for "próximo", diga sim. \ near
Se the substring for "perto", diga sim. \ near
Se the substring for "com", diga sim. \ with
Se the substring for "como", diga sim. \ as
Se the substring for "contra", diga sim. \ against
\ Se the substring for "de", diga sim. \ reverse-possessive indicator 
Se the substring for "dada", diga sim. \ given
Se the substring for "dado", diga sim. \ given
Se the substring for "dando", diga sim. \ given
Se the substring for "gerando", diga sim. \ giving
Se the substring for "resultando", diga sim. \ giving
Se the substring for "retornando", diga sim. \ giving
Se the substring for "direita", diga sim. \ right
Se the substring for "desde", diga sim. \ since
Se the substring for "depois", diga sim. \ after
Se the substring for "durante", diga sim. \ during
Se the substring for "em", diga sim. \ in
Se the substring for "entre", diga sim. \ between
Se the substring for "até", diga sim. \ until
Se the substring for "esquerda", diga sim. \ left
Se the substring for "mediante", diga sim. \ through
Se the substring for "para", diga sim. \ to
Se the substring for "via", diga sim. \ by
Se the substring for "segundo", diga sim. \ according
Se the substring for "sem", diga sim. \ without
Se the substring for "então", diga sim.
Se the substring for "sobre", diga sim. \ on
Se the substring for "após", diga sim. \ after
Se the substring for "depois", diga sim. \ after
Se the substring for "usando", diga sim. \ using
Se the substring for "versus", diga sim. \ versus
Se the substring for "via", diga sim. \ by
Se the substring for "enquanto", diga sim. \ while
Se the substring for "redefinindo", diga sim. \# 'at' na redefinição de campos  
\CAL
Se the substring for "about", diga sim.
Se the substring for "above", diga sim.
Se the substring for "across", diga sim.
Se the substring for "after", diga sim.
Se the substring for "against", diga sim.
Se the substring for "all", diga sim.
Se the substring for "alone", diga sim.
Se the substring for "along", diga sim.
Se the substring for "among", diga sim.
Se the substring for "any", diga sim.
Se the substring for "anywhere", diga sim.
Se the substring for "around", diga sim.
\Se the substring for "as", diga sim.
Se the substring for "at", diga sim.
Se the substring for "away", diga sim.
Se the substring for "back", diga sim.
Se the substring for "backward", diga sim.
Se the substring for "backwards", diga sim.
Se the substring for "before", diga sim.
Se the substring for "beginning", diga sim.
Se the substring for "behind", diga sim.
Se the substring for "below", diga sim.
Se the substring for "beneath", diga sim.
Se the substring for "beside", diga sim.
Se the substring for "between", diga sim.
Se the substring for "beyond", diga sim.
Se the substring for "bigger", diga sim.
Se the substring for "by", diga sim.
Se the substring for "close", diga sim.
Se the substring for "deep", diga sim.
Se the substring for "diagonally", diga sim.
Se the substring for "down", diga sim.
Se the substring for "downward", diga sim.
Se the substring for "ending", diga sim.
Se the substring for "everywhere", diga sim.
Se the substring for "except", diga sim.
Se the substring for "finishing", diga sim.
Se the substring for "facing", diga sim.
\Se the substring for "for", diga sim.
Se the substring for "por", diga sim.
Se the substring for "forward", diga sim.
Se the substring for "from", diga sim.
Se the substring for "given", diga sim.
Se the substring for "giving", diga sim.
Se the substring for "high", diga sim.
Se the substring for "in", diga sim.
Se the substring for "inside", diga sim.
Se the substring for "into", diga sim.
Se the substring for "en", diga sim.
Se the substring for "larger", diga sim.
Se the substring for "leaning", diga sim.
Se the substring for "left", diga sim.
Se the substring for "leftward", diga sim.
Se the substring for "leftways", diga sim.
Se the substring for "like", diga sim.
Se the substring for "limiting", diga sim.
Se the substring for "long", diga sim.
Se the substring for "near", diga sim.
Se the substring for "of", diga sim.
Se the substring for "off", diga sim.
Se the substring for "on", diga sim.
Se the substring for "only", diga sim.
Se the substring for "onto", diga sim.
Se the substring for "out", diga sim.
Se the substring for "outside", diga sim.
Se the substring for "over", diga sim.
Se the substring for "past", diga sim.
Se the substring for "pointing", diga sim.
Se the substring for "returning", diga sim.
Se the substring for "right", diga sim.
Se the substring for "rightward", diga sim.
Se the substring for "rightways", diga sim.
Se the substring for "shorter", diga sim.
Se the substring for "sideway", diga sim.
Se the substring for "sideways", diga sim.
Se the substring for "similar", diga sim.
Se the substring for "smaller", diga sim.
Se the substring for "somewhere", diga sim.
Se the substring for "slantwise", diga sim.
Se the substring for "slantway", diga sim.
Se the substring for "slantways", diga sim.
Se the substring for "starting", diga sim.
Se the substring for "tall", diga sim.
Se the substring for "taller", diga sim.
Se the substring for "thru", diga sim.
Se the substring for "through", diga sim.
Se the substring for "throughout", diga sim.
Se the substring for "to", diga sim.
Se the substring for "toward", diga sim.
Se the substring for "towards", diga sim.
Se the substring for "under", diga sim.
Se the substring for "underneath", diga sim.
Se the substring for "until", diga sim.
Se the substring for "unto", diga sim.
Se the substring for "up", diga sim.
Se the substring for "upward", diga sim.
Se the substring for "upon", diga sim.
Se the substring for "using", diga sim.
Se the substring for "via", diga sim.
Se the substring for "while", diga sim.
Se the substring for "wide", diga sim.
Se the substring for "with", diga sim.
Se the substring for "within", diga sim.
Se the substring for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any preposition:
Se the string for "about", diga sim.
Se the string for "above", diga sim.
Se the string for "across", diga sim.
Se the string for "after", diga sim.
Se the string for "against", diga sim.
Se the string for "all", diga sim.
Se the string for "alone", diga sim.
Se the string for "along", diga sim.
Se the string for "among", diga sim.
Se the string for "any", diga sim.
Se the string for "anywhere", diga sim.
Se the string for "around", diga sim.
\Se the string for "as", diga sim.
Se the string for "at", diga sim.
Se the string for "away", diga sim.
Se the string for "back", diga sim.
Se the string for "backward", diga sim.
Se the string for "backwards", diga sim.
Se the string for "before", diga sim.
Se the string for "beginning", diga sim.
Se the string for "behind", diga sim.
Se the string for "below", diga sim.
Se the string for "beneath", diga sim.
Se the string for "beside", diga sim.
Se the string for "between", diga sim.
Se the string for "beyond", diga sim.
Se the string for "bigger", diga sim.
Se the string for "by", diga sim.
Se the string for "close", diga sim.
Se the string for "deep", diga sim.
Se the string for "diagonally", diga sim.
Se the string for "down", diga sim.
Se the string for "downward", diga sim.
Se the string for "ending", diga sim.
Se the string for "everywhere", diga sim.
Se the string for "except", diga sim.
Se the string for "finishing", diga sim.
Se the string for "facing", diga sim.
\Se the string for "for", diga sim.
Se the string for "por", diga sim.
Se the string for "forward", diga sim.
Se the string for "from", diga sim.
Se the string for "given", diga sim.
Se the string for "giving", diga sim.
Se the string for "high", diga sim.
Se the string for "in", diga sim.
Se the string for "inside", diga sim.
Se the string for "into", diga sim.
Se the string for "larger", diga sim.
Se the string for "leaning", diga sim.
Se the string for "left", diga sim.
Se the string for "leftward", diga sim.
Se the string for "leftways", diga sim.
Se the string for "like", diga sim.
Se the string for "limiting", diga sim.
Se the string for "long", diga sim.
Se the string for "near", diga sim.
Se the string for "of", diga sim.
Se the string for "off", diga sim.
Se the string for "on", diga sim.
Se the string for "only", diga sim.
Se the string for "onto", diga sim.
Se the string for "out", diga sim.
Se the string for "outside", diga sim.
Se the string for "over", diga sim.
Se the string for "past", diga sim.
Se the string for "pointing", diga sim.
Se the string for "returning", diga sim.
Se the string for "right", diga sim.
Se the string for "rightward", diga sim.
Se the string for "rightways", diga sim.
Se the string for "shorter", diga sim.
Se the string for "sideway", diga sim.
Se the string for "sideways", diga sim.
Se the string for "similar", diga sim.
Se the string for "smaller", diga sim.
Se the string for "somewhere", diga sim.
Se the string for "slantwise", diga sim.
Se the string for "slantway", diga sim.
Se the string for "slantways", diga sim.
Se the string for "starting", diga sim.
Se the string for "tall", diga sim.
Se the string for "taller", diga sim.
Se the string for "thru", diga sim.
Se the string for "through", diga sim.
Se the string for "throughout", diga sim.
Se the string for "to", diga sim.
Se the string for "toward", diga sim.
Se the string for "towards", diga sim.
Se the string for "under", diga sim.
Se the string for "underneath", diga sim.
Se the string for "until", diga sim.
Se the string for "unto", diga sim.
Se the string for "up", diga sim.
Se the string for "upward", diga sim.
Se the string for "upon", diga sim.
Se the string for "using", diga sim.
Se the string for "via", diga sim.
Se the string for "while", diga sim.
Se the string for "wide", diga sim.
Se the string for "with", diga sim.
Se the string for "within", diga sim.
Se the string for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any qualifier:
Se the string estiver em branco, diga não.
Se the string's first's target for the left-paren pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any reverse-possessive:
\Se the string for "uv", diga sim.
Se the string for "de", diga sim.
\Se the string for "pertencente", diga sim.
\Se the string for "que pertence", diga sim.
\Se the string for "del", diga sim. \ short por "de el", expanded in "compile um term usando um percorredor e um field name (reverse-possessive)"
Diga não.

Etapas necessárias para que se determine se um percorredor está on any reverse-possessive:
Privatize the percorredor.
\CAL
\Se the percorredor's token for "uv", diga sim.
\PAL
\Se the string for "pertencente a", diga sim.
\Se the string for "pertencente ao", diga sim.
\Se the string for "que pertence a", diga sim.
\Se the string for "que pertence ao", diga sim.
\que consta
\que figura
\incorporada
\inerente
Se the percorredor's token não for "integrada de", diga não.
Se the percorredor's token não for "interna de", diga não.
Se the percorredor's token não for "interno de", diga não.
Se the percorredor's token não for "do registro de", diga não.
Se the percorredor's token não for "que está dentro de", diga não.
Se the percorredor's token não for "de dentro do registro de", diga não.
Se the percorredor's token não for "de dentro de", diga não.
Se the percorredor's token não for "que faz parte de", diga não.
Mova the percorredor (compilador rules).
Se the percorredor's token for any article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any string literal:
Se the string estiver em branco, diga não.
Se the string's first's target for the double-quote pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any symbol:
Se the string's length não for 1, diga não.
Se the string's first's target for any symbol, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any verb:
\PAL
Se the string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se the string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se the string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se the string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
Se the string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" to non-tempora state
Se the string for "ser", diga sim. \ "be"
Se the string for "for", diga sim. \ "be"
Se the string for "forem", diga sim. \ "be"
Se the string for "estiver", diga sim. \ "be"
Se the string for "estiverem", diga sim. \ "be"
Se the string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated in the singular third person (3ps) present, perm.
Se the string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated in the singular third person (3ps) present, temp.
Se the string for "são", diga sim. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, perm.
Se the string for "estão", diga sim. \ "are" are not \ aren't: "to be" conjugated in the plural third person (3pp) present, temp.
Se the string for "foi", diga sim. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
Se the string for "estava", diga sim. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
Se the string for "foram", diga sim. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
Se the string for "estavam", diga sim. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
Se the string for "será", diga sim. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
Se the string for "estará", diga sim. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
Se the string for "serão", diga sim. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
Se the string for "estarão", diga sim. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
Se the string for "supera", diga sim. \ beats, exceeds
Se the string for "superam", diga sim. \ beats, exceeds
Se the string for "excede", diga sim. \ beats, exceeds
Se the string for "excedem", diga sim. \ beats, exceeds
Se the string for "pode", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se the string for "puder", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se the string for "puderem", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se the string for "podem", diga sim. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
Se the string for "poderia", diga sim. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
Se the string for "poderia", diga sim. \ they "could" could not \ couldn't:  not used in CAL (3pp) added just in case
Se the string for "podemos", diga sim. \ we "could" could not \ couldn't: only once in Noodle (1pp) "Etapas necessárias para que se determine se we could encontre um endereço de memória:"
Se the string for "tem", diga sim. \ it "has" used in type definitions; (3ps) present
Se the string for "têm", diga sim. \ they "have" used in type definitions; (3pp) present
Se the string for "ter", diga sim. \ used in type definitions
Se the string for "possui", diga sim. \ it "has" used in type definitions; (3ps) present
Se the string for "possuem", diga sim. \ they "have" used in type definitions; (3pp) present
Se the string for "possuir", diga sim. \ used in type definitions
\\ trouble makers
Se the string for "inicia", diga sim. \ "begins" does not begin \ doesn't begin
Se the string for "começa", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se the string for "começar", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se the string for "termina", diga sim. \ "ends" does not end \ doesn't end
Se the string for "terminar", diga sim. \ "ends" does not end \ doesn't end
Se the string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
Se the string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
Se the string for "parece", diga sim. \ "looks" does not look \ doesn't look
Se the string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
Se the string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
Se the string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
\CAL
Se the string for "are", diga sim. \ are not \ aren't
Se the string for "be", diga sim. \
Se the string for "can", diga sim. \ cannot \ can't
Se the string for "cannot", diga sim. 
\Se the string for "could", diga sim. \ could not \ couldn't
\Se the string for "do", diga sim. \ does not \ don't
Se the string for "does", diga sim. \ does not \ doesn't
Se the string for "is", diga sim. \ não for \ isn't
Se the string for "may", diga sim. \ may not \ mayn't
Se the string for "should", diga sim. \ não deveria \ shouldn't
Se the string for "was", diga sim. \ was not \ wasn't
Se the string for "will", diga sim. \ will not \ won't
Se the string for "would", diga sim. \ would not \ wouldn't
Se the string for "has", diga sim. \ used in type definitions
Se the string for "have", diga sim. \ used in type definitions
Se the string ends with "n't", diga sim.
\\ trouble makers
Se the string for "begins", diga sim. \ does not begin \ doesn't begin
Se the string for "ends", diga sim. \ does not end \ doesn't end
Se the string for "looks", diga sim. \ does not look \ doesn't look
Se the string for "needs", diga sim. \ does not need \ doesn't need
Se the string for "starts", diga sim. \ does not start \ doesn't start
Diga não.

Etapas necessárias para que se determine se um string é the start of any definition:
\PAL
Se the string for "Passos", diga sim.
Se the string for "Etapas", diga sim.
\CAL
Se the string for "to", diga sim.
\default
Se the string for any indefinite article, diga sim.
Se the string for any definite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conditional:
\PAL
Se the string for "se", diga sim.
Se the string for "quando", diga sim.
\CAL
Se the string for "if", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any privatize:
\PAL
Se the string for "privatize", diga sim.
Se the string for "reserve", diga sim.
Se the string for "proteja", diga sim.
Se the string for "derive", diga sim.
\CAL
\Se the string for "privatize", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any loop:
\PAL
Se the string for "percorra", diga sim.
\Se the string for "ciclo", diga sim.
\Se the string for "laço", diga sim. \# muito usado em pseudo-codigo
\CAL
Se the string for "loop", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any break:
\PAL
Se the string for "pare", diga sim.
Se the string for "Suspenda de percorrer", diga sim.
Se the string for "Suspenda de repetir", diga sim.
Se the string for "cancele a operação", diga sim.
Se the string for "interrompa a operação", diga sim.
\CAL
Se the string for "break", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any exit:
\PAL
Se the string for "acabe", diga sim.
Se the string for "acabou", diga sim.
Se the string for "acabou-se", diga sim.
\Se the string for "advirta", diga sim.
\Se the string for "anuncie", diga sim.
\Se the string for "avise", diga sim.
Se the string for "cancele", diga sim.
Se the string for "desconsidere.", diga sim.
Se the string for "deixa quieto", diga sim.
Se the string for "deixe quieto", diga sim.
Se the string for "e mais nada", diga sim.
Se the string for "e pronto", diga sim.
Se the string for "e só", diga sim.
Se the string for "fim", diga sim.
Se the string for "fimse", diga sim.
Se the string for "ignore", diga sim.
\Se the string for "informe", diga sim.
Se the string for "prossiga", diga sim.
Se the string for "pronto", diga sim.
Se the string for "retorne", diga sim.
Se the string for "saia", diga sim.
Se the string for "siga adiante", diga sim.
Se the string for "terminamos", diga sim.
Se the string for "termine", diga sim.
\CAL
Se the string for "exit", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any repeat:
\PAL
Se the string for "repetir", diga sim. \# muito usado em pseudo-codigo
Se the string for "repita", diga sim. \# muito usado em pseudo-codigo
\CAL
Se the string for "repeat", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any say:
\PAL
Se the string for "diga", diga sim. \# modo imperativo
Se the string for "responda", diga sim. \# modo imperativo
Se the string for "informe", diga sim. \# modo imperativo
Se the string for "dizer", diga sim. \# modo infinitivo opcional.
\CAL
Se the string for "say", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any decide:
\PAL
\Se the string for "decidir", diga sim.
Se the string for "decida", diga sim.
\Se the string for "escolha", diga sim.
Se the string for "defina", diga sim.
Se the string for "determine", diga sim.
Se the string for "conclua", diga sim.
Se the string for "esclareça", diga sim.
Se the string for "esclareça", diga sim.
Se the string for "descubra", diga sim.
Se the string for "analise", diga sim.
\CAL
Se the string for "decide", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any call:
\PAL
Se the string for "chamar", diga sim.
\CAL
Se the string for "call", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any point:
\PAL
Se the string for "apontar", diga sim.
\CAL
Se the string for "point", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any employ:
\PAL
Se the string for "empregar", diga sim.
\CAL
Se the string for "employ", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any noise word: \Nova rotina 
Se the string for "already", diga sim.
Se the string for "still", diga sim.
Se the string for "yet", diga sim.
Se the string for "já", diga sim.
Se the string for "ainda", diga sim.
\Se the string for "que", diga sim.
\Se the string for "se", diga sim.
[more noise words here]
Diga não.

Etapas necessárias para que se determine se um string é the start of any expression:
Se the string for any sign, diga sim.
Se the string for any indefinite article, diga sim.
Se the string for any definite article, diga sim.
Se the string for any literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any global:
Se the string for any definite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any new local:
Se the string for any indefinite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any optional info:
\PAL
Se the string for "com", diga sim.
\CAL
Se the string for "to", diga sim.
Se the string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any routine:
\PAL
Se the string for "Passos", diga sim.
Se the string for "Etapas", diga sim.
Se the string for "Etapas Etapas necessárias para que se", diga sim.
Se the string for "Passos Etapas necessárias para que se", diga sim.
\CAL
Se the string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any statement:
Se the string for the start of any definition, diga não.
Se the string for any literal, diga não.
Se the string for any mark, diga não.
Se the string estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é the start of any type:
Se the string for any indefinite article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é the start of any variable:
Se the string for any definite article, diga sim.
\Se the string for "do", diga sim. \ this é iffy, here por reverse-possessives
Diga não.

Etapas necessárias para que se determine se um string has any stressed vowel:
Privatize the string.
Percorra.
Se the string estiver em branco, diga não.
Se the string's last's target for any stressed vowel, diga sim.
Subtraia 1 from the string's last.
Repita.

Etapas necessárias para que se determine se um term é vazio:
Se the term's variable não for inexistente, diga não.
Se the term's phrase não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um type puder ser reduzido para um string using the base name:
Se the type for inexistente, diga não.
Se the type's name for the string, diga sim.
Se the type's cooking sinal estiver verde, diga não.
Abra the type's cooking sinal.
Encontre um base type usando the type's base name e the type index.
Se the base type for inexistente, feche the type's cooking sinal; Diga não.
Se the base type puder ser reduzido para the string using the base name, feche the type's cooking sinal; say yes.
Feche the type's cooking sinal.
Diga não.

Etapas necessárias para que se determine se um type puder ser reduzido para um type name:
Se the type for inexistente, diga não.
Privatize the type.
Percorra.
Se the type for inexistente, diga não.
Se the type's name for the type name, diga sim.
Se the type's base type for the type, diga não.
Coloque the type's base type into the type.
Repita.

Etapas necessárias para que se determine se um type é any built-in type:
Se the type for inexistente, diga não.
Se the type for the type's base type, diga sim.
Diga não.

Etapas necessárias para que se determine se um type é value pushable:
Se the type for inexistente, diga não.
Se the type for inexistente, diga não.
Se the type's length for 4, diga sim.
Se the type's length for 2, diga sim.
Se the type's length for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser finalizado:
Se the type for inexistente, diga não.
Se the type puder ser reduzido para "substring", diga não.
Se the type puder ser reduzido para "string", diga sim.
Se the type's fields deveria ser finalizado, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser ignorado:
Se the type for inexistente, diga não.
\PAL
\Se the type's name for "elemento", diga não.
\Se the type's name for "elementos", diga não.
\CAL
Se the type's name for "coisa", diga não.
Se the type's name for "coisas", diga não.
Se the type puder ser reduzido para "coisas", diga sim.
Se the type não puder ser reduzido para "endereço de memória", diga não.
Se the type's target type for inexistente, diga não.
Se the type's target type não puder ser reduzido para "endereço de memória", diga sim.
Se the type's target type não deveria ser ignorado, diga não.
Diga sim.

Etapas necessárias para que se determine se uma variable é duplicated in alguns variables:
Obtenha another variable from the variables.
Se the other variable for inexistente, diga não.
Se the other variable's name estiver em branco, repita.
Se the other variable for the variable, repita.
Se the other variable's name for the variable's name, diga sim.
Repita.

The dereference tag é uma tag igual a 5.

An dos header é um conjunto with
An wyrd called signature,
An wyrd called numberofbytesonlastpage,
An wyrd called numberofpages,
An wyrd called relocuss,
An wyrd called sizeofheaderinparagraphs,
An wyrd called minimumextraparagraphs,
An wyrd called maximumextraparagraphs,
An wyrd called initialrelativess,
An wyrd called initialsp,
An wyrd called initialchecksum,
An wyrd called initialip,
An wyrd called initialirelativecs,
An wyrd called addressofrelocationtableinfile,
An wyrd called overlynumber,
8 pedaços called resveredbytes,
An wyrd called oemidentifier,
An wyrd called oeminfo,
20 pedaços called reservedwords,  
An número called addressofpeheaderinfile.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variables:
Crie um index usando 101.
Eliminate duplicate nicknames from the variables usando the index.
Destroy the index.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variables usando um index:
Se the index for inexistente, cancele.
Percorra.
Obtenha uma variable from the variables.
Se the variable for inexistente, cancele.
Eliminate duplicate nicknames usando the variable e the index.
Repita.

Etapas necessárias para que se eliminate duplicate nicknames usando uma variable e um index:
Se the variable for inexistente, cancele.
Se the index for inexistente, cancele.
Encontre another variable usando the variable's nickname e the index.
Se the other variable for inexistente, encontre the other variable usando the variable's name e the index.
Se the other variable for inexistente, catalogue the variable usando the variable's nickname e the index; exit.
Limpe the other variable's nickname.
Limpe the variable's nickname.

The end if tag é uma tag igual a 6.

An entry é uma coisa with
An name address,
An thunk address,
An name,
An address.

The epilog tag é uma tag igual a 7.

The exit tag é uma tag igual a 8.

An expression é um term.

Etapas necessárias para que se extend um string with another string:
Se the other string estiver em branco, cancele.
Se the string não estiver em branco, posponha the space pedaço to the string.
Posponha the other string to the string.

An field é uma variable.

An field term é um conjunto with
An dereference sinal,
An field (reference),
An function routine (reference),
An push sinal.

Etapas necessárias para que se finalize the compilador:
Destroy the utility index.
Destroy the routine index.
Destroy the literal index.
Destroy the global index.
Destroy the type index.
Destroy the imports.
Destroy the routines.
Destroy the literals.
Destroy the globals.
Destroy the types.
Destroy the source files.

The finalize tag é uma tag igual a 9.

Etapas necessárias para que se encontre um entry usando um string e alguns entries:
Esvazie the entry.
Percorra.
Obtenha the entry from the entries.
Se the entry for inexistente, cancele.
Se the entry's name for the string, cancele.
Repita.

Etapas necessárias para que se encontre um field term usando um phrase e um type e um name:
Limpe the field term.
Encontre the field term usando the type e the name.
Se the field term's field não for inexistente, cancele.
Se the phrase não estiver em branco, encontre uma routine usando "coloque" e the phrase e "'s " then the name e "into".
Se the routine não for inexistente, coloque the routine into the field term's function; exit.
Se the type for inexistente, cancele.
Encontre the routine usando "coloque" e the type e "'s " then the name e "into".
Se the routine não for inexistente, abra the field term's push sinal; coloque the routine into the field term's function; exit.
\  code below por looking deep within endereço de memórias - um debatable feature
\  if the type's target type não for inexistente, encontre the routine usando "coloque" e the type's target type e "'s " then the name e "into".
\  if the routine não for inexistente, abra the field term's dereference sinal; coloque the routine into the field term's function; exit.

Etapas necessárias para que se encontre um field term usando um type e um name:
Se the type for inexistente, cancele.
Encontre um field usando the name e the type's fields.
Se the field não for inexistente, coloque the field into the field term's field; exit.
Se the type's target type não for inexistente, encontre the field usando the name e the type's target type's fields.
Se the field não for inexistente, abra the field term's dereference sinal; coloque the field into the field term's field; exit.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag:
Coloque the other fragment into the fragment.
Percorra.
Se the fragment for inexistente, cancele.
Se the fragment's tag for the tag, cancele.
Coloque the fragment's next into the fragment.
Repita.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag (backwards):
Coloque the other fragment into the fragment.
Percorra.
Se the fragment for inexistente, cancele.
Se the fragment's tag for the tag, cancele.
Coloque the fragment's previous into the fragment.
Repita.

Etapas necessárias para que se encontre um import usando um string:
Esvazie the import.
Percorra.
Obtenha the import from the imports.
Se the import for inexistente, cancele.
Se the import's name for the string, cancele.
Repita.

Etapas necessárias para que se encontre um path e um row# usando um pedaço endereço de memória:
Limpe the path.
Coloque 0 into the row#.
Encontre um source file usando the pedaço endereço de memória.
Se the source file for inexistente, cancele.
Coloque the source file's path into the path.
Encontre the row# usando the source file e the pedaço endereço de memória.

Etapas necessárias para que se encontre uma routine usando um moniker e um monikette e um index:
Se the monikette for inexistente, cancele.
Esvazie the routine.
Privatize the moniker.
Coloque the monikette's type into the monikette's current type.
Lance the monikette's current substring on the monikette's string.
Percorra.
Posponha the monikette to the moniker (while bubbling).
Encontre um refer usando the moniker e the index.
Se the refer não for inexistente, coloque the refer's endereço de memória into the routine.
Se the refer não for inexistente, encontre the routine usando the moniker e the monikette's next e the index.
Se the routine não for inexistente, pare.
Bubble the monikette.
Se the monikette estiver bubbled out, pare.
Coloque the original moniker into the moniker.
Repita.

Etapas necessárias para que se encontre uma routine usando alguns monikettes:
Esvazie the routine.
Encontre the routine usando um moniker e the monikettes' first e the routine index.

Etapas necessárias para que se encontre uma routine usando um string e another string e um third string e um fourth string:
Adicione um monikette to alguns monikettes usando the string.
Adicione another monikette to the monikettes usando the other string.
Adicione um third monikette to the monikettes usando the third string.
Adicione um fourth monikette to the monikettes usando the fourth string.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type:
Adicione um monikette to alguns monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e another type:
Adicione um monikette to alguns monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the other type.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um third string:
Adicione um monikette to alguns monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the third string.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um third string e um fourth string e um fifth string:
Adicione um monikette to alguns monikettes usando the string.
Adicione another monikette to the monikettes usando the type.
Adicione um third monikette to the monikettes usando the other string.
Adicione um fourth monikette to the monikettes usando the third string.
Adicione um fifth monikette to the monikettes usando the fourth string.
Adicione um sixth monikette to the monikettes usando the fifth string.
Encontre the routine usando the monikettes.
Destroy the monikettes.

Etapas necessárias para que se encontre um row# usando um source file e um pedaço endereço de memória:
Se the pedaço endereço de memória for inexistente, coloque 0 into the row#; exit.
Lance um substring on the source file's buffer.
Coloque 1 into the row#.
Percorra.
Se the substring estiver em branco, cancele.
Se the substring's first for the pedaço endereço de memória, cancele.
Se the substring's first's target for the return pedaço, adicione 1 to the row#.
Adicione 1 to the substring's first.
Repita.

Etapas necessárias para que se encontre um source file usando um pedaço endereço de memória:
Se the pedaço endereço de memória for inexistente, esvazie the source file; exit.
Percorra.
Obtenha the source file from the source files.
Se the source file for inexistente, cancele.
Se the pedaço endereço de memória for menor do que the source file's buffer's first, repita.
Se the pedaço endereço de memória for maior do que the source file's buffer's last, repita.

Etapas necessárias para que se encontre um type e um nickname usando um name:
Esvazie the type.
Limpe the nickname.
Encontre the type e the nickname usando the name (forward).
Se the type não for inexistente, cancele.
Encontre the type e the nickname usando the name (backward).
\Lance um substring on the name.
\Percorra.
\Se the substring estiver em branco, cancele.
\Encontre the type usando the substring e the type index.
\Se the type não for inexistente, pare.
\Skip to the next word in the substring.
\Repita.
\Coloque the name's first into another substring's first.
\Coloque the substring's first minus 2 into the other substring's last.
\Se the other substring não estiver em branco, coloque the other substring into the nickname.
\Se the other substring estiver em branco, coloque the substring into the nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (backward):
Esvazie the type.
Limpe the nickname.
Lance um substring on the name.
Percorra.
Se the substring estiver em branco, cancele.
Encontre the type usando the substring e the type index.
Se the type não for inexistente, pare.
Skip to the previous word in the substring.
Repita.
Coloque the name's last into another substring's last.
Coloque the substring's last plus 2 into the other substring's first.
Se the other substring não estiver em branco, coloque the other substring into the nickname.
Se the other substring estiver em branco, coloque the substring into the nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (forward):  \ original - no mude
Esvazie the type.
Limpe the nickname.
Lance um substring on the name.
Percorra.
Se the substring estiver em branco, cancele.
Encontre the type usando the substring e the type index.
Se the type não for inexistente, pare.
Skip to the next word in the substring.
Repita.
Coloque the name's first into another substring's first.
Coloque the substring's first minus 2 into the other substring's last.
Se the other substring não estiver em branco, coloque the other substring into the nickname.
Se the other substring estiver em branco, coloque the substring into the nickname.

Etapas necessárias para que se encontre uma variable usando um name:
Se the current routine for inexistente, esvazie the variable; exit.
Encontre the variable usando the name e the current routine's locals.
Se the variable não for inexistente, cancele.
Encontre the variable usando the name e the current routine's parameters.
Se the variable não for inexistente, cancele.
Encontre the variable usando the name e the global index.
Se the variable não for inexistente, cancele.
Encontre the variable usando the name e the literal index.

Etapas necessárias para que se encontre uma variable usando um name e alguns variables:
Esvazie the variable.
Percorra.
Obtenha the variable from the variables.
Se the variable for inexistente, cancele.
Se the variable's name for the name, cancele.
Se the variable's nickname for the name, cancele.
Repita.


\Etapas necessárias para que se encontre uma variable usando um name:
\Se the current routine for inexistente, esvazie the variable; exit.
\Encontre the variable usando the name e the current routine's locals.
\Se the variable não for inexistente, cancele.
\Encontre the variable usando the name e the current routine's parameters.
\Se the variable não for inexistente, cancele.
\Encontre the variable usando the name e the global index.
\Se the variable não for inexistente, cancele.
\ Encontre the variable usando the name e the literal index.

\Etapas necessárias para que se encontre uma variable usando um name e alguns variables:
\esvazie the variable.
\Percorra.
\Obtenha the variable from the variables.
\Se the variable for inexistente, cancele.
\Se the variable's name é the name, cancele.
\Se the variable's nickname é the name, cancele.
\Repita.

An fragment é uma coisa with
An tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
An variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
An routine (reference) [call internal, routine address],
An entry (reference) [call external],
An número [increment],
An sinal [load eax], \SAL
An address,
An texto hexadecimal called code.

Etapas necessárias para que se gere um name usando um string:
Coloque the string into the name.
Adicione 1 to the compilador's name count.
Convert the compilador's name count to another string.
Posponha the other string to the name.

Etapas necessárias para que se obtenha um address usando uma routine:
Se the routine's address não for 0, coloque the routine's address into the address; exit.
Coloque -1 into the routine's address.
Encontre another routine usando the routine's employs moniker e the routine index.
Se the other routine for inexistente, abort with "Eu não consegui encontrar um tarefa '" then the routine's employs moniker then "' que você está tentando employ." e the routine's locus; exit.
Se the other routine's address for -1, abort with "Referência recursiva na cláusula employ." e the routine's locus; exit. \Bora traduzir
Obtenha the address usando the other routine.
Coloque the address into the routine's address.

Etapas necessárias para que se obtenha um count usando alguns imports (all entries plus markers):
Coloque 0 into the count.
Percorra.
Obtenha um import from the imports.
Se the import for inexistente, cancele.
Adicione the import's entries' count to the count.
Adicione 1 to the count.
Repita.

An global body é um substring.

The global index é um index.

An global é uma variable.

The globals are alguns globals.

The image base é um address igual a 4194304 [$00400000].

The import borough é um borough.

An import header é um conjunto with
An address called original first thunk,
An número called timestamp,
An address called forwarder chain,
An address called name memory address,
An address called first thunk memory address.

An import é uma coisa with
An name address,
An header address,
An name,
An import header,
Some entries.

The imports are alguns imports.

The increment tag é uma tag igual a 10.

Etapas necessárias para que se catalogue um global:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the global for inexistente, cancele.
Se the global's name estiver in the global index, abort with "'" then the global's name then "' é uma variável global duplicada." e the global's locus; exit.
Catalogue the global usando the global's name e the global index.

Etapas necessárias para que se catalogue um literal:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the literal for inexistente, cancele.
Se the literal's name estiver in the literal index, abort with "Erro interno no nome do literal na função index um literal" e the literal's locus; exit.
Catalogue the literal usando the literal's name e the literal index.

Etapas necessárias para que se catalogue um partial moniker usando um index (special):
Encontre um refer usando the partial moniker e the index.
Se the refer não for inexistente, cancele.
Catalogue the partial moniker in the index.

Etapas necessárias para que se catalogue uma routine por utility use:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the routine for inexistente, cancele.
Se the routine's function sinal estiver verde, cancele.
Se the routine's parameters' count for 0, cancele.
Copy the routine's monikettes into alguns monikettes.
Reduce the monikettes por utility use.
Convert the monikettes to um moniker.
Destroy the monikettes.
Se the moniker estiver in the routine index, cancele.
Encontre um refer usando the moniker e the utility index.
Se the refer não for inexistente, coloque nil into the refer's endereço de memória; exit.
Catalogue the routine usando the moniker e the utility index.

Etapas necessárias para que se catalogue uma routine usando um moniker e um index (special):
Encontre um refer usando the moniker e the index.
Se the refer não for inexistente, coloque the routine into the refer's endereço de memória; exit.
Catalogue the routine usando the moniker e the index.

Etapas necessárias para que se catalogue uma routine usando alguns monikettes e um index:
Se the routine for inexistente, cancele.
Limpe um partial moniker.
Percorra.
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Posponha the monikette to the partial moniker.
Se the monikette for the monikettes' last, pare.
Catalogue the partial moniker usando the index (special).
Repita.
Catalogue the routine usando the partial moniker como um moniker e the index (special).

Etapas necessárias para que se catalogue alguns routines por utility use:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Catalogue the routine por utility use.
Repita.

Etapas necessárias para que se catalogue um type:
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Catalogue the type usando the type's name.

Etapas necessárias para que se catalogue um type usando um name:
Se the type for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Encontre um existing type usando the name e the type index.
Se the existing type for inexistente, catalogue the type usando the name e the type index; exit.
Coloque the type's locus into um locus.
Se the locus for inexistente, coloque the existing type's locus into the locus. \ point the error to um type in the source code, not um generated type
Abort with "Acho que já vi o tipo '" then the name then "' em algum lugar antes; você deve ter duplicado ele." e the locus.

The indexing utilities timer é um timer.

Etapas necessárias para que se initialize the compilador:

Etapas necessárias para que se initialize the compilador usando um directory:
Coloque the directory into the compilador's directory.
Coloque 0 into the compilador's name count.
Feche the compilador's sinal de alerta.
Limpe the compilador's mensagem de erro.
Limpe the compilador's abort path.
Coloque 0 into the compilador's abort row#.
Esvazie the current routine.
Crie the type index with 13001 [buckets]. \ was 4027
Crie the global index with 13001 [buckets]. \ was 4027
Crie the literal index with 13001 [buckets]. \ was 4027
Crie the routine index with 13001 [buckets]. \ was 7919
Crie the utility index with 13001 [buckets]. \ was 4027

Etapas necessárias para que se initialize um dos header:
Coloque 23117 [$5A4D] into the dos header's signature.
Coloque 64 [$0040] into the dos header's addressofrelocationtableinfile.
Coloque 256 [$00000100] into the dos header's addressofpeheaderinfile.

Etapas necessárias para que se initialize um pe header:
Initialize the pe header (standard header).
Initialize the pe header (optional header).
Initialize the pe header (version information).
Initialize the pe header (directories).
Initialize the pe header (import section).
Initialize the pe header (data section).
Initialize the pe header (code section).

Etapas necessárias para que se initialize um pe header (code section):
Copy pedaços from "code  "'s first to the pe header's code section's name's whereabouts por 6.
Coloque the code borough's length into the pe header's code section's sizeinbytes.
Coloque the code borough's base into the pe header's code section's addressinmemory.
Coloque the code borough's length into the pe header's code section's sizeinfile.
Coloque the code borough's base into the pe header's code section's addressinfile.
Coloque -536870880 [$E0000020] into the pe header's code section's characteristics. \ executable, readable, writable, code object

Etapas necessárias para que se initialize um pe header (data section):
Copy pedaços from "data  "'s first to the pe header's data section's name's whereabouts por 6.
Coloque the data borough's length into the pe header's data section's sizeinbytes.
Coloque the data borough's base into the pe header's data section's addressinmemory.
Coloque the data borough's length into the pe header's data section's sizeinfile.
Coloque the data borough's base into the pe header's data section's addressinfile.
Coloque -1073741760 [$C0000040] into the pe header's data section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um pe header (directories):
Coloque 16 [$00000010] into the pe header's numberofdirectories.
Coloque the import borough's base into the pe header's imagedirectoryentryimportaddress.
Coloque the import borough's length into the pe header's imagedirectoryentryimportsize.

Etapas necessárias para que se initialize um pe header (import section):
Copy pedaços from "idata "'s first to the pe header's idata section's name's whereabouts por 6.
Coloque the import borough's length into the pe header's idata section's sizeinbytes.
Coloque the import borough's base into the pe header's idata section's addressinmemory.
Coloque the import borough's length into the pe header's idata section's sizeinfile.
Coloque the import borough's base into the pe header's idata section's addressinfile.
Coloque -1073741760 [$C0000040] into the pe header's idata section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um pe header (optional header):
Coloque 267 [$010B] into the pe header's magicnumber.
Coloque the code borough's length into the pe header's sizeofcodeinfile.
Coloque the data borough's length into the pe header's sizeofinitializeddatainfile.
Coloque 0 into the pe header's sizeofuninitializeddatainfile.
Encontre uma routine usando "~initialize before run e run e finalize after run" e the routine index.
Se the routine for inexistente, abort with "Erro interno: não achei a tarefa de inicialização"; exit.
Coloque the routine's address minus the image base into the pe header's addressofentrypointinmemory.
Coloque the code borough's base into the pe header's addressofcodeinmemory.
Coloque the data borough's base into the pe header's addressofinitializeddatainmemory.
Coloque the image base into the pe header's imagebase.
Coloque 4096 [$00001000] into the pe header's memoryalignment.
Coloque 4096 [$00001000] into the pe header's filealignment.
Coloque 0 into the pe header's reserved.
Coloque the compilador's exe size into the pe header's sizeofimageinmemory.
Coloque 4096 [section base] into the pe header's sizeofallheadersinfile.
Coloque 0 into the pe header's checksum.
Coloque 0 into the pe header's dllcharacteristics.
Coloque 1048576 [$00100000] into the pe header's maxstack.
Coloque 16384 [$00004000] into the pe header's minstack.
Coloque 1048576 [$00100000] into the pe header's maxheap.
Coloque 16384 [$00004000] into the pe header's minheap.
Coloque 0 into the pe header's loadersinals.

Etapas necessárias para que se initialize um pe header (standard header):
Coloque 17744 [$00004550] into the pe header's signature.
Coloque 332 [$014C] into the pe header's machinetype.
Coloque 3 [$0003] into the pe header's numberofsections.
Coloque 0 into the pe header's timestamp.
Coloque 0 into the pe header's pointertosymboltable.
Coloque 0 into the pe header's numberofsymbols.
Coloque 224 [$00E0] into the pe header's sizeofoptionalheaderinbytes.
Coloque 33166 [$818E] into the pe header's characteristics.

Etapas necessárias para que se initialize um pe header (version information):
Coloque 0 into the pe header's majorlinkerversion.
Coloque 0 into the pe header's minorlinkerversion.
Coloque 4 [$0004] into the pe header's osmajorversion.
Coloque 0 [$0000] into the pe header's osminorversion.
Coloque 0 into the pe header's usermajorversion.
Coloque 0 into the pe header's userminorversion.
Coloque 4 [$0004] into the pe header's subsystemmajorversion.
Coloque 0 [$0000] into the pe header's subsystemminorversion.
Coloque 2 [$0002] into the pe header's subsystem.

The intel tag é uma tag igual a 11.

An intermediate é um local.

The jump false tag é uma tag igual a 12.

Etapas necessárias para que se link:
Round up borough sizes.
Initialize um dos header.
Initialize um pe header.
Fill the compilador's exe with the null pedaço usando the compilador's exe size.
Blurt the dos header into the compilador's exe.
Blurt the pe header into the compilador's exe.
Blurt the imports into the compilador's exe.
Blurt the globals into the compilador's exe.
Blurt the literals into the compilador's exe.
Blurt the routines into the compilador's exe.

The linking timer é um timer.

Etapas necessárias para que se list:
Limpe the compilador's listing.
List the compilador's mensagem de erro in the compilador's listing.
List the types under "TYPES:" in the compilador's listing.
List the globals under "GLOBALS:" in the compilador's listing.
List the literals under "LITERALS:" in the compilador's listing.
List the routines under "ROUTINES:" in the compilador's listing.
List the type index under "TYPE INDEX:" in the compilador's listing.
List the global index under "GLOBAL INDEX:" in the compilador's listing.
List the literal index under "LITERAL INDEX:" in the compilador's listing.
List the routine index under "ROUTINE INDEX:" in the compilador's listing.
List the utility index under "UTILITY INDEX:" in the compilador's listing.
List the imports under "IMPORTS:" in the compilador's listing.
List the source files under "SOURCE FILES:" in the compilador's listing.
List the timers under "TIMERS:" in the compilador's listing.
Escreva the compilador's listing to the compilador's listing path.

Etapas necessárias para que se list um mensagem de erro in um buffer:
Se the mensagem de erro estiver em branco, cancele.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" to the buffer.
Advance the buffer (twice).
Posponha the mensagem de erro to the buffer.
Advance the buffer (twice).

Etapas necessárias para que se list um bucket in um buffer:
Se the bucket's refers estiverem vazio, cancele.
Posponha "/bucket" to the buffer (with separator).
Advance the buffer.
List the bucket's refers in the buffer.
Advance the buffer.

Etapas necessárias para que se list alguns entries in um buffer:
Obtenha um entry from the entries.
Se the entry for inexistente, cancele.
List the entry in the buffer.
Repita.

Etapas necessárias para que se list um entry in um buffer:
Se the entry for inexistente, cancele.
Posponha "/entry" to the buffer (with separator).
Posponha the entry's name to the buffer (with separator).
Posponha the entry's address to the buffer (as hex with separator).
Advance the buffer.

Etapas necessárias para que se list um fragment in um buffer:
Posponha "/fragment" to the buffer (with separator).
Posponha the fragment's tag to the buffer (as um fragment tag string with separator).
Posponha the fragment's variable to the buffer (with separator).
Posponha the fragment's other variable to the buffer (with separator).
Posponha the fragment's routine to the buffer (with separator).
Posponha the fragment's entry to the buffer (with separator).
Posponha the fragment's número to the buffer (as hex with separator).
Posponha the fragment's address to the buffer (as hex with separator).
Convert the fragment's code to um nibble string.
Posponha the nibble string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list alguns fragments in um buffer:
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
List the fragment in the buffer.
Repita.

Etapas necessárias para que se list um import in um buffer:
Se the import for inexistente, cancele.
Posponha "/import" to the buffer (with separator).
Posponha the import's name to the buffer (with separator).
Advance the buffer.
List the import's entries in the buffer.
Advance the buffer.

Etapas necessárias para que se list alguns imports in um buffer:
Obtenha um import from the imports.
Se the import for inexistente, cancele.
List the import in the buffer.
Repita.

Etapas necessárias para que se list alguns imports under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the imports estiverem vazio, cancele.
List the imports in the buffer.

Etapas necessárias para que se list um index in um buffer:
Posponha "/" then the index's used bucket count then " buckets" to the buffer (with separator).
Posponha the index's count then " refers" to the buffer (with separator).
Advance the buffer (twice).
Percorra.
Obtenha um bucket usando the index.
Se the bucket for inexistente, cancele.
List the bucket in the buffer.
Repita.

Etapas necessárias para que se list um index under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the index estiver vazio, cancele.
List the index in the buffer.

Etapas necessárias para que se list um refer in um buffer:
Se the refer for inexistente, cancele.
Posponha "/refer" to the buffer (with separator).
Posponha the refer's string to the buffer.
Se the refer's endereço de memória for inexistente, posponha "..." to the buffer.
Posponha "/" to the buffer.
Advance the buffer.

Etapas necessárias para que se list alguns refers in um buffer:
Obtenha um refer from the refers.
Se the refer for inexistente, cancele.
List the refer in the buffer.
Repita.

Etapas necessárias para que se list uma routine in um buffer:
Se the routine for inexistente, cancele.
Posponha "/routine" to the buffer (with separator).
Posponha the routine's moniker to the buffer (with separator).
Posponha the routine's compiled sinal to the buffer (with separator).
Posponha the routine's callback sinal to the buffer (with separator).
Posponha the routine's decider sinal to the buffer (with separator).
Posponha the routine's function sinal to the buffer (with separator).
Posponha the routine's employs moniker to the buffer (with separator).
Posponha the routine's parameter size to the buffer (with separator).
Posponha the routine's local size to the buffer (with separator).
Posponha the routine's address to the buffer (as hex with separator).
Advance the buffer.
List the routine's parameters in the buffer.
List the routine's locals in the buffer.
List the routine's fragments in the buffer.
Advance the buffer.

Etapas necessárias para que se list alguns routines in um buffer:
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
List the routine in the buffer.
Repita.

Etapas necessárias para que se list alguns routines under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the routines estiverem vazio, cancele.
List the routines in the buffer.

Etapas necessárias para que se list um source file in um buffer:
Se the source file for inexistente, cancele.
Posponha "/source file" to the buffer (with separator).
Posponha the source file's path to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list alguns source files in um buffer:
Obtenha um source file from the source files.
Se the source file for inexistente, cancele.
List the source file in the buffer.
Repita.

Etapas necessárias para que se list alguns source files under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the source files estiverem vazio, cancele.
List the source files in the buffer.
Advance the buffer.

Etapas necessárias para que se list um timer usando um string in um buffer:
Posponha "/timer" to the buffer (with separator).
Posponha the string to the buffer (with separator).
Posponha the timer's string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list the timers under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
List the loading timer usando "loading" in the buffer.
List the scanning timer usando "scanning" in the buffer.
List the resolving types timer usando "resolving types" in the buffer.
List the resolving globals timer usando "resolving globals" in the buffer.
List the compiling routine headers timer usando "compiling routine headers" in the buffer.
List the calculating timer usando "calculating" in the buffer.
List the adding built-in memory routines timer usando "adding built-in memory routines" in the buffer.
List the indexing utilities timer usando "indexing utilities" in the buffer.
List the compiling routine bodies timer usando "compiling routine bodies" in the buffer.
List the adding built-in startup routine timer usando "adding built-in startup routine" in the buffer.
List the offsetting timer usando "offsetting" in the buffer.
List the addressing timer usando "addressing" in the buffer.
List the transmogrifying timer usando "transmogrifying" in the buffer.
List the linking timer usando "linking" in the buffer.
List the writing timer usando "writing" in the buffer.
List the compilador's timer usando "total" in the buffer.
Advance the buffer.

Etapas necessárias para que se list um type in um buffer:
Se the type for inexistente, cancele.
Posponha "/type" to the buffer (with separator).
Posponha the type's name to the buffer (with separator).
Posponha the type's plural name to the buffer (with separator).
Posponha the type's length to the buffer (as hex with separator).
Posponha the type's base name to the buffer (with separator).
Posponha the type's base type to the buffer (with separator).
Posponha the type's target name to the buffer (with separator).
Posponha the type's target type to the buffer (with separator).
Posponha the type's scale to the buffer (with separator).
Advance the buffer.
List the type's fields in the buffer.
Advance the buffer.

Etapas necessárias para que se list alguns types in um buffer:
Obtenha um type from the types.
Se the type for inexistente, cancele.
List the type in the buffer.
Repita.

Etapas necessárias para que se list alguns types under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the types estiverem vazio, cancele.
List the types in the buffer.

Etapas necessárias para que se list uma variable in um buffer:
Se the variable for inexistente, cancele.
Posponha "/variable" to the buffer (with separator).
Posponha the variable's kind to the buffer (with separator).
Posponha the variable's compiled sinal to the buffer (with separator).
Posponha the variable's name to the buffer (with separator).
Posponha the variable's nickname to the buffer (with separator).
Posponha the variable's type name to the buffer (with separator).
Posponha the variable's type to the buffer (with separator).
Posponha the variable's address [or offset] to the buffer (as hex with separator).
Posponha the variable's by-value sinal to the buffer (with separator).
Posponha the variable's count to the buffer (with separator).
Posponha the variable's reference sinal to the buffer (with separator).
Posponha the variable's redefinition target name to the buffer (with separator).
Posponha the variable's literal to the buffer (with separator).
Convert the variable's data to um nibble string.
Posponha the nibble string to the buffer (with separator).
Advance the buffer.

Etapas necessárias para que se list alguns variables in um buffer:
Obtenha uma variable from the variables.
Se the variable for inexistente, cancele.
List the variable in the buffer.
Repita.

Etapas necessárias para que se list alguns variables under um string in um buffer:
Posponha the string to the buffer.
Advance the buffer (twice).
Se the variables estiverem vazio, cancele.
List the variables in the buffer.
Advance the buffer.

The literal index é um index.

An literal é uma variable.

The literals are alguns literals.

The load address tag é uma tag igual a 13.

The load eax tag é uma tag igual a 14.

An local é uma variable.

An locus é um pedaço endereço de memória.

The loop tag é uma tag igual a 15.

An moniker é um string.

An monikette é uma coisa with
An string,
An type (reference),
An variable (reference),
\ por bubbling
An current type (reference),
An current substring.

Etapas necessárias para que se mova um percorredor (code rules - comment):
Avance the percorredor.
Se the percorredor's source estiver em branco, cancele.
Se the percorredor's source's first's target não for the return pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - glom):
Avance the percorredor.
Se the percorredor's source estiver em branco, cancele.
Se the percorredor está on any possessive, cancele.
Se the percorredor's source's first's target é any glom pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - mark):
Avance the percorredor.

Etapas necessárias para que se mova um percorredor (code rules - noise):
Avance the percorredor.
Se the percorredor's source estiver em branco, cancele.
Se the percorredor's source's first's target é noise, repita.

Etapas necessárias para que se mova um percorredor (code rules - possessive):
Avance the percorredor.
Se the percorredor's source estiver em branco, cancele.
Se the percorredor's source starts with "s", avance the percorredor.

Etapas necessárias para que se mova um percorredor (code rules - qualifier):
Se the percorredor's source estiver em branco, cancele.
Se the percorredor's source's first's target for the return pedaço, pare.
Se the percorredor's source's first's target for the left-paren pedaço, adicione 1 to um count.
Se the percorredor's source's first's target for the right-paren pedaço, subtraia 1 from the count.
Avance the percorredor.
Se the count for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - remark):
Se the percorredor's source estiver em branco, cancele.
Se the percorredor's source's first's target for the return pedaço, pare.
Se the percorredor's source's first's target for the left-bracket pedaço, adicione 1 to um count.
Se the percorredor's source's first's target for the right-bracket pedaço, subtraia 1 from the count.
Avance the percorredor.
Se the count for 0, pare.
Repita.  

Etapas necessárias para que se mova um percorredor (code rules - string):
Avance the percorredor.
Se the percorredor's source estiver em branco, cancele.
Se the percorredor's source's first's target for the return pedaço, cancele.
Se the percorredor estiver on any nested double-quote, avance the percorredor; repeat.
Se the percorredor's source's first's target for the double-quote pedaço, avance the percorredor; exit.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - symbol):
Avance the percorredor.

Etapas necessárias para que se mova um percorredor (code rules):
Position the percorredor's token on the percorredor's source.
Se the percorredor's source estiver em branco, cancele.
Se the percorredor's source's first's target for noise, mova the percorredor (code rules - noise); exit.
Se the percorredor's source's first's target for the backslash pedaço, mova the percorredor (code rules - comment); exit.
Se the percorredor's source's first's target for the left-bracket pedaço, mova the percorredor (code rules - remark); exit.
Se the percorredor's source's first's target for the double-quote pedaço, mova the percorredor (code rules - string); exit.
Se the percorredor's source's first's target for the left-paren pedaço, mova the percorredor (code rules - qualifier); exit.
Se the percorredor's source's first's target for any mark, mova the percorredor (code rules - mark); exit.
Se the percorredor estiver on any possessive, mova the percorredor (code rules - possessive); exit.
Mova the percorredor (code rules - glom).

Etapas necessárias para que se mova um percorredor (compilador rules):
Se the compilador's sinal de alerta estiver verde, limpe o percorredor's token; exit.
Mova the percorredor returning um error string (code rules).
Se the error string não estiver em branco, abort with the error string e the percorredor's token's first; exit.
\Se the percorredor's token for "del", unbump the percorredor; exit. \ Spanish contraction "del"; fudged to "de l", short por "de el"
\Se the percorredor's token for "al", unbump the percorredor; exit. \ Spanish contraction "al"; fudged to "a l", short por "a el"
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token's first's target for noise, repita.
Se the percorredor's token's first's target for the backslash pedaço, repita.
Se the percorredor's token's first's target for the left-bracket pedaço, repita.

Etapas necessárias para que se mova um percorredor returning um error string (code rules - validate qualifier):
Se the percorredor's token's length for menor do que 2, coloque "Qualifiers need to end with ')'." into the error string; exit.
Se the percorredor's token's last's target não for the right-paren pedaço, coloque "Qualifiers need to end with ')'." into the error string; exit.

Etapas necessárias para que se mova um percorredor returning um error string (code rules - validate remark):
Se the percorredor's token's length for menor do que 2, coloque "Remarks need to end with ']'." into the error string; exit.
Se the percorredor's token's last's target não for the right-bracket pedaço, coloque "Remarks need to end with ']'." into the error string; exit.

Etapas necessárias para que se mova um percorredor returning um error string (code rules - validate string):
Se the percorredor's token's length for menor do que 2, coloque "Strings need to end with '""'." into the error string; exit.
Se the percorredor's token's last's target não for the double-quote pedaço, coloque "Strings need to end with '""'." into the error string; exit.

Etapas necessárias para que se mova um percorredor returning um error string (code rules):
Limpe the error string.
Mova the percorredor (code rules).
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token's first's target for the left-bracket pedaço, mova the percorredor returning the error string (code rules - validate remark); exit.
Se the percorredor's token's first's target for the double-quote pedaço, mova the percorredor returning the error string (code rules - validate string); exit.
Se the percorredor's token's first's target for the left-paren pedaço, mova the percorredor returning the error string (code rules - validate qualifier); exit.

An nibble substring é um substring.

An nickname é um name.

The not tag é uma tag igual a 16.

Etapas necessárias para que se offset the locals in uma routine:
Se the routine for inexistente, cancele.
Se the routine's compiled sinal não estiver verde, cancele.
Limpe the routine's local size.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um local from the routine's locals.
Se the local for inexistente, cancele.
Se the local's previous não for inexistente, coloque the local's previous' offset into the local's offset.
Coloque the local's type's length into um length.
Se the local's kind for "scratch", coloque um endereço de memória's magnitude into the length.
Round the length up to the nearest multiple of 4.
Subtraia the length from the local's offset.
Adicione the length to the routine's local size.
Repita.

Etapas necessárias para que se offset the locals in alguns routines:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Offset the locals in the routine.
Repita.

Etapas necessárias para que se offset the parameters in uma routine:
Se the routine for inexistente, cancele.
Se the routine's compiled sinal não estiver verde, cancele.
Limpe the routine's parameter size.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um parameter from the routine's parameters.
Se the parameter for inexistente, cancele.
Se the routine's callback sinal estiver verde, abra the parameter's by-value sinal.
Se the parameter's previous for inexistente, coloque 8 into the parameter's offset. \ skip the return address e saved ebp
Se the parameter's previous não for inexistente, coloque the parameter's previous' offset plus 4 into the parameter's offset. \ all parameters are 4 pedaço endereço de memórias ou 4 pedaço values por callbacks
Adicione 4 to the routine's parameter size.
Repita.

Etapas necessárias para que se offset the parameters in alguns routines:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, cancele.
Offset the parameters in the routine.
Repita.

The offsetting timer é um timer.

An parameter é uma variable.

An partial moniker é um moniker.

An pe header é um conjunto with
An número called signature,
An wyrd called machinetype,
An wyrd called numberofsections,
An número called timestamp,
An número called pointertosymboltable,
An número called numberofsymbols,
An wyrd called sizeofoptionalheaderinbytes,
An wyrd called characteristics,
\ optional header
An wyrd called magicnumber,
An pedaço called majorlinkerversion,
An pedaço called minorlinkerversion,
An número called sizeofcodeinfile,
An número called sizeofinitializeddatainfile,
An número called sizeofuninitializeddatainfile,
An número called addressofentrypointinmemory,
An número called addressofcodeinmemory,
An número called addressofinitializeddatainmemory,
An número called imagebase,
An número called memoryalignment,
An número called filealignment,
An wyrd called osmajorversion,
An wyrd called osminorversion,
An wyrd called usermajorversion,
An wyrd called userminorversion,
An wyrd called subsystemmajorversion,
An wyrd called subsystemminorversion,
An número called reserved,
An número called sizeofimageinmemory,
An número called sizeofallheadersinfile,
An número called checksum,
An wyrd called subsystem,
An wyrd called dllcharacteristics,
An número called maxstack,
An número called minstack,
An número called maxheap,
An número called minheap,
An número called loadersinals,
\ directories (16 address e size pairs)
An número called numberofdirectories,
8 pedaços called directory0,
An número called imagedirectoryentryimportaddress,
An número called imagedirectoryentryimportsize,
112 pedaços called directories2-15,
An pe section header called idata section,
An pe section header called data section,
An pe section header called code section.

An pe section header é um conjunto with
8 pedaços called name,
An número called sizeinbytes,
An número called addressinmemory,
An número called sizeinfile,
An número called addressinfile,
12 pedaços called reserved,
An número called characteristics.

An phrase é um string.

\Etapas necessárias para que se determine se um string looks like English:
\Load the lexicon.
\Se the lexicon for inexistente, mostre error "I can't find any lecksicon."; Diga não.
\Se the string estiver em branco, diga não.
\Lance um substring on the string.
\Coloque the substring's last into the substring's first.
\Percorra.
\Se the substring's first é the string's first, pare.
\Se the substring's first's target é the space pedaço, adicione 1 to the substring's first; break.
\Subtraia 1 from the substring's first.
\Repita.
\Se the substring estiver in the lexicon's index, diga sim.
\Diga não.

Etapas necessárias para que se pluralize um string (portuguese rules):
Lance um percorredor on the string.
Percorra.
Mova the percorredor (spell checking rules).
Se the percorredor's token estiver em branco, pare.
Se um plural string não estiver em branco, posponha " " to the plural string.
Posponha the percorredor's token to the plural string.
Se the percorredor's token for "de", abra um sinal; repeat.
Se the sinal não estiver verde, pluralize the plural string (portuguese rules - each word).
Repita.
Coloque the plural string into the string.

Etapas necessárias para que se pluralize um string (portuguese rules - each word):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se the string for "cidadão", posponha "s" to the string; exit.
Se the string for "irmão", posponha "s" to the string; exit.
Se the string for "cristão", posponha "s" to the string; exit.
Se the string for "refrão", posponha "s" to the string; exit.
Se the string for "pão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "capitão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "alemão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "charlatão", remove the last pedaço from the string; posponha "es" to the string; exit.
Se the string for "caráter", coloque "carateres" into the string; exit.
Se the string for "júnior", coloque "juniores" into the string; exit.
Se the string for "sênior", coloque "seniores" into the string; exit.
Se the string for "mão", coloque "mãos" into the string; exit.
Se the string for "são", coloque "sãos" into the string; exit.
\# advérbios principais
Se the string for "muito", cancele.
Se the string for "pouco", cancele.
Se the string for "mais", cancele.
Se the string for "menos", cancele.
Se the string for "bastante", cancele.
Se the string for "quase", cancele.
Se the string for "demais", cancele.
Se the string for "bem", cancele.
Se the string for "deveras", cancele.
Se the string for "mal", cancele.
Se the string for "melhor", cancele.
Se the string for "pior", cancele.
\# palavras terminadas com "ão"
Se the string ends with "ão", pluralize the string (portuguese rules - ending words with "ão"); exit.
\# palavras terminadas com "l"
Se the string ends with "l", pluralize the string (portuguese rules - ending words with "l"); exit.
\# palavra terminadas com "m"
Se the string ends with "m", remove the last pedaço from the string; posponha "ns" to the string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se the string ends with "n", posponha "es" to the string; exit.
\# palavras terminadas com "r"
Se the string ends with "r", pluralize the string (portuguese rules - ending words with "r"); exit.
\# palavras terminadas com "s"
Se the string ends with "s", pluralize the string (portuguese rules - ending words with "s"); exit.
\# palavra terminadas com "x"
Se the string ends with "x", cancele.
\# palavras terminadas com "z"
Se the string ends with "z", pluralize the string (portuguese rules - ending words with "z"); exit.
\# regra padrão
Posponha "s" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "ão"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, posponha "s" to the string; exit.
\# regra padrão
Remove the last two pedaços from the string.
Posponha "ões" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "l"):
\# palavras terminadas com "al"
Se the string ends with "al", remove the last pedaço from the string; posponha "is" to the string; exit.
\# palavras terminadas com "el"
Se the string ends with "el", pluralize the string (portuguese rules - ending words with "el"); exit.
\# palavras terminadas com "il"
Se the string ends with "il", pluralize the string (portuguese rules - ending words with "il"); exit.
\# palavras terminadas com "ol"
Se the string ends with "ol", pluralize the string (portuguese rules - ending words with "ol"); exit.
\# palavras terminadas com "ul"
Se the string ends with "ul", remove the last pedaço from the string; posponha "is" to the string; exit.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "el"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, remove the last pedaço from the string; posponha "is" to the string; exit.
Remove the last two pedaços from the string.
Posponha "éis" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "il"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, remove the last two pedaços from the string; posponha "eis" to the string; exit.
Remove the last pedaço from the string.
Posponha "s" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "ol"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, remove the last pedaço from the string; posponha "is" to the string; exit.
Remove the last two pedaços from the string.
Posponha "óis" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "r"):
\# hiatos acentuados
\Se the string ends with "aír", posponha "es" to the string; exit.
\Se the string ends with "aúr", posponha "es" to the string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se the string ends with "ár", remove the last two pedaços from the string; posponha "ares" to the string; exit.
\Se the string ends with "âr", remove the last two pedaços from the string; posponha "ares" to the string; exit.
\Se the string ends with "ér", remove the last two pedaços from the string; posponha "eres" to the string; exit.
\Se the string ends with "êr", remove the last two pedaços from the string; posponha "eres" to the string; exit.
\Se the string ends with "ír", remove the last two pedaços from the string; posponha "ires" to the string; exit.
\Se the string ends with "ór", remove the last two pedaços from the string; posponha "ores" to the string; exit.
\Se the string ends with "ôr", remove the last two pedaços from the string; posponha "ores" to the string; exit.
\Se the string ends with "úr", remove the last two pedaços from the string; posponha "ures" to the string; exit.
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, posponha "es" to the string; exit.
\# hiatos
Se the string ends with "air", remove the last two pedaços from the string; posponha "íres" to the string; exit.
Se the string ends with "aur", remove the last two pedaços from the string; posponha "úres" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se the string ends with "as", cancele.
Se the string ends with "es", cancele.
Se the string ends with "os", cancele.
\# hiatos acentuados
Se the string ends with "aís", posponha "es" to the string; exit.
Se the string ends with "aús", posponha "es" to the string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se the string ends with "ás", remove the last two pedaços from the string; posponha "ases" to the string; exit.
Se the string ends with "âs", remove the last two pedaços from the string; posponha "ases" to the string; exit.
Se the string ends with "és", remove the last two pedaços from the string; posponha "eses" to the string; exit.
Se the string ends with "ês", remove the last two pedaços from the string; posponha "eses" to the string; exit.
Se the string ends with "ís", remove the last two pedaços from the string; posponha "ises" to the string; exit.
Se the string ends with "ós", remove the last two pedaços from the string; posponha "oses" to the string; exit.
Se the string ends with "ôs", remove the last two pedaços from the string; posponha "oses" to the string; exit.
Se the string ends with "ús", remove the last two pedaços from the string; posponha "uses" to the string; exit.
\# palavras terminadas com "is", "us"
Se the string ends with "is", pluralize the string (portuguese rules - ending words with "is/us"); exit.
Se the string ends with "us", pluralize the string (portuguese rules - ending words with "is/us"); exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "is/us"):
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, cancele.
\# hiatos
Se the string ends with "ais", remove the last two pedaços from the string; posponha "íses" to the string; exit.
Se the string ends with "aus", remove the last two pedaços from the string; posponha "úses" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending words with "z"):
\# hiatos acentuados
Se the string ends with "aíz", posponha "es" to the string; exit.
Se the string ends with "aúz", posponha "es" to the string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se the string ends with "áz", remove the last two pedaços from the string; posponha "azes" to the string; exit.
Se the string ends with "âz", remove the last two pedaços from the string; posponha "azes" to the string; exit.
Se the string ends with "éz", remove the last two pedaços from the string; posponha "ezes" to the string; exit.
Se the string ends with "êz", remove the last two pedaços from the string; posponha "ezes" to the string; exit.
Se the string ends with "íz", remove the last two pedaços from the string; posponha "izes" to the string; exit.
Se the string ends with "óz", remove the last two pedaços from the string; posponha "ozes" to the string; exit.
Se the string ends with "ôz", remove the last two pedaços from the string; posponha "ozes" to the string; exit.
Se the string ends with "úz", remove the last two pedaços from the string; posponha "uzes" to the string; exit.
\# acentos em sílabas prévias
Lance um substring on the string.
Subtraia 2 from the substring's last.
Se the substring has any stressed vowel, posponha "es" to the string; exit.
\# hiatos
Se the string ends with "aiz", remove the last two pedaços from the string; posponha "ízes" to the string; exit.
Se the string ends with "auz", remove the last two pedaços from the string; posponha "úzes" to the string; exit.
\# regra padrão
Posponha "es" to the string.

Etapas necessárias para que se pluralize um string (english rules);
Etapas necessárias para que se pluralize um string: \ nouns only
Se the string for "alumnus", coloque "alumni" into the string; exit.
Se the string for "auto", coloque "autos" into the string; exit.
Se the string for "cello", coloque "cellos" into the string; exit.
Se the string for "dwarf", coloque "dwarfs" into the string; exit.
Se the string for "foot", coloque "feet" into the string; exit.
Se the string for "genus", coloque "genera" into the string; exit.
Se the string for "goose", coloque "geese" into the string; exit.
Se the string for "hippo", coloque "hippos" into the string; exit.
Se the string for "louse", coloque "lice" into the string; exit.
Se the string for "memo", coloque "memos" into the string; exit.
Se the string for "mouse", coloque "mice" into the string; exit.
Se the string for "ox", coloque "oxen" into the string; exit.
Se the string for "phenomenon", coloque "phenomena" into the string; exit.
Se the string for "photo", coloque "photos" into the string; exit.
Se the string for "phylum", coloque "phyla" into the string; exit.
Se the string for "piano", coloque "pianos" into the string; exit.
Se the string for "pimento", coloque "pimentos" into the string; exit.
Se the string for "pro", coloque "pros" into the string; exit.
Se the string for "proof", coloque "proofs" into the string; exit.
Se the string for "radius", coloque "radii" into the string; exit.
Se the string for "rhinoceros", coloque "rhinoceri" into the string; exit.
Se the string for "roof", coloque "roofs" into the string; exit.
Se the string for "solo", coloque "solos" into the string; exit.
Se the string for "soprano", coloque "sopranos" into the string; exit.
Se the string for "staff", coloque "staffs" into the string; exit.
Se the string for "tooth", coloque "teeth" into the string; exit.
Se the string for "torus", coloque "tori" into the string; exit.
Se the string for "turf", coloque "turfs" into the string; exit.
Se the string for "virus", coloque "viruses" into the string; exit.
Se the string ends with "sh", posponha "es" to the string; exit.
Se the string ends with "ch", posponha "es" to the string; exit.
Se the string ends with "man", remove the last two pedaços from the string; posponha "en" to the string; exit.
Se the string ends with "child", posponha "ren" to the string; exit.
Se the string ends with "ex", remove the last two pedaços from the string; posponha "ices" to the string; exit. \ ou adicione ES
Se the string ends with "fe", remove the last two pedaços from the string; posponha "ves" to the string; exit.
Se the string ends with "is", remove the last two pedaços from the string; posponha "es" to the string; exit.
Se the string ends with "ix", remove the last two pedaços from the string; posponha "ices" to the string; exit. \ ou adicione ES
Se the string ends with "ma", posponha "ta" to the string; exit. \ ou adicione S
Se the string ends with any consonant e "y", remove the last pedaço from the string; posponha "ies" to the string; exit.
Se the string ends with any vowel e "o", posponha "s" to the string; exit.
Se the string ends with any vowel e "y", posponha "s" to the string; exit.
Se the string ends with "f", remove the last pedaço from the string; posponha "ves" to the string; exit.
Se the string ends with "s", posponha "es" to the string; exit.
Se the string ends with "x", posponha "es" to the string; exit.
Se the string ends with "z", posponha "es" to the string; exit.
Posponha "s" to the string.

The prolog tag é uma tag igual a 17.

An prototype string é um conjunto with um first pedaço endereço de memória e um last pedaço endereço de memória.

The push address tag é uma tag igual a 18.

The push value tag é uma tag igual a 19.

Etapas necessárias para que se coloque the compilador's exe path into um path:
Extract um designator from the compilador's directory.
Remove any trailing backslash from the designator.
Coloque the compilador's directory then the designator then ".exe" into the path.

Etapas necessárias para que se coloque the compilador's exe size into um size:
Coloque 4096 [section base] into the size.
Adicione the import borough's size to the size.
Adicione the data borough's size to the size.
Adicione the code borough's size to the size.

Etapas necessárias para que se coloque the compilador's listing path into um path:
Extract um designator from the compilador's directory.
Remove any trailing backslash from the designator.
Coloque the compilador's directory then the designator then ".lst" into the path.

Etapas necessárias para que se coloque um term into another term:
Coloque the term's variable into the other term's variable.
Coloque the term's phrase into the other term's phrase.

Etapas necessárias para que se load um source file:
Se the source file for inexistente, cancele.
Load the source file's path into the source file's buffer.
Se the i/o error não estiver em branco, abort with "Não foi possível carregar o arquivo: '" then the source file's path then "'."; exit.
\Load the source file's path into um string.
\Se the i/o error não estiver em branco, abort with "Não foi possível carregar o arquivo '" then the source file's path then "'."; exit.
\Parse the string to the source file's buffer (portuguese contractions e synonyms rules).

Etapas necessárias para que se load alguns source files:
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um item from the compilador's directory.
Se the item não for found, pare.
Se the item's kind não for "file", repita.
Se the item's extension não estiver em branco, repita.
Se the item looks reamish, repita.
Adicione um source file to the source files usando the item's path.
Load the source file.
Repita.

The loading timer é um timer.

Etapas necessárias para que se parse um string to another string (portuguese contractions e synonyms rules):
Limpe the other string.
Limpe um third string.
Lance um percorredor on the string.
Percorra.
Se the percorredor's source estiver em branco, cancele.
Position the percorredor's token on the percorredor's source.
Mova the percorredor (code rules).
Se the percorredor's token's first's target não for any glom pedaço, posponha the percorredor's token to the other string; repeat.
Posponha the percorredor's token to the other string giving the third string (portuguese contractions e synonyms rules).
Coloque the percorredor's token into the third string.
Repita.

Etapas necessárias para que se reduce alguns monikettes por utility use:
Obtenha um monikette from the monikettes.
Se the monikette for inexistente, cancele.
Se the monikette's type for inexistente, repita.
Reduce the monikette's type to um type por utility use.
Se the type não for inexistente, coloque the type into the monikette's type.
Repita.

Etapas necessárias para que se reduce um type to another type por utility use:
Coloque the type into the other type.
Percorra.
Se the other type for inexistente, cancele.
Se the other type's name for "texto hexadecimal", cancele.
Se the other type's name for "string", cancele.
Se the other type's name for "número", cancele.
Se the other type's name for "endereço de memória", cancele.
Se the other type's name for "coisa", esvazie the other type; exit.
\PAL
\Se the other type's name for "elemento", esvazie the other type; exit.
Se the other type's base type for the other type, esvazie the other type; exit.
Coloque the other type's base type into the other type.
Repita.

Etapas necessárias para que se catalogue novamente the utility index:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um bucket usando the utility index.
Se the bucket for inexistente, cancele.
Se the bucket's refers estiverem vazio, repita.
Catalogue novamente the utility index usando the bucket's refers.
Repita.

Etapas necessárias para que se catalogue novamente the utility index usando alguns refers:
Obtenha um refer from the refers.
Se the refer for inexistente, cancele.
Coloque the refer's endereço de memória into uma routine.
Se the routine for inexistente, abort with "Erro interno na função: index the utility routines usando alguns refers"; exit.
Copy the routine's monikettes into alguns monikettes.
Reduce the monikettes por utility use.
Catalogue the routine usando the monikettes e the routine index.
Destroy the monikettes.
Repita.

Etapas necessárias para que se remove any negatives from alguns monikettes returning um sinal:
Feche the sinal.
Swap the monikettes with alguns other monikettes.
Percorra.
Coloque the other monikettes' first into um monikette.
Se the monikette for inexistente, cancele.
Remove the monikette from the other monikettes.
\PAL
Se the monikette's string for "não", reverse the sinal; destroy the monikette; repeat.
Se the monikette's string for "nada", reverse the sinal; destroy the monikette; repeat.
\CAL
Se the monikette's string for "not", reverse the sinal; destroy the monikette; repeat.
Se the monikette's string for "nada", reverse the sinal; destroy the monikette; repeat.
Posponha the monikette to the monikettes.
Se the monikette's string for "can't", reverse the sinal; coloque "can" into the monikette's string; repeat.
Se the monikette's string for "cannot", reverse the sinal; coloque "can" into the monikette's string; repeat.
Se the monikette's string for "nothing", reverse the sinal; coloque "something" into the monikette's string; repeat.
Se the monikette's string for "won't", reverse the sinal; coloque "will" into the monikette's string; repeat.
Se the monikette's string ends with "n't", reverse the sinal; remove trailing pedaços from the monikette's string usando 3; repeat.
Repita.

The repeat tag é uma tag igual a 21.

Etapas necessárias para que se resolva um field:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the field for inexistente, cancele.
Resolva the field como uma variable.
Se the field's nickname não for any valid field name, limpe o field's nickname.
Se the field's name não for any valid field name, abort with "'" then the field's name then "' é um field name inválido." e the field's locus; exit.

Etapas necessárias para que se resolva um global:
Se the global for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the global's global body não estiver em branco, resolva the global (compile body).
Se the global's type name estiver em branco, abort with "Tipo inválido: '" then the global's name then "' . O tipo da variável global está vazio." e the global's locus; exit.
Resolva the global como uma variable.

Etapas necessárias para que se resolva um global (compile body):
Se the global for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Lance um percorredor on the global's global body.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any literal, abort with "Erro de tipo. O tipo: '" then the percorredor's token then "' tem que ser do tipo literal." e the percorredor; exit.
Compile um literal usando the percorredor.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token não estiver em branco, abort with "Acho que era bom colocar um ponto por aqui, né?" e the percorredor; exit.
Se the global's type name estiver em branco, coloque the literal's type's name into the global's type name.
Coloque the literal into the global's literal.
Catalogue the literal.

Etapas necessárias para que se resolva alguns globals:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um global from the globals.
Se the global for inexistente, cancele.
Resolva the global.
Repita.

Etapas necessárias para que se resolva um type (base type):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's base type não for inexistente, cancele.
Encontre the type's base type usando the type's base name e the type index.
Se the type's base type for inexistente, abort with "Base type inválido:'" then the type's base name then "'." e the type's locus; exit.
Abra the type's cooking sinal.
Se the type's base type's cooking sinal estiver verde, abort with "Definição recursiva com '" then the type's base name then "'." e the type's locus; exit.
Resolva the type's base type (base type).
Feche the type's cooking sinal.

Etapas necessárias para que se resolva um type (expand coisa): \ type's base type não for resolved yet
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's base type não for inexistente, cancele.
Se the type's name for "coisa", cancele.
\Se the type's name for "elemento", cancele.
Se the type não puder ser reduzido para "coisa" using the base name, cancele.
Encontre um base type usando the type's base name e the type index.
\  adicione coisa conjunto - the número of secret fields é hard coded in two places: search por "do que 4" \ was 6
Coloque the type's name then " conjunto" into um name.
Coloque the type's name then " conjuntos" into um plural name.
Coloque the base type's name then " conjunto" into um base name.
Adicione um conjunto type to the types usando the name e the plural name e the base name.
Adicione um field to the conjunto type's fields usando "next " then the type's name e "next" e the type's name e the on sinal.
\PAL
Adicione um portuguese field to the conjunto type's fields usando "seguinte " then the type's name e "seguinte" e the type's name e the on sinal.
Coloque "next " then the type's name into the portuguese field's redefinition target name.
\Adicione um portuguese reverse field to the conjunto type's fields usando the type's name then " seguinte" e "seguinte" e the type's name e the on sinal.
\Coloque "next " then the type's name into the portuguese reverse field's redefinition target name.
Adicione another field to the conjunto type's fields usando "previous " then the type's name e "previous" e the type's name e the on sinal.
\Adicione another portuguese field to the conjunto type's fields usando "anterior " then the type's name e "anterior" e the type's name e the on sinal.
\Coloque "previous " then the type's name into the other portuguese field's redefinition target name.
Adicione another portuguese reverse field to the conjunto type's fields usando the type's name then " anterior" e "anterior" e the type's name e the on sinal.
Coloque "previous " then the type's name into the other portuguese reverse field's redefinition target name.
Se the type's fields não estiverem vazio, posponha the type's fields to the conjunto type's fields.
Catalogue the conjunto type.
\ fix up original type to look like um endereço de memória
Coloque the conjunto type's name into the type's target name.
\ adicione chain type
Adicione um chain type to the types usando the type's plural name e "" e the base type's plural name.
Adicione um third field to the chain type's fields usando "first " then the type's name e "first" e the type's name e the on sinal.
Adicione um third portuguese field to the chain type's fields usando "primeiro " then the type's name e "primeiro" e the type's name e the on sinal.
Coloque "first " then the type's name into the third portuguese field's redefinition target name.
Adicione um third feminine portuguese field to the chain type's fields usando "primeira " then the type's name e "primeira" e the type's name e the on sinal.
Coloque "first " then the type's name into the third feminine portuguese field's redefinition target name.
Adicione um fourth field to the chain type's fields usando "last " then the type's name e "last" e the type's name e the on sinal.
Adicione um fourth portuguese field to the chain type's fields usando "último " then the type's name e "último" e the type's name e the on sinal.
Coloque "last " then the type's name into the fourth portuguese field's redefinition target name.
Adicione um fourth portuguese feminine field to the chain type's fields usando "última " then the type's name e "última" e the type's name e the on sinal.
Coloque "last " then the type's name into the fourth portuguese feminine field's redefinition target name.
Catalogue the chain type.

Etapas necessárias para que se resolva um type (registro de plurais):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's plural name estiver em branco, cancele.
Se the type puder ser reduzido para "coisa" using the base name, cancele.
Catalogue the type usando the type's plural name.

Etapas necessárias para que se resolva um type (optional info - endereço de memória):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type's target type não for inexistente, cancele.
Se the type's target name estiver em branco, coloque the type's base type's target type into the type's target type; exit.
Encontre the type's target type usando the type's target name e the type index.
Se the type's target type for inexistente, abort with "Não sei bem pra que coisa você está pointing at." e the type's locus; exit.

Etapas necessárias para que se resolva um type (optional info - conjunto):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type's fields estiverem vazio, copy the type's base type's fields into the type's fields; exit.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um field from the type's fields (backwards).
Se the field for inexistente, pare.
Se the field é duplicated in the type's fields, abort with "O campo '" then the field's name then "' está definido mais de uma vez." e the field's locus; exit.
Resolva the field.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the field's type's cooking sinal estiver verde, abort with "Recursive definition no: '" then the field's type's name then "'." e the field's locus; exit.
Resolva the field's type (optional info). \ de novo
Se the field's reference sinal não estiver verde, repita.
Se the field's type não puder ser reduzido para "endereço de memória", abort with "Não entendi o parâmetro '(reference)' nesse campo '" then the field's name then "'..." e the field's locus; exit.
Repita.
Eliminate duplicate nicknames from the type's fields.
Se the type não puder ser reduzido para "coisa conjunto", cancele.
Se the type's fields' count for maior do que 4, cancele. \ already copied? was 2 por next e prev, now 6 to included Spanish redefiniions
Copy the type's base type's fields into the type's fields (data fields only).

Etapas necessárias para que se resolva um type (optional info - scale):
Se the compilador's sinal de alerta estiver presente, cancele.
Coloque the type's base type into um base type.
Se the type's scale for 0, coloque the type's base type's scale into the type's scale; exit.
Se the base type's scale for 0, cancele.
Multiplique the type's scale por the base type's scale.
Coloque the base type's base type into the type's base type.

Etapas necessárias para que se resolva um type (optional info):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the type for inexistente, cancele.
Se the type's optional info resolved sinal estiver verde, cancele.
Se the type's base type for the type, cancele. \ por built in types
Check por invalid optional info on the type.
Abra the type's cooking sinal.
Resolva the type's base type (optional info).
Se the type puder ser reduzido para "endereço de memória", resolva the type (optional info - endereço de memória).
Se the type puder ser reduzido para "conjunto", resolva the type (optional info - conjunto). \ mudar aqui
Se the type puder ser reduzido para "número", resolva the type (optional info - scale).
Feche the type's cooking sinal.
Abra the type's optional info resolved sinal.

Etapas necessárias para que se resolva alguns types (base types):
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolva the type (base type).
Repita.

Etapas necessárias para que se resolva alguns types (expand coisas):
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolva the type (expand coisa).
Repita.

Etapas necessárias para que se resolva alguns types (registro de plurais):
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolva the type (registro de plurais).
Repita.

Etapas necessárias para que se resolva alguns types (optional info):
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um type from the types.
Se the type for inexistente, cancele.
Resolva the type (optional info).
Repita.

Etapas necessárias para que se resolva uma variable:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the variable for inexistente, cancele.
Se the variable's type não for inexistente, cancele.
Se the variable's type name não estiver em branco, resolva the variable (explicit type name); exit.
Encontre the variable's type e the variable's nickname usando the variable's name.
Se the variable's type não for inexistente, coloque the variable's type's name into the variable's type name; exit.
Abort with "Não achei o tipo da variável '" then the variable's name then "'." e the variable's locus.

Etapas necessárias para que se resolva uma variable (explicit type name):
Encontre the variable's type usando the variable's type name e the type index.
Se the variable's type for inexistente, abort with "Não achei o nome do tipo da variável '" then the variable's type name then "'." e the variable's locus; exit.

The resolving globals timer é um timer.

The resolving types timer é um timer.

Etapas necessárias para que se round up borough sizes:
Coloque the import borough's length into the import borough's size.
Round the import borough's size up to the nearest multiple of 4096.
Coloque the data borough's length into the data borough's size.
Round the data borough's size up to the nearest multiple of 4096.
Coloque the code borough's length into the code borough's size.
Round the code borough's size up to the nearest multiple of 4096.

The routine address tag é uma tag igual a 22.

An routine body é um substring.

An routine header é um substring.

The routine index é um index.

An routine é uma coisa with
An locus (reference),
An callback sinal,
An decider sinal,
An function sinal,
An compiled sinal,
An nickname index,
An moniker, alguns monikettes, alguns parameters, um parameter size,
An employs moniker,
Some locals, um local size,
An routine header, um header string,
An routine body, um body string,
Some fragments,
An address.

An routine reference é alguns monikettes.

The routines are alguns routines.

The save eax tag é uma tag igual a 20.

Etapas necessárias para que se examine any optional info por um type usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token for "to", examine any optional info por the type usando the percorredor (endereço de memória); exit.
Se the percorredor's token for "para", examine any optional info por the type usando the percorredor (endereço de memória); exit.
Se the percorredor's token for any with, examine any optional info por the type usando the percorredor (conjunto); exit.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (endereço de memória):
Mova the percorredor (compilador rules).
Se the percorredor's token não for any indefinite article, abort with "A palavra 'to' precisa de um artigo indefinido depois dela, não de um '" then the percorredor's token then "'." e the percorredor; exit. 
Mova the percorredor (compilador rules).
Examine the type's target name usando the percorredor.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (conjunto):
Mova the percorredor (compilador rules).
Examine the type's fields usando the percorredor.

Etapas necessárias para que se examine any pauses usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token não for any pause, cancele.
Mova the percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um field usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Examine the field usando the percorredor (type part).
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token for any called, examine the field usando the percorredor (called part); repeat.
Se the percorredor's token for "at", examine the field usando the percorredor (redefine part); repeat.
Se the percorredor's token for "em", examine the field usando the percorredor (redefine part); repeat.
Se the percorredor's token for "redefinindo", examine the field usando the percorredor (redefine part); repeat.
Se the percorredor's token for any reference, examine the field usando the percorredor (reference part); repeat.

Etapas necessárias para que se examine um field usando um percorredor (called part):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Se the field's type name estiver em branco, coloque the field's name into the field's type name. \ pedaço array type name already filled in
Examine the field's name usando the percorredor.

Etapas necessárias para que se examine um field usando um percorredor (redefine part):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any definite article, abort with "Eu estava esperando o artigo 'the', mas o que encontrei foi '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Examine the field's redefinition target name usando the percorredor.

Etapas necessárias para que se examine um field usando um percorredor (reference part):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Abra the field's reference sinal.

Etapas necessárias para que se examine um field usando um percorredor (type part - pedaço array):
Se the compilador's sinal de alerta estiver presente, cancele.
Convert the percorredor's token to um ratio.
Reduce the ratio.
Se the ratio's denominator não for 1, abort with "Você tem que especificar um número completo de pedaços para um pedaço array" e the percorredor; exit.
Coloque the ratio's numerator into the field's count.
Mova the percorredor (compilador rules).
Se the percorredor's token não for "pedaço" ou "pedaços", abort with "Você precisa usar a palavra 'pedaços' depois de um counted field designator." e the percorredor; exit.
Mova the percorredor (compilador rules).
Coloque "pedaço" into the field's type name.

Etapas necessárias para que se examine um field usando um percorredor (type part - normal):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token não for any indefinite article, abort with "Falta por um artigo idefinido aqui, mas você colocou isso: '" then the percorredor's token then "'." e the percorredor; exit.
Se the percorredor's token for "another", coloque "other" into the field's name.
\PAL
Se the percorredor's token for "outra", coloque "segunda" into the field's name.
Se the percorredor's token for "outro", coloque "segundo" into the field's name.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Extend the field's name with the name.

Etapas necessárias para que se examine um field usando um percorredor (type part):
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token for any numeric literal, examine the field usando the percorredor (type part - pedaço array); exit.
Examine the field usando the percorredor (type part - normal).

Etapas necessárias para que se examine alguns fields usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione um field to the fields usando "field" e the percorredor's token's first.
Examine the field usando the percorredor.
Se the percorredor's token não for any pause, cancele.
Examine any pauses usando the percorredor.
Repita.

Etapas necessárias para que se examine um global body usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Coloque the percorredor's token's first into the global body's first.
Coloque -1 into the global body's last.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token for the colon pedaço, cancele.
Se the percorredor's token for the period pedaço, cancele.
Coloque the percorredor's token's last into the global body's last.
Mova the percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um global usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione the global to the globals usando "global" e the percorredor's token's first.
Mova the percorredor (compilador rules).
Examine the global's name usando the percorredor.
Se the percorredor's token for any has, examine the global usando the percorredor (has ou have); exit.
Se the percorredor's token não for any is, abort with "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any indefinite article, examine the global usando the percorredor (literal term); exit.
Mova the percorredor (compilador rules).
Examine the global's type name usando the percorredor.  
Se the percorredor's token for the start of any optional info, examine the global usando the percorredor (optional info); exit.
Se the percorredor's token for any operador de atribuição, examine the global usando the percorredor (data part); exit.
Se the percorredor's token não for the period pedaço, abort with "Toda definição precisa terminar com um ponto. Inclusive essa." e the percorredor; exit. 
Mova the percorredor (compilador rules).
Catalogue the global.

Etapas necessárias para que se examine um global usando um percorredor (data part):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any to, abort with "Depois da palavra 'equal' você precisa por um palavra  'to'. Você colocou ; '" then the percorredor's token then "'." e the percorredor; exit. 
Mova the percorredor (compilador rules).
Examine the global's global body usando the percorredor.
Se the percorredor's token não for the period pedaço, abort with "Falta terminar um frase com um ponto." e the percorredor; exit. 
Mova the percorredor (compilador rules).
Catalogue the global.

Etapas necessárias para que se examine um global usando um percorredor (has ou have):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Coloque "~inline " then the global's name then " type" into um name.
Coloque the name then "s" into um plural name.
Adicione um type to the types usando the name e the plural name e "conjunto" e the global's locus. \mudar aqui
Catalogue the type.
Coloque the type's name into the global's type name.
Examine the type's fields usando the percorredor.
Se the percorredor's token não for the period pedaço, abort with "Aprenda a escrever direito. Cadê o ponto?." e the percorredor; exit. 
Mova the percorredor (compilador rules).
Catalogue the global.

Etapas necessárias para que se examine um global usando um percorredor (literal term):
Se the compilador's sinal de alerta estiver presente, cancele.
Examine the global's global body usando the percorredor.
Se the percorredor's token não for the period pedaço, abort with "Aprenda a escrever corretamente. Cadê o ponto?." e the percorredor; exit. 
Mova the percorredor (compilador rules).
Catalogue the global.

Etapas necessárias para que se examine um global usando um percorredor (optional info):
Se the compilador's sinal de alerta estiver presente, cancele.
Coloque "~inline " then the global's name then " type" into um name.
Coloque the name then "s" into um plural name.
Adicione um type to the types usando the name e the plural name e the global's type name e the global's locus.
Catalogue the type.
Coloque the type's name into the global's type name.
Examine any optional info por the type usando the percorredor.
Se the percorredor's token não for the period pedaço, abort with "Tá na hora de aprender a escrever direito. Cadê o ponto?." e the percorredor; exit. 
Mova the percorredor (compilador rules).
Catalogue the global.

Etapas necessárias para que se examine um name usando um percorredor:
Limpe the name.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor está on any name starter, extend the name with the percorredor's token; mova the percorredor (compilador rules).
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor está on any name ender, pare.
Extend the name with the percorredor's token.
Mova the percorredor (compilador rules).
Repita.
Se the name estiver em branco, abort with "Acho que faltou colocar um nome por aqui. Você escreveu '" then the percorredor's token then "'." e the percorredor; exit.

Etapas necessárias para que se examine uma routine body usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token for the start of any definition, cancele.
Coloque the percorredor's token's first into the routine body's first.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Coloque the percorredor's token's last into the routine body's last.
Se the percorredor's token for the colon pedaço, abort with "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e the percorredor; exit.
Se the percorredor's token não for the period pedaço, mova the percorredor (compilador rules); repeat.
Mova the percorredor (compilador rules).
Se the percorredor's token for the start of any definition, cancele.
Repita.

Etapas necessárias para que se examine uma routine usando um percorredor:  \ Define o cabeçalho de rotina.
Se the compilador's sinal de alerta estiver presente, cancele.
Adicione the routine to the routines usando the percorredor's token's first.
Mova the percorredor (compilador rules). \ skip the "Passos" e obtenha the next token
Se the percorredor's token for "necessários" ou "necessárias", mova the percorredor (compilador rules). 
Se the percorredor's token não for "para", abort with "Você precisa escrever 'para' antes de '" then the percorredor's token then "' nesse tipo de rotina." e the percorredor; exit.
Mova the percorredor (compilador rules). \ skip the "para" e obtenha the next token
Se the percorredor's token for "que", mova the percorredor (compilador rules). 
\Se the percorredor's token não for "que", abort with "Você precisa colocar um 'que' antes da palavra '" then the percorredor's token then "'." e the percorredor; exit.
\Mova the percorredor (compilador rules). \ skip the "que" e obtenha the next token
Se the percorredor's token for "se", mova the percorredor (compilador rules). 
\Se the percorredor's token não for "se", abort with "Você precisa colocar um 'se' antes da palavra '" then the percorredor's token then "'." e the percorredor; exit.
\Mova the percorredor (compilador rules).  \ skip the "se" e obtenha the next token
Examine the routine's routine header usando the percorredor.
Se the percorredor's token for the semi-colon pedaço, examine the routine usando the percorredor (alternate wording); exit.  \ *** por alternate wordings
Se the percorredor's token não for the colon pedaço, abort with "O nome dessa função está escrito errado.." e the routine's locus; exit.
Mova the percorredor (compilador rules).
Examine the routine's routine body usando the percorredor.

Etapas necessárias para que se examine uma routine usando um percorredor (alternate wording):  \ *** por alternate wordings
Privatize the percorredor.
Mova the percorredor (compilador rules).
Se the percorredor's token não for the start of any routine, abort with "Esse ponto e vírgula tá no lugar errado." e the original percorredor; exit.
Coloque the original percorredor's token's first into the routine's routine body's first.
Coloque the original percorredor's token's last into the routine's routine body's last.
Mova the original percorredor (compilador rules).

Etapas necessárias para que se examine uma routine header usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Coloque the percorredor's token's first into the routine header's first.
Coloque -1 into the routine header's last.
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token for the semi-colon pedaço, cancele. \ *** alternate wordings
Se the percorredor's token for the colon pedaço, cancele.
Se the percorredor's token for the period pedaço, cancele.
Coloque the percorredor's token's last into the routine header's last.
Mova the percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um source file:
Se the source file for inexistente, cancele.
Se the compilador's sinal de alerta estiver presente, cancele.
Lance um percorredor on the source file's buffer.
Mova the percorredor (compilador rules).
Percorra.
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token estiver em branco, cancele.
Se the percorredor's token for the start of any type, examine um type usando the percorredor; repeat.
Se the percorredor's token for the start of any global, examine um global usando the percorredor; repeat.
Se the percorredor's token for the start of any routine, examine uma routine usando the percorredor; repeat.
Abort with "Faltou definir melhor o que é o '" then the percorredor's token then "'." e the percorredor.
Repita.

Etapas necessárias para que se examine alguns source files:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um source file from the source files.
Se the source file for inexistente, cancele.
Examine the source file.
Repita.

Etapas necessárias para que se examine um type usando um percorredor:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the percorredor's token for any portuguese indefinite article, abra um portuguese sinal.
Se the percorredor's token for any english indefinite article, abra um english sinal.
Adicione the type to the types usando the percorredor's token's first.
Mova the percorredor (compilador rules).
Examine the type's name usando the percorredor.
Coloque the type's name into the type's plural name.
Se the portuguese sinal estiver verde, pluralize the type's plural name (portuguese rules).
Se the english sinal estiver verde, pluralize the type's plural name (english rules).
Se the english sinal não estiver verde, pluralize the type's plural name (portuguese rules).
Se the percorredor's token for any has, examine the type usando the percorredor (has ou have); exit.
Se the percorredor's token não for any is, abort with "Eu esperava um 'is' ou um 'are', mas só achei um : '" then the percorredor's token then "'." e the percorredor; exit.
\Pluralize the type's plural name.
\Se the percorredor's token for "has" ou "have", examine the type usando the percorredor (has ou have); exit.
\Se the percorredor's token não for "is" ou "are", abort with "I was expecting um 'is' ou 'are', but I found '" then the percorredor's token then "'." e the percorredor; exit.

Mova the percorredor (compilador rules).
Se the percorredor's token for any numeric literal, examine the type usando the percorredor (unit of measure); exit.
Se the percorredor's token não for any indefinite article, abort with "Faltou um artigo indefinido, lembra? '" then the percorredor's token then "'." e the percorredor; exit. 
Mova the percorredor (compilador rules).
Examine the type's base name usando the percorredor.
Examine any optional info por the type usando the percorredor.
Se the percorredor's token não for the period pedaço, abort with "Você precisa usar um ponto para definir um tipo, lembra? Você usou '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Catalogue the type.

Etapas necessárias para que se examine um type usando um percorredor (has ou have):
Se the compilador's sinal de alerta estiver presente, cancele.
Mova the percorredor (compilador rules).
Coloque "conjunto" into the type's base name. \\mudar aqui
Examine the type's fields usando the percorredor.
Se the percorredor's token não for the period pedaço, abort with "Ao invés de usar o ponto para definir  tipo, você usou '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Catalogue the type.

Etapas necessárias para que se examine um type usando um percorredor (unit of measure):
Se the compilador's sinal de alerta estiver presente, cancele.
Convert the percorredor's token to the type's scale.
Se the type's scale for 0, abort with "Zero é um tipo de escala inválido." e the type's locus; exit.
Mova the percorredor (compilador rules).
Examine the type's base name usando the percorredor.
Se the percorredor's token não for the period pedaço, abort with "Os tipos precisam terminar com um ponto, não com '" then the percorredor's token then "'." e the percorredor; exit.
Mova the percorredor (compilador rules).
Catalogue the type.

The scanning timer é um timer.

An scratch é um local.

Etapas necessárias para que se scrub um index:
Obtenha um bucket usando the index.
Se the bucket for inexistente, cancele.
Se the bucket's refers estiverem vazio, repita.
Scrub the bucket's refers.
Repita.

Etapas necessárias para que se scrub alguns refers:
Swap the refers with alguns other refers.
Percorra.
Coloque the other refers' first into um refer.
Se the refer for inexistente, cancele.
Remove the refer from the other refers.
Se the refer's endereço de memória for inexistente, destroy the refer; repeat.
Posponha the refer to the refers.
Repita.

Etapas necessárias para que se abra the compiled sinal in uma variable:
Se the variable for inexistente, cancele.
Se the variable's compiled sinal estiver verde, cancele.
Abra the variable's compiled sinal.
Se the variable's kind não for "global", cancele.
Se the variable's literal for inexistente, cancele.
Encontre uma routine usando "coloque" e the variable's literal's type e "into" e the variable's type.
Se the routine for inexistente, encontre the routine usando "convert" e the variable's literal's type e "to" e the variable's type; abra um sinal.
Se the routine for inexistente, abort with "O tipo dessa variável global e desse literal não são compatíveis." e the variable's locus; exit.
Compile the body of the routine.
Se the sinal estiver verde, coloque "convert the " then the variable's literal's name then " to the " then the variable's name then ". " into the variable's initializer string.
Se the sinal não estiver verde, coloque "coloque the " then the variable's literal's name then " into the " then the variable's name then ". " into the variable's initializer string.

Etapas necessárias para que se skip to the next word in um substring:
Se the substring estiver em branco, cancele.
Se the substring's first's target for noise, pare.
Adicione 1 to the substring's first.
Repita.
Skip any leading noise in the substring.

Etapas necessárias para que se skip to the previous word in um substring:
Se the substring estiver em branco, cancele.
Se the substring's last's target for noise, pare.
Subtraia 1 from the substring's last.
Repita.
Skip any trailing noise in the substring.

An source file é uma coisa with um path e um buffer.

The source files are alguns source files.

An tag é um número.

An term é um conjunto with uma variable e um phrase.

Etapas necessárias para que se transmogrify um fragment:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the fragment for inexistente, cancele.
Se the fragment's tag for the push address tag, transmogrify the fragment (push address); exit.
Se the fragment's tag for the call internal tag, transmogrify the fragment (call internal); exit.
Se the fragment's tag for the load address tag, transmogrify the fragment (load address); exit.
Se the fragment's tag for the increment tag, transmogrify the fragment (increment); exit.
Se the fragment's tag for the dereference tag, transmogrify the fragment (dereference); exit.
Se the fragment's tag for the jump false tag, transmogrify the fragment (jump false); exit.
Se the fragment's tag for the not tag, transmogrify the fragment (not); exit.
Se the fragment's tag for the exit tag, transmogrify the fragment (exit); exit.
Se the fragment's tag for the repeat tag, transmogrify the fragment (repeat); exit.
Se the fragment's tag for the break tag, transmogrify the fragment (break); exit.
Se the fragment's tag for the prolog tag, transmogrify the fragment (prolog); exit.
Se the fragment's tag for the epilog tag, transmogrify the fragment (epilog); exit.
Se the fragment's tag for the push value tag, transmogrify the fragment (push value); exit.
Se the fragment's tag for the call external tag, transmogrify the fragment (call external); exit.
Se the fragment's tag for the load eax tag, transmogrify the fragment (load eax); exit.
Se the fragment's tag for the save eax tag, transmogrify the fragment (save eax); exit.
Se the fragment's tag for the call indirect tag, transmogrify the fragment (call indirect); exit.
Se the fragment's tag for the routine address tag, transmogrify the fragment (routine address); exit.

Etapas necessárias para que se transmogrify um fragment (break):
Coloque the repeat tag into uma tag.
Encontre another fragment usando the fragment e the tag.
Se the other fragment for inexistente, coloque the finalize tag into the tag. \ por break sem um loop ou after um loop
Encontre um third fragment usando the current routine's fragments' last e the tag (backwards).
Se the third fragment for inexistente, abort with "Erro interno - transmogrify um fragment (break)"; exit.
Se the third fragment's next for inexistente, abort with "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 e the third fragment's next's address to the fragment. \ JMP the destination's address

Etapas necessárias para que se transmogrify um fragment (call external):
Attach $FF15 e the fragment's entry's address to the fragment's code. \ call [the fragment's entry's address]

Etapas necessárias para que se transmogrify um fragment (call indirect):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Attach $FF12 to the fragment's code. \ call [edx]

Etapas necessárias para que se transmogrify um fragment (call internal):
Obtenha um address usando the fragment's routine.
Attach $E8 e the address to the fragment. \ call the fragment's routine's address

Etapas necessárias para que se transmogrify um fragment (dereference):
Attach $8B95 e the fragment's variable's offset to the fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
Attach $8B12 to the fragment's code. \ mov edx,[edx]
Attach $8995 e the fragment's variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

Etapas necessárias para que se transmogrify um fragment (epilog):
Se the current routine's callback sinal estiver verde, attach $5F5E5B to the fragment's code. \ pop edi, esi, ebx
Attach $8BE5 to the fragment's code. \ mov esp,ebp
Attach $5D to the fragment's code. \ pop ebp
Attach $C2 e the current routine's parameter size to the fragment's code. \ ret the current routine's parameter size

Etapas necessárias para que se transmogrify um fragment (exit):
Encontre another fragment usando the fragment e the finalize tag.
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 e the other fragment's address to the fragment. \ jmp the destination's address

Etapas necessárias para que se transmogrify um fragment (increment):
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (increment)"; exit.
Se the fragment's variable's kind não for "scratch", abort with "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 e the fragment's variable's offset e the fragment's número to the fragment's code. \ adicione [ebp+the fragment's variable's offset],the fragment's número

Etapas necessárias para que se transmogrify um fragment (jump false):
Encontre another fragment usando the fragment e the end if tag.
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 to the fragment's code. \ cmp eax,0
Attach $0F84 e the other fragment's address to the fragment. \ je the destination's address

Etapas necessárias para que se transmogrify um fragment (load address):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Attach $8995 e the fragment's other variable's offset to the fragment's code. \ mov [ebp+the fragment's variable's offset],edx

\Etapas necessárias para que se transmogrify um fragment (load eax):
\Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
\Se the fragment's variable for inexistente, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type for inexistente, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type's length não for 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (load eax):
Attach $B8 e the fragment's sinal to the fragment's code. \ mov eax,sinal
\Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
\Se the fragment's variable for inexistente, abort with "Internal error - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type for inexistente, abort with "Internal error 2 - transmogrify um fragment (load eax)"; exit.
\Se the fragment's variable's type's length não for 4, abort with "Internal error 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to the fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (not):
Attach $83F001 to the fragment's code. \ xor eax,1

Etapas necessárias para que se transmogrify um fragment (prolog):
Attach $55 to the fragment's code. \ push ebp
Attach $8BEC to the fragment's code. \ mov ebp,esp
Coloque the current routine's local size dividido por 4 into um número.
Se the número não for 0, attach $B9 e the número e $6A004975FB to the fragment's code. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
Se the current routine's callback sinal estiver verde, attach $535657 to the fragment's code. \ push ebx, esi, edi

Etapas necessárias para que se transmogrify um fragment (push address):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Attach $52 to the fragment's code. \ push edx

Etapas necessárias para que se transmogrify um fragment (push value):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (push value)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Coloque the fragment's variable's type's length into um length.
Se the length for 4, attach $FF32 to the fragment's code; exit. \ push [edx]
Se the length for 2, attach $66FF32 to the fragment's code; exit. \ push word ptr [edx]
Se the length for 1, attach $0FB61252 to the fragment's code; exit. \ movzxb edx,[edx]; push edx
Abort with "Erro interno 3 - transmogrify um fragment (push value)".

Etapas necessárias para que se transmogrify um fragment (repeat):
Encontre another fragment usando the fragment e the loop tag (backwards).
Se the other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 e the other fragment's address to the fragment. \ jmp the destination's address

Etapas necessárias para que se transmogrify um fragment (routine address):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Se the fragment's routine for inexistente, abort with "Erro interno - transmogrify um fragment (routine address)"; exit.
Obtenha um address usando the fragment's routine.
Attach $C702 e the address to the fragment's code. \ mov [edx],the address

Etapas necessárias para que se transmogrify um fragment (save eax):
Attach address loading code to the fragment's code usando the fragment's variable. \ coloque address into edx
Se the fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (save eax)"; exit.
Se the fragment's variable's type for inexistente, abort with "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Coloque the fragment's variable's type's length into um length.
Se the length for 4, attach $8902 to the fragment's code; exit. \ mov [edx],eax
Se the length for 2, attach $668902 to the fragment's code; exit. \ mov [edx],ax
Se the length for 1, attach $8802 to the fragment's code; exit. \ mov [edx],al
Abort with "Erro interno 3 - transmogrify um fragment (save eax)".

Etapas necessárias para que se transmogrify alguns fragments:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha um fragment from the fragments.
Se the fragment for inexistente, cancele.
Transmogrify the fragment.
Repita.

Etapas necessárias para que se transmogrify uma routine:
Se the compilador's sinal de alerta estiver presente, cancele.
Se the routine for inexistente, cancele.
Se the routine's employs moniker não estiver em branco, cancele.
Se the routine's compiled sinal não estiver verde, cancele.
Coloque the routine into the current routine.
Transmogrify the routine's fragments.

Etapas necessárias para que se transmogrify alguns routines:
Se the compilador's sinal de alerta estiver presente, cancele.
Obtenha uma routine from the routines.
Se the routine for inexistente, pare.
Transmogrify the routine.
Repita.

The transmogrifying timer é um timer.

The type index é um index.

An type é uma coisa with
An locus (reference),
An name, um plural name,
An partial moniker,
An length,
An base name, um base type (reference),
An target name, um target type (reference) [endereço de memórias only],
An scale ratio,
Some fields [records only],
An cooking sinal,
An optional info resolved sinal.

An type name é um name.

The types are alguns types.

The utility index é um index.

An variable é uma coisa with
An locus (reference),
An kind [literal, global, local, parameter, scratch],
An compiled sinal,
An name, um nickname, um type name,
An type (reference), \ actual type on literal, global, local; dereferenced type on parameters e scratches
An address [globals e literals only] ou 
An offset at the address [locals, parameters, e fields only],
An count [fields only],
An reference sinal [fields only],
An redefinition target name [fields only],
An by-value sinal [parameters only],
An global body [globals only],
An initializer string [globals only],
An literal (reference) [globals only - constant with which to initalize the global],
An texto hexadecimal called data [literals only].

The writing timer é um timer.

Etapas necessárias para que se skip any trailing noise in um substring:
Se the substring estiver em branco, cancele.
Se the substring's last's target não for noise, cancele.
Subtraia 1 from the substring's last.
Repita.

\ dahn - reverse functions
\ to coloque the xxx uv a/the yyy into zzz
\ internally we vire this into "to coloque a/the yyy's xxx into zzz"
Etapas necessárias para que se compile the header of uma routine usando um percorredor (reverse-possessive function):
Se the compilador's sinal de alerta estiver presente, cancele.
Abra the routine's function sinal.
Adicione um monikette to the routine's monikettes usando "coloque".
Mova the percorredor (compilador rules). \ skip "coloque" ou "poner"
Mova the percorredor (compilador rules). \ skip "the" ou Portuguese definite article
Examine um name usando the percorredor. \ field name
Mova the percorredor (compilador rules). \ skip "uv" ou "de"
Se the percorredor's token for any indefinite article, abra um sinal.
Se the sinal estiver verde, compile the routine's monikettes e the routine's parameters usando the percorredor (indefinite article).
Se the sinal não estiver verde, compile the routine's monikettes e the routine's parameters usando the percorredor (definite article).
Adicione another monikette to the routine's monikettes usando "'s " then the name.
Se the percorredor's token não for any reverse-possessive function into, abort with "Esperava a palavra 'em', mas encontrei '" then the percorredor's token then "'." e the percorredor; exit.
Adicione um third monikette to the routine's monikettes usando "into".
Convert the routine's monikettes to um moniker.
Se the moniker estiver in the routine index, abort with "Já sei como '" then the moniker then "'." e the routine's locus; exit.
Catalogue the routine usando the routine's monikettes e the routine index.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any indefinite article, abort with "Esperava um artigo indefinido, mas encontrei '" then the percorredor's token then "'." e the percorredor; exit.
Compile the routine's monikettes e the routine's parameters usando the percorredor (indefinite article).
Se the percorredor's token não estiver em branco, abort with "Existem outras coisas no final desta função." e the percorredor; exit.
Convert the routine's monikettes to the routine's moniker.
Catalogue the routine usando the routine's monikettes e the routine index. \ por employs

\ dahn - reverse functions
\ to coloque the xxx uv a/the yyy into zzz
Etapas necessárias para que se determine se um percorredor é the start of any reverse-possessive function:
Se the compilador's sinal de alerta estiver verde, diga não.
Se the percorredor's token não for any coloque, diga não.
Privatize the percorredor.
Mova the percorredor (compilador rules).
Se the percorredor's token não for any definite article, diga não.
Mova the percorredor (compilador rules).
Examine um name usando the percorredor.
Se the percorredor não for on any reverse-possessive, diga não.
Diga sim.
\finalmente