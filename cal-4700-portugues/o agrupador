\ o compilador (el compilador) copyright © 2006-2021 o osmosian order

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

An mensagem de erro é um string.

Etapas necessárias para que se abort with um string:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o alarme de alerta deste compilador.
Coloque o string into a mensagem de erro deste compilador.

Etapas necessárias para que se abort with um string e um endereço de memória du pedaço :
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o alarme de alerta deste compilador.
Coloque o string into a mensagem de erro deste compilador.
Encontre o abort endereço completo deste compilador e o abort row# deste compilador usando o endereço de memória du pedaço .
Se o abort endereço completo deste compilador estiver em branco, cancele.
Extract um nome du arquivo from o abort endereço completo deste compilador.
Anteponha "Erro no " then o nome du arquivo then ". " to a mensagem de erro deste compilador.

Etapas necessárias para que se abort with um string e um percorredor:
Se o token deste percorredor não estiver em branco, abort with o string e o first deste token deste percorredor; exit.
Abort with o string e o last deste source deste percorredor.

Etapas necessárias para que se adicione o allocate e deallocate e finalize e destroy routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Adicione o finalize routine por o type.
Adicione o allocate routine por o type.
Adicione o deallocate routine por o type.
Adicione o destroy routine por o type.
Repita.

Etapas necessárias para que se adicione o allocate routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o target type deste type for inexistente, cancele.
Adicione uma routine to o routines usando nil.
Posponha "Allocate memory por um " then o name deste type to o header string desta routine. \ traduzir aqui
Posponha "Assign o " then o name deste type then " usando " to o body string desta routine.
Posponha o length deste target type deste type then "." to o body string desta routine.
Lance o routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of o routine.

Etapas necessárias para que se adicione e compile o initialize before run e run e finalize after run routine:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine to o routines usando nil.
Posponha "~initialize before run e run e finalize after run" to o header string desta routine.
Posponha "initialize before run. " to o body string desta routine.
Posponha o global initializers to o body string desta routine.
Posponha "nosso programa seja executado. " to o body string desta routine. \ traduzir
Posponha o global finalizers to o body string desta routine.
Posponha "finalize after run. " to o body string desta routine.
Posponha "call ""kernel32.dll"" ""ExitProcess"" with 0. " to o body string desta routine.
Lance o routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of o routine.
Compile o body of o routine.

Etapas necessárias para que se adicione o built-in types:
Adicione um built-in type usando "byte" e "bytes" e 1.
Adicione another built-in type usando "record" e "records" e 0.
Adicione um third built-in type usando "pedaço" e "pedaços" e 1.
Adicione um fourth built-in type usando "conjunto" e "conjuntos" e 0.

Etapas necessárias para que se adicione um built-in type usando um name e um plural name e um length:
Adicione o built-in type to o types usando o name e o plural name e o name.
Coloque o length into o length deste built-in type.
Coloque o built-in type into o base type deste built-in type.
Catalogue o built-in type.

Etapas necessárias para que se adicione o deallocate routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o target type deste type for inexistente, cancele.
Adicione uma routine to o routines usando nil.
Posponha "Deallocate um " then o name deste type to o header string desta routine.
Posponha "Se o " then o name deste type then " for inexistente, cancele. " to o body string desta routine.
Se o target type deste type deveria ser [estar] finalizado, posponha "~finalize o " then o name deste type then "'s target. " to o body string desta routine.
Posponha "Unassign o " then o name deste type then "." to o body string desta routine.
Lance o routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of o routine.

Etapas necessárias para que se adicione o destroy routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não deveria ser ignorado, cancele.
Se o type puder ser reduzido para "coisas", adicione o destroy routine por o type (coisas); exit.
Se o type puder ser reduzido para "endereço de memória", adicione o destroy routine por o type (endereço de memória); exit.

Etapas necessárias para que se adicione o destroy routine por um type (endereço de memória):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque "Destroy [" then o name deste type then "]" into um moniker.
Se o moniker estiver in o catálogo geral de rotinas, cancele.
Adicione uma routine to o routines usando nil.
Posponha "Destroy um " then o name deste type to o header string desta routine.
Posponha "Se o " then o name deste type then " for inexistente, cancele. " to o body string desta routine.
Se o target type deste type puder ser reduzido para "endereço de memória", posponha "Destroy o " then o name deste type then "'s target. " to o body string desta routine.
Se o target type deste type puder ser reduzido para "coisas", posponha "Destroy o " then o name deste type then "'s target. " to o body string desta routine.
Percorra.
Obtenha um field from os fields deste target type deste type.
Se o field for inexistente, pare.
Se o reference alarme deste field estiver ativo, repita.
Se o type deste field não deveria ser ignorado, repita.
Posponha "Destroy o " then o name deste type then "'s " then o name deste field then ". " to o body string desta routine.
Repita.
Posponha "Deallocate o " then o name deste type then ". " to o body string desta routine. \ traduzir aqui
Lance o routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of o routine.

Etapas necessárias para que se adicione o destroy routine por um type (coisas):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
\Coloque "Erro interno na hora de executar a tarefa de destruição de tipos" into a reply.
Se o first destes fields deste type for inexistente, abort with "Erro interno na rotina 'adicione um forget routine por um type (coisas)'"; [Say o reply;] exit. \Adicionado Say o reply
Se o type deste first destes fields deste type for inexistente, abort with "Erro interno 2 na rotina 'adicione o forget routine por um type (coisas)'"; exit.
Coloque "Destroy [" then o name deste type then "]" into um moniker.
Se o moniker estiver in o catálogo geral de rotinas, cancele.
Adicione uma routine to o routines usando nil.
Posponha "Destroy um " then o name deste type to o header string desta routine.
Posponha "Se o " then o name deste type then "'s first for inexistente, cancele. " to o body string desta routine.
Coloque o name deste type deste first destes fields deste type into um name.
Posponha "Coloque o " then o name deste type then "'s first into um " then o name then ". " to o body string desta routine.
Posponha "Remove o " then o name then " from o " then o name deste type then ". " to o body string desta routine.
Posponha "Destroy o " then o name then ". " to o body string desta routine.
Posponha "Repeat. " to o body string desta routine.
Lance o routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of o routine.

Etapas necessárias para que se adicione um entry to alguns imports usando um import name e um entry name:
Encontre um import usando o import name.
Se o import for inexistente, adicione o import to o imports usando o import name.
Encontre o entry usando o entry name e as entries deste import.
Se o entry não for inexistente, cancele.
Crie o entry.
Posponha o entry to as entries deste import.
Coloque o entry name into o name desta entry.

Etapas necessárias para que se adicione um field to alguns fields usando um name e um nickname e um type name e um reference alarme:
Adicione o field to o fields usando "field" e nil.
Coloque o name into o name deste field.
Coloque o nickname into o nickname deste field.
Coloque o type name into o type name deste field.
Coloque o reference alarme into o reference alarme deste field.

Etapas necessárias para que se adicione o finalize routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não deveria ser finalizado, cancele.
Se o name deste type for "string", adicione o finalize routine por o type (string); exit.
Se o type puder ser reduzido para "string", cancele. \ prevents generation of finalizer por derived string types
Adicione o finalize routine por o type (conjunto).

Etapas necessárias para que se adicione o finalize routine por um type (conjunto):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine to o routines usando nil.
Posponha "~finalize um " then o name deste type to o header string desta routine.
Posponha "intel $50. " to o body string desta routine. \ push eax
Percorra.
Obtenha um field from os fields deste type.
Se o field for inexistente, pare.
Se o type deste field não deveria ser finalizado, repita.
Posponha "~finalize o " then o name deste type then "'s " then o name deste field then ". " to o body string desta routine.
Repita.
Posponha "intel $58." to o body string desta routine. \ pop eax
Lance o routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of o routine.

Etapas necessárias para que se adicione o finalize routine por um type (string):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine to o routines usando nil.
Posponha "~finalize um " then o name deste type to o header string desta routine.
Posponha "intel $50. " to o body string desta routine. \ push eax
Posponha "unassign o string's first. " to o body string desta routine.
Posponha "intel $58." to o body string desta routine. \ pop eax
Lance o routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of o routine.

Etapas necessárias para que se adicione um fragment usando uma tag:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.

Etapas necessárias para que se adicione um fragment usando uma tag e um entry:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o entry into a entry deste fragment.

Etapas necessárias para que se adicione um fragment usando uma tag e um alarme:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o alarme into o alarme deste fragment.

Etapas necessárias para que se adicione um fragment usando uma tag e uma routine:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o routine into a routine deste fragment.
Compile o body of o routine.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o variable into o variable deste fragment.
Ligue o compiled alarme in o variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e another variable:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o variable into a variable deste fragment.
Coloque o other variable into o fragment's other variable.
Ligue o compiled alarme in o variable.
Ligue o compiled alarme in o other variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e um número:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o variable into a variable deste fragment.
Coloque o número into o número deste fragment.
Ligue o compiled alarme in o variable.

Etapas necessárias para que se adicione um import to alguns imports usando um import name:
Crie o import.
Posponha o import to o imports.
Coloque o import name into o name deste import.

Etapas necessárias para que se adicione um intermediate usando um type name e um locus:
Se a rotina utilizada atualmente for inexistente, esvazie o intermediate; exit.
Adicione o intermediate to os locals desta rotina utilizada atualmente usando "local" e o locus.
Gere o name deste intermediate usando "~I".
Coloque o type name into o type name deste intermediate.
Resolva o intermediate.

Etapas necessárias para que se adicione um literal to alguns variables usando um locus:
Adicione o literal como uma variable to o variables usando "literal" e o locus.
Gere o name deste literal usando "~L".

Etapas necessárias para que se adicione um monikette to alguns monikettes usando um expression:
Crie o monikette.
Posponha o monikette to o monikettes.
Coloque a phrase desta expression into o string deste monikette.
Coloque a variable desta expression into a variable deste monikette.
Se a variable desta expression não for inexistente, coloque o type desta expression into o type deste monikette.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette to alguns monikettes usando um string:
Crie o monikette.
Posponha o monikette to o monikettes.
\PAL
\\ conjunctions
Se o string for "e", coloque "e" into o string deste monikette; exit. \ and
Se o string for "ou", coloque "or" into o string deste monikette; exit. \ or
\ from/given/with/using
Se o string for "desde", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "a partir de", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "partindo de", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "de", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "dada", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "dado", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "dadas", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "dados", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "com", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "usando", coloque "from/given/with/using" into o string deste monikette; exit.
\\ in/into/to
Se o string for "em", coloque "in/into/to" into o string deste monikette; exit.
Se o string for "a", coloque "in/into/to" into o string deste monikette; exit.
\\ is/are
Se o string for "é", coloque "is/are" into o string deste monikette; exit.
Se o string for "está", coloque "is/are" into o string deste monikette; exit.
Se o string for "for", coloque "is/are" into o string deste monikette; exit. 
Se o string for "foi", coloque "is/are" into o string deste monikette; exit. 
Se o string for "foram", coloque "is/are" into o string deste monikette; exit. 
Se o string for "forem", coloque "is/are" into o string deste monikette; exit. 
Se o string for "estiver", coloque "is/are" into o string deste monikette; exit.
Se o string for "estiverem", coloque "is/are" into o string deste monikette; exit.
\Se o string for "tem", coloque "is/are" into o string deste monikette; exit.
\Se o string for "tiver", coloque "is/are" into o string deste monikette; exit.
Se o string for "are", coloque "is/are" into o string deste monikette; exit.
Se o string for "são", coloque "is/are" into o string deste monikette; exit.
Se o string for "estão", coloque "is/are" into o string deste monikette; exit.
Se o string for "is", coloque "is/are" into o string deste monikette; exit.
Se o string for "forem", coloque "is/are" into o string deste monikette; exit.
Se o string for "estiverem", coloque "is/are" into o string deste monikette; exit.
Se o string for "puder", coloque "pode" into o string deste monikette; exit.
Se o string for "puderem", coloque "pode" into o string deste monikette; exit.
Se o string for "existir", coloque "existe" into o string deste monikette; exit.
\Se o string for "decide", coloque "decidir" into o string deste monikette; exit.
\Se o string for "decidiu", coloque "decidir" into o string deste monikette; exit.
\Se o string for "decidindo", coloque "decidir" into o string deste monikette; exit. \melhor não por gerúndio ou verbos compostos
\Se o string for "decidiu-se", coloque "decidir" into o string deste monikette; exit.
Se o string for "existir", coloque "existe" into o string deste monikette; exit.
\\ allocates e destroys
\Se o string for "alojar", coloque "allocate" into o string deste monikette; exit.
Se o string for "aloje", coloque "allocate" into o string deste monikette; exit.
\Se o string for "alocar", coloque "allocate" into o string deste monikette; exit.
Se o string for "aloque", coloque "allocate" into o string deste monikette; exit.
\Se o string for "reservar", coloque "allocate" into o string deste monikette; exit.
Se o string for "reserve", coloque "allocate" into o string deste monikette; exit.
Se o string for "memória", coloque "memory" into o string deste monikette; exit.
\Se o string for "for", coloque "por" into o string deste monikette; exit. \\servia pra converter o "for" para "por"
Se o string for "pelo", coloque "por the" into o string deste monikette; exit. 
Se o string for "pela", coloque "por the" into o string deste monikette; exit. 
\Se o string for "desalocar", coloque "deallocate" into o string deste monikette; exit.
Se o string for "desaloque", coloque "deallocate" into o string deste monikette; exit.
\Se o string for "desalojar", coloque "deallocate" into o string deste monikette; exit.
Se o string for "desaloje", coloque "deallocate" into o string deste monikette; exit.
\Se o string for "esvaziar", coloque "deallocate" into o string deste monikette; exit.
\Se o string for "esvazie", coloque "deallocate" into o string deste monikette; exit.
Se o string for "destruir", coloque "destroy" into o string deste monikette; exit.
\CAL
\\ from/given/with/using
Se o string for "from", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "given", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "with", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "using", coloque "from/given/with/using" into o string deste monikette; exit.
\ in/into/to
Se o string for "in", coloque "in/into/to" into o string deste monikette; exit.
Se o string for "into", coloque "in/into/to" into o string deste monikette; exit.
Se o string for "to", coloque "in/into/to" into o string deste monikette; exit.
\ is/are
Se o string for "are", coloque "is/are" into o string deste monikette; exit.
Se o string for "is", coloque "is/are" into o string deste monikette; exit.
\ aren't/isn't
Se o string for "isn't", coloque "is/aren't" into o string deste monikette; exit.
Se o string for "aren't", coloque "is/aren't" into o string deste monikette; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se o string for "backward", coloque "backward" into o string deste monikette; exit.
Se o string for "backwards", coloque "backward" into o string deste monikette; exit.
Se o string for "counterclockwise", coloque "backward" into o string deste monikette; exit.
Se o string for "counter-clockwise", coloque "backward" into o string deste monikette; exit.
Se o string for "anticlockwise", coloque "backward" into o string deste monikette; exit.
Se o string for "anti-clockwise", coloque "backward" into o string deste monikette; exit.
\ at/on
Se o string for "at", coloque "at/on" into o string deste monikette; exit.
Se o string for "on", coloque "at/on" into o string deste monikette; exit.
\ other
Coloque o string into o string deste monikette.

Etapas necessárias para que se adicione um monikette to alguns monikettes usando um type:
Crie o monikette.
Posponha o monikette to o monikettes. 
Coloque o type into o type deste monikette.

Etapas necessárias para que se adicione push fragments usando alguns monikettes:
Se a rotina utilizada atualmente for inexistente, cancele.
Percorra.
Obtenha um monikette from o monikettes (backwards).
Se o monikette for inexistente, cancele.
Se a variable deste monikette for inexistente, repita.
Se o subtexto atual deste monikette não estiver em branco, repita.
Se o type atual deste monikette for inexistente, repita.
Adicione um fragment usando o push address tag e a variable deste monikette.
Repita.

Etapas necessárias para que se adicione o coloque ou convert fragments usando uma variable e another variable e um locus:
Adicione um fragment usando o push address tag e o other variable.
Adicione another fragment usando o push address tag e o variable.
Encontre uma routine usando "coloque" e o type desta variable e "into" e o other variable's type.
Se a routine for inexistente, encontre o routine usando "convert" e o type desta variable e "to" e o other variable's type.
Se o routine não for inexistente, adicione um third fragment usando o call internal tag e o routine; exit.
\ erro message
Adicione um monikette to alguns monikettes usando "coloque/convert".
Adicione another monikette to o monikettes usando o type desta variable.
Adicione um third monikette to o monikettes usando "into/to".
Adicione um fourth monikette to o monikettes usando o other variable's type.
Convert o monikettes to um moniker.
Destroy o monikettes.
Abort with "Eu não sei como '" then o moniker then "'." e o locus.

Etapas necessárias para que se adicione uma routine to alguns routines usando um locus:
Crie o routine.
Posponha o routine to o routines.
Coloque o locus into o locus desta routine.

Etapas necessárias para que se adicione um scratch usando um type name e um locus:
Se a rotina utilizada atualmente for inexistente, esvazie o scratch; exit.
Adicione o scratch to os locals desta rotina utilizada atualmente usando "scratch" e o locus.
Gere o name deste scratch usando "~S".
Coloque o type name into o type name deste scratch.
Resolva o scratch.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um locus:
Adicione um fragment usando o push address tag e o other variable.
Adicione another fragment usando o push address tag e o variable.
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to o monikettes usando o type desta variable.
Adicione um third monikette to o monikettes usando o other string.
Adicione um fourth monikette to o monikettes usando o other variable's type.
Encontre uma routine usando o monikettes.
Se a routine for inexistente, convert o monikettes to um moniker.
Destroy o monikettes.
Se a routine for inexistente, abort with "Eu não sei como '" then o moniker then "'." e o locus; exit.
Adicione um third fragment usando o call internal tag e o routine.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um third string e um third variable e um endereço de memória du pedaço :
Adicione um fragment usando o push address tag e o third variable.
Adicione another fragment usando o push address tag e o other variable.
Adicione um third fragment usando o push address tag e o variable.
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to o monikettes usando o type desta variable.
Adicione um third monikette to o monikettes usando o other string.
Adicione um fourth monikette to o monikettes usando o other variable's type.
Adicione um fifth monikette to o monikettes usando o third string.
Adicione um sixth monikette to o monikettes usando o type desta third variable.
Encontre uma routine usando o monikettes.
Se a routine for inexistente, convert o monikettes to um moniker.
Destroy o monikettes.
Se a routine for inexistente, abort with "Eu não sei como '" then o moniker then "'." e o endereço de memória du pedaço; exit.
Adicione um fourth fragment usando o call internal tag e o routine.

Etapas necessárias para que se adicione um source file to alguns source files usando um endereço completo:
Crie o source file.
Posponha o source file to o source files.
Coloque o endereço completo into o endereço completo deste source file.

Etapas necessárias para que se adicione two fragments usando um string e uma variable e um locus:
Adicione um fragment usando o push address tag e o variable.
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to o monikettes usando o type desta variable.
Encontre uma routine usando o monikettes.
Se a routine for inexistente, convert o monikettes to um moniker.
Destroy o monikettes.
Se a routine for inexistente, abort with "Eu não sei como '" then o moniker then "'." e o locus; exit.
Adicione another fragment usando o call internal tag e o routine.

Etapas necessárias para que se adicione um type to alguns types usando um locus:
Crie o type.
Posponha o type to o types.
Coloque o locus into o locus deste type.

Etapas necessárias para que se adicione um type to alguns types usando um name e um plural name e um base name:
Adicione o type to o types usando o name e o plural name e o base name e nil.

Etapas necessárias para que se adicione um type to alguns types usando um name e um plural name e um base name e um locus:
Crie o type.
Posponha o type to o types.
Coloque o locus into o locus deste type.
Coloque o name into o name deste type.
Coloque o plural name into o plural name deste type.
Coloque o base name into o base name deste type.

Etapas necessárias para que se adicione uma variable to alguns variables usando um categoria e um locus:
Crie o variable usando o categoria.
Posponha o variable to o variables.
Coloque o locus into o locus desta variable.

The adding built-in memory routines cronômetro é um cronômetro.

The adding built-in startup routine cronômetro é um cronômetro.

Etapas necessárias para que se address alguns entries:
Obtenha um entry from o entries.
Se o entry for inexistente, cancele.
Address o entry.
Repita.

Etapas necessárias para que se address um entry:
Coloque o endereço du nome usado atualmente into o name address desta entry.
Coloque o length deste name deste entry mais 3 into um número.
Round o número up to o nearest multiple of 2.
Adicione o número to o endereço du nome usado atualmente.
Coloque o current thunk address into o thunk address desta entry.
Coloque o image base mais o current thunk address into o address desta entry.
Adicione 4 to o current thunk address.

Etapas necessárias para que se address um fragment usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Coloque o image base mais o address into o address deste fragment.
Se a tag deste fragment for a push address tag, adicione 7 to o address; exit.
Se a tag deste fragment for a call internal tag, adicione 5 to o address; exit.
Se a tag deste fragment for a load address tag, adicione 12 to o address; exit.
Se a tag deste fragment for a increment tag, adicione 10 to o address; exit.
Se a tag deste fragment for a dereference tag, adicione 14 to o address; exit.
Se a tag deste fragment for a jump false tag, adicione 9 to o address; exit.
Se a tag deste fragment for a not tag, adicione 3 to o address; exit.
Se a tag deste fragment for a exit tag, adicione 5 to o address; exit.
Se a tag deste fragment for a repeat tag, adicione 5 to o address; exit.
Se a tag deste fragment for a break tag, adicione 5 to o address; exit.
Se a tag deste fragment for a prolog tag, address o fragment usando o address (prolog); exit.
Se a tag deste fragment for a epilog tag, address o fragment usando o address (epilog); exit.
Se a tag deste fragment for a intel tag, adicione o length deste code deste fragment to o address; exit.
Se a tag deste fragment for a push value tag, address o fragment usando o address (push value); exit.
Se a tag deste fragment for a call external tag, adicione 6 to o address; exit.
Se a tag deste fragment for a load eax tag, adicione 5 to o address; exit. \ was 8 when "load eax" took in variables; now "load eax" only does um immediate value
Se a tag deste fragment for a save eax tag, address o fragment usando o address (save eax); exit.
Se a tag deste fragment for a call indirect tag, adicione 8 to o address; exit.
Se a tag deste fragment for a routine address tag, adicione 12 to o address; exit.

Etapas necessárias para que se address um fragment usando um address (epilog):
Se o callback alarme desta rotina utilizada atualmente estiver ativo, adicione 3 to o address.
Adicione 6 to o address.

Etapas necessárias para que se address um fragment usando um address (prolog):
Adicione 3 to o address.
Se o local size desta rotina utilizada atualmente não for 0, adicione 10 to o address.
Se o callback alarme desta rotina utilizada atualmente estiver ativo, adicione 3 to o address.

Etapas necessárias para que se address um fragment usando um address (push value):
Adicione 6 to o address.
Se a variable deste fragment for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se o type desta variable deste fragment for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Coloque o length deste type desta variable deste fragment into um length.
Se o length for 4, adicione 2 to o address; exit.
Se o length for 2, adicione 3 to o address; exit.
Se o length for 1, adicione 4 to o address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address um fragment usando um address (save eax):
Adicione 6 to o address.
Se o variable deste fragment for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se o type desta variable deste fragment for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Coloque o length deste type desta variable deste fragment into um length.
Se o length for 4, adicione 2 to o address; exit.
Se o length for 2, adicione 3 to o address; exit.
Se o length for 1, adicione 2 to o address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address alguns fragments usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Address o fragment usando o address.
Repita.

Etapas necessárias para que se address um import:
Coloque o endereço du nome usado atualmente into o name address deste import.
Coloque o endereço du cabeçalho usado atualmente into o header address deste import.
Coloque o endereço du nome usado atualmente into o name memory address deste import header deste import.
Coloque o length deste name deste import mais 1 into um número.
Round o número up to o nearest multiple of 2.
Adicione o número to o endereço du nome usado atualmente.
Adicione um import header's magnitude to o endereço du cabeçalho usado atualmente. \ tenho que traduzir com calma isso depois
Coloque o current thunk address into o first thunk memory address deste import header deste import.
Address as entries deste import.
Adicione 4 to o current thunk address.

Etapas necessárias para que se address alguns imports usando um address:
Coloque o address into o endereço du cabeçalho usado atualmente.
Coloque as contagem destes imports into um contagem.
Adicione 1 to o contagem.
Multiplique a contagem por um import header's magnitude.
Coloque o address mais o contagem into o current thunk address.
Obtenha another contagem usando o imports (all entries mais markers).
Multiplique o other contagem por 4.
Coloque o current thunk address mais o other contagem into o endereço du nome usado atualmente.
Percorra.
Obtenha um import from o imports.
Se o import for inexistente, pare.
Address o import.
Repita.
Coloque o endereço du nome usado atualmente menos o address into um número.
Adicione o número to o address.

An address é um número.

Etapas necessárias para que se address uma routine usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o employs moniker desta routine não estiver em branco, cancele. \ employs são addressed later
Se o compiled alarme desta routine não estiver ativo, cancele.
Coloque o routine into a rotina utilizada atualmente.
Coloque o image base mais o address into o address desta routine.
Address os fragments desta routine usando o address.
Round o address up to o nearest multiple of 4.

Etapas necessárias para que se address alguns routines usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from o routines.
Se a routine for inexistente, pare.
Address o routine usando o address.
Repita.

Etapas necessárias para que se address uma variable usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Se o compiled alarme desta variable não estiver ativo, cancele.
Coloque o image base mais o address into o address desta variable.
Adicione o length deste type desta variable to o address.
Se o type desta variable puder ser reduzido para "string", adicione o length deste data desta variable mais 1 to o address.
Round o address up to o nearest multiple of 4.

Etapas necessárias para que se address alguns variables usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Address o variable usando o address.
Repita.

The addressing cronômetro é um cronômetro.

Etapas necessárias para que se advance um trecho:
Posponha o return pedaço to o trecho.
Posponha o linefeed pedaço to o trecho.

Etapas necessárias para que se advance um trecho (twice):
Advance o trecho. 
Advance o trecho.

Etapas necessárias para que se posponha um entry to um trecho (with separator):
Se o entry for inexistente, posponha "" to o trecho (with separator); exit.
Posponha o name desta entry to o trecho (with separator).

Etapas necessárias para que se posponha um alarme to um trecho (with separator):
Convert o alarme to um string.
Posponha o string to o trecho (with separator).

Etapas necessárias para que se posponha o global finalizers to um string:
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Se o compiled alarme deste global não estiver ativo, repita.
Se o type deste global não deveria ser [estar] finalizado, repita.
Posponha "~finalize o " then o name deste global then ". " to o string.
Repita.

Etapas necessárias para que se posponha o global initializers to um string:
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Se o literal deste global for inexistente, repita.
Se o compiled alarme deste global não estiver ativo, repita.
Desative um alarme.
Posponha o initializer string deste global to o string.
Repita.

Etapas necessárias para que se posponha um monikette to um moniker:
Se o monikette for inexistente, cancele.
Se o moniker não estiver em branco, posponha o space pedaço to o moniker.
Se o type deste monikette não for inexistente, posponha "[" e o name deste type deste monikette e "]" to o moniker (fast); exit.
Se o string deste monikette não estiver em branco, posponha o string deste monikette to o moniker; exit.

Etapas necessárias para que se posponha um monikette to um moniker (while bubbling):
Se o monikette for inexistente, cancele.
Se o moniker não estiver em branco, posponha o space pedaço to o moniker.
Se o subtexto atual deste monikette não estiver em branco, posponha o subtexto atual deste monikette to o moniker; exit.
Se o type atual deste monikette não for inexistente, posponha "[" e o name deste type atual deste monikette e "]" to o moniker (fast); exit.

Etapas necessárias para que se posponha um número to um trecho (as hex with separator):
Convert o número to um texto dâ cifra binária.
Posponha o texto dâ cifra binária to o trecho (with separator).

Etapas necessárias para que se posponha um número to um trecho (with separator):
Convert o número to um string.
Posponha o string to o trecho (with separator).

Etapas necessárias para que se posponha um ratio to um trecho (with separator):
Convert o ratio to um string.
Posponha o string to o trecho (with separator).

Etapas necessárias para que se posponha uma routine to um trecho (with separator):
Se a routine for inexistente, posponha "" to o trecho (with separator); exit.
Posponha o moniker deste routine to o trecho (with separator).

Etapas necessárias para que se posponha um string e another string e um third string to um fourth string (fast):
Coloque o length deste fourth string into um length.
Adicione o length deste string to o length.
Adicione o other string's length to o length.
Adicione o length deste third string to o length.
Reassign um endereço de memória usando o length.
Coloque o endereço de memória into um endereço de memória du pedaço .
Copy pedaços from o first deste fourth string to o endereço de memória du pedaço por o length deste fourth string.
Adicione o length deste fourth string to o endereço de memória du pedaço .
Copy pedaços from o first deste string to o endereço de memória du pedaço por o length deste string.
Adicione o length deste string to o endereço de memória du pedaço .
Copy pedaços from o other string's first to o endereço de memória du pedaço por o other string's length.
Adicione o other string's length to o endereço de memória du pedaço .
Copy pedaços from o first deste third string to o endereço de memória du pedaço por o length deste third string.
Unassign o first deste fourth string.
Coloque o endereço de memória into o first deste fourth string.
Coloque o endereço de memória mais o length menos 1 into o last deste fourth string.

Etapas necessárias para que se posponha um string to um trecho (with separator):
Posponha o string to o trecho.
Posponha "/" to o trecho.

Etapas necessárias para que se posponha uma tag to um trecho (as um fragment tag string with separator):
Se a tag for a break tag, posponha "break" to o trecho (with separator); exit.
Se a tag for a call external tag, posponha "call external" to o trecho (with separator); exit.
Se a tag for a call indirect tag, posponha "call indirect" to o trecho (with separator); exit.
Se a tag for a call internal tag, posponha "call internal" to o trecho (with separator); exit.
Se a tag for a dereference tag, posponha "dereference" to o trecho (with separator); exit.
Se a tag for a end if tag, posponha "end if" to o trecho (with separator); exit.
Se a tag for a epilog tag, posponha "epilog" to o trecho (with separator); exit.
Se a tag for a exit tag, posponha "exit" to o trecho (with separator); exit.
Se a tag for a finalize tag, posponha "finalize" to o trecho (with separator); exit.
Se a tag for a increment tag, posponha "increment" to o trecho (with separator); exit.
Se a tag for a intel tag, posponha "intel" to o trecho (with separator); exit.
Se a tag for a jump false tag, posponha "jump false" to o trecho (with separator); exit.
Se a tag for a load address tag, posponha "load address" to o trecho (with separator); exit.
Se a tag for a load eax tag, posponha "load eax" to o trecho (with separator); exit.
Se a tag for a loop tag, posponha "loop" to o trecho (with separator); exit.
Se a tag for a not tag, posponha "not" to o trecho (with separator); exit.
Se a tag for a prolog tag, posponha "prolog" to o trecho (with separator); exit.
Se a tag for a push address tag, posponha "push address" to o trecho (with separator); exit.
Se a tag for a push value tag, posponha "push value" to o trecho (with separator); exit.
Se a tag for a save eax tag, posponha "save eax" to o trecho (with separator); exit.
Se a tag for a repeat tag, posponha "repeat" to o trecho (with separator); exit.
Se a tag for a routine address tag, posponha "routine address" to o trecho (with separator); exit.
Posponha "?" to o trecho (with separator).

Etapas necessárias para que se posponha um type to um trecho (with separator):
Se o type for inexistente, posponha "" to o trecho (with separator); exit.
Posponha o name deste type to o trecho (with separator).

Etapas necessárias para que se posponha uma variable to um trecho (with separator):
Se o variable for inexistente, posponha "" to o trecho (with separator); exit.
Posponha o name desta variable to o trecho (with separator).

Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules):
\# contrações
Se o string for "ao", posponha "para o" to o other string; exit.
\Se o string for "à", posponha "para a" to o other string; exit.
Se o string for "aos", posponha "para os" to o other string; exit.
Se o string for "às", posponha "para as" to o other string; exit.
\Se o string for "do", posponha "de o" to o other string; exit.
\Se o string for "da", posponha "de a" to o other string; exit.
\Se o string for "dos", posponha "de os" to o other string; exit.
\Se o string for "das", posponha "de as" to o other string; exit.
\Se o string for "dum", posponha "de um" to o other string; exit.
\Se o string for "duma", posponha "de uma" to o other string; exit.
\Se o string for "dumas", posponha "de umas" to o other string; exit.
\Se o string for "duns", posponha "de uns" to o other string; exit.
Se o string for "daqui", posponha "de aqui" to o other string; exit.
Se o string for "dali", posponha "de ali" to o other string; exit.
Se o string for "dele", posponha "de ele" to o other string; exit.
Se o string for "dela", posponha "de ela" to o other string; exit.
Se o string for "desse", posponha "de esse" to o other string; exit.
Se o string for "dessa", posponha "de essa" to o other string; exit.
Se o string for "desses", posponha "de esses" to o other string; exit.
Se o string for "dessas", posponha "de essas" to o other string; exit.
Se o string for "deste", posponha "de este" to o other string; exit.
Se o string for "desta", posponha "de esta" to o other string; exit.
Se o string for "destes", posponha "de estes" to o other string; exit.
Se o string for "destas", posponha "de estas" to o other string; exit.
Se o string for "disso", posponha "de isso" to o other string; exit.
Se o string for "disto", posponha "de isto" to o other string; exit.
Se o string for "nesse", posponha "em esse" to o other string; exit.
Se o string for "nesses", posponha "em esses" to o other string; exit.
Se o string for "neste", posponha "em este" to o other string; exit.
Se o string for "nestes", posponha "em estes" to o other string; exit.
Se o string for "nisso", posponha "em isso" to o other string; exit.
Se o string for "nisto", posponha "em isto" to o other string; exit.
Se o string for "nessa", posponha "em essa" to o other string; exit.
Se o string for "nessas", posponha "em essas" to o other string; exit.
Se o string for "nesta", posponha "em esta" to o other string; exit.
Se o string for "nestas", posponha "em estas" to o other string; exit.
Se o string for "donde", posponha "de onde" to o other string; exit.
Se o string for "dentre", posponha "de entre" to o other string; exit.
Se o string for "dantes", posponha "de antes" to o other string; exit.
Se o string for "dalguém", posponha "de alguém" to o other string; exit.
Se o string for "dalgum", posponha "de algum" to o other string; exit.
Se o string for "dalguma", posponha "de alguma" to o other string; exit.
Se o string for "dalguns", posponha "de alguns" to o other string; exit.
Se o string for "dalgumas", posponha "de algumas" to o other string; exit.
Se o string for "nalgum", posponha "em algum" to o other string; exit.
Se o string for "nalguma", posponha "em alguma" to o other string; exit.
Se o string for "nalguns", posponha "em alguns" to o other string; exit.
Se o string for "nalgumas", posponha "em algumas" to o other string; exit.
Se o string for "doutro", posponha "de outro" to o other string; exit.
Se o string for "doutra", posponha "de outra" to o other string; exit.
Se o string for "doutros", posponha "de outros" to o other string; exit.
Se o string for "doutras", posponha "de outras" to o other string; exit.
Se o string for "noutro", posponha "em outro" to o other string; exit.
Se o string for "noutra", posponha "em outra" to o other string; exit.
Se o string for "noutros", posponha "em outros" to o other string; exit.
Se o string for "noutras", posponha "em outras" to o other string; exit.
\# "no" pode ser uma negação em inglês.
Se o string for any contraction giving o third string (portuguese rules - "no"), posponha "em o" to o other string; exit.
Se o string for "na", posponha "em a" to o other string; exit.
Se o string for "nos", posponha "em os" to o other string; exit.
Se o string for "nas", posponha "em as" to o other string; exit.
\Se o string for "noutro", posponha "em outro" to o other string; exit.
\Se o string for "noutra", posponha "em outra" to o other string; exit.
\Se o string for "noutros", posponha "em outros" to o other string; exit.
\Se o string for "noutras", posponha "em outras" to o other string; exit.
Se o string for "num", posponha "em um" to o other string; exit.
Se o string for "numa", posponha "em uma" to o other string; exit.
Se o string for "nuns", posponha "em uns" to o other string; exit.
Se o string for "numas", posponha "em umas" to o other string; exit.
Se o string for "pelo", posponha "por o" to o other string; exit.
Se o string for "pela", posponha "por a" to o other string; exit.
Se o string for "pelos", posponha "por os" to o other string; exit.
Se o string for "pelas", posponha "por as" to o other string; exit.
\# sinônimos
Se o string for "adir", posponha "adicionar" to o other string; exit.
Se o string for "agregar", posponha "adicionar" to o other string; exit.
Se o string for "acrescentar", posponha "adicionar" to o other string; exit.
Se o string for "somar", posponha "adicionar" to o other string; exit.
Se o string for "começar", posponha "iniciar" to o other string; exit.
Se o string for "terminar", posponha "finalizar" to o other string; exit.
Se o string for "acabar", posponha "finalizar" to o other string; exit.
Se o string for "completar", posponha "finalizar" to o other string; exit.
Se o string for "colocar", posponha "pôr" to o other string; exit.
Se o string for "mudar", posponha "alterar" to o other string; exit.
Se o string for "limpar", posponha "apagar" to o other string; exit.
Se o string for "ampliar", posponha "aumentar" to o other string; exit.
Se o string for "expandir", posponha "aumentar" to o other string; exit.
Se o string for "alargar", posponha "aumentar" to o other string; exit.
Se o string for "dilatar", posponha "aumentar" to o other string; exit.
Se o string for "estender", posponha "aumentar" to o other string; exit.
Se o string for "prolongar", posponha "aumentar" to o other string; exit.
Se o string for "ampliar", posponha "aumentar" to o other string; exit.
Se o string for "achar", posponha "encontrar" to o other string; exit.
Se o string for "descobrir", posponha "encontrar" to o other string; exit.
Se o string for "buscar", posponha "encontrar" to o other string; exit.
Se o string for "manusear", posponha "manejar" to o other string; exit.
Se o string for "manipular", posponha "manejar" to o other string; exit.
Se o string for "enumerar", posponha "listar" to o other string; exit.
Se o string for "elencar", posponha "listar" to o other string; exit.
Se o string for "selecionar", posponha "escolher" to o other string; exit.
Se o string for "eliminar", posponha "remover" to o other string; exit.
Se o string for "excluir", posponha "remover" to o other string; exit.
Se o string for "retirar", posponha "remover" to o other string; exit.
Se o string for "rodar", posponha "girar" to o other string; exit.
Se o string for "começar", posponha "iniciar" to o other string; exit.
Se o string for "permutar", posponha "trocar" to o other string; exit.
Se o string for "esperar", posponha "aguardar" to o other string; exit.
Se o string for "rascunhar", posponha "esboçar" to o other string; exit.
Se o string for "antepor", posponha "prepor" to o other string; exit.
Posponha o string to o other string.

Etapas necessárias para que se attach address loading code to um texto hexadecimal usando uma variable:
\ loads into edx
Se o variable for inexistente, attach $C7C200000000 to o texto hexadecimal; exit. \ mov edx,0
Se a categoria desta variable for "global", attach $C7C2 e o address desta variable to o texto hexadecimal; exit. \ mov edx,the variable's address
Se a categoria desta variable for "literal", attach $C7C2 e o address desta variable to o texto hexadecimal; exit. \ mov edx,the variable's address
Se a categoria desta variable for "local", attach $8D95 e o offset desta variable to o texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Se a categoria desta variable for "scratch", attach $8B95 e o offset desta variable to o texto hexadecimal; exit. \ mov edx,[ebp+the variable's offset]
Se a categoria desta variable não for "parameter", abort with "Erro interno - attach address loading code to um texto hexadecimal usando uma variable"; exit.
Se o by-value alarme desta variable estiver ativo, attach $8D95 e o offset desta variable to o texto hexadecimal; exit. \ lea edx,[ebp+the variable's offset]
Attach $8B95 e o offset desta variable to o texto hexadecimal. \ mov edx,[ebp+the variable's offset]

Etapas necessárias para que se attach um texto hexadecimal e um address to um fragment:
\ call ou jump
Coloque o address into um número.
Subtraia o address deste fragment from o número.
Subtraia o length deste code deste fragment from o número.
Subtraia o length deste texto hexadecimal from o número.
Subtraia 4 from o número.
Attach o texto hexadecimal e o número to o code deste fragment.

Etapas necessárias para que se attach um texto hexadecimal e um número e another texto hexadecimal to um third texto hexadecimal:
Posponha o texto hexadecimal to o third texto hexadecimal.
Convert o número to um fourth texto hexadecimal.
Posponha o fourth texto hexadecimal to o third texto hexadecimal.
Posponha o other texto hexadecimal to o third texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um número e another número to another texto hexadecimal:
Posponha o texto hexadecimal to o other texto hexadecimal.
Convert o número to um third texto hexadecimal.
Posponha o third texto hexadecimal to o other texto hexadecimal.
Convert o other número to um fourth texto hexadecimal.
Posponha o fourth texto hexadecimal to o other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um alarme to another texto hexadecimal;
Etapas necessárias para que se attach um texto hexadecimal e um número to another texto hexadecimal:
Posponha o texto hexadecimal to o other texto hexadecimal.
Convert o número to um third texto hexadecimal.
Posponha o third texto hexadecimal to o other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal to another texto hexadecimal: 
Employ posponha um string to another string.

Etapas necessárias para que se blurt pedaços usando um endereço de memória e um length e um trecho e um offset:
Coloque o first deste trecho mais o offset into another endereço de memória.
Copy pedaços from o endereço de memória to o other endereço de memória por o length.

Etapas necessárias para que se blurt um DOS header into um trecho:
Blurt pedaços usando o whereabouts deste DOS header e o magnitude deste DOS header e o trecho e 0.

Etapas necessárias para que se blurt alguns entries into um trecho:
Obtenha um entry from o entries.
Se o entry for inexistente, cancele.
Blurt o entry into o trecho.
Repita.

Etapas necessárias para que se blurt um entry into um trecho:
Blurt pedaços usando o whereabouts deste name address desta entry e 4 e o trecho e o thunk address desta entry.
Coloque o name address desta entry mais 2 into um address.
Blurt o name desta entry into o trecho at o address.

Etapas necessárias para que se blurt um fragment into um trecho:
Se o code deste fragment estiver em branco, cancele.
Coloque o address deste fragment menos o image base into um address.
Blurt o code deste fragment into o trecho at o address.

Etapas necessárias para que se blurt alguns fragments into um trecho:
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Blurt o fragment into o trecho.
Repita.

Etapas necessárias para que se blurt um import into um trecho:
Blurt pedaços usando o whereabouts deste import header deste import e o magnitude deste import header deste import e o trecho e o header address deste import.
Blurt o name deste import into o trecho at o name address deste import.
Blurt as entries deste import into o trecho.

Etapas necessárias para que se blurt alguns imports into um trecho:
Obtenha um import from o imports.
Se o import for inexistente, cancele.
Blurt o import into o trecho.
Repita.

Etapas necessárias para que se blurt um PE header into um trecho:
Blurt pedaços usando o whereabouts deste PE header e o magnitude deste PE header e o trecho e 256.

Etapas necessárias para que se blurt uma routine into um trecho:
Se o compiled alarme desta routine não estiver ativo, cancele.
Blurt os fragments desta routine into o trecho.

Etapas necessárias para que se blurt alguns routines into um trecho:
Obtenha uma routine from o routines.
Se a routine for inexistente, cancele.
Blurt o routine into o trecho.
Repita.

Etapas necessárias para que se blurt um string into um trecho at um address:
Blurt pedaços usando o first deste string e o length deste string e o trecho e o address.

Etapas necessárias para que se blurt uma variable into um trecho:
Se o compiled alarme desta variable não estiver ativo, cancele.
Se o type desta variable puder ser reduzido para "string", blurt o variable into o trecho (as um string); exit.
Coloque o address desta variable menos o image base into um address. \ Coloque a diferença entre o endreço da variável e a base da imagem em um endereço.
Blurt o data desta variable into o trecho at o address.

Etapas necessárias para que se blurt uma variable into um trecho (as um string):
Coloque o address desta variable menos o image base into um address.
Coloque o length deste data desta variable into um length.
Coloque o address into another address.
Adicione uma prototype string's magnitude to o other address. 
Adicione o image base to o other address.
Coloque 0 into o first deste prototype string.
Coloque -1 into o last deste prototype string.
Se o length não for 0, coloque o other address into o first deste prototype string.
Se o length não for 0, coloque o first deste prototype string mais o length menos 1 into o last deste prototype string.
Blurt pedaços usando o whereabouts deste prototype string e a magnitude deste prototype string e o trecho e o address.
Adicione a magnitude deste prototype string to o address.
Blurt os data desta variable into o trecho at o address.

Etapas necessárias para que se blurt alguns variables into um trecho:
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Blurt o variable into o trecho.
Repita.

An zona é um conjunto with um base address, um length e um size.

The break tag é uma tag igual a 1.

Etapas necessárias para que se bubble um monikette:
Se o monikette for inexistente, cancele.
Se o subtexto atual deste monikette não estiver em branco, limpe o subtexto atual deste monikette; exit.
Se o type atual deste monikette for inexistente, cancele.
Se o type atual deste monikette for any built-in type, coloque nil into o type atual deste monikette; exit.
Coloque o base type deste type atual deste monikette into o type atual deste monikette.

An built-in type é um type.

Etapas necessárias para que se calculate o length of um type:
Se o type for inexistente, cancele.
Se o length deste type não for -1, cancele.
Calculate o length of o base type deste type.
Se os fields deste type estiverem vazio, coloque o length deste base type deste type into o length deste type; exit.
Coloque 0 into o length deste type.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from o fields deste type.
Se o field for inexistente, cancele.
Se o redefinition target name deste field não estiver em branco, repita.
Calculate o length of o type deste field.
Adicione o length deste type deste field times a contagem deste field to o length deste type.
Repita.

Etapas necessárias para que se calculate o lengths of alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o length of o type.
Repita.

Etapas necessárias para que se calculate o offsets in um type:
Se o type for inexistente, cancele.
Coloque 0 into um offset.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from os fields deste type.
Se o field for inexistente, cancele.
Se o redefinition target name deste field não estiver em branco, repita.
Coloque o offset into o offset deste field.
Adicione o length deste type deste field times o contagem deste field to o offset.
Repita.

Etapas necessárias para que se calculate o offsets in alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o offsets in o type.
Repita.

Etapas necessárias para que se calculate o redefinition offsets in um type:
Se o type for inexistente, cancele.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from os fields deste type.
Se o field for inexistente, cancele.
Se o redefinition target name deste field estiver em branco, repita.
Encontre another field usando o redefinition target name deste field e os fields deste type.
Se o other field for inexistente, abort with "Redefine inválido. Eu não consigo encontrar o campo '" then o redefinition target name deste field then "' field." e o locus deste field; exit.
Coloque o other field's offset into o offset deste field.
Repita.

Etapas necessárias para que se calculate o redefinition offsets in alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o redefinition offsets in o type.
Repita.

The calculating cronômetro é um cronômetro.

The call external tag é uma tag igual a 2.

The call indirect tag é uma tag igual a 3.

The call internal tag é uma tag igual a 4.

Etapas necessárias para que se check por invalid optional info on um type:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o target name deste type não estiver em branco, check por invalid optional info on o type (target).
Se o fields deste type não estiverem vazio, check por invalid optional info on o type (fields).
Se o scale deste type não for 0, check por invalid optional info on o type (scale).

Etapas necessárias para que se check por invalid optional info on um type (fields):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "conjunto", abort with "A palavra 'with' só é permitida em conjunto types." e o locus deste type; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info on um type (scale):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "número", abort with "Escalas são permitidas apenas em tipos numéricos." e o locus deste type; exit.

Etapas necessárias para que se check por invalid optional info on um type (target):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", abort with "An palavra 'to' só é permitida em endereço de memória types." e o locus deste type; exit.

Etapas necessárias para que se limpe um field term:
Fill pedaços with o null pedaço starting at o whereabouts deste field term por o magnitude deste field term.

Etapas necessárias para que se limpe um term:
Esvazie o variable deste term.
Limpe o phrase deste term.

The code zona é um zona.

Etapas necessárias para que se compile o bodies of o routines:
Compile o body of o routine called "initialize before run".
Compile o body of o routine called "nosso programa seja executado".
Compile o body of o routine called "finalize after run".

Etapas necessárias para que se compile o body of uma routine:
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o compiled alarme desta routine estiver ativo, cancele.
Ligue o compiled alarme desta routine.
Lance um percorredor on o instruções desta routine.
Mova o percorredor (compilador rules).
Se o token deste percorredor for o ponto&vírgula, compile o body of o routine usando o percorredor (alternate palavraing); exit. \ *** alternate palavraing
Se o token deste percorredor for any employ, compile o body of o routine usando o percorredor (employ); exit.
Coloque a rotina utilizada atualmente into um saved routine.
Coloque a routine into a rotina utilizada atualmente.
Crie o nickname index desta routine usando 101.
Eliminate duplicate nicknames from os parameters desta routine usando o nickname index desta routine.
Compile o body of o routine (prolog).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, pare.
Compile o next statement usando o percorredor.
Repita.
Compile o body of o routine (epilog).
Coloque o saved routine into a rotina utilizada atualmente.

Etapas necessárias para que se compile o body of uma routine (epilog):
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o finalize tag.
Percorra.
Obtenha uma variable from os locals desta routine.
Se o variable for inexistente, pare.
Se o categoria desta variable for "scratch", repita.
Se o type desta variable não deveria ser finalizado, repita.
Adicione another fragment usando o push address tag e o variable.
Encontre another routine usando "~finalize" e o type desta variable.
Se o other routine for inexistente, abort with "Erro interno - compile o body of uma routine (epilog)"; exit.
Adicione um third fragment usando o call internal tag e o other routine.
Repita.
Adicione um fourth fragment usando o epilog tag.

Etapas necessárias para que se compile o body of uma routine (prolog):
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o prolog tag.
Adicione another fragment usando o loop tag.

Etapas necessárias para que se compile o body of o routine called um string:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Encontre uma routine usando o string e o catálogo geral de rotinas.
Se a routine for inexistente, abort with "Eu preciso de uma função para fazer '" then o string then "'."; exit.
Compile o body of o routine.

Etapas necessárias para que se compile o body of uma routine usando um percorredor (alternate palavraing):
\ *** alternate palavraing
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules). \ *** do we need this?
Coloque o next desta routine into um target routine.
Se o target routine for inexistente, abort with "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e o percorredor; exit.
Coloque o moniker desta target routine into o employs moniker desta routine.
Compile o body of o target routine.

Etapas necessárias para que se compile o body of uma routine usando um percorredor (employ):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile uma routine reference usando o percorredor.
Convert o routine reference to o employs moniker desta routine.
Destroy o routine reference.
Se o token deste percorredor não for ".", abort with "Employ statments devem terminar com um ponto, não com '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não estiver em branco, abort with "Somente um employ" e o percorredor; exit.
Encontre another routine usando o employs moniker desta routine e o catálogo geral de rotinas.
Se o other routine for inexistente, abort with "Não consigo encontrar um rotina '" then o employs moniker desta routine then "' que você está tentando empregar." e o locus desta routine; exit.
Compile o body of o other routine.

Etapas necessárias para que se compile o call'd part usando um percorredor e uma variable:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Coloque o name desta variable into o type name desta variable.
Mova o percorredor (compilador rules).
Examine o name desta variable usando o percorredor.

Etapas necessárias para que se compile um endereço dâ pasta:
Compile o endereço dâ pasta (start).
Compile o endereço dâ pasta (load o source files).
Compile o endereço dâ pasta (examine o source files).
Compile o endereço dâ pasta (resolva o types).
Compile o endereço dâ pasta (resolva o globals).
Compile o endereço dâ pasta (compile o headers of o routines).
Compile o endereço dâ pasta (calculate lengths e offsets of types).
Compile o endereço dâ pasta (Adicione o built-in memory routines).
Compile o endereço dâ pasta (catalogue o routines por utility use).
Compile o endereço dâ pasta (compile o bodies of o routines).
Compile o endereço dâ pasta (Adicione e compile o built-in startup routine).
Compile o endereço dâ pasta (offset parameters e variables).
Compile o endereço dâ pasta (address).
Compile o endereço dâ pasta (transmogrify).
Compile o endereço dâ pasta (link).
Compile o endereço dâ pasta (write o exe).
Compile o endereço dâ pasta (stop).

Etapas necessárias para que se compile um endereço dâ pasta (Adicione e compile o built-in startup routine):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando e agrupando um tarefa de inicialização padrão...".
Start o adding built-in startup routine cronômetro.
Adicione e compile o initialize before run e run e finalize after run routine.
Suspenda o adding built-in startup routine cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (Adicione o built-in memory routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando como tarefas predefinidas na memória...".
Start o adding built-in memory routines cronômetro.
Adicione o allocate e deallocate e finalize e destroy routines.
Suspenda o adding built-in memory routines cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (address):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Obtendo endereço dos itens...".
Start o addressing cronômetro.
Coloque 4096 into um address.
Coloque o address into a base desta import zona.
Address o imports usando o address.
Coloque o address menos a base desta import zona into o length desta import zona.
Round o address up to o nearest multiple of 4096.
Coloque o address into a base desta zona de dados.
Address o globals usando o address.
Address o literals usando o address.
Coloque o address menos a base desta zona de dados into o length desta zona de dados.
Round o address up to o nearest multiple of 4096.
Coloque o address into a base desta code zona.
Address o routines usando o address.
Coloque o address menos a base desta code zona into o length desta code zona.
Suspenda o addressing cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (calculate lengths e offsets of types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Calculando tamanhos e deslocamentos...".
Start o calculating cronômetro.
Calculate o lengths of o types.
Calculate o offsets in o types.
Calculate o redefinition offsets in o types.
Suspenda o calculating cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (compile o bodies of o routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando o conteúdo das tarefas...".
Start o compiling routine bodies cronômetro.
Compile o bodies of o routines.
Suspenda o compiling routine bodies cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (compile o headers of o routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando os nomes das tarefas...".
Start o compiling routine headers cronômetro.
Compile o headers of o routines.
Suspenda o compiling routine headers cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (catalogue o routines por utility use):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Catalogando tarefas...".
Start o indexing utilities cronômetro.
Catalogue o routines por utility use.
Scrub o catálogo de rotinas úteis.
Catalogue novamente o catálogo de rotinas úteis.
Suspenda o indexing utilities cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (link):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Elencando arquivos..".
Start o linking cronômetro.
Link.
Suspenda o linking cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (offset parameters e variables):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Deslocando parâmetros e variáveis...".
Start o offsetting cronômetro.
Offset o parameters in o routines.
Offset o locals in o routines.
Suspenda o offsetting cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (load o source files):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Carregando arquivos...".
Start o loading cronômetro.
Load o source files.
Suspenda o loading cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (resolva o globals):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo itens de escopo abrangente...".
Start o resolving globals cronômetro.
Resolva o globals.
Suspenda o resolving globals cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (resolva o types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo tipos...".
Start o resolving types cronômetro.
Resolva o types (expand coisas).
Resolva o types (registro de plurais).
Resolva o types (base types).
Resolva o types (optional info).
Suspenda o resolving types cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (examine o source files):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Analisando arquivos...".
Start o scanning cronômetro.
Examine o source files.
Suspenda o scanning cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (start):
Mostre painel de informações "Iniciando...".
Finalize o compilador.
Start o compilador's cronômetro.
Initialize o compilador usando o endereço dâ pasta.
Adicione o built-in types.

Etapas necessárias para que se compile um endereço dâ pasta (stop):
Suspenda o compilador's cronômetro.
Mostre painel de informações "Interrompendo".

Etapas necessárias para que se compile um endereço dâ pasta (transmogrify):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Modificando...".
Start o transmogrifying cronômetro.
Transmogrify o routines.
Suspenda o transmogrifying cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (write o exe):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Gerando arquivo executável...".
Start o writing cronômetro.
Escreva o compilador's exe to o compilador's exe endereço completo.
Se o i/o erro não estiver em branco, abort with o i/o erro.
Suspenda o writing cronômetro.

Etapas necessárias para que se compile um expression usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile um term usando o percorredor.
Coloque o term into o expression.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any operator, cancele.
Se o token deste percorredor for any divided, compile o expression usando o percorredor (divided); repita.
Se o token deste percorredor for any minus, compile o expression usando o percorredor (menos); repita.
Se o token deste percorredor for any plus, compile o expression usando o percorredor (mais); repita.
Se o token deste percorredor for any then, compile o expression usando o percorredor (then); repita.
Se o token deste percorredor for any times, compile o expression usando o percorredor (times); repita.

Etapas necessárias para que se compile um expression usando um percorredor (divided):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any by, abort with "Você deve usar o termo 'divided BY'." e o percorredor; exit.
Se o expression's variable for inexistente, abort with "Termo 'divided by' inválido, há um erro na variável: '" then o expression's phrase then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "O seu 'divided by',está errado. Não dá pra dividir por '" then o term's phrase then "'." e o percorredor; exit.
Adicione um intermediate usando o expression's type name e o percorredor's token's first.
Adicione several fragments usando "coloque" e o expression's variable e "into" e o intermediate e o percorredor's token's first.
Adicione several fragments usando "divida" e o intermediate e "por" e o term's variable e o percorredor's token's first.
Coloque o intermediate into o expression's variable.
Limpe o expression's phrase.

Etapas necessárias para que se compile um expression usando um percorredor (menos):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o expression's variable for inexistente, abort with "O seu 'minus', está errado. Não consigo subtrair o(a) '" then o expression's phrase then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "O seu 'minus', está errado. Não consigo diminuir do(a) '" then o term's phrase then "'." e o percorredor; exit.
Adicione um intermediate usando o expression's type name e o percorredor's token's first.
Adicione several fragments usando "coloque" e o expression's variable e "into" e o intermediate e o percorredor's token's first.
Adicione several fragments usando "subtraia" e o term's variable e "from" e o intermediate e o percorredor's token's first.
Coloque o intermediate into o expression's variable.
Limpe o expression's phrase.

Etapas necessárias para que se compile um expression usando um percorredor (mais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o expression's variable for inexistente, abort with "O seu 'plus', está errado. Não consigo somar o '" then o expression's phrase then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "O seu 'plus', está errado. Não consigo somar um '" then o term's phrase then "'." e o percorredor; exit.
Adicione um intermediate usando o expression's type name e o percorredor's token's first.
Adicione several fragments usando "coloque" e o expression's variable e "into" e o intermediate e o percorredor's token's first. \aqui muda o coloque
Adicione several fragments usando "adicione" e o term's variable e "to" e o intermediate e o percorredor's token's first. \ aqui muda o add
Coloque o intermediate into o expression's variable.
Limpe o expression's phrase.

Etapas necessárias para que se compile um expression usando um percorredor (then):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o expression's variable for inexistente, abort with "O seu 'then', está errado. Eu não entendi o que é o(a) '" then o expression's phrase then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "O seu 'then', está errado. Eu não sei o que é o(a) '" then o term's phrase then "'." e o percorredor; exit.
Adicione um intermediate usando "string" e o percorredor's token's first.
Adicione o coloque ou convert fragments usando o expression's variable e o intermediate e o percorredor's token's first.
Convert o term por concatenation usando o percorredor.
Adicione several fragments usando "posponha" e o term's variable e "to" e o intermediate e o percorredor's token's first.
Coloque o intermediate into o expression's variable.
Limpe o expression's phrase.

Etapas necessárias para que se compile um expression usando um percorredor (times):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o expression's variable for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar o '" then o expression's phrase then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar um '" then o term's phrase then "'." e o percorredor; exit.
Adicione um intermediate usando o expression's type name e o percorredor's token's first.
Adicione several fragments usando "coloque" e o expression's variable e "into" e o intermediate e o percorredor's token's first.
Adicione several fragments usando "multiplique" e o intermediate e "por" e o term's variable e o percorredor's token's first.
Coloque o intermediate into o expression's variable.
Limpe o expression's phrase.

Etapas necessárias para que se compile o header of uma routine:
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor on o routine's routine header.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any decide, compile o header of o routine usando o percorredor (decider); exit.
Se o percorredor for o start of any reverse-possessive function, compile o header of o routine usando o percorredor (reverse-possessive function); exit.
Se o percorredor for o start of any function, compile o header of o routine usando o percorredor (function); exit.
Se o token deste percorredor for "compativelmente", compile o header of o routine usando o percorredor (callback); exit.
Compile o header of o routine usando o percorredor (procedure).

Etapas necessárias para que se compile o header of uma routine usando um percorredor (callback):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Ligue o routine's callback alarme.
Compile o routine's monikettes e o routine's parameters usando o percorredor.
Convert o routine's monikettes to o routine's moniker.
Se o routine's moniker estiver in o catálogo geral de rotinas, abort with "Você já tinha escrito um função '" then o routine's moniker then "'." e o routine's locus; exit.
Catalogue o routine usando o routine's monikettes e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma routine usando um percorredor (decider):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any conditional, abort with "Erro na sintaxe do comando 'Para que se determine se'" e o percorredor; exit.
Mova o percorredor (compilador rules).
Ligue o routine's decider alarme.
Compile o routine's monikettes e o routine's parameters usando o percorredor.
Se any of o routine's monikettes forem negative palavras, abort with "Não consigo me dar bem com palavras negativas em nomes de funções decisoras." e o percorredor; exit.
Convert o routine's monikettes to o routine's moniker.
Se o routine's moniker estiver in o catálogo geral de rotinas, abort with "Você já me contou como'" then o routine's moniker then "'." e o routine's locus; exit.
Catalogue o routine usando o routine's monikettes e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma routine usando um percorredor (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o routine's function alarme.
Adicione um monikette to o routine's monikettes usando "coloque".
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile o routine's monikettes e o routine's parameters usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile o routine's monikettes e o routine's parameters usando o percorredor (artigo definido).
Se o token deste percorredor não for any possessive, abort with "Tá faltando um 's por aqui (ou está no lugar errado)." e o percorredor; exit. \ not translated - no possessives in Spanish
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Adicione another monikette to o routine's monikettes usando "'s " then o name.
Se o token deste percorredor não for "into", abort with "Eu estava esperando um palavra 'into', mas encontrei um palavra '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to o routine's monikettes usando "into".
Convert o routine's monikettes to um moniker.
Se o moniker estiver in o catálogo geral de rotinas, abort with "Eu já sei como '" then o moniker then "'." e o routine's locus; exit. \ not translated - no possessives in Spanish
Catalogue o routine usando o routine's monikettes e o catálogo geral de rotinas.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "Estava esperando um artigo indefinido, mas achei isso aqui: '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Compile o routine's monikettes e o routine's parameters usando o percorredor (artigo indefinido).
Se o token deste percorredor não estiver em branco, abort with "Tem comandos extras no fim dessa função." e o percorredor; exit. \ not translated - no possessives in Spanish
Convert o routine's monikettes to o routine's moniker.
Catalogue o routine usando o routine's monikettes e o catálogo geral de rotinas. \ por employs

Etapas necessárias para que se compile o header of uma routine usando um percorredor (procedure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile o routine's monikettes e o routine's parameters usando o percorredor.
Convert o routine's monikettes to o routine's moniker.
Se o routine's moniker estiver in o catálogo geral de rotinas, abort with "Você já escreveu como fazer '" then o routine's moniker then "'." e o routine's locus; exit.
Catalogue o routine usando o routine's monikettes e o catálogo geral de rotinas.

Etapas necessárias para que se compile o headers of alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from o routines.
Se a routine for inexistente, cancele.
Compile o header of o routine.
Repita.

Etapas necessárias para que se compile um literal usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione o literal to o literals usando o percorredor's token's first.
\Se o token deste percorredor for any alarme literal, compile o literal usando o percorredor (alarme); exit.
Se o token deste percorredor for any hex literal, compile o literal usando o percorredor (hex); exit.
Se o token deste percorredor for any numeric literal, compile o literal usando o percorredor (numeric); exit.
Se o token deste percorredor for any endereço de memória literal, compile o literal usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for any string literal, compile o literal usando o percorredor (string); exit.
Abort with "Erro interno - compile um term usando um percorredor (literal)" e o percorredor.

Etapas necessárias para que se compile um literal usando um percorredor (alarme):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um alarme.
Convert o alarme to o literal's data.
Mova o percorredor (compilador rules).
Coloque "alarme" into o literal's type name.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (hex):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o token deste percorredor into um parte dâ cifra binária.
Adicione 1 to o parte dâ cifra binária's first.
Convert o parte dâ cifra binária to o literal's data.
Mova o percorredor (compilador rules).
Coloque "texto hexadecimal" into o literal's type name.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - integer):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um número.
Convert o número to o literal's data.
Mova o percorredor (compilador rules).
Coloque "número" into o literal's type name.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - ratio):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um ratio.
Convert o ratio to o literal's data.
Mova o percorredor (compilador rules).
Coloque "ratio" into o literal's type name.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - with unit of measure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um ratio.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Encontre um type usando o name e o catálogo de tipos.
Se o type for inexistente, abort with "'" then o name then "' é uma unidade de medida inexistente." e o literal's locus; exit.
Se o type não puder ser reduzido para "número", abort with "'" then o name then "' é uma unidade de medida inválida." e o literal's locus; exit.
Coloque o type's scale into um final ratio.
Se o type's scale for 0, coloque 1/1 into o final ratio.
Multiplique o final ratio por o ratio.
Reduce o final ratio.
Se o final ratio's denominador for 0, abort with "Parece que essa é uma unidade de medida inválida." e o literal's locus.
Coloque o final ratio's numerador dividido por o final ratio's denominador into um número.
Coloque o name deste type into o literal's type name.
Convert o número to o literal's data.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor estiver followed por any unit of measure, compile o literal usando o percorredor (numeric - with unit of measure); exit.
Se o token deste percorredor for any integer literal, compile o literal usando o percorredor (numeric - integer); exit.
Se o token deste percorredor for any ratio literal, compile o literal usando o percorredor (numeric - ratio); exit.
Se o token deste percorredor for any mixed literal, compile o literal usando o percorredor (numeric - ratio); exit.

Etapas necessárias para que se compile um literal usando um percorredor (endereço de memória):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert 0 to o literal's data. \ was nil
Mova o percorredor (compilador rules).
Coloque "endereço de memória" into o literal's type name.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o token deste percorredor into o literal's data.
Unquote o literal's data.
Mova o percorredor (compilador rules).
Coloque "string" into o literal's type name.
Resolva o literal.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for any artigo definido, compile o monikettes e o parameters usando o percorredor (artigo definido); repita.
Se o percorredor estiver on any artigo indefinido, compile o monikettes e o parameters usando o percorredor (artigo indefinido); repita.
Se o percorredor estiver on any monikette string, compile o monikettes e o parameters usando o percorredor (monikette string); repita.
Abort with "'" then o token deste percorredor then "' não é um nome de função que eu conheça." e o percorredor.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (artigo definido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Anteponha "the " to o name.
Adicione um monikette to o monikettes usando o name.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (artigo indefinido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um parameter to o parameters usando "parameter" e o percorredor's token's first.
\PAL
Se o token deste percorredor for "outra", coloque "segunda" into o parameter's name.
Se o token deste percorredor for "outro", coloque "segundo" into o parameter's name.
\CAL
Se o token deste percorredor for "another", coloque "other" into o parameter's name.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o parameter's name with o name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o parameter.
Resolva o parameter.
Se o parameter estiver duplicated in o parameters, abort with "Cara, você repetiu o parâmetro '" then o parameter's name then "'." e o parameter's locus; exit.
Adicione um monikette to o monikettes usando o parameter's type.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (monikette string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette to o monikettes usando o percorredor's token.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile alguns monikettes usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor está on any monikette string, adicione um monikette to o monikettes usando o percorredor's token; mova o percorredor (compilador rules); repita.
Se o token deste percorredor não for o start of any expression, cancele.
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione another monikette to o monikettes usando o expression.
Repita.

\Etapas necessárias para que se compile alguns monikettes usando um percorredor:
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Se o token deste percorredor for any monikette string, adicione um monikette to o monikettes usando o percorredor's token; mova o percorredor (compilador rules); repita.
\Se o token deste percorredor não for o start of any expression, cancele.
\Compile um expression usando o percorredor.
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Adicione another monikette to o monikettes usando o expression.
\Repita.

Etapas necessárias para que se compile o next statement usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any conditional, compile o next statement usando o percorredor (if); exit.
Se o token deste percorredor for any loop, compile o next statement usando o percorredor (loop); exit.
Se o token deste percorredor for any privatize, compile o next statement usando o percorredor (privatize); exit.
Se o token deste percorredor não for o start of any statement, abort with "Eu esperava uma declaração aqui, mas encontrei: '" then o token deste percorredor then "'." e o percorredor; exit.
Compile o next statement usando o percorredor (other).
Se o token deste percorredor não for o ponto final, abort with "Acho que tá faltando um pontinho por aqui." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (break):
Adicione um fragment usando o break tag.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (call - external):
Coloque o token deste percorredor into um string.
Unquote o string.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any string literal, abort with "Cara, você precisa colocar os nomes entre aspas, mas você colocou '" then o token deste percorredor then "'." e o percorredor; exit.
Coloque o token deste percorredor into another string.
Unquote o other string.
Mova o percorredor (compilador rules).
Adicione um entry to o imports usando o string e o other string.
Se o token deste percorredor for "with", compile o next statement usando o percorredor (call - with clause).
Se o token deste percorredor for "returning", compile o next statement usando o percorredor returning um term (call - returning part).
Adicione um fragment usando o call external tag e o entry.
Se o term estiver vazio, cancele.
Se o term's variable for inexistente, abort with "Não entendi bem o que é '" then o term's phrase then "'." e o percorredor; exit.
Adicione another fragment usando o save eax tag e o term's variable.

Etapas necessárias para que se compile o next statement usando um percorredor (call - indirect):
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o expression's variable for inexistente, abort with "Eu não sei o que é '" then o expression's phrase then "'." e o percorredor; exit.
Se o expression's type não puder ser reduzido para "endereço de memória", abort with "Eu preciso de um endereço de memória type nesse CALL statement." e o percorredor; exit.
Se o token deste percorredor for "with", compile o next statement usando o percorredor (call - with clause).
Se o token deste percorredor for "returning", compile o next statement usando o percorredor returning um term (call - returning part).
Adicione um fragment usando o call indirect tag e o expression's variable.
Se o term estiver vazio, cancele.
Se o term's variable for inexistente, abort with "Acho que essa varíavel é inválida: '" then o term's phrase then "'." e o percorredor; exit.
Adicione another fragment usando o save eax tag e o term's variable.

Etapas necessárias para que se compile o next statement usando um percorredor (call - internal):
Compile alguns monikettes usando o percorredor.
Encontre uma routine usando o monikettes.
Se o routine não for inexistente, adicione push fragments usando o monikettes.
Se o routine não for inexistente, destroy o monikettes; adicione um fragment usando o call internal tag e o routine; exit.
Convert o monikettes to um moniker.
Destroy o monikettes.
\Coloque "Eu ainda não aprendi como" into a reply.
\Say o reply.
Coloque o moniker into a reply.
\Say o reply.
Abort with "Eu ainda não aprendi como '" then o moniker then "'." e o percorredor.

Etapas necessárias para que se compile o next statement usando um percorredor (call - with clause):
\ this guy é recursise so parameters obtenha passed right to left
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o expression's variable for inexistente, abort with "Eu não entendo um variável: '" then o expression's phrase then "'." e o percorredor; exit.
Se o expression's type não for value pushable, abort with "'" then o expression's type's name then "' não pode ser processado corretamente." e o percorredor; exit.
Se o token deste percorredor for any and, compile o next statement usando o percorredor (call - with clause).
Adicione um fragment usando o push value tag e o expression's variable.

Etapas necessárias para que se compile o next statement usando um percorredor (call):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any string literal, compile o next statement usando o percorredor (call - external); exit.
Compile o next statement usando o percorredor (call - indirect). 

Etapas necessárias para que se compile o next statement usando um percorredor (exit):
Se o rotina utilizada atualmente's decider alarme estiver ativo, abort with "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" e o percorredor; exit.
Adicione um fragment usando o exit tag.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (if):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile alguns monikettes usando o percorredor.
Remove any negatives from o monikettes returning um alarme.
Encontre uma routine usando o monikettes.
Se o routine não for inexistente, adicione push fragments usando o monikettes.
Se a routine for inexistente, convert o monikettes to um moniker.
Destroy o monikettes.
Se a routine for inexistente, abort with "Preciso de um decider que tenha como palavras: '" then o moniker then "'." e o percorredor; exit.
Se o routine's decider alarme não estiver ativo, abort with "Cara eu vou precisar de um decider aqui, blz?" e o percorredor; exit.
Se o token deste percorredor não for o vírgula, abort with "Acho que você esqueceu de uma vírgula, eu achei isso aqui: '" then o token deste percorredor then "'." e o percorredor; exit.
Adicione um fragment usando o call internal tag e o routine.
Se o alarme estiver ativo, adicione another fragment usando o not tag.
Adicione um third fragment usando o jump false tag.
Mova o percorredor (compilador rules).
Percorra.
Compile o next statement usando o percorredor (other).
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for o ponto&vírgula, mova o percorredor (compilador rules); repita.
Se o token deste percorredor não for o ponto final, abort with "Você precisa usar um ponto ao invés de usar o termo '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Adicione um fourth fragment usando o end if tag.

Etapas necessárias para que se compile o next statement usando um percorredor (intel):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any hex literal, abort with "Eu preciso de um pouco de machine code, mas o que eu achei foi '" then o token deste percorredor then "'." e o percorredor; exit.
Adicione um fragment usando o intel tag.
Coloque o token deste percorredor into um parte dâ cifra binária.
Adicione 1 to o parte dâ cifra binária's first.
Convert o parte dâ cifra binária to o fragment's code.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (loop):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o loop tag.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o ponto final, abort with "Parece que alguém esqueceu de colocar um ponto por aí." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (other):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for any exit, compile o next statement usando o percorredor (exit); exit.
Se o token deste percorredor for any repeat, compile o next statement usando o percorredor (repeat); exit.
Se o token deste percorredor for any break, compile o next statement usando o percorredor (break); exit.
Se o token deste percorredor for any say, compile o next statement usando o percorredor (say); exit.
Se o token deste percorredor for "intel", compile o next statement usando o percorredor (intel); exit.
Se o token deste percorredor for "push", compile o next statement usando o percorredor (push); exit.
Se o token deste percorredor for any call, compile o next statement usando o percorredor (call); exit.
Se o token deste percorredor for any point, compile o next statement usando o percorredor (point); exit.
Se o token deste percorredor for any conditional, abort with "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." e o percorredor; exit.
Se o token deste percorredor for any privatize, abort with "A sentença 'privatizar' não pode ser usada aqui." e o percorredor; exit.
Se o token deste percorredor for any loop, abort with "Usar um percorra deentro de um SE for uma ótima forma de arranjar problemas." e o percorredor; exit.
Se o token deste percorredor for any employ, abort with "'Empregue' deve ser o único imperativo em uma rotina." e o percorredor; exit.
Compile o next statement usando o percorredor (call - internal).

Etapas necessárias para que se compile o next statement usando um percorredor (point):
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Acho que o termo '" then o term's phrase then "' está vazio." e o percorredor; exit.
Se o term's categoria for "literal", abort with "Você usou o tipo errado de variável aqui (literal)." e o percorredor.
Se o term's type's length não for 4, abort with "Você usou uma variável de comprimento errado (<>4)." e o percorredor.
Se o token deste percorredor não for "to", abort with "Acho que faltou um 'to', mas você usou '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for "routine", abort with "Acho que faltou a palavra 'routine'. Você usou o termo '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile uma routine reference usando o percorredor.
Convert o routine reference to um moniker.
Destroy o routine reference.
Encontre uma routine usando o moniker e o catálogo geral de rotinas.
Se a routine for inexistente, abort with "Não achei a tarefa '" then o moniker then "' que você falou." e o percorredor; exit.
Adicione um fragment usando o routine address tag e o routine.
Coloque o term's variable into o fragment's variable.

Etapas necessárias para que se compile o next statement usando um percorredor (privatize):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Comando 'privatize', Inválido. Eu acho que o termo da variável '" then o term's phrase then "' está vazio." e o percorredor; exit.
Se o term's categoria não for "parameter", abort with "Você só pode privatizar parâmetros." e o percorredor; exit.
Adicione um local to o rotina utilizada atualmente's locals usando "local" e o percorredor's token's first.
Coloque o term's name into o local's name.
Coloque o term's nickname into o local's nickname.
Coloque o term's type name into o local's type name.
Resolva o local.
Anteponha "original " to o term's name.
Se o term's nickname não estiver em branco, Anteponha "original " to o term's nickname.
Adicione several fragments usando "coloque" e o term's variable e "into" e o local e o percorredor's token's first.
Se o token deste percorredor não for o ponto final, abort with "Você vive esquecendo dos pontos né?." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (push):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o expression's variable for inexistente, abort with "Comando 'push' inválido, um expressão '" then o expression's phrase then "' parece estar vazia." e o percorredor; exit.
Se o expression's type não for value pushable, abort with "Valores do tipo '" then o expression's type's name then "' não podem ser pushed." e o percorredor; exit.
Adicione um fragment usando o push value tag e o expression's variable.

Etapas necessárias para que se compile o next statement usando um percorredor (repeat):
Adicione um fragment usando o repeat tag.
Mova o percorredor (compilador rules).

\Etapas necessárias para que se compile o next statement usando um percorredor (say):
\Se o rotina utilizada atualmente's decider alarme não estiver ativo, compile o next statement usando o percorredor (call - internal); exit.
\Mova o percorredor (compilador rules).
\Compile um expression usando o percorredor.
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Se o expression's variable for inexistente, abort with "No es válido este 'diga', no entiendo la variable '" then o expression's phrase then "'." e o percorredor; exit.
\Se o expression's type não puder ser reduzido para "alarme", abort with "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; exit.
\Adicione um fragment usando o load eax tag e o expression's variable.
\Adicione another fragment usando o exit tag.

Etapas necessárias para que se compile o next statement usando um percorredor (say):
Se o rotina utilizada atualmente's decider alarme não estiver ativo, compile o next statement usando o percorredor (call - internal); exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any decider literal, abort with "Você precisa terminar com um yes ou no." e o percorredor; exit.
Desative um alarme. Se o token deste percorredor for any positive decider literal, acione o alarme.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o ponto final, abort with "Faltou um ponto. Você usou o termo: '" then o token deste percorredor then "'." e o percorredor; exit.
Adicione um fragment usando o load eax tag e o alarme.
Adicione another fragment usando o exit tag.

Etapas necessárias para que se compile o next statement usando um percorredor returning um term (call - returning part):
Mova o percorredor (compilador rules).
Compile o term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Eu não compreendi o termo da variável '" then o term's phrase then "'. Ela parece estar vazia." e o percorredor; exit.
Se o term's type não for value pushable, abort with "Uma varíavel de 1, 2, ou 4-pedaços é necessária na 'returning' clause." e o percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor:
Se o token deste percorredor for "to", mova o percorredor (compilador rules).
Se o percorredor for o start of any function, compile o routine reference usando o percorredor (function); exit.
Se o token deste percorredor for any decide, compile o routine reference usando o percorredor (decide).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for ".", cancele.
Se o token deste percorredor for any artigo definido, compile o routine reference usando o percorredor (artigo definido); repita.
Se o token deste percorredor for any artigo indefinido, compile o routine reference usando o percorredor (artigo indefinido); repita.
Se o percorredor está on any monikette string, compile o routine reference usando o percorredor (monikette string); repita.
Abort with "'" then o token deste percorredor then "' não é válido em um employ statement." e o percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor (decide):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any conditional, abort with "Sempre use DECIDE IF, ao invés de apenas DECIDE com '" then o token deste percorredor then "' logo em seguida." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile uma routine reference usando um percorredor (artigo definido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Anteponha "the " to o name.
Adicione um monikette to o routine reference usando o name.

Etapas necessárias para que se compile uma routine reference usando um percorredor (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette to o routine reference usando "coloque".
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile o routine reference usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile o routine reference usando o percorredor (artigo definido).
Se o token deste percorredor não for any possessive, abort with "Eu estava esperando un 's, mas apareceu '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Adicione another monikette to o routine reference usando "'s " then o name.
Se o token deste percorredor não for "into", abort with "E estava esperando um palavra 'into', mas encontrei '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to o routine reference usando "into".
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "Eu estava esperando um artigo indefinido mas encontrei isso: '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Compile o routine reference usando o percorredor (artigo indefinido).

Etapas necessárias para que se compile uma routine reference usando um percorredor (artigo indefinido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Encontre um type e um nickname usando o name.
Se o type for inexistente, abort with "Employ statement inválido, Eu não sei o que é '" then o name then "'." e o percorredor; exit.
Adicione um monikette to o routine reference usando o type.

Etapas necessárias para que se compile uma routine reference usando um percorredor (monikette string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette to o routine reference usando o percorredor's token.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile um term usando um percorredor:
Limpe o term.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile o term usando o percorredor (common part).
Se o percorredor está on any simile, cancele. \ added por invisible turtle project ***
\Se o token deste percorredor for "as", compile o term usando o percorredor (as part). \preposição
\Se o token deste percorredor for "tão", compile o term usando o percorredor (as part). \ me parece desnecessário por ser usado apenas em funções.
Se o token deste percorredor for "quão", compile o term usando o percorredor (as part).
Se o token deste percorredor for "quanto", compile o term usando o percorredor (as part).
Se o token deste percorredor for "como", compile o term usando o percorredor (as part).
\Se o token deste percorredor for "que nem", compile o term usando o percorredor (as part).
Se o token deste percorredor for "/", compile o term usando o percorredor (runtime ratio).

Etapas necessárias para que se compile um term usando um percorredor (as part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Comando 'as'inválido. Eu acho que um variável '" then o term's phrase then "' está vaiza." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "Tá faltando um artigo indefinido depois do 'como', mas você escreveu '" then o token deste percorredor then "' no lugar disso." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine um type name usando o percorredor.
Encontre um type usando o type name e o catálogo de tipos.
Se o type for inexistente, abort with "Eu não sei em qual tipo o '" then o type name then "' se encaixa." e o percorredor; exit.
Adicione um scratch usando o name deste type e o percorredor's token's first.
Adicione um fragment usando o load address tag e o term's variable e o scratch.
Coloque o scratch into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (common part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for o hífem, compile o term usando o percorredor (negated term); exit.
Se o token deste percorredor for o sinal de adição, compile o term usando o percorredor (posigated term); exit.
Se o token deste percorredor for o start of any variable, compile o term usando o percorredor (variable); exit.
Se o token deste percorredor for o start of any new local, compile o term usando o percorredor (new local); exit.
Se o token deste percorredor for any literal, compile o term usando o percorredor (literal); exit.
Abort with "Faltou um termo por aqui. Só achei isso aqui: '" then o token deste percorredor then "'." e o percorredor.

Etapas necessárias para que se compile um term usando um percorredor (dereference - in place):
Se o term's variable for inexistente, abort with "Erro interno na função - compile um term usando um percorredor (dereference - in place). Termo vazio" e o percorredor; exit.
Coloque o term's type's target type's name into o term's type name.
Coloque o term's type's target type into o term's type.
Adicione um fragment usando o dereference tag e o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (dereference):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Dereference inválido, um variável '" then o term's phrase then "' parece estar vazia." e o percorredor; exit.
Se o term's type's target type for inexistente, abort with "Não consegui identificar o tipo desse target." e o percorredor; exit.
Se o term's categoria for "scratch", compile o term usando o percorredor (dereference - in place); exit.
Adicione um scratch usando o term's type's target type's name e o percorredor's token's first.
Adicione um fragment usando o load address tag e o term's variable e o scratch.
Adicione another fragment usando o dereference tag e o scratch.
Coloque o scratch into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (literal):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile um literal usando o percorredor.
Coloque o literal into o term's variable.
Limpe o term's phrase.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor (negated term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile another term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o other term's variable for inexistente, abort with "Negate inválido, um variável '" then o other term's phrase then "' parece estar vazia." e o percorredor; exit.
Adicione um intermediate usando o other term's type name e o percorredor's token's first.
Adicione several fragments usando "coloque" e o other term's variable e "into" e o intermediate e o other term's locus.
Adicione two fragments usando "negate" e o intermediate e o percorredor's token's first.
Coloque o intermediate into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (new local):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, abort with "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e o percorredor; exit.
Adicione um local to o rotina utilizada atualmente's locals usando "local" e o percorredor's token's first.
\PAL
Se o token deste percorredor for "outra", coloque "segunda" into o local's name.
Se o token deste percorredor for "outro", coloque "segundo" into o local's name.
\CAL
Se o token deste percorredor for "another", coloque "other" into o local's name.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o local's name with o name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicated in o rotina utilizada atualmente's parameters, abort with "o parâmetro '" then o local's name then "' já está sendo usado como parâmetro." e o local's locus; exit.
Se o local estiver duplicated in o rotina utilizada atualmente's locals, abort with "Já existe uma variável local chamada'" then o local's name then "'. Você tem que dar um nome diferente." e o local's locus; exit.
Eliminate duplicate nicknames usando o local e o rotina utilizada atualmente's nickname index.
Coloque o local into o term's variable.
Limpe o term's phrase.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor (posigated term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile o term usando o percorredor.
Se o term's variable for inexistente, abort with "Posigate inválido, o termo da variável'" then o term's phrase then "' parece estar vazio." e o percorredor; exit.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (possessive - magnitude):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Use da magnitude inválido. An variável '" then o term's phrase then "' parece estar vazia." e o percorredor; exit.
Adicione um literal to o literals usando o percorredor's token's first.
Convert o term's type's length to o literal's data.
Coloque "número" into o literal's type name.
Resolva o literal.
Coloque o literal into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (possessive - target):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Você usou o target de forma errada. O termo da variável '" then o term's phrase then "' parece estar vazio." e o percorredor; exit.
Se o term's type não puder ser reduzido para "endereço de memória", abort with "Você só pode usar target com tipos endereço de memória." e o percorredor; exit.
Compile o term usando o percorredor (dereference).

Etapas necessárias para que se compile um term usando um percorredor (possessive - whereabouts):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Você usou whereabouts da forma errada, erro no termo da variável '" then o term's phrase then "'." e o percorredor; exit.
Adicione um intermediate usando "endereço de memória" e o percorredor's token's first. 
Adicione um fragment usando o load address tag e o term's variable e o intermediate.
Coloque o intermediate into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (possessive):
\ similar to "compile um term usando um percorredor (reverse-possessive)
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o name for any magnitude, compile o term usando o percorredor (possessive - magnitude); exit.
Se o name for any target, compile o term usando o percorredor (possessive - target); exit.
Se o name for any whereabouts, compile o term usando o percorredor (possessive - whereabouts); exit.
Compile o term usando o percorredor e o name (possessive - field).

Etapas necessárias para que se compile um term usando um percorredor (possessives):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any possessive, cancele.
Compile o term usando o percorredor (possessive).
Repita. 

Etapas necessárias para que se compile um term usando um percorredor (runtime ratio):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable for inexistente, abort with "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável '" then o term's phrase then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile another term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o other term's variable for inexistente, abort with "Uso inválido da /, termo vazio da variável: '" then o other term's phrase then "'." e o percorredor; exit.
Adicione um intermediate usando "ratio" e o percorredor's token's first.
Adicione several fragments usando "coloque" e o term's variable e "e" e o other term's variable e "into" e o intermediate e o percorredor's token's first.
Coloque o intermediate into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor (variable):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, abort with "Erro de tarefa vazia, nada pra pull da pilha aqui." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o percorredor está on any reverse-possessive, compile o term usando o percorredor e o name (reverse-possessive); exit.
Encontre uma variable usando o name.
Coloque o variable into o term's variable.
Coloque "the " into o term's phrase.
Posponha o name to o term's phrase.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor e um field name (reverse-possessive):
\ this é recursive \ dahn version 2
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules). \ past o reverse-possessive starter
\Se o token deste percorredor não for "del", Mova o percorredor (compilador rules). \ past o reverse-possessive starter \ gerry added "if" part
\Se o token deste percorredor for "del", adicione 1 to o percorredor's token's first. \ makes "del" look like "de el"
Se o token deste percorredor não for any article, abort with "Esperaba un artículo, pero encontré '" then o token deste percorredor then "'."; exit.
Coloque o token deste percorredor into um article token.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor. 
Se o percorredor está on any reverse-possessive, acione um reverse-possessive alarme.
Se o reverse-possessive alarme estiver ativo, compile o term usando o percorredor e o name (reverse-possessive).
Se o reverse-possessive alarme não estiver ativo, compile o term usando o percorredor e o name e o article (reverse-possessive prepare to unwind).
Compile o term usando o field name e o percorredor (reverse-possessive).

Etapas necessárias para que se compile um term usando um percorredor e uma variable name e um article token (reverse-possessive prepare to unwind):
\ dahn version 2
Se o article for o start of any variable, compile o term usando o percorredor e o variable name e o article (reverse-possessive prepare to unwind existing variable); exit.
Compile o term usando o percorredor e o variable name (reverse-possessive prepare to unwind new local).

Etapas necessárias para que se compile um term usando um percorredor e uma variable name e um article token (reverse-possessive prepare to unwind existing variable):
\ dahn version 2
Encontre uma variable usando o variable name.
Se o variable for inexistente, abort with "No se pudo encontrar una variable con el nombre '" then o variable name then "'.".
Coloque o variable into o term's variable.
Coloque "the " into o term's phrase.
Posponha o variable name to o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor e uma variable name (reverse-possessive prepare to unwind new local):
\ dahn version 2
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um local to o rotina utilizada atualmente's locals usando "local" e o percorredor's token's first.
\PAL
Se o token deste percorredor for "outra", coloque "segunda" into o local's name.
Se o token deste percorredor for "outro", coloque "segundo" into o local's name.
\CAL
Se o token deste percorredor for "another", coloque "other" into o local's name.
Extend o local's name with o variable name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicated in o rotina utilizada atualmente's parameters, abort with "O termo '" then o local's name then "' já está sendo usado como parâmetro." e o local's locus; exit.
Se o local estiver duplicated in o rotina utilizada atualmente's locals,abort with "O termo '" then o local's name then "' já está sendo usado como variável local." e o local's locus; exit.
Eliminate duplicate nicknames usando o local e o rotina utilizada atualmente's nickname index.
Coloque o local into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um field name e um percorredor (reverse-possessive):
\ similar to "compile um term usando um percorredor (possessive)" \ dahn
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o field name for any magnitude, compile o term usando o percorredor (possessive - magnitude); exit.
Se o field name for any target, compile o term usando o percorredor (possessive - target); exit.
Se o field name for any whereabouts, compile o term usando o percorredor (possessive - whereabouts); exit.
Compile o term usando o percorredor e o field name (possessive - field).

Etapas necessárias para que se compile um term usando um percorredor e um field term:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o field term's dereference alarme estiver ativo, compile o term usando o percorredor (dereference). 
Se o field term's function não for inexistente, compile o term usando o percorredor e o field term (function); exit.
Se o term's categoria for "scratch", compile o term usando o percorredor e o field term (in place); exit.
Coloque o field term's field into um field.
Adicione um scratch usando o field's type's name e o percorredor's token's first.
Adicione um fragment usando o load address tag e o term's variable e o scratch.
Se o field's offset não for 0, adicione um third fragment usando o increment tag e o scratch e o field's offset.
Coloque o scratch into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor e um field term (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o field term's function into uma routine.
Coloque o routine's parameters' last into um parameter.
Se o parameter for inexistente, abort with "Erro interno na função compile um term usando um percorredor e um field term (function) - parâmetro vazio." e o percorredor; exit.
Se o parameter's type for inexistente, abort with "Erro interno 2 na função compile um term usando um percorredor e um field term (function) - tipo do parâmetro inexistente." e o percorredor; exit.
Adicione um intermediate usando o parameter's type's name e o percorredor's token's first.
Adicione um fragment usando o push address tag e o intermediate.
Se o field term's push alarme estiver ativo, adicione another fragment usando o push address tag e o term's variable.
Adicione um third fragment usando o call internal tag e o routine.
Coloque o intermediate into o term's variable.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor e um field term (in place):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o field term's field into um field.
Coloque o field's type's name into o term's type name.
Coloque o type deste field into o term's type.
Se o field's offset não for 0, adicione um third fragment usando o increment tag e o term's variable e o field's offset.
Limpe o term's phrase.

Etapas necessárias para que se compile um term usando um percorredor e um name (possessive - field):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o term's variable não for inexistente, coloque o term's type into um type.
Encontre um field term usando o term's phrase e o type e o name.
Se o field term não for vazio, compile o term usando o percorredor e o field term; exit.
Se o term's variable for inexistente, abort with "Erro: variável vazia '" then o term's phrase then "'." e o percorredor; exit.
Se o type puder ser reduzido para "endereço de memória", coloque o target type deste type into o type.
Se o type for inexistente, abort with "Não existe o campo '" then o name then "' no tipo '" then o term's type's name then "'." e o percorredor; exit.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from o type's fields.
Se o field for inexistente, abort with "Não tem nenhum campo '" then o name then "' no tipo '" then o term's type's name then "'." e o percorredor; exit.
Encontre um deep field term usando "" e o type deste field e o name.
Se o deep field term estiver vazio, repita.
Coloque o field into um first field term's field.
Se o term's type puder ser reduzido para "endereço de memória", acione o first field term's dereference alarme.
Compile o term usando o percorredor e o first field term.
Compile o term usando o percorredor e o deep field term.

The compilador é um conjunto with
An endereço dâ pasta,
An cronômetro,
An abort alarme,
An alarme de alerta, \new line
An mensagem de erro,
An abort endereço completo,
An abort row#,
An name contagem,
An exe trecho,
An listing trecho.

The compiling routine bodies cronômetro é um cronômetro.

The compiling routine headers cronômetro é um cronômetro.

Etapas necessárias para que se convert alguns monikettes to um moniker:
Convert o monikettes to o moniker usando o monikettes' last.

Etapas necessárias para que se convert alguns monikettes to um moniker usando um monikette:
Limpe o moniker.
Percorra.
Obtenha um current monikette from o monikettes.
Se o current monikette for inexistente, cancele.
Posponha o current monikette to o moniker.
Se o current monikette for o monikette, cancele.
Repita.

Etapas necessárias para que se convert uma parte dâ cifra binária to um string:
Employ convert um texto dâ cifra binária to um texto hexadecimal.

Etapas necessárias para que se convert um term por concatenation usando um percorredor:
\ used for right-side THEN operand
Se a variable deste term for inexistente, abort with "Erro: variável do termo está vazia '" then a phrase deste term then "'." e o percorredor; exit.
Se o type deste term puder ser reduzido para "string", cancele.
Adicione um intermediate usando "string" e o first deste token deste percorredor.
Adicione o coloque ou convert fragments usando a variable deste term e o intermediate e o first deste token deste percorredor.
Coloque o intermediate into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se copy um field into another field:
Se o field for inexistente, esvazie o other field; exit.
Allocate memory por o other field.
Coloque o locus deste field into o other field's locus.
Coloque o name deste field into o other field's name.
Coloque o nickname deste field into o other field's nickname.
Coloque o type name deste field into o other field's type name.
Coloque o type deste field into o other field's type.
Coloque o field's contagem into o other field's contagem.
Coloque o redefinition target name deste field into o other field's redefinition target name.
Coloque o reference alarme deste field into o other field's reference alarme.
Coloque o offset deste field into o other field's offset.

Etapas necessárias para que se copy alguns fields into alguns other fields:
Obtenha um field from o fields.
Se o field for inexistente, cancele.
Copy o field into another field.
Posponha o other field to o other fields.
Repita.

Etapas necessárias para que se copy alguns fields into alguns other fields (data fields only):
Se a contagem destes fields for menor du que 4, cancele. \ for english next e prev e spanish next e prev redefinitions
\Se o fields' first for inexistente, cancele.
\Se o fields' first's next for inexistente, cancele.
\Se o fields' first's next's next for inexistente, cancele.
\\Coloque o fields' first's next's next into um field. \ skip next e prev
\Se o fields' first's next's next's next for inexistente, cancele.
\Se o fields' first's next's next's next's next for inexistente, cancele.
\Se o fields' first's next's next's next's next's next for inexistente, cancele.
\Coloque o fields' first's next's next's next's next into um field. 
Coloque o next deste next deste next deste next deste first destes fields into um field.\ english next e prev e spanish next e prev redefinitions
Percorra.
Se o field for inexistente, cancele.
Copy o field into another field.
Posponha o other field to o other fields.
Obtenha o field from o fields.
Repita.

Etapas necessárias para que se copy um monikette into another monikette:
Se o monikette for inexistente, esvazie o other monikette; exit.
Allocate memory por o other monikette.
Coloque o string deste monikette into o other monikette's string.
Coloque o type deste monikette into o other monikette's type.
Coloque a variable deste monikette into o other monikette's variable.
\ don't copy subtexto
Coloque o type atual deste monikette into o other monikette's type atual.

Etapas necessárias para que se copy alguns monikettes into alguns other monikettes:
Destroy o other monikettes.
Percorra.
Obtenha um monikette from o monikettes.
Se o monikette for inexistente, cancele.
Copy o monikette into another monikette.
Posponha o other monikette to o other monikettes.
Repita.

Etapas necessárias para que se crie um entry:
Allocate memory por o entry.

Etapas necessárias para que se crie um fragment usando uma tag:
Allocate memory por o fragment.
Coloque o tag into a tag deste fragment.

Etapas necessárias para que se crie um import:
Allocate memory por o import.

Etapas necessárias para que se crie um monikette:
Allocate memory por o monikette.

Etapas necessárias para que se crie uma routine:
Allocate memory por o routine.

Etapas necessárias para que se crie um source file:
Allocate memory por o source file.

Etapas necessárias para que se crie um type:
Allocate memory por o type.
Coloque 0/1 into o scale deste type.
Coloque -1 into o length deste type.

Etapas necessárias para que se crie uma variable usando um categoria:
Allocate memory por o variable.
Coloque o categoria into a categoria desta variable.
Coloque 1 into o contagem desta variable.

The endereço du cabeçalho usado atualmente é um address.

The endereço du nome usado atualmente é um address.

The rotina utilizada atualmente é uma routine.

The current thunk address é um address.

The zona de dados é um zona.

Etapas necessárias para que se determine se any of alguns monikettes são negative palavras:
Obtenha um monikette from o monikettes.
Se o monikette for inexistente, diga não.
Se o string deste monikette for any negative palavra, diga sim.
Repita.

Etapas necessárias para que se determine se um pedaço é any glom pedaço:
Se o pedaço for any letter, diga sim.
Se o pedaço for any digit, diga sim.
Se o pedaço for o acento til, diga sim.
Se o pedaço for o sinal de arroba, diga sim.
Se o pedaço for o número-sign pedaço, diga sim.
Se o pedaço for o sinal de porcentagem, diga sim.
Se o pedaço for o & comercial, diga sim.
Se o pedaço for o underscore pedaço, diga sim.
Se o pedaço for o single-quote pedaço, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any mark:
Se o pedaço for o ponto final, diga sim.
Se o pedaço for o vírgula, diga sim.
Se o pedaço for o ponto&vírgula, diga sim.
Se o pedaço for o sinal de dois pontos, diga sim.
Se o pedaço for o exclamation pedaço, diga sim.
Se o pedaço for o question-mark pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any stressed vowel:
Se o pedaço estiver in "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
Diga não.

Etapas necessárias para que se determine se um pedaço é any symbol:
Se o pedaço for o caret pedaço, diga sim.
Se o pedaço for o barra vertical, diga sim.
Se o pedaço for o asterisco, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Se o pedaço for o left-alligator pedaço, diga sim.
Se o pedaço for o right-alligator pedaço, diga sim.
Se o pedaço for o left-brace pedaço, diga sim.
Se o pedaço for o right-brace pedaço, diga sim.
Se o pedaço for o sinal de igualdade, diga sim.
Se o pedaço for 128, diga sim.
Se o pedaço for 130, diga sim.
Se o pedaço estiver entre 132 e 137, diga sim.
Se o pedaço for 139, diga sim.
Se o pedaço estiver entre 145 e 153, diga sim.
Se o pedaço for 155, diga sim.
Se o pedaço estiver entre 161 e 180, diga sim.
Se o pedaço estiver entre 183 e 191, diga sim.
Se o pedaço for 215, diga sim.
Se o pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um field term é vazio:
Se o field deste field term não for inexistente, diga não.
Se a function deste field term não for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se alguns fields deveriam ser finalizados;
Etapas necessárias para que se determine se alguns fields deveria ser finalizado:
Obtenha um field from o fields.
Se o field for inexistente, diga não.
Se o type deste field deveria ser finalizado, diga sim.
Repita.

Etapas necessárias para que se determine se um item looks reamish:
Load o endereço completo deste item into um trecho.
Se o trecho starts with "ream cal", diga sim.
Diga não.

Etapas necessárias para que se determine se um moniker estiver in um index:
Encontre um refer usando o moniker e o index.
Se o refer for inexistente, diga não.
Se o endereço de memória deste refer for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se o monikette for inexistente, diga sim.
Se o type atual deste monikette não for inexistente, diga não.
Se o subtexto atual deste monikette não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um name é any magnitude:
\PAL
Se o name for "magnitude", diga sim.
\CAL
Se o name for "magnitud", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any target:
\PAL
Se o name for "conteúdo", diga sim.
Se o name for "alvo", diga sim.
\CAL
Se o name for "target", diga sim.
Se o name for "objetivo", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any whereabouts:
\PAL
Se o name for "paradeiro", diga sim.
\CAL
Se o name for "whereabouts", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any valid field name:
Se o name for any magnitude, diga não.
Se o name for any target, diga não.
Se o name for any whereabouts, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está followed por any unit of measure:
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o percorredor não for on any name starter, diga não.
Examine um name usando o percorredor.
Encontre um type usando o name e o catálogo de tipos.
Se o type for inexistente, diga não.
Se o name não for "times", diga sim. \ special because times é um infix operator e um unit of measure
\Se o name não for "vezes", diga sim. 
Se o token deste percorredor for o start of any expression, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any nested double-quote:
Se o source deste percorredor starts with """""", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive:
Se o source deste percorredor estiver em branco, diga não.
Se o target deste first deste source deste percorredor não for o single-quote pedaço, diga não.
Se o percorredor estiver on any possessive (type 1 - single-quote, s, non-glom-byte), diga sim.
Se o percorredor estiver on any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive (type 1 - single-quote, s, non-glom-byte):
Se o source deste percorredor does not start with "'s", diga não.
Isole o percorredor.
Adicione 2 to o first deste source deste percorredor .
Se o source deste percorredor estiver em branco, diga sim.
Se o target deste first deste source deste percorredor não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Isole o percorredor.
Se o first deste source deste percorredor for o first deste subtexto original deste percorredor, diga não.
Subtraia 1 from o first deste source deste percorredor.
Se o target deste first deste source deste percorredor não for o little-s pedaço ou o S maiúsculo, diga não.
Adicione 2 to o first deste source deste percorredor.
Se o source deste percorredor estiver em branco, diga sim.
Se o target deste first deste source deste percorredor não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any simile:
\ added for invisible turtle project ***
Isole o percorredor.
Se o token deste percorredor for "LIKE", diga sim.
Se o token deste percorredor não for "AS", diga não.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor é o start of any function:
Se o alarme de alerta deste compilador estiver ativado, diga não.
Se o token deste percorredor for "Ponha", diga sim.
\Se o token deste percorredor não for any coloque, diga não.
Se o token deste percorredor não for "coloque", diga não.
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any article, diga não.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o token deste percorredor for any possessive, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any contraction giving another string (portuguese rules - "no"):
Se o string não for "no", diga não.
Se o other string for "say", diga não.
Se o other string for "diga", diga não.
\Se o other string for "dizer", diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant e another string:
Lance um subtexto on o string.
Subtraia o other string's length from o last deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o target deste last deste subtexto não for any consonant, diga não.
Se o string does not end with o other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel e another string:
Lance um subtexto on o string.
Subtraia o other string's length from o last deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o target deste last deste subtexto não for any vowel, diga não.
Se o string does not end with o other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant:
Se o string estiver em branco, diga não.
Se o target deste last deste string não for any consonant, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel:
Se o string estiver em branco, diga não.
Se o target deste last deste string não for any vowel, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any plus:
\PAL
Se o string for "mais", diga sim.
\CAL
Se o string for "plus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any coloque:
\PAL
Se o string for "pôr", diga sim.
\# Não precisa porque está como sinônimo: ver "Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules)"
\Se o string for "colocar", diga sim. 
\CAL
Se o string for "coloque", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any minus:
\PAL
Se o string for "menos", diga sim.
\CAL
Se o string for "minus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any times:
\PAL
Se o string for "vezes", diga sim.
\CAL
Se o string for "times", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any divided:
\PAL
Se o string for "dividido", diga sim.
\CAL
Se o string for "divided", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any by:
\PAL
Se o string for "via", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se o string for "por", diga sim.
\CAL
Se o string for "by", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any then:
\PAL
\# operador de concatenação de strings tipo: "abc" then "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida". 
Se o string for "depois", diga sim.
Se o string for "então", diga sim.
\CAL
Se o string for "then", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any has:
\PAL
Se o string for "tem", diga sim.
Se o string for "têm", diga sim.
Se o string for "possui", diga sim.
Se o string for "possuem", diga sim.
\CAL
Se o string for "has", diga sim.
Se o string for "have", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any is:
\PAL
Se o string for "é", diga sim.
Se o string for "está", diga sim.
Se o string for "são", diga sim.
Se o string for "estão", diga sim.
Se o string for "for", diga sim.
Se o string for "forem", diga sim.
Se o string for "estiverem", diga sim.
Se o string for "estarem", diga sim.
\CAL
Se o string for "is", diga sim.
Se o string for "are", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operador de atribuição:
\PAL
Se o string for "igual", diga sim.
\CAL
Se o string for "equal", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any with:
\PAL
Se o string for "com", diga sim.
\CAL
Se o string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any article:
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se o string for "e", diga sim.
Se o string for "ou", diga sim.
Se o string for "nem", diga sim.
\CAL
Se o string for "and", diga sim.
Se o string for "both", diga sim.
Se o string for "but", diga sim.
Se o string for "either", diga sim.
Se o string for "neither", diga sim.
Se o string for "nor", diga sim.
Se o string for "or", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any alarme literal:
\Se o string for "yes", diga sim.
\Se o string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any to:
\PAL
Se o string for "a", diga sim. \ this é questionable
\CAL
Se o string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any and:
\PAL
Se o string for "e", diga sim.
\CAL
Se o string for "and", diga sim.
Diga não. \repetido?

Etapas necessárias para que se determine se um string é any reverse-possessive function into:
\PAL
Se o string for "em", diga sim.
\CAL
Se o string for "into", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any alarme literal:
\Se o string for "si", diga sim.
\Se o string for "yes", diga sim.
\Se o string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any decider literal:
\PAL
Se o string for "sim", diga sim.
Se o string for "positivo", diga sim.
Se o string for "positivamente", diga sim.
Se o string for "não", diga sim.
Se o string for "negativo", diga sim.
Se o string for "negativamente", diga sim.
\CAL
Se o string for "yes", diga sim.
\Se o string for "yep", diga sim.
\Se o string for "yea", diga sim.
Se o string for "no", diga sim.
\Se o string for "nay", diga sim.
\Se o string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any positive decider literal:
\PAL
Se o string for "sim", diga sim.
Se o string for "positivo", diga sim.
Se o string for "positivamente", diga sim.
\CAL
Se o string for "yes", diga sim.
\Se o string for "yep", diga sim.
\Se o string for "yea", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any negative decider literal:
\PAL
Se o string for "não", diga sim.
Se o string for "negativo", diga sim.
Se o string for "negativamente", diga sim.
\CAL
Se o string for "no", diga sim.
\Se o string for "nay", diga sim.
\Se o string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any hex literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string for o cifrão, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo definido:
\PAL
Se o string for "o", diga sim.
Se o string for "a", diga sim.
Se o string for "os", diga sim.
Se o string for "as", diga sim.
Se o string for any pronome demonstrativo adjacente, diga sim.
\CAL
Se o string for "the", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo:
\CEL
Se o string for any pronome demonstrativo adjacente, diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo adjacente:
\CEL
Se o string for "este", diga sim.
Se o string for "esta", diga sim.
Se o string for "estes", diga sim.
Se o string for "estas", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo abrangente:
\CEL
Se o string for "esse", diga sim.
Se o string for "essa", diga sim.
Se o string for "aquele", diga sim.
Se o string for "aquela", diga sim.
Se o string for "esses", diga sim.
Se o string for "essas", diga sim.
Se o string for "aqueles", diga sim.
Se o string for "aquelas", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any artigo definido:
Se o percorredor estiver on any preposição conectiva, diga não.
Se o token deste percorredor não for any artigo definido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any artigo indefinido:
Se o percorredor estiver on any preposição conectiva, diga não.
Se o token deste percorredor não for any artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any preposição conectiva:
Se o token deste percorredor não for "a", diga não.
Isole o percorredor. Mova o percorredor (compilador rules).
Se o token deste percorredor for any article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo indefinido:
\PAL
Se o string for any artigo definido português, diga sim.
\CAL
Se o string for any artigo definido inglês, diga sim.
\Se o string for "a", diga sim.
Se o string for "an", diga sim.
Se o string for "another", diga sim.
Se o string for "some", diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo definido inglês:
\CAL
Se o string for "an", diga sim.
Se o string for "another", diga sim.
Se o string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo definido português:
\PAL
Se o string for "um", diga sim.
Se o string for "uma", diga sim.
Se o string for "outro", diga sim.
Se o string for "outra", diga sim.
Se o string for "algum", diga sim.
Se o string for "alguma", diga sim.
Se o string for "alguns", diga sim.
Se o string for "algumas", diga sim.
Diga não.



Etapas necessárias para que se determine se um string é any literal:
Se o string for any endereço de memória literal, diga sim.
Se o string for any numeric literal, diga sim.
Se o string for any string literal, diga sim.
\Se o string for any alarme literal, diga sim. ***
Se o string for any hex literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any mark:
Se o length deste string não for 1, diga não.
Se o target deste first deste string for any mark, diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any monikette string:
\Se o string estiver em branco, diga não.
\Se o string for "the", diga não.
\Se o string é any artigo indefinido, diga não.
\Se o string é any possessive, diga não.
\Se o string é any literal, diga não.
\Se o string é any mark, diga não.
\Se o string é any symbol, diga não.
\Diga sim.

Etapas necessárias para que se determine se um percorredor está on any monikette string:
Se o token deste percorredor estiver em branco, diga não.
Se o percorredor estiver on any artigo definido, diga não.
Se o percorredor estiver on any artigo indefinido, diga não.
Se o token deste percorredor for any possessive, diga não.
Se o token deste percorredor for any literal, diga não.
Se o token deste percorredor for any mark, diga não.
Se o token deste percorredor for any symbol, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any called:
\PAL
Se o string for "chamado", diga sim.
Se o string for "chamada", diga sim.
\CAL
Se o string for "called", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name ender:
\ compare with name starter
Se o string for any mark, diga sim.
Se o string for any symbol, diga sim.
Se o string for any article, diga sim.
Se o string for any conjunction, diga sim.
Se o string for any possessive, diga sim.
Se o string for any verb, diga sim.
Se o string for any operator, diga sim.
Se o string for any preposition, diga sim.
Se o string for any qualifier, diga sim.
Se o string for any literal, diga sim.
Se o string for "called", diga sim.
Se o string for "equal", diga sim.
Se o string estiver em branco, diga sim.
Diga não.
Etapas necessárias para que se determine se um string é any reference:
\PAL
Se o string for "(referência)", diga sim.
\CAL
Se o string for "(reference)", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any name ender:
\ compare with name starter
Se o token deste percorredor for any mark, diga sim.
Se o token deste percorredor for any symbol, diga sim.
Se o token deste percorredor for any article, diga sim.
Se o token deste percorredor for any conjunction, diga sim.
Se o token deste percorredor for any possessive, diga sim.
Se o percorredor estiver on any reverse-possessive, diga sim.
Se o token deste percorredor for any verb, diga sim.
Se o token deste percorredor for any operator, diga sim.
Se o percorredor estiver on any preposition, diga sim.
Se o token deste percorredor for any qualifier, diga sim.
Se o token deste percorredor for any literal, diga sim.
Se o token deste percorredor for any called, diga sim.
Se o token deste percorredor for any operador de atribuição, diga sim.
Se o token deste percorredor estiver em branco, diga sim.
\ Portuguese trouble makers
Se o token deste percorredor for any negative palavra, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name starter:
\ compare with name ender
Se o string for any mark, diga não.
Se o string for any symbol, diga não.
Se o string for any article, diga não.
Se o string for any conjunction, diga sim.
Se o string for any possessive, diga não.
Se o string for any verb, diga sim.
Se o string for any operator, diga sim.
Se o string for any preposition, diga sim.
Se o string for any qualifier, diga não.
Se o string for any literal, diga não.
Se o string for "called", diga sim.
Se o string for "equal", diga sim.
Se o string estiver em branco, diga não.
Diga sim.
Etapas necessárias para que se determine se um percorredor está on any name starter:
\ compare with name ender
Se o token deste percorredor for any mark, diga não.
Se o token deste percorredor for any symbol, diga não.
Se o token deste percorredor for any article, diga não.
Se o token deste percorredor for any conjunction, diga sim.
Se o token deste percorredor for any possessive, diga não.
Se o token deste percorredor for any verb, diga sim.
Se o token deste percorredor for any operator, diga sim.
Se o percorredor estiver on any preposition, diga sim.
Se o token deste percorredor for any qualifier, diga não.
Se o token deste percorredor for any literal, diga não.
Se o token deste percorredor for any called, diga sim.
Se o token deste percorredor for any operador de atribuição, diga sim.
Se o token deste percorredor estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any negative palavra:
\SAL
Se o string for "não", diga sim.
\Se o string for "nada", diga sim.
\Se o string for "ainda", diga sim.
\CAL
\Se o string for "no", diga sim.
Se o string for "not", diga sim.
Se o string for "cannot", diga sim.
Se o string for "nothing", diga sim.
Se o string ends with "n't", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operator:
\PAL
Se o string for "mais", diga sim.
Se o string for "menos", diga sim.
Se o string for "vezes", diga sim.
Se o string for "dividido", diga sim.
Se o string for "depois", diga sim.
Se o string for "então", diga sim.
\CAL
Se o string for "plus", diga sim.
Se o string for "minus", diga sim.
Se o string for "times", diga sim.
Se o string for "divided", diga sim.
Se o string for "then", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any artigo definido inglês:
\Se o string for "a", diga sim.
\Se o string for "an", diga sim.
\Se o string for "another", diga sim.
\Se o string for "some", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any pause:
\PAL
Se o string for "e", diga sim.
Se o string for "ou", diga sim.
\CAL
Se o string for "and", diga sim.
Se o string for "or", diga sim.
\default
Se o string for ",", diga sim.
Se o string for ";", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any endereço de memória literal:
\PAL
Se o string for "nulo", diga sim.
Se o string for "nula", diga sim.
Se o string for "inexistente", diga sim.
\CAL
Se o string for "nil", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any possessive:
Se o string for "'s", diga sim.
Se o string for "'", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any preposition:
Coloque o token deste percorredor into um subtexto.
\PAL
Se o percorredor estiver on any preposição conectiva, diga sim. \ "a" followed por um article for "to" in portuguese
Se o subtexto for "abaixo", diga sim. \ down
Se o subtexto for "acima", diga sim. \ up
Se o subtexto for "ante", diga sim. \ antes de
Se o subtexto for "antes", diga sim. \ antes de
Se o subtexto for "perante", diga sim. \ antes de
Se o subtexto for "debaixo", diga sim. \ below
Se o subtexto for "sob", diga sim. \ below
Se o subtexto for "acerca", diga sim. \ near
Se o subtexto for "próximo", diga sim. \ near
Se o subtexto for "perto", diga sim. \ near
Se o subtexto for "com", diga sim. \ with
Se o subtexto for "como", diga sim. \ as
Se o subtexto for "contra", diga sim. \ against
\ Se o subtexto for "de", diga sim. \ reverse-possessive indicator 
Se o subtexto for "dada", diga sim. \ given
Se o subtexto for "dado", diga sim. \ given
Se o subtexto for "dando", diga sim. \ given
Se o subtexto for "gerando", diga sim. \ giving
Se o subtexto for "resultando", diga sim. \ giving
Se o subtexto for "retornando", diga sim. \ giving
Se o subtexto for "direita", diga sim. \ right
Se o subtexto for "desde", diga sim. \ since
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "durante", diga sim. \ during
Se o subtexto for "em", diga sim. \ in
Se o subtexto for "entre", diga sim. \ between
Se o subtexto for "até", diga sim. \ until
Se o subtexto for "esquerda", diga sim. \ left
Se o subtexto for "mediante", diga sim. \ through
Se o subtexto for "para", diga sim. \ to
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "segundo", diga sim. \ according
Se o subtexto for "sem", diga sim. \ without
Se o subtexto for "então", diga sim.
Se o subtexto for "sobre", diga sim. \ on
Se o subtexto for "após", diga sim. \ after
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "usando", diga sim. \ using
Se o subtexto for "versus", diga sim. \ versus
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "enquanto", diga sim. \ while
Se o subtexto for "redefinindo", diga sim. \# 'at' na redefinição de campos 
\CAL
Se o subtexto for "about", diga sim.
Se o subtexto for "above", diga sim.
Se o subtexto for "across", diga sim.
Se o subtexto for "after", diga sim.
Se o subtexto for "against", diga sim.
Se o subtexto for "all", diga sim.
Se o subtexto for "alone", diga sim.
Se o subtexto for "along", diga sim.
Se o subtexto for "among", diga sim.
Se o subtexto for "any", diga sim.
Se o subtexto for "anywhere", diga sim.
Se o subtexto for "around", diga sim.
\Se o subtexto for "as", diga sim.
Se o subtexto for "at", diga sim.
Se o subtexto for "away", diga sim.
Se o subtexto for "back", diga sim.
Se o subtexto for "backward", diga sim.
Se o subtexto for "backwards", diga sim.
Se o subtexto for "antes de", diga sim.
Se o subtexto for "beginning", diga sim.
Se o subtexto for "behind", diga sim.
Se o subtexto for "below", diga sim.
Se o subtexto for "beneath", diga sim.
Se o subtexto for "beside", diga sim.
Se o subtexto for "between", diga sim.
Se o subtexto for "beyond", diga sim.
Se o subtexto for "bigger", diga sim.
Se o subtexto for "by", diga sim.
Se o subtexto for "close", diga sim.
Se o subtexto for "deep", diga sim.
Se o subtexto for "diagonally", diga sim.
Se o subtexto for "down", diga sim.
Se o subtexto for "downward", diga sim.
Se o subtexto for "ending", diga sim.
Se o subtexto for "everywhere", diga sim.
Se o subtexto for "except", diga sim.
Se o subtexto for "finishing", diga sim.
Se o subtexto for "facing", diga sim.
\Se o subtexto for "for", diga sim.
Se o subtexto for "por", diga sim.
Se o subtexto for "forward", diga sim.
Se o subtexto for "from", diga sim.
Se o subtexto for "given", diga sim.
Se o subtexto for "giving", diga sim.
Se o subtexto for "high", diga sim.
Se o subtexto for "in", diga sim.
Se o subtexto for "inside", diga sim.
Se o subtexto for "into", diga sim.
Se o subtexto for "en", diga sim.
Se o subtexto for "larger", diga sim.
Se o subtexto for "leaning", diga sim.
Se o subtexto for "left", diga sim.
Se o subtexto for "leftward", diga sim.
Se o subtexto for "leftways", diga sim.
Se o subtexto for "like", diga sim.
Se o subtexto for "limiting", diga sim.
Se o subtexto for "long", diga sim.
Se o subtexto for "near", diga sim.
Se o subtexto for "of", diga sim.
Se o subtexto for "off", diga sim.
Se o subtexto for "on", diga sim.
Se o subtexto for "only", diga sim.
Se o subtexto for "onto", diga sim.
Se o subtexto for "out", diga sim.
Se o subtexto for "outside", diga sim.
Se o subtexto for "over", diga sim.
Se o subtexto for "past", diga sim.
Se o subtexto for "pointing", diga sim.
Se o subtexto for "returning", diga sim.
Se o subtexto for "right", diga sim.
Se o subtexto for "rightward", diga sim.
Se o subtexto for "rightways", diga sim.
Se o subtexto for "shorter", diga sim.
Se o subtexto for "sideway", diga sim.
Se o subtexto for "sideways", diga sim.
Se o subtexto for "similar", diga sim.
Se o subtexto for "smaller", diga sim.
Se o subtexto for "somewhere", diga sim.
Se o subtexto for "slantwise", diga sim.
Se o subtexto for "slantway", diga sim.
Se o subtexto for "slantways", diga sim.
Se o subtexto for "starting", diga sim.
Se o subtexto for "tall", diga sim.
Se o subtexto for "taller", diga sim.
Se o subtexto for "thru", diga sim.
Se o subtexto for "through", diga sim.
Se o subtexto for "throughout", diga sim.
Se o subtexto for "to", diga sim.
Se o subtexto for "toward", diga sim.
Se o subtexto for "towards", diga sim.
Se o subtexto for "under", diga sim.
Se o subtexto for "underneath", diga sim.
Se o subtexto for "until", diga sim.
Se o subtexto for "unto", diga sim.
Se o subtexto for "up", diga sim.
Se o subtexto for "upward", diga sim.
Se o subtexto for "upon", diga sim.
Se o subtexto for "using", diga sim.
Se o subtexto for "via", diga sim.
Se o subtexto for "while", diga sim.
Se o subtexto for "wide", diga sim.
Se o subtexto for "with", diga sim.
Se o subtexto for "within", diga sim.
Se o subtexto for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any preposition:
Se o string for "about", diga sim.
Se o string for "above", diga sim.
Se o string for "across", diga sim.
Se o string for "after", diga sim.
Se o string for "against", diga sim.
Se o string for "all", diga sim.
Se o string for "alone", diga sim.
Se o string for "along", diga sim.
Se o string for "among", diga sim.
Se o string for "any", diga sim.
Se o string for "anywhere", diga sim.
Se o string for "around", diga sim.
\Se o string for "as", diga sim.
Se o string for "at", diga sim.
Se o string for "away", diga sim.
Se o string for "back", diga sim.
Se o string for "backward", diga sim.
Se o string for "backwards", diga sim.
Se o string for "antes de", diga sim.
Se o string for "beginning", diga sim.
Se o string for "behind", diga sim.
Se o string for "below", diga sim.
Se o string for "beneath", diga sim.
Se o string for "beside", diga sim.
Se o string for "between", diga sim.
Se o string for "beyond", diga sim.
Se o string for "bigger", diga sim.
Se o string for "by", diga sim.
Se o string for "close", diga sim.
Se o string for "deep", diga sim.
Se o string for "diagonally", diga sim.
Se o string for "down", diga sim.
Se o string for "downward", diga sim.
Se o string for "ending", diga sim.
Se o string for "everywhere", diga sim.
Se o string for "except", diga sim.
Se o string for "finishing", diga sim.
Se o string for "facing", diga sim.
\Se o string for "for", diga sim.
Se o string for "por", diga sim.
Se o string for "forward", diga sim.
Se o string for "from", diga sim.
Se o string for "given", diga sim.
Se o string for "giving", diga sim.
Se o string for "high", diga sim.
Se o string for "in", diga sim.
Se o string for "inside", diga sim.
Se o string for "into", diga sim.
Se o string for "larger", diga sim.
Se o string for "leaning", diga sim.
Se o string for "left", diga sim.
Se o string for "leftward", diga sim.
Se o string for "leftways", diga sim.
Se o string for "like", diga sim.
Se o string for "limiting", diga sim.
Se o string for "long", diga sim.
Se o string for "near", diga sim.
Se o string for "of", diga sim.
Se o string for "off", diga sim.
Se o string for "on", diga sim.
Se o string for "only", diga sim.
Se o string for "onto", diga sim.
Se o string for "out", diga sim.
Se o string for "outside", diga sim.
Se o string for "over", diga sim.
Se o string for "past", diga sim.
Se o string for "pointing", diga sim.
Se o string for "returning", diga sim.
Se o string for "right", diga sim.
Se o string for "rightward", diga sim.
Se o string for "rightways", diga sim.
Se o string for "shorter", diga sim.
Se o string for "sideway", diga sim.
Se o string for "sideways", diga sim.
Se o string for "similar", diga sim.
Se o string for "smaller", diga sim.
Se o string for "somewhere", diga sim.
Se o string for "slantwise", diga sim.
Se o string for "slantway", diga sim.
Se o string for "slantways", diga sim.
Se o string for "starting", diga sim.
Se o string for "tall", diga sim.
Se o string for "taller", diga sim.
Se o string for "thru", diga sim.
Se o string for "through", diga sim.
Se o string for "throughout", diga sim.
Se o string for "to", diga sim.
Se o string for "toward", diga sim.
Se o string for "towards", diga sim.
Se o string for "under", diga sim.
Se o string for "underneath", diga sim.
Se o string for "until", diga sim.
Se o string for "unto", diga sim.
Se o string for "up", diga sim.
Se o string for "upward", diga sim.
Se o string for "upon", diga sim.
Se o string for "using", diga sim.
Se o string for "via", diga sim.
Se o string for "while", diga sim.
Se o string for "wide", diga sim.
Se o string for "with", diga sim.
Se o string for "within", diga sim.
Se o string for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any qualifier:
Se o string estiver em branco, diga não.
Se o target deste first deste string for o left-paren pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any reverse-possessive:
\Se o string for "uv", diga sim.
Se o string for "de", diga sim.
\Se o string for "pertencente", diga sim.
\Se o string for "que pertence", diga sim.
\Se o string for "del", diga sim. \ short por "de el", expanded in "compile um term usando um percorredor e um field name (reverse-possessive)"
Diga não.

Etapas necessárias para que se determine se um percorredor está on any reverse-possessive:
Isole o percorredor.
\CAL
\Se o token deste percorredor for "uv", diga sim.
\PAL
\Se o string for "pertencente a", diga sim.
\Se o string for "pertencente ao", diga sim.
\Se o string for "que pertence a", diga sim.
\Se o string for "que pertence ao", diga sim.
\que consta
\que figura
\incorporada
\inerente
\Se o token deste percorredor não for "integrada de", diga não.
\Se o token deste percorredor não for "interna de", diga não.
\Se o token deste percorredor não for "interno de", diga não.
\Se o token deste percorredor não for "do registro de", diga não.
\Se o token deste percorredor não for "que está dentro de", diga não.
\Se o token deste percorredor não for "de dentro do registro de", diga não.
\Se o token deste percorredor não for "de dentro de", diga não.
\Se o token deste percorredor não for "que faz parte de", diga não.
Se o token deste percorredor não for "de", diga não.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any pronome demonstrativo, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any string literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string for as aspas duplas, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any symbol:
Se o length deste string não for 1, diga não.
Se o target deste first deste string for any symbol, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any verb:
\PAL
Se o string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
Se o string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" to non-tempora state
Se o string for "ser", diga sim. \ "be"
Se o string for "for", diga sim. \ "be"
Se o string for "forem", diga sim. \ "be"
Se o string for "estiver", diga sim. \ "be"
Se o string for "estiverem", diga sim. \ "be"
Se o string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated in o singular third person (3ps) present, perm.
Se o string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated in o singular third person (3ps) present, temp.
Se o string for "são", diga sim. \ "are" são not \ aren't: "to be" conjugated in o plural third person (3pp) present, perm.
Se o string for "estão", diga sim. \ "are" são not \ aren't: "to be" conjugated in o plural third person (3pp) present, temp.
Se o string for "foi", diga sim. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
Se o string for "estava", diga sim. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
Se o string for "foram", diga sim. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
Se o string for "estavam", diga sim. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
Se o string for "será", diga sim. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
Se o string for "estará", diga sim. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
Se o string for "serão", diga sim. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
Se o string for "estarão", diga sim. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
Se o string for "supera", diga sim. \ beats, exceeds
Se o string for "superam", diga sim. \ beats, exceeds
Se o string for "excede", diga sim. \ beats, exceeds
Se o string for "excedem", diga sim. \ beats, exceeds
Se o string for "pode", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se o string for "puder", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se o string for "puderem", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se o string for "podem", diga sim. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
Se o string for "poderia", diga sim. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
Se o string for "poderia", diga sim. \ they "could" could not \ couldn't: not used in CAL (3pp) added just in case
Se o string for "podemos", diga sim. \ we "could" could not \ couldn't: only once in Noodle (1pp) "Etapas necessárias para que se determine se we could encontre um endereço de memória:"
Se o string for "tem", diga sim. \ it "has" used in type definitions; (3ps) present
Se o string for "têm", diga sim. \ they "have" used in type definitions; (3pp) present
Se o string for "ter", diga sim. \ used in type definitions
Se o string for "possui", diga sim. \ it "has" used in type definitions; (3ps) present
Se o string for "possuem", diga sim. \ they "have" used in type definitions; (3pp) present
Se o string for "possuir", diga sim. \ used in type definitions
\\ trouble makers
Se o string for "inicia", diga sim. \ "begins" does not begin \ doesn't begin
Se o string for "começa", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se o string for "começar", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se o string for "termina", diga sim. \ "ends" does not end \ doesn't end
Se o string for "terminar", diga sim. \ "ends" does not end \ doesn't end
Se o string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
Se o string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
Se o string for "parece", diga sim. \ "looks" does not look \ doesn't look
Se o string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
Se o string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
Se o string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
\CAL
Se o string for "are", diga sim. \ são not \ aren't
Se o string for "be", diga sim. \
Se o string for "can", diga sim. \ cannot \ can't
Se o string for "cannot", diga sim. 
\Se o string for "could", diga sim. \ could not \ couldn't
\Se o string for "do", diga sim. \ does not \ don't
Se o string for "does", diga sim. \ does not \ doesn't
Se o string for "is", diga sim. \ não for \ isn't
Se o string for "may", diga sim. \ may not \ mayn't
Se o string for "should", diga sim. \ não deveria \ shouldn't
Se o string for "was", diga sim. \ was not \ wasn't
Se o string for "will", diga sim. \ will not \ won't
Se o string for "would", diga sim. \ would not \ wouldn't
Se o string for "has", diga sim. \ used in type definitions
Se o string for "have", diga sim. \ used in type definitions
Se o string ends with "n't", diga sim.
\\ trouble makers
Se o string for "begins", diga sim. \ does not begin \ doesn't begin
Se o string for "ends", diga sim. \ does not end \ doesn't end
Se o string for "looks", diga sim. \ does not look \ doesn't look
Se o string for "needs", diga sim. \ does not need \ doesn't need
Se o string for "starts", diga sim. \ does not start \ doesn't start
Diga não.

Etapas necessárias para que se determine se um string é o start of any definition:
\PAL
Se o string for "Passos", diga sim.
Se o string for "Etapas", diga sim.
\CAL
Se o string for "to", diga sim.
\default
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conditional:
\PAL
Se o string for "se", diga sim.
Se o string for "quando", diga sim.
\CAL
Se o string for "if", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any privatize:
\PAL
Se o string for "privatize", diga sim.
\Se o string for "reserve", diga sim.
Se o string for "separe", diga sim.
Se o string for "isole", diga sim.
Se o string for "Isole", diga sim.
Se o string for "conserve", diga sim.
Se o string for "derive", diga sim.
\CAL
\Se o string for "privatize", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any loop:
\PAL
Se o string for "percorra", diga sim.
\Se o string for "ciclo", diga sim.
\Se o string for "laço", diga sim. \# muito usado em pseudo-codigo
\CAL
Se o string for "loop", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any break:
\PAL
Se o string for "pare", diga sim.
Se o string for "pare de percorrer", diga sim.
Se o string for "pare de repetir", diga sim.
Se o string for "cancele a operação", diga sim.
Se o string for "interrompa a operação", diga sim.
\CAL
Se o string for "break", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any exit:
\PAL
Se o string for "acabe", diga sim.
Se o string for "acabou", diga sim.
Se o string for "acabou-se", diga sim.
\Se o string for "advirta", diga sim.
\Se o string for "anuncie", diga sim.
\Se o string for "avise", diga sim.
Se o string for "cancele", diga sim.
Se o string for "desconsidere.", diga sim.
Se o string for "deixa quieto", diga sim.
Se o string for "deixe quieto", diga sim.
Se o string for "e mais nada", diga sim.
Se o string for "e pronto", diga sim.
Se o string for "e só", diga sim.
Se o string for "fim", diga sim.
Se o string for "fimse", diga sim.
Se o string for "ignore", diga sim.
\Se o string for "informe", diga sim.
Se o string for "prossiga", diga sim.
Se o string for "pronto", diga sim.
Se o string for "retorne", diga sim.
Se o string for "saia", diga sim.
Se o string for "siga adiante", diga sim.
Se o string for "terminamos", diga sim.
Se o string for "termine", diga sim.
\CAL
Se o string for "exit", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any repeat:
\PAL
\Se o string for "repetir", diga sim. \# muito usado em pseudo-codigo
Se o string for "repita", diga sim. \# muito usado em pseudo-codigo
\CAL
Se o string for "repeat", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any say:
\PAL
Se o string for "diga", diga sim. \# modo imperativo
Se o string for "responda", diga sim. \# modo imperativo
Se o string for "informe", diga sim. \# modo imperativo
\Se o string for "dizer", diga sim. \# modo infinitivo opcional.
\CAL
Se o string for "say", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any decide:
\PAL
\Se o string for "decidir", diga sim.
Se o string for "decida", diga sim.
\Se o string for "escolha", diga sim.
Se o string for "determine", diga sim.
Se o string for "conclua", diga sim.
Se o string for "esclareça", diga sim.
Se o string for "descubra", diga sim.
Se o string for "analise", diga sim.
\CAL
Se o string for "decide", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any call:
\PAL
Se o string for "chame", diga sim.
\Se o string for "repasse", diga sim.
\Se o string for "informe", diga sim.
\CAL
Se o string for "call", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any point:
\PAL
Se o string for "aponte", diga sim.
\CAL
Se o string for "point", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any employ:
\PAL
Se o string for "empregue", diga sim.
\CAL
Se o string for "employ", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any noise palavra:
\Nova rotina 
Se o string for "already", diga sim.
Se o string for "still", diga sim.
Se o string for "yet", diga sim.
Se o string for "já", diga sim.
Se o string for "ainda", diga sim.
\Se o string for "que", diga sim.
\Se o string for "se", diga sim.
[more noise palavras here]
Diga não.

Etapas necessárias para que se determine se um string é o start of any expression:
Se o string for any sign, diga sim.
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Se o string for any literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any global:
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any new local:
Se o string for any artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any optional info:
\PAL
Se o string for "com", diga sim.
\CAL
Se o string for "to", diga sim.
Se o string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any routine:
\PAL
Se o string for "Passos", diga sim.
Se o string for "Etapas", diga sim.
Se o string for "Etapas necessárias para que se", diga sim. \verificar depois
Se o string for "Passos necessários para que se", diga sim.
\CAL
Se o string for "to", diga sim. \verificar se pode ser excluído
Diga não.

Etapas necessárias para que se determine se um string é o start of any statement:
Se o string for o start of any definition, diga não.
Se o string for any literal, diga não.
Se o string for any mark, diga não.
Se o string estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é o start of any type:
Se o string for any artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any variable:
Se o string for any artigo definido, diga sim.
\Se o string for "do", diga sim. \ this é iffy, here por reverse-possessives
Diga não.

Etapas necessárias para que se determine se um string has any stressed vowel:
Isole o string.
Percorra.
Se o string estiver em branco, diga não.
Se o target deste last deste string for any stressed vowel, diga sim.
Subtraia 1 from o last deste string.
Repita.

Etapas necessárias para que se determine se um term é vazio:
Se a variable deste term não for inexistente, diga não.
Se a phrase deste term não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um type puder ser reduzido para um string using o base name:
Se o type for inexistente, diga não.
Se o name deste type for o string, diga sim.
Se o cooking alarme deste type estiver ativo, diga não.
Ligue o cooking alarme deste type.
Encontre um base type usando o base name deste type e o catálogo de tipos.
Se o base type for inexistente, desative o cooking alarme deste type; diga não.
Se o base type puder ser reduzido para o string using o base name, desative o cooking alarme deste type; say yes.
Desative o cooking alarme deste type.
Diga não.

Etapas necessárias para que se determine se um type puder ser reduzido para um type name:
Se o type for inexistente, diga não.
Isole o type.
Percorra.
Se o type for inexistente, diga não.
Se o name deste type for o type name, diga sim.
Se o type's base type for o type, diga não.
Coloque o base type deste type into o type.
Repita.

Etapas necessárias para que se determine se um type é any built-in type:
Se o type for inexistente, diga não.
Se o type for o base type deste type, diga sim.
Diga não.

Etapas necessárias para que se determine se um type é value pushable:
Se o type for inexistente, diga não.
Se o type for inexistente, diga não. \\ repetido?
Se o length deste type for 4, diga sim.
Se o length deste type for 2, diga sim.
Se o length deste type for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser finalizado:
Se o type for inexistente, diga não.
Se o type puder ser reduzido para "subtexto", diga não.
Se o type puder ser reduzido para "string", diga sim.
Se os fields deste type deveriam ser finalizados, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser ignorado:
Se o type for inexistente, diga não.
\PAL
\Se o name deste type for "elemento", diga não.
\Se o name deste type for "elementos", diga não.
\CAL
Se o name deste type for "coisa", diga não.
Se o name deste type for "coisas", diga não.
Se o type puder ser reduzido para "coisas", diga sim.
Se o type não puder ser reduzido para "endereço de memória", diga não.
Se o target type deste type for inexistente, diga não.
Se o target type deste type não puder ser reduzido para "endereço de memória", diga sim.
Se o target type deste type não deveria ser ignorado, diga não.
Diga sim.

Etapas necessárias para que se determine se uma variable é duplicated in alguns variables:
Obtenha another variable from o variables.
Se o other variable for inexistente, diga não.
Se o other variable's name estiver em branco, repita.
Se o other variable for o variable, repita.
Se o other variable's name for o name desta variable, diga sim.
Repita.

The dereference tag é uma tag igual a 5.

An DOS header é um conjunto with
An wyrd called signature, \\ The value of this word is 5A4DH (with the 4DH coming first). 
\\ Signature Word. This contains a 'magic number' which provides a simple check that the file really is a DOS .EXE file;
\\ it follows that the filename extension does not in fact have to be .EXE, as long as programs check this word. 
\\The value of this word is 5A4DH (with the 4DH coming first). 
\\These two bytes represent the character string 'MZ', the initials of Mark Zibowski, a Microsoft employee at the time the file format was designed.
An wyrd called numberofbytesonlastpage, \\ The last page may contain between 1 and 512 bytes
\\Last Page Size. 
\\The file occupies a number of 512 byte pages. 
\\The last page may contain between 1 and 512 bytes. 
\\This word indicates the number of bytes actually used in the last page, 
\\with the special case of a full page being represented by a value of zero (since the last page is never empty).
An wyrd called numberofpages,
\\ File Pages. 
\\This word contains a count of the number of pages required to hold the file. 
\\For example, if the file contains 1024 bytes, this word would contain 0002H; 
\\if the file contains 1025 bytes, this word would contain 0003H. 
\\The Last Page Size field is used to determine the number of valid bytes in the final page. 
\\Thus, if the file contains 1024 bytes, the Last Page Size field contains 0000H, because no bytes overflow into a final partly used page. 
\\If the file contains 1025 bytes, then the Last Page Size field contains 0001H, because the final page contains only one valid byte (the 1025th byte).
An wyrd called relocuss,
\\ Relocation Items. 
\\ This word gives the number of entries that exist in the relocation pointer table. 
\\It is quite in order for this value to be zero, in which case there are no relocation entries.
An wyrd called sizeofheaderinparagraphs,
\\ Header Paragraphs. 
\\This word gives the size of the .EXE header in paragraphs. 
\\It indicates the offset of the program's compiled/assembled and linked image (the load module) within the .EXE file. 
\\The size of the load module can be deduced by subtracting this value (converted to bytes) from the overall file size 
\\derived from combining the File Pages and Last Page Size values. 
\\The header always spans an even number of paragraphs.
An wyrd called minimumextraparagraphs,
\\ MINALLOC. 
\\This word indicates the minimum number of paragraphs the program requires to begin execution. 
\\This is in addition to the memory required to hold the load module. 
\\This value normally represents the total size of any uninitialised data and/or stack segments that are linked at the end of a program. 
\\This space is not directly included in the load module, since there are no particular initialising values and it would simply waste disk space.
An wyrd called maximumextraparagraphs,
\\ MAXALLOC. 
\\This word indicates the maximum number of paragraphs that the program would like allocated to it before it begins execution. 
\\This indicates additional memory over and above that required by the load module and the value specified by MINALLOC. 
\\If the request cannot be satisfied, the program is allocated as much memory as is available.
An wyrd called initialrelativess,
\\ Initial SS value. 
\\This word contains the paragraph address of the stack segment relative to the start of the load module. 
\\At load time, this value is relocated by adding the address of the start segment of the program to it, 
\\and the resulting value is placed in the SS register before the program is started. 
\\In DOS, the start segment of the program is the first segment boundary in memory after the PSP.
An wyrd called initialsp,
\\ Initial SP value. 
\\This word contains the absolute value that must be loaded into the SP register before the program is given control. 
\\Since the actual stack segment is determined by the loader, and this is merely a value within that segment, it does not need to be relocated.
An wyrd called initialchecksum,
\\ Complemented Checksum. 
\\This word contains a checksum of the contents of the .EXE file. 
\\ Its value is rarely checked, but its purpose is to ensure the integrity of the data within the file. 
\\ Full details of how it is calculated appear in the section on checksum calculation.
An wyrd called initialip,
\\ Initial IP value. 
\\This word contains the absolute value that should be loaded into the IP register in order to transfer control to the program. 
\\Since the actual code segment is determined by the loader, and this is merely a value within that segment, it does not need to be relocated.
An wyrd called initialirelativecs, 
\\ Pre-relocated initial CS value. 
\\ This word contains the initial value, relative to the start of the load module, that should be placed in the CS register in order to transfer control to the program. 
\\ At load time, this value is relocated by adding the address of the start segment of the program to it, and the resulting value is placed in the CS register
\\ when control is transferred.
An wyrd called addressofrelocationtableinfile,
\\ Relocation table offset. 
\\ This word gives the offset from the start of the file to the relocation pointer table. 
\\ This value must be used to locate the relocation pointer table (rather than assuming a fixed location) 
\\because variable-length information pertaining to program overlays can occur before this table, causing its position to vary. 
\\A value of 40H in this field generally indicates a different kind of executable file, not a DOS 'MZ' type.
An wyrd called overlynumber,
\\ Overlay number. 
\\ This word is normally set to 0000H, because few programs actually have overlays. 
\\It changes only in files containing programs that use overlays; see the note below.
8 pedaços called resveredbytes, \\ Specifies reserved words for the program (known in winnt.h as e_res[4]), usually set to zero by the linker. 
\\In this case, just use a single reserved1 set to zero; if not zero create four reserved1 with the correct value.
An wyrd called oemidentifier, \\ Specifies the identifier for the OEM for e_oeminfo.
An wyrd called oeminfo, \\ Specifies the OEM information for a specific value of e_oeminfo.
20 pedaços called reservedwords, \\ Specifies reserved words for the program (known in winnt.h as e_res[10]), usually set to zero by the linker. 
\\In this case, just use a single reserved1 set to zero; if not zero create ten reserved1 with the correct value.
An número called addressofpeheaderinfile.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variables:
Crie um index usando 101.
Eliminate duplicate nicknames from o variables usando o index.
Destroy o index.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variables usando um index:
Se o index for inexistente, cancele.
Percorra.
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Eliminate duplicate nicknames usando o variable e o index.
Repita.

Etapas necessárias para que se eliminate duplicate nicknames usando uma variable e um index:
Se o variable for inexistente, cancele.
Se o index for inexistente, cancele.
Encontre another variable usando o nickname desta variable e o index.
Se o other variable for inexistente, encontre o other variable usando o name desta variable e o index.
Se o other variable for inexistente, catalogue o variable usando o nickname desta variable e o index; exit.
Limpe o other variable's nickname.
Limpe o nickname desta variable.

The end if tag é uma tag igual a 6.

An entry é uma coisa with
An name address,
An thunk address,
An name,
An address.

The epilog tag é uma tag igual a 7.

The exit tag é uma tag igual a 8.

An expression é um term.

Etapas necessárias para que se extend um string with another string:
Se o other string estiver em branco, cancele.
Se o string não estiver em branco, posponha o space pedaço to o string.
Posponha o other string to o string.

An field é uma variable.

An field term é um conjunto with
An dereference alarme,
An field (reference),
An function routine (reference),
An push alarme.

Etapas necessárias para que se finalize o compilador:
Destroy o catálogo de rotinas úteis.
Destroy o catálogo geral de rotinas.
Destroy o catálogo de variáveis hexadecimais.
Destroy o catálogo de variáveis globais.
Destroy o catálogo de tipos.
Destroy o imports.
Destroy o routines.
Destroy o literals.
Destroy o globals.
Destroy o types.
Destroy o source files.

The finalize tag é uma tag igual a 9.

Etapas necessárias para que se encontre um entry usando um string e alguns entries:
Esvazie o entry.
Percorra.
Obtenha o entry from o entries.
Se o entry for inexistente, cancele.
Se o name desta entry for o string, cancele.
Repita.

Etapas necessárias para que se encontre um field term usando um phrase e um type e um name:
Limpe o field term.
Encontre o field term usando o type e o name.
Se o field deste field term não for inexistente, cancele.
Se o phrase não estiver em branco, encontre uma routine usando "coloque" e o phrase e "'s " then o name e "into".
Se o routine não for inexistente, coloque o routine into o function deste field term; exit.
Se o type for inexistente, cancele.
Encontre o routine usando "coloque" e o type e "'s " then o name e "into".
Se o routine não for inexistente, acione o field term's push alarme; coloque o routine into o function deste field term; exit.
\ code below for looking deep within endereço de memórias - a debatable feature
\ if o target type deste type não for inexistente, encontre o routine usando "coloque" e o target type deste type e "'s " then o name e "into".
\ if o routine não for inexistente, acione o field term's dereference alarme; coloque o routine into o field term's function; exit.

Etapas necessárias para que se encontre um field term usando um type e um name:
Se o type for inexistente, cancele.
Encontre um field usando o name e os fields deste type.
Se o field não for inexistente, coloque o field into o field deste field term; exit.
Se o target type deste type não for inexistente, encontre o field usando o name e os fields deste target type deste type.
Se o field não for inexistente, acione o dereference alarme deste field term; coloque o field into o field deste field term; exit.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag:
Coloque o other fragment into o fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se o tag deste fragment for o tag, cancele.
Coloque o next deste fragment into o fragment.
Repita.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag (backwards):
Coloque o other fragment into o fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se o tag deste fragment for o tag, cancele.
Coloque o previous deste fragment into o fragment.
Repita.

Etapas necessárias para que se encontre um import usando um string:
Esvazie o import.
Percorra.
Obtenha o import from o imports.
Se o import for inexistente, cancele.
Se o name deste import for o string, cancele.
Repita.

Etapas necessárias para que se encontre um endereço completo e um row# usando um endereço de memória du pedaço :
Limpe o endereço completo.
Coloque 0 into o row#.
Encontre um source file usando o endereço de memória du pedaço .
Se o source file for inexistente, cancele.
Coloque o endereço completo deste source file into o endereço completo.
Encontre o row# usando o source file e o endereço de memória du pedaço .

Etapas necessárias para que se encontre uma routine usando um moniker e um monikette e um index:
Se o monikette for inexistente, cancele.
Esvazie o routine.
Isole o moniker.
Coloque o type deste monikette into o type atual deste monikette.
Lance o subtexto atual deste monikette on o string deste monikette.
Percorra.
Posponha o monikette to o moniker (while bubbling).
Encontre um refer usando o moniker e o index.
Se o refer não for inexistente, coloque o endereço de memória deste refer into o routine.
Se o refer não for inexistente, encontre o routine usando o moniker e o next deste monikette e o index.
Se o routine não for inexistente, pare.
Bubble o monikette.
Se o monikette estiver bubbled out, pare.
Coloque o original moniker into o moniker.
Repita.

Etapas necessárias para que se encontre uma routine usando alguns monikettes:
Esvazie o routine.
Encontre o routine usando um moniker e o first destes monikettes e o catálogo geral de rotinas.

Etapas necessárias para que se encontre uma routine usando um string e another string e um third string e um fourth string:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to o monikettes usando o other string.
Adicione um third monikette to o monikettes usando o third string.
Adicione um fourth monikette to o monikettes usando o fourth string.
Encontre o routine usando o monikettes.
Destroy o monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to o monikettes usando o type.
Encontre o routine usando o monikettes.
Destroy o monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e another type:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to o monikettes usando o type.
Adicione um third monikette to o monikettes usando o other string.
Adicione um fourth monikette to o monikettes usando o other type.
Encontre o routine usando o monikettes.
Destroy o monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um third string:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to o monikettes usando o type.
Adicione um third monikette to o monikettes usando o other string.
Adicione um fourth monikette to o monikettes usando o third string.
Encontre o routine usando o monikettes.
Destroy o monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um third string e um fourth string e um fifth string:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to o monikettes usando o type.
Adicione um third monikette to o monikettes usando o other string.
Adicione um fourth monikette to o monikettes usando o third string.
Adicione um fifth monikette to o monikettes usando o fourth string.
Adicione um sixth monikette to o monikettes usando o fifth string.
Encontre o routine usando o monikettes.
Destroy o monikettes.

Etapas necessárias para que se encontre um row# usando um source file e um endereço de memória du pedaço :
Se o endereço de memória du pedaço for inexistente, coloque 0 into o row#; exit.
Lance um subtexto on o source file's trecho.
Coloque 1 into o row#.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o first deste subtexto for o endereço de memória du pedaço , cancele.
Se o target deste first deste subtexto for o return pedaço, adicione 1 to o row#.
Adicione 1 to o first deste subtexto.
Repita.

Etapas necessárias para que se encontre um source file usando um endereço de memória du pedaço :
Se o endereço de memória du pedaço for inexistente, esvazie o source file; exit.
Percorra.
Obtenha o source file from o source files.
Se o source file for inexistente, cancele.
Se o endereço de memória du pedaço for menor du que o first deste trecho deste source file, repita.
Se o endereço de memória du pedaço for maior du que o last deste trecho deste source file, repita.

Etapas necessárias para que se encontre um type e um nickname usando um name:
Esvazie o type.
Limpe o nickname.
Encontre o type e o nickname usando o name (forward).
Se o type não for inexistente, cancele.
Encontre o type e o nickname usando o name (backward).
\Lance um subtexto on o name.
\Percorra.
\Se o subtexto estiver em branco, cancele.
\Encontre o type usando o subtexto e o catálogo de tipos.
\Se o type não for inexistente, pare.
\Skip to o next palavra in o subtexto.
\Repita.
\Coloque o name's first into another subtexto's first.
\Coloque o first deste subtexto menos 2 into o other subtexto's last.
\Se o other subtexto não estiver em branco, coloque o other subtexto into o nickname.
\Se o other subtexto estiver em branco, coloque o subtexto into o nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (backward):
Esvazie o type.
Limpe o nickname.
Lance um subtexto on o name.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip to o previous palavra in o subtexto.
Repita.
Coloque o last deste name into another subtexto's last .
Coloque o last deste subtexto mais 2 into o other subtexto's first.
Se o other subtexto não estiver em branco, coloque o other subtexto into o nickname.
Se o other subtexto estiver em branco, coloque o subtexto into o nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (forward):
\ original - no mude
Esvazie o type.
Limpe o nickname.
Lance um subtexto on o name.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip to o next palavra in o subtexto.
Repita.
Coloque o name's first into another subtexto's first.
Coloque o first deste subtexto menos 2 into o other subtexto's last.
Se o other subtexto não estiver em branco, coloque o other subtexto into o nickname.
Se o other subtexto estiver em branco, coloque o subtexto into o nickname.

Etapas necessárias para que se encontre uma variable usando um name:
Se a rotina utilizada atualmente for inexistente, esvazie o variable; exit.
Encontre o variable usando o name e os locals desta rotina utilizada atualmente.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e os parameters desta rotina utilizada atualmente.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e o catálogo de variáveis globais.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se encontre uma variable usando um name e algumas variables:
Esvazie o variable.
Percorra.
Obtenha o variable from o variables.
Se o variable for inexistente, cancele.
Se o name desta variable for o name, cancele.
Se o nickname desta variable for o name, cancele.
Repita.


\Etapas necessárias para que se encontre uma variable usando um name:
\Se a rotina utilizada atualmente for inexistente, esvazie o variable; exit.
\Encontre o variable usando o name e o rotina utilizada atualmente's locals.
\Se o variable não for inexistente, cancele.
\Encontre o variable usando o name e o rotina utilizada atualmente's parameters.
\Se o variable não for inexistente, cancele.
\Encontre o variable usando o name e o catálogo de variáveis globais.
\Se o variable não for inexistente, cancele.
\ Encontre o variable usando o name e o catálogo de variáveis hexadecimais.

\Etapas necessárias para que se encontre uma variable usando um name e alguns variables:
\esvazie o variable.
\Percorra.
\Obtenha o variable from o variables.
\Se o variable for inexistente, cancele.
\Se o variable's name é o name, cancele.
\Se o variable's nickname é o name, cancele.
\Repita.

An fragment é uma coisa with
An tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
An variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
An routine (reference) [call internal, routine address],
An entry (reference) [call external],
An número [increment],
An alarme [load eax], \SAL
An address,
An texto hexadecimal called code.

Etapas necessárias para que se gere um name usando um string:
Coloque o string into o name.
Adicione 1 to o name contagem deste compilador.
Convert o name contagem deste compilador to another string.
Posponha o other string to o name.

Etapas necessárias para que se obtenha um address usando uma routine:
Se o address desta routine não for 0, coloque o address desta routine into o address; exit.
Coloque -1 into o address desta routine.
Encontre another routine usando o employs moniker desta routine e o catálogo geral de rotinas.
Se o other routine for inexistente, abort with "Eu não consegui encontrar uma tarefa '" then o employs moniker desta routine then "' que você está tentando employ." e o locus desta routine; exit.
Se o other routine's address for -1, abort with "Referência recursiva na cláusula employ." e o routine's locus; exit. \Bora traduzir
Obtenha o address usando o other routine.
Coloque o address into o address desta routine.

Etapas necessárias para que se obtenha um contagem usando alguns imports (all entries mais markers):
Coloque 0 into o contagem.
Percorra.
Obtenha um import from o imports.
Se o import for inexistente, cancele.
Adicione a contagem destas entries deste import to o contagem.
Adicione 1 to o contagem.
Repita.

An global body é um subtexto.

The catálogo de variáveis globais é um index.

An global é uma variable.

The globals são alguns globals.

The image base é um address igual a 4194304 [$00400000].

The import zona é um zona.

An import header é um conjunto with
An address called original first thunk, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-first-thunkoft-milad-kahsari-alhadi/
\ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft#:~:text=The%20original%20first%20thunk%20is,%2C%20user32%20etc)%20are%20known.
\Thunks are the defnitive pieces of codes in an operating system that handle the transitions between 16 and 32-bit code.
\ Thus they ensure backward compatibility between the calls made by the application.
\ The OS is subjected with this facility for backward compatibility, so that the 16 bit applications can run smoothly in 32 bit environment.
\ The original first thunk is needed if the imports are bound but the imported .DLL does not match.
\ On a fresh unpatched version of Windows, all addresses of all functions in the base .DLLs (ntdll, kernel32, user32 etc) are known. 
\Take shell32 for example, it links to kernel32!CreateProcess and the true address of CreateProcess can be stored directly in shell32. 
\This is called import binding and lets the loader skip the step where it looks up all the addresses of the imported functions.
\This does not work if the imported .DLL has not been loaded at its preferred address nor if the .DLL has changed (security update etc). 
\If this happens then the loader has to look up the functions "the normal way" and the original first thunk array has to be used
\ because that is the only place where the RVAs of the function names are stored.
\ If import binding is not used then the original first thunk array is optional and might not be present.
\ ASLR has probably made this optimization irrelevant.
An número called timestamp, \ Set to zero until bound; then this feld is set to the TimeDateStamp of the exporting DLL's 'FileHeader'
An address called forwarder chain, \ Forwarder Chain: The 32-bit index of the frst forwarder in the list of imported functions
An address called name memory address, 
\It holds the RVA [Relative Virtual Address] of the dll to be loaded into memory. It is a dword value. 
\It is comprised of : RVA = Image Base + Endian Order 
\Note: As we know OllyDbg gives the result in the Big Endian order where as the x86 architecture holds the address in the Little Endian order, 
\ so the address gets exchanged reversibly in the di tuples
An address called first thunk memory address. 
\ Once the API is linked and gets loaded into memory the frst thunk which is a RVA points to the Import Address Table [IAT]

An import é uma coisa with
An name address,
An header address,
An name,
An import header,
Some entries.

The imports são alguns imports.

The increment tag é uma tag igual a 10.

Etapas necessárias para que se catalogue um global:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o global for inexistente, cancele.
Se o name deste global estiver in o catálogo de variáveis globais, abort with "'" then o name deste global then "' é uma variável global duplicada." e o locus deste global; exit.
Catalogue o global usando o name deste global e o catálogo de variáveis globais.

Etapas necessárias para que se catalogue um literal:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o literal for inexistente, cancele.
Se o name deste literal estiver in o catálogo de variáveis hexadecimais, abort with "Erro interno no nome do literal na função index um literal" e o literal's locus; exit.
Catalogue o literal usando o name deste literal e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se catalogue um partial moniker usando um index (special):
Encontre um refer usando o partial moniker e o index.
Se o refer não for inexistente, cancele.
Catalogue o partial moniker in o index.

Etapas necessárias para que se catalogue uma routine por utility use:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o function alarme desta routine estiver ativo, cancele.
Se o contagem destes parameters desta routine for 0, cancele.
Copy os monikettes desta routine into alguns monikettes.
Reduce o monikettes por utility use.
Convert o monikettes to um moniker.
Destroy o monikettes.
Se o moniker estiver in o catálogo geral de rotinas, cancele.
Encontre um refer usando o moniker e o catálogo de rotinas úteis.
Se o refer não for inexistente, coloque nil into o endereço de memória deste refer; exit.
Catalogue o routine usando o moniker e o catálogo de rotinas úteis.

Etapas necessárias para que se catalogue uma routine usando um moniker e um index (special):
Encontre um refer usando o moniker e o index.
Se o refer não for inexistente, coloque o routine into o endereço de memória deste refer; exit.
Catalogue o routine usando o moniker e o index.

Etapas necessárias para que se catalogue uma routine usando alguns monikettes e um index:
Se a routine for inexistente, cancele.
Limpe um partial moniker.
Percorra.
Obtenha um monikette from o monikettes.
Se o monikette for inexistente, cancele.
Posponha o monikette to o partial moniker.
Se o monikette for o last destes monikettes, pare.
Catalogue o partial moniker usando o index (special).
Repita.
Catalogue o routine usando o partial moniker como um moniker e o index (special).

Etapas necessárias para que se catalogue alguns routines por utility use:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from o routines.
Se a routine for inexistente, cancele.
Catalogue o routine por utility use.
Repita.

Etapas necessárias para que se catalogue um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Catalogue o type usando o name deste type.

Etapas necessárias para que se catalogue um type usando um name:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Encontre um existing type usando o name e o catálogo de tipos.
Se o existing type for inexistente, catalogue o type usando o name e o catálogo de tipos; exit.
Coloque o locus deste type into um locus.
Se o locus for inexistente, coloque o existing type's locus into o locus. \ point o erro to um type in o source code, not um generated type
Abort with "Acho que já vi o tipo '" then o name then "' em algum lugar antes; você deve ter duplicado ele." e o locus.

The indexing utilities cronômetro é um cronômetro.

Etapas necessárias para que se initialize o compilador:

Etapas necessárias para que se initialize o compilador usando um endereço dâ pasta:
Coloque o endereço dâ pasta into o endereço dâ pasta deste compilador.
Coloque 0 into o name contagem deste compilador.
Desative o alarme de alerta deste compilador.
Limpe a mensagem de erro deste compilador.
Limpe o abort endereço completo deste compilador.
Coloque 0 into o abort row# deste compilador.
Esvazie a rotina utilizada atualmente.
Crie o catálogo de tipos with 13001 [buckets]. \ was 4027
Crie o catálogo de variáveis globais with 13001 [buckets]. \ was 4027
Crie o catálogo de variáveis hexadecimais with 13001 [buckets]. \ was 4027
Crie o catálogo geral de rotinas with 13001 [buckets]. \ was 7919
Crie o catálogo de rotinas úteis with 13001 [buckets]. \ was 4027

Etapas necessárias para que se initialize um DOS header: \ vou alterar depois
Coloque 23117 [$5A4D] into o DOS header's signature.
Coloque 64 [$0040] into o DOS header's addressofrelocationtableinfile.
Coloque 256 [$00000100] into o DOS header's addressofpeheaderinfile.

Etapas necessárias para que se initialize um PE header:
Initialize o PE header (standard header).
Initialize o PE header (optional header).
Initialize o PE header (version information).
Initialize o PE header (directories).
Initialize o PE header (import section).
Initialize o PE header (data section).
Initialize o PE header (code section).

Etapas necessárias para que se initialize um PE header (code section):
Copy pedaços from "code "'s first to o PE header's code section's name's whereabouts por 6.
Coloque o code zona's length into o PE header's code section's sizeinbytes.
Coloque o code zona's base into o PE header's code section's addressinmemory.
Coloque o code zona's length into o PE header's code section's sizeinfile.
Coloque o code zona's base into o PE header's code section's addressinfile.
Coloque -536870880 [$E0000020] into o PE header's code section's characteristics. \ executable, readable, writable, code object

Etapas necessárias para que se initialize um PE header (data section):
Copy pedaços from "data "'s first to o PE header's data section's name's whereabouts por 6.
Coloque o zona de dados's length into o PE header's data section's sizeinbytes.
Coloque o zona de dados's base into o PE header's data section's addressinmemory.
Coloque o zona de dados's length into o PE header's data section's sizeinfile.
Coloque o zona de dados's base into o PE header's data section's addressinfile.
Coloque -1073741760 [$C0000040] into o PE header's data section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um PE header (directories):
Coloque 16 [$00000010] into o PE header's numberofdirectories.
Coloque o import zona's base into o PE header's imagedirectoryentryimportaddress.
Coloque o import zona's length into o PE header's imagedirectoryentryimportsize.

Etapas necessárias para que se initialize um PE header (import section):
Copy pedaços from "idata "'s first to o PE header's idata section's name's whereabouts por 6.
Coloque o import zona's length into o PE header's idata section's sizeinbytes.
Coloque o import zona's base into o PE header's idata section's addressinmemory.
Coloque o import zona's length into o PE header's idata section's sizeinfile.
Coloque o import zona's base into o PE header's idata section's addressinfile.
Coloque -1073741760 [$C0000040] into o PE header's idata section's characteristics. \ initialized, readable, writable

Etapas necessárias para que se initialize um PE header (optional header):
Coloque 267 [$010B] into o PE header's magicnumber.
Coloque o code zona's length into o PE header's sizeofcodeinfile.
Coloque o zona de dados's length into o PE header's sizeofinitializeddatainfile.
Coloque 0 into o PE header's sizeofuninitializeddatainfile.
Encontre uma routine usando "~initialize before run e run e finalize after run" e o catálogo geral de rotinas.
Se a routine for inexistente, abort with "Erro interno: não achei a tarefa de inicialização"; exit.
Coloque o routine's address menos o image base into o PE header's addressofentrypointinmemory.
Coloque o code zona's base into o PE header's addressofcodeinmemory.
Coloque o zona de dados's base into o PE header's addressofinitializeddatainmemory.
Coloque o image base into o PE header's imagebase.
Coloque 4096 [$00001000] into o PE header's memoryalignment.
Coloque 4096 [$00001000] into o PE header's filealignment.
Coloque 0 into o PE header's reserved.
Coloque o compilador's exe size into o PE header's sizeofimageinmemory.
Coloque 4096 [section base] into o PE header's sizeofallheadersinfile.
Coloque 0 into o PE header's checksum.
Coloque 0 into o PE header's dllcharacteristics.
Coloque 1048576 [$00100000] into o PE header's maxstack.
Coloque 16384 [$00004000] into o PE header's minstack.
Coloque 1048576 [$00100000] into o PE header's maxheap.
Coloque 16384 [$00004000] into o PE header's minheap.
Coloque 0 into o PE header's loaderalarmes.

Etapas necessárias para que se initialize um PE header (standard header):
Coloque 17744 [$00004550] into o PE header's signature.
Coloque 332 [$014C] into o PE header's machinetype.
Coloque 3 [$0003] into o PE header's numberofsections.
Coloque 0 into o PE header's timestamp.
Coloque 0 into o PE header's pointertosymboltable.
Coloque 0 into o PE header's numberofsymbols.
Coloque 224 [$00E0] into o PE header's sizeofoptionalheaderinbytes.
Coloque 33166 [$818E] into o PE header's characteristics.

Etapas necessárias para que se initialize um PE header (version information):
Coloque 0 into o PE header's majorlinkerversion.
Coloque 0 into o PE header's minorlinkerversion.
Coloque 4 [$0004] into o PE header's osmajorversion.
Coloque 0 [$0000] into o PE header's osminorversion.
Coloque 0 into o PE header's usermajorversion.
Coloque 0 into o PE header's userminorversion.
Coloque 4 [$0004] into o PE header's subsystemmajorversion.
Coloque 0 [$0000] into o PE header's subsystemminorversion.
Coloque 2 [$0002] into o PE header's subsystem.

The intel tag é uma tag igual a 11.

An intermediate é um local.

The jump false tag é uma tag igual a 12.

Etapas necessárias para que se link:
Round up zona sizes.
Initialize um DOS header.
Initialize um PE header.
Fill o compilador's exe with o null pedaço usando o compilador's exe size.
Blurt o DOS header into o compilador's exe.
Blurt o PE header into o compilador's exe.
Blurt o imports into o compilador's exe.
Blurt o globals into o compilador's exe.
Blurt o literals into o compilador's exe.
Blurt o routines into o compilador's exe.

The linking cronômetro é um cronômetro.

Etapas necessárias para que se list:
Limpe o compilador's listing.
List a mensagem de erro deste compilador in o compilador's listing.
List o types under "TYPES:" in o compilador's listing.
List o globals under "GLOBALS:" in o compilador's listing.
List o literals under "LITERALS:" in o compilador's listing.
List o routines under "ROUTINES:" in o compilador's listing.
List o catálogo de tipos under "TYPE INDEX:" in o compilador's listing.
List o catálogo de variáveis globais under "GLOBAL INDEX:" in o compilador's listing.
List o catálogo de variáveis hexadecimais under "LITERAL INDEX:" in o compilador's listing.
List o catálogo geral de rotinas under "ROUTINE INDEX:" in o compilador's listing.
List o catálogo de rotinas úteis under "catálogo de rotinas úteis:" in o compilador's listing.
List o imports under "IMPORTS:" in o compilador's listing.
List o source files under "SOURCE FILES:" in o compilador's listing.
List o cronômetros under "TIMERS:" in o compilador's listing.
Escreva o compilador's listing to o compilador's listing endereço completo.

Etapas necessárias para que se list um mensagem de erro in um trecho:
Se o mensagem de erro estiver em branco, cancele.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" to o trecho.
Advance o trecho (twice).
Posponha o mensagem de erro to o trecho.
Advance o trecho (twice).

Etapas necessárias para que se list um bucket in um trecho:
Se o bucket's refers estiverem vazio, cancele.
Posponha "/bucket" to o trecho (with separator).
Advance o trecho.
List o bucket's refers in o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns entries in um trecho:
Obtenha um entry from o entries.
Se o entry for inexistente, cancele.
List o entry in o trecho.
Repita.

Etapas necessárias para que se list um entry in um trecho:
Se o entry for inexistente, cancele.
Posponha "/entry" to o trecho (with separator).
Posponha o name desta entry to o trecho (with separator).
Posponha o address desta entry to o trecho (as hex with separator).
Advance o trecho.

Etapas necessárias para que se list um fragment in um trecho:
Posponha "/fragment" to o trecho (with separator).
Posponha o fragment's tag to o trecho (as um fragment tag string with separator).
Posponha o fragment's variable to o trecho (with separator).
Posponha o fragment's other variable to o trecho (with separator).
Posponha o fragment's routine to o trecho (with separator).
Posponha o fragment's entry to o trecho (with separator).
Posponha o fragment's número to o trecho (as hex with separator).
Posponha o fragment's address to o trecho (as hex with separator).
Convert o fragment's code to um texto dâ cifra binária.
Posponha o texto dâ cifra binária to o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns fragments in um trecho:
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
List o fragment in o trecho.
Repita.

Etapas necessárias para que se list um import in um trecho:
Se o import for inexistente, cancele.
Posponha "/import" to o trecho (with separator).
Posponha o import's name to o trecho (with separator).
Advance o trecho.
List as entries deste import in o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns imports in um trecho:
Obtenha um import from o imports.
Se o import for inexistente, cancele.
List o import in o trecho.
Repita.

Etapas necessárias para que se list alguns imports under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o imports estiverem vazio, cancele.
List o imports in o trecho.

Etapas necessárias para que se list um index in um trecho:
Posponha "/" then o index's used bucket contagem then " buckets" to o trecho (with separator).
Posponha o index's contagem then " refers" to o trecho (with separator).
Advance o trecho (twice).
Percorra.
Obtenha um bucket usando o index.
Se o bucket for inexistente, cancele.
List o bucket in o trecho.
Repita.

Etapas necessárias para que se list um index under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o index estiver vazio, cancele.
List o index in o trecho.

Etapas necessárias para que se list um refer in um trecho:
Se o refer for inexistente, cancele.
Posponha "/refer" to o trecho (with separator).
Posponha o refer's string to o trecho.
Se o refer's endereço de memória for inexistente, posponha "..." to o trecho.
Posponha "/" to o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns refers in um trecho:
Obtenha um refer from o refers.
Se o refer for inexistente, cancele.
List o refer in o trecho.
Repita.

Etapas necessárias para que se list uma routine in um trecho:
Se a routine for inexistente, cancele.
Posponha "/routine" to o trecho (with separator).
Posponha o routine's moniker to o trecho (with separator).
Posponha o routine's compiled alarme to o trecho (with separator).
Posponha o routine's callback alarme to o trecho (with separator).
Posponha o routine's decider alarme to o trecho (with separator).
Posponha o routine's function alarme to o trecho (with separator).
Posponha o routine's employs moniker to o trecho (with separator).
Posponha o routine's parameter size to o trecho (with separator).
Posponha o routine's local size to o trecho (with separator).
Posponha o routine's address to o trecho (as hex with separator).
Advance o trecho.
List o routine's parameters in o trecho.
List o routine's locals in o trecho.
List o routine's fragments in o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns routines in um trecho:
Obtenha uma routine from o routines.
Se a routine for inexistente, cancele.
List o routine in o trecho.
Repita.

Etapas necessárias para que se list alguns routines under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o routines estiverem vazio, cancele.
List o routines in o trecho.

Etapas necessárias para que se list um source file in um trecho:
Se o source file for inexistente, cancele.
Posponha "/source file" to o trecho (with separator).
Posponha o source file's endereço completo to o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns source files in um trecho:
Obtenha um source file from o source files.
Se o source file for inexistente, cancele.
List o source file in o trecho.
Repita.

Etapas necessárias para que se list alguns source files under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o source files estiverem vazio, cancele.
List o source files in o trecho.
Advance o trecho.

Etapas necessárias para que se list um cronômetro usando um string in um trecho:
Posponha "/timer" to o trecho (with separator).
Posponha o string to o trecho (with separator).
Posponha o cronômetro's string to o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list o cronômetros under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
List o loading cronômetro usando "loading" in o trecho.
List o scanning cronômetro usando "scanning" in o trecho.
List o resolving types cronômetro usando "resolving types" in o trecho.
List o resolving globals cronômetro usando "resolving globals" in o trecho.
List o compiling routine headers cronômetro usando "compiling routine headers" in o trecho.
List o calculating cronômetro usando "calculating" in o trecho.
List o adding built-in memory routines cronômetro usando "adding built-in memory routines" in o trecho.
List o indexing utilities cronômetro usando "indexing utilities" in o trecho.
List o compiling routine bodies cronômetro usando "compiling routine bodies" in o trecho.
List o adding built-in startup routine cronômetro usando "adding built-in startup routine" in o trecho.
List o offsetting cronômetro usando "offsetting" in o trecho.
List o addressing cronômetro usando "addressing" in o trecho.
List o transmogrifying cronômetro usando "transmogrifying" in o trecho.
List o linking cronômetro usando "linking" in o trecho.
List o writing cronômetro usando "writing" in o trecho.
List o compilador's cronômetro usando "total" in o trecho.
Advance o trecho.

Etapas necessárias para que se list um type in um trecho:
Se o type for inexistente, cancele.
Posponha "/type" to o trecho (with separator).
Posponha o name deste type to o trecho (with separator).
Posponha o plural name deste type to o trecho (with separator).
Posponha o type's length to o trecho (as hex with separator).
Posponha o type's base name to o trecho (with separator).
Posponha o type's base type to o trecho (with separator).
Posponha o type's target name to o trecho (with separator).
Posponha o target type deste type to o trecho (with separator).
Posponha o type's scale to o trecho (with separator).
Advance o trecho.
List o type's fields in o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns types in um trecho:
Obtenha um type from o types.
Se o type for inexistente, cancele.
List o type in o trecho.
Repita.

Etapas necessárias para que se list alguns types under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o types estiverem vazio, cancele.
List o types in o trecho.

Etapas necessárias para que se list uma variable in um trecho:
Se o variable for inexistente, cancele.
Posponha "/variable" to o trecho (with separator).
Posponha o variable's categoria to o trecho (with separator).
Posponha o variable's compiled alarme to o trecho (with separator).
Posponha o variable's name to o trecho (with separator).
Posponha o variable's nickname to o trecho (with separator).
Posponha o variable's type name to o trecho (with separator).
Posponha o variable's type to o trecho (with separator).
Posponha o variable's address [or offset] to o trecho (as hex with separator).
Posponha o variable's by-value alarme to o trecho (with separator).
Posponha o variable's contagem to o trecho (with separator).
Posponha o variable's reference alarme to o trecho (with separator).
Posponha o variable's redefinition target name to o trecho (with separator).
Posponha o variable's literal to o trecho (with separator).
Convert o variable's data to um texto dâ cifra binária.
Posponha o texto dâ cifra binária to o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns variables in um trecho:
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
List o variable in o trecho.
Repita.

Etapas necessárias para que se list alguns variables under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o variables estiverem vazio, cancele.
List o variables in o trecho.
Advance o trecho.

The catálogo de variáveis hexadecimais é um index.

An literal é uma variable.

The literals são alguns literals.

The load address tag é uma tag igual a 13.

The load eax tag é uma tag igual a 14.

An local é uma variable.

An locus é um endereço de memória du pedaço .

The loop tag é uma tag igual a 15.

An moniker é um string.

An monikette é uma coisa with
An string,
An type (reference),
An variable (reference),
\ por bubbling
An type atual (reference),
An subtexto atual.

Etapas necessárias para que se mova um percorredor (code rules - comment):
Avance o percorredor.
Se o percorredor's source estiver em branco, cancele.
Se o percorredor's source's first's target não for o return pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - glom):
Avance o percorredor.
Se o percorredor's source estiver em branco, cancele.
Se o percorredor está on any possessive, cancele.
Se o percorredor's source's first's target é any glom pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - mark):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules - noise):
Avance o percorredor.
Se o percorredor's source estiver em branco, cancele.
Se o percorredor's source's first's target é noise, repita.

Etapas necessárias para que se mova um percorredor (code rules - possessive):
Avance o percorredor.
Se o percorredor's source estiver em branco, cancele.
Se o percorredor's source starts with "s", avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules - qualifier):
Se o percorredor's source estiver em branco, cancele.
Se o percorredor's source's first's target for o return pedaço, pare.
Se o percorredor's source's first's target for o left-paren pedaço, adicione 1 to um contagem.
Se o percorredor's source's first's target for o right-paren pedaço, subtraia 1 from o contagem.
Avance o percorredor.
Se o contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - remark):
Se o percorredor's source estiver em branco, cancele.
Se o percorredor's source's first's target for o return pedaço, pare.
Se o percorredor's source's first's target for o left-bracket pedaço, adicione 1 to um contagem.
Se o percorredor's source's first's target for o right-bracket pedaço, subtraia 1 from o contagem.
Avance o percorredor.
Se o contagem for 0, pare.
Repita. 

Etapas necessárias para que se mova um percorredor (code rules - string):
Avance o percorredor.
Se o percorredor's source estiver em branco, cancele.
Se o percorredor's source's first's target for o return pedaço, cancele.
Se o percorredor estiver on any nested double-quote, avance o percorredor; repita.
Se o percorredor's source's first's target for o aspas duplas, avance o percorredor; exit.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - symbol):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules):
Position o token deste percorredor on o percorredor's source.
Se o percorredor's source estiver em branco, cancele.
Se o percorredor's source's first's target for noise, mova o percorredor (code rules - noise); exit.
Se o percorredor's source's first's target for o barra invertida, mova o percorredor (code rules - comment); exit.
Se o percorredor's source's first's target for o left-bracket pedaço, mova o percorredor (code rules - remark); exit.
Se o percorredor's source's first's target for o aspas duplas, mova o percorredor (code rules - string); exit.
Se o percorredor's source's first's target for o left-paren pedaço, mova o percorredor (code rules - qualifier); exit.
Se o percorredor's source's first's target for any mark, mova o percorredor (code rules - mark); exit.
Se o percorredor estiver on any possessive, mova o percorredor (code rules - possessive); exit.
Mova o percorredor (code rules - glom).

Etapas necessárias para que se mova um percorredor (compilador rules):
Se o alarme de alerta deste compilador estiver ativo, limpe o percorredor's token; exit.
Mova o percorredor returning um erro string (code rules).
Se o erro string não estiver em branco, abort with o erro string e o percorredor's token's first; exit.
\Se o token deste percorredor for "del", unbump o percorredor; exit. \ Spanish contraction "del"; fudged to "de l", short por "de el"
\Se o token deste percorredor for "al", unbump o percorredor; exit. \ Spanish contraction "al"; fudged to "a l", short por "a el"
Se o token deste percorredor estiver em branco, cancele.
Se o percorredor's token's first's target for noise, repita.
Se o percorredor's token's first's target for o barra invertida, repita.
Se o percorredor's token's first's target for o left-bracket pedaço, repita.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate qualifier):
Se o percorredor's token's length for menor du que 2, coloque "Qualificadores devem terminar com parêntese ')'." into o erro string; exit.
Se o percorredor's token's last's target não for o right-paren pedaço, coloque "Qualificadores precisam terminar com um parêntese ')'." into o erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate remark):
Se o percorredor's token's length for menor du que 2, coloque "Observações devem terminar com um colchete ']'." into o erro string; exit.
Se o percorredor's token's last's target não for o right-bracket pedaço, coloque "Observações precisam terminar com um colchete ']'." into o erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate string):
Se o percorredor's token's length for menor du que 2, coloque "Textos precisam terminar com aspas '""'." into o erro string; exit.
Se o percorredor's token's last's target não for o aspas duplas, coloque "Textos tem que terminar com aspas '""'." into o erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules):
Limpe o erro string.
Mova o percorredor (code rules).
Se o token deste percorredor estiver em branco, cancele.
Se o percorredor's token's first's target for o left-bracket pedaço, mova o percorredor returning o erro string (code rules - validate remark); exit.
Se o percorredor's token's first's target for o aspas duplas, mova o percorredor returning o erro string (code rules - validate string); exit.
Se o percorredor's token's first's target for o left-paren pedaço, mova o percorredor returning o erro string (code rules - validate qualifier); exit.

An parte dâ cifra binária é um subtexto.

An nickname é um name.

The not tag é uma tag igual a 16.

Etapas necessárias para que se offset o locals in uma routine:
Se a routine for inexistente, cancele.
Se o routine's compiled alarme não estiver ativo, cancele.
Limpe o routine's local size.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um local from o routine's locals.
Se o local for inexistente, cancele.
Se o local's previous não for inexistente, coloque o local's previous' offset into o local's offset.
Coloque o local's type's length into um length.
Se o local's categoria for "scratch", coloque um endereço de memória's magnitude into o length.
Round o length up to o nearest multiple of 4.
Subtraia o length from o local's offset.
Adicione o length to o routine's local size.
Repita.

Etapas necessárias para que se offset o locals in alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from o routines.
Se a routine for inexistente, cancele.
Offset o locals in o routine.
Repita.

Etapas necessárias para que se offset o parameters in uma routine:
Se a routine for inexistente, cancele.
Se o routine's compiled alarme não estiver ativo, cancele.
Limpe o routine's parameter size.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um parameter from o routine's parameters.
Se o parameter for inexistente, cancele.
Se o routine's callback alarme estiver ativo, acione o parameter's by-value alarme.
Se o parameter's previous for inexistente, coloque 8 into o parameter's offset. \ skip o return address e saved ebp
Se o parameter's previous não for inexistente, coloque o parameter's previous' offset mais 4 into o parameter's offset. \ all parameters são 4 endereço de memória du pedaço s ou 4 pedaço values por callbacks
Adicione 4 to o routine's parameter size.
Repita.

Etapas necessárias para que se offset o parameters in alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from o routines.
Se a routine for inexistente, cancele.
Offset o parameters in o routine.
Repita.

The offsetting cronômetro é um cronômetro.

An parameter é uma variable.

An partial moniker é um moniker.

An PE header é um conjunto with
An número called signature,
An wyrd called machinetype,
An wyrd called numberofsections,
An número called timestamp,
An número called pointertosymboltable,
An número called numberofsymbols,
An wyrd called sizeofoptionalheaderinbytes,
An wyrd called characteristics,
\ optional header
An wyrd called magicnumber,
An pedaço called majorlinkerversion,
An pedaço called minorlinkerversion,
An número called sizeofcodeinfile,
An número called sizeofinitializeddatainfile,
An número called sizeofuninitializeddatainfile,
An número called addressofentrypointinmemory,
An número called addressofcodeinmemory,
An número called addressofinitializeddatainmemory,
An número called imagebase,
An número called memoryalignment,
An número called filealignment,
An wyrd called osmajorversion,
An wyrd called osminorversion,
An wyrd called usermajorversion,
An wyrd called userminorversion,
An wyrd called subsystemmajorversion,
An wyrd called subsystemminorversion,
An número called reserved,
An número called sizeofimageinmemory,
An número called sizeofallheadersinfile,
An número called checksum,
An wyrd called subsystem,
An wyrd called dllcharacteristics,
An número called maxstack,
An número called minstack,
An número called maxheap,
An número called minheap,
An número called loaderalarmes,
\ directories (16 address e size pairs)
An número called numberofdirectories,
8 pedaços called directory0,
An número called imagedirectoryentryimportaddress,
An número called imagedirectoryentryimportsize,
112 pedaços called directories2-15,
An PE section header called idata section,
An PE section header called data section,
An PE section header called code section.

An PE section header é um conjunto with
8 pedaços called name,
An número called sizeinbytes,
An número called addressinmemory,
An número called sizeinfile,
An número called addressinfile,
12 pedaços called reserved,
An número called characteristics.

An phrase é um string.

\Etapas necessárias para que se determine se um string looks like English:
\Load o lexicon.
\Se o lexicon for inexistente, mostre erro "I can't find any lecksicon."; diga não.
\Se o string estiver em branco, diga não.
\Lance um subtexto on o string.
\Coloque o last deste subtexto into o first deste subtexto.
\Percorra.
\Se o first deste subtexto é o string's first, pare.
\Se o subtexto's first's target for o space pedaço, adicione 1 to o first deste subtexto; break.
\Subtraia 1 from o first deste subtexto.
\Repita.
\Se o subtexto estiver in o lexicon's index, diga sim.
\Diga não.

Etapas necessárias para que se pluralize um string (portuguese rules):
Lance um percorredor on o string.
Percorra.
Mova o percorredor (spell checking rules).
Se o token deste percorredor estiver em branco, pare.
Se um plural string não estiver em branco, posponha " " to o plural string.
Posponha o token deste percorredor to o plural string.
Se o token deste percorredor for "de", acione um alarme; repita.
Se o alarme não estiver ativo, pluralize o plural string (portuguese rules - each palavra).
Repita.
Coloque o plural string into o string.

Etapas necessárias para que se pluralize um string (portuguese rules - each palavra):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se o string for "cidadão", posponha "s" to o string; exit.
Se o string for "irmão", posponha "s" to o string; exit.
Se o string for "cristão", posponha "s" to o string; exit.
Se o string for "refrão", posponha "s" to o string; exit.
Se o string for "pão", remove o last pedaço from o string; posponha "es" to o string; exit.
Se o string for "capitão", remove o last pedaço from o string; posponha "es" to o string; exit.
Se o string for "alemão", remove o last pedaço from o string; posponha "es" to o string; exit.
Se o string for "charlatão", remove o last pedaço from o string; posponha "es" to o string; exit.
Se o string for "caráter", coloque "carateres" into o string; exit.
Se o string for "júnior", coloque "juniores" into o string; exit.
Se o string for "sênior", coloque "seniores" into o string; exit.
Se o string for "mão", coloque "mãos" into o string; exit.
Se o string for "são", coloque "sãos" into o string; exit.
\# advérbios principais
Se o string for "muito", cancele.
Se o string for "pouco", cancele.
Se o string for "mais", cancele.
Se o string for "menos", cancele.
Se o string for "bastante", cancele.
Se o string for "quase", cancele.
Se o string for "demais", cancele.
Se o string for "bem", cancele.
Se o string for "deveras", cancele.
Se o string for "mal", cancele.
Se o string for "melhor", cancele.
Se o string for "pior", cancele.
\# palavras terminadas com "ão"
Se o string ends with "ão", pluralize o string (portuguese rules - ending palavras with "ão"); exit.
\# palavras terminadas com "l"
Se o string ends with "l", pluralize o string (portuguese rules - ending palavras with "l"); exit.
\# palavra terminadas com "m"
Se o string ends with "m", remove o last pedaço from o string; posponha "ns" to o string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se o string ends with "n", posponha "es" to o string; exit.
\# palavras terminadas com "r"
Se o string ends with "r", pluralize o string (portuguese rules - ending palavras with "r"); exit.
\# palavras terminadas com "s"
Se o string ends with "s", pluralize o string (portuguese rules - ending palavras with "s"); exit.
\# palavra terminadas com "x"
Se o string ends with "x", cancele.
\# palavras terminadas com "z"
Se o string ends with "z", pluralize o string (portuguese rules - ending palavras with "z"); exit.
\# regra padrão
Posponha "s" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "ão"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "s" to o string; exit.
\# regra padrão
Remove o last número doiss from o string.
Posponha "ões" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "l"):
\# palavras terminadas com "al"
Se o string ends with "al", remove o last pedaço from o string; posponha "is" to o string; exit.
\# palavras terminadas com "el"
Se o string ends with "el", pluralize o string (portuguese rules - ending palavras with "el"); exit.
\# palavras terminadas com "il"
Se o string ends with "il", pluralize o string (portuguese rules - ending palavras with "il"); exit.
\# palavras terminadas com "ol"
Se o string ends with "ol", pluralize o string (portuguese rules - ending palavras with "ol"); exit.
\# palavras terminadas com "ul"
Se o string ends with "ul", remove o last pedaço from o string; posponha "is" to o string; exit.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "el"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last pedaço from o string; posponha "is" to o string; exit.
Remove o last número doiss from o string.
Posponha "éis" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "il"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last número doiss from o string; posponha "eis" to o string; exit.
Remove o last pedaço from o string.
Posponha "s" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "ol"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last pedaço from o string; posponha "is" to o string; exit.
Remove o last número doiss from o string.
Posponha "óis" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "r"):
\# hiatos acentuados
\Se o string ends with "aír", posponha "es" to o string; exit.
\Se o string ends with "aúr", posponha "es" to o string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se o string ends with "ár", remove o last número doiss from o string; posponha "ares" to o string; exit.
\Se o string ends with "âr", remove o last número doiss from o string; posponha "ares" to o string; exit.
\Se o string ends with "ér", remove o last número doiss from o string; posponha "eres" to o string; exit.
\Se o string ends with "êr", remove o last número doiss from o string; posponha "eres" to o string; exit.
\Se o string ends with "ír", remove o last número doiss from o string; posponha "ires" to o string; exit.
\Se o string ends with "ór", remove o last número doiss from o string; posponha "ores" to o string; exit.
\Se o string ends with "ôr", remove o last número doiss from o string; posponha "ores" to o string; exit.
\Se o string ends with "úr", remove o last número doiss from o string; posponha "ures" to o string; exit.
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "es" to o string; exit.
\# hiatos
Se o string ends with "air", remove o last número doiss from o string; posponha "íres" to o string; exit.
Se o string ends with "aur", remove o last número doiss from o string; posponha "úres" to o string; exit.
\# regra padrão
Posponha "es" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se o string ends with "as", cancele.
Se o string ends with "es", cancele.
Se o string ends with "os", cancele.
\# hiatos acentuados
Se o string ends with "aís", posponha "es" to o string; exit.
Se o string ends with "aús", posponha "es" to o string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se o string ends with "ás", remove o last número doiss from o string; posponha "ases" to o string; exit.
Se o string ends with "âs", remove o last número doiss from o string; posponha "ases" to o string; exit.
Se o string ends with "és", remove o last número doiss from o string; posponha "eses" to o string; exit.
Se o string ends with "ês", remove o last número doiss from o string; posponha "eses" to o string; exit.
Se o string ends with "ís", remove o last número doiss from o string; posponha "ises" to o string; exit.
Se o string ends with "ós", remove o last número doiss from o string; posponha "oses" to o string; exit.
Se o string ends with "ôs", remove o last número doiss from o string; posponha "oses" to o string; exit.
Se o string ends with "ús", remove o last número doiss from o string; posponha "uses" to o string; exit.
\# palavras terminadas com "is", "us"
Se o string ends with "is", pluralize o string (portuguese rules - ending palavras with "is/us"); exit.
Se o string ends with "us", pluralize o string (portuguese rules - ending palavras with "is/us"); exit.
\# regra padrão
Posponha "es" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "is/us"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, cancele.
\# hiatos
Se o string ends with "ais", remove o last número doiss from o string; posponha "íses" to o string; exit.
Se o string ends with "aus", remove o last número doiss from o string; posponha "úses" to o string; exit.
\# regra padrão
Posponha "es" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "z"):
\# hiatos acentuados
Se o string ends with "aíz", posponha "es" to o string; exit.
Se o string ends with "aúz", posponha "es" to o string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se o string ends with "áz", remove o last número doiss from o string; posponha "azes" to o string; exit.
Se o string ends with "âz", remove o last número doiss from o string; posponha "azes" to o string; exit.
Se o string ends with "éz", remove o last número doiss from o string; posponha "ezes" to o string; exit.
Se o string ends with "êz", remove o last número doiss from o string; posponha "ezes" to o string; exit.
Se o string ends with "íz", remove o last número doiss from o string; posponha "izes" to o string; exit.
Se o string ends with "óz", remove o last número doiss from o string; posponha "ozes" to o string; exit.
Se o string ends with "ôz", remove o last número doiss from o string; posponha "ozes" to o string; exit.
Se o string ends with "úz", remove o last número doiss from o string; posponha "uzes" to o string; exit.
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "es" to o string; exit.
\# hiatos
Se o string ends with "aiz", remove o last número doiss from o string; posponha "ízes" to o string; exit.
Se o string ends with "auz", remove o last número doiss from o string; posponha "úzes" to o string; exit.
\# regra padrão
Posponha "es" to o string.

Etapas necessárias para que se pluralize um string (english rules);
Etapas necessárias para que se pluralize um string:
\ nouns only
Se o string for "alumnus", coloque "alumni" into o string; exit.
Se o string for "auto", coloque "autos" into o string; exit.
Se o string for "botão", coloque "botões" into o string; exit.
Se o string for "cello", coloque "cellos" into o string; exit.
Se o string for "dwarf", coloque "dwarfs" into o string; exit.
Se o string for "foot", coloque "feet" into o string; exit.
Se o string for "forma", coloque "formas" into o string; exit.
Se o string for "genus", coloque "genera" into o string; exit.
Se o string for "goose", coloque "geese" into o string; exit.
Se o string for "hippo", coloque "hippos" into o string; exit.
Se o string for "louse", coloque "lice" into o string; exit.
Se o string for "memo", coloque "memos" into o string; exit.
Se o string for "mouse", coloque "mice" into o string; exit.
Se o string for "ox", coloque "oxen" into o string; exit.
Se o string for "phenomenon", coloque "phenomena" into o string; exit.
Se o string for "photo", coloque "photos" into o string; exit.
Se o string for "phylum", coloque "phyla" into o string; exit.
Se o string for "piano", coloque "pianos" into o string; exit.
Se o string for "pimento", coloque "pimentos" into o string; exit.
Se o string for "pro", coloque "pros" into o string; exit.
Se o string for "proof", coloque "proofs" into o string; exit.
Se o string for "radius", coloque "radii" into o string; exit.
Se o string for "rhinoceros", coloque "rhinoceri" into o string; exit.
Se o string for "roof", coloque "roofs" into o string; exit.
Se o string for "solo", coloque "solos" into o string; exit.
Se o string for "soprano", coloque "sopranos" into o string; exit.
Se o string for "staff", coloque "staffs" into o string; exit.
Se o string for "tooth", coloque "teeth" into o string; exit.
Se o string for "torus", coloque "tori" into o string; exit.
Se o string for "turf", coloque "turfs" into o string; exit.
Se o string for "virus", coloque "viruses" into o string; exit.
Se o string ends with "sh", posponha "es" to o string; exit.
Se o string ends with "ch", posponha "es" to o string; exit.
Se o string ends with "man", remove o last número doiss from o string; posponha "en" to o string; exit.
Se o string ends with "child", posponha "ren" to o string; exit.
Se o string ends with "ex", remove o last número doiss from o string; posponha "ices" to o string; exit. \ ou adicione ES
Se o string ends with "fe", remove o last número doiss from o string; posponha "ves" to o string; exit.
Se o string ends with "is", remove o last número doiss from o string; posponha "es" to o string; exit.
Se o string ends with "ix", remove o last número doiss from o string; posponha "ices" to o string; exit. \ ou adicione ES
Se o string ends with "ma", posponha "ta" to o string; exit. \ ou adicione S
Se o string ends with any consonant e "y", remove o last pedaço from o string; posponha "ies" to o string; exit.
Se o string ends with any vowel e "o", posponha "s" to o string; exit.
Se o string ends with any vowel e "y", posponha "s" to o string; exit.
Se o string ends with "f", remove o last pedaço from o string; posponha "ves" to o string; exit.
Se o string ends with "s", posponha "es" to o string; exit.
Se o string ends with "x", posponha "es" to o string; exit.
Se o string ends with "z", posponha "es" to o string; exit.
Posponha "s" to o string.

The prolog tag é uma tag igual a 17.

An prototype string é um conjunto with um first endereço de memória du pedaço e um last endereço de memória du pedaço .

The push address tag é uma tag igual a 18.

The push value tag é uma tag igual a 19.

Etapas necessárias para que se coloque o compilador's exe endereço completo into um endereço completo:
Extract um designador from o compilador's endereço dâ pasta.
Remove any trailing barra invertida from o designador.
Coloque o compilador's endereço dâ pasta then o designador then ".exe" into o endereço completo.

Etapas necessárias para que se coloque o compilador's exe size into um size:
Coloque 4096 [section base] into o size.
Adicione o import zona's size to o size.
Adicione o zona de dados's size to o size.
Adicione o code zona's size to o size.

Etapas necessárias para que se coloque o compilador's listing endereço completo into um endereço completo:
Extract um designador from o compilador's endereço dâ pasta.
Remove any trailing barra invertida from o designador.
Coloque o compilador's endereço dâ pasta then o designador then ".lst" into o endereço completo.

Etapas necessárias para que se coloque um term into another term:
Coloque o term's variable into o other term's variable.
Coloque o term's phrase into o other term's phrase.

Etapas necessárias para que se load um source file:
Se o source file for inexistente, cancele.
\Load o source file's endereço completo into o source file's trecho.
\Se o i/o erro não estiver em branco, abort with "Não foi possível carregar o arquivo: '" then o source file's endereço completo then "'."; exit.
Load o source file's endereço completo into um string.
Se o i/o erro não estiver em branco, abort with "Não foi possível carregar o arquivo '" then o source file's endereço completo then "'."; exit.
Parse the string to the source file's trecho (portuguese contractions e synonyms rules).



Etapas necessárias para que se load alguns source files:
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um item from o compilador's endereço dâ pasta.
Se o item não for found, pare.
Se o item's categoria não for "file", repita.
Se o item's extensão não estiver em branco, repita.
Se o item looks reamish, repita.
Adicione um source file to o source files usando o item's endereço completo.
Load o source file.
Repita.

The loading cronômetro é um cronômetro.

Etapas necessárias para que se parse um string to another string (portuguese contractions e synonyms rules):
Limpe o other string.
Limpe um third string.
Lance um percorredor on o string.
Percorra.
Se o percorredor's source estiver em branco, cancele.
Position o token deste percorredor on o percorredor's source.
Mova o percorredor (code rules).
Se o percorredor's token's first's target não for any glom pedaço, posponha o token deste percorredor to o other string; repita.
Posponha o token deste percorredor to o other string giving o third string (portuguese contractions e synonyms rules).
Coloque o token deste percorredor into o third string.
Repita.

Etapas necessárias para que se reduce alguns monikettes por utility use:
Obtenha um monikette from o monikettes.
Se o monikette for inexistente, cancele.
Se o monikette's type for inexistente, repita.
Reduce o monikette's type to um type por utility use.
Se o type não for inexistente, coloque o type into o monikette's type.
Repita.

Etapas necessárias para que se reduce um type to another type por utility use:
Coloque o type into o other type.
Percorra.
Se o other type for inexistente, cancele.
Se o other type's name for "texto hexadecimal", cancele.
Se o other type's name for "string", cancele.
Se o other type's name for "número", cancele.
Se o other type's name for "endereço de memória", cancele.
Se o other type's name for "coisa", esvazie o other type; exit.
\PAL
\Se o other type's name for "elemento", esvazie o other type; exit.
Se o other type's base type for o other type, esvazie o other type; exit.
Coloque o other type's base type into o other type.
Repita.

Etapas necessárias para que se catalogue novamente o catálogo de rotinas úteis:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um bucket usando o catálogo de rotinas úteis.
Se o bucket for inexistente, cancele.
Se o bucket's refers estiverem vazio, repita.
Catalogue novamente o catálogo de rotinas úteis usando o bucket's refers.
Repita.

Etapas necessárias para que se catalogue novamente o catálogo de rotinas úteis usando alguns refers:
Obtenha um refer from o refers.
Se o refer for inexistente, cancele.
Coloque o refer's endereço de memória into uma routine.
Se a routine for inexistente, abort with "Erro interno na função: index o utility routines usando alguns refers"; exit.
Copy o routine's monikettes into alguns monikettes.
Reduce o monikettes por utility use.
Catalogue o routine usando o monikettes e o catálogo geral de rotinas.
Destroy o monikettes.
Repita.

Etapas necessárias para que se remove any negatives from alguns monikettes returning um alarme:
Desative o alarme.
Swap o monikettes with alguns other monikettes.
Percorra.
Coloque o other monikettes' first into um monikette.
Se o monikette for inexistente, cancele.
Remove o monikette from o other monikettes.
\PAL
Se o monikette's string for "não", reverse o alarme; destroy o monikette; repita.
Se o monikette's string for "nada", reverse o alarme; destroy o monikette; repita.
\CAL
Se o monikette's string for "not", reverse o alarme; destroy o monikette; repita.
Se o monikette's string for "nada", reverse o alarme; destroy o monikette; repita.
Posponha o monikette to o monikettes.
Se o monikette's string for "can't", reverse o alarme; coloque "can" into o monikette's string; repita.
Se o monikette's string for "cannot", reverse o alarme; coloque "can" into o monikette's string; repita.
Se o monikette's string for "nothing", reverse o alarme; coloque "something" into o monikette's string; repita.
Se o monikette's string for "won't", reverse o alarme; coloque "will" into o monikette's string; repita.
Se o monikette's string ends with "n't", reverse o alarme; remove trailing pedaços from o monikette's string usando 3; repita.
Repita.

The repeat tag é uma tag igual a 21.

Etapas necessárias para que se resolva um field:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o field for inexistente, cancele.
Resolva o field como uma variable.
Se o field's nickname não for any valid field name, limpe o field's nickname.
Se o name deste field não for any valid field name, abort with "'" then o name deste field then "' é um field name inválido." e o field's locus; exit.

Etapas necessárias para que se resolva um global:
Se o global for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o global's global body não estiver em branco, resolva o global (compile body).
Se o global's type name estiver em branco, abort with "Tipo inválido: '" then o global's name then "' . O tipo da variável global está vazio." e o global's locus; exit.
Resolva o global como uma variable.

Etapas necessárias para que se resolva um global (compile body):
Se o global for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor on o global's global body.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any literal, abort with "Erro de tipo. O tipo: '" then o token deste percorredor then "' tem que ser do tipo literal." e o percorredor; exit.
Compile um literal usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não estiver em branco, abort with "Acho que era bom colocar um ponto por aqui, né?" e o percorredor; exit.
Se o global's type name estiver em branco, coloque o literal's type's name into o global's type name.
Coloque o literal into o global's literal.
Catalogue o literal.

Etapas necessárias para que se resolva alguns globals:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Resolva o global.
Repita.

Etapas necessárias para que se resolva um type (base type):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o type's base type não for inexistente, cancele.
Encontre o type's base type usando o type's base name e o catálogo de tipos.
Se o type's base type for inexistente, abort with "Base type inválido:'" then o type's base name then "'." e o type's locus; exit.
Ligue o type's cooking alarme.
Se o type's base type's cooking alarme estiver ativo, abort with "Definição recursiva com '" then o type's base name then "'." e o type's locus; exit.
Resolva o type's base type (base type).
Desative o type's cooking alarme.

Etapas necessárias para que se resolva um type (expand coisa):
\ type's base type não for resolved yet
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o type's base type não for inexistente, cancele.
Se o name deste type for "coisa", cancele.
\Se o name deste type for "elemento", cancele.
Se o type não puder ser reduzido para "coisa" using o base name, cancele.
Encontre um base type usando o type's base name e o catálogo de tipos.
\ adicione coisa conjunto - o número of secret fields é hard coded in two places: search por "du que 4" \ was 6
Coloque o name deste type then " conjunto" into um name.
Coloque o name deste type then " conjuntos" into um plural name.
Coloque o base type's name then " conjunto" into um base name.
Adicione um conjunto type to o types usando o name e o plural name e o base name.
Adicione um field to o conjunto type's fields usando "next " then o name deste type e "next" e o name deste type e o alarme de ignição.
\PAL
Adicione um portuguese field to o conjunto type's fields usando "seguinte " then o name deste type e "seguinte" e o name deste type e o alarme de ignição.
Coloque "next " then o name deste type into o portuguese field's redefinition target name.
\Adicione um portuguese reverse field to o conjunto type's fields usando o name deste type then " seguinte" e "seguinte" e o name deste type e o alarme de ignição.
\Coloque "next " then o name deste type into o portuguese reverse field's redefinition target name.
Adicione another field to o conjunto type's fields usando "previous " then o name deste type e "previous" e o name deste type e o alarme de ignição.
\Adicione another portuguese field to o conjunto type's fields usando "anterior " then o name deste type e "anterior" e o name deste type e o alarme de ignição.
\Coloque "previous " then o name deste type into o other portuguese field's redefinition target name.
Adicione another portuguese reverse field to o conjunto type's fields usando o name deste type then " anterior" e "anterior" e o name deste type e o alarme de ignição.
Coloque "previous " then o name deste type into o other portuguese reverse field's redefinition target name.
Se o type's fields não estiverem vazio, posponha o type's fields to o conjunto type's fields.
Catalogue o conjunto type.
\ fix up original type to look like um endereço de memória
Coloque o name deste conjunto type into o target name deste type.
\ adicione chain type
Adicione um chain type to o types usando o plural name deste type e "" e o plural name deste base type.
Adicione um third field to o chain type's fields usando "first " then o name deste type e "first" e o name deste type e o alarme de ignição.
Adicione um third portuguese field to o chain type's fields usando "primeiro " then o name deste type e "primeiro" e o name deste type e o alarme de ignição.
Coloque "first " then o name deste type into o third portuguese field's redefinition target name.
Adicione um third feminine portuguese field to o chain type's fields usando "primeira " then o name deste type e "primeira" e o name deste type e o alarme de ignição.
Coloque "first " then o name deste type into o third feminine portuguese field's redefinition target name.
Adicione um fourth field to o chain type's fields usando "last " then o name deste type e "last" e o name deste type e o alarme de ignição.
Adicione um fourth portuguese field to o chain type's fields usando "último " then o name deste type e "último" e o name deste type e o alarme de ignição.
Coloque "last " then o name deste type into o fourth portuguese field's redefinition target name.
Adicione um fourth portuguese feminine field to o chain type's fields usando "última " then o name deste type e "última" e o name deste type e o alarme de ignição.
Coloque "last " then o name deste type into o fourth portuguese feminine field's redefinition target name.
Catalogue o chain type.

Etapas necessárias para que se resolva um type (registro de plurais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o plural name deste type estiver em branco, cancele.
Se o type puder ser reduzido para "coisa" using o base name, cancele.
Catalogue o type usando o plural name deste type.

Etapas necessárias para que se resolva um type (optional info - endereço de memória):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o target type deste type não for inexistente, cancele.
Se o type's target name estiver em branco, coloque o type's base type's target type into o type's target type; exit.
Encontre o target type deste type usando o type's target name e o catálogo de tipos.
Se o target type deste type for inexistente, abort with "Não sei bem pra que coisa você está pointing at." e o type's locus; exit.

Etapas necessárias para que se resolva um type (optional info - conjunto):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type's fields estiverem vazio, copy o type's base type's fields into o type's fields; exit.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from o type's fields (backwards).
Se o field for inexistente, pare.
Se o field é duplicated in o type's fields, abort with "O campo '" then o name deste field then "' está definido mais de uma vez." e o field's locus; exit.
Resolva o field.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o field's type's cooking alarme estiver ativo, abort with "Recursive definition no: '" then o field's type's name then "'." e o field's locus; exit.
Resolva o type deste field (optional info). \ de novo
Se o reference alarme deste field não estiver ativo, repita.
Se o type deste field não puder ser reduzido para "endereço de memória", abort with "Não entendi o parâmetro '(reference)' nesse campo '" then o name deste field then "'..." e o field's locus; exit.
Repita.
Eliminate duplicate nicknames from o type's fields.
Se o type não puder ser reduzido para "coisa conjunto", cancele.
Se o type's fields' contagem for maior du que 4, cancele. \ already copied? was 2 por next e prev, now 6 to included Spanish redefiniions
Copy o type's base type's fields into o type's fields (data fields only).

Etapas necessárias para que se resolva um type (optional info - scale):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o type's base type into um base type.
Se o type's scale for 0, coloque o type's base type's scale into o type's scale; exit.
Se o base type's scale for 0, cancele.
Multiplique o type's scale por o base type's scale.
Coloque o base type's base type into o type's base type.

Etapas necessárias para que se resolva um type (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o type's optional info resolved alarme estiver ativo, cancele.
Se o type's base type for o type, cancele. \ por built in types
Check por invalid optional info on o type.
Ligue o type's cooking alarme.
Resolva o type's base type (optional info).
Se o type puder ser reduzido para "endereço de memória", resolva o type (optional info - endereço de memória).
Se o type puder ser reduzido para "conjunto", resolva o type (optional info - conjunto). \ mudar aqui
Se o type puder ser reduzido para "número", resolva o type (optional info - scale).
Desative o type's cooking alarme.
Ligue o type's optional info resolved alarme.

Etapas necessárias para que se resolva alguns types (base types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (base type).
Repita.

Etapas necessárias para que se resolva alguns types (expand coisas):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (expand coisa).
Repita.

Etapas necessárias para que se resolva alguns types (registro de plurais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (registro de plurais).
Repita.

Etapas necessárias para que se resolva alguns types (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (optional info).
Repita.

Etapas necessárias para que se resolva uma variable:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Se o variable's type não for inexistente, cancele.
Se o variable's type name não estiver em branco, resolva o variable (explicit type name); exit.
Encontre o variable's type e o variable's nickname usando o variable's name.
Se o variable's type não for inexistente, coloque o variable's type's name into o variable's type name; exit.
Abort with "Não achei o tipo da variável '" then o variable's name then "'." e o variable's locus.

Etapas necessárias para que se resolva uma variable (explicit type name):
Encontre o variable's type usando o variable's type name e o catálogo de tipos.
Se o variable's type for inexistente, abort with "Não achei o nome do tipo da variável '" then o variable's type name then "'." e o variable's locus; exit.

The resolving globals cronômetro é um cronômetro.

The resolving types cronômetro é um cronômetro.

Etapas necessárias para que se round up zona sizes:
Coloque o import zona's length into o import zona's size.
Round o import zona's size up to o nearest multiple of 4096.
Coloque o zona de dados's length into o zona de dados's size.
Round o zona de dados's size up to o nearest multiple of 4096.
Coloque o code zona's length into o code zona's size.
Round o code zona's size up to o nearest multiple of 4096.

The routine address tag é uma tag igual a 22.

An instruções é um subtexto.

An routine header é um subtexto.

The catálogo geral de rotinas é um index.

An routine é uma coisa with
An locus (reference),
An callback alarme,
An decider alarme,
An function alarme,
An compiled alarme,
An nickname index,
An moniker, alguns monikettes, alguns parameters, um parameter size,
An employs moniker,
Some locals, um local size,
An routine header, um header string,
An instruções, um body string,
Some fragments,
An address.

An routine reference é alguns monikettes.

The routines são algumas routines.

The save eax tag é uma tag igual a 20.

Etapas necessárias para que se examine any optional info por um type usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for "to", examine any optional info por o type usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for "para", examine any optional info por o type usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for any with, examine any optional info por o type usando o percorredor (conjunto); exit.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (endereço de memória):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "A palavra 'to' precisa de um artigo indefinido depois dela, não de um '" then o token deste percorredor then "'." e o percorredor; exit. 
Mova o percorredor (compilador rules).
Examine o type's target name usando o percorredor.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (conjunto):
Mova o percorredor (compilador rules).
Examine o type's fields usando o percorredor.

Etapas necessárias para que se examine any pauses usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any pause, cancele.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um field usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Examine o field usando o percorredor (type part).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any called, examine o field usando o percorredor (called part); repita.
Se o token deste percorredor for "at", examine o field usando o percorredor (redefine part); repita.
Se o token deste percorredor for "em", examine o field usando o percorredor (redefine part); repita.
Se o token deste percorredor for "redefinindo", examine o field usando o percorredor (redefine part); repita.
Se o token deste percorredor for any reference, examine o field usando o percorredor (reference part); repita.

Etapas necessárias para que se examine um field usando um percorredor (called part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o type name deste field estiver em branco, coloque o name deste field into o type name deste field. \ pedaço array type name already filled in
Examine o name deste field usando o percorredor.

Etapas necessárias para que se examine um field usando um percorredor (redefine part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo definido, abort with "Eu estava esperando o artigo 'the', mas o que encontrei foi '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o field's redefinition target name usando o percorredor.

Etapas necessárias para que se examine um field usando um percorredor (reference part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Ligue o reference alarme deste field.

Etapas necessárias para que se examine um field usando um percorredor (type part - pedaço array):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um ratio.
Reduce o ratio.
Se o ratio's denominador não for 1, abort with "Você tem que especificar um número completo de pedaços para um pedaço array" e o percorredor; exit.
Coloque o ratio's numerador into o field's contagem.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for "pedaço" ou "pedaços", abort with "Você precisa usar a palavra 'pedaços' depois de um counted field designador." e o percorredor; exit.
Mova o percorredor (compilador rules).
Coloque "pedaço" into o type name deste field.

Etapas necessárias para que se examine um field usando um percorredor (type part - normal):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any artigo indefinido, abort with "Falta por um artigo idefinido aqui, mas você colocou isso: '" then o token deste percorredor then "'." e o percorredor; exit.
Se o token deste percorredor for "another", coloque "other" into o name deste field.
\PAL
Se o token deste percorredor for "outra", coloque "segunda" into o name deste field.
Se o token deste percorredor for "outro", coloque "segundo" into o name deste field.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o name deste field with o name.

Etapas necessárias para que se examine um field usando um percorredor (type part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any numeric literal, examine o field usando o percorredor (type part - pedaço array); exit.
Examine o field usando o percorredor (type part - normal).

Etapas necessárias para que se examine alguns fields usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um field to o fields usando "field" e o percorredor's token's first.
Examine o field usando o percorredor.
Se o token deste percorredor não for any pause, cancele.
Examine any pauses usando o percorredor.
Repita.

Etapas necessárias para que se examine um global body usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Coloque o percorredor's token's first into o global body's first.
Coloque -1 into o global body's last.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o sinal de dois pontos, cancele.
Se o token deste percorredor for o ponto final, cancele.
Coloque o percorredor's token's last into o global body's last.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um global usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione o global to o globals usando "global" e o percorredor's token's first.
Mova o percorredor (compilador rules).
Examine o global's name usando o percorredor.
Se o token deste percorredor for any has, examine o global usando o percorredor (has ou have); exit.
Se o token deste percorredor não for any is, abort with "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, examine o global usando o percorredor (literal term); exit.
Mova o percorredor (compilador rules).
Examine o global's type name usando o percorredor. 
Se o token deste percorredor for o start of any optional info, examine o global usando o percorredor (optional info); exit.
Se o token deste percorredor for any operador de atribuição, examine o global usando o percorredor (data part); exit.
Se o token deste percorredor não for o ponto final, abort with "Toda definição precisa terminar com um ponto. Inclusive essa." e o percorredor; exit. 
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (data part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any to, abort with "Depois da palavra 'equal' você precisa por um palavra 'to'. Você colocou ; '" then o token deste percorredor then "'." e o percorredor; exit. 
Mova o percorredor (compilador rules).
Examine o global's global body usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Falta terminar um frase com um ponto." e o percorredor; exit. 
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (has ou have):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Coloque "~inline " then o global's name then " type" into um name.
Coloque o name then "s" into um plural name.
Adicione um type to o types usando o name e o plural name e "conjunto" e o global's locus. \mudar aqui
Catalogue o type.
Coloque o name deste type into o global's type name.
Examine o type's fields usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Aprenda a escrever direito. Cadê o ponto?." e o percorredor; exit. 
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (literal term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Examine o global's global body usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Aprenda a escrever corretamente. Cadê o ponto?." e o percorredor; exit. 
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque "~inline " then o global's name then " type" into um name.
Coloque o name then "s" into um plural name.
Adicione um type to o types usando o name e o plural name e o global's type name e o global's locus.
Catalogue o type.
Coloque o name deste type into o global's type name.
Examine any optional info por o type usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Tá na hora de aprender a escrever direito. Cadê o ponto?." e o percorredor; exit. 
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um name usando um percorredor:
Limpe o name.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor está on any name starter, extend o name with o percorredor's token; mova o percorredor (compilador rules).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor está on any name ender, pare.
Extend o name with o percorredor's token.
Mova o percorredor (compilador rules).
Repita.
Se o name estiver em branco, abort with "Acho que faltou colocar um nome por aqui. Você escreveu '" then o token deste percorredor then "'." e o percorredor; exit.

Etapas necessárias para que se examine uma instruções usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o start of any definition, cancele.
Coloque o percorredor's token's first into o instruções's first.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Coloque o percorredor's token's last into o instruções's last.
Se o token deste percorredor for o sinal de dois pontos, abort with "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e o percorredor; exit.
Se o token deste percorredor não for o ponto final, mova o percorredor (compilador rules); repita.
Mova o percorredor (compilador rules).
Se o token deste percorredor for o start of any definition, cancele.
Repita.

Etapas necessárias para que se examine uma routine usando um percorredor:
\ Define o cabeçalho de rotina.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione o routine to o routines usando o percorredor's token's first.
Mova o percorredor (compilador rules). \ skip o "Passos" e obtenha o next token
Se o token deste percorredor for "necessários" ou "necessárias", mova o percorredor (compilador rules). 
Se o token deste percorredor não for "para", abort with "Você precisa escrever 'para' antes de '" then o token deste percorredor then "' nesse tipo de rotina." e o percorredor; exit.
Mova o percorredor (compilador rules). \ skip o "para" e obtenha o next token
Se o token deste percorredor for "que", mova o percorredor (compilador rules). 
\Se o token deste percorredor não for "que", abort with "Você precisa colocar um 'que' antes da palavra '" then o token deste percorredor then "'." e o percorredor; exit.
\Mova o percorredor (compilador rules). \ skip o "que" e obtenha o next token
Se o token deste percorredor for "se", mova o percorredor (compilador rules). 
\Se o token deste percorredor não for "se", abort with "Você precisa colocar um 'se' antes da palavra '" then o token deste percorredor then "'." e o percorredor; exit.
\Mova o percorredor (compilador rules). \ skip o "se" e obtenha o next token
Examine o routine header desta routine usando o percorredor.
Se o token deste percorredor for o ponto&vírgula, examine o routine usando o percorredor (alternate palavraing); exit. \ *** por alternate palavraings
Se o token deste percorredor não for o sinal de dois pontos, abort with "O nome dessa função está escrito errado.." e o routine's locus; exit.
Mova o percorredor (compilador rules).
Examine as instruções desta routine usando o percorredor.

Etapas necessárias para que se examine uma routine usando um percorredor (alternate palavraing):
\ *** por alternate palavraings
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o start of any routine, abort with "Esse ponto e vírgula tá no lugar errado." e o original percorredor; exit.
Coloque o original percorredor's token's first into o routine's instruções's first.
Coloque o original percorredor's token's last into o routine's instruções's last.
Mova o original percorredor (compilador rules).

Etapas necessárias para que se examine uma routine header usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Coloque o percorredor's token's first into o routine header's first.
Coloque -1 into o routine header's last.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o ponto&vírgula, cancele. \ *** alternate palavraings
Se o token deste percorredor for o sinal de dois pontos, cancele.
Se o token deste percorredor for o ponto final, cancele.
Coloque o percorredor's token's last into o routine header's last.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um source file:
Se o source file for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor on o source file's trecho.
Mova o percorredor (compilador rules).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o start of any type, examine um type usando o percorredor; repita.
Se o token deste percorredor for o start of any global, examine um global usando o percorredor; repita.
Se o token deste percorredor for o start of any routine, examine uma routine usando o percorredor; repita.
Abort with "Faltou definir melhor o que é o '" then o token deste percorredor then "'." e o percorredor.
Repita.

Etapas necessárias para que se examine alguns source files:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um source file from o source files.
Se o source file for inexistente, cancele.
Examine o source file.
Repita.

Etapas necessárias para que se examine um type usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any artigo definido português, acione um portuguese alarme.
Se o token deste percorredor for any artigo definido inglês, acione um english alarme.
Adicione o type to o types usando o percorredor's token's first.
Mova o percorredor (compilador rules).
Examine o name deste type usando o percorredor.
Coloque o name deste type into o plural name deste type.
Se o portuguese alarme estiver ativo, pluralize o plural name deste type (portuguese rules).
Se o english alarme estiver ativo, pluralize o plural name deste type (english rules).
Se o english alarme não estiver ativo, pluralize o plural name deste type (portuguese rules).
Se o token deste percorredor for any has, examine o type usando o percorredor (has ou have); exit.
Se o token deste percorredor não for any is, abort with "Eu esperava um 'is' ou um 'are', mas só achei um : '" then o token deste percorredor then "'." e o percorredor; exit.
\Pluralize o plural name deste type.
\Se o token deste percorredor for "has" ou "have", examine o type usando o percorredor (has ou have); exit.
\Se o token deste percorredor não for "is" ou "are", abort with "I was expecting um 'is' ou 'are', but I found '" then o token deste percorredor then "'." e o percorredor; exit.

Mova o percorredor (compilador rules).
Se o token deste percorredor for any numeric literal, examine o type usando o percorredor (unit of measure); exit.
Se o token deste percorredor não for any artigo indefinido, abort with "Faltou um artigo indefinido, lembra? '" then o token deste percorredor then "'." e o percorredor; exit. 
Mova o percorredor (compilador rules).
Examine o type's base name usando o percorredor.
Examine any optional info por o type usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Você precisa usar um ponto para definir um tipo, lembra? Você usou '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (has ou have):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Coloque "conjunto" into o type's base name. \\mudar aqui
Examine o type's fields usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Ao invés de usar o ponto para definir tipo, você usou '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (unit of measure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to o type's scale.
Se o type's scale for 0, abort with "Zero é um tipo de escala inválido." e o type's locus; exit.
Mova o percorredor (compilador rules).
Examine o type's base name usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Os tipos precisam terminar com um ponto, não com '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

The scanning cronômetro é um cronômetro.

An scratch é um local.

Etapas necessárias para que se scrub um index:
Obtenha um bucket usando o index.
Se o bucket for inexistente, cancele.
Se o bucket's refers estiverem vazio, repita.
Scrub o bucket's refers.
Repita.

Etapas necessárias para que se scrub alguns refers:
Swap o refers with alguns other refers.
Percorra.
Coloque o other refers' first into um refer.
Se o refer for inexistente, cancele.
Remove o refer from o other refers.
Se o refer's endereço de memória for inexistente, destroy o refer; repita.
Posponha o refer to o refers.
Repita.

Etapas necessárias para que se ative o compiled alarme in uma variable;
Etapas necessárias para que se ligue o compiled alarme in uma variable:
Se o variable for inexistente, cancele.
Se o variable's compiled alarme estiver ativo, cancele.
Ligue o variable's compiled alarme.
Se o variable's categoria não for "global", cancele.
Se o variable's literal for inexistente, cancele.
Encontre uma routine usando "coloque" e o variable's literal's type e "into" e o variable's type.
Se a routine for inexistente, encontre o routine usando "convert" e o variable's literal's type e "to" e o variable's type; acione um alarme.
Se a routine for inexistente, abort with "O tipo dessa variável global e desse literal não são compatíveis." e o variable's locus; exit.
Compile o body of o routine.
Se o alarme estiver ativo, coloque "convert o " then o variable's literal's name then " to o " then o variable's name then ". " into o variable's initializer string.
Se o alarme não estiver ativo, coloque "coloque o " then o variable's literal's name then " into o " then o variable's name then ". " into o variable's initializer string.

Etapas necessárias para que se skip to o next palavra in um subtexto:
Se o subtexto estiver em branco, cancele.
Se o subtexto's first's target for noise, pare.
Adicione 1 to o first deste subtexto.
Repita.
Skip any leading noise in o subtexto.

Etapas necessárias para que se skip to o previous palavra in um subtexto:
Se o subtexto estiver em branco, cancele.
Se o subtexto's last's target for noise, pare.
Subtraia 1 from o last deste subtexto.
Repita.
Skip any trailing noise in o subtexto.

An source file é uma coisa with um endereço completo e um trecho.

The source files são alguns source files.

An tag é um número.

An term é um conjunto with uma variable e um phrase.

Etapas necessárias para que se transmogrify um fragment:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Se o fragment's tag for o push address tag, transmogrify o fragment (push address); exit.
Se o fragment's tag for o call internal tag, transmogrify o fragment (call internal); exit.
Se o fragment's tag for o load address tag, transmogrify o fragment (load address); exit.
Se o fragment's tag for o increment tag, transmogrify o fragment (increment); exit.
Se o fragment's tag for o dereference tag, transmogrify o fragment (dereference); exit.
Se o fragment's tag for o jump false tag, transmogrify o fragment (jump false); exit.
Se o fragment's tag for o not tag, transmogrify o fragment (not); exit.
Se o fragment's tag for o exit tag, transmogrify o fragment (exit); exit.
Se o fragment's tag for o repeat tag, transmogrify o fragment (repeat); exit.
Se o fragment's tag for o break tag, transmogrify o fragment (break); exit.
Se o fragment's tag for o prolog tag, transmogrify o fragment (prolog); exit.
Se o fragment's tag for o epilog tag, transmogrify o fragment (epilog); exit.
Se o fragment's tag for o push value tag, transmogrify o fragment (push value); exit.
Se o fragment's tag for o call external tag, transmogrify o fragment (call external); exit.
Se o fragment's tag for o load eax tag, transmogrify o fragment (load eax); exit.
Se o fragment's tag for o save eax tag, transmogrify o fragment (save eax); exit.
Se o fragment's tag for o call indirect tag, transmogrify o fragment (call indirect); exit.
Se o fragment's tag for o routine address tag, transmogrify o fragment (routine address); exit.

Etapas necessárias para que se transmogrify um fragment (break):
Coloque o repeat tag into uma tag.
Encontre another fragment usando o fragment e o tag.
Se o other fragment for inexistente, coloque o finalize tag into o tag. \ por break sem um loop ou after um loop
Encontre um third fragment usando o rotina utilizada atualmente's fragments' last e o tag (backwards).
Se o third fragment for inexistente, abort with "Erro interno - transmogrify um fragment (break)"; exit.
Se o third fragment's next for inexistente, abort with "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 e o third fragment's next's address to o fragment. \ JMP o destination's address

Etapas necessárias para que se transmogrify um fragment (call external):
Attach $FF15 e o fragment's entry's address to o fragment's code. \ call [the fragment's entry's address]

Etapas necessárias para que se transmogrify um fragment (call indirect):
Attach address loading code to o fragment's code usando o fragment's variable. \ coloque address into edx
Attach $FF12 to o fragment's code. \ call [edx]

Etapas necessárias para que se transmogrify um fragment (call internal):
Obtenha um address usando o fragment's routine.
Attach $E8 e o address to o fragment. \ call o fragment's routine's address

Etapas necessárias para que se transmogrify um fragment (dereference):
Attach $8B95 e o fragment's variable's offset to o fragment's code. \ mov edx,[ebp+the fragment's variable's offset]
Attach $8B12 to o fragment's code. \ mov edx,[edx]
Attach $8995 e o fragment's variable's offset to o fragment's code. \ mov [ebp+the fragment's variable's offset],edx

Etapas necessárias para que se transmogrify um fragment (epilog):
Se o rotina utilizada atualmente's callback alarme estiver ativo, attach $5F5E5B to o fragment's code. \ pop edi, esi, ebx
Attach $8BE5 to o fragment's code. \ mov esp,ebp
Attach $5D to o fragment's code. \ pop ebp
Attach $C2 e o rotina utilizada atualmente's parameter size to o fragment's code. \ ret o rotina utilizada atualmente's parameter size

Etapas necessárias para que se transmogrify um fragment (exit):
Encontre another fragment usando o fragment e o finalize tag.
Se o other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 e o other fragment's address to o fragment. \ jmp o destination's address

Etapas necessárias para que se transmogrify um fragment (increment):
Se o fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (increment)"; exit.
Se o fragment's variable's categoria não for "scratch", abort with "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 e o fragment's variable's offset e o fragment's número to o fragment's code. \ adicione [ebp+the fragment's variable's offset],the fragment's número

Etapas necessárias para que se transmogrify um fragment (jump false):
Encontre another fragment usando o fragment e o end if tag.
Se o other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 to o fragment's code. \ cmp eax,0
Attach $0F84 e o other fragment's address to o fragment. \ je o destination's address

Etapas necessárias para que se transmogrify um fragment (load address):
Attach address loading code to o fragment's code usando o fragment's variable. \ coloque address into edx
Attach $8995 e o fragment's other variable's offset to o fragment's code. \ mov [ebp+the fragment's variable's offset],edx

\Etapas necessárias para que se transmogrify um fragment (load eax):
\Attach address loading code to o fragment's code usando o fragment's variable. \ coloque address into edx
\Se o fragment's variable for inexistente, abort with "Internal erro - transmogrify um fragment (load eax)"; exit.
\Se o type desta variable deste fragment for inexistente, abort with "Internal erro 2 - transmogrify um fragment (load eax)"; exit.
\Se o length deste type desta variable deste fragment não for 4, abort with "Internal erro 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to o fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (load eax):
Attach $B8 e o fragment's alarme to o fragment's code. \ mov eax,alarme
\Attach address loading code to o fragment's code usando o fragment's variable. \ coloque address into edx
\Se o fragment's variable for inexistente, abort with "Internal erro - transmogrify um fragment (load eax)"; exit.
\Se o type desta variable deste fragment for inexistente, abort with "Internal erro 2 - transmogrify um fragment (load eax)"; exit.
\Se o length deste type desta variable deste fragment não for 4, abort with "Internal erro 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to o fragment's code. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (not):
Attach $83F001 to o fragment's code. \ xor eax,1

Etapas necessárias para que se transmogrify um fragment (prolog):
Attach $55 to o fragment's code. \ push ebp
Attach $8BEC to o fragment's code. \ mov ebp,esp
Coloque o rotina utilizada atualmente's local size dividido por 4 into um número.
Se o número não for 0, attach $B9 e o número e $6A004975FB to o fragment's code. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
Se o rotina utilizada atualmente's callback alarme estiver ativo, attach $535657 to o fragment's code. \ push ebx, esi, edi

Etapas necessárias para que se transmogrify um fragment (push address):
Attach address loading code to o fragment's code usando o fragment's variable. \ coloque address into edx
Attach $52 to o fragment's code. \ push edx

Etapas necessárias para que se transmogrify um fragment (push value):
Attach address loading code to o fragment's code usando o fragment's variable. \ coloque address into edx
Se o fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (push value)"; exit.
Se o type desta variable deste fragment for inexistente, abort with "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Coloque o length deste type desta variable deste fragment into um length.
Se o length for 4, attach $FF32 to o fragment's code; exit. \ push [edx]
Se o length for 2, attach $66FF32 to o fragment's code; exit. \ push palavra ptr [edx]
Se o length for 1, attach $0FB61252 to o fragment's code; exit. \ movzxb edx,[edx]; push edx
Abort with "Erro interno 3 - transmogrify um fragment (push value)".

Etapas necessárias para que se transmogrify um fragment (repeat):
Encontre another fragment usando o fragment e o loop tag (backwards).
Se o other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 e o other fragment's address to o fragment. \ jmp o destination's address

Etapas necessárias para que se transmogrify um fragment (routine address):
Attach address loading code to o fragment's code usando o fragment's variable. \ coloque address into edx
Se o fragment's routine for inexistente, abort with "Erro interno - transmogrify um fragment (routine address)"; exit.
Obtenha um address usando o fragment's routine.
Attach $C702 e o address to o fragment's code. \ mov [edx],the address

Etapas necessárias para que se transmogrify um fragment (save eax):
Attach address loading code to o fragment's code usando o fragment's variable. \ coloque address into edx
Se o fragment's variable for inexistente, abort with "Erro interno - transmogrify um fragment (save eax)"; exit.
Se o type desta variable deste fragment for inexistente, abort with "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Coloque o length deste type desta variable deste fragment into um length.
Se o length for 4, attach $8902 to o fragment's code; exit. \ mov [edx],eax
Se o length for 2, attach $668902 to o fragment's code; exit. \ mov [edx],ax
Se o length for 1, attach $8802 to o fragment's code; exit. \ mov [edx],al
Abort with "Erro interno 3 - transmogrify um fragment (save eax)".

Etapas necessárias para que se transmogrify alguns fragments:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Transmogrify o fragment.
Repita.

Etapas necessárias para que se transmogrify uma routine:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o routine's employs moniker não estiver em branco, cancele.
Se o routine's compiled alarme não estiver ativo, cancele.
Coloque o routine into a rotina utilizada atualmente.
Transmogrify o routine's fragments.

Etapas necessárias para que se transmogrify alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from o routines.
Se a routine for inexistente, pare.
Transmogrify o routine.
Repita.

The transmogrifying cronômetro é um cronômetro.

The catálogo de tipos é um index.

An type é uma coisa with
An locus (reference),
An name, um plural name,
An partial moniker,
An length,
An base name, um base type (reference),
An target name, um target type (reference) [endereço de memórias only],
An scale ratio,
Some fields [records only],
An cooking alarme,
An optional info resolved alarme.

An type name é um name.

The types são alguns types.

The catálogo de rotinas úteis é um index.

An variable é uma coisa with
An locus (reference),
An categoria [literal, global, local, parameter, scratch],
An compiled alarme,
An name, um nickname, um type name,
An type (reference), \ actual type on literal, global, local; dereferenced type on parameters e scratches
An address [globals e literals only] ou 
An offset at o address [locals, parameters, e fields only],
An contagem [fields only],
An reference alarme [fields only],
An redefinition target name [fields only],
An by-value alarme [parameters only],
An global body [globals only],
An initializer string [globals only],
An literal (reference) [globals only - constant with which to initalize o global],
An texto hexadecimal called data [literals only].

The writing cronômetro é um cronômetro.

Etapas necessárias para que se skip any trailing noise in um subtexto:
Se o subtexto estiver em branco, cancele.
Se o subtexto's last's target não for noise, cancele.
Subtraia 1 from o last deste subtexto.
Repita.

\ dahn - reverse functions
\ to coloque o xxx uv a/the yyy into zzz
\ internally we vire this into "to coloque a/the yyy's xxx into zzz"
Etapas necessárias para que se compile o header of uma routine usando um percorredor (reverse-possessive function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o routine's function alarme.
Adicione um monikette to os monikettes desta routine usando "coloque".
Mova o percorredor (compilador rules). \ skip "coloque" ou "poner"
Mova o percorredor (compilador rules). \ skip "the" ou Portuguese artigo definido
Examine um name usando o percorredor. \ field name
Mova o percorredor (compilador rules). \ skip "uv" ou "de"
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo definido).
Adicione another monikette to os monikettes desta routine usando "'s " then o name.
Se o token deste percorredor não for any reverse-possessive function into, abort with "Esperava a palavra 'em', mas encontrei '" then o token deste percorredor then "'." e o percorredor; exit.
Adicione um third monikette to o monikettes desta routine usando "into".
Convert os monikettes desta routine to um moniker.
Se o moniker estiver in o catálogo geral de rotinas, abort with "Já sei como '" then o moniker then "'." e o routine's locus; exit.
Catalogue o routine usando os monikettes desta routine e o catálogo geral de rotinas.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "Esperava um artigo indefinido, mas encontrei '" then o token deste percorredor then "'." e o percorredor; exit.
Compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo indefinido).
Se o token deste percorredor não estiver em branco, abort with "Existem outras coisas no final desta função." e o percorredor; exit.
Convert os monikettes desta routine to o moniker desta routine.
Catalogue o routine usando os monikettes desta routine e o catálogo geral de rotinas. \ por employs

\ dahn - reverse functions
\ to coloque o xxx uv a/the yyy into zzz
Etapas necessárias para que se determine se um percorredor é o start of any reverse-possessive function:
Se o alarme de alerta deste compilador estiver ativo, diga não.
Se o token deste percorredor não for any coloque, diga não.
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo definido, diga não.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o percorredor não for on any reverse-possessive, diga não.
Diga sim.
\finalmente