\ o compilador (el compilador) copyright © 2006-2021 o osmosian order

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

An mensagem de erro é um string.

Etapas necessárias para que se abort with um string:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o alarme de alerta deste compilador.
Coloque o string into a mensagem de erro deste compilador.

Etapas necessárias para que se abort with um string e um endereço de memória du pedaço :
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o alarme de alerta deste compilador.
Coloque o string into a mensagem de erro deste compilador.
Encontre o abort endereço completo deste compilador e o abort row# deste compilador usando o endereço de memória du pedaço .
Se o abort endereço completo deste compilador estiver em branco, cancele.
Extract um nome du arquivo from o abort endereço completo deste compilador.
Anteponha "Erro no " then o nome du arquivo then ". " to a mensagem de erro deste compilador.

Etapas necessárias para que se abort with um string e um percorredor:
Se o token deste percorredor não estiver em branco, abort with o string e o first deste token deste percorredor; exit.
Abort with o string e o last deste source deste percorredor.

Etapas necessárias para que se adicione o allocate e deallocate e finalize e destroy routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Adicione o finalize routine por o type.
Adicione o allocate routine por o type.
Adicione o deallocate routine por o type.
Adicione o destroy routine por o type.
Repita.

Etapas necessárias para que se adicione o allocate routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o target type deste type for inexistente, cancele.
Adicione uma routine to a routines usando nil.
Posponha "Allocate memory por um " then o name deste type to o header string desta routine. \ traduzir aqui
Posponha "Assign o " then o name deste type then " usando " to o body string desta routine.
Posponha o length deste target type deste type then "." to o body string desta routine.
Lance a routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione e compile o initialize before run e run e finalize after run routine:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine to a routines usando nil.
Posponha "~initialize before run e run e finalize after run" to o header string desta routine.
Posponha "initialize before run. " to o body string desta routine.
Posponha o global initializers to o body string desta routine.
Posponha "nosso programa seja executado. " to o body string desta routine. \ traduzir
Posponha o global finalizers to o body string desta routine.
Posponha "finalize after run. " to o body string desta routine.
Posponha "call ""kernel32.dll"" ""ExitProcess"" with 0. " to o body string desta routine.
Lance a routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of a routine.
Compile o body of a routine.

Etapas necessárias para que se adicione o built-in types:
Adicione um built-in type usando "byte" e "bytes" e 1. \ que tal octeto?
Adicione another built-in type usando "record" e "records" e 0.
Adicione um third built-in type usando "pedaço" e "pedaços" e 1.
Adicione um fourth built-in type usando "conjunto" e "conjuntos" e 0.

Etapas necessárias para que se adicione um built-in type usando um name e um plural name e um length:
Adicione o built-in type to o types usando o name e o plural name e o name.
Coloque o length into o length deste built-in type.
Coloque o built-in type into o base type deste built-in type.
Catalogue o built-in type.

Etapas necessárias para que se adicione o deallocate routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o target type deste type for inexistente, cancele.
Adicione uma routine to a routines usando nil.
Posponha "Deallocate um " then o name deste type to o header string desta routine.
Posponha "Se o " then o name deste type then " for inexistente, cancele. " to o body string desta routine.
Se o target type deste type deveria ser [estar] finalizado, posponha "~finalize o " then o name deste type then "'s target. " to o body string desta routine.
Posponha "Unassign o " then o name deste type then "." to o body string desta routine.
Lance a routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione o destroy routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não deveria ser ignorado, cancele.
Se o type puder ser reduzido para "coisas", adicione o destroy routine por o type (coisas); exit.
Se o type puder ser reduzido para "endereço de memória", adicione o destroy routine por o type (endereço de memória); exit.

Etapas necessárias para que se adicione o destroy routine por um type (endereço de memória):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque "Destroy [" then o name deste type then "]" into um moniker.
Se o moniker estiver in o catálogo geral de rotinas, cancele.
Adicione uma routine to a routines usando nil.
Posponha "Destroy um " then o name deste type to o header string desta routine.
Posponha "Se o " then o name deste type then " for inexistente, cancele. " to o body string desta routine.
Se o target type deste type puder ser reduzido para "endereço de memória", posponha "Destroy o " then o name deste type then "'s target. " to o body string desta routine.
Se o target type deste type puder ser reduzido para "coisas", posponha "Destroy o " then o name deste type then "'s target. " to o body string desta routine.
Percorra.
Obtenha um field from os fields deste target type deste type.
Se o field for inexistente, pare.
Se o reference alarme deste field estiver ativo, repita.
Se o type deste field não deveria ser ignorado, repita.
Posponha "Destroy o " then o name deste type then "'s " then o name deste field then ". " to o body string desta routine.
Repita.
Posponha "Deallocate o " then o name deste type then ". " to o body string desta routine. \ traduzir aqui
Lance a routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione o destroy routine por um type (coisas):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
\Coloque "Erro interno na hora de executar a tarefa de destruição de tipos" into a reply.
Se o first destes fields deste type for inexistente, abort with "Erro interno na rotina 'adicione um forget routine por um type (coisas)'"; [Say o reply;] exit. \Adicionado Say o reply
Se o type deste first destes fields deste type for inexistente, abort with "Erro interno 2 na rotina 'adicione o forget routine por um type (coisas)'"; exit.
Coloque "Destroy [" then o name deste type then "]" into um moniker.
Se o moniker estiver in o catálogo geral de rotinas, cancele.
Adicione uma routine to a routines usando nil.
Posponha "Destroy um " then o name deste type to o header string desta routine.
Posponha "Se o " then o name deste type then "'s first for inexistente, cancele. " to o body string desta routine.
Coloque o name deste type deste first destes fields deste type into um name.
Posponha "Coloque o " then o name deste type then "'s first into um " then o name then ". " to o body string desta routine.
Posponha "Remove o " then o name then " from o " then o name deste type then ". " to o body string desta routine.
Posponha "Destroy o " then o name then ". " to o body string desta routine.
Posponha "Repeat. " to o body string desta routine.
Lance a routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione um entry to alguns imports usando um import name e um entry name:
Encontre um import usando o import name.
Se o import for inexistente, adicione o import to o imports usando o import name.
Encontre o entry usando o entry name e as entries deste import.
Se o entry não for inexistente, cancele.
Crie o entry.
Posponha o entry to as entries deste import.
Coloque o entry name into o name desta entry.

Etapas necessárias para que se adicione um field to alguns fields usando um name e um nickname e um type name e um reference alarme:
Adicione o field to o fields usando "field" e nil.
Coloque o name into o name deste field.
Coloque o nickname into o nickname deste field.
Coloque o type name into o type name deste field.
Coloque o reference alarme into o reference alarme deste field.

Etapas necessárias para que se adicione o finalize routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não deveria ser finalizado, cancele.
Se o name deste type for "string", adicione o finalize routine por o type (string); exit.
Se o type puder ser reduzido para "string", cancele. \ prevents generation of finalizer por derived string types
Adicione o finalize routine por o type (conjunto).

Etapas necessárias para que se adicione o finalize routine por um type (conjunto):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine to a routines usando nil.
Posponha "~finalize um " then o name deste type to o header string desta routine.
Posponha "intel $50. " to o body string desta routine. \ push eax
Percorra.
Obtenha um field from os fields deste type.
Se o field for inexistente, pare.
Se o type deste field não deveria ser finalizado, repita.
Posponha "~finalize o " then o name deste type then "'s " then o name deste field then ". " to o body string desta routine.
Repita.
Posponha "intel $58." to o body string desta routine. \ pop eax
Lance a routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione o finalize routine por um type (string):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine to a routines usando nil.
Posponha "~finalize um " then o name deste type to o header string desta routine.
Posponha "intel $50. " to o body string desta routine. \ push eax
Posponha "unassign o string's first. " to o body string desta routine.
Posponha "intel $58." to o body string desta routine. \ pop eax
Lance a routine header desta routine on o header string desta routine.
Lance as instruções desta routine on o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione um fragment usando uma tag:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.

Etapas necessárias para que se adicione um fragment usando uma tag e um entry:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o entry into a entry deste fragment.

Etapas necessárias para que se adicione um fragment usando uma tag e um alarme:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o alarme into o alarme deste fragment.

Etapas necessárias para que se adicione um fragment usando uma tag e uma routine:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque a routine into a routine deste fragment.
Compile o body of a routine.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o variable into o variable deste fragment.
Ligue o compiled alarme in o variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e another variable:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o variable into a variable deste fragment.
Coloque o other variable into o other variable deste fragment.
Ligue o compiled alarme in o variable.
Ligue o compiled alarme in o other variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e um número:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment to os fragments desta rotina utilizada atualmente.
Coloque o variable into a variable deste fragment.
Coloque o número into o número deste fragment.
Ligue o compiled alarme in o variable.

Etapas necessárias para que se adicione um import to alguns imports usando um import name:
Crie o import.
Posponha o import to o imports.
Coloque o import name into o name deste import.

Etapas necessárias para que se adicione um intermediate usando um type name e um locus:
Se a rotina utilizada atualmente for inexistente, esvazie o intermediate; exit.
Adicione o intermediate to os locals desta rotina utilizada atualmente usando "local" e o locus.
Gere o name deste intermediate usando "~I".
Coloque o type name into o type name deste intermediate.
Resolva o intermediate.

Etapas necessárias para que se adicione um literal to alguns variables usando um locus:
Adicione o literal como uma variable to o variables usando "literal" e o locus.
Gere o name deste literal usando "~L".

Etapas necessárias para que se adicione um monikette to alguns monikettes usando um expression:
Crie o monikette.
Posponha o monikette to os monikettes.
Coloque a phrase desta expression into o string deste monikette.
Coloque a variable desta expression into a variable deste monikette.
Se a variable desta expression não for inexistente, coloque o type desta expression into o type deste monikette.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette to alguns monikettes usando um string:
Crie o monikette.
Posponha o monikette to os monikettes.
\PAL
\\ conjunctions
Se o string for "e", coloque "e" into o string deste monikette; exit. \ and
Se o string for "ou", coloque "or" into o string deste monikette; exit. \ or
\ from/given/with/using
Se o string for "desde", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "a partir de", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "partindo de", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "de", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "dada", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "dado", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "dadas", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "dados", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "com", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "usando", coloque "from/given/with/using" into o string deste monikette; exit.
\\ in/into/to
Se o string for "em", coloque "in/into/to" into o string deste monikette; exit.
Se o string for "a", coloque "in/into/to" into o string deste monikette; exit.
\\ is/are
Se o string for "é", coloque "is/are" into o string deste monikette; exit.
Se o string for "está", coloque "is/are" into o string deste monikette; exit.
Se o string for "for", coloque "is/are" into o string deste monikette; exit.
Se o string for "foi", coloque "is/are" into o string deste monikette; exit.
Se o string for "foram", coloque "is/are" into o string deste monikette; exit.
Se o string for "forem", coloque "is/are" into o string deste monikette; exit.
Se o string for "estiver", coloque "is/are" into o string deste monikette; exit.
Se o string for "estiverem", coloque "is/are" into o string deste monikette; exit.
\Se o string for "tem", coloque "is/are" into o string deste monikette; exit.
\Se o string for "tiver", coloque "is/are" into o string deste monikette; exit.
Se o string for "are", coloque "is/are" into o string deste monikette; exit.
Se o string for "são", coloque "is/are" into o string deste monikette; exit.
Se o string for "estão", coloque "is/are" into o string deste monikette; exit.
Se o string for "is", coloque "is/are" into o string deste monikette; exit.
Se o string for "forem", coloque "is/are" into o string deste monikette; exit.
Se o string for "estiverem", coloque "is/are" into o string deste monikette; exit.
Se o string for "puder", coloque "pode" into o string deste monikette; exit.
Se o string for "puderem", coloque "pode" into o string deste monikette; exit.
Se o string for "existir", coloque "existe" into o string deste monikette; exit.
\Se o string for "decide", coloque "decidir" into o string deste monikette; exit.
\Se o string for "decidiu", coloque "decidir" into o string deste monikette; exit.
\Se o string for "decidindo", coloque "decidir" into o string deste monikette; exit. \melhor não por gerúndio ou verbos compostos
\Se o string for "decidiu-se", coloque "decidir" into o string deste monikette; exit.
Se o string for "existir", coloque "existe" into o string deste monikette; exit.
\\ allocates e destroys
\Se o string for "alojar", coloque "allocate" into o string deste monikette; exit.
Se o string for "aloje", coloque "allocate" into o string deste monikette; exit.
\Se o string for "alocar", coloque "allocate" into o string deste monikette; exit.
Se o string for "aloque", coloque "allocate" into o string deste monikette; exit.
\Se o string for "reservar", coloque "allocate" into o string deste monikette; exit.
Se o string for "reserve", coloque "allocate" into o string deste monikette; exit.
Se o string for "memória", coloque "memory" into o string deste monikette; exit.
\Se o string for "for", coloque "por" into o string deste monikette; exit. \\servia pra converter o "for" para "por"
Se o string for "pelo", coloque "por the" into o string deste monikette; exit.
Se o string for "pela", coloque "por the" into o string deste monikette; exit.
\Se o string for "desalocar", coloque "deallocate" into o string deste monikette; exit.
Se o string for "desaloque", coloque "deallocate" into o string deste monikette; exit.
\Se o string for "desalojar", coloque "deallocate" into o string deste monikette; exit.
Se o string for "desaloje", coloque "deallocate" into o string deste monikette; exit.
\Se o string for "esvaziar", coloque "deallocate" into o string deste monikette; exit.
\Se o string for "esvazie", coloque "deallocate" into o string deste monikette; exit.
Se o string for "destruir", coloque "destroy" into o string deste monikette; exit.
\CAL
\\ from/given/with/using
Se o string for "from", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "given", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "with", coloque "from/given/with/using" into o string deste monikette; exit.
Se o string for "using", coloque "from/given/with/using" into o string deste monikette; exit.
\ in/into/to
Se o string for "in", coloque "in/into/to" into o string deste monikette; exit.
Se o string for "into", coloque "in/into/to" into o string deste monikette; exit.
Se o string for "to", coloque "in/into/to" into o string deste monikette; exit.
\ is/are
Se o string for "are", coloque "is/are" into o string deste monikette; exit.
Se o string for "is", coloque "is/are" into o string deste monikette; exit.
\ aren't/isn't
Se o string for "isn't", coloque "is/aren't" into o string deste monikette; exit.
Se o string for "aren't", coloque "is/aren't" into o string deste monikette; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se o string for "backward", coloque "backward" into o string deste monikette; exit.
Se o string for "backwards", coloque "backward" into o string deste monikette; exit.
Se o string for "counterclockwise", coloque "backward" into o string deste monikette; exit.
Se o string for "counter-clockwise", coloque "backward" into o string deste monikette; exit.
Se o string for "anticlockwise", coloque "backward" into o string deste monikette; exit.
Se o string for "anti-clockwise", coloque "backward" into o string deste monikette; exit.
\ at/on
Se o string for "at", coloque "at/on" into o string deste monikette; exit.
Se o string for "on", coloque "at/on" into o string deste monikette; exit.
\ other
Coloque o string into o string deste monikette.

Etapas necessárias para que se adicione um monikette to alguns monikettes usando um type:
Crie o monikette.
Posponha o monikette to os monikettes.
Coloque o type into o type deste monikette.

Etapas necessárias para que se adicione push fragments usando alguns monikettes:
Se a rotina utilizada atualmente for inexistente, cancele.
Percorra.
Obtenha um monikette from os monikettes (backwards).
Se o monikette for inexistente, cancele.
Se a variable deste monikette for inexistente, repita.
Se o subtexto atual deste monikette não estiver em branco, repita.
Se o type atual deste monikette for inexistente, repita.
Adicione um fragment usando o push address tag e a variable deste monikette.
Repita.

Etapas necessárias para que se adicione o coloque ou convert fragments usando uma variable e another variable e um locus:
Adicione um fragment usando o push address tag e o other variable.
Adicione another fragment usando o push address tag e o variable.
Encontre uma routine usando "coloque" e o type desta variable e "into" e o type desta other variable.
Se a routine for inexistente, encontre a routine usando "convert" e o type desta variable e "to" e o type desta other variable.
Se a routine não for inexistente, adicione um third fragment usando o call internal tag e a routine; exit.
\ erro message
Adicione um monikette to alguns monikettes usando "coloque/convert".
Adicione another monikette to os monikettes usando o type desta variable.
Adicione um third monikette to os monikettes usando "into/to".
Adicione um fourth monikette to os monikettes usando o type desta other variable.
Convert os monikettes to um moniker.
Destroy os monikettes.
Abort with "Eu não sei como '" then o moniker then "'." e o locus.

Etapas necessárias para que se adicione uma routine to alguns routines usando um locus:
Crie a routine.
Posponha a routine to a routines.
Coloque o locus into o locus desta routine.

Etapas necessárias para que se adicione um scratch usando um type name e um locus:
Se a rotina utilizada atualmente for inexistente, esvazie o scratch; exit.
Adicione o scratch to os locals desta rotina utilizada atualmente usando "scratch" e o locus.
Gere o name deste scratch usando "~S".
Coloque o type name into o type name deste scratch.
Resolva o scratch.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um locus:
Adicione um fragment usando o push address tag e o other variable.
Adicione another fragment usando o push address tag e o variable.
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to os monikettes usando o type desta variable.
Adicione um third monikette to os monikettes usando o other string.
Adicione um fourth monikette to os monikettes usando o type desta other variable.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, convert os monikettes to um moniker.
Destroy os monikettes.
Se a routine for inexistente, abort with "Eu não sei como '" then o moniker then "'." e o locus; exit.
Adicione um third fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um third string e um third variable e um endereço de memória du pedaço :
Adicione um fragment usando o push address tag e o third variable.
Adicione another fragment usando o push address tag e o other variable.
Adicione um third fragment usando o push address tag e o variable.
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to os monikettes usando o type desta variable.
Adicione um third monikette to os monikettes usando o other string.
Adicione um fourth monikette to os monikettes usando o type desta other variable.
Adicione um fifth monikette to os monikettes usando o third string.
Adicione um sixth monikette to os monikettes usando o type desta third variable.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, convert os monikettes to um moniker.
Destroy os monikettes.
Se a routine for inexistente, abort with "Eu não sei como '" then o moniker then "'." e o endereço de memória du pedaço; exit.
Adicione um fourth fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione um source file to alguns source files usando um endereço completo:
Crie o source file.
Posponha o source file to o source files.
Coloque o endereço completo into o endereço completo deste source file.

Etapas necessárias para que se adicione two fragments usando um string e uma variable e um locus:
Adicione um fragment usando o push address tag e o variable.
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to os monikettes usando o type desta variable.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, convert os monikettes to um moniker.
Destroy os monikettes.
Se a routine for inexistente, abort with "Eu não sei como '" then o moniker then "'." e o locus; exit.
Adicione another fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione um type to alguns types usando um locus:
Crie o type.
Posponha o type to o types.
Coloque o locus into o locus deste type.

Etapas necessárias para que se adicione um type to alguns types usando um name e um plural name e um base name:
Adicione o type to o types usando o name e o plural name e o base name e nil.

Etapas necessárias para que se adicione um type to alguns types usando um name e um plural name e um base name e um locus:
Crie o type.
Posponha o type to o types.
Coloque o locus into o locus deste type.
Coloque o name into o name deste type.
Coloque o plural name into o plural name deste type.
Coloque o base name into o base name deste type.

Etapas necessárias para que se adicione uma variable to alguns variables usando um categoria e um locus:
Crie o variable usando o categoria.
Posponha o variable to o variables.
Coloque o locus into o locus desta variable.

The adding built-in memory routines cronômetro é um cronômetro.

The adding built-in startup routine cronômetro é um cronômetro.

Etapas necessárias para que se address alguns entries:
Obtenha um entry from o entries.
Se o entry for inexistente, cancele.
Address o entry.
Repita.

Etapas necessárias para que se address um entry:
Coloque o endereço du nome usado atualmente into o name address desta entry.
Coloque o length deste name deste entry mais 3 into um número.
Round o número up to o nearest multiple of 2.
Adicione o número to o endereço du nome usado atualmente.
Coloque o current thunk address into o thunk address desta entry.
Coloque o image base mais o current thunk address into o address desta entry.
Adicione 4 to o current thunk address.

Etapas necessárias para que se address um fragment usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Coloque o image base mais o address into o address deste fragment.
Se a tag deste fragment for a push address tag, adicione 7 to o address; exit.
Se a tag deste fragment for a call internal tag, adicione 5 to o address; exit.
Se a tag deste fragment for a load address tag, adicione 12 to o address; exit.
Se a tag deste fragment for a increment tag, adicione 10 to o address; exit.
Se a tag deste fragment for a dereference tag, adicione 14 to o address; exit.
Se a tag deste fragment for a jump false tag, adicione 9 to o address; exit.
Se a tag deste fragment for a not tag, adicione 3 to o address; exit.
Se a tag deste fragment for a exit tag, adicione 5 to o address; exit.
Se a tag deste fragment for a repeat tag, adicione 5 to o address; exit.
Se a tag deste fragment for a break tag, adicione 5 to o address; exit.
Se a tag deste fragment for a prolog tag, address o fragment usando o address (prolog); exit.
Se a tag deste fragment for a epilog tag, address o fragment usando o address (epilog); exit.
Se a tag deste fragment for a intel tag, adicione o length deste code deste fragment to o address; exit.
Se a tag deste fragment for a push value tag, address o fragment usando o address (push value); exit.
Se a tag deste fragment for a call external tag, adicione 6 to o address; exit.
Se a tag deste fragment for a load eax tag, adicione 5 to o address; exit. \ was 8 when "load eax" took in variables; now "load eax" only does um immediate value
Se a tag deste fragment for a save eax tag, address o fragment usando o address (save eax); exit.
Se a tag deste fragment for a call indirect tag, adicione 8 to o address; exit.
Se a tag deste fragment for a routine address tag, adicione 12 to o address; exit.

Etapas necessárias para que se address um fragment usando um address (epilog):
Se o callback alarme desta rotina utilizada atualmente estiver ativo, adicione 3 to o address.
Adicione 6 to o address.

Etapas necessárias para que se address um fragment usando um address (prolog):
Adicione 3 to o address.
Se o local size desta rotina utilizada atualmente não for 0, adicione 10 to o address.
Se o callback alarme desta rotina utilizada atualmente estiver ativo, adicione 3 to o address.

Etapas necessárias para que se address um fragment usando um address (push value):
Adicione 6 to o address.
Se a variable deste fragment for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se o type desta variable deste fragment for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Coloque o length deste type desta variable deste fragment into um length.
Se o length for 4, adicione 2 to o address; exit.
Se o length for 2, adicione 3 to o address; exit.
Se o length for 1, adicione 4 to o address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address um fragment usando um address (save eax):
Adicione 6 to o address.
Se o variable deste fragment for inexistente, abort with "Erro interno - address um fragment usando um address (push value)"; exit.
Se o type desta variable deste fragment for inexistente, abort with "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Coloque o length deste type desta variable deste fragment into um length.
Se o length for 4, adicione 2 to o address; exit.
Se o length for 2, adicione 3 to o address; exit.
Se o length for 1, adicione 2 to o address; exit.
Abort with "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address alguns fragments usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Address o fragment usando o address.
Repita.

Etapas necessárias para que se address um import:
Coloque o endereço du nome usado atualmente into o name address deste import.
Coloque o endereço du cabeçalho usado atualmente into o header address deste import.
Coloque o endereço du nome usado atualmente into o name memory address deste import header deste import.
Coloque o length deste name deste import mais 1 into um número.
Round o número up to o nearest multiple of 2.
Adicione o número to o endereço du nome usado atualmente.
Adicione um import header's magnitude to o endereço du cabeçalho usado atualmente. \ tenho que traduzir com calma isso depois
Coloque o current thunk address into o first thunk memory address deste import header deste import.
Address as entries deste import.
Adicione 4 to o current thunk address.

Etapas necessárias para que se address alguns imports usando um address:
Coloque o address into o endereço du cabeçalho usado atualmente.
Coloque as contagem destes imports into um contagem.
Adicione 1 to o contagem.
Multiplique a contagem por um import header's magnitude.
Coloque o address mais o contagem into o current thunk address.
Obtenha another contagem usando o imports (all entries mais markers).
Multiplique o other contagem por 4.
Coloque o current thunk address mais o other contagem into o endereço du nome usado atualmente.
Percorra.
Obtenha um import from o imports.
Se o import for inexistente, pare.
Address o import.
Repita.
Coloque o endereço du nome usado atualmente menos o address into um número.
Adicione o número to o address.

An address é um número.

Etapas necessárias para que se address uma routine usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o employs moniker desta routine não estiver em branco, cancele. \ employs são addressed later
Se o compiled alarme desta routine não estiver ativo, cancele.
Coloque a routine into a rotina utilizada atualmente.
Coloque o image base mais o address into o address desta routine.
Address os fragments desta routine usando o address.
Round o address up to o nearest multiple of 4.

Etapas necessárias para que se address alguns routines usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, pare.
Address a routine usando o address.
Repita.

Etapas necessárias para que se address uma variable usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Se o compiled alarme desta variable não estiver ativo, cancele.
Coloque o image base mais o address into o address desta variable.
Adicione o length deste type desta variable to o address.
Se o type desta variable puder ser reduzido para "string", adicione o length deste data desta variable mais 1 to o address.
Round o address up to o nearest multiple of 4.

Etapas necessárias para que se address alguns variables usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Address o variable usando o address.
Repita.

The addressing cronômetro é um cronômetro.

Etapas necessárias para que se advance um trecho:
Posponha o return pedaço to o trecho.
Posponha o linefeed pedaço to o trecho.

Etapas necessárias para que se advance um trecho (twice):
Advance o trecho.
Advance o trecho.

Etapas necessárias para que se posponha um entry to um trecho (with separator):
Se o entry for inexistente, posponha "" to o trecho (with separator); exit.
Posponha o name desta entry to o trecho (with separator).

Etapas necessárias para que se posponha um alarme to um trecho (with separator):
Convert o alarme to um string.
Posponha o string to o trecho (with separator).

Etapas necessárias para que se posponha o global finalizers to um string:
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Se o compiled alarme deste global não estiver ativo, repita.
Se o type deste global não deveria ser [estar] finalizado, repita.
Posponha "~finalize o " then o name deste global then ". " to o string.
Repita.

Etapas necessárias para que se posponha o global initializers to um string:
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Se o literal deste global for inexistente, repita.
Se o compiled alarme deste global não estiver ativo, repita.
Desative um alarme.
Posponha o initializer string deste global to o string.
Repita.

Etapas necessárias para que se posponha um monikette to um moniker:
Se o monikette for inexistente, cancele.
Se o moniker não estiver em branco, posponha o space pedaço to o moniker.
Se o type deste monikette não for inexistente, posponha "[" e o name deste type deste monikette e "]" to o moniker (fast); exit.
Se o string deste monikette não estiver em branco, posponha o string deste monikette to o moniker; exit.

Etapas necessárias para que se posponha um monikette to um moniker (while bubbling):
Se o monikette for inexistente, cancele.
Se o moniker não estiver em branco, posponha o space pedaço to o moniker.
Se o subtexto atual deste monikette não estiver em branco, posponha o subtexto atual deste monikette to o moniker; exit.
Se o type atual deste monikette não for inexistente, posponha "[" e o name deste type atual deste monikette e "]" to o moniker (fast); exit.

Etapas necessárias para que se posponha um número to um trecho (as hex with separator):
Convert o número to um texto dâ cifra binária.
Posponha o texto dâ cifra binária to o trecho (with separator).

Etapas necessárias para que se posponha um número to um trecho (with separator):
Convert o número to um string.
Posponha o string to o trecho (with separator).

Etapas necessárias para que se posponha um ratio to um trecho (with separator):
Convert o ratio to um string.
Posponha o string to o trecho (with separator).

Etapas necessárias para que se posponha uma routine to um trecho (with separator):
Se a routine for inexistente, posponha "" to o trecho (with separator); exit.
Posponha o moniker deste routine to o trecho (with separator).

Etapas necessárias para que se posponha um string e another string e um third string to um fourth string (fast):
Coloque o length deste fourth string into um length.
Adicione o length deste string to o length.
Adicione o length deste other string to o length.
Adicione o length deste third string to o length.
Reassign um endereço de memória usando o length.
Coloque o endereço de memória into um endereço de memória du pedaço .
Copy pedaços from o first deste fourth string to o endereço de memória du pedaço por o length deste fourth string.
Adicione o length deste fourth string to o endereço de memória du pedaço .
Copy pedaços from o first deste string to o endereço de memória du pedaço por o length deste string.
Adicione o length deste string to o endereço de memória du pedaço .
Copy pedaços from o first deste other string to o endereço de memória du pedaço por o length deste other string.
Adicione o length deste other string to o endereço de memória du pedaço .
Copy pedaços from o first deste third string to o endereço de memória du pedaço por o length deste third string.
Unassign o first deste fourth string.
Coloque o endereço de memória into o first deste fourth string.
Coloque o endereço de memória mais o length menos 1 into o last deste fourth string.

Etapas necessárias para que se posponha um string to um trecho (with separator):
Posponha o string to o trecho.
Posponha "/" to o trecho.

Etapas necessárias para que se posponha uma tag to um trecho (as um fragment tag string with separator):
Se a tag for a break tag, posponha "break" to o trecho (with separator); exit.
Se a tag for a call external tag, posponha "call external" to o trecho (with separator); exit.
Se a tag for a call indirect tag, posponha "call indirect" to o trecho (with separator); exit.
Se a tag for a call internal tag, posponha "call internal" to o trecho (with separator); exit.
Se a tag for a dereference tag, posponha "dereference" to o trecho (with separator); exit.
Se a tag for a end if tag, posponha "end if" to o trecho (with separator); exit.
Se a tag for a epilog tag, posponha "epilog" to o trecho (with separator); exit.
Se a tag for a exit tag, posponha "exit" to o trecho (with separator); exit.
Se a tag for a finalize tag, posponha "finalize" to o trecho (with separator); exit.
Se a tag for a increment tag, posponha "increment" to o trecho (with separator); exit.
Se a tag for a intel tag, posponha "intel" to o trecho (with separator); exit.
Se a tag for a jump false tag, posponha "jump false" to o trecho (with separator); exit.
Se a tag for a load address tag, posponha "load address" to o trecho (with separator); exit.
Se a tag for a load eax tag, posponha "load eax" to o trecho (with separator); exit.
Se a tag for a loop tag, posponha "loop" to o trecho (with separator); exit.
Se a tag for a not tag, posponha "not" to o trecho (with separator); exit.
Se a tag for a prolog tag, posponha "prolog" to o trecho (with separator); exit.
Se a tag for a push address tag, posponha "push address" to o trecho (with separator); exit.
Se a tag for a push value tag, posponha "push value" to o trecho (with separator); exit.
Se a tag for a save eax tag, posponha "save eax" to o trecho (with separator); exit.
Se a tag for a repeat tag, posponha "repeat" to o trecho (with separator); exit.
Se a tag for a routine address tag, posponha "routine address" to o trecho (with separator); exit.
Posponha "?" to o trecho (with separator).

Etapas necessárias para que se posponha um type to um trecho (with separator):
Se o type for inexistente, posponha "" to o trecho (with separator); exit.
Posponha o name deste type to o trecho (with separator).

Etapas necessárias para que se posponha uma variable to um trecho (with separator):
Se o variable for inexistente, posponha "" to o trecho (with separator); exit.
Posponha o name desta variable to o trecho (with separator).

Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules):
\# contrações
Se o string for "ao", posponha "para o" to o other string; exit.
\Se o string for "à", posponha "para a" to o other string; exit.
Se o string for "aos", posponha "para os" to o other string; exit.
Se o string for "às", posponha "para as" to o other string; exit.
\Se o string for "do", posponha "de o" to o other string; exit.
\Se o string for "da", posponha "de a" to o other string; exit.
\Se o string for "dos", posponha "de os" to o other string; exit.
\Se o string for "das", posponha "de as" to o other string; exit.
\Se o string for "dum", posponha "de um" to o other string; exit.
\Se o string for "duma", posponha "de uma" to o other string; exit.
\Se o string for "dumas", posponha "de umas" to o other string; exit.
\Se o string for "duns", posponha "de uns" to o other string; exit.
Se o string for "daqui", posponha "de aqui" to o other string; exit.
Se o string for "dali", posponha "de ali" to o other string; exit.
Se o string for "dele", posponha "de ele" to o other string; exit.
Se o string for "dela", posponha "de ela" to o other string; exit.
Se o string for "desse", posponha "de esse" to o other string; exit.
Se o string for "dessa", posponha "de essa" to o other string; exit.
Se o string for "desses", posponha "de esses" to o other string; exit.
Se o string for "dessas", posponha "de essas" to o other string; exit.
Se o string for "deste", posponha "de este" to o other string; exit.
Se o string for "desta", posponha "de esta" to o other string; exit.
Se o string for "destes", posponha "de estes" to o other string; exit.
Se o string for "destas", posponha "de estas" to o other string; exit.
Se o string for "disso", posponha "de isso" to o other string; exit.
Se o string for "disto", posponha "de isto" to o other string; exit.
Se o string for "nesse", posponha "em esse" to o other string; exit.
Se o string for "nesses", posponha "em esses" to o other string; exit.
Se o string for "neste", posponha "em este" to o other string; exit.
Se o string for "nestes", posponha "em estes" to o other string; exit.
Se o string for "nisso", posponha "em isso" to o other string; exit.
Se o string for "nisto", posponha "em isto" to o other string; exit.
Se o string for "nessa", posponha "em essa" to o other string; exit.
Se o string for "nessas", posponha "em essas" to o other string; exit.
Se o string for "nesta", posponha "em esta" to o other string; exit.
Se o string for "nestas", posponha "em estas" to o other string; exit.
Se o string for "donde", posponha "de onde" to o other string; exit.
Se o string for "dentre", posponha "de entre" to o other string; exit.
Se o string for "dantes", posponha "de antes" to o other string; exit.
Se o string for "dalguém", posponha "de alguém" to o other string; exit.
Se o string for "dalgum", posponha "de algum" to o other string; exit.
Se o string for "dalguma", posponha "de alguma" to o other string; exit.
Se o string for "dalguns", posponha "de alguns" to o other string; exit.
Se o string for "dalgumas", posponha "de algumas" to o other string; exit.
Se o string for "nalgum", posponha "em algum" to o other string; exit.
Se o string for "nalguma", posponha "em alguma" to o other string; exit.
Se o string for "nalguns", posponha "em alguns" to o other string; exit.
Se o string for "nalgumas", posponha "em algumas" to o other string; exit.
Se o string for "doutro", posponha "de outro" to o other string; exit.
Se o string for "doutra", posponha "de outra" to o other string; exit.
Se o string for "doutros", posponha "de outros" to o other string; exit.
Se o string for "doutras", posponha "de outras" to o other string; exit.
Se o string for "noutro", posponha "em outro" to o other string; exit.
Se o string for "noutra", posponha "em outra" to o other string; exit.
Se o string for "noutros", posponha "em outros" to o other string; exit.
Se o string for "noutras", posponha "em outras" to o other string; exit.
\# "no" pode ser uma negação em inglês.
Se o string for any contraction giving o third string (portuguese rules - "no"), posponha "em o" to o other string; exit.
Se o string for "na", posponha "em a" to o other string; exit.
Se o string for "nos", posponha "em os" to o other string; exit.
Se o string for "nas", posponha "em as" to o other string; exit.
\Se o string for "noutro", posponha "em outro" to o other string; exit.
\Se o string for "noutra", posponha "em outra" to o other string; exit.
\Se o string for "noutros", posponha "em outros" to o other string; exit.
\Se o string for "noutras", posponha "em outras" to o other string; exit.
Se o string for "num", posponha "em um" to o other string; exit.
Se o string for "numa", posponha "em uma" to o other string; exit.
Se o string for "nuns", posponha "em uns" to o other string; exit.
Se o string for "numas", posponha "em umas" to o other string; exit.
Se o string for "pelo", posponha "por o" to o other string; exit.
Se o string for "pela", posponha "por a" to o other string; exit.
Se o string for "pelos", posponha "por os" to o other string; exit.
Se o string for "pelas", posponha "por as" to o other string; exit.
\# sinônimos
Se o string for "adir", posponha "adicionar" to o other string; exit.
Se o string for "agregar", posponha "adicionar" to o other string; exit.
Se o string for "acrescentar", posponha "adicionar" to o other string; exit.
Se o string for "somar", posponha "adicionar" to o other string; exit.
Se o string for "começar", posponha "iniciar" to o other string; exit.
Se o string for "terminar", posponha "finalizar" to o other string; exit.
Se o string for "acabar", posponha "finalizar" to o other string; exit.
Se o string for "completar", posponha "finalizar" to o other string; exit.
Se o string for "colocar", posponha "pôr" to o other string; exit.
Se o string for "mudar", posponha "alterar" to o other string; exit.
Se o string for "limpar", posponha "apagar" to o other string; exit.
Se o string for "ampliar", posponha "aumentar" to o other string; exit.
Se o string for "expandir", posponha "aumentar" to o other string; exit.
Se o string for "alargar", posponha "aumentar" to o other string; exit.
Se o string for "dilatar", posponha "aumentar" to o other string; exit.
Se o string for "estender", posponha "aumentar" to o other string; exit.
Se o string for "prolongar", posponha "aumentar" to o other string; exit.
Se o string for "ampliar", posponha "aumentar" to o other string; exit.
Se o string for "achar", posponha "encontrar" to o other string; exit.
Se o string for "descobrir", posponha "encontrar" to o other string; exit.
Se o string for "buscar", posponha "encontrar" to o other string; exit.
Se o string for "manusear", posponha "manejar" to o other string; exit.
Se o string for "manipular", posponha "manejar" to o other string; exit.
Se o string for "enumerar", posponha "listar" to o other string; exit.
Se o string for "elencar", posponha "listar" to o other string; exit.
Se o string for "selecionar", posponha "escolher" to o other string; exit.
Se o string for "eliminar", posponha "remover" to o other string; exit.
Se o string for "excluir", posponha "remover" to o other string; exit.
Se o string for "retirar", posponha "remover" to o other string; exit.
Se o string for "rodar", posponha "girar" to o other string; exit.
Se o string for "começar", posponha "iniciar" to o other string; exit.
Se o string for "permutar", posponha "trocar" to o other string; exit.
Se o string for "esperar", posponha "aguardar" to o other string; exit.
Se o string for "rascunhar", posponha "esboçar" to o other string; exit.
Se o string for "antepor", posponha "prepor" to o other string; exit.
Posponha o string to o other string.

Etapas necessárias para que se attach address loading code to um texto hexadecimal usando uma variable:
\ loads into edx
Se o variable for inexistente, attach $C7C200000000 to o texto hexadecimal; exit. \ mov edx,0
Se a categoria desta variable for "global", attach $C7C2 e o address desta variable to o texto hexadecimal; exit. \ mov edx,the address da variable
Se a categoria desta variable for "literal", attach $C7C2 e o address desta variable to o texto hexadecimal; exit. \ mov edx,the address da variable
Se a categoria desta variable for "local", attach $8D95 e o offset desta variable to o texto hexadecimal; exit. \ lea edx,[ebp+ the offset da variable]
Se a categoria desta variable for "scratch", attach $8B95 e o offset desta variable to o texto hexadecimal; exit. \ mov edx,[ebp+ the offset da variable]
Se a categoria desta variable não for "parameter", abort with "Erro interno - attach address loading code to um texto hexadecimal usando uma variable"; exit.
Se o by-value alarme desta variable estiver ativo, attach $8D95 e o offset desta variable to o texto hexadecimal; exit. \ lea edx,[ebp+the offset da variable]
Attach $8B95 e o offset desta variable to o texto hexadecimal. \ mov edx,[ebp+ the offset da variable]

Etapas necessárias para que se attach um texto hexadecimal e um address to um fragment:
\ call ou jump
Coloque o address into um número.
Subtraia o address deste fragment from o número.
Subtraia o length deste code deste fragment from o número.
Subtraia o length deste texto hexadecimal from o número.
Subtraia 4 from o número.
Attach o texto hexadecimal e o número to o code deste fragment.

Etapas necessárias para que se attach um texto hexadecimal e um número e another texto hexadecimal to um third texto hexadecimal:
Posponha o texto hexadecimal to o third texto hexadecimal.
Convert o número to um fourth texto hexadecimal.
Posponha o fourth texto hexadecimal to o third texto hexadecimal.
Posponha o other texto hexadecimal to o third texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um número e another número to another texto hexadecimal:
Posponha o texto hexadecimal to o other texto hexadecimal.
Convert o número to um third texto hexadecimal.
Posponha o third texto hexadecimal to o other texto hexadecimal.
Convert o other número to um fourth texto hexadecimal.
Posponha o fourth texto hexadecimal to o other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um alarme to another texto hexadecimal;
Etapas necessárias para que se attach um texto hexadecimal e um número to another texto hexadecimal:
Posponha o texto hexadecimal to o other texto hexadecimal.
Convert o número to um third texto hexadecimal.
Posponha o third texto hexadecimal to o other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal to another texto hexadecimal:
Employ posponha um string to another string.

Etapas necessárias para que se blurt pedaços usando um endereço de memória e um length e um trecho e um offset:
Coloque o first deste trecho mais o offset into another endereço de memória.
Copy pedaços from o endereço de memória to o other endereço de memória por o length.

Etapas necessárias para que se blurt um DOS header into um trecho:
Blurt pedaços usando o whereabouts deste DOS header e o magnitude deste DOS header e o trecho e 0.

Etapas necessárias para que se blurt alguns entries into um trecho:
Obtenha um entry from o entries.
Se o entry for inexistente, cancele.
Blurt o entry into o trecho.
Repita.

Etapas necessárias para que se blurt um entry into um trecho:
Blurt pedaços usando o whereabouts deste name address desta entry e 4 e o trecho e o thunk address desta entry.
Coloque o name address desta entry mais 2 into um address.
Blurt o name desta entry into o trecho at o address.

Etapas necessárias para que se blurt um fragment into um trecho:
Se o code deste fragment estiver em branco, cancele.
Coloque o address deste fragment menos o image base into um address.
Blurt o code deste fragment into o trecho at o address.

Etapas necessárias para que se blurt alguns fragments into um trecho:
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Blurt o fragment into o trecho.
Repita.

Etapas necessárias para que se blurt um import into um trecho:
Blurt pedaços usando o whereabouts deste import header deste import e o magnitude deste import header deste import e o trecho e o header address deste import.
Blurt o name deste import into o trecho at o name address deste import.
Blurt as entries deste import into o trecho.

Etapas necessárias para que se blurt alguns imports into um trecho:
Obtenha um import from o imports.
Se o import for inexistente, cancele.
Blurt o import into o trecho.
Repita.

Etapas necessárias para que se blurt um PE header into um trecho:
Blurt pedaços usando o whereabouts deste PE header e o magnitude deste PE header e o trecho e 256.

Etapas necessárias para que se blurt uma routine into um trecho:
Se o compiled alarme desta routine não estiver ativo, cancele.
Blurt os fragments desta routine into o trecho.

Etapas necessárias para que se blurt alguns routines into um trecho:
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Blurt a routine into o trecho.
Repita.

Etapas necessárias para que se blurt um string into um trecho at um address:
Blurt pedaços usando o first deste string e o length deste string e o trecho e o address.

Etapas necessárias para que se blurt uma variable into um trecho:
Se o compiled alarme desta variable não estiver ativo, cancele.
Se o type desta variable puder ser reduzido para "string", blurt o variable into o trecho (as um string); exit.
Coloque o address desta variable menos o image base into um address. \ Coloque a diferença entre o endreço da variável e a base da imagem em um endereço.
Blurt o data desta variable into o trecho at o address.

Etapas necessárias para que se blurt uma variable into um trecho (as um string):
Coloque o address desta variable menos o image base into um address.
Coloque o length deste data desta variable into um length.
Coloque o address into another address.
Adicione uma prototype string's magnitude to o other address.
Adicione o image base to o other address.
Coloque 0 into o first deste prototype string.
Coloque -1 into o last deste prototype string.
Se o length não for 0, coloque o other address into o first deste prototype string.
Se o length não for 0, coloque o first deste prototype string mais o length menos 1 into o last deste prototype string.
Blurt pedaços usando o whereabouts deste prototype string e a magnitude deste prototype string e o trecho e o address.
Adicione a magnitude deste prototype string to o address.
Blurt os data desta variable into o trecho at o address.

Etapas necessárias para que se blurt alguns variables into um trecho:
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Blurt o variable into o trecho.
Repita.

An zona é um conjunto with um base address, um length e um size.

The break tag é uma tag igual a 1.

Etapas necessárias para que se bubble um monikette:
Se o monikette for inexistente, cancele.
Se o subtexto atual deste monikette não estiver em branco, limpe o subtexto atual deste monikette; exit.
Se o type atual deste monikette for inexistente, cancele.
Se o type atual deste monikette for any built-in type, coloque nil into o type atual deste monikette; exit.
Coloque o base type deste type atual deste monikette into o type atual deste monikette.

An built-in type é um type.

Etapas necessárias para que se calculate o length of um type:
Se o type for inexistente, cancele.
Se o length deste type não for -1, cancele.
Calculate o length of o base type deste type.
Se os fields deste type estiverem vazio, coloque o length deste base type deste type into o length deste type; exit.
Coloque 0 into o length deste type.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from o fields deste type.
Se o field for inexistente, cancele.
Se o redefinition target name deste field não estiver em branco, repita.
Calculate o length of o type deste field.
Adicione o length deste type deste field times a contagem deste field to o length deste type.
Repita.

Etapas necessárias para que se calculate o lengths of alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o length of o type.
Repita.

Etapas necessárias para que se calculate o offsets in um type:
Se o type for inexistente, cancele.
Coloque 0 into um offset.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from os fields deste type.
Se o field for inexistente, cancele.
Se o redefinition target name deste field não estiver em branco, repita.
Coloque o offset into o offset deste field.
Adicione o length deste type deste field times o contagem deste field to o offset.
Repita.

Etapas necessárias para que se calculate o offsets in alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o offsets in o type.
Repita.

Etapas necessárias para que se calculate o redefinition offsets in um type:
Se o type for inexistente, cancele.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from os fields deste type.
Se o field for inexistente, cancele.
Se o redefinition target name deste field estiver em branco, repita.
Encontre another field usando o redefinition target name deste field e os fields deste type.
Se o other field for inexistente, abort with "Redefine inválido. Eu não consigo encontrar o campo '" then o redefinition target name deste field then "' field." e o locus deste field; exit.
Coloque o offset deste other field into o offset deste field.
Repita.

Etapas necessárias para que se calculate o redefinition offsets in alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o redefinition offsets in o type.
Repita.

The calculating cronômetro é um cronômetro.

The call external tag é uma tag igual a 2.

The call indirect tag é uma tag igual a 3.

The call internal tag é uma tag igual a 4.

Etapas necessárias para que se check por invalid optional info on um type:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o target name deste type não estiver em branco, check por invalid optional info on o type (target).
Se o fields deste type não estiverem vazio, check por invalid optional info on o type (fields).
Se o scale deste type não for 0, check por invalid optional info on o type (scale).

Etapas necessárias para que se check por invalid optional info on um type (fields):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "conjunto", abort with "A palavra 'with' só é permitida em conjunto types." e o locus deste type; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info on um type (scale):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "número", abort with "Escalas são permitidas apenas em tipos numéricos." e o locus deste type; exit.

Etapas necessárias para que se check por invalid optional info on um type (target):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", abort with "An palavra 'to' só é permitida em endereço de memória types." e o locus deste type; exit.

Etapas necessárias para que se limpe um field term:
Fill pedaços with o null pedaço starting at o whereabouts deste field term por o magnitude deste field term.

Etapas necessárias para que se limpe um term:
Esvazie o variable deste term.
Limpe o phrase deste term.

The code zona é um zona.

Etapas necessárias para que se compile o bodies of a routines:
Compile o body of a routine called "initialize before run".
Compile o body of a routine called "nosso programa seja executado".
Compile o body of a routine called "finalize after run".

Etapas necessárias para que se compile o body of uma routine:
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o compiled alarme desta routine estiver ativo, cancele.
Ligue o compiled alarme desta routine.
Lance um percorredor on o instruções desta routine.
Mova o percorredor (compilador rules).
Se o token deste percorredor for o ponto&vírgula, compile o body of a routine usando o percorredor (alternate palavraing); exit. \ *** alternate palavraing
Se o token deste percorredor for any employ, compile o body of a routine usando o percorredor (employ); exit.
Coloque a rotina utilizada atualmente into um saved routine.
Coloque a routine into a rotina utilizada atualmente.
Crie o nickname index desta routine usando 101.
Eliminate duplicate nicknames from os parameters desta routine usando o nickname index desta routine.
Compile o body of a routine (prolog).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, pare.
Compile o next statement usando o percorredor.
Repita.
Compile o body of a routine (epilog).
Coloque o saved routine into a rotina utilizada atualmente.

Etapas necessárias para que se compile o body of uma routine (epilog):
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o finalize tag.
Percorra.
Obtenha uma variable from os locals desta routine.
Se o variable for inexistente, pare.
Se o categoria desta variable for "scratch", repita.
Se o type desta variable não deveria ser finalizado, repita.
Adicione another fragment usando o push address tag e o variable.
Encontre another routine usando "~finalize" e o type desta variable.
Se o other routine for inexistente, abort with "Erro interno - compile o body of uma routine (epilog)"; exit.
Adicione um third fragment usando o call internal tag e o other routine.
Repita.
Adicione um fourth fragment usando o epilog tag.

Etapas necessárias para que se compile o body of uma routine (prolog):
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o prolog tag.
Adicione another fragment usando o loop tag.

Etapas necessárias para que se compile o body of a routine called um string:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Encontre uma routine usando o string e o catálogo geral de rotinas.
Se a routine for inexistente, abort with "Eu preciso de uma função para fazer '" then o string then "'."; exit.
Compile o body of a routine.

Etapas necessárias para que se compile o body of uma routine usando um percorredor (alternate palavraing):
\ *** alternate palavraing
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules). \ *** do we need this?
Coloque o next desta routine into um target routine.
Se o target routine for inexistente, abort with "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e o percorredor; exit.
Coloque o moniker desta target routine into o employs moniker desta routine.
Compile o body of o target routine.

Etapas necessárias para que se compile o body of uma routine usando um percorredor (employ):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile uma routine reference usando o percorredor.
Convert a routine reference to o employs moniker desta routine.
Destroy a routine reference.
Se o token deste percorredor não for ".", abort with "Employ statments devem terminar com um ponto, não com '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não estiver em branco, abort with "Somente um employ" e o percorredor; exit.
Encontre another routine usando o employs moniker desta routine e o catálogo geral de rotinas.
Se o other routine for inexistente, abort with "Não consigo encontrar um rotina '" then o employs moniker desta routine then "' que você está tentando empregar." e o locus desta routine; exit.
Compile o body of o other routine.

Etapas necessárias para que se compile o call'd part usando um percorredor e uma variable:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Coloque o name desta variable into o type name desta variable.
Mova o percorredor (compilador rules).
Examine o name desta variable usando o percorredor.

Etapas necessárias para que se compile um endereço dâ pasta:
Compile o endereço dâ pasta (start).
Compile o endereço dâ pasta (load o source files).
Compile o endereço dâ pasta (examine o source files).
Compile o endereço dâ pasta (resolva o types).
Compile o endereço dâ pasta (resolva o globals).
Compile o endereço dâ pasta (compile o headers of a routines).
Compile o endereço dâ pasta (calculate lengths e offsets of types).
Compile o endereço dâ pasta (Adicione o built-in memory routines).
Compile o endereço dâ pasta (catalogue a routines por utility use).
Compile o endereço dâ pasta (compile o bodies of a routines).
Compile o endereço dâ pasta (Adicione e compile o built-in startup routine).
Compile o endereço dâ pasta (offset parameters e variables).
Compile o endereço dâ pasta (address).
Compile o endereço dâ pasta (transmogrify).
Compile o endereço dâ pasta (link).
Compile o endereço dâ pasta (write o exe).
Compile o endereço dâ pasta (stop).

Etapas necessárias para que se compile um endereço dâ pasta (Adicione e compile o built-in startup routine):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando e agrupando um tarefa de inicialização padrão...".
Start o adding built-in startup routine cronômetro.
Adicione e compile o initialize before run e run e finalize after run routine.
Suspenda o adding built-in startup routine cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (Adicione o built-in memory routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando como tarefas predefinidas na memória...".
Start o adding built-in memory routines cronômetro.
Adicione o allocate e deallocate e finalize e destroy routines.
Suspenda o adding built-in memory routines cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (address):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Obtendo endereço dos itens...".
Start o addressing cronômetro.
Coloque 4096 into um address.
Coloque o address into a base desta import zona.
Address o imports usando o address.
Coloque o address menos a base desta import zona into o length desta import zona.
Round o address up to o nearest multiple of 4096.
Coloque o address into a base desta zona de dados.
Address o globals usando o address.
Address o literals usando o address.
Coloque o address menos a base desta zona de dados into o length desta zona de dados.
Round o address up to o nearest multiple of 4096.
Coloque o address into a base desta code zona.
Address a routines usando o address.
Coloque o address menos a base desta code zona into o length desta code zona.
Suspenda o addressing cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (calculate lengths e offsets of types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Calculando tamanhos e deslocamentos...".
Start o calculating cronômetro.
Calculate o lengths of o types.
Calculate o offsets in o types.
Calculate o redefinition offsets in o types.
Suspenda o calculating cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (compile o bodies of a routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando o conteúdo das tarefas...".
Start o compiling routine bodies cronômetro.
Compile o bodies of a routines.
Suspenda o compiling routine bodies cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (compile o headers of a routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando os nomes das tarefas...".
Start o compiling routine headers cronômetro.
Compile o headers of a routines.
Suspenda o compiling routine headers cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (catalogue a routines por utility use):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Catalogando tarefas...".
Start o indexing utilities cronômetro.
Catalogue a routines por utility use.
Scrub o catálogo de rotinas úteis.
Catalogue novamente o catálogo de rotinas úteis.
Suspenda o indexing utilities cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (link):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Elencando arquivos..".
Start o linking cronômetro.
Link.
Suspenda o linking cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (offset parameters e variables):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Deslocando parâmetros e variáveis...".
Start o offsetting cronômetro.
Offset o parameters in a routines.
Offset o locals in a routines.
Suspenda o offsetting cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (load o source files):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Carregando arquivos...".
Start o loading cronômetro.
Load o source files.
Suspenda o loading cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (resolva o globals):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo itens de escopo abrangente...".
Start o resolving globals cronômetro.
Resolva o globals.
Suspenda o resolving globals cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (resolva o types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo tipos...".
Start o resolving types cronômetro.
Resolva o types (expand coisas).
Resolva o types (registro de plurais).
Resolva o types (base types).
Resolva o types (optional info).
Suspenda o resolving types cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (examine o source files):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Analisando arquivos...".
Start o scanning cronômetro.
Examine o source files.
Suspenda o scanning cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (start):
Mostre painel de informações "Iniciando...".
Finalize o compilador.
Start o cronômetro deste compilador.
Initialize o compilador usando o endereço dâ pasta.
Adicione o built-in types.

Etapas necessárias para que se compile um endereço dâ pasta (stop):
Suspenda o cronômetro deste compilador.
Mostre painel de informações "Interrompendo".

Etapas necessárias para que se compile um endereço dâ pasta (transmogrify):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Modificando...".
Start o transmogrifying cronômetro.
Transmogrify a routines.
Suspenda o transmogrifying cronômetro.

Etapas necessárias para que se compile um endereço dâ pasta (write o exe):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Gerando arquivo executável...".
Start o writing cronômetro.
Escreva o exe deste compilador to o endereço exe completo deste compilador.
Se o i/o erro não estiver em branco, abort with o i/o erro.
Suspenda o writing cronômetro.

Etapas necessárias para que se compile um expression usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile um term usando o percorredor.
Coloque o term into o expression.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any operator, cancele.
Se o token deste percorredor for any divided, compile o expression usando o percorredor (divided); repita.
Se o token deste percorredor for any minus, compile o expression usando o percorredor (menos); repita.
Se o token deste percorredor for any plus, compile o expression usando o percorredor (mais); repita.
Se o token deste percorredor for any then, compile o expression usando o percorredor (then); repita.
Se o token deste percorredor for any times, compile o expression usando o percorredor (times); repita.

Etapas necessárias para que se compile um expression usando um percorredor (divided):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any by, abort with "Você deve usar o termo 'divided BY'." e o percorredor; exit.
Se a variable desta expression for inexistente, abort with "Termo 'divided by' inválido, há um erro na variável: '" then a phrase desta expression then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "O seu 'divided by',está errado. Não dá pra dividir por '" then a phrase deste term then "'." e o percorredor; exit.
Adicione um intermediate usando o type name desta expression e o first deste token deste percorredor.
Adicione several fragments usando "coloque" e a variable desta expression e "into" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "divida" e o intermediate e "por" e a variable deste term e o first deste token deste percorredor.
Coloque o intermediate into a variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (menos):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, abort with "O seu 'minus', está errado. Não consigo subtrair o(a) '" then a phrase desta expression then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "O seu 'minus', está errado. Não consigo diminuir do(a) '" then a phrase deste term then "'." e o percorredor; exit.
Adicione um intermediate usando o type name desta expression e o first deste token deste percorredor.
Adicione several fragments usando "coloque" e a variable desta expression e "into" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "subtraia" e a variable deste term e "from" e o intermediate e o first deste token deste percorredor.
Coloque o intermediate into a variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (mais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, abort with "O seu 'plus', está errado. Não consigo somar o '" then a phrase desta expression then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "O seu 'plus', está errado. Não consigo somar um '" then a phrase deste term then "'." e o percorredor; exit.
Adicione um intermediate usando o type name desta expression e o first deste token deste percorredor.
Adicione several fragments usando "coloque" e a variable desta expression e "into" e o intermediate e o first deste token deste percorredor.\aqui muda o coloque
Adicione several fragments usando "adicione" e a variable deste term e "to" e o intermediate e o first deste token deste percorredor. \ aqui muda o add
Coloque o intermediate into a variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (then):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, abort with "O seu 'then', está errado. Eu não entendi o que é o(a) '" then a phrase desta expression then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "O seu 'then', está errado. Eu não sei o que é o(a) '" then a phrase deste term then "'." e o percorredor; exit.
Adicione um intermediate usando "string" e o first deste token deste percorredor.
Adicione o coloque ou convert fragments usando a variable desta expression e o intermediate e o first deste token deste percorredor.
Convert o term por concatenation usando o percorredor.
Adicione several fragments usando "posponha" e a variable deste term e "to" e o intermediate e o first deste token deste percorredor.
Coloque o intermediate into a variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (times):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar o '" then a phrase desta expression then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "O seu 'times', está errado. Eu não sei como multiplicar um '" then a phrase deste term then "'." e o percorredor; exit.
Adicione um intermediate usando o type name desta expression e o first deste token deste percorredor.
Adicione several fragments usando "coloque" e a variable desta expression e "into" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "multiplique" e o intermediate e "por" e a variable deste term e o first deste token deste percorredor.
Coloque o intermediate into a variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile o header of uma routine:
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor on a routine header desta routine.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any decide, compile o header of a routine usando o percorredor (decider); exit.
Se o percorredor for o start of any reverse-possessive function, compile o header of a routine usando o percorredor (reverse-possessive function); exit.
Se o percorredor for o start of any function, compile o header of a routine usando o percorredor (function); exit.
Se o token deste percorredor for "compativelmente", compile o header of a routine usando o percorredor (callback); exit.
Compile o header of a routine usando o percorredor (procedure).

Etapas necessárias para que se compile o header of uma routine usando um percorredor (callback):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Ligue o callback alarme desta routine.
Compile os monikettes desta routine e os parameters desta routine usando o percorredor.
Convert os monikettes desta routine to o moniker desta routine.
Se o moniker desta routine estiver in o catálogo geral de rotinas, abort with "Você já tinha escrito um função '" then o moniker desta routine then "'." e o locus desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma routine usando um percorredor (decider):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any conditional, abort with "Erro na sintaxe do comando 'Para que se determine se'" e o percorredor; exit.
Mova o percorredor (compilador rules).
Ligue o decider alarme desta routine.
Compile os monikettes desta routine e os parameters desta routine usando o percorredor.
Se any of os monikettes desta routine forem negative palavras, abort with "Não consigo me dar bem com palavras negativas em nomes de funções decisoras." e o percorredor; exit.
Convert os monikettes desta routine to o moniker desta routine.
Se o moniker desta routine estiver in o catálogo geral de rotinas, abort with "Você já me contou como'" then o moniker desta routine then "'." e o locus desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma routine usando um percorredor (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o function alarme desta routine.
Adicione um monikette to os monikettes desta routine usando "coloque".
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile os monikettes desta routine e os parameters desta routine usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile os monikettes desta routine e os parameters desta routine usando o percorredor (artigo definido).
Se o token deste percorredor não for any possessive, abort with "Tá faltando um 's por aqui (ou está no lugar errado)." e o percorredor; exit. \ not translated - no possessives in Spanish
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Adicione another monikette to os monikettes desta routine usando "'s " then o name.
Se o token deste percorredor não for "into", abort with "Eu estava esperando um palavra 'into', mas encontrei uma palavra '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to os monikettes desta routine usando "into".
Convert os monikettes desta routine to um moniker.
Se o moniker estiver in o catálogo geral de rotinas, abort with "Eu já sei como '" then o moniker then "'." e o locus desta routine; exit. \ not translated - no possessives in Spanish
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "Estava esperando um artigo indefinido, mas achei isso aqui: '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Compile os monikettes desta routine e os parameters desta routine usando o percorredor (artigo indefinido).
Se o token deste percorredor não estiver em branco, abort with "Tem comandos extras no fim dessa função." e o percorredor; exit. \ not translated - no possessives in Spanish
Convert os monikettes desta routine to o moniker desta routine.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas. \ por employs

Etapas necessárias para que se compile o header of uma routine usando um percorredor (procedure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile os monikettes desta routine e os parameters desta routine usando o percorredor.
Convert os monikettes desta routine to o moniker desta routine.
Se o moniker desta routine estiver in o catálogo geral de rotinas, abort with "Você já escreveu como fazer '" then o moniker desta routine then "'." e o locus desta routines ; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o headers of alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Compile o header of a routine.
Repita.

Etapas necessárias para que se compile um literal usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione o literal to o literals usando o first deste token deste percorredor .
\Se o token deste percorredor for any alarme literal, compile o literal usando o percorredor (alarme); exit.
Se o token deste percorredor for any hex literal, compile o literal usando o percorredor (hex); exit.
Se o token deste percorredor for any numeric literal, compile o literal usando o percorredor (numeric); exit.
Se o token deste percorredor for any endereço de memória literal, compile o literal usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for any string literal, compile o literal usando o percorredor (string); exit.
Abort with "Erro interno - compile um term usando um percorredor (literal)" e o percorredor.

Etapas necessárias para que se compile um literal usando um percorredor (alarme):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um alarme.
Convert o alarme to os data deste literal.
Mova o percorredor (compilador rules).
Coloque "alarme" into o type name deste literal.
Resolva o literal. \\ Que tal utilizar os termos "decifre", "traduza", "destrinche", "decodifique"?

Etapas necessárias para que se compile um literal usando um percorredor (hex):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o token deste percorredor into um parte dâ cifra binária.
Adicione 1 to o first desta parte dâ cifra binária.
Convert o parte dâ cifra binária to o data deste literal.
Mova o percorredor (compilador rules).
Coloque "texto hexadecimal" into o type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - integer):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um número.
Convert o número to os data deste literal.
Mova o percorredor (compilador rules).
Coloque "número" into o type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - ratio):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um ratio.
Convert o ratio to o data deste literal.
Mova o percorredor (compilador rules).
Coloque "ratio" into o type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - with unit of measure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um ratio.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Encontre um type usando o name e o catálogo de tipos.
Se o type for inexistente, abort with "'" then o name then "' é uma unidade de medida inexistente." e o locus deste literal; exit.
Se o type não puder ser reduzido para "número", abort with "'" then o name then "' é uma unidade de medida inválida." e o locus deste literal; exit.
Coloque a scale deste type into um final ratio.
Se a scale deste type for 0, coloque 1/1 into o final ratio.
Multiplique o final ratio por o ratio.
Reduce o final ratio.
Se o denominador deste final ratio for 0, abort with "Parece que essa é uma unidade de medida inválida." e o locus deste literal.
Coloque o numerador deste final ratio dividido por o denominador deste final ratio into um número.
Coloque o name deste type into o type name deste literal.
Convert o número to o data deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor estiver followed por any unit of measure, compile o literal usando o percorredor (numeric - with unit of measure); exit.
Se o token deste percorredor for any integer literal, compile o literal usando o percorredor (numeric - integer); exit.
Se o token deste percorredor for any ratio literal, compile o literal usando o percorredor (numeric - ratio); exit.
Se o token deste percorredor for any mixed literal, compile o literal usando o percorredor (numeric - ratio); exit.

Etapas necessárias para que se compile um literal usando um percorredor (endereço de memória):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert 0 to os data deste literal. \ was nil
Mova o percorredor (compilador rules).
Coloque "endereço de memória" into o type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o token deste percorredor into os data deste literal.
Unquote os data deste literal.
Mova o percorredor (compilador rules).
Coloque "string" into o type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for any artigo definido, compile os monikettes e o parameters usando o percorredor (artigo definido); repita.
Se o percorredor estiver on any artigo indefinido, compile os monikettes e o parameters usando o percorredor (artigo indefinido); repita.
Se o percorredor estiver on any monikette string, compile os monikettes e o parameters usando o percorredor (monikette string); repita.
Abort with "'" then o token deste percorredor then "' não é um nome de função que eu conheça." e o percorredor.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (artigo definido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Anteponha "the " to o name.
Adicione um monikette to os monikettes usando o name.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (artigo indefinido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um parameter to o parameters usando "parameter" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", coloque "segunda" into o name deste parameter.
Se o token deste percorredor for "outro", coloque "segundo" into o name deste parameter.
\CAL
Se o token deste percorredor for "another", coloque "other" into o name deste parameter.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o name destes parameter with o name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o parameter.
Resolva o parameter.
Se o parameter estiver duplicated in o parameters, abort with "Cara, você repetiu o parâmetro '" then o name deste parameter then "'." e o locus deste parameter; exit.
Adicione um monikette to os monikettes usando o type deste parameter.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (monikette string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette to os monikettes usando o token deste percorredor.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile alguns monikettes usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor está on any monikette string, adicione um monikette to os monikettes usando o token deste percorredor; mova o percorredor (compilador rules); repita.
Se o token deste percorredor não for o start of any expression, cancele.
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione another monikette to os monikettes usando o expression.
Repita.

\Etapas necessárias para que se compile alguns monikettes usando um percorredor:
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Se o token deste percorredor for any monikette string, adicione um monikette to os monikettes usando o token deste percorredor; mova o percorredor (compilador rules); repita.
\Se o token deste percorredor não for o start of any expression, cancele.
\Compile um expression usando o percorredor.
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Adicione another monikette to os monikettes usando o expression.
\Repita.

Etapas necessárias para que se compile o next statement usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any conditional, compile o next statement usando o percorredor (if); exit.
Se o token deste percorredor for any loop, compile o next statement usando o percorredor (loop); exit.
Se o token deste percorredor for any privatize, compile o next statement usando o percorredor (privatize); exit.
Se o token deste percorredor não for o start of any statement, abort with "Eu esperava uma declaração aqui, mas encontrei: '" then o token deste percorredor then "'." e o percorredor; exit.
Compile o next statement usando o percorredor (other).
Se o token deste percorredor não for o ponto final, abort with "Acho que tá faltando um pontinho por aqui." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (break):
Adicione um fragment usando o break tag.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (call - external):
Coloque o token deste percorredor into um string.
Unquote o string.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any string literal, abort with "Cara, você precisa colocar os nomes entre aspas, mas você colocou '" then o token deste percorredor then "'." e o percorredor; exit.
Coloque o token deste percorredor into another string.
Unquote o other string.
Mova o percorredor (compilador rules).
Adicione um entry to o imports usando o string e o other string.
Se o token deste percorredor for "with", compile o next statement usando o percorredor (call - with clause).
Se o token deste percorredor for "returning", compile o next statement usando o percorredor returning um term (call - returning part).
Adicione um fragment usando o call external tag e o entry.
Se o term estiver vazio, cancele.
Se a variable deste term for inexistente, abort with "Não entendi bem o que é '" then a phrase deste term then "'." e o percorredor; exit.
Adicione another fragment usando o save eax tag e a variable deste term.

Etapas necessárias para que se compile o next statement usando um percorredor (call - indirect):
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, abort with "Eu não sei o que é '" then a phrase desta expression then "'." e o percorredor; exit.
Se o type desta expression não puder ser reduzido para "endereço de memória", abort with "Eu preciso de um endereço de memória type nesse CALL statement." e o percorredor; exit.
Se o token deste percorredor for "with", compile o next statement usando o percorredor (call - with clause).
Se o token deste percorredor for "returning", compile o next statement usando o percorredor returning um term (call - returning part).
Adicione um fragment usando o call indirect tag e a variable desta expression.
Se o term estiver vazio, cancele.
Se a variable deste term for inexistente, abort with "Acho que essa varíavel é inválida: '" then a phrase deste term then "'." e o percorredor; exit.
Adicione another fragment usando o save eax tag e a variable deste term.

Etapas necessárias para que se compile o next statement usando um percorredor (call - internal):
Compile alguns monikettes usando o percorredor.
Encontre uma routine usando os monikettes.
Se a routine não for inexistente, adicione push fragments usando os monikettes.
Se a routine não for inexistente, destroy os monikettes; adicione um fragment usando o call internal tag e a routine; exit.
Convert os monikettes to um moniker.
Destroy os monikettes.
\Coloque "Eu ainda não aprendi como" into a reply.
\Say o reply.
Coloque o moniker into a reply.
\Say o reply.
Abort with "Eu ainda não aprendi como '" then o moniker then "'." e o percorredor.

Etapas necessárias para que se compile o next statement usando um percorredor (call - with clause):
\ this guy é recursise so parameters obtenha passed right to left
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, abort with "Eu não entendo um variável: '" then a phrase desta expression then "'." e o percorredor; exit.
Se o type desta expression não for value pushable, abort with "'" then o name deste type desta expression then "' não pode ser processado corretamente." e o percorredor; exit.
Se o token deste percorredor for any and, compile o next statement usando o percorredor (call - with clause).
Adicione um fragment usando o push value tag e a variable desta expression.

Etapas necessárias para que se compile o next statement usando um percorredor (call):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any string literal, compile o next statement usando o percorredor (call - external); exit.
Compile o next statement usando o percorredor (call - indirect).

Etapas necessárias para que se compile o next statement usando um percorredor (exit):
Se o decider alarme desta rotina utilizada atualmente estiver ativo, abort with "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" e o percorredor; exit.
Adicione um fragment usando o exit tag.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (if):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile alguns monikettes usando o percorredor.
Remove any negatives from os monikettes returning um alarme.
Encontre uma routine usando os monikettes.
Se a routine não for inexistente, adicione push fragments usando os monikettes.
Se a routine for inexistente, convert os monikettes to um moniker.
Destroy os monikettes.
Se a routine for inexistente, abort with "Preciso de um decider que tenha como palavras: '" then o moniker then "'." e o percorredor; exit.
Se o decider alarme desta routine não estiver ativo, abort with "Cara eu vou precisar de um decider aqui, blz?" e o percorredor; exit.
Se o token deste percorredor não for a vírgula, abort with "Acho que você esqueceu de uma vírgula, eu achei isso aqui: '" then o token deste percorredor then "'." e o percorredor; exit.
Adicione um fragment usando o call internal tag e a routine.
Se o alarme estiver ativo, adicione another fragment usando o not tag.
Adicione um third fragment usando o jump false tag.
Mova o percorredor (compilador rules).
Percorra.
Compile o next statement usando o percorredor (other).
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for o ponto&vírgula, mova o percorredor (compilador rules); repita.
Se o token deste percorredor não for o ponto final, abort with "Você precisa usar um ponto ao invés de usar o termo '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Adicione um fourth fragment usando o end if tag.

Etapas necessárias para que se compile o next statement usando um percorredor (intel):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any hex literal, abort with "Eu preciso de um pouco de machine code, mas o que eu achei foi '" then o token deste percorredor then "'." e o percorredor; exit.
Adicione um fragment usando o intel tag.
Coloque o token deste percorredor into um parte dâ cifra binária.
Adicione 1 to o first desta parte dâ cifra binária.
Convert o parte dâ cifra binária to o code deste fragment.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (loop):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o loop tag.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o ponto final, abort with "Parece que alguém esqueceu de colocar um ponto por aí." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (other):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for any exit, compile o next statement usando o percorredor (exit); exit.
Se o token deste percorredor for any repeat, compile o next statement usando o percorredor (repeat); exit.
Se o token deste percorredor for any break, compile o next statement usando o percorredor (break); exit.
Se o token deste percorredor for any say, compile o next statement usando o percorredor (say); exit.
Se o token deste percorredor for "intel", compile o next statement usando o percorredor (intel); exit.
Se o token deste percorredor for "push", compile o next statement usando o percorredor (push); exit.
Se o token deste percorredor for any call, compile o next statement usando o percorredor (call); exit.
Se o token deste percorredor for any point, compile o next statement usando o percorredor (point); exit.
Se o token deste percorredor for any conditional, abort with "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." e o percorredor; exit.
Se o token deste percorredor for any privatize, abort with "A sentença 'privatizar' não pode ser usada aqui." e o percorredor; exit.
Se o token deste percorredor for any loop, abort with "Usar um percorra dentro de um SE for uma ótima forma de arranjar problemas." e o percorredor; exit.
Se o token deste percorredor for any employ, abort with "'Empregue' deve ser o único imperativo em uma rotina." e o percorredor; exit.
Compile o next statement usando o percorredor (call - internal).

Etapas necessárias para que se compile o next statement usando um percorredor (point):
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Acho que o termo '" then a phrase deste term then "' está vazio." e o percorredor; exit.
Se o categoria deste term for "literal", abort with "Você usou o tipo errado de variável aqui (literal)." e o percorredor.
Se o length deste type deste term não for 4, abort with "Você usou uma variável de comprimento errado (<>4)." e o percorredor.
Se o token deste percorredor não for "to", abort with "Acho que faltou um 'to', mas você usou '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for "routine", abort with "Acho que faltou a palavra 'routine'. Você usou o termo '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile uma routine reference usando o percorredor.
Convert a routine reference to um moniker.
Destroy a routine reference.
Encontre uma routine usando o moniker e o catálogo geral de rotinas.
Se a routine for inexistente, abort with "Não achei a tarefa '" then o moniker then "' que você falou." e o percorredor; exit.
Adicione um fragment usando a routine address tag e a routine.
Coloque a variable deste term into a variable deste fragment.

Etapas necessárias para que se compile o next statement usando um percorredor (privatize):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Comando 'privatize', Inválido. Eu acho que o termo da variável '" then a phrase deste term then "' está vazio." e o percorredor; exit.
Se o categoria deste term não for "parameter", abort with "Você só pode privatizar parâmetros." e o percorredor; exit.
Adicione um local to os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
Coloque o name deste term into o name deste local.
Coloque o nickname deste term into o nickname deste local.
Coloque o type name deste term into o type name deste local.
Resolva o local.
Anteponha "original " to o name deste term.
Se o nickname deste term não estiver em branco, Anteponha "original " to o nickname deste term.
Adicione several fragments usando "coloque" e a variable deste term e "into" e o local e o first deste token deste percorredor.
Se o token deste percorredor não for o ponto final, abort with "Você vive esquecendo dos pontos né?." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (push):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, abort with "Comando 'push' inválido, um expressão '" then a phrase desta expression then "' parece estar vazia." e o percorredor; exit.
Se o type desta expression não for value pushable, abort with "Valores do tipo '" then o name deste type desta expression then "' não podem ser pushed." e o percorredor; exit.
Adicione um fragment usando o push value tag e a variable desta expression.

Etapas necessárias para que se compile o next statement usando um percorredor (repeat):
Adicione um fragment usando o repeat tag.
Mova o percorredor (compilador rules).

\Etapas necessárias para que se compile o next statement usando um percorredor (say):
\Se o decider alarme desta rotina utilizada atualmente não estiver ativo, compile o next statement usando o percorredor (call - internal); exit.
\Mova o percorredor (compilador rules).
\Compile um expression usando o percorredor.
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Se a variable desta expression for inexistente, abort with "No es válido este 'diga', no entiendo la variable '" then a phrase desta expression then "'." e o percorredor; exit.
\Se o type desta expression não puder ser reduzido para "alarme", abort with "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; exit.
\Adicione um fragment usando o load eax tag e a variable desta expression.
\Adicione another fragment usando o exit tag.

Etapas necessárias para que se compile o next statement usando um percorredor (say):
Se o decider alarme desta rotina utilizada atualmente não estiver ativo, compile o next statement usando o percorredor (call - internal); exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any decider literal, abort with "Você precisa terminar com um yes ou no." e o percorredor; exit.
Desative um alarme. Se o token deste percorredor for any positive decider literal, acione o alarme.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o ponto final, abort with "Faltou um ponto. Você usou o termo: '" then o token deste percorredor then "'." e o percorredor; exit.
Adicione um fragment usando o load eax tag e o alarme.
Adicione another fragment usando o exit tag.

Etapas necessárias para que se compile o next statement usando um percorredor returning um term (call - returning part):
Mova o percorredor (compilador rules).
Compile o term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Eu não compreendi o termo da variável '" then a phrase deste term then "'. Ela parece estar vazia." e o percorredor; exit.
Se o type deste term não for value pushable, abort with "Uma varíavel de 1, 2, ou 4-pedaços é necessária na 'returning' clause." e o percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor:
Se o token deste percorredor for "to", mova o percorredor (compilador rules).
Se o percorredor for o start of any function, compile a routine reference usando o percorredor (function); exit.
Se o token deste percorredor for any decide, compile a routine reference usando o percorredor (decide).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for ".", cancele.
Se o token deste percorredor for any artigo definido, compile a routine reference usando o percorredor (artigo definido); repita.
Se o token deste percorredor for any artigo indefinido, compile a routine reference usando o percorredor (artigo indefinido); repita.
Se o percorredor está on any monikette string, compile a routine reference usando o percorredor (monikette string); repita.
Abort with "'" then o token deste percorredor then "' não é válido em um employ statement." e o percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor (decide):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any conditional, abort with "Sempre use DECIDE IF, ao invés de apenas DECIDE com '" then o token deste percorredor then "' logo em seguida." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile uma routine reference usando um percorredor (artigo definido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Anteponha "the " to o name.
Adicione um monikette to a routine reference usando o name.

Etapas necessárias para que se compile uma routine reference usando um percorredor (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette to a routine reference usando "coloque".
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile a routine reference usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile a routine reference usando o percorredor (artigo definido).
Se o token deste percorredor não for any possessive, abort with "Eu estava esperando un 's, mas apareceu '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Adicione another monikette to a routine reference usando "'s " then o name.
Se o token deste percorredor não for "into", abort with "E estava esperando um palavra 'into', mas encontrei '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Adicione um third monikette to a routine reference usando "into".
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "Eu estava esperando um artigo indefinido mas encontrei isso: '" then o token deste percorredor then "'." e o percorredor; exit. \ not translated - no possessives in Spanish
Compile a routine reference usando o percorredor (artigo indefinido).

Etapas necessárias para que se compile uma routine reference usando um percorredor (artigo indefinido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Encontre um type e um nickname usando o name.
Se o type for inexistente, abort with "Employ statement inválido, Eu não sei o que é '" then o name then "'." e o percorredor; exit.
Adicione um monikette to a routine reference usando o type.

Etapas necessárias para que se compile uma routine reference usando um percorredor (monikette string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette to a routine reference usando o token deste percorredor.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile um term usando um percorredor:
Limpe o term.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile o term usando o percorredor (common part).
Se o percorredor está on any simile, cancele. \ added for invisible turtle project ***
\Se o token deste percorredor for "as", compile o term usando o percorredor (as part). \preposição
\Se o token deste percorredor for "tão", compile o term usando o percorredor (as part). \ me parece desnecessário por ser usado apenas em funções.
Se o token deste percorredor for "quão", compile o term usando o percorredor (as part).
Se o token deste percorredor for "quanto", compile o term usando o percorredor (as part).
Se o token deste percorredor for "como", compile o term usando o percorredor (as part).
\Se o token deste percorredor for "que nem", compile o term usando o percorredor (as part).
Se o token deste percorredor for "/", compile o term usando o percorredor (runtime ratio).

Etapas necessárias para que se compile um term usando um percorredor (as part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Comando 'as'inválido. Eu acho que um variável '" then a phrase deste term then "' está vaiza." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "Tá faltando um artigo indefinido depois do 'como', mas você escreveu '" then o token deste percorredor then "' no lugar disso." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine um type name usando o percorredor.
Encontre um type usando o type name e o catálogo de tipos.
Se o type for inexistente, abort with "Eu não sei em qual tipo o '" then o type name then "' se encaixa." e o percorredor; exit.
Adicione um scratch usando o name deste type e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variable deste term e o scratch.
Coloque o scratch into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (common part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for o hífem, compile o term usando o percorredor (negated term); exit.
Se o token deste percorredor for o sinal de adição, compile o term usando o percorredor (posigated term); exit.
Se o token deste percorredor for o start of any variable, compile o term usando o percorredor (variable); exit.
Se o token deste percorredor for o start of any new local, compile o term usando o percorredor (new local); exit.
Se o token deste percorredor for any literal, compile o term usando o percorredor (literal); exit.
Abort with "Faltou um termo por aqui. Só achei isso aqui: '" then o token deste percorredor then "'." e o percorredor.

Etapas necessárias para que se compile um term usando um percorredor (dereference - in place):
Se a variable deste term for inexistente, abort with "Erro interno na função - compile um term usando um percorredor (dereference - in place). Termo vazio" e o percorredor; exit.
Coloque o name deste target type deste type deste term into o type name deste term.
Coloque o target type deste type deste term into o type deste term.
Adicione um fragment usando o dereference tag e a variable deste term.
Limpe o phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (dereference):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Dereference inválido, um variável '" then a phrase deste term then "' parece estar vazia." e o percorredor; exit.
Se o target type deste type deste term for inexistente, abort with "Não consegui identificar o tipo desse target." e o percorredor; exit.
Se a categoria deste term for "scratch", compile o term usando o percorredor (dereference - in place); exit.
Adicione um scratch usando o name deste target type deste type deste term e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variable deste term e o scratch.
Adicione another fragment usando o dereference tag e o scratch.
Coloque o scratch into o variable deste term.
Limpe o phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (literal):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile um literal usando o percorredor.
Coloque o literal into o variable deste term.
Limpe o phrase deste term.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor (negated term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile another term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste other term for inexistente, abort with "Negate inválido, um variável '" then o phrase deste other term then "' parece estar vazia." e o percorredor; exit.
Adicione um intermediate usando o type name deste other term e o first deste token deste percorredor.
Adicione several fragments usando "coloque" e o variable deste other term e "into" e o intermediate e o locus deste other term.
Adicione two fragments usando "negate" e o intermediate e o first deste token deste percorredor.
Coloque o intermediate into o variable deste term.
Limpe o phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (new local):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, abort with "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e o percorredor; exit.
Adicione um local to os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", coloque "segunda" into o name deste local.
Se o token deste percorredor for "outro", coloque "segundo" into o name deste local.
\CAL
Se o token deste percorredor for "another", coloque "other" into o name deste local.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o name deste local with o name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicated in os parameters desta rotina utilizada atualmente, abort with "o parâmetro '" then o name deste local then "' já está sendo usado como parâmetro." e o locus deste local ; exit.
Se o local estiver duplicated in os locals desta rotina utilizada atualmente, abort with "Já existe uma variável local chamada'" then o name deste local then "'. Você tem que dar um nome diferente." e o locus deste local; exit.
Eliminate duplicate nicknames usando o local e o nickname index desta rotina utilizada atualmente.
Coloque o local into a variable deste term.
Limpe a phrase deste term.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor (posigated term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile o term usando o percorredor.
Se a variable deste term for inexistente, abort with "Posigate inválido, o termo da variável'" then a phrase deste term then "' parece estar vazio." e o percorredor; exit.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (possessive - magnitude):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Use da magnitude inválido. An variável '" then a phrase deste term then "' parece estar vazia." e o percorredor; exit.
Adicione um literal to o literals usando o first deste token deste percorredor.
Convert o length deste type deste term to os data deste literal.
Coloque "número" into o type name deste literal.
Resolva o literal.
Coloque o literal into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (possessive - target):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Você usou o target de forma errada. O termo da variável '" then a phrase deste term then "' parece estar vazio." e o percorredor; exit.
Se o type deste term não puder ser reduzido para "endereço de memória", abort with "Você só pode usar target com tipos endereço de memória." e o percorredor; exit.
Compile o term usando o percorredor (dereference).

Etapas necessárias para que se compile um term usando um percorredor (possessive - whereabouts):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Você usou whereabouts da forma errada, erro no termo da variável '" then a phrase deste term then "'." e o percorredor; exit.
Adicione um intermediate usando "endereço de memória" e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variable deste term e o intermediate.
Coloque o intermediate into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (possessive):
\ similar to "compile um term usando um percorredor (reverse-possessive)
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o name for any magnitude, compile o term usando o percorredor (possessive - magnitude); exit.
Se o name for any target, compile o term usando o percorredor (possessive - target); exit.
Se o name for any whereabouts, compile o term usando o percorredor (possessive - whereabouts); exit.
Compile o term usando o percorredor e o name (possessive - field).

Etapas necessárias para que se compile um term usando um percorredor (possessives):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any possessive, cancele.
Compile o term usando o percorredor (possessive).
Repita.

Etapas necessárias para que se compile um term usando um percorredor (runtime ratio):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, abort with "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável '" then a phrase deste term then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile another term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable deste other term for inexistente, abort with "Uso inválido da /, termo vazio da variável: '" then o phrase deste other term then "'." e o percorredor; exit.
Adicione um intermediate usando "ratio" e o first deste token deste percorredor.
Adicione several fragments usando "coloque" e a variable deste term e "e" e a variable deste other term e "into" e o intermediate e o first deste token deste percorredor.
Coloque o intermediate into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (variable):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, abort with "Erro de tarefa vazia, nada pra pull da pilha aqui." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o percorredor está on any reverse-possessive, compile o term usando o percorredor e o name (reverse-possessive); exit.
Encontre uma variable usando o name.
Coloque o variable into a variable deste term.
Coloque "the " into a phrase deste term.
Posponha o name to a phrase deste term.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor e um field name (reverse-possessive):
\ this é recursive \ dahn version 2
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules). \ past o reverse-possessive starter
\Se o token deste percorredor não for "del", Mova o percorredor (compilador rules). \ past o reverse-possessive starter \ gerry added "if" part
\Se o token deste percorredor for "del", adicione 1 to o first deste token deste percorredor. \ makes "del" look like "de el"
Se o token deste percorredor não for any article, abort with "Esperaba un artículo, pero encontré '" then o token deste percorredor then "'."; exit.
Coloque o token deste percorredor into um article token.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o percorredor está on any reverse-possessive, acione um reverse-possessive alarme.
Se o reverse-possessive alarme estiver ativo, compile o term usando o percorredor e o name (reverse-possessive).
Se o reverse-possessive alarme não estiver ativo, compile o term usando o percorredor e o name e o article (reverse-possessive prepare to unwind).
Compile o term usando o field name e o percorredor (reverse-possessive).

Etapas necessárias para que se compile um term usando um percorredor e uma variable name e um article token (reverse-possessive prepare to unwind):
\ dahn version 2
Se o article for o start of any variable, compile o term usando o percorredor e o variable name e o article (reverse-possessive prepare to unwind existing variable); exit.
Compile o term usando o percorredor e o variable name (reverse-possessive prepare to unwind new local).

Etapas necessárias para que se compile um term usando um percorredor e uma variable name e um article token (reverse-possessive prepare to unwind existing variable):
\ dahn version 2
Encontre uma variable usando o variable name.
Se o variable for inexistente, abort with "No se pudo encontrar una variable con el nombre '" then o variable name then "'.".
Coloque o variable into a variable deste term.
Coloque "the " into a phrase deste term.
Posponha o variable name to a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor e uma variable name (reverse-possessive prepare to unwind new local):
\ dahn version 2
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um local to os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", coloque "segunda" into o name deste local.
Se o token deste percorredor for "outro", coloque "segundo" into o name deste local.
\CAL
Se o token deste percorredor for "another", coloque "other" into o name deste local.
Extend o name deste local with o variable name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicated in os parameters desta rotina utilizada atualmente, abort with "O termo '" then o name deste local then "' já está sendo usado como parâmetro." e o locus deste local; exit.
Se o local estiver duplicated in os locals desta rotina utilizada atualmente,abort with "O termo '" then o name deste local then "' já está sendo usado como variável local." e o locus deste local; exit.
Eliminate duplicate nicknames usando o local e o nickname index desta rotina utilizada atualmente.
Coloque o local into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um field name e um percorredor (reverse-possessive):
\ similar to "compile um term usando um percorredor (possessive)" \ dahn
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o field name for any magnitude, compile o term usando o percorredor (possessive - magnitude); exit.
Se o field name for any target, compile o term usando o percorredor (possessive - target); exit.
Se o field name for any whereabouts, compile o term usando o percorredor (possessive - whereabouts); exit.
Compile o term usando o percorredor e o field name (possessive - field).

Etapas necessárias para que se compile um term usando um percorredor e um field term:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o dereference alarme deste field term estiver ativo, compile o term usando o percorredor (dereference).
Se o function deste field term não for inexistente, compile o term usando o percorredor e o field term (function); exit.
Se o categoria deste term for "scratch", compile o term usando o percorredor e o field term (in place); exit.
Coloque o field deste field term into um field.
Adicione um scratch usando o name deste type deste field e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variable deste term e o scratch.
Se o offset deste field não for 0, adicione um third fragment usando o increment tag e o scratch e o offset deste field.
Coloque o scratch into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor e um field term (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o function deste field term into uma routine.
Coloque o last destes parameters desta routine into um parameter.
Se o parameter for inexistente, abort with "Erro interno na função compile um term usando um percorredor e um field term (function) - parâmetro vazio." e o percorredor; exit.
Se o type deste parameter for inexistente, abort with "Erro interno 2 na função compile um term usando um percorredor e um field term (function) - tipo do parâmetro inexistente." e o percorredor; exit.
Adicione um intermediate usando o name deste type deste parameter e o first deste token deste percorredor.
Adicione um fragment usando o push address tag e o intermediate.
Se o push alarme deste field term estiver ativo, adicione another fragment usando o push address tag e a variable deste term.
Adicione um third fragment usando o call internal tag e a routine.
Coloque o intermediate into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor e um field term (in place):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o field deste field term into um field.
Coloque o name deste type deste field into o type name deste term.
Coloque o type deste field into o type deste term.
Se o offset deste field não for 0, adicione um third fragment usando o increment tag e a variable deste term e o offset deste field.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor e um name (possessive - field):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term não for inexistente, coloque o type deste term into um type.
Encontre um field term usando o phrase deste term e o type e o name.
Se o field term não for vazio, compile o term usando o percorredor e o field term; exit.
Se a variable deste term for inexistente, abort with "Erro: variável vazia '" then a phrase deste term then "'." e o percorredor; exit.
Se o type puder ser reduzido para "endereço de memória", coloque o target type deste type into o type.
Se o type for inexistente, abort with "Não existe o campo '" then o name then "' no tipo '" then o name deste type deste term then "'." e o percorredor; exit.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from os fields deste type.
Se o field for inexistente, abort with "Não tem nenhum campo '" then o name then "' no tipo '" then o name deste type deste term then "'." e o percorredor; exit.
Encontre um deep field term usando "" e o type deste field e o name.
Se o deep field term estiver vazio, repita.
Coloque o field into um first field term's field.
Se o type deste term puder ser reduzido para "endereço de memória", acione o dereference alarme deste first field term.
Compile o term usando o percorredor e o first field term.
Compile o term usando o percorredor e o deep field term.

The compilador é um conjunto with
An endereço dâ pasta,
An cronômetro,
An abort alarme,
An alarme de alerta, \new line
An mensagem de erro,
An abort endereço completo,
An abort row#,
An name contagem,
An exe trecho,
An listing trecho.

The compiling routine bodies cronômetro é um cronômetro.

The compiling routine headers cronômetro é um cronômetro.

Etapas necessárias para que se convert alguns monikettes to um moniker:
Convert os monikettes to o moniker usando o last destes monikettes.

Etapas necessárias para que se convert alguns monikettes to um moniker usando um monikette:
Limpe o moniker.
Percorra.
Obtenha um current monikette from os monikettes.
Se o current monikette for inexistente, cancele.
Posponha o current monikette to o moniker.
Se o current monikette for o monikette, cancele.
Repita.

Etapas necessárias para que se convert uma parte dâ cifra binária to um string:
Employ convert um texto dâ cifra binária to um texto hexadecimal.

Etapas necessárias para que se convert um term por concatenation usando um percorredor:
\ used for right-side THEN operand
Se a variable deste term for inexistente, abort with "Erro: variável do termo está vazia '" then a phrase deste term then "'." e o percorredor; exit.
Se o type deste term puder ser reduzido para "string", cancele.
Adicione um intermediate usando "string" e o first deste token deste percorredor.
Adicione o coloque ou convert fragments usando a variable deste term e o intermediate e o first deste token deste percorredor.
Coloque o intermediate into a variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se copy um field into another field:
Se o field for inexistente, esvazie o other field; exit.
Allocate memory por o other field.
Coloque o locus deste field into o locus deste other field.
Coloque o name deste field into o name deste other field.
Coloque o nickname deste field into o nickname deste other field.
Coloque o type name deste field into o type name deste other field.
Coloque o type deste field into o type deste other field.
Coloque a contagem deste field  into a contagem deste other field.
Coloque o redefinition target name deste field into o redefinition target name deste other field.
Coloque o reference alarme deste field into o reference alarme deste other field.
Coloque o offset deste field into o offset deste other field.

Etapas necessárias para que se copy alguns fields into alguns other fields:
Obtenha um field from o fields.
Se o field for inexistente, cancele.
Copy o field into another field.
Posponha o other field to o other fields.
Repita.

Etapas necessárias para que se copy alguns fields into alguns other fields (data fields only):
Se a contagem destes fields for menor du que 4, cancele. \ for english next e prev e spanish next e prev redefinitions
\Se o first destes fields for inexistente, cancele.
\Se o next deste first destes fields for inexistente, cancele.
\Se o next deste next deste first destes fields for inexistente, cancele.
\\Coloque o next deste next deste first destes fields into um field. \ skip next e prev
\Se o next deste next deste next deste first destes fields for inexistente, cancele.
\Se o next deste next deste next deste next deste first destes fields for inexistente, cancele.
\Se o next deste next deste next deste next deste next deste first destes fields for inexistente, cancele.
\Coloque o next deste next deste next deste next deste first destes fields into um field.
Coloque o next deste next deste next deste next deste first destes fields into um field.\ english next e prev e spanish next e prev redefinitions
Percorra.
Se o field for inexistente, cancele.
Copy o field into another field.
Posponha o other field to o other fields.
Obtenha o field from o fields.
Repita.

Etapas necessárias para que se copy um monikette into another monikette:
Se o monikette for inexistente, esvazie o other monikette; exit.
Allocate memory por o other monikette.
Coloque o string deste monikette into o string deste other monikette.
Coloque o type deste monikette into o type deste other monikette.
Coloque a variable deste monikette into o variable deste other monikette.
\ don't copy subtexto
Coloque o type atual deste monikette into o type atual deste other monikette.

Etapas necessárias para que se copy alguns monikettes into alguns other monikettes:
Destroy o other monikettes.
Percorra.
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Copy o monikette into another monikette.
Posponha o other monikette to o other monikettes.
Repita.

Etapas necessárias para que se crie um entry:
Allocate memory por o entry.

Etapas necessárias para que se crie um fragment usando uma tag:
Allocate memory por o fragment.
Coloque o tag into a tag deste fragment.

Etapas necessárias para que se crie um import:
Allocate memory por o import.

Etapas necessárias para que se crie um monikette:
Allocate memory por o monikette.

Etapas necessárias para que se crie uma routine:
Allocate memory por a routine.

Etapas necessárias para que se crie um source file:
Allocate memory por o source file.

Etapas necessárias para que se crie um type:
Allocate memory por o type.
Coloque 0/1 into o scale deste type.
Coloque -1 into o length deste type.

Etapas necessárias para que se crie uma variable usando um categoria:
Allocate memory por o variable.
Coloque o categoria into a categoria desta variable.
Coloque 1 into o contagem desta variable.

The endereço du cabeçalho usado atualmente é um address.

The endereço du nome usado atualmente é um address.

The rotina utilizada atualmente é uma routine.

The current thunk address é um address.

The zona de dados é um zona.

Etapas necessárias para que se determine se any of alguns monikettes são negative palavras:
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, diga não.
Se o string deste monikette for any negative palavra, diga sim.
Repita.

Etapas necessárias para que se determine se um pedaço é any glom pedaço:
Se o pedaço for any letter, diga sim.
Se o pedaço for any digit, diga sim.
Se o pedaço for o acento til, diga sim.
Se o pedaço for o sinal de arroba, diga sim.
Se o pedaço for o número-sign pedaço, diga sim.
Se o pedaço for o sinal de porcentagem, diga sim.
Se o pedaço for o & comercial, diga sim.
Se o pedaço for o underscore pedaço, diga sim.
Se o pedaço for o single-quote pedaço, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any mark:
Se o pedaço for o ponto final, diga sim.
Se o pedaço for o vírgula, diga sim.
Se o pedaço for o ponto&vírgula, diga sim.
Se o pedaço for o sinal de dois pontos, diga sim.
Se o pedaço for o exclamation pedaço, diga sim.
Se o pedaço for o question-mark pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any stressed vowel:
Se o pedaço estiver in "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
Diga não.

Etapas necessárias para que se determine se um pedaço é any symbol:
Se o pedaço for o caret pedaço, diga sim.
Se o pedaço for o barra vertical, diga sim.
Se o pedaço for o asterisco, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Se o pedaço for o left-alligator pedaço, diga sim.
Se o pedaço for o right-alligator pedaço, diga sim.
Se o pedaço for o left-brace pedaço, diga sim.
Se o pedaço for o right-brace pedaço, diga sim.
Se o pedaço for o sinal de igualdade, diga sim.
Se o pedaço for 128, diga sim.
Se o pedaço for 130, diga sim.
Se o pedaço estiver entre 132 e 137, diga sim.
Se o pedaço for 139, diga sim.
Se o pedaço estiver entre 145 e 153, diga sim.
Se o pedaço for 155, diga sim.
Se o pedaço estiver entre 161 e 180, diga sim.
Se o pedaço estiver entre 183 e 191, diga sim.
Se o pedaço for 215, diga sim.
Se o pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um field term está vazia;
Etapas necessárias para que se determine se um field term estão vazias;
Etapas necessárias para que se determine se um field term estão vazios;
Etapas necessárias para que se determine se um field term está vazio:
Se o field deste field term não for inexistente, diga não.
Se a function deste field term não for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se alguns fields deveriam ser finalizados;
Etapas necessárias para que se determine se alguns fields deveria ser finalizado:
Obtenha um field from o fields.
Se o field for inexistente, diga não.
Se o type deste field deveria ser finalizado, diga sim.
Repita.

Etapas necessárias para que se determine se um item looks reamish:
Load o endereço completo deste item into um trecho.
Se o trecho starts with "ream cal", diga sim.
Diga não.

Etapas necessárias para que se determine se um moniker estiver in um index:
Encontre um refer usando o moniker e o index.
Se o refer for inexistente, diga não.
Se o endereço de memória deste refer for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se o monikette for inexistente, diga sim.
Se o type atual deste monikette não for inexistente, diga não.
Se o subtexto atual deste monikette não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um name é any magnitude:
\PAL
Se o name for "magnitude", diga sim.
\CAL
Se o name for "magnitud", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any target:
\PAL
Se o name for "conteúdo", diga sim.
Se o name for "alvo", diga sim.
\CAL
Se o name for "target", diga sim.
Se o name for "objetivo", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any whereabouts:
\PAL
Se o name for "paradeiro", diga sim.
\CAL
Se o name for "whereabouts", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any valid field name:
Se o name for any magnitude, diga não.
Se o name for any target, diga não.
Se o name for any whereabouts, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está followed por any unit of measure:
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o percorredor não for on any name starter, diga não.
Examine um name usando o percorredor.
Encontre um type usando o name e o catálogo de tipos.
Se o type for inexistente, diga não.
Se o name não for "times", diga sim. \ special because times é um infix operator e um unit of measure
\Se o name não for "vezes", diga sim.
Se o token deste percorredor for o start of any expression, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any nested double-quote:
Se o source deste percorredor starts with """""", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive:
Se o source deste percorredor estiver em branco, diga não.
Se o target deste first deste source deste percorredor não for o single-quote pedaço, diga não.
Se o percorredor estiver on any possessive (type 1 - single-quote, s, non-glom-byte), diga sim.
Se o percorredor estiver on any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive (type 1 - single-quote, s, non-glom-byte):
Se o source deste percorredor does not start with "'s", diga não.
Isole o percorredor.
Adicione 2 to o first deste source deste percorredor .
Se o source deste percorredor estiver em branco, diga sim.
Se o target deste first deste source deste percorredor não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Isole o percorredor.
Se o first deste source deste percorredor for o first deste subtexto original deste percorredor, diga não.
Subtraia 1 from o first deste source deste percorredor.
Se o target deste first deste source deste percorredor não for o little-s pedaço ou o S maiúsculo, diga não.
Adicione 2 to o first deste source deste percorredor.
Se o source deste percorredor estiver em branco, diga sim.
Se o target deste first deste source deste percorredor não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any simile:
\ added for invisible turtle project ***
Isole o percorredor.
Se o token deste percorredor for "LIKE", diga sim.
Se o token deste percorredor não for "AS", diga não.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor é o start of any function:
Se o alarme de alerta deste compilador estiver ativado, diga não.
Se o token deste percorredor for "Ponha", diga sim.
\Se o token deste percorredor não for any coloque, diga não.
Se o token deste percorredor não for "coloque", diga não.
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any article, diga não.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o token deste percorredor for any possessive, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any contraction giving another string (portuguese rules - "no"):
Se o string não for "no", diga não.
Se o other string for "say", diga não.
Se o other string for "diga", diga não.
\Se o other string for "dizer", diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant e another string:
Lance um subtexto on o string.
Subtraia o length deste other string from o last deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o target deste last deste subtexto não for any consonant, diga não.
Se o string does not end with o other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel e another string:
Lance um subtexto on o string.
Subtraia o length deste other string from o last deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o target deste last deste subtexto não for any vowel, diga não.
Se o string does not end with o other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant:
Se o string estiver em branco, diga não.
Se o target deste last deste string não for any consonant, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel:
Se o string estiver em branco, diga não.
Se o target deste last deste string não for any vowel, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any plus:
\PAL
Se o string for "mais", diga sim.
\CAL
Se o string for "plus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any coloque:
\PAL
Se o string for "pôr", diga sim.
\# Não precisa porque está como sinônimo: ver "Etapas necessárias para que se posponha um string to another string giving um third string (portuguese contractions e synonyms rules)"
\Se o string for "colocar", diga sim.
\CAL
Se o string for "coloque", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any minus:
\PAL
Se o string for "menos", diga sim.
\CAL
Se o string for "minus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any times:
\PAL
Se o string for "vezes", diga sim.
\CAL
Se o string for "times", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any divided:
\PAL
Se o string for "dividido", diga sim.
\CAL
Se o string for "divided", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any by:
\PAL
Se o string for "via", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se o string for "por", diga sim.
\CAL
Se o string for "by", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any then:
\PAL
\# operador de concatenação de strings tipo: "abc" then "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida".
Se o string for "depois", diga sim.
Se o string for "então", diga sim.
\CAL
Se o string for "then", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any has:
\PAL
Se o string for "tem", diga sim.
Se o string for "têm", diga sim.
Se o string for "possui", diga sim.
Se o string for "possuem", diga sim.
\CAL
Se o string for "has", diga sim.
Se o string for "have", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any is:
\PAL
Se o string for "é", diga sim.
Se o string for "está", diga sim.
Se o string for "são", diga sim.
Se o string for "estão", diga sim.
Se o string for "for", diga sim.
Se o string for "forem", diga sim.
Se o string for "estiverem", diga sim.
Se o string for "estarem", diga sim.
\CAL
Se o string for "is", diga sim.
Se o string for "are", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operador de atribuição:
\PAL
Se o string for "igual", diga sim.
\CAL
Se o string for "equal", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any with:
\PAL
Se o string for "com", diga sim.
\CAL
Se o string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any article:
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se o string for "e", diga sim.
Se o string for "ou", diga sim.
Se o string for "nem", diga sim.
\CAL
Se o string for "and", diga sim.
Se o string for "both", diga sim.
Se o string for "but", diga sim.
Se o string for "either", diga sim.
Se o string for "neither", diga sim.
Se o string for "nor", diga sim.
Se o string for "or", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any alarme literal:
\Se o string for "yes", diga sim.
\Se o string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any to:
\PAL
Se o string for "a", diga sim. \ this é questionable
\CAL
Se o string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any and:
\PAL
Se o string for "e", diga sim.
\CAL
Se o string for "and", diga sim.
Diga não. \repetido?

Etapas necessárias para que se determine se um string é any reverse-possessive function into:
\PAL
Se o string for "em", diga sim.
\CAL
Se o string for "into", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any alarme literal:
\Se o string for "si", diga sim.
\Se o string for "yes", diga sim.
\Se o string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any decider literal:
\PAL
Se o string for "sim", diga sim.
Se o string for "positivo", diga sim.
Se o string for "positivamente", diga sim.
Se o string for "afirmativamente", diga sim.
Se o string for "não", diga sim.
Se o string for "negativo", diga sim.
Se o string for "negativamente", diga sim.
\CAL
Se o string for "yes", diga sim.
\Se o string for "yep", diga sim.
\Se o string for "yea", diga sim.
Se o string for "no", diga sim.
\Se o string for "nay", diga sim.
\Se o string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any positive decider literal:
\PAL
Se o string for "sim", diga sim.
Se o string for "positivo", diga sim.
Se o string for "positivamente", diga sim.
Se o string for "afirmativamente", diga sim.
\CAL
Se o string for "yes", diga sim.
\Se o string for "yep", diga sim.
\Se o string for "yea", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any negative decider literal:
\PAL
Se o string for "não", diga sim.
Se o string for "negativo", diga sim.
Se o string for "negativamente", diga sim.
\CAL
Se o string for "no", diga sim.
\Se o string for "nay", diga sim.
\Se o string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any hex literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string for o cifrão, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo definido:
\PAL
Se o string for "o", diga sim.
Se o string for "a", diga sim.
Se o string for "os", diga sim.
Se o string for "as", diga sim.
Se o string for any pronome demonstrativo adjacente, diga sim.
\CAL
Se o string for "the", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo:
\CEL
Se o string for any pronome demonstrativo adjacente, diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo adjacente:
\CEL
Se o string for "este", diga sim.
Se o string for "esta", diga sim.
Se o string for "estes", diga sim.
Se o string for "estas", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo abrangente:
\CEL
Se o string for "esse", diga sim.
Se o string for "essa", diga sim.
Se o string for "aquele", diga sim.
Se o string for "aquela", diga sim.
Se o string for "esses", diga sim.
Se o string for "essas", diga sim.
Se o string for "aqueles", diga sim.
Se o string for "aquelas", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any artigo definido:
Se o percorredor estiver on any preposição conectiva, diga não.
Se o token deste percorredor não for any artigo definido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any artigo indefinido:
Se o percorredor estiver on any preposição conectiva, diga não.
Se o token deste percorredor não for any artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está on any preposição conectiva:
Se o token deste percorredor não for "a", diga não.
Isole o percorredor. Mova o percorredor (compilador rules).
Se o token deste percorredor for any article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo indefinido:
\PAL
Se o string for any artigo definido português, diga sim.
\CAL
Se o string for any artigo definido inglês, diga sim.
\Se o string for "a", diga sim.
Se o string for "an", diga sim.
Se o string for "another", diga sim.
Se o string for "some", diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo definido inglês:
\CAL
Se o string for "an", diga sim.
Se o string for "another", diga sim.
Se o string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo definido português:
\PAL
Se o string for "um", diga sim.
Se o string for "uma", diga sim.
Se o string for "outro", diga sim.
Se o string for "outra", diga sim.
Se o string for "algum", diga sim.
Se o string for "alguma", diga sim.
Se o string for "alguns", diga sim.
Se o string for "algumas", diga sim.
Diga não.



Etapas necessárias para que se determine se um string é any literal:
Se o string for any endereço de memória literal, diga sim.
Se o string for any numeric literal, diga sim.
Se o string for any string literal, diga sim.
\Se o string for any alarme literal, diga sim. ***
Se o string for any hex literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any mark:
Se o length deste string não for 1, diga não.
Se o target deste first deste string for any mark, diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any monikette string:
\Se o string estiver em branco, diga não.
\Se o string for "the", diga não.
\Se o string é any artigo indefinido, diga não.
\Se o string é any possessive, diga não.
\Se o string é any literal, diga não.
\Se o string é any mark, diga não.
\Se o string é any symbol, diga não.
\Diga sim.

Etapas necessárias para que se determine se um percorredor está on any monikette string:
Se o token deste percorredor estiver em branco, diga não.
Se o percorredor estiver on any artigo definido, diga não.
Se o percorredor estiver on any artigo indefinido, diga não.
Se o token deste percorredor for any possessive, diga não.
Se o token deste percorredor for any literal, diga não.
Se o token deste percorredor for any mark, diga não.
Se o token deste percorredor for any symbol, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any called:
\PAL
Se o string for "chamado", diga sim.
Se o string for "chamada", diga sim.
\CAL
Se o string for "called", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name ender:
\ compare with name starter
Se o string for any mark, diga sim.
Se o string for any symbol, diga sim.
Se o string for any article, diga sim.
Se o string for any conjunction, diga sim.
Se o string for any possessive, diga sim.
Se o string for any verb, diga sim.
Se o string for any operator, diga sim.
Se o string for any preposition, diga sim.
Se o string for any qualifier, diga sim.
Se o string for any literal, diga sim.
Se o string for "called", diga sim.
Se o string for "equal", diga sim.
Se o string estiver em branco, diga sim.
Diga não.
Etapas necessárias para que se determine se um string é any reference:
\PAL
Se o string for "(referência)", diga sim.
\CAL
Se o string for "(reference)", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any name ender:
\ compare with name starter
Se o token deste percorredor for any mark, diga sim.
Se o token deste percorredor for any symbol, diga sim.
Se o token deste percorredor for any article, diga sim.
Se o token deste percorredor for any conjunction, diga sim.
Se o token deste percorredor for any possessive, diga sim.
Se o percorredor estiver on any reverse-possessive, diga sim.
Se o token deste percorredor for any verb, diga sim.
Se o token deste percorredor for any operator, diga sim.
Se o percorredor estiver on any preposition, diga sim.
Se o token deste percorredor for any qualifier, diga sim.
Se o token deste percorredor for any literal, diga sim.
Se o token deste percorredor for any called, diga sim.
Se o token deste percorredor for any operador de atribuição, diga sim.
Se o token deste percorredor estiver em branco, diga sim.
\ Portuguese trouble makers
Se o token deste percorredor for any negative palavra, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name starter:
\ compare with name ender
Se o string for any mark, diga não.
Se o string for any symbol, diga não.
Se o string for any article, diga não.
Se o string for any conjunction, diga sim.
Se o string for any possessive, diga não.
Se o string for any verb, diga sim.
Se o string for any operator, diga sim.
Se o string for any preposition, diga sim.
Se o string for any qualifier, diga não.
Se o string for any literal, diga não.
Se o string for "called", diga sim.
Se o string for "equal", diga sim.
Se o string estiver em branco, diga não.
Diga sim.
Etapas necessárias para que se determine se um percorredor está on any name starter:
\ compare with name ender
Se o token deste percorredor for any mark, diga não.
Se o token deste percorredor for any symbol, diga não.
Se o token deste percorredor for any article, diga não.
Se o token deste percorredor for any conjunction, diga sim.
Se o token deste percorredor for any possessive, diga não.
Se o token deste percorredor for any verb, diga sim.
Se o token deste percorredor for any operator, diga sim.
Se o percorredor estiver on any preposition, diga sim.
Se o token deste percorredor for any qualifier, diga não.
Se o token deste percorredor for any literal, diga não.
Se o token deste percorredor for any called, diga sim.
Se o token deste percorredor for any operador de atribuição, diga sim.
Se o token deste percorredor estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any negative palavra:
\SAL
Se o string for "não", diga sim.
\Se o string for "nada", diga sim.
\Se o string for "ainda", diga sim.
\CAL
\Se o string for "no", diga sim.
Se o string for "not", diga sim.
Se o string for "cannot", diga sim.
Se o string for "nothing", diga sim.
Se o string ends with "n't", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operator:
\PAL
Se o string for "mais", diga sim.
Se o string for "menos", diga sim.
Se o string for "vezes", diga sim.
Se o string for "dividido", diga sim.
Se o string for "depois", diga sim.
Se o string for "então", diga sim.
\CAL
Se o string for "plus", diga sim.
Se o string for "minus", diga sim.
Se o string for "times", diga sim.
Se o string for "divided", diga sim.
Se o string for "then", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any artigo definido inglês:
\Se o string for "a", diga sim.
\Se o string for "an", diga sim.
\Se o string for "another", diga sim.
\Se o string for "some", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any pause:
\PAL
Se o string for "e", diga sim.
Se o string for "ou", diga sim.
\CAL
Se o string for "and", diga sim.
Se o string for "or", diga sim.
\default
Se o string for ",", diga sim.
Se o string for ";", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any endereço de memória literal:
\PAL
Se o string for "nulo", diga sim.
Se o string for "nula", diga sim.
Se o string for "inexistente", diga sim.
\CAL
Se o string for "nil", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any possessive:
Se o string for "'s", diga sim.
Se o string for "'", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está on any preposition:
Coloque o token deste percorredor into um subtexto.
\PAL
Se o percorredor estiver on any preposição conectiva, diga sim. \ "a" followed por um article for "to" in portuguese
Se o subtexto for "abaixo", diga sim. \ down
Se o subtexto for "acima", diga sim. \ up
Se o subtexto for "ante", diga sim. \ antes de
Se o subtexto for "antes", diga sim. \ antes de
Se o subtexto for "perante", diga sim. \ antes de
Se o subtexto for "debaixo", diga sim. \ below
Se o subtexto for "sob", diga sim. \ below
Se o subtexto for "acerca", diga sim. \ near
Se o subtexto for "próximo", diga sim. \ near
Se o subtexto for "perto", diga sim. \ near
Se o subtexto for "com", diga sim. \ with
Se o subtexto for "como", diga sim. \ as
Se o subtexto for "contra", diga sim. \ against
\ Se o subtexto for "de", diga sim. \ reverse-possessive indicator 
Se o subtexto for "dada", diga sim. \ given
Se o subtexto for "dado", diga sim. \ given
Se o subtexto for "dando", diga sim. \ given
Se o subtexto for "gerando", diga sim. \ giving
Se o subtexto for "resultando", diga sim. \ giving
Se o subtexto for "retornando", diga sim. \ giving
Se o subtexto for "direita", diga sim. \ right
Se o subtexto for "desde", diga sim. \ since
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "durante", diga sim. \ during
Se o subtexto for "em", diga sim. \ in
Se o subtexto for "entre", diga sim. \ between
Se o subtexto for "até", diga sim. \ until
Se o subtexto for "esquerda", diga sim. \ left
Se o subtexto for "mediante", diga sim. \ through
Se o subtexto for "para", diga sim. \ to
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "segundo", diga sim. \ according
Se o subtexto for "sem", diga sim. \ without
Se o subtexto for "então", diga sim.
Se o subtexto for "sobre", diga sim. \ on
Se o subtexto for "após", diga sim. \ after
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "usando", diga sim. \ using
Se o subtexto for "versus", diga sim. \ versus
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "enquanto", diga sim. \ while
Se o subtexto for "redefinindo", diga sim. \# 'at' na redefinição de campos 
\CAL
Se o subtexto for "about", diga sim.
Se o subtexto for "above", diga sim.
Se o subtexto for "across", diga sim.
Se o subtexto for "after", diga sim.
Se o subtexto for "against", diga sim.
Se o subtexto for "all", diga sim.
Se o subtexto for "alone", diga sim.
Se o subtexto for "along", diga sim.
Se o subtexto for "among", diga sim.
Se o subtexto for "any", diga sim.
Se o subtexto for "anywhere", diga sim.
Se o subtexto for "around", diga sim.
\Se o subtexto for "as", diga sim.
Se o subtexto for "at", diga sim.
Se o subtexto for "away", diga sim.
Se o subtexto for "back", diga sim.
Se o subtexto for "backward", diga sim.
Se o subtexto for "backwards", diga sim.
Se o subtexto for "antes de", diga sim.
Se o subtexto for "beginning", diga sim.
Se o subtexto for "behind", diga sim.
Se o subtexto for "below", diga sim.
Se o subtexto for "beneath", diga sim.
Se o subtexto for "beside", diga sim.
Se o subtexto for "between", diga sim.
Se o subtexto for "beyond", diga sim.
Se o subtexto for "bigger", diga sim.
Se o subtexto for "by", diga sim.
Se o subtexto for "close", diga sim.
Se o subtexto for "deep", diga sim.
Se o subtexto for "diagonally", diga sim.
Se o subtexto for "down", diga sim.
Se o subtexto for "downward", diga sim.
Se o subtexto for "ending", diga sim.
Se o subtexto for "everywhere", diga sim.
Se o subtexto for "except", diga sim.
Se o subtexto for "finishing", diga sim.
Se o subtexto for "facing", diga sim.
\Se o subtexto for "for", diga sim.
Se o subtexto for "por", diga sim.
Se o subtexto for "forward", diga sim.
Se o subtexto for "from", diga sim.
Se o subtexto for "given", diga sim.
Se o subtexto for "giving", diga sim.
Se o subtexto for "high", diga sim.
Se o subtexto for "in", diga sim.
Se o subtexto for "inside", diga sim.
Se o subtexto for "into", diga sim.
Se o subtexto for "en", diga sim.
Se o subtexto for "larger", diga sim.
Se o subtexto for "leaning", diga sim.
Se o subtexto for "left", diga sim.
Se o subtexto for "leftward", diga sim.
Se o subtexto for "leftways", diga sim.
Se o subtexto for "like", diga sim.
Se o subtexto for "limiting", diga sim.
Se o subtexto for "long", diga sim.
Se o subtexto for "near", diga sim.
Se o subtexto for "of", diga sim.
Se o subtexto for "off", diga sim.
Se o subtexto for "on", diga sim.
Se o subtexto for "only", diga sim.
Se o subtexto for "onto", diga sim.
Se o subtexto for "out", diga sim.
Se o subtexto for "outside", diga sim.
Se o subtexto for "over", diga sim.
Se o subtexto for "past", diga sim.
Se o subtexto for "pointing", diga sim.
Se o subtexto for "returning", diga sim.
Se o subtexto for "right", diga sim.
Se o subtexto for "rightward", diga sim.
Se o subtexto for "rightways", diga sim.
Se o subtexto for "shorter", diga sim.
Se o subtexto for "sideway", diga sim.
Se o subtexto for "sideways", diga sim.
Se o subtexto for "similar", diga sim.
Se o subtexto for "smaller", diga sim.
Se o subtexto for "somewhere", diga sim.
Se o subtexto for "slantwise", diga sim.
Se o subtexto for "slantway", diga sim.
Se o subtexto for "slantways", diga sim.
Se o subtexto for "starting", diga sim.
Se o subtexto for "tall", diga sim.
Se o subtexto for "taller", diga sim.
Se o subtexto for "thru", diga sim.
Se o subtexto for "through", diga sim.
Se o subtexto for "throughout", diga sim.
Se o subtexto for "to", diga sim.
Se o subtexto for "toward", diga sim.
Se o subtexto for "towards", diga sim.
Se o subtexto for "under", diga sim.
Se o subtexto for "underneath", diga sim.
Se o subtexto for "until", diga sim.
Se o subtexto for "unto", diga sim.
Se o subtexto for "up", diga sim.
Se o subtexto for "upward", diga sim.
Se o subtexto for "upon", diga sim.
Se o subtexto for "using", diga sim.
Se o subtexto for "via", diga sim.
Se o subtexto for "while", diga sim.
Se o subtexto for "wide", diga sim.
Se o subtexto for "with", diga sim.
Se o subtexto for "within", diga sim.
Se o subtexto for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any preposition:
Se o string for "about", diga sim.
Se o string for "above", diga sim.
Se o string for "across", diga sim.
Se o string for "after", diga sim.
Se o string for "against", diga sim.
Se o string for "all", diga sim.
Se o string for "alone", diga sim.
Se o string for "along", diga sim.
Se o string for "among", diga sim.
Se o string for "any", diga sim.
Se o string for "anywhere", diga sim.
Se o string for "around", diga sim.
\Se o string for "as", diga sim.
Se o string for "at", diga sim.
Se o string for "away", diga sim.
Se o string for "back", diga sim.
Se o string for "backward", diga sim.
Se o string for "backwards", diga sim.
Se o string for "antes de", diga sim.
Se o string for "beginning", diga sim.
Se o string for "behind", diga sim.
Se o string for "below", diga sim.
Se o string for "beneath", diga sim.
Se o string for "beside", diga sim.
Se o string for "between", diga sim.
Se o string for "beyond", diga sim.
Se o string for "bigger", diga sim.
Se o string for "by", diga sim.
Se o string for "close", diga sim.
Se o string for "deep", diga sim.
Se o string for "diagonally", diga sim.
Se o string for "down", diga sim.
Se o string for "downward", diga sim.
Se o string for "ending", diga sim.
Se o string for "everywhere", diga sim.
Se o string for "except", diga sim.
Se o string for "finishing", diga sim.
Se o string for "facing", diga sim.
\Se o string for "for", diga sim.
Se o string for "por", diga sim.
Se o string for "forward", diga sim.
Se o string for "from", diga sim.
Se o string for "given", diga sim.
Se o string for "giving", diga sim.
Se o string for "high", diga sim.
Se o string for "in", diga sim.
Se o string for "inside", diga sim.
Se o string for "into", diga sim.
Se o string for "larger", diga sim.
Se o string for "leaning", diga sim.
Se o string for "left", diga sim.
Se o string for "leftward", diga sim.
Se o string for "leftways", diga sim.
Se o string for "like", diga sim.
Se o string for "limiting", diga sim.
Se o string for "long", diga sim.
Se o string for "near", diga sim.
Se o string for "of", diga sim.
Se o string for "off", diga sim.
Se o string for "on", diga sim.
Se o string for "only", diga sim.
Se o string for "onto", diga sim.
Se o string for "out", diga sim.
Se o string for "outside", diga sim.
Se o string for "over", diga sim.
Se o string for "past", diga sim.
Se o string for "pointing", diga sim.
Se o string for "returning", diga sim.
Se o string for "right", diga sim.
Se o string for "rightward", diga sim.
Se o string for "rightways", diga sim.
Se o string for "shorter", diga sim.
Se o string for "sideway", diga sim.
Se o string for "sideways", diga sim.
Se o string for "similar", diga sim.
Se o string for "smaller", diga sim.
Se o string for "somewhere", diga sim.
Se o string for "slantwise", diga sim.
Se o string for "slantway", diga sim.
Se o string for "slantways", diga sim.
Se o string for "starting", diga sim.
Se o string for "tall", diga sim.
Se o string for "taller", diga sim.
Se o string for "thru", diga sim.
Se o string for "through", diga sim.
Se o string for "throughout", diga sim.
Se o string for "to", diga sim.
Se o string for "toward", diga sim.
Se o string for "towards", diga sim.
Se o string for "under", diga sim.
Se o string for "underneath", diga sim.
Se o string for "until", diga sim.
Se o string for "unto", diga sim.
Se o string for "up", diga sim.
Se o string for "upward", diga sim.
Se o string for "upon", diga sim.
Se o string for "using", diga sim.
Se o string for "via", diga sim.
Se o string for "while", diga sim.
Se o string for "wide", diga sim.
Se o string for "with", diga sim.
Se o string for "within", diga sim.
Se o string for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any qualifier:
Se o string estiver em branco, diga não.
Se o target deste first deste string for o left-paren pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any reverse-possessive:
\Se o string for "uv", diga sim.
Se o string for "de", diga sim.
\Se o string for "pertencente", diga sim.
\Se o string for "que pertence", diga sim.
\Se o string for "del", diga sim. \ short por "de el", expanded in "compile um term usando um percorredor e um field name (reverse-possessive)"
Diga não.

Etapas necessárias para que se determine se um percorredor está on any reverse-possessive:
Isole o percorredor.
\CAL
\Se o token deste percorredor for "uv", diga sim.
\PAL
\Se o string for "pertencente a", diga sim.
\Se o string for "pertencente ao", diga sim.
\Se o string for "que pertence a", diga sim.
\Se o string for "que pertence ao", diga sim.
\que consta
\que figura
\incorporada
\inerente
\Se o token deste percorredor não for "integrada de", diga não.
\Se o token deste percorredor não for "interna de", diga não.
\Se o token deste percorredor não for "interno de", diga não.
\Se o token deste percorredor não for "do registro de", diga não.
\Se o token deste percorredor não for "que está dentro de", diga não.
\Se o token deste percorredor não for "de dentro do registro de", diga não.
\Se o token deste percorredor não for "de dentro de", diga não.
\Se o token deste percorredor não for "que faz parte de", diga não.
Se o token deste percorredor não for "de", diga não.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any pronome demonstrativo, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any string literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string for as aspas duplas, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any symbol:
Se o length deste string não for 1, diga não.
Se o target deste first deste string for any symbol, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any verb:
\PAL
Se o string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
Se o string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" to non-tempora state
Se o string for "ser", diga sim. \ "be"
Se o string for "for", diga sim. \ "be"
Se o string for "forem", diga sim. \ "be"
Se o string for "estiver", diga sim. \ "be"
Se o string for "estiverem", diga sim. \ "be"
Se o string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated in o singular third person (3ps) present, perm.
Se o string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated in o singular third person (3ps) present, temp.
Se o string for "são", diga sim. \ "are" são not \ aren't: "to be" conjugated in o plural third person (3pp) present, perm.
Se o string for "estão", diga sim. \ "are" são not \ aren't: "to be" conjugated in o plural third person (3pp) present, temp.
Se o string for "foi", diga sim. \ "was" was not \ wasn't: only used in Noodle (3ps) past, perm.
Se o string for "estava", diga sim. \ "was" was not \ wasn't: only used in Noodle (3ps) past, temp.
Se o string for "foram", diga sim. \ "were" were not \ weren't?: not used in CAL (3pp) past, perm.
Se o string for "estavam", diga sim. \ "were" were not \ weren't?: not used in CAL (3pp) past, temp.
Se o string for "será", diga sim. \ it "will" will not \ won't: not used in CAL (3ps) past, perm.
Se o string for "estará", diga sim. \ it "will" will not \ won't: not used in CAL (3ps) past, temp.
Se o string for "serão", diga sim. \ they "will" will not \ won't: not used in CAL (3pp) past, perm.
Se o string for "estarão", diga sim. \ they "will" will not \ won't: not used in CAL (3pp) past, temp.
Se o string for "supera", diga sim. \ beats, exceeds
Se o string for "superam", diga sim. \ beats, exceeds
Se o string for "excede", diga sim. \ beats, exceeds
Se o string for "excedem", diga sim. \ beats, exceeds
Se o string for "pode", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se o string for "puder", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se o string for "puderem", diga sim. \ it "can" cannot \ can't: only case in CAL (3ps)
Se o string for "podem", diga sim. \ they "can" cannot \ can't: not used in CAL (3pp) added just in case 
Se o string for "poderia", diga sim. \ it "could" could not \ couldn't: not used in CAL (3ps) added just in case
Se o string for "poderia", diga sim. \ they "could" could not \ couldn't: not used in CAL (3pp) added just in case
Se o string for "podemos", diga sim. \ we "could" could not \ couldn't: only once in Noodle (1pp) "Etapas necessárias para que se determine se we could encontre um endereço de memória:"
Se o string for "tem", diga sim. \ it "has" used in type definitions; (3ps) present
Se o string for "têm", diga sim. \ they "have" used in type definitions; (3pp) present
Se o string for "ter", diga sim. \ used in type definitions
Se o string for "possui", diga sim. \ it "has" used in type definitions; (3ps) present
Se o string for "possuem", diga sim. \ they "have" used in type definitions; (3pp) present
Se o string for "possuir", diga sim. \ used in type definitions
\\ trouble makers
Se o string for "inicia", diga sim. \ "begins" does not begin \ doesn't begin
Se o string for "começa", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se o string for "começar", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se o string for "termina", diga sim. \ "ends" does not end \ doesn't end
Se o string for "terminar", diga sim. \ "ends" does not end \ doesn't end
Se o string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
Se o string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
Se o string for "parece", diga sim. \ "looks" does not look \ doesn't look
Se o string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
Se o string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
Se o string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used in CAL
\CAL
Se o string for "are", diga sim. \ são not \ aren't
Se o string for "be", diga sim. \
Se o string for "can", diga sim. \ cannot \ can't
Se o string for "cannot", diga sim.
\Se o string for "could", diga sim. \ could not \ couldn't
\Se o string for "do", diga sim. \ does not \ don't
Se o string for "does", diga sim. \ does not \ doesn't
Se o string for "is", diga sim. \ não for \ isn't
Se o string for "may", diga sim. \ may not \ mayn't
Se o string for "should", diga sim. \ não deveria \ shouldn't
Se o string for "was", diga sim. \ was not \ wasn't
Se o string for "will", diga sim. \ will not \ won't
Se o string for "would", diga sim. \ would not \ wouldn't
Se o string for "has", diga sim. \ used in type definitions
Se o string for "have", diga sim. \ used in type definitions
Se o string ends with "n't", diga sim.
\\ trouble makers
Se o string for "begins", diga sim. \ does not begin \ doesn't begin
Se o string for "ends", diga sim. \ does not end \ doesn't end
Se o string for "looks", diga sim. \ does not look \ doesn't look
Se o string for "needs", diga sim. \ does not need \ doesn't need
Se o string for "starts", diga sim. \ does not start \ doesn't start
Diga não.

Etapas necessárias para que se determine se um string é o start of any definition:
\PAL
Se o string for "Passos", diga sim.
Se o string for "Etapas", diga sim.
\CAL
Se o string for "to", diga sim.
\default
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conditional:
\PAL
Se o string for "se", diga sim.
Se o string for "quando", diga sim.
\CAL
Se o string for "if", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any privatize:
\PAL
Se o string for "privatize", diga sim.
\Se o string for "reserve", diga sim.
Se o string for "separe", diga sim.
Se o string for "isole", diga sim.
Se o string for "Isole", diga sim.
Se o string for "conserve", diga sim.
Se o string for "derive", diga sim.
\CAL
\Se o string for "privatize", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any loop:
\PAL
Se o string for "percorra", diga sim.
\Se o string for "ciclo", diga sim.
\Se o string for "laço", diga sim. \# muito usado em pseudo-codigo
\CAL
Se o string for "loop", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any break:
\PAL
Se o string for "pare", diga sim.
Se o string for "pare de percorrer", diga sim.
Se o string for "pare de repetir", diga sim.
Se o string for "cancele a operação", diga sim.
Se o string for "interrompa a operação", diga sim.
\CAL
Se o string for "break", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any exit:
\PAL
Se o string for "acabe", diga sim.
Se o string for "acabou", diga sim.
Se o string for "acabou-se", diga sim.
\Se o string for "advirta", diga sim.
\Se o string for "anuncie", diga sim.
\Se o string for "avise", diga sim.
Se o string for "cancele", diga sim.
Se o string for "desconsidere.", diga sim.
Se o string for "deixa quieto", diga sim.
Se o string for "deixe quieto", diga sim.
Se o string for "e mais nada", diga sim.
Se o string for "e pronto", diga sim.
Se o string for "e só", diga sim.
Se o string for "fim", diga sim.
Se o string for "fimse", diga sim.
Se o string for "ignore", diga sim.
\Se o string for "informe", diga sim.
Se o string for "prossiga", diga sim.
Se o string for "pronto", diga sim.
Se o string for "retorne", diga sim.
Se o string for "saia", diga sim.
Se o string for "siga adiante", diga sim.
Se o string for "terminamos", diga sim.
Se o string for "termine", diga sim.
\CAL
Se o string for "exit", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any repeat:
\PAL
\Se o string for "repetir", diga sim. \# muito usado em pseudo-codigo
Se o string for "repita", diga sim. \# muito usado em pseudo-codigo
\CAL
Se o string for "repeat", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any say:
\PAL
Se o string for "diga", diga sim. \# modo imperativo
Se o string for "responda", diga sim. \# modo imperativo
Se o string for "informe", diga sim. \# modo imperativo
\Se o string for "decida", diga sim. \ para usar como "decida afirmativamente e decida negativamente"
\Se o string for "dizer", diga sim. \# modo infinitivo opcional.
\CAL
Se o string for "say", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any decide:
\PAL
\Se o string for "decidir", diga sim.
Se o string for "decida", diga sim. \estou pensando em retirar devido o comentário da rotina anterior
\Se o string for "escolha", diga sim.
Se o string for "determine", diga sim.
Se o string for "conclua", diga sim.
Se o string for "esclareça", diga sim.
Se o string for "descubra", diga sim.
Se o string for "analise", diga sim.
\CAL
Se o string for "decide", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any call:
\PAL
Se o string for "chame", diga sim.
\Se o string for "repasse", diga sim.
\Se o string for "informe", diga sim.
\CAL
Se o string for "call", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any point:
\PAL
Se o string for "aponte", diga sim.
\CAL
Se o string for "point", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any employ:
\PAL
Se o string for "empregue", diga sim.
\CAL
Se o string for "employ", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any noise palavra:
\Nova rotina 
Se o string for "already", diga sim.
Se o string for "still", diga sim.
Se o string for "yet", diga sim.
Se o string for "já", diga sim.
Se o string for "ainda", diga sim.
\Se o string for "que", diga sim.
\Se o string for "se", diga sim.
[more noise palavras here]
Diga não.

Etapas necessárias para que se determine se um string é o start of any expression:
Se o string for any sign, diga sim.
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Se o string for any literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any global:
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any new local:
Se o string for any artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any optional info:
\PAL
Se o string for "com", diga sim.
\CAL
Se o string for "to", diga sim.
Se o string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any routine:
\PAL
Se o string for "Passos", diga sim.
Se o string for "Etapas", diga sim.
Se o string for "Etapas necessárias para que se", diga sim. \verificar depois
Se o string for "Passos necessários para que se", diga sim.
\CAL
Se o string for "to", diga sim. \verificar se pode ser excluído
Diga não.

Etapas necessárias para que se determine se um string é o start of any statement:
Se o string for o start of any definition, diga não.
Se o string for any literal, diga não.
Se o string for any mark, diga não.
Se o string estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é o start of any type:
Se o string for any artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any variable:
Se o string for any artigo definido, diga sim.
\Se o string for "do", diga sim. \ this é iffy, here por reverse-possessives
Diga não.

Etapas necessárias para que se determine se um string has any stressed vowel:
Isole o string.
Percorra.
Se o string estiver em branco, diga não.
Se o target deste last deste string for any stressed vowel, diga sim.
Subtraia 1 from o last deste string.
Repita.

Etapas necessárias para que se determine se um term está vazia;
Etapas necessárias para que se determine se um term estão vazias;
Etapas necessárias para que se determine se um term estão vazios;
Etapas necessárias para que se determine se um term está vazio:
Se a variable deste term não for inexistente, diga não.
Se a phrase deste term não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um type puder ser reduzido para um string using o base name:
Se o type for inexistente, diga não.
Se o name deste type for o string, diga sim.
Se o cooking alarme deste type estiver ativo, diga não.
Ligue o cooking alarme deste type.
Encontre um base type usando o base name deste type e o catálogo de tipos.
Se o base type for inexistente, desative o cooking alarme deste type; diga não.
Se o base type puder ser reduzido para o string using o base name, desative o cooking alarme deste type; diga sim.
Desative o cooking alarme deste type.
Diga não.

Etapas necessárias para que se determine se um type puder ser reduzido para um type name:
Se o type for inexistente, diga não.
Isole o type.
Percorra.
Se o type for inexistente, diga não.
Se o name deste type for o type name, diga sim.
Se o base type deste type for o type, diga não.
Coloque o base type deste type into o type.
Repita.

Etapas necessárias para que se determine se um type é any built-in type:
Se o type for inexistente, diga não.
Se o type for o base type deste type, diga sim.
Diga não.

Etapas necessárias para que se determine se um type é value pushable:
Se o type for inexistente, diga não.
Se o type for inexistente, diga não. \\ repetido?
Se o length deste type for 4, diga sim.
Se o length deste type for 2, diga sim.
Se o length deste type for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser finalizado:
Se o type for inexistente, diga não.
Se o type puder ser reduzido para "subtexto", diga não.
Se o type puder ser reduzido para "string", diga sim.
Se os fields deste type deveriam ser finalizados, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser ignorado:
Se o type for inexistente, diga não.
\PAL
\Se o name deste type for "elemento", diga não.
\Se o name deste type for "elementos", diga não.
\CAL
Se o name deste type for "coisa", diga não.
Se o name deste type for "coisas", diga não.
Se o type puder ser reduzido para "coisas", diga sim.
Se o type não puder ser reduzido para "endereço de memória", diga não.
Se o target type deste type for inexistente, diga não.
Se o target type deste type não puder ser reduzido para "endereço de memória", diga sim.
Se o target type deste type não deveria ser ignorado, diga não.
Diga sim.

Etapas necessárias para que se determine se uma variable é duplicated in alguns variables:
Obtenha another variable from o variables.
Se o other variable for inexistente, diga não.
Se o name desta other variable estiver em branco, repita.
Se o other variable for o variable, repita.
Se o name desta other variable for o name desta variable, diga sim.
Repita.

The dereference tag é uma tag igual a 5.

An DOS header é um conjunto with
An wyrd called signature, \\ The value of this word is 5A4DH (with the 4DH coming first).
\\ Signature Word. This contains a "magic number" which provides a simple check that the file really is a DOS .EXE file;
\\ it follows that the filename extension does not in fact have to be .EXE, as long as programs check this word.
\\The value of this word is 5A4DH (with the 4DH coming first).
\\These two bytes represent the character string "MZ", the initials of Mark Zibowski, a Microsoft employee at the time the file format was designed.
An wyrd called numberofbytesonlastpage, \\ The last page may contain between 1 and 512 bytes
\\Last Page Size.
\\The file occupies a number of 512 byte pages.
\\The last page may contain between 1 and 512 bytes.
\\This word indicates the number of bytes actually used in the last page, 
\\with the special case of a full page being represented by a value of zero (since the last page is never empty).
An wyrd called numberofpages,
\\ File Pages.
\\This word contains a count of the number of pages required to hold the file.
\\For example, if the file contains 1024 bytes, this word would contain 0002H; 
\\if the file contains 1025 bytes, this word would contain 0003H.
\\The Last Page Size field is used to determine the number of valid bytes in the final page.
\\Thus, if the file contains 1024 bytes, the Last Page Size field contains 0000H, because no bytes overflow into a final partly used page.
\\If the file contains 1025 bytes, then the Last Page Size field contains 0001H, because the final page contains only one valid byte (the 1025th byte).
An wyrd called relocuss,
\\ Relocation Items.
\\ This word gives the number of entries that exist in the relocation pointer table.
\\It is quite in order for this value to be zero, in which case there are no relocation entries.
An wyrd called sizeofheaderinparagraphs,
\\ Header Paragraphs.
\\This word gives the size of the .EXE header in paragraphs.
\\It indicates the offset of the compiled/assembled and linked image do program (the load module) within the .EXE file.
\\The size of the load module can be deduced by subtracting this value (converted to bytes) from the overall file size 
\\derived from combining the File Pages and Last Page Size values.
\\The header always spans an even number of paragraphs.
An wyrd called minimumextraparagraphs,
\\ MINALLOC.
\\This word indicates the minimum number of paragraphs the program requires to begin execution.
\\This is in addition to the memory required to hold the load module.
\\This value normally represents the total size of any uninitialised data and/or stack segments that are linked at the end of a program.
\\This space is not directly included in the load module, since there are no particular initialising values and it would simply waste disk space.
An wyrd called maximumextraparagraphs,
\\ MAXALLOC.
\\This word indicates the maximum number of paragraphs that the program would like allocated to it before it begins execution.
\\This indicates additional memory over and above that required by the load module and the value specified by MINALLOC.
\\If the request cannot be satisfied, the program is allocated as much memory as is available.
An wyrd called initialrelativess,
\\ Initial SS value.
\\This word contains the paragraph address of the stack segment relative to the start of the load module.
\\At load time, this value is relocated by adding the address of the start segment of the program to it, 
\\and the resulting value is placed in the SS register before the program is started.
\\In DOS, the start segment of the program is the first segment boundary in memory after the PSP.
An wyrd called initialsp,
\\ Initial SP value.
\\This word contains the absolute value that must be loaded into the SP register before the program is given control.
\\Since the actual stack segment is determined by the loader, and this is merely a value within that segment, it does not need to be relocated.
An wyrd called initialchecksum,
\\ Complemented Checksum.
\\This word contains a checksum of the contents of the .EXE file.
\\ Its value is rarely checked, but its purpose is to ensure the integrity of the data within the file.
\\ Full details of how it is calculated appear in the section on checksum calculation.
An wyrd called initialip,
\\ Initial IP value.
\\This word contains the absolute value that should be loaded into the IP register in order to transfer control to the program.
\\Since the actual code segment is determined by the loader, and this is merely a value within that segment, it does not need to be relocated.
An wyrd called initialirelativecs, 
\\ Pre-relocated initial CS value.
\\ This word contains the initial value, relative to the start of the load module, that should be placed in the CS register in order to transfer control to the program.
\\ At load time, this value is relocated by adding the address of the start segment of the program to it, and the resulting value is placed in the CS register
\\ when control is transferred.
An wyrd called addressofrelocationtableinfile,
\\ Relocation table offset.
\\ This word gives the offset from the start of the file to the relocation pointer table.
\\ This value must be used to locate the relocation pointer table (rather than assuming a fixed location) 
\\because variable-length information pertaining to program overlays can occur before this table, causing its position to vary.
\\A value of 40H in this field generally indicates a different kind of executable file, not a DOS "MZ" type.
An wyrd called overlynumber,
\\ Overlay number.
\\ This word is normally set to 0000H, because few programs actually have overlays.
\\It changes only in files containing programs that use overlays; see the note below.
8 pedaços called resveredbytes, \\ Specifies reserved words for the program (known in winnt.h as e_res[4]), usually set to zero by the linker.
\\In this case, just use a single reserved1 set to zero; if not zero create four reserved1 with the correct value.
An wyrd called oemidentifier, \\ Specifies the identifier for the OEM for e_oeminfo.
An wyrd called oeminfo, \\ Specifies the OEM information for a specific value of e_oeminfo.
20 pedaços called reservedwords, \\ Specifies reserved words for the program (known in winnt.h as e_res[10]), usually set to zero by the linker.
\\In this case, just use a single reserved1 set to zero; if not zero create ten reserved1 with the correct value.
An número called addressofpeheaderinfile.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variables:
Crie um index usando 101.
Eliminate duplicate nicknames from o variables usando o index.
Destroy o index.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variables usando um index:
Se o index for inexistente, cancele.
Percorra.
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Eliminate duplicate nicknames usando o variable e o index.
Repita.

Etapas necessárias para que se eliminate duplicate nicknames usando uma variable e um index:
Se o variable for inexistente, cancele.
Se o index for inexistente, cancele.
Encontre another variable usando o nickname desta variable e o index.
Se o other variable for inexistente, encontre o other variable usando o name desta variable e o index.
Se o other variable for inexistente, catalogue o variable usando o nickname desta variable e o index; exit.
Limpe o nickname desta other variable.
Limpe o nickname desta variable.

The end if tag é uma tag igual a 6.

An entry é uma coisa with
An name address,
An thunk address,
An name,
An address.

The epilog tag é uma tag igual a 7.

The exit tag é uma tag igual a 8.

An expression é um term.

Etapas necessárias para que se extend um string with another string:
Se o other string estiver em branco, cancele.
Se o string não estiver em branco, posponha o space pedaço to o string.
Posponha o other string to o string.

An field é uma variable.

An field term é um conjunto with
An dereference alarme,
An field (reference),
An function routine (reference),
An push alarme.

Etapas necessárias para que se finalize o compilador:
Destroy o catálogo de rotinas úteis.
Destroy o catálogo geral de rotinas.
Destroy o catálogo de variáveis hexadecimais.
Destroy o catálogo de variáveis globais.
Destroy o catálogo de tipos.
Destroy o imports.
Destroy a routines.
Destroy o literals.
Destroy o globals.
Destroy o types.
Destroy o source files.

The finalize tag é uma tag igual a 9.

Etapas necessárias para que se encontre um entry usando um string e alguns entries:
Esvazie o entry.
Percorra.
Obtenha o entry from o entries.
Se o entry for inexistente, cancele.
Se o name desta entry for o string, cancele.
Repita.

Etapas necessárias para que se encontre um field term usando um phrase e um type e um name:
Limpe o field term.
Encontre o field term usando o type e o name.
Se o field deste field term não for inexistente, cancele.
Se o phrase não estiver em branco, encontre uma routine usando "coloque" e o phrase e "'s " then o name e "into".
Se a routine não for inexistente, coloque a routine into a function deste field term; exit.
Se o type for inexistente, cancele.
Encontre a routine usando "coloque" e o type e "'s " then o name e "into".
Se a routine não for inexistente, acione o push alarme deste field term; coloque a routine into o function deste field term; exit.
\ code below for looking deep within endereço de memórias - a debatable feature
\ Se o target type deste type não for inexistente, encontre a routine usando "coloque" e o target type deste type e "'s " then o name e "into".
\ Se a routine não for inexistente, acione o dereference alarme deste field term; coloque a routine into a function deste field term; exit.

Etapas necessárias para que se encontre um field term usando um type e um name:
Se o type for inexistente, cancele.
Encontre um field usando o name e os fields deste type.
Se o field não for inexistente, coloque o field into o field deste field term; exit.
Se o target type deste type não for inexistente, encontre o field usando o name e os fields deste target type deste type.
Se o field não for inexistente, acione o dereference alarme deste field term; coloque o field into o field deste field term; exit.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag:
Coloque o other fragment into o fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se o tag deste fragment for o tag, cancele.
Coloque o next deste fragment into o fragment.
Repita.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag (backwards):
Coloque o other fragment into o fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se o tag deste fragment for o tag, cancele.
Coloque o previous deste fragment into o fragment.
Repita.

Etapas necessárias para que se encontre um import usando um string:
Esvazie o import.
Percorra.
Obtenha o import from o imports.
Se o import for inexistente, cancele.
Se o name deste import for o string, cancele.
Repita.

Etapas necessárias para que se encontre um endereço completo e um row# usando um endereço de memória du pedaço :
Limpe o endereço completo.
Coloque 0 into o row#.
Encontre um source file usando o endereço de memória du pedaço .
Se o source file for inexistente, cancele.
Coloque o endereço completo deste source file into o endereço completo.
Encontre o row# usando o source file e o endereço de memória du pedaço .

Etapas necessárias para que se encontre uma routine usando um moniker e um monikette e um index:
Se o monikette for inexistente, cancele.
Esvazie a routine.
Isole o moniker.
Coloque o type deste monikette into o type atual deste monikette.
Lance o subtexto atual deste monikette on o string deste monikette.
Percorra.
Posponha o monikette to o moniker (while bubbling).
Encontre um refer usando o moniker e o index.
Se o refer não for inexistente, coloque o endereço de memória deste refer into a routine.
Se o refer não for inexistente, encontre a routine usando o moniker e o next deste monikette e o index.
Se a routine não for inexistente, pare.
Bubble o monikette.
Se o monikette estiver bubbled out, pare.
Coloque o original moniker into o moniker.
Repita.

Etapas necessárias para que se encontre uma routine usando alguns monikettes:
Esvazie a routine.
Encontre a routine usando um moniker e o first destes monikettes e o catálogo geral de rotinas.

Etapas necessárias para que se encontre uma routine usando um string e another string e um third string e um fourth string:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to os monikettes usando o other string.
Adicione um third monikette to os monikettes usando o third string.
Adicione um fourth monikette to os monikettes usando o fourth string.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to os monikettes usando o type.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e another type:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to os monikettes usando o type.
Adicione um third monikette to os monikettes usando o other string.
Adicione um fourth monikette to os monikettes usando o other type.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um third string:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to os monikettes usando o type.
Adicione um third monikette to os monikettes usando o other string.
Adicione um fourth monikette to os monikettes usando o third string.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um third string e um fourth string e um fifth string:
Adicione um monikette to alguns monikettes usando o string.
Adicione another monikette to os monikettes usando o type.
Adicione um third monikette to os monikettes usando o other string.
Adicione um fourth monikette to os monikettes usando o third string.
Adicione um fifth monikette to os monikettes usando o fourth string.
Adicione um sixth monikette to os monikettes usando o fifth string.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre um row# usando um source file e um endereço de memória du pedaço :
Se o endereço de memória du pedaço for inexistente, coloque 0 into o row#; exit.
Lance um subtexto on o trecho deste source file.
Coloque 1 into o row#.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o first deste subtexto for o endereço de memória du pedaço , cancele.
Se o target deste first deste subtexto for o return pedaço, adicione 1 to o row#.
Adicione 1 to o first deste subtexto.
Repita.

Etapas necessárias para que se encontre um source file usando um endereço de memória du pedaço :
Se o endereço de memória du pedaço for inexistente, esvazie o source file; exit.
Percorra.
Obtenha o source file from o source files.
Se o source file for inexistente, cancele.
Se o endereço de memória du pedaço for menor du que o first deste trecho deste source file, repita.
Se o endereço de memória du pedaço for maior du que o last deste trecho deste source file, repita.

Etapas necessárias para que se encontre um type e um nickname usando um name:
Esvazie o type.
Limpe o nickname.
Encontre o type e o nickname usando o name (forward).
Se o type não for inexistente, cancele.
Encontre o type e o nickname usando o name (backward).
\Lance um subtexto on o name.
\Percorra.
\Se o subtexto estiver em branco, cancele.
\Encontre o type usando o subtexto e o catálogo de tipos.
\Se o type não for inexistente, pare.
\Skip to o next palavra in o subtexto.
\Repita.
\Coloque o first deste name into first deste another subtexto. \ pode estar errado
\Coloque o first deste subtexto menos 2 into o last deste other subtexto.
\Se o other subtexto não estiver em branco, coloque o other subtexto into o nickname.
\Se o other subtexto estiver em branco, coloque o subtexto into o nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (backward):
Esvazie o type.
Limpe o nickname.
Lance um subtexto on o name.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip to o previous palavra in o subtexto.
Repita.
Coloque o last deste name into another subtexto's last .
Coloque o last deste subtexto mais 2 into o first deste other subtexto.
Se o other subtexto não estiver em branco, coloque o other subtexto into o nickname.
Se o other subtexto estiver em branco, coloque o subtexto into o nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (forward):
\ original - no mude
Esvazie o type.
Limpe o nickname.
Lance um subtexto on o name.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip to o next palavra in o subtexto.
Repita.
Coloque o first deste name into another subtexto's first.
Coloque o first deste subtexto menos 2 into o last deste other subtexto.
Se o other subtexto não estiver em branco, coloque o other subtexto into o nickname.
Se o other subtexto estiver em branco, coloque o subtexto into o nickname.

Etapas necessárias para que se encontre uma variable usando um name:
Se a rotina utilizada atualmente for inexistente, esvazie o variable; exit.
Encontre o variable usando o name e os locals desta rotina utilizada atualmente.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e os parameters desta rotina utilizada atualmente.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e o catálogo de variáveis globais.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se encontre uma variable usando um name e algumas variables:
Esvazie o variable.
Percorra.
Obtenha o variable from o variables.
Se o variable for inexistente, cancele.
Se o name desta variable for o name, cancele.
Se o nickname desta variable for o name, cancele.
Repita.


\Etapas necessárias para que se encontre uma variable usando um name:
\Se a rotina utilizada atualmente for inexistente, esvazie o variable; exit.
\Encontre o variable usando o name e os locals desta rotina utilizada atualmente.
\Se o variable não for inexistente, cancele.
\Encontre o variable usando o name e os parameters desta rotina utilizada atualmente.
\Se o variable não for inexistente, cancele.
\Encontre o variable usando o name e o catálogo de variáveis globais.
\Se o variable não for inexistente, cancele.
\ Encontre o variable usando o name e o catálogo de variáveis hexadecimais.

\Etapas necessárias para que se encontre uma variable usando um name e alguns variables:
\esvazie o variable.
\Percorra.
\Obtenha o variable from o variables.
\Se o variable for inexistente, cancele.
\Se o name desta variable for o name, cancele.
\Se o nickname desta variable for o name, cancele.
\Repita.

An fragment é uma coisa with
An tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
An variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
An routine (reference) [call internal, routine address],
An entry (reference) [call external],
An número [increment],
An alarme [load eax], \SAL
An address,
An texto hexadecimal called code.

Etapas necessárias para que se gere um name usando um string:
Coloque o string into o name.
Adicione 1 to o name contagem deste compilador.
Convert o name contagem deste compilador to another string.
Posponha o other string to o name.

Etapas necessárias para que se obtenha um address usando uma routine:
Se o address desta routine não for 0, coloque o address desta routine into o address; exit.
Coloque -1 into o address desta routine.
Encontre another routine usando o employs moniker desta routine e o catálogo geral de rotinas.
Se o other routine for inexistente, abort with "Eu não consegui encontrar uma tarefa '" then o employs moniker desta routine then "' que você está tentando employ." e o locus desta routine; exit.
Se o address desta other routine for -1, abort with "Referência recursiva na cláusula employ." e o locus desta routine; exit. \Bora traduzir
Obtenha o address usando o other routine.
Coloque o address into o address desta routine.

Etapas necessárias para que se obtenha um contagem usando alguns imports (all entries mais markers):
Coloque 0 into o contagem.
Percorra.
Obtenha um import from o imports.
Se o import for inexistente, cancele.
Adicione a contagem destas entries deste import to o contagem.
Adicione 1 to o contagem.
Repita.

An global body é um subtexto.

The catálogo de variáveis globais é um index.

An global é uma variable.

The globals são alguns globals.

The image base é um address igual a 4194304 [$00400000].

The import zona é um zona.

An import header é um conjunto with
An address called original first thunk, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-first-thunkoft-milad-kahsari-alhadi/
\ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft#:~:text=The%20original%20first%20thunk%20is,%2C%20user32%20etc)%20are%20known.
\Thunks are the defnitive pieces of codes in an operating system that handle the transitions between 16 and 32-bit code.
\ Thus they ensure backward compatibility between the calls made by the application.
\ The OS is subjected with this facility for backward compatibility, so that the 16 bit applications can run smoothly in 32 bit environment.
\ The original first thunk is needed if the imports are bound but the imported .DLL does not match.
\ On a fresh unpatched version of Windows, all addresses of all functions in the base .DLLs (ntdll, kernel32, user32 etc) are known.
\Take shell32 for example, it links to kernel32!CreateProcess and the true address of CreateProcess can be stored directly in shell32.
\This is called import binding and lets the loader skip the step where it looks up all the addresses of the imported functions.
\This does not work if the imported .DLL has not been loaded at its preferred address nor if the .DLL has changed (security update etc).
\If this happens then the loader has to look up the functions "the normal way" and the original first thunk array has to be used
\ because that is the only place where the RVAs of the function names are stored.
\ If import binding is not used then the original first thunk array is optional and might not be present.
\ ASLR has probably made this optimization irrelevant.
An número called timestamp, \ Set to zero until bound; then this feld is set to the TimeDateStamp of the exporting FileHeader da DLL
An address called forwarder chain, \ Forwarder Chain: The 32-bit index of the frst forwarder in the list of imported functions
An address called name memory address, 
\It holds the RVA [Relative Virtual Address] of the dll to be loaded into memory. It is a dword value.
\It is comprised of : RVA = Image Base + Endian Order 
\Note: As we know OllyDbg gives the result in the Big Endian order where as the x86 architecture holds the address in the Little Endian order, 
\ so the address gets exchanged reversibly in the di tuples
An address called first thunk memory address.
\ Once the API is linked and gets loaded into memory the frst thunk which is a RVA points to the Import Address Table [IAT]

An import é uma coisa with
An name address,
An header address,
An name,
An import header,
Some entries.

The imports são alguns imports.

The increment tag é uma tag igual a 10.

Etapas necessárias para que se catalogue um global:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o global for inexistente, cancele.
Se o name deste global estiver in o catálogo de variáveis globais, abort with "'" then o name deste global then "' é uma variável global duplicada." e o locus deste global; exit.
Catalogue o global usando o name deste global e o catálogo de variáveis globais.

Etapas necessárias para que se catalogue um literal:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o literal for inexistente, cancele.
Se o name deste literal estiver in o catálogo de variáveis hexadecimais, abort with "Erro interno no nome do literal na função index um literal" e o locus deste literal; exit.
Catalogue o literal usando o name deste literal e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se catalogue um partial moniker usando um index (special):
Encontre um refer usando o partial moniker e o index.
Se o refer não for inexistente, cancele.
Catalogue o partial moniker in o index.

Etapas necessárias para que se catalogue uma routine por utility use:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o function alarme desta routine estiver ativo, cancele.
Se o contagem destes parameters desta routine for 0, cancele.
Copy os monikettes desta routine into alguns monikettes.
Reduce os monikettes por utility use.
Convert os monikettes to um moniker.
Destroy os monikettes.
Se o moniker estiver in o catálogo geral de rotinas, cancele.
Encontre um refer usando o moniker e o catálogo de rotinas úteis.
Se o refer não for inexistente, coloque nil into o endereço de memória deste refer; exit.
Catalogue a routine usando o moniker e o catálogo de rotinas úteis.

Etapas necessárias para que se catalogue uma routine usando um moniker e um index (special):
Encontre um refer usando o moniker e o index.
Se o refer não for inexistente, coloque a routine into o endereço de memória deste refer; exit.
Catalogue a routine usando o moniker e o index.

Etapas necessárias para que se catalogue uma routine usando alguns monikettes e um index:
Se a routine for inexistente, cancele.
Limpe um partial moniker.
Percorra.
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Posponha o monikette to o partial moniker.
Se o monikette for o last destes monikettes, pare.
Catalogue o partial moniker usando o index (special).
Repita.
Catalogue a routine usando o partial moniker como um moniker e o index (special).

Etapas necessárias para que se catalogue alguns routines por utility use:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Catalogue a routine por utility use.
Repita.

Etapas necessárias para que se catalogue um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Catalogue o type usando o name deste type.

Etapas necessárias para que se catalogue um type usando um name:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Encontre um existing type usando o name e o catálogo de tipos.
Se o existing type for inexistente, catalogue o type usando o name e o catálogo de tipos; exit.
Coloque o locus deste type into um locus.
Se o locus for inexistente, coloque o locus deste existing type into o locus. \ point o erro to um type in o source code, not um generated type
Abort with "Acho que já vi o tipo '" then o name then "' em algum lugar antes; você deve ter duplicado ele." e o locus.

The indexing utilities cronômetro é um cronômetro.

Etapas necessárias para que se initialize o compilador:

Etapas necessárias para que se initialize o compilador usando um endereço dâ pasta:
Coloque o endereço dâ pasta into o endereço dâ pasta deste compilador.
Coloque 0 into o name contagem deste compilador.
Desative o alarme de alerta deste compilador.
Limpe a mensagem de erro deste compilador.
Limpe o abort endereço completo deste compilador.
Coloque 0 into o abort row# deste compilador.
Esvazie a rotina utilizada atualmente.
Crie o catálogo de tipos with 13001 [buckets]. \ was 4027
Crie o catálogo de variáveis globais with 13001 [buckets]. \ was 4027
Crie o catálogo de variáveis hexadecimais with 13001 [buckets]. \ was 4027
Crie o catálogo geral de rotinas with 13001 [buckets]. \ was 7919
Crie o catálogo de rotinas úteis with 13001 [buckets]. \ was 4027

Etapas necessárias para que se initialize um DOS header: \ vou alterar depois
Coloque 23117 [$5A4D] into o signature deste DOS header.
Coloque 64 [$0040] into o addressofrelocationtableinfile deste DOS header. \ The ?addressofrelocationtableinfile? is a pointer to the variable-length table of DLLs needed for this program.
Coloque 256 [$00000100] into o addressofpeheaderinfile deste DOS header. \The ?addressofpeheaderinfile? is a pointer to the ?PE Header?, a revised and extended version of the DOS Header introduced with advent of Windows. 
\The other 16 fields of the DOS Header are not used.

Etapas necessárias para que se initialize um PE header:
Initialize o PE header (standard header).
Initialize o PE header (optional header).
Initialize o PE header (version information).
Initialize o PE header (directories).
Initialize o PE header (import section).
Initialize o PE header (data section).
Initialize o PE header (code section).

Etapas necessárias para que se initialize um PE header (code section):
Copy pedaços from "code "'s first to o whereabouts deste name desta code section deste PE header por 6.
Coloque o length desta code zona into o sizeinbytes desta code section deste PE header.
Coloque a base desta code zona into o addressinmemory desta code section deste PE header.
Coloque o length desta code zona into o sizeinfile desta code section deste PE header.
Coloque a base desta code zona into o addressinfile desta code section deste PE header.
Coloque -536870880 [$E0000020] into as characteristics desta code section deste PE header. \ executable, readable, writable, code object

Etapas necessárias para que se initialize um PE header (data section):
Copy pedaços from "data "'s first to o whereabouts deste name desta data section deste PE header por 6.
Coloque o length desta zona de dados into o sizeinbytes desta data section deste PE header.
Coloque a base desta zona de dados  into o addressinmemory desta data section deste PE header.
Coloque o length desta zona de dados into o sizeinfile desta data section deste PE header.
Coloque a base desta zona de dados into o addressinfile desta data section deste PE header.
Coloque -1073741760 [$C0000040] into as characteristics desta data section deste PE header. \ initialized, readable, writable

Etapas necessárias para que se initialize um PE header (directories):
Coloque 16 [$00000010] into o numberofdirectories deste PE header.
Coloque a base desta import zona into o imagedirectoryentryimportaddress deste PE header.
Coloque o length desta import zona  into o imagedirectoryentryimportsize deste PE header.

Etapas necessárias para que se initialize um PE header (import section):
Copy pedaços from "idata "'s first to o whereabouts deste name desta idata section deste PE header por 6.
Coloque o length desta import zona into o sizeinbytes desta idata section deste PE header.
Coloque a base desta import zona into o addressinmemory desta idata section deste PE header.
Coloque o length desta import zona into o sizeinfile desta idata section deste PE header.
Coloque a base desta import zona into o addressinfile desta idata section deste PE header.
Coloque -1073741760 [$C0000040] into as characteristics desta idata section deste PE header. \ initialized, readable, writable

Etapas necessárias para que se initialize um PE header (optional header):
Coloque 267 [$010B] into o magicnumber deste PE header.
Coloque o length desta code zona into o sizeofcodeinfile deste PE header.
Coloque o length desta zona de dados into o sizeofinitializeddatainfile deste PE header.
Coloque 0 into o sizeofuninitializeddatainfile deste PE header.
Encontre uma routine usando "~initialize before run e run e finalize after run" e o catálogo geral de rotinas.
Se a routine for inexistente, abort with "Erro interno: não achei a tarefa de inicialização"; exit.
Coloque o address desta routine menos o image base into o addressofentrypointinmemory deste PE header.
Coloque a base desta code zona  into o addressofcodeinmemory deste PE header.
Coloque a base desta zona de dados into o addressofinitializeddatainmemory deste PE header.
Coloque o image base into a imagebase deste PE header.
Coloque 4096 [$00001000] into o memoryalignment deste PE header.
Coloque 4096 [$00001000] into o filealignment deste PE header.
Coloque 0 into o reserved deste PE header.
Coloque o exe size deste compilador into o sizeofimageinmemory deste PE header.
Coloque 4096 [section base] into o sizeofallheadersinfile deste PE header.
Coloque 0 into o checksum deste PE header.
Coloque 0 into as dllcharacteristics deste PE header.
Coloque 1048576 [$00100000] into o maxstack deste PE header.
Coloque 16384 [$00004000] into o minstack deste PE header.
Coloque 1048576 [$00100000] into o maxheap deste PE header.
Coloque 16384 [$00004000] into o minheap deste PE header.
Coloque 0 into o loaderflags deste PE header.

Etapas necessárias para que se initialize um PE header (standard header):
Coloque 17744 [$00004550] into o signature deste PE header.
Coloque 332 [$014C] into o machinetype deste PE header.
Coloque 3 [$0003] into o numberofsections deste PE header.
Coloque 0 into o timestamp deste PE header.
Coloque 0 into o pointertosymboltable deste PE header.
Coloque 0 into o numberofsymbols deste PE header.
Coloque 224 [$00E0] into o sizeofoptionalheaderinbytes deste PE header.
Coloque 33166 [$818E] into o characteristics deste PE header.

Etapas necessárias para que se initialize um PE header (version information):
Coloque 0 into o majorlinkerversion deste PE header.
Coloque 0 into o minorlinkerversion deste PE header.
Coloque 4 [$0004] into o osmajorversion deste PE header.
Coloque 0 [$0000] into o osminorversion deste PE header.
Coloque 0 into o usermajorversion deste PE header.
Coloque 0 into o userminorversion deste PE header.
Coloque 4 [$0004] into o subsystemmajorversion deste PE header.
Coloque 0 [$0000] into o subsystemminorversion deste PE header.
Coloque 2 [$0002] into o subsystem deste PE header.

The intel tag é uma tag igual a 11.

An intermediate é um local.

The jump false tag é uma tag igual a 12.

Etapas necessárias para que se link:
Round up zona sizes.
Initialize um DOS header.
Initialize um PE header.
Fill o exe deste compilador with o null pedaço usando o exe size deste compilador.
Blurt o DOS header into o exe deste compilador.
Blurt o PE header into o exe deste compilador.
Blurt o imports into o exe deste compilador.
Blurt o globals into o exe deste compilador.
Blurt o literals into o exe deste compilador.
Blurt a routines into o exe deste compilador.

The linking cronômetro é um cronômetro.

Etapas necessárias para que se list:
Limpe o listing deste compilador.
List a mensagem de erro deste compilador in o listing deste compilador.
List o types under "TYPES:" in o listing deste compilador.
List o globals under "GLOBALS:" in o listing deste compilador.
List o literals under "LITERALS:" in o listing deste compilador.
List a routines under "ROUTINES:" in o listing deste compilador.
List o catálogo de tipos under "TYPE INDEX:" in o listing deste compilador.
List o catálogo de variáveis globais under "GLOBAL INDEX:" in o listing deste compilador.
List o catálogo de variáveis hexadecimais under "LITERAL INDEX:" in o listing deste compilador.
List o catálogo geral de rotinas under "ROUTINE INDEX:" in o listing deste compilador.
List o catálogo de rotinas úteis under "catálogo de rotinas úteis:" in o listing deste compilador.
List o imports under "IMPORTS:" in o listing deste compilador.
List o source files under "SOURCE FILES:" in o listing deste compilador.
List o cronômetros under "TIMERS:" in o listing deste compilador.
Escreva o listing deste compilador to o listing endereço completo deste compilador.

Etapas necessárias para que se list um mensagem de erro in um trecho:
Se o mensagem de erro estiver em branco, cancele.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" to o trecho.
Advance o trecho (twice).
Posponha o mensagem de erro to o trecho.
Advance o trecho (twice).

Etapas necessárias para que se list um bucket in um trecho:
Se os refers deste bucket estiverem vazio, cancele.
Posponha "/bucket" to o trecho (with separator).
Advance o trecho.
List os refers deste bucket in o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns entries in um trecho:
Obtenha um entry from as entries.
Se o entry for inexistente, cancele.
List o entry in o trecho.
Repita.

Etapas necessárias para que se list um entry in um trecho:
Se o entry for inexistente, cancele.
Posponha "/entry" to o trecho (with separator).
Posponha o name desta entry to o trecho (with separator).
Posponha o address desta entry to o trecho (as hex with separator).
Advance o trecho.

Etapas necessárias para que se list um fragment in um trecho:
Posponha "/fragment" to o trecho (with separator).
Posponha a tag deste fragment to o trecho (as um fragment tag string with separator).
Posponha a variable deste fragment to o trecho (with separator).
Posponha a other variable deste fragment to o trecho (with separator).
Posponha a routine deste fragment to o trecho (with separator).
Posponha a entry desta fragment to o trecho (with separator).
Posponha o número deste fragment to o trecho (as hex with separator).
Posponha o address deste fragment to o trecho (as hex with separator).
Convert o code deste fragment to um texto dâ cifra binária.
Posponha o texto dâ cifra binária to o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns fragments in um trecho:
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
List o fragment in o trecho.
Repita.

Etapas necessárias para que se list um import in um trecho:
Se o import for inexistente, cancele.
Posponha "/import" to o trecho (with separator).
Posponha o name deste import to o trecho (with separator).
Advance o trecho.
List as entries deste import in o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns imports in um trecho:
Obtenha um import from o imports.
Se o import for inexistente, cancele.
List o import in o trecho.
Repita.

Etapas necessárias para que se list alguns imports under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o imports estiverem vazio, cancele.
List o imports in o trecho.

Etapas necessárias para que se list um index in um trecho:
Posponha "/" then o used bucket contagem deste index then " buckets" to o trecho (with separator).
Posponha a contagem deste index then " refers" to o trecho (with separator).
Advance o trecho (twice).
Percorra.
Obtenha um bucket usando o index.
Se o bucket for inexistente, cancele.
List o bucket in o trecho.
Repita.

Etapas necessárias para que se list um index under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o index estiver vazio, cancele.
List o index in o trecho.

Etapas necessárias para que se list um refer in um trecho:
Se o refer for inexistente, cancele.
Posponha "/refer" to o trecho (with separator).
Posponha o string deste refer to o trecho.
Se o endereço de memória deste refer for inexistente, posponha "..." to o trecho.
Posponha "/" to o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns refers in um trecho:
Obtenha um refer from o refers.
Se o refer for inexistente, cancele.
List o refer in o trecho.
Repita.

Etapas necessárias para que se list uma routine in um trecho:
Se a routine for inexistente, cancele.
Posponha "/routine" to o trecho (with separator).
Posponha o moniker desta routine to o trecho (with separator).
Posponha o compiled alarme desta routine to o trecho (with separator).
Posponha o callback alarme desta routine  to o trecho (with separator).
Posponha o decider alarme desta routine  to o trecho (with separator).
Posponha o function alarme desta routine  to o trecho (with separator).
Posponha o employs moniker desta routine  to o trecho (with separator).
Posponha o parameter size desta routine  to o trecho (with separator).
Posponha o local size desta routine  to o trecho (with separator).
Posponha o address desta routine  to o trecho (as hex with separator).
Advance o trecho.
List os parameters desta routine  in o trecho.
List os locals desta routine  in o trecho.
List os fragments desta routine  in o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns routines in um trecho:
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
List a routine in o trecho.
Repita.

Etapas necessárias para que se list alguns routines under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se a routines estiverem vazio, cancele.
List a routines in o trecho.

Etapas necessárias para que se list um source file in um trecho:
Se o source file for inexistente, cancele.
Posponha "/source file" to o trecho (with separator).
Posponha o endereço completo deste source file to o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns source files in um trecho:
Obtenha um source file from o source files.
Se o source file for inexistente, cancele.
List o source file in o trecho.
Repita.

Etapas necessárias para que se list alguns source files under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o source files estiverem vazio, cancele.
List o source files in o trecho.
Advance o trecho.

Etapas necessárias para que se list um cronômetro usando um string in um trecho:
Posponha "/timer" to o trecho (with separator).
Posponha o string to o trecho (with separator).
Posponha o string deste cronômetro to o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list o cronômetros under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
List o loading cronômetro usando "loading" in o trecho.
List o scanning cronômetro usando "scanning" in o trecho.
List o resolving types cronômetro usando "resolving types" in o trecho.
List o resolving globals cronômetro usando "resolving globals" in o trecho.
List o compiling routine headers cronômetro usando "compiling routine headers" in o trecho.
List o calculating cronômetro usando "calculating" in o trecho.
List o adding built-in memory routines cronômetro usando "adding built-in memory routines" in o trecho.
List o indexing utilities cronômetro usando "indexing utilities" in o trecho.
List o compiling routine bodies cronômetro usando "compiling routine bodies" in o trecho.
List o adding built-in startup routine cronômetro usando "adding built-in startup routine" in o trecho.
List o offsetting cronômetro usando "offsetting" in o trecho.
List o addressing cronômetro usando "addressing" in o trecho.
List o transmogrifying cronômetro usando "transmogrifying" in o trecho.
List o linking cronômetro usando "linking" in o trecho.
List o writing cronômetro usando "writing" in o trecho.
List o cronômetro deste compilador usando "total" in o trecho.
Advance o trecho.

Etapas necessárias para que se list um type in um trecho:
Se o type for inexistente, cancele.
Posponha "/type" to o trecho (with separator).
Posponha o name deste type to o trecho (with separator).
Posponha o plural name deste type to o trecho (with separator).
Posponha o length deste type to o trecho (as hex with separator).
Posponha o base name deste type to o trecho (with separator).
Posponha o base type deste type to o trecho (with separator).
Posponha o target name deste type to o trecho (with separator).
Posponha o target type deste type to o trecho (with separator).
Posponha a scale deste type to o trecho (with separator).
Advance o trecho.
List os fields deste type in o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns types in um trecho:
Obtenha um type from o types.
Se o type for inexistente, cancele.
List o type in o trecho.
Repita.

Etapas necessárias para que se list alguns types under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o types estiverem vazio, cancele.
List o types in o trecho.

Etapas necessárias para que se list uma variable in um trecho:
Se o variable for inexistente, cancele.
Posponha "/variable" to o trecho (with separator).
Posponha o categoria desta variable to o trecho (with separator).
Posponha o  compiled alarme desta variable to o trecho (with separator).
Posponha o name desta variable to o trecho (with separator).
Posponha o nickname desta variable to o trecho (with separator).
Posponha o type name desta variable to o trecho (with separator).
Posponha o type desta variable to o trecho (with separator).
Posponha o address desta variable [or offset] to o trecho (as hex with separator).
Posponha o by-value alarme desta variable to o trecho (with separator).
Posponha o contagem desta variable to o trecho (with separator).
Posponha o reference alarme desta variable to o trecho (with separator).
Posponha o redefinition target name desta variable to o trecho (with separator).
Posponha o literal desta variable to o trecho (with separator).
Convert o data desta variable to um texto dâ cifra binária.
Posponha o texto dâ cifra binária to o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns variables in um trecho:
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
List o variable in o trecho.
Repita.

Etapas necessárias para que se list alguns variables under um string in um trecho:
Posponha o string to o trecho.
Advance o trecho (twice).
Se o variables estiverem vazio, cancele.
List o variables in o trecho.
Advance o trecho.

The catálogo de variáveis hexadecimais é um index.

An literal é uma variable.

The literals são alguns literals.

The load address tag é uma tag igual a 13.

The load eax tag é uma tag igual a 14.

An local é uma variable.

An locus é um endereço de memória du pedaço .

The loop tag é uma tag igual a 15.

An moniker é um string.

An monikette é uma coisa with
An string,
An type (reference),
An variable (reference),
\ por bubbling
An type atual (reference),
An subtexto atual.

Etapas necessárias para que se mova um percorredor (code rules - comment):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor não for o return pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - glom):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o percorredor estiver on any possessive, cancele.
Se o target deste first deste source deste percorredor for any glom pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - mark):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules - noise):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for noise, repita.

Etapas necessárias para que se mova um percorredor (code rules - possessive):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o source deste percorredor starts with "s", avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules - qualifier):
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, pare.
Se o target deste first deste source deste percorredor for o left-paren pedaço, adicione 1 to um contagem.
Se o target deste first deste source deste percorredor for o right-paren pedaço, subtraia 1 from o contagem.
Avance o percorredor.
Se o contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - remark):
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, pare.
Se o target deste first deste source deste percorredor for o left-bracket pedaço, adicione 1 to um contagem.
Se o target deste first deste source deste percorredor for o right-bracket pedaço, subtraia 1 from o contagem.
Avance o percorredor.
Se o contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - string):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, cancele.
Se o percorredor estiver on any nested double-quote, avance o percorredor; repita.
Se o target deste first deste source deste percorredor for o aspas duplas, avance o percorredor; exit.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - symbol):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules):
Position o token deste percorredor on o source deste percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for noise, mova o percorredor (code rules - noise); exit.
Se o target deste first deste source deste percorredor for o barra invertida, mova o percorredor (code rules - comment); exit.
Se o target deste first deste source deste percorredor for o left-bracket pedaço, mova o percorredor (code rules - remark); exit.
Se o target deste first deste source deste percorredor for o aspas duplas, mova o percorredor (code rules - string); exit.
Se o target deste first deste source deste percorredor for o left-paren pedaço, mova o percorredor (code rules - qualifier); exit.
Se o target deste first deste source deste percorredor for any mark, mova o percorredor (code rules - mark); exit.
Se o percorredor estiver on any possessive, mova o percorredor (code rules - possessive); exit.
Mova o percorredor (code rules - glom).

Etapas necessárias para que se mova um percorredor (compilador rules):
Se o alarme de alerta deste compilador estiver ativo, limpe o token deste percorredor; exit.
Mova o percorredor returning um erro string (code rules).
Se o erro string não estiver em branco, abort with o erro string e o first deste token deste percorredor; exit.
\Se o token deste percorredor for "del", unbump o percorredor; exit. \ Spanish contraction "del"; fudged to "de l", short por "de el"
\Se o token deste percorredor for "al", unbump o percorredor; exit. \ Spanish contraction "al"; fudged to "a l", short por "a el"
Se o token deste percorredor estiver em branco, cancele.
Se o target deste first deste token deste percorredor for noise, repita.
Se o target deste first deste token deste percorredor for a barra invertida, repita.
Se o target deste first deste token deste percorredor for o left-bracket pedaço, repita.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate qualifier):
Se o length deste token deste percorredor for menor du que 2, coloque "Qualificadores devem terminar com parêntese ')'." into o erro string; exit.
Se o target deste last deste token deste percorredor não for o right-paren pedaço, coloque "Qualificadores precisam terminar com um parêntese ')'." into o erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate remark):
Se o length deste token deste percorredor for menor du que 2, coloque "Observações devem terminar com um colchete ']'." into o erro string; exit.
Se o  target deste last deste token deste percorredor não for o right-bracket pedaço, coloque "Observações precisam terminar com um colchete ']'." into o erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate string):
Se o length deste token deste percorredor for menor du que 2, coloque "Textos precisam terminar com aspas '""'." into o erro string; exit.
Se o  target deste last deste token deste percorredor não for as aspas duplas, coloque "Textos tem que terminar com aspas '""'." into o erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules):
Limpe o erro string.
Mova o percorredor (code rules).
Se o token deste percorredor estiver em branco, cancele.
Se o target deste first deste token deste percorredor for o left-bracket pedaço, mova o percorredor returning o erro string (code rules - validate remark); exit.
Se o target deste first deste token deste percorredor for o aspas duplas, mova o percorredor returning o erro string (code rules - validate string); exit.
Se o target deste first deste token deste percorredor for o left-paren pedaço, mova o percorredor returning o erro string (code rules - validate qualifier); exit.

An parte dâ cifra binária é um subtexto.

An nickname é um name.

The not tag é uma tag igual a 16.

Etapas necessárias para que se offset o locals in uma routine:
Se a routine for inexistente, cancele.
Se a compiled alarme desta routine não estiver ativo, cancele.
Limpe o  local size desta routine.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um local from os locals desta routine.
Se o local for inexistente, cancele.
Se o previous deste local não for inexistente, coloque o offset deste previous deste local into o offset deste local.
Coloque o length deste type deste local into um length.
Se a categoria deste local for "scratch", coloque um endereço de memória's magnitude into o length.
Round o length up to o nearest multiple of 4.
Subtraia o length from o offset deste local.
Adicione o length to o local size desta routine.
Repita.

Etapas necessárias para que se offset os locals in alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Offset os locals in a routine.
Repita.

Etapas necessárias para que se offset o parameters in uma routine:
Se a routine for inexistente, cancele.
Se a compiled alarme desta routine não estiver ativo, cancele.
Limpe o parameter size desta routine.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um parameter from os parameters desta routine.
Se o parameter for inexistente, cancele.
Se o callback alarme desta routine estiver ativo, acione o by-value alarme deste parameter.
Se o previous deste parameter for inexistente, coloque 8 into o offset deste parameter. \ skip o return address e saved ebp
Se o previous deste parameter não for inexistente, coloque o offset deste previous deste parameter mais 4 into o offset deste parameter. \ all parameters são 4 endereço de memória du pedaço s ou 4 pedaço values por callbacks
Adicione 4 to a parameter size desta routine.
Repita.

Etapas necessárias para que se offset o parameters in alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Offset o parameters in a routine.
Repita.

The offsetting cronômetro é um cronômetro.

An parameter é uma variable.

An partial moniker é um moniker.

An PE header é um conjunto with
\ Portable Executable (PE) file format is a file format for executable / dll files introduced in Windows NT. It is based on COFF (Common Object File Format) specification.
\To remain compatible with previous versions of the MS-DOS and Windows, the PE file format retains the old MZ header from MS-DOS.
\The PE file format is organized as a linear stream of data. 
\It begins with an MS-DOS header, a real-mode program stub, and a PE file signature. 
\Immediately following is a PE file header and optional header. Beyond that, all the section headers appear, followed by all of the section bodies. 
\Closing out the file are a few other regions of miscellaneous information, including relocation information, symbol table information, line number information, and string table data. 
\ The MS-DOS header occupies the first 64 bytes of the PE file. A structure representing its content is described below:
An número called signature,
An wyrd called machinetype, \ The number that identifies the type of target machine. For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types
An wyrd called numberofsections, \ The number of sections. This indicates the size of the section table, which immediately follows the headers.
An número called timestamp, \ The low 32 bits of the number of seconds since 00:00 January 1, 1970 (a C run-time time_t value), which indicates when the file was created.
An número called pointertosymboltable, \ The file offset of the COFF symbol table, or zero if no COFF symbol table is present. 
\This value should be zero for an image because COFF debugging information is deprecated.
An número called numberofsymbols, \ The number of entries in the symbol table. 
\This data can be used to locate the string table, which immediately follows the symbol table. 
\This value should be zero for an image because COFF debugging information is deprecated.
An wyrd called sizeofoptionalheaderinbytes, \ The size of the optional header, which is required for executable files but not for object files. 
\This value should be zero for an object file. For a description of the header format, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-image-only
An wyrd called characteristics, \ The flags that indicate the attributes of the file. For specific flag values, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics
\ optional header
An wyrd called magicnumber, \ The optional header magic number determines whether an image is a PE32 or PE32+ executable.
\PE32+ images allow for a 64-bit address space while limiting the image size to 2 gigabytes. Other PE32+ modifications are addressed in their respective sections.
\ The unsigned integer that identifies the state of the image file. 
\The most common number is 0x10B, which identifies it as a normal executable file. 0x107 identifies it as a ROM image, and 0x20B identifies it as a PE32+ executable.
\ The first field, e_magic, is the so-called magic number. 
\This field is used to identify an MS-DOS-compatible file type. 
\All MS-DOS-compatible executable files set this value to 0x5A4D, which represents the ASCII characters MZ. 
\MS-DOS headers are sometimes referred to as MZ headers for this reason. 
\Many other fields are important to MS-DOS operating systems, but for Windows NT, there is really one more important field in this structure. 
\The final field, e_lfanew, is a 4-byte offset into the file where the PE file header is located. 
\It is necessary to use this offset to locate the PE header in the file. 
\For PE files in Windows NT, the PE file header occurs soon after the MS-DOS header with only the real-mode stub program between them.
An pedaço called majorlinkerversion, \ Indicates version of the linker that linked this image.
An pedaço called minorlinkerversion, \ Indicates version of the linker that linked this image.
An número called sizeofcodeinfile, \ Size of executable code. The size of the code (text) section, or the sum of all code sections if there are multiple sections.
An número called sizeofinitializeddatainfile, \  Size of initialized data. The size of the initialized data section, or the sum of all such sections if there are multiple data sections.
An número called sizeofuninitializeddatainfile, \ Size of uninitialized data. The size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.
An número called addressofentrypointinmemory, \ Of the standard fields, the AddressOfEntryPoint field is the most interesting for the PE file format. 
\This field indicates the location of the entry point for the application and, perhaps more importantly to system hackers, the location of the end of the Import Address Table (IAT). 
\The address of the entry point relative to the image base when the executable file is loaded into memory. 
\For program images, this is the starting address. For device drivers, this is the address of the initialization function. 
\An entry point is optional for DLLs. When no entry point is present, this field must be zero.
An número called addressofcodeinmemory, \ The address that is relative to the image base of the beginning-of-code section when it is loaded into memory.
An número called addressofinitializeddatainmemory, \ The address that is relative to the image base of the beginning-of-data section when it is loaded into memory.
An número called imagebase, \  The preferred address of the first byte of image when loaded into memory; must be a multiple of 64 K. 
\The default for DLLs is 0x10000000. The default for Windows CE EXEs is 0x00010000. 
\The default for Windows NT, Windows 2000, Windows XP, Windows 95, Windows 98, and Windows Me is 0x00400000.
\Preferred base address in the address space of a process to map the executable image to. The linker defaults to 0x00400000, but you can override the default.
An número called memoryalignment, \ The alignment (in bytes) of sections when they are loaded into memory. 
\It must be greater than or equal to FileAlignment. 
\The default is the page size for the architecture.
An número called filealignment, \ The alignment factor (in bytes) that is used to align the raw data of sections in the image file. 
\The value should be a power of 2 between 512 and 64 K (65535) , inclusive. The default is 512. 
\If the SectionAlignment is less than the page size da architecture, then FileAlignment must match SectionAlignment.
An wyrd called osmajorversion, \  Indicates the major version of the Windows NT operating system.
An wyrd called osminorversion, \ Indicates the minor version of the Windows NT operating system.
An wyrd called usermajorversion, \ Used to indicate the major version number of the application.
An wyrd called userminorversion, \ Used to indicate the minor version number of the application.
An wyrd called subsystemmajorversion, \ Indicates the Windows NT Win32 subsystem major version number.
An wyrd called subsystemminorversion, \ Indicates the Windows NT Win32 subsystem minor version number.
An número called reserved, \ Reserved, must be zero. Unknown purpose, currently not used by the system and set to zero by the linker.
An número called sizeofimageinmemory, \ The size (in bytes) of the image, including all headers, as the image is loaded in memory. It must be a multiple of SectionAlignment.
\ Indicates the amount of address space to reserve in the address space for the loaded executable image. 
\This number is influenced greatly by SectionAlignment. 
\For example, consider a system having a fixed page size of 4096 bytes. 
\If you have an executable with 11 sections, each less than 4096 bytes, aligned on a 65,536-byte boundary, the SizeOfImage field would be set to 11 * 65,536 = 720,896 (176 pages). 
\The same file linked with 4096-byte alignment would result in 11 * 4096 = 45,056 (11 pages) for the SizeOfImage field. 
\This is a simple example in which each section requires less than a page of memory. 
\In reality, the linker determines the exact SizeOfImage by figuring each section individually. 
\It first determines how many bytes the section requires, then it rounds up to the nearest page boundary, and finally it rounds page count to the nearest SectionAlignment boundary. 
\The total is then the sum of each individual requirement da section.
An número called sizeofallheadersinfile, \ The combined size of an MS-DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.
\ This field indicates how much space in the file is used for representing all the file headers, 
\ including the MS-DOS header, PE file header, PE optional header, and PE section headers. The section bodies begin at this location in the file.
An número called checksum, \  The image file checksum. 
\ The algorithm for computing the checksum is incorporated into IMAGHELP.DLL. 
\ The following are checked for validation at load time: all drivers, any DLL loaded at boot time, and any DLL that is loaded into a critical Windows process.
\ A checksum value is used to validate the executable file at load time. 
\ The value is set and verified by the linker. The algorithm used for creating these checksum values is proprietary information and will not be published.
An wyrd called subsystem, \ Field used to identify the target subsystem for this executable (The subsystem that is required to run this image). 
\Each of the possible subsystem values are listed in the WINNT.H file immediately after the IMAGE_OPTIONAL_HEADER structure.
\For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#windows-subsystem
An wyrd called dllcharacteristics, \ Flags used to indicate if a DLL image includes entry points for process and thread initialization and termination.
\ For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics
An número called maxstack, \These fields control the amount of address space to reserve and commit for the stack and default heap. 
An número called minstack, \Both the stack and heap have default values of 1 page committed and 16 pages reserved.  
An número called maxheap, \These values are set with the linker switches -STACKSIZE: and -HEAPSIZE:. 
An número called minheap, 
An número called loaderflags, \ TReserved, must be zero. Tells the loader whether to break on load, debug on load, or the default, which is to let things run normally.
\ directories (16 address e size pairs)
An número called numberofdirectories,
8 pedaços called directory0,
An número called imagedirectoryentryimportaddress,
An número called imagedirectoryentryimportsize,
112 pedaços called directories2-15,
An PE section header called idata section,
An PE section header called data section,
An PE section header called code section. \ https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags

An PE section header é um conjunto with
\ Section headers are located sequentially right after the optional header in the PE file format. Each section header is 40 bytes with no padding between them. 
\The PE file specification consists of the headers defined so far and a generic object called a section. 
\Sections contain the content of the file, including code, data, resources, and other executable information. 
\Each section has a header and a body (the raw data). Section headers are described below, but section bodies lack a rigid file structure. 
\They can be organized in almost any way a linker wishes to organize them, as long as the header is filled with enough information to be able to decipher the data.
8 pedaços called name, \ Each section header has a name field up to eight characters long, for which the first character must be a period.
An número called sizeinbytes,
An número called addressinmemory,
An número called sizeinfile,
An número called addressinfile,
12 pedaços called reserved,
An número called characteristics. \ Defines the section characteristics. These values are found both in WINNT.H and in the Portable Executable Format specification.
\Value	Definition
\0x00000020	Code section
\0x00000040	Initialized data section
\0x00000080	Uninitialized data section
\0x04000000	Section cannot be cached
\0x08000000	Section is not pageable
\0x10000000	Section is shared
\0x20000000	Executable section
\0x40000000	Readable section
\0x80000000	Writable section

An phrase é um string.

\Etapas necessárias para que se determine se um string looks like English:
\Load o lexicon.
\Se o lexicon for inexistente, mostre erro "I can't find any lecksicon."; diga não.
\Se o string estiver em branco, diga não.
\Lance um subtexto on o string.
\Coloque o last deste subtexto into o first deste subtexto.
\Percorra.
\Se o first deste subtexto é o first deste string, pare.
\Se o target deste first deste subtexto for o space pedaço, adicione 1 to o first deste subtexto; break.
\Subtraia 1 from o first deste subtexto.
\Repita.
\Se o subtexto estiver in o index deste lexicon, diga sim.
\Diga não.

Etapas necessárias para que se pluralize um string (portuguese rules):
Lance um percorredor on o string.
Percorra.
Mova o percorredor (spell checking rules).
Se o token deste percorredor estiver em branco, pare.
Se um plural string não estiver em branco, posponha " " to o plural string.
Posponha o token deste percorredor to o plural string.
Se o token deste percorredor for "de", acione um alarme; repita. \ aqui identifica um termo composto. Falta implementar.
Se o alarme não estiver ativo, pluralize o plural string (portuguese rules - each palavra).
\ Se o alarme estiver ativo, pluralize o plural string (substantivos compostos).
Repita.
Coloque o plural string into o string.

Etapas necessárias para que se pluralize um string (portuguese rules - each palavra):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se o string for "cidadão", posponha "s" to o string; exit.
Se o string for "irmão", posponha "s" to o string; exit.
Se o string for "cristão", posponha "s" to o string; exit.
Se o string for "refrão", posponha "s" to o string; exit.
Se o string for "pão", remove o last pedaço from o string; posponha "es" to o string; exit.
Se o string for "capitão", remove o last pedaço from o string; posponha "es" to o string; exit.
Se o string for "alemão", remove o last pedaço from o string; posponha "es" to o string; exit.
Se o string for "charlatão", remove o last pedaço from o string; posponha "es" to o string; exit.
Se o string for "caráter", coloque "carateres" into o string; exit.
Se o string for "júnior", coloque "juniores" into o string; exit.
Se o string for "sênior", coloque "seniores" into o string; exit.
Se o string for "mão", coloque "mãos" into o string; exit.
Se o string for "são", coloque "sãos" into o string; exit.
\# advérbios principais
Se o string for "muito", cancele.
Se o string for "pouco", cancele.
Se o string for "mais", cancele.
Se o string for "menos", cancele.
Se o string for "bastante", cancele.
Se o string for "quase", cancele.
Se o string for "demais", cancele.
Se o string for "bem", cancele.
Se o string for "deveras", cancele.
Se o string for "mal", cancele.
Se o string for "melhor", cancele.
Se o string for "pior", cancele.
\# palavras terminadas com "ão"
Se o string ends with "ão", pluralize o string (portuguese rules - ending palavras with "ão"); exit.
\# palavras terminadas com "l"
Se o string ends with "l", pluralize o string (portuguese rules - ending palavras with "l"); exit.
\# palavra terminadas com "m"
Se o string ends with "m", remove o last pedaço from o string; posponha "ns" to o string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se o string ends with "n", posponha "es" to o string; exit.
\# palavras terminadas com "r"
Se o string ends with "r", pluralize o string (portuguese rules - ending palavras with "r"); exit.
\# palavras terminadas com "s"
Se o string ends with "s", pluralize o string (portuguese rules - ending palavras with "s"); exit.
\# palavra terminadas com "x"
Se o string ends with "x", cancele.
\# palavras terminadas com "z"
Se o string ends with "z", pluralize o string (portuguese rules - ending palavras with "z"); exit.
\# regra padrão
Posponha "s" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "ão"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "s" to o string; exit.
\# regra padrão
Remove os last dois pedaços from o string.
Posponha "ões" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "l"):
\# palavras terminadas com "al"
Se o string ends with "al", remove o last pedaço from o string; posponha "is" to o string; exit.
\# palavras terminadas com "el"
Se o string ends with "el", pluralize o string (portuguese rules - ending palavras with "el"); exit.
\# palavras terminadas com "il"
Se o string ends with "il", pluralize o string (portuguese rules - ending palavras with "il"); exit.
\# palavras terminadas com "ol"
Se o string ends with "ol", pluralize o string (portuguese rules - ending palavras with "ol"); exit.
\# palavras terminadas com "ul"
Se o string ends with "ul", remove o last pedaço from o string; posponha "is" to o string; exit.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "el"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last pedaço from o string; posponha "is" to o string; exit.
Remove os last dois pedaços from o string.
Posponha "éis" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "il"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove os last dois pedaços from o string; posponha "eis" to o string; exit.
Remove o last pedaço from o string.
Posponha "s" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "ol"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last pedaço from o string; posponha "is" to o string; exit.
Remove os last dois pedaços from o string.
Posponha "óis" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "r"):
\# hiatos acentuados
\Se o string ends with "aír", posponha "es" to o string; exit.
\Se o string ends with "aúr", posponha "es" to o string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se o string ends with "ár", remove os last dois pedaços from o string; posponha "ares" to o string; exit.
\Se o string ends with "âr", remove os last dois pedaços from o string; posponha "ares" to o string; exit.
\Se o string ends with "ér", remove os last dois pedaços from o string; posponha "eres" to o string; exit.
\Se o string ends with "êr", remove os last dois pedaços from o string; posponha "eres" to o string; exit.
\Se o string ends with "ír", remove os last dois pedaços from o string; posponha "ires" to o string; exit.
\Se o string ends with "ór", remove os last dois pedaços from o string; posponha "ores" to o string; exit.
\Se o string ends with "ôr", remove os last dois pedaços from o string; posponha "ores" to o string; exit.
\Se o string ends with "úr", remove os last dois pedaços from o string; posponha "ures" to o string; exit.
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "es" to o string; exit.
\# hiatos
Se o string ends with "air", remove os last dois pedaços from o string; posponha "íres" to o string; exit.
Se o string ends with "aur", remove os last dois pedaços from o string; posponha "úres" to o string; exit.
\# regra padrão
Posponha "es" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se o string ends with "as", cancele.
Se o string ends with "es", cancele.
Se o string ends with "os", cancele.
\# hiatos acentuados
Se o string ends with "aís", posponha "es" to o string; exit.
Se o string ends with "aús", posponha "es" to o string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se o string ends with "ás", remove os last dois pedaços from o string; posponha "ases" to o string; exit.
Se o string ends with "âs", remove os last dois pedaços from o string; posponha "ases" to o string; exit.
Se o string ends with "és", remove os last dois pedaços from o string; posponha "eses" to o string; exit.
Se o string ends with "ês", remove os last dois pedaços from o string; posponha "eses" to o string; exit.
Se o string ends with "ís", remove os last dois pedaços from o string; posponha "ises" to o string; exit.
Se o string ends with "ós", remove os last dois pedaços from o string; posponha "oses" to o string; exit.
Se o string ends with "ôs", remove os last dois pedaços from o string; posponha "oses" to o string; exit.
Se o string ends with "ús", remove os last dois pedaços from o string; posponha "uses" to o string; exit.
\# palavras terminadas com "is", "us"
Se o string ends with "is", pluralize o string (portuguese rules - ending palavras with "is/us"); exit.
Se o string ends with "us", pluralize o string (portuguese rules - ending palavras with "is/us"); exit.
\# regra padrão
Posponha "es" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "is/us"):
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, cancele.
\# hiatos
Se o string ends with "ais", remove os last dois pedaços from o string; posponha "íses" to o string; exit.
Se o string ends with "aus", remove os last dois pedaços from o string; posponha "úses" to o string; exit.
\# regra padrão
Posponha "es" to o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "z"):
\# hiatos acentuados
Se o string ends with "aíz", posponha "es" to o string; exit.
Se o string ends with "aúz", posponha "es" to o string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se o string ends with "áz", remove os last dois pedaços from o string; posponha "azes" to o string; exit.
Se o string ends with "âz", remove os last dois pedaços from o string; posponha "azes" to o string; exit.
Se o string ends with "éz", remove os last dois pedaços from o string; posponha "ezes" to o string; exit.
Se o string ends with "êz", remove os last dois pedaços from o string; posponha "ezes" to o string; exit.
Se o string ends with "íz", remove os last dois pedaços from o string; posponha "izes" to o string; exit.
Se o string ends with "óz", remove os last dois pedaços from o string; posponha "ozes" to o string; exit.
Se o string ends with "ôz", remove os last dois pedaços from o string; posponha "ozes" to o string; exit.
Se o string ends with "úz", remove os last dois pedaços from o string; posponha "uzes" to o string; exit.
\# acentos em sílabas prévias
Lance um subtexto on o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "es" to o string; exit.
\# hiatos
Se o string ends with "aiz", remove os last dois pedaços from o string; posponha "ízes" to o string; exit.
Se o string ends with "auz", remove os last dois pedaços from o string; posponha "úzes" to o string; exit.
\# regra padrão
Posponha "es" to o string.

Etapas necessárias para que se pluralize um string (english rules);
Etapas necessárias para que se pluralize um string:
\ nouns only
Se o string for "alumnus", coloque "alumni" into o string; exit.
Se o string for "auto", coloque "autos" into o string; exit.
Se o string for "botão", coloque "botões" into o string; exit.
Se o string for "cello", coloque "cellos" into o string; exit.
Se o string for "dwarf", coloque "dwarfs" into o string; exit.
Se o string for "foot", coloque "feet" into o string; exit.
Se o string for "forma", coloque "formas" into o string; exit.
Se o string for "genus", coloque "genera" into o string; exit.
Se o string for "goose", coloque "geese" into o string; exit.
Se o string for "hippo", coloque "hippos" into o string; exit.
Se o string for "louse", coloque "lice" into o string; exit.
Se o string for "memo", coloque "memos" into o string; exit.
Se o string for "mouse", coloque "mice" into o string; exit.
Se o string for "ox", coloque "oxen" into o string; exit.
Se o string for "phenomenon", coloque "phenomena" into o string; exit.
Se o string for "photo", coloque "photos" into o string; exit.
Se o string for "phylum", coloque "phyla" into o string; exit.
Se o string for "piano", coloque "pianos" into o string; exit.
Se o string for "pimento", coloque "pimentos" into o string; exit.
Se o string for "pro", coloque "pros" into o string; exit.
Se o string for "proof", coloque "proofs" into o string; exit.
Se o string for "radius", coloque "radii" into o string; exit.
Se o string for "rhinoceros", coloque "rhinoceri" into o string; exit.
Se o string for "roof", coloque "roofs" into o string; exit.
Se o string for "solo", coloque "solos" into o string; exit.
Se o string for "soprano", coloque "sopranos" into o string; exit.
Se o string for "staff", coloque "staffs" into o string; exit.
Se o string for "tooth", coloque "teeth" into o string; exit.
Se o string for "torus", coloque "tori" into o string; exit.
Se o string for "turf", coloque "turfs" into o string; exit.
Se o string for "virus", coloque "viruses" into o string; exit.
Se o string ends with "sh", posponha "es" to o string; exit.
Se o string ends with "ch", posponha "es" to o string; exit.
Se o string ends with "man", remove os last dois pedaços from o string; posponha "en" to o string; exit.
Se o string ends with "child", posponha "ren" to o string; exit.
Se o string ends with "ex", remove os last dois pedaços from o string; posponha "ices" to o string; exit. \ ou adicione ES
Se o string ends with "fe", remove os last dois pedaços from o string; posponha "ves" to o string; exit.
Se o string ends with "is", remove os last dois pedaços from o string; posponha "es" to o string; exit.
Se o string ends with "ix", remove os last dois pedaços from o string; posponha "ices" to o string; exit. \ ou adicione ES
Se o string ends with "ma", posponha "ta" to o string; exit. \ ou adicione S
Se o string ends with any consonant e "y", remove o last pedaço from o string; posponha "ies" to o string; exit.
Se o string ends with any vowel e "o", posponha "s" to o string; exit.
Se o string ends with any vowel e "y", posponha "s" to o string; exit.
Se o string ends with "f", remove o last pedaço from o string; posponha "ves" to o string; exit.
Se o string ends with "s", posponha "es" to o string; exit.
Se o string ends with "x", posponha "es" to o string; exit.
Se o string ends with "z", posponha "es" to o string; exit.
Posponha "s" to o string.

The prolog tag é uma tag igual a 17.

An prototype string é um conjunto with um first endereço de memória du pedaço e um last endereço de memória du pedaço .

The push address tag é uma tag igual a 18.

The push value tag é uma tag igual a 19.

Etapas necessárias para que se coloque o endereço exe completo deste compilador into um endereço completo:
Extract um designador from o endereço dâ pasta deste compilador.
Remove any trailing barra invertida from o designador.
Coloque o endereço dâ pasta deste compilador then o designador then ".exe" into o endereço completo.

Etapas necessárias para que se coloque o exe size deste compilador into um size:
Coloque 4096 [section base] into o size.
Adicione o size desta import zona to o size.
Adicione o size desta zona de dados to o size.
Adicione o size desta code zona to o size.

Etapas necessárias para que se coloque o listing endereço completo deste compilador into um endereço completo:
Extract um designador from o endereço dâ pasta deste compilador.
Remove any trailing barra invertida from o designador.
Coloque o endereço dâ pasta deste compilador then o designador then ".lst" into o endereço completo.

Etapas necessárias para que se coloque um term into another term:
Coloque a variable deste term into o variable deste other term.
Coloque a phrase deste term into o phrase deste other term.

Etapas necessárias para que se load um source file:
Se o source file for inexistente, cancele.
\Load o endereço completo deste source file into o trecho deste source file.
\Se o i/o erro não estiver em branco, abort with "Não foi possível carregar o arquivo: '" then o endereço completo deste source file then "'."; exit.
Load o endereço completo deste source file into um string.
Se o i/o erro não estiver em branco, abort with "Não foi possível carregar o arquivo '" then o endereço completo deste source file then "'."; exit.
Parse o string to o trecho deste source file (portuguese contractions e synonyms rules).

Etapas necessárias para que se load alguns source files:
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um item from o endereço dâ pasta deste compilador.
Se o item não for found, pare.
Se a categoria deste item não for "file", repita.
Se a extensão deste item não estiver em branco, repita.
Se o item looks reamish, repita.
Adicione um source file to o source files usando o endereço completo deste item.
Load o source file.
Repita.

The loading cronômetro é um cronômetro.

Etapas necessárias para que se parse um string to another string (portuguese contractions e synonyms rules):
Limpe o other string.
Limpe um third string.
Lance um percorredor on o string.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Position o token deste percorredor on o source deste percorredor.
Mova o percorredor (code rules).
Se o target deste first deste token deste percorredor não for any glom pedaço, posponha o token deste percorredor to o other string; repita.
Posponha o token deste percorredor to o other string giving o third string (portuguese contractions e synonyms rules).
Coloque o token deste percorredor into o third string.
Repita.

Etapas necessárias para que se reduce alguns monikettes por utility use:
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Se o type deste monikette for inexistente, repita.
Reduce o type deste monikette to um type por utility use.
Se o type não for inexistente, coloque o type into o type deste monikette.
Repita.

Etapas necessárias para que se reduce um type to another type por utility use:
Coloque o type into o other type.
Percorra.
Se o other type for inexistente, cancele.
Se o name deste other type for "texto hexadecimal", cancele.
Se o name deste other type for "string", cancele.
Se o name deste other type for "número", cancele.
Se o name deste other type for "endereço de memória", cancele.
Se o name deste other type for "coisa", esvazie o other type; exit.
\PAL
\Se o name  deste other type for "elemento", esvazie o other type; exit.
Se o base type deste other type for o other type, esvazie o other type; exit.
Coloque o base type deste other type into o other type.
Repita.

Etapas necessárias para que se catalogue novamente o catálogo de rotinas úteis:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um bucket usando o catálogo de rotinas úteis.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Catalogue novamente o catálogo de rotinas úteis usando os refers deste bucket.
Repita.

Etapas necessárias para que se catalogue novamente o catálogo de rotinas úteis usando alguns refers:
Obtenha um refer from o refers.
Se o refer for inexistente, cancele.
Coloque o endereço de memória deste refer into uma routine.
Se a routine for inexistente, abort with "Erro interno na função: index o utility routines usando alguns refers"; exit.
Copy os monikettes desta routine into alguns monikettes.
Reduce os monikettes por utility use.
Catalogue a routine usando os monikettes e o catálogo geral de rotinas.
Destroy os monikettes.
Repita.

Etapas necessárias para que se remove any negatives from alguns monikettes returning um alarme:
Desative o alarme.
Swap os monikettes with alguns other monikettes.
Percorra.
Coloque o first destes other monikettes into um monikette.
Se o monikette for inexistente, cancele.
Remove o monikette from o other monikettes.
\PAL
Se o string deste monikette for "não", reverse o alarme; destroy o monikette; repita.
Se o string deste monikette for "nada", reverse o alarme; destroy o monikette; repita.
\CAL
Se o string deste monikette for "not", reverse o alarme; destroy o monikette; repita.
Se o string deste monikette for "nada", reverse o alarme; destroy o monikette; repita.
Posponha o monikette to os monikettes.
Se o string deste monikette for "can't", reverse o alarme; coloque "can" into o string deste monikette; repita.
Se o string deste monikette for "cannot", reverse o alarme; coloque "can" into o string deste monikette; repita.
Se o string deste monikette for "nothing", reverse o alarme; coloque "something" into o string deste monikette; repita.
Se o string deste monikette for "won't", reverse o alarme; coloque "will" into o string deste monikette; repita.
Se o string deste monikette ends with "n't", reverse o alarme; remove trailing pedaços from o string deste monikette usando 3; repita.
Repita.

The repeat tag é uma tag igual a 21.

Etapas necessárias para que se resolva um field:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o field for inexistente, cancele.
Resolva o field como uma variable.
Se o nickname deste field não for any valid field name, limpe o nickname deste field. \it
Se o name deste field não for any valid field name, abort with "'" then o name deste field then "' é um field name inválido." e o locus deste field; exit.

Etapas necessárias para que se resolva um global:
Se o global for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o global body deste global não estiver em branco, resolva o global (compile body).
Se o type name deste global estiver em branco, abort with "Tipo inválido: '" then o name deste global then "' . O tipo da variável global está vazio." e o locus deste global; exit.
Resolva o global como uma variable.

Etapas necessárias para que se resolva um global (compile body):
Se o global for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor on o global body deste global.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any literal, abort with "Erro de tipo. O tipo: '" then o token deste percorredor then "' tem que ser do tipo literal." e o percorredor; exit.
Compile um literal usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não estiver em branco, abort with "Acho que era bom colocar um ponto por aqui, né?" e o percorredor; exit.
Se o type name deste global estiver em branco, coloque o name deste type deste literal into o type name deste global.
Coloque o literal into o literal deste global.
Catalogue o literal.

Etapas necessárias para que se resolva alguns globals:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Resolva o global.
Repita.

Etapas necessárias para que se resolva um type (base type):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o base type deste type não for inexistente, cancele.
Encontre o base type deste type usando o base name deste type e o catálogo de tipos.
Se o base type deste type for inexistente, abort with "Base type inválido:'" then o base name deste type then "'." e o locus deste type; exit.
Ligue o cooking alarme deste type.
Se o cooking alarme deste base type deste type estiver ativo, abort with "Definição recursiva com '" then o base name deste type then "'." e o locus deste type; exit.
Resolva o base type deste type (base type).
Desative o cooking alarme deste type.

Etapas necessárias para que se resolva um type (expand coisa): \ base type deste type não está resolved yet
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o base type deste type não for inexistente, cancele.
Se o name deste type for "coisa", cancele.
\Se o name deste type for "elemento", cancele.
Se o type não puder ser reduzido para "coisa" using o base name, cancele.
Encontre um base type usando o base name deste type e o catálogo de tipos.
\ adicione coisa conjunto - o número of secret fields é hard coded in two places: search por "du que 4" \ was 6
Coloque o name deste type then " conjunto" into um name.
Coloque o name deste type then " conjuntos" into um plural name.
Coloque o name deste base type then " conjunto" into um base name.
Adicione um conjunto type to o types usando o name e o plural name e o base name.
Adicione um field to os fields deste conjunto type usando "next " then o name deste type e "next" e o name deste type e o alarme de ignição.
\PAL
Adicione um portuguese field to os fields deste conjunto type usando "seguinte " then o name deste type e "seguinte" e o name deste type e o alarme de ignição.
Coloque "next " then o name deste type into o redefinition target name deste portuguese field.
\Adicione um portuguese reverse field to os fields deste conjunto type usando o name deste type then " seguinte" e "seguinte" e o name deste type e o alarme de ignição.
\Coloque "next " then o name deste type into o redefinition target name deste portuguese reverse field.
Adicione another field to os fields deste conjunto type usando "previous " then o name deste type e "previous" e o name deste type e o alarme de ignição.
\Adicione another portuguese field to os fields deste conjunto type usando "anterior " then o name deste type e "anterior" e o name deste type e o alarme de ignição.
\Coloque "previous " then o name deste type into o redefinition target name deste other portuguese field.
Adicione another portuguese reverse field to os fields deste conjunto type usando o name deste type then " anterior" e "anterior" e o name deste type e o alarme de ignição.
Coloque "previous " then o name deste type into o redefinition target name deste other portuguese reverse field.
Se os fields deste type não estiverem vazio, posponha os fields deste type to os fields deste conjunto type.
Catalogue o conjunto type.
\ fix up original type to look like um endereço de memória
Coloque o name deste conjunto type into o target name deste type.
\ adicione chain type
Adicione um chain type to o types usando o plural name deste type e "" e o plural name deste base type.
Adicione um third field to os fields deste chain type usando "first " then o name deste type e "first" e o name deste type e o alarme de ignição.
Adicione um third portuguese field to os fields deste chain type usando "primeiro " then o name deste type e "primeiro" e o name deste type e o alarme de ignição.
Coloque "first " then o name deste type into o redefinition target name deste third portuguese field.
Adicione um third feminine portuguese field to os fields deste chain type usando "primeira " then o name deste type e "primeira" e o name deste type e o alarme de ignição.
Coloque "first " then o name deste type into o redefinition target name deste third feminine portuguese field.
Adicione um fourth field to os fields deste chain type usando "last " then o name deste type e "last" e o name deste type e o alarme de ignição.
Adicione um fourth portuguese field to os fields deste chain type usando "último " then o name deste type e "último" e o name deste type e o alarme de ignição.
Coloque "last " then o name deste type into o redefinition target name deste fourth portuguese field.
Adicione um fourth portuguese feminine field to os fields deste chain type usando "última " then o name deste type e "última" e o name deste type e o alarme de ignição.
Coloque "last " then o name deste type into o redefinition target name deste fourth portuguese feminine field.
Catalogue o chain type.

Etapas necessárias para que se resolva um type (registro de plurais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o plural name deste type estiver em branco, cancele.
Se o type puder ser reduzido para "coisa" using o base name, cancele.
Catalogue o type usando o plural name deste type.

Etapas necessárias para que se resolva um type (optional info - endereço de memória):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o target type deste type não for inexistente, cancele.
Se o target name deste type estiver em branco, coloque o target type deste base type deste type into o target type deste type; exit.
Encontre o target type deste type usando o target name deste type e o catálogo de tipos.
Se o target type deste type for inexistente, abort with "Não sei bem pra que coisa você está pointing at." e o locus deste type; exit.

Etapas necessárias para que se resolva um type (optional info - conjunto):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se os fields deste type estiverem vazio, copy os fields deste base type deste type into os fields deste type; exit.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um field from os fields deste type (backwards).
Se o field for inexistente, pare.
Se o field estiver duplicated in os fields deste type, abort with "O campo '" then o name deste field then "' está definido mais de uma vez." e o locus deste field; exit.
Resolva o field.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o cooking alarme deste type deste field estiver ativo, abort with "Recursive definition no: '" then o name deste type deste field then "'." e o locus deste field; exit.
Resolva o type deste field (optional info). \ de novo
Se o reference alarme deste field não estiver ativo, repita.
Se o type deste field não puder ser reduzido para "endereço de memória", abort with "Não entendi o parâmetro '(reference)' nesse campo '" then o name deste field then "'..." e o locus deste field; exit.
Repita.
Eliminate duplicate nicknames from os fields deste type.
Se o type não puder ser reduzido para "coisa conjunto", cancele.
Se a contagem destes fields deste type for maior du que 4, cancele. \ already copied? was 2 por next e prev, now 6 to included Spanish redefiniions
Copy os fields deste base type deste type into os fields deste type (data fields only).

Etapas necessárias para que se resolva um type (optional info - scale):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque o base type deste type into um base type.
Se a scale deste type for 0, coloque o scale deste base type deste type into o scale deste type; exit.
Se a scale deste base type for 0, cancele.
Multiplique o scale deste type por a scale deste base type.
Coloque o base type deste base type into o base type deste type.

Etapas necessárias para que se resolva um type (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o optional info resolved alarme deste type estiver ativo, cancele.
Se o base type deste type for o type, cancele. \ por built in types
Check por invalid optional info on o type.
Ligue o cooking alarme deste type.
Resolva o base type deste type (optional info).
Se o type puder ser reduzido para "endereço de memória", resolva o type (optional info - endereço de memória).
Se o type puder ser reduzido para "conjunto", resolva o type (optional info - conjunto). \ mudar aqui
Se o type puder ser reduzido para "número", resolva o type (optional info - scale).
Desative o cooking alarme deste type.
Ligue o optional info resolved alarme deste type.

Etapas necessárias para que se resolva alguns types (base types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (base type).
Repita.

Etapas necessárias para que se resolva alguns types (expand coisas):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (expand coisa).
Repita.

Etapas necessárias para que se resolva alguns types (registro de plurais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (registro de plurais).
Repita.

Etapas necessárias para que se resolva alguns types (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (optional info).
Repita.

Etapas necessárias para que se resolva uma variable:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Se a type desta variable não for inexistente, cancele.
Se o type name desta variable não estiver em branco, resolva o variable (explicit type name); exit.
Encontre o type desta variable e o nickname desta variable usando o name desta variable.
Se o type desta variable não for inexistente, coloque o name deste type desta variable into o type name desta variable; exit.
Abort with "Não achei o tipo da variável '" then o name desta variable then "'." e o locus desta variable.

Etapas necessárias para que se resolva uma variable (explicit type name):
Encontre o type desta variable usando o type name desta variable e o catálogo de tipos.
Se o type desta variable for inexistente, abort with "Não achei o nome do tipo da variável '" then o type name desta variable then "'." e o locus desta variable; exit.

The resolving globals cronômetro é um cronômetro.

The resolving types cronômetro é um cronômetro.

Etapas necessárias para que se round up zona sizes:
Coloque o length desta import zona into o size desta import zona.
Round o size desta import zona up to o nearest multiple of 4096.
Coloque o length desta zona de dados into o size desta zona de dados.
Round o size desta zona de dados up to o nearest multiple of 4096.
Coloque o length desta code zona into o size desta code zona.
Round o size desta code zona up to o nearest multiple of 4096.

The routine address tag é uma tag igual a 22.

An instruções é um subtexto.

An routine header é um subtexto.

The catálogo geral de rotinas é um index.

An routine é uma coisa with
An locus (reference),
An callback alarme,
An decider alarme,
An function alarme,
An compiled alarme,
An nickname index,
An moniker, alguns monikettes, alguns parameters, um parameter size,
An employs moniker,
Some locals, um local size,
An routine header, um header string,
An instruções, um body string,
Some fragments,
An address.

An routine reference é alguns monikettes.

The routines são algumas routines.

The save eax tag é uma tag igual a 20.

Etapas necessárias para que se examine any optional info por um type usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for "to", examine any optional info por o type usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for "para", examine any optional info por o type usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for any with, examine any optional info por o type usando o percorredor (conjunto); exit.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (endereço de memória):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "A palavra 'to' precisa de um artigo indefinido depois dela, não de um '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o target name deste type usando o percorredor.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (conjunto):
Mova o percorredor (compilador rules).
Examine o fields deste type usando o percorredor.

Etapas necessárias para que se examine any pauses usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any pause, cancele.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um field usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Examine o field usando o percorredor (type part).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any called, examine o field usando o percorredor (called part); repita.
Se o token deste percorredor for "at", examine o field usando o percorredor (redefine part); repita.
Se o token deste percorredor for "em", examine o field usando o percorredor (redefine part); repita.
Se o token deste percorredor for "redefinindo", examine o field usando o percorredor (redefine part); repita.
Se o token deste percorredor for any reference, examine o field usando o percorredor (reference part); repita.

Etapas necessárias para que se examine um field usando um percorredor (called part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o type name deste field estiver em branco, coloque o name deste field into o type name deste field. \ pedaço array type name already filled in
Examine o name deste field usando o percorredor.

Etapas necessárias para que se examine um field usando um percorredor (redefine part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo definido, abort with "Eu estava esperando o artigo 'the', mas o que encontrei foi '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o redefinition target name deste field usando o percorredor.

Etapas necessárias para que se examine um field usando um percorredor (reference part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Ligue o reference alarme deste field.

Etapas necessárias para que se examine um field usando um percorredor (type part - pedaço array):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to um ratio.
Reduce o ratio.
Se o denominador desta ratio não for 1, abort with "Você tem que especificar um número completo de pedaços para um pedaço array" e o percorredor; exit.
Coloque o numerador desta ratio into o contagem deste field.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for "pedaço" ou "pedaços", abort with "Você precisa usar a palavra 'pedaços' depois de um counted field designador." e o percorredor; exit.
Mova o percorredor (compilador rules).
Coloque "pedaço" into o type name deste field.

Etapas necessárias para que se examine um field usando um percorredor (type part - normal):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any artigo indefinido, abort with "Falta por um artigo idefinido aqui, mas você colocou isso: '" then o token deste percorredor then "'." e o percorredor; exit.
Se o token deste percorredor for "another", coloque "other" into o name deste field.
\PAL
Se o token deste percorredor for "outra", coloque "segunda" into o name deste field.
Se o token deste percorredor for "outro", coloque "segundo" into o name deste field.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o name deste field with o name.

Etapas necessárias para que se examine um field usando um percorredor (type part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any numeric literal, examine o field usando o percorredor (type part - pedaço array); exit.
Examine o field usando o percorredor (type part - normal).

Etapas necessárias para que se examine alguns fields usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um field to o fields usando "field" e o first deste token deste percorredor.
Examine o field usando o percorredor.
Se o token deste percorredor não for any pause, cancele.
Examine any pauses usando o percorredor.
Repita.

Etapas necessárias para que se examine um global body usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Coloque o first deste token deste percorredor into o first deste global body.
Coloque -1 into o last deste global body.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o sinal de dois pontos, cancele.
Se o token deste percorredor for o ponto final, cancele.
Coloque o last deste token deste percorredor into o last deste global body.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um global usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione o global to o globals usando "global" e o first deste token deste percorredor.
Mova o percorredor (compilador rules).
Examine o name deste global usando o percorredor.
Se o token deste percorredor for any has, examine o global usando o percorredor (has ou have); exit.
Se o token deste percorredor não for any is, abort with "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, examine o global usando o percorredor (literal term); exit.
Mova o percorredor (compilador rules).
Examine o type name deste global usando o percorredor.
Se o token deste percorredor for o start of any optional info, examine o global usando o percorredor (optional info); exit.
Se o token deste percorredor for any operador de atribuição, examine o global usando o percorredor (data part); exit.
Se o token deste percorredor não for o ponto final, abort with "Toda definição precisa terminar com um ponto. Inclusive essa." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (data part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any to, abort with "Depois da palavra 'equal' você precisa por um palavra 'to'. Você colocou ; '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o global body deste global usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Falta terminar um frase com um ponto." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (has ou have):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Coloque "~inline " then o name deste global then " type" into um name.
Coloque o name then "s" into um plural name.
Adicione um type to os types usando o name e o plural name e "conjunto" e o locus deste global. \mudar aqui
Catalogue o type.
Coloque o name deste type into o type name deste global.
Examine os fields deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Aprenda a escrever direito. Cadê o ponto?." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (literal term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Examine o global body deste global usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Aprenda a escrever corretamente. Cadê o ponto final?." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Coloque "~inline " then o name deste global then " type" into um name.
Coloque o name then "s" into um plural name.
Adicione um type to o types usando o name e o plural name e o type name deste global e o locus deste global.
Catalogue o type.
Coloque o name deste type into o type name deste global.
Examine any optional info por o type usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Tá na hora de aprender a escrever direito. Cadê o ponto?." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um name usando um percorredor:
Limpe o name.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor está on any name starter, extend o name with o token deste percorredor; mova o percorredor (compilador rules).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor está on any name ender, pare.
Extend o name with o token deste percorredor.
Mova o percorredor (compilador rules).
Repita.
Se o name estiver em branco, abort with "Acho que faltou colocar um nome por aqui. Você escreveu '" then o token deste percorredor then "'." e o percorredor; exit.

Etapas necessárias para que se examine uma instruções usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o start of any definition, cancele.
Coloque o first deste token deste percorredor into o first destas instruções.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Coloque o last deste token deste percorredor into o last destas instruções.
Se o token deste percorredor for o sinal de dois pontos, abort with "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e o percorredor; exit.
Se o token deste percorredor não for o ponto final, mova o percorredor (compilador rules); repita.
Mova o percorredor (compilador rules).
Se o token deste percorredor for o start of any definition, cancele.
Repita.

Etapas necessárias para que se examine uma routine usando um percorredor:
\ Define o cabeçalho de rotina.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione a routine to a routines usando o first deste token deste percorredor.
Mova o percorredor (compilador rules). \ skip o "Passos" e obtenha o next token
Se o token deste percorredor for "necessários" ou "necessárias", mova o percorredor (compilador rules).
Se o token deste percorredor não for "para", abort with "Você precisa escrever 'para' antes de '" then o token deste percorredor then "' nesse tipo de rotina." e o percorredor; exit.
Mova o percorredor (compilador rules). \ skip o "para" e obtenha o next token
Se o token deste percorredor for "que", mova o percorredor (compilador rules).
\Se o token deste percorredor não for "que", abort with "Você precisa colocar um 'que' antes da palavra '" then o token deste percorredor then "'." e o percorredor; exit.
\Mova o percorredor (compilador rules). \ skip o "que" e obtenha o next token
Se o token deste percorredor for "se", mova o percorredor (compilador rules).
\Se o token deste percorredor não for "se", abort with "Você precisa colocar um 'se' antes da palavra '" then o token deste percorredor then "'." e o percorredor; exit.
\Mova o percorredor (compilador rules). \ skip o "se" e obtenha o next token
Examine a routine header desta routine usando o percorredor.
Se o token deste percorredor for o ponto&vírgula, examine a routine usando o percorredor (alternate palavraing); exit. \ *** por alternate palavraings
Se o token deste percorredor não for o sinal de dois pontos, abort with "O nome dessa função está escrito errado.." e o locus desta routine; exit.
Mova o percorredor (compilador rules).
Examine as instruções desta routine usando o percorredor.

Etapas necessárias para que se examine uma routine usando um percorredor (alternate palavraing):
\ *** por alternate palavraings
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o start of any routine, abort with "Esse ponto e vírgula tá no lugar errado." e o original percorredor; exit.
Coloque o first deste token deste original percorredor into o first destas instruções desta routine.
Coloque o last deste token deste original percorredor into o last destas instruções desta routine.
Mova o original percorredor (compilador rules).

Etapas necessárias para que se examine uma routine header usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Coloque o first deste token deste percorredor into o first deste routine header.
Coloque -1 into o last deste routine header.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o ponto&vírgula, cancele. \ *** alternate palavraings
Se o token deste percorredor for o sinal de dois pontos, cancele.
Se o token deste percorredor for o ponto final, cancele.
Coloque o last deste token deste percorredor into o last deste routine header.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um source file:
Se o source file for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor on o trecho deste source file.
Mova o percorredor (compilador rules).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o start of any type, examine um type usando o percorredor; repita.
Se o token deste percorredor for o start of any global, examine um global usando o percorredor; repita.
Se o token deste percorredor for o start of any routine, examine uma routine usando o percorredor; repita.
Abort with "Faltou definir melhor o que é o '" then o token deste percorredor then "'." e o percorredor.
Repita.

Etapas necessárias para que se examine alguns source files:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um source file from o source files.
Se o source file for inexistente, cancele.
Examine o source file.
Repita.

Etapas necessárias para que se examine um type usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any artigo definido português, acione um portuguese alarme.
Se o token deste percorredor for any artigo definido inglês, acione um english alarme.
Adicione o type to o types usando o first deste token deste percorredor.
Mova o percorredor (compilador rules).
Examine o name deste type usando o percorredor.
Coloque o name deste type into o plural name deste type.
Se o portuguese alarme estiver ativo, pluralize o plural name deste type (portuguese rules).
Se o english alarme estiver ativo, pluralize o plural name deste type (english rules).
Se o english alarme não estiver ativo, pluralize o plural name deste type (portuguese rules).
Se o token deste percorredor for any has, examine o type usando o percorredor (has ou have); exit.
Se o token deste percorredor não for any is, abort with "Eu esperava um 'is' ou um 'are', mas só achei um : '" then o token deste percorredor then "'." e o percorredor; exit.
\Pluralize o plural name deste type.
\Se o token deste percorredor for "has" ou "have", examine o type usando o percorredor (has ou have); exit.
\Se o token deste percorredor não for "is" ou "are", abort with "I was expecting um 'is' ou 'are', but I found '" then o token deste percorredor then "'." e o percorredor; exit.

Mova o percorredor (compilador rules).
Se o token deste percorredor for any numeric literal, examine o type usando o percorredor (unit of measure); exit.
Se o token deste percorredor não for any artigo indefinido, abort with "Faltou um artigo indefinido, lembra? '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o base name deste type usando o percorredor.
Examine any optional info por o type usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Você precisa usar um ponto para definir um tipo, lembra? Você usou '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (has ou have):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Coloque "conjunto" into o base name deste type. \\mudar aqui
Examine o fields deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Ao invés de usar o ponto para definir tipo, você usou '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (unit of measure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor to o scale deste type.
Se o scale deste type for 0, abort with "Zero é um tipo de escala inválido." e o locus deste type; exit.
Mova o percorredor (compilador rules).
Examine o base name deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, abort with "Os tipos precisam terminar com um ponto, não com '" then o token deste percorredor then "'." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

The scanning cronômetro é um cronômetro.

An scratch é um local.

Etapas necessárias para que se scrub um index:
Obtenha um bucket usando o index.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Scrub os refers deste bucket.
Repita.

Etapas necessárias para que se scrub alguns refers:
Swap o refers with alguns other refers.
Percorra.
Coloque o first destes other refers into um refer.
Se o refer for inexistente, cancele.
Remove o refer from o other refers.
Se o endereço de memória deste refer for inexistente, destroy o refer; repita.
Posponha o refer to os refers.
Repita.

Etapas necessárias para que se ative o compiled alarme in uma variable;
Etapas necessárias para que se ligue o compiled alarme in uma variable:
Se o variable for inexistente, cancele.
Se o compiled alarme desta variable [já] estiver ativo, cancele.
Ligue o compiled alarme desta variable.
Se a categoria desta variable não for "global", cancele.
Se o literal desta variable for inexistente, cancele.
Encontre uma routine usando "coloque" e o type deste literal desta variable e "into" e o type desta variable.
Se a routine for inexistente, encontre a routine usando "convert" e o type deste literal desta variable e "to" e o type desta variable; acione um alarme.
Se a routine for inexistente, abort with "O tipo dessa variável global e desse literal não são compatíveis." e o locus desta variable; exit.
Compile o body of a routine.
Se o alarme estiver ativo, coloque "convert o " then o name deste literal desta variable then " to o " then o name desta variable then ". " into o initializer string desta variable.
Se o alarme não estiver ativo, coloque "coloque o " then o name deste literal desta variable then " into o " then o name desta variable then ". " into o initializer string desta variable.

Etapas necessárias para que se skip to o next palavra in um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for noise, pare.
Adicione 1 to o first deste subtexto.
Repita.
Skip any leading noise in o subtexto.

Etapas necessárias para que se skip to o previous palavra in um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste last deste subtexto for noise, pare.
Subtraia 1 from o last deste subtexto.
Repita.
Skip any trailing noise in o subtexto.

An source file é uma coisa with um endereço completo e um trecho.

The source files são alguns source files.

An tag é um número.

An term é um conjunto with uma variable e um phrase.

Etapas necessárias para que se transmogrify um fragment:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Se a tag deste fragment for o push address tag, transmogrify o fragment (push address); exit.
Se a tag deste fragment for o call internal tag, transmogrify o fragment (call internal); exit.
Se a tag deste fragment for o load address tag, transmogrify o fragment (load address); exit.
Se a tag deste fragment for o increment tag, transmogrify o fragment (increment); exit.
Se a tag deste fragment for o dereference tag, transmogrify o fragment (dereference); exit.
Se a tag deste fragment for o jump false tag, transmogrify o fragment (jump false); exit.
Se a tag deste fragment for o not tag, transmogrify o fragment (not); exit.
Se a tag deste fragment for o exit tag, transmogrify o fragment (exit); exit.
Se a tag deste fragment for o repeat tag, transmogrify o fragment (repeat); exit.
Se a tag deste fragment for o break tag, transmogrify o fragment (break); exit.
Se a tag deste fragment for o prolog tag, transmogrify o fragment (prolog); exit.
Se a tag deste fragment for o epilog tag, transmogrify o fragment (epilog); exit.
Se a tag deste fragment for o push value tag, transmogrify o fragment (push value); exit.
Se a tag deste fragment for o call external tag, transmogrify o fragment (call external); exit.
Se a tag deste fragment for o load eax tag, transmogrify o fragment (load eax); exit.
Se a tag deste fragment for o save eax tag, transmogrify o fragment (save eax); exit.
Se a tag deste fragment for o call indirect tag, transmogrify o fragment (call indirect); exit.
Se a tag deste fragment for a routine address tag, transmogrify o fragment (routine address); exit.

Etapas necessárias para que se transmogrify um fragment (break):
Coloque o repeat tag into uma tag.
Encontre another fragment usando o fragment e o tag.
Se o other fragment for inexistente, coloque o finalize tag into o tag. \ por break sem um loop ou after um loop
Encontre um third fragment usando o last deste fragments desta rotina utilizada atualmente e o tag (backwards).
Se o third fragment for inexistente, abort with "Erro interno - transmogrify um fragment (break)"; exit.
Se o next deste third fragment for inexistente, abort with "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 e o address deste next deste third fragment to o fragment. \ JMP o address da destination

Etapas necessárias para que se transmogrify um fragment (call external):
Attach $FF15 e o address desta entry deste fragment to o code deste fragment. \ call [o address desta entry deste fragment ]

Etapas necessárias para que se transmogrify um fragment (call indirect):
Attach address loading code to o code deste fragment usando o variable deste fragment. \ coloca address into edx
Attach $FF12 to o code deste fragment. \ call [edx]

Etapas necessárias para que se transmogrify um fragment (call internal):
Obtenha um address usando o routine deste fragment.
Attach $E8 e o address to o fragment. \ call o address da routine do fragment 

Etapas necessárias para que se transmogrify um fragment (dereference):
Attach $8B95 e o offset desta variable deste fragment to o code deste fragment. \ mov edx,[ebp+ o offset desta variable deste fragment]
Attach $8B12 to o code deste fragment. \ mov edx,[edx]
Attach $8995 e o offset desta variable deste fragment to o code deste fragment. \ mov [ebp+ o offset desta variable deste fragment]

Etapas necessárias para que se transmogrify um fragment (epilog):
Se o callback alarme desta rotina utilizada atualmente estiver ativo, attach $5F5E5B to o code deste fragment. \ pop edi, esi, ebx
Attach $8BE5 to o code deste fragment. \ mov esp,ebp
Attach $5D to o code deste fragment. \ pop ebp
Attach $C2 e o parameter size desta rotina utilizada atualmente to o code deste fragment. \ ret o parameter size da rotina utilizada atualmente

Etapas necessárias para que se transmogrify um fragment (exit):
Encontre another fragment usando o fragment e o finalize tag.
Se o other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 e o address deste other fragment to o fragment. \ jmp o address da destination

Etapas necessárias para que se transmogrify um fragment (increment):
Se a variable deste fragment for inexistente, abort with "Erro interno - transmogrify um fragment (increment)"; exit.
Se a categoria desta variable deste fragment não for "scratch", abort with "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 e o offset desta variable deste fragment e o número deste fragment to o code deste fragment. \ add [ebp+ o offset desta variable deste fragment], o número deste fragment

Etapas necessárias para que se transmogrify um fragment (jump false):
Encontre another fragment usando o fragment e o end if tag.
Se o other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 to o code deste fragment. \ cmp eax,0
Attach $0F84 e o address deste other fragment to o fragment. \ je o address da destination

Etapas necessárias para que se transmogrify um fragment (load address):
Attach address loading code to o code deste fragment usando a variable deste fragment. \ coloque address into edx
Attach $8995 e o offset desta other variable deste fragment to o code deste fragment. \ mov [ebp+ o offset desta variable deste fragment],edx

\Etapas necessárias para que se transmogrify um fragment (load eax):
\Attach address loading code to o code deste fragment usando a variable deste fragment. \ coloque address into edx
\Se a variable deste fragment for inexistente, abort with "Internal erro - transmogrify um fragment (load eax)"; exit.
\Se o type desta variable deste fragment for inexistente, abort with "Internal erro 2 - transmogrify um fragment (load eax)"; exit.
\Se o length deste type desta variable deste fragment não for 4, abort with "Internal erro 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to o code deste fragment. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (load eax):
Attach $B8 e o alarme deste fragment to o code deste fragment. \ mov eax,alarme
\Attach address loading code to o code deste fragment usando a variable do fragment. \ coloque address into edx
\Se a variable deste fragment for inexistente, abort with "Internal erro - transmogrify um fragment (load eax)"; exit.
\Se o type desta variable deste fragment for inexistente, abort with "Internal erro 2 - transmogrify um fragment (load eax)"; exit.
\Se o length deste type desta variable deste fragment não for 4, abort with "Internal erro 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 to o code deste fragment. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (not):
Attach $83F001 to o code deste fragment. \ xor eax,1

Etapas necessárias para que se transmogrify um fragment (prolog):
Attach $55 to o code deste fragment. \ push ebp
Attach $8BEC to o code deste fragment. \ mov ebp,esp
Coloque o local size desta rotina utilizada atualmente dividido por 4 into um número.
Se o número não for 0, attach $B9 e o número e $6A004975FB to o code deste fragment. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
Se o callback alarme desta rotina utilizada atualmente estiver ativo, attach $535657 to o code deste fragment. \ push ebx, esi, edi

Etapas necessárias para que se transmogrify um fragment (push address):
Attach address loading code to o code deste fragment usando a variable deste fragment. \ coloque address into edx
Attach $52 to o code deste fragment. \ push edx

Etapas necessárias para que se transmogrify um fragment (push value):
Attach address loading code to o code deste fragment usando a variable deste fragment. \ coloque address into edx
Se a variable deste fragment for inexistente, abort with "Erro interno - transmogrify um fragment (push value)"; exit.
Se o type desta variable deste fragment for inexistente, abort with "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Coloque o length deste type desta variable deste fragment into um length.
Se o length for 4, attach $FF32 to o code deste fragment; exit. \ push [edx]
Se o length for 2, attach $66FF32 to o code deste fragment; exit. \ push palavra ptr [edx]
Se o length for 1, attach $0FB61252 to o code deste fragment; exit. \ movzxb edx,[edx]; push edx
Abort with "Erro interno 3 - transmogrify um fragment (push value)".

Etapas necessárias para que se transmogrify um fragment (repeat):
Encontre another fragment usando o fragment e o loop tag (backwards).
Se o other fragment for inexistente, abort with "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 e o address deste other fragment to o fragment. \ jmp o address da destination 

Etapas necessárias para que se transmogrify um fragment (routine address):
Attach address loading code to o code deste fragment usando a variable deste fragment. \ coloque address into edx
Se a routine deste fragment for inexistente, abort with "Erro interno - transmogrify um fragment (routine address)"; exit.
Obtenha um address usando a routine deste fragment.
Attach $C702 e o address to o code deste fragment. \ mov [edx],the address

Etapas necessárias para que se transmogrify um fragment (save eax):
Attach address loading code to o code deste fragment usando a variable deste fragment. \ coloque address into edx
Se a variable deste fragment for inexistente, abort with "Erro interno - transmogrify um fragment (save eax)"; exit.
Se o type desta variable deste fragment for inexistente, abort with "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Coloque o length deste type desta variable deste fragment into um length.
Se o length for 4, attach $8902 to o code deste fragment; exit. \ mov [edx],eax
Se o length for 2, attach $668902 to o code deste fragment; exit. \ mov [edx],ax
Se o length for 1, attach $8802 to o code deste fragment; exit. \ mov [edx],al
Abort with "Erro interno 3 - transmogrify um fragment (save eax)".

Etapas necessárias para que se transmogrify alguns fragments:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Transmogrify o fragment.
Repita.

Etapas necessárias para que se transmogrify uma routine:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o employs moniker desta routine não estiver em branco, cancele.
Se o compiled alarme desta routine não estiver ativo, cancele.
Coloque a routine into a rotina utilizada atualmente.
Transmogrify os fragments desta routine.

Etapas necessárias para que se transmogrify alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, pare.
Transmogrify a routine.
Repita.

The transmogrifying cronômetro é um cronômetro.

The catálogo de tipos é um index.

An type é uma coisa with
An locus (reference),
An name, um plural name,
An partial moniker,
An length,
An base name, um base type (reference),
An target name, um target type (reference) [endereço de memórias only],
An scale ratio,
Some fields [records only],
An cooking alarme,
An optional info resolved alarme.

An type name é um name.

The types são alguns types.

The catálogo de rotinas úteis é um index.

An variable é uma coisa with
An locus (reference),
An categoria [literal, global, local, parameter, scratch],
An compiled alarme,
An name, um nickname, um type name,
An type (reference), \ actual type on literal, global, local; dereferenced type on parameters e scratches
An address [globals e literals only] ou 
An offset at o address [locals, parameters, e fields only],
An contagem [fields only],
An reference alarme [fields only],
An redefinition target name [fields only],
An by-value alarme [parameters only],
An global body [globals only],
An initializer string [globals only],
An literal (reference) [globals only - constant with which to initalize o global],
An texto hexadecimal called data [literals only].

The writing cronômetro é um cronômetro.

Etapas necessárias para que se skip any trailing noise in um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste last deste subtexto não for noise, cancele.
Subtraia 1 from o last deste subtexto.
Repita.

\ dahn - reverse functions
\ to put o xxx uv a/the yyy into zzz
\ internally we turn this into "to put a/the yyy's xxx into zzz"
Etapas necessárias para que se compile o header of uma routine usando um percorredor (reverse-possessive function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o function alarme desta routine.
Adicione um monikette to os monikettes desta routine usando "coloque".
Mova o percorredor (compilador rules). \ skip "coloque" ou "poner"
Mova o percorredor (compilador rules). \ skip "the" ou Portuguese artigo definido
Examine um name usando o percorredor. \ field name
Mova o percorredor (compilador rules). \ skip "uv" ou "de"
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo definido).
Adicione another monikette to os monikettes desta routine usando "'s " then o name.
Se o token deste percorredor não for any reverse-possessive function into, abort with "Esperava a palavra 'em', mas encontrei '" then o token deste percorredor then "'." e o percorredor; exit.
Adicione um third monikette to os monikettes desta routine usando "into".
Convert os monikettes desta routine to um moniker.
Se o moniker estiver in o catálogo geral de rotinas, abort with "Já sei como '" then o moniker then "'." e o locus desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, abort with "Esperava um artigo indefinido, mas encontrei '" then o token deste percorredor then "'." e o percorredor; exit.
Compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo indefinido).
Se o token deste percorredor não estiver em branco, abort with "Existem outras coisas no final desta função." e o percorredor; exit.
Convert os monikettes desta routine to o moniker desta routine.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas. \ por employs

\ dahn - reverse functions
\ to coloque o xxx uv a/the yyy into zzz
Etapas necessárias para que se determine se um percorredor é o start of any reverse-possessive function:
Se o alarme de alerta deste compilador estiver ativo, diga não.
Se o token deste percorredor não for any coloque, diga não.
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo definido, diga não.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o percorredor não for on any reverse-possessive, diga não.
Diga sim.
\finalmente