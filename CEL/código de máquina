\Um programa em código de máquina consiste de uma sequência de bytes que correspondem a instruções a serem executadas pelo processador. 
\As instruções do processador, chamadas de opcodes, são representadas por valores em hexadecimal.[
\Para se programar em código de máquina, deve-se obter os códigos de instruções do processador utilizado contendo opcodes, operandos e formatos de cada instrução.
\Por esse motivo foi criada uma linguagem de programação chamada Assembly, composta de códigos mnemônicos que expressam as mesmas instruções do processador, 
\embora escritos em acrônimos da língua inglesa, tais como MOV ou REP, em vez de opcodes.

Um endereço de memória é um conjunto com 4 pedaços.
Um endereço numérico é um endereço de memória para um número.
Uma cifra binária é um pedaço. \ somente são válidos os 4 bits de ordem inferior. Exemplo: No byte 0101 1010 somente a parte "1010" é válida. 
 \ é um "low order nibble" ou uma sucessão de bytes de ordem inferior

Um cifra hexadecimal é uma string. \ Exemplo: $0010A0... O cifrão serve para indicar ao compilador que se trata de um valor hexadecimal. 
 \Em outras linguagens costuma-se usar um # (como no css #a1b2e3; ou um 0x, por exemplo 0xA1B2FF...

Uma word é um conjunto com 
  Um pedaço inicial [high byte] e 
  Um pedaço final [low byte].

Um número é um conjunto com
  Um first pedaço,
  Um second pedaço,
  Um terceiro pedaço,
  Um quarto pedaço, \ 4 bytes = 32 bits +
  Uma low word at o first pedaço, \ 
  Uma high word at o terceiro pedaço.

Uma máscara de disjunção exclusiva é uma mask.

Etapas necessárias para que se unassign um endereço de memória:
  Se o endereço de memória for inexistente, cancele.
  Call "kernel32.dll" "HeapFree" com 
    O endereço heap 
    e 0 [no options] e 
  o endereço de memória 
    devolvendo um número.
  Se o número for 0, cancele.
  Esvazie o endereço de memória.
  Subtraia 1 desde a contagem do heap.

An unit é um número.

Uma coisa é um endereço de memória para uma coisa conjunto.
\An conjunto de texto é uma coisa com uma string.
Uma coisa conjunto é um conjunto com 
  Uma next coisa e 
  Uma previous coisa.

Some coisas é um conjunto com 
  Uma first coisa e 
  Uma last coisa.

Etapas necessárias para que se permute um par de números com uma segunda par de números:
  Permute o número X deste par de números com o número X desta segunda par de números.
  Permute o número Y deste par de números com o número Y desta segunda par de números.

Etapas necessárias para que se permute um endereço de memória com um segundo endereço de memória;
Etapas necessárias para que se permute um número com um segundo número:
  Atribua o número a um terceiro número.
  Atribua o segundo número ao número.
  Atribua o terceiro número ao segundo número.

Etapas necessárias para que se permute umas coisas com umas segunda coisas:
  Permute o first destas coisas com o first destas segunda coisas.
  Permute o last destas coisas com o last destas segunda coisas.

Etapas necessárias para que se subtraia uma fração desde uma segunda fração:
  Isole a fração.
  Normalize a fração e a segunda fração.
  Subtraia o numerador desta fração desde o numerador desta segunda fração.
  Reduce a segunda fração.

Etapas necessárias para que se subtraia um número e um segundo número desde um par de números:
  Subtraia o número desde o x deste par de números.
  Subtraia o segundo número desde o y deste par de números.

Etapas necessárias para que se subtraia um número desde um fração:
  Subtraia o número / 1 desde a fração.

Etapas necessárias para que se subtraia um número desde um par de números:
  Subtraia o número desde o número X deste par de números.
  Subtraia o número desde o número Y deste par de números.

Etapas necessárias para que se subtraia um par de números desde uma segunda par de números:
  Subtraia o número X deste par de números desde o número X desta segunda par de números.
  Subtraia o número Y deste par de números desde o número Y desta segunda par de números.

Etapas necessárias para que se subtraia um pedaço desde um segundo pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8]  -> Salva o 1º byte (ebp+8) no registrador eax
  Intel $0FB600. \ movzx eax,[eax] -> ebp+8 é onde fica o valor do 1º argumento da função. ebp+12 é o 2º argumento
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> Salva o 2º byte (ebp+12) no registrador ebx
  Intel $2803. \ sub [ebx],al -> subtrai o 1º byte do 2º byte

Etapas necessárias para que se subtraia um pedaço desde um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> Salva o byte (ebp+8) no registrador eax
  Intel $0FB600. \ movzx eax,[eax] -> ebp+8 é onde fica o valor do 1º argumento da função. ebp+12 é o 2º argumento
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> Salva o número (ebp+12) no registrador ebx
  Intel $2903. \ sub [ebx],eax -> subtrai o byte do número

Etapas necessárias para que se subtraia um número desde um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> Salva o número (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp+8 é onde fica o valor do 1º argumento da função. ebp+12 é o 2º argumento
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> Salva o byte (ebp+12) no registrador ebx
  Intel $0FB60B. \ movzx ecx,[ebx] -> Salva o endereço de ebx em ecx. E "zero extende", ou seja
  \se houver disparidade entre o valor do byte e do número e for preciso expandir a quantidade de bits,  o espaço restante é preenchido com zeros
  Intel $2BC8. \ sub ecx,eax -> subtrai o número do byte
  Intel $880B. \ mov [ebx],cl -> salva o valor no endereço de memória salvo no registrador ebx

Etapas necessárias para que se subtraia um endereço de memória desde um segundo endereço de memória;
Etapas necessárias para que se subtraia um número desde um endereço de memória;
Etapas necessárias para que se subtraia um número desde um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> Salva o 1º número/endereço (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp+8 é onde fica o valor do 1º argumento da função. ebp+12 é o 2º argumento
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> Salva o 2º número/endereço (ebp+12) no registrador ebx
  Intel $2903. \ sub [ebx],eax -> subtrai o 1º valor do 2º

Etapas necessárias para que se desloque um pedaço left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o byte (ebp+8) no registrador eax
  Intel $D220. \ shl ptr [eax],ecx -> efetua o deslocamento dos bits para a esquerda (comando shl)

Etapas necessárias para que se desloque um pedaço right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o byte (ebp+8) no registrador eax
  Intel $D228. \ shr ptr [eax],ecx -> efetua o deslocamento dos bits para a direita (comando shr)

Etapas necessárias para que se desloque um número left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o número (ebp+8) no registrador eax
  Intel $D320. \ shl [eax],ecx -> efetua o deslocamento do número para a esquerda (comando shl)

Etapas necessárias para que se desloque um número right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o número (ebp+8) no registrador eax
  Intel $D328. \ shr [eax],ecx -> efetua o deslocamento do número para a direita (comando shr)

Etapas necessárias para que se desloque um word left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] \ salva a word (ebp+8) no registrador eax
  Intel $66D320. \ shl word ptr [eax],ecx \ shr word ptr [eax],ecx -> efetua o deslocamento dos bits para a esquerda (comando shl)

Etapas necessárias para que se desloque um word right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] \ salva a word (ebp+8) no registrador eax
  Intel $66D328. \ shr word ptr [eax],ecx -> efetua o deslocamento dos bits  para a direita (comando shr)

Etapas necessárias para que se arredonde um número para cima para o nearest power of two:
  Intel $8B8D08000000. \ mov ecx,[ebp+8] -> salva o número (ebp+8) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] 
  Intel $49. \ dec ecx -> diminui o valor de ecx
  Intel $0FBDC9. \ bsr ecx,ecx ->Bit scan reverse- Pesquisa no operando de origem (segundo operando) pelo conjunto de bits mais significativo (1 bit)
  \Se encontrar, o índice de bit é armazenado no operando de destino (primeiro operando).
  Intel $41. \ inc ecx -> aumenta o valor de ecx
  Intel $81F904000000. \ cmp ecx,4 -> compara o valor de ecx
  Intel $0F8F05000000. \ jg over the next 1 statement (Jump short if greater)
  Intel $B904000000. \ mov ecx,4
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $C70001000000. \ mov [eax],1
  Intel $D320. \ shl [eax],ecx 

Etapas necessárias para que se reset um endereço de memória;
Etapas necessárias para que se reset um endereço de memória pelo next time around;
Etapas necessárias para que se esvazie um endereço de memória:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o endereço de memória (ebp+8) no registrador eax
  Intel $C70000000000. \ mov [eax],0 -> zera o registrador eax

Etapas necessárias para que se atribua uma word para uma segunda word:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva a 1ª word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,[eax] -> salva o endereço da 1ª word no registrador ax
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva a 2ª word (ebp+12) no registrador ebx
  Intel $668903. \ mov [ebx],ax -> Atribui o endereço da 1ª word para a 2ª word

Etapas necessárias para que se atribua um word para um big-endian unsigned word:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva a word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,word ptr [eax]  -> ebp+8 é o 1º parâmetro da função. 
  Intel $86E0. \ xchg al,ah -> ebp+12 é o 2º parâmetro da função
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva a o big-endian unsigned word  (ebp+12) no registrador ebx
  Intel $668903. \ mov word ptr [ebx],ax

Etapas necessárias para que se atribua um word para um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva a word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,[eax] -> ebp+8 é o 1º parâmetro da função. ebp+12 é o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva o byte (ebp+12) no registrador ebx
  Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um word para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva a word (ebp+8) no registrador ebx
  Intel $0FBF03. \ movsx eax,word ptr [ebx]

Etapas necessárias para que se atribua um word para um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva a word (ebp+8) no registrador eax
  Intel $0FBF00. \ movsx eax,word ptr [eax] -> ebp+8 é o 1º parâmetro da função. ebp+12 é o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva o número (ebp+12) no registrador ebx
  Intel $8903. \ mov [ebx],eax -> atribui a word ao número

Etapas necessárias para que se atribua a quantidade de caracteres dessa string para uma quantidade de caracteres:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva a string (ebp+8) no registrador eax
  \ Carrega default result
  Intel $B900000000. \ mov ecx,0 -> zera o registrador ecx
  \ if first for 0, store 0
  Intel $833B00. \ cmp [ebx],0 -> compara a string com 0. 
  Intel $0F8414000000. \ je store it
  \ if last for menor do que first, store 0
  Intel $8B5304. \ mov edx,[ebx+4] -> atribui o last endereço de memória ao registrador edx
  Intel $3B13. \ cmp edx,[ebx] -> compara edc com ebx
  Intel $0F8C09000000. \ jl store it
  \ calcula a  quantidade de caracteres
  Intel $8B8B04000000. \ mov ecx,[ebx+4] ->atribui o last endereço de memória ao registrador ecx
  Intel $2B0B. \ sub ecx,[ebx] \ subtrai o registrador ebx do ecx
  Intel $41. \ inc ecx \ adiciona 1 ao registrador ecx
  \ STORE IT:
  Intel $8B950C000000. \ mov edx,[ebp+12] \ atribui a quantidade de caracteres (ebp+12) ao registrador edx
  Intel $890A. \ mov [edx],ecx -> atribui o valor de ecx ao registrador edx

Etapas necessárias para que se atribua um número para uma word:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> atribui o número (ebp+8) ao registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp+8 representa o primeiro argumento da função (o número).
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> atribui a word (ebp+12) ao registrador ebx
  Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua um número para um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> atribui o número (ebp+8) ao registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp+8 representa o primeiro argumento da função (o número).
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> atribui o byte (ebp+12) ao registrador ebx
  Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um detector para um segundo detector;
Etapas necessárias para que se atribua um detector para um número;
Etapas necessárias para que se atribua um endereço de memória para um número;
Etapas necessárias para que se atribua um endereço de memória para um segundo endereço de memória;
Etapas necessárias para que se atribua um número para um detector;
Etapas necessárias para que se atribua um número para um endereço de memória;
Etapas necessárias para que se atribua um número para um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o 1º valor (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp=8 representa o 1º parâmetro da função. ebp+12 representa o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva o 2º valor (ebp+12) no registrador ebx
  Intel $8903. \ mov [ebx],eax -> salva eax em ebx

Etapas necessárias para que se atribua um detector para eax;
Etapas necessárias para que se atribua um endereço de memória para eax;
Etapas necessárias para que se atribua um número para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva o número (ebp+8) no registrador ebx
  Intel $8B03. \ mov eax,[ebx] -> salva ebx em eax

Etapas necessárias para que se atribua eax para um pedaço:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva o byte (ebp+8) no registrador ebx
  Intel $8803. \ mov [ebx],al -> atribui o al para o endereço de ebx

Etapas necessárias para que se atribua eax para um detector;
Etapas necessárias para que se atribua eax para um endereço de memória;
Etapas necessárias para que se atribua eax para um número:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva o número (ebp+8) no registrador ebx
  Intel $8903. \ mov [ebx],eax -> atribui eax ao endereço de ebx

Etapas necessárias para que se atribua eax para um word:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva a word (ebp+8) no registrador ebx
  Intel $668903. \ mov [ebx],ax -> atribui o ax para o endereço do ebx

Etapas necessárias para que se atribua um pedaço para um word:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $660FB600. \ movzx eax,byte ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o word
  Intel $668903. \ mov [ebx],ah

Etapas necessárias para que se atribua um pedaço para um segundo pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda byte
  Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um pedaço para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0FB603. \ movzx eax,byte ptr [ebx]

Etapas necessárias para que se atribua um pedaço para um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $0FB600. \ movzx eax,byte ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se translate um pedaço using um translation texto hexadecimal:
  Intel $8B8D08000000. \ mov ecx,[ebp+8] \ o endereço de memória do pedaço 
  Intel $8B01. \ mov eax,[ecx] \ o byte
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o tabela de tradução
  Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
  Intel $D7. \ xlat al,[ebx]
  Intel $8901. \ mov [ecx],eax

Etapas necessárias para que se posicione um subtexto sobre uma string:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a string
  \ atribua o first endereço de memória do pedaço desta string ao first endereço de memória do pedaço deste subtexto
  Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o first  endereço de memória do pedaço da string
  Intel $898800000000. \ mov [eax+0],ecx \ o first  endereço de memória do pedaço do subtexto
  \ atribua o first endereço de memória do pedaço desta string menos 1 ao last endereço de memória do pedaço deste subtexto
  Intel $49. \ dec ecx
  Intel $898804000000. \ mov [eax+4],ecx \ o last endereço de memória do pedaço deste subtexto

Etapas necessárias para que se escolha aleatoriamente uns twips between uns min twips e uns segunda twips; \ são all these necessary? ***
Etapas necessárias para que se escolha aleatoriamente um número between uns min twips e uns segunda twips;
Etapas necessárias para que se escolha aleatoriamente um número between um min número e um max número;
Etapas necessárias para que se escolha aleatoriamente um número desde um min número para um max número;
Etapas necessárias para que se defina um número para something between um segundo número e um terceiro número;
Etapas necessárias para que se escolha aleatoriamente um random número between um min número e um max número:
  Atribua o endereçamento deste seed para EAX.
    \ atribua address of randseed A ecx
  Intel $8BC8. \ mov ecx,eax
    \ calculate zero based max
  Intel $8B8510000000. \ mov eax,[ebp+16] \ o max
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o min
  Intel $2B03. \ sub eax,[ebx]
  Intel $40. \ inc eax
    \ ajuste randseed
  Intel $691105840808. \ imul edx,[ecx],134775813
  Intel $42. \ inc edx
  Intel $8911. \ mov [ecx],edx
    \ mul adjusted randseed pelo zero based max
  Intel $F7E2. \ mul edx
    \ adicione o min para an-zero base o número
  Intel $0313. \ adicione edx,[ebx] o min
    \ store o result
  Intel $8B9D08000000. \ mov ebx,[ebp+08] \ o random número
  Intel $8913. \ mov [ebx],edx
  Atribua o random número ao número deste context.

Etapas necessárias para que se multiplique um endereço de memória por um número;
Etapas necessárias para que se multiplique um número por um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo número
  Intel $F72B.\ mul [ebx] \ means mul eax,[ebx] but é weird form
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se negate um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $F718.\ neg [eax]

Etapas necessárias para que se negate um par de números:
  Negate o número X deste par de números.
  Negate o número Y deste par de números.

Etapas necessárias para que se negate uma fração:
  Negate o numerador desta fração.

Etapas necessárias para que se atribua um detector para uma string;
Etapas necessárias para que se converta um detector para uma string:
  Se o detector estiver ativo, atribua "yes" à string; exit. \ no momento tem que ser inglês por conta das externalized reams
  Atribua "no" à string.

Etapas necessárias para que se reassign um endereço de memória usando um quantidade de pedaços:
  Se o endereço de memória for inexistente, assign o endereço de memória usando o quantidade de pedaços; exit.
  Se o quantidade de pedaços for 0, unassign o endereço de memória; exit.
  Isole o quantidade de pedaços.
  Arredonde o quantidade de pedaços para cima para o nearest power of two.
  Call "kernel32.dll" "HeapReAlloc" com 
    O endereço heap 
    e 8 [HEAP_ZERO_MEMORY] 
    e O endereço de memória 
    e A quantidade de pedaços 
    devolvendo o endereço de memória.

Etapas necessárias para que se mostre olá mundo no console:
  Intel $B403 \mov    ah,0x3
  Intel $CD10 \int    0x10
  Intel $B001 \mov    al,0x1
  Intel $B30A \mov    bl,0xa
  Intel $B90B00BD13  \mov    ecx,0x13bd000b
  Intel $01B413CD10C34F \add    DWORD PTR [ebx+edx*1+0x4fc310cd],esi
  Intel $69206D756E64  \ imul   esp,DWORD PTR [eax],0x646e756d
  Intel $6D \  outs   dx,DWORD PTR ds:[esi]
  Intel $21 \   .byte 0x21
  Intel $0D  \   .byte 0xd
  Intel $0A  \   .byte 0xa






  
  