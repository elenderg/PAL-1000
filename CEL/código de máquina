\Um programa em código de máquina consiste de uma sequência de bytes que correspondem a instruções a serem executadas pelo processador. 
\As instruções do processador, chamadas de opcodes, são representadas por valores em hexadecimal.[
\Para se programar em código de máquina, deve-se obter os códigos de instruções do processador utilizado contendo opcodes, operandos e formatos de cada instrução.
\Por esse motivo foi criada uma linguagem de programação chamada Assembly, composta de códigos mnemônicos que expressam as mesmas instruções do processador, 
\embora escritos em acrônimos da língua inglesa, tais como MOV ou REP, em vez de opcodes.
\all parameters are passed by reference
\All parameters passed to Plain English routines are passed by reference, though parameters passed to DLLs use the C convention (the order is reversed and "simple" types are passed by value
\"The whole system is built on just two, compiler-defined types: BYTE and RECORD. 
\All the other types are constructed from these, and are defined in the "Noodle" library {a file, loaded by the compiler}. 
\The idea was to put as much as we could in the library, and as little as possible in the compiler. 
\The compiler is aware of a few other types -- like NUMBER, STRING, SUBSTRING, THING -- mostly for memory management purposes, but all the other the type definitions are built up from BYTE and RECORD in the library." These are extended to support BYTE, WYRD, POINTER, FLAG, and RECORD.


Um endereço de memória é um conjunto com 4 pedaços.
Um endereço numérico é um endereço de memória para um número.
Uma cifra binária é um pedaço. \ somente são válidos os 4 bits de ordem inferior. Exemplo: No byte 0101 1010 somente a parte "1010" é válida. 
 \ é um "low order nibble" ou uma sucessão de bytes de ordem inferior
O texto CRLF é uma string igual a $0D0A.
Um cifra hexadecimal é uma string. \ Exemplo: $0010A0... O cifrão serve para indicar ao compilador que se trata de um valor hexadecimal. 
 \Em outras linguagens costuma-se usar um # (como no css #a1b2e3; ou um 0x, por exemplo 0xA1B2FF...

Uma word é um conjunto com 
  Um pedaço inicial [high byte] e 
  Um pedaço final [low byte].

Um número é um conjunto com
  Um primeiro pedaço,
  Um segundo pedaço,
  Um terceiro pedaço,
  Um quarto pedaço, \ 4 bytes = 32 bits +
  Uma low word sob o primeiro pedaço, \ 
  Uma high word sob o terceiro pedaço.

Uma máscara de disjunção exclusiva é uma mask.

Etapas para que se unassign um endereço de memória:
  Se o endereço de memória for inexistente, cancele.
  Call "kernel32.dll" "HeapFree" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/heapapi/nf-heapapi-heapfree
  \Libera um bloco de memória alocado de um heap pela função HeapAlloc ou HeapReAlloc.
    O endereço heap [hHeap] \Um identificador para o heap cujo bloco de memória deve ser liberado. Esse identificador é retornado pela função HeapCreate ou GetProcessHeap.
    e 0 [dwFlags no options] e  \As opções de liberação de heap.
  o endereço de memória [lpMem] \Um ponteiro para o bloco de memória a ser liberado. Este ponteiro é retornado pela função HeapAlloc ou HeapReAlloc. Este ponteiro pode ser NULL.
    devolvendo um número. \ Se a função for bem-sucedida, o valor de retorno será diferente de zero. 
  Se o número for 0, cancele. \Se a função falhar, o valor de retorno é zero.
  Esvazie o endereço de memória.
  Subtraia 1 desde a contagem do heap.

Uma unit é um número.

Uma coisa é um endereço de memória para uma coisa conjunto.
\Um conjunto de texto é uma coisa com uma string.
Uma coisa conjunto é um conjunto com 
  Uma next coisa e 
  Uma previous coisa.

Some coisas é um conjunto com 
  Uma first coisa e 
  Uma last coisa.

Etapas para que se permute um par de números com um segundo par de números:
  Permute o número X deste par de números com o número X deste segundo par de números.
  Permute o número Y deste par de números com o número Y deste segundo par de números.

Etapas para que se permute um endereço de memória com um segundo endereço de memória;
Etapas para que se permute um número com um segundo número:
  Atribua o número a um terceiro número.
  Atribua o segundo número ao número.
  Atribua o terceiro número ao segundo número.

Etapas para que se permute umas coisas com umas segunda coisas:
  Permute a first coisa destas coisas com o first coisa destas segunda coisas.
  Permute a last coisa destas coisas com o last coisa destas segunda coisas.

Etapas para que se subtraia uma fração desde uma segunda fração:
  Isole a fração.
  Normalize a fração e a segunda fração.
  Subtraia o numerador desta fração desde o numerador desta segunda fração.
  Reduza a segunda fração.

Etapas para que se subtraia um número e um segundo número desde um par de números:
  Subtraia o número desde o x deste par de números.
  Subtraia o segundo número desde o y deste par de números.

Etapas para que se subtraia um número desde um fração:
  Subtraia o número / 1 desde a fração.

Etapas para que se subtraia um número desde um par de números:
  Subtraia o número desde o número X deste par de números.
  Subtraia o número desde o número Y deste par de números.

Etapas para que se subtraia um par de números desde um segundo par de números:
  Subtraia o número X deste par de números desde o número X deste segundo par de números.
  Subtraia o número Y deste par de números desde o número Y deste segundo par de números.

\ CONCEITOS GERAIS DE ASSEMBLY:
\ ANTES DE SE TRABALHAR COM UM VALOR, DEVE-SE MOVÊ-LO PARA UM REGISTRADOR.
\ OS REGISTRADORES MAIS USADOS SÃO eax, ebx, ecx e assim por diante
\ EXISTEM REGISTRADORES DE USO GERAL E DE USO ESPECÍFICO
\ NO GERAL ebp+8 SE REFERE AO 1º ARGUMENTO DE UMA FUNÇÃO
\ ebp+12 SE REFERE AO 2º ARGUMENTO E ASSIM POR DIANTE
\O registrador ESP é um indicador do topo da pilha - portanto, muda constantemente à medida que a pilha aumenta ou diminui. 
\EBP é um registrador auxiliar.
\ Primeiro, colocamos o conteúdo de ebp na pilha. em seguida, copiamos ESP (endereço do topo da pilha atual) para ebp 
\é por isso que quando nos referimos a outros itens na pilha, usamos o valor constante de ebp (e não alteramos um de esp).
\Os parâmetros são acessados usando o  do ponteiro salvo de base de pilha EBP
\[ebp + 16] - 3º parâmetro 'c'
\[ebp + 12] - 2º parâmetro 'b'
\[ebp + 8] - 1 º parâmetro 'a'
\[ebp + 4] - endereço de retorno da função
\[ebp + 0] - registrador do ponteiro salvo de base de pilha 
\esp é o topo da pilha.
\ebp geralmente é definido como esp no início de uma função. 
\Parâmetros de função e variáveis locais são acessados ao adicionar e subtrair um valor de deslocamento constante do registrador ebp. 
\Todas as convenções de chamada x86 definem ebp como sendo preservado nas chamadas de função. 
\O próprio ebp aponta, na verdade, para o ponteiro de base do quadro anterior, o que permite o funcionamento da pilha em um depurador e a visualização de outras variáveis locais de quadros.
\ESP é o ponteiro da pilha atual, que mudará sempre que uma palavra ou endereço for inserido ou colocado na / fora da pilha. 
\EBP é uma maneira mais conveniente para o compilador controlar os parâmetros de uma função e as variáveis locais do que usar o ESPdiretamente.
\Geralmente (e isso pode variar de compilador para compilador), todos os argumentos para uma função sendo chamada são colocados na pilha pela função de chamada 
\(geralmente na ordem inversa em que são declarados no protótipo da função, mas isso varia) . 
\Em seguida, a função é chamada, o que coloca o endereço de retorno ( EIP) na pilha.
\Ao entrar na função, o EBPvalor antigo é colocado na pilha e EBPé definido como o valor de ESP. 
\Em seguida, o ESPé diminuído (porque a pilha cresce para baixo na memória) para alocar espaço para as variáveis locais e temporárias da função. 
\A partir desse ponto, durante a execução da função, os argumentos para a função estão localizados na pilha em deslocamentos positivos de EBP
\(porque foram empurrados antes da chamada da função), e as variáveis locais estão localizadas em deslocamentos negativos de EBP
\(porque eles foram alocados na pilha após a entrada da função). 
\É por isso que EBPé chamado de Ponteiro de Quadro , porque aponta para o centro do quadro de chamada de função .
\Ao sair, tudo que a função precisa fazer é definir ESPo valor de EBP(que desaloca as variáveis locais da pilha e expõe a entrada EBPno topo da pilha), 
\em seguida, retirar o EBPvalor antigo da pilha e, em seguida, a função retornos (estalar o endereço de retorno em EIP).
\Ao retornar à função de chamada, ele pode incrementar ESPpara remover os argumentos da função que colocou na pilha antes de chamar a outra função. 
\Neste ponto, a pilha está de volta ao mesmo estado em que estava antes de invocar a função chamada.

Etapas para que se subtraia um pedaço desde um segundo pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> Salva o 1º byte (ebp+8) no registrador eax
  Intel $0FB600. \ movzx eax,[eax] ; -> ebp+8  o local onde o processador armazena o valor do 1º argumento da função.
  \ ebp+12 é é o local onde o processador armazena o valor do o 2º argumento da função
  \ A instrução MOVZX (Move with Zero-Extend) copia o conteúdo do operando de origem (registrador ou localização na memória) para o operando de destino (registrador) e zero estende o valor. 
  \O tamanho do valor convertido depende do atributo de tamanho do operando.
  \Ao contrário do que se pode pensar, a instrução movzx (que preenche todos os registradores) na verdade é executada de forma mais rápida do que a instrução mov, 
  \ já que a instrução mov  define apenas as partes inferiores dos registradores.
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> Salva o 2º byte (ebp+12) no registrador ebx
  Intel $2803. \ sub [ebx],al ; -> subtrai o 1º byte do 2º byte

Etapas para que se subtraia um pedaço desde um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> Salva o byte (ebp+8) no registrador eax
  Intel $0FB600. \ movzx eax,[eax] ; -> ebp+8 é o local onde o processador armazena o valor do 1º argumento da função. 
  \ ebp+12 é é o local onde o processador armazena o valor do o 2º argumento da função
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> Salva o número (ebp+12) no registrador ebx
  Intel $2903. \ sub [ebx],eax ; -> subtrai o byte do número

Etapas para que se subtraia um número desde um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> Salva o número (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] ; -> ebp+8 é o local onde o processador armazena o valor do 1º argumento da função.
  \ ebp+12 é é o local onde o processador armazena o valor do o 2º argumento da função
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> Salva o byte (ebp+12) no registrador ebx
  Intel $0FB60B. \ movzx ecx,[ebx] ; -> Salva o endereço de ebx em ecx. E "zero extende", ou seja
  \se houver disparidade entre o valor do byte e do número e for preciso expandir a quantidade de bits,  o espaço restante é preenchido com zeros
  Intel $2BC8. \ sub ecx,eax ; -> subtrai o número do byte
  Intel $880B. \ mov [ebx],cl ; -> salva o valor no endereço de memória salvo no registrador ebx

Etapas para que se subtraia um endereço de memória desde um segundo endereço de memória;
Etapas para que se subtraia um número desde um endereço de memória;
Etapas para que se subtraia um número desde um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> Salva o 1º número/endereço (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] ; -> ebp+8 é o local onde o processador armazena o valor do 1º argumento da função.
  \ ebp+12 é é o local onde o processador armazena o valor do o 2º argumento da função
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> Salva o 2º número/endereço (ebp+12) no registrador ebx
  Intel $2903. \ sub [ebx],eax ; -> subtrai o 1º valor do 2º

Etapas para que se desloque um pedaço left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] ; -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] ; -> ebp+12 é é o local onde o processador armazena o valor do o 2º argumento da função
  \ebp+8 é o local onde o processador armazena o valor do 1º argumento da função.
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o byte (ebp+8) no registrador eax
  Intel $D220. \ shl ptr [eax],ecx ; -> efetua o deslocamento dos bits para a esquerda (comando shl)

Etapas para que se desloque um pedaço right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] ; -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  \ ebp+12 é é o local onde o processador armazena o valor do o 2º argumento da função. 
  Intel $8B09. \ mov ecx,[ecx] ; -> Nessa rotina o "pedaço left" é considerado como um argumento, por isso precisamos do valor do 2º argumento
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o byte (ebp+8) no registrador eax
   \ebp+8 é o local onde o processador armazena o valor do 1º argumento da função.
  Intel $D228. \ shr ptr [eax],ecx ; -> efetua o deslocamento dos bits para a direita (comando shr)

Etapas para que se desloque um número left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] ; -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] ; -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o número (ebp+8) no registrador eax
  Intel $D320. \ shl [eax],ecx ; -> efetua o deslocamento do número para a esquerda (comando shl)

Etapas para que se desloque um número right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] ; -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] ; -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o número (ebp+8) no registrador eax
  Intel $D328. \ shr [eax],ecx ; -> efetua o deslocamento do número para a direita (comando shr)

Etapas para que se desloque um word left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] ; -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] ; -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] \ salva a word (ebp+8) no registrador eax
  Intel $66D320. \ shl word ptr [eax],ecx \ shr word ptr [eax],ecx ; -> efetua o deslocamento dos bits para a esquerda (comando shl)

Etapas para que se desloque um word right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] ; -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] ; -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] \ salva a word (ebp+8) no registrador eax
  Intel $66D328. \ shr word ptr [eax],ecx ; -> efetua o deslocamento dos bits  para a direita (comando shr)

Etapas para que se arredonde um número para cima para o nearest power of two:
  Intel $8B8D08000000. \ mov ecx,[ebp+8] ; -> salva o número (ebp+8) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] 
  Intel $49. \ dec ecx ; -> diminui o valor de ecx
  Intel $0FBDC9. \ bsr ecx,ecx ; ->Bit scan reverse- Pesquisa no operando de origem (segundo operando) pelo conjunto de bits mais significativo (1 bit)
  \Se encontrar, o índice de bit é armazenado no operando de destino (primeiro operando).
  Intel $41. \ inc ecx ; -> aumenta o valor de ecx
  Intel $81F904000000. \ cmp ecx,4 ; -> compara o valor de ecx
  Intel $0F8F05000000. \ jg over the next 1 statement (Jump short if greater)
  Intel $B904000000. \ mov ecx,4
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $C70001000000. \ mov [eax],1
  Intel $D320. \ shl [eax],ecx 

Etapas para que se redefina um endereço de memória;
Etapas para que se redefina um endereço de memória pelo next time around;
Etapas para que se esvazie um endereço de memória:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o endereço de memória (ebp+8) no registrador eax
  Intel $C70000000000. \ mov [eax],0 ; -> zera o registrador eax

Etapas para que se atribua uma word para uma segunda word:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva a 1ª word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,[eax] ; -> salva o endereço da 1ª word no registrador ax
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> salva a 2ª word (ebp+12) no registrador ebx
  Intel $668903. \ mov [ebx],ax ; -> Atribui o endereço da 1ª word para a 2ª word

Etapas para que se atribua um word para um word big-endian unsigned:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva a word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,word ptr [eax]  ; -> ebp+8 é o 1º parâmetro da função. 
  Intel $86E0. \ xchg al,ah ; -> ebp+12 é o 2º parâmetro da função
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> salva a a word big-endian unsigned  (ebp+12) no registrador ebx
  Intel $668903. \ mov word ptr [ebx],ax

Etapas para que se atribua um word para um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva a word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,[eax] ; -> ebp+8 é o 1º parâmetro da função. ebp+12 é o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> salva o byte (ebp+12) no registrador ebx
  Intel $8803. \ mov [ebx],al

Etapas para que se atribua um word para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] ; -> salva a word (ebp+8) no registrador ebx
  Intel $0FBF03. \ movsx eax,word ptr [ebx]

Etapas para que se atribua um word para um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva a word (ebp+8) no registrador eax
  Intel $0FBF00. \ movsx eax,word ptr [eax] ; -> ebp+8 é o 1º parâmetro da função. ebp+12 é o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> salva o número (ebp+12) no registrador ebx
  Intel $8903. \ mov [ebx],eax ; -> atribui a word ao número

Etapas para que se atribua a quantidade de caracteres dessa string para uma quantidade de caracteres:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] ; -> salva a string (ebp+8) no registrador eax
  \ Carrega default result
  Intel $B900000000. \ mov ecx,0 ; -> zera o registrador ecx
  \ if first for 0, store 0
  Intel $833B00. \ cmp [ebx],0 ; -> compara a string com 0. 
  Intel $0F8414000000. \ je store it
  \ if last for menor do que first, store 0
  Intel $8B5304. \ mov edx,[ebx+4] ; -> atribui o last endereço de memória ao registrador edx
  Intel $3B13. \ cmp edx,[ebx] ; -> compara edc com ebx
  Intel $0F8C09000000. \ jl store it
  \ calcula a  quantidade de caracteres
  Intel $8B8B04000000. \ mov ecx,[ebx+4] ; ->atribui o last endereço de memória ao registrador ecx
  Intel $2B0B. \ sub ecx,[ebx] \ subtrai o registrador ebx do ecx
  Intel $41. \ inc ecx \ adiciona 1 ao registrador ecx
  \ STORE IT:
  Intel $8B950C000000. \ mov edx,[ebp+12] \ atribui a quantidade de caracteres (ebp+12) ao registrador edx
  Intel $890A. \ mov [edx],ecx ; -> atribui o valor de ecx ao registrador edx

Etapas para que se atribua um número para uma word:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> atribui o número (ebp+8) ao registrador eax
  Intel $8B00. \ mov eax,[eax] ; -> ebp+8 representa o primeiro argumento da função (o número).
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> atribui a word (ebp+12) ao registrador ebx
  Intel $668903. \ mov [ebx],ax

Etapas para que se atribua um número para um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> atribui o número (ebp+8) ao registrador eax
  Intel $8B00. \ mov eax,[eax] ; -> ebp+8 representa o primeiro argumento da função (o número).
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> atribui o byte (ebp+12) ao registrador ebx
  Intel $8803. \ mov [ebx],al

Etapas para que se atribua um detector para um segundo detector;
Etapas para que se atribua um detector para um número;
Etapas para que se atribua um endereço de memória para um número;
Etapas para que se atribua um endereço de memória para um segundo endereço de memória;
Etapas para que se atribua um número para um detector;
Etapas para que se atribua um número para um endereço de memória;
Etapas para que se atribua um número para um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o 1º valor (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] ; -> ebp=8 representa o 1º parâmetro da função. ebp+12 representa o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> salva o 2º valor (ebp+12) no registrador ebx
  Intel $8903. \ mov [ebx],eax ; -> salva eax em ebx

Etapas para que se atribua um detector para eax;
Etapas para que se atribua um endereço de memória para eax;
Etapas para que se atribua um número para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] ; -> salva o número (ebp+8) no registrador ebx
  Intel $8B03. \ mov eax,[ebx] ; -> salva ebx em eax

Etapas para que se atribua eax para um pedaço:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] ; -> salva o byte (ebp+8) no registrador ebx
  Intel $8803. \ mov [ebx],al ; -> atribui o al para o endereço de ebx

Etapas para que se atribua eax para um detector;
Etapas para que se atribua eax para um endereço de memória;
Etapas para que se atribua eax para um número:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] ; -> salva o número (ebp+8) no registrador ebx
  Intel $8903. \ mov [ebx],eax ; -> atribui eax ao endereço de ebx

Etapas para que se atribua eax para um word:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] ; -> salva a word (ebp+8) no registrador ebx
  Intel $668903. \ mov [ebx],ax ; -> atribui o ax para o endereço do ebx

Etapas para que se atribua um pedaço para uma word:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o byte (ebp+8) no registrador eax
  Intel $660FB600. \ movzx eax,byte ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; ->  salva a word (ebp+12) no registrador ebx
  Intel $668903. \ mov [ebx],ah

Etapas para que se atribua um pedaço para um segundo pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o 1º byte (ebp+8) no registrador eax
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> salva o 2º byte (ebp+12) no registrador ebx
  Intel $8803. \ mov [ebx],al

Etapas para que se atribua um pedaço para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] ; -> salva o byte (ebp+8) no registrador eax
  Intel $0FB603. \ movzx eax,byte ptr [ebx]

Etapas para que se atribua um pedaço para um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o byte (ebp+8) no registrador eax
  Intel $0FB600. \ movzx eax,byte ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; ->  salva o número (ebp+12) no registrador ebx
  Intel $8903. \ mov [ebx],eax

Etapas para que se translate um pedaço using um translation texto hexadecimal:
  Intel $8B8D08000000. \ mov ecx,[ebp+8]  ; -> salva o endereço do byte (ebp+8) no registrador ecx 
  Intel $8B01. \ mov eax,[ecx] \ o byte
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] salva o endereço da tabela (ebp+12) no registrador ebx 
  Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
  Intel $D7. \ xlat al,[ebx]
  Intel $8901. \ mov [ecx],eax

Etapas para que se posicione um subtexto sobre uma string:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a string
  \ atribua o caractere inicial desta string ao caractere inicial deste subtexto
  Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o caractere inicial da string
  Intel $898800000000. \ mov [eax+0],ecx \ o caractere inicial do subtexto
  \ atribua o caractere inicial desta string menos 1 ao caractere final deste subtexto
  Intel $49. \ dec ecx
  Intel $898804000000. \ mov [eax+4],ecx \ o caractere final deste subtexto

Etapas para que se escolha aleatoriamente uns twips entre uns min twips e uns segundo twips; \ precisa de tudo isso? ***
Etapas para que se escolha aleatoriamente um número entre uns min twips e uns segundo twips;
Etapas para que se escolha aleatoriamente um número entre um min número e um max número;
Etapas para que se escolha aleatoriamente um número desde um min número para um max número;
Etapas para que se defina um número para something entre um segundo número e um terceiro número;
Etapas para que se escolha aleatoriamente um número aleatório entre um min número e um max número:
  Atribua o endereçamento deste seed para EAX.
  \ atribua address of randseed A ecx
  Intel $8BC8. \ mov ecx,eax
  \ calculate zero based max
  Intel $8B8510000000. \ mov eax,[ebp+16] \ o max
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o min
  Intel $2B03. \ sub eax,[ebx]
  Intel $40. \ inc eax
  \ ajuste randseed
  Intel $691105840808. \ imul edx,[ecx],134775813
  Intel $42. \ inc edx
  Intel $8911. \ mov [ecx],edx
  \ mul adjusted randseed pelo zero based max
  Intel $F7E2. \ mul edx
  \ adicione o min para an-zero base o número
  Intel $0313. \ adicione edx,[ebx] o min
  \ store o result
  Intel $8B9D08000000. \ mov ebx,[ebp+08] \ o número aleatório
  Intel $8913. \ mov [ebx],edx
  Atribua o número aleatório ao número deste contexto.

Etapas para que se multiplique um endereço de memória por um número;
Etapas para que se multiplique um número por um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo número
  Intel $F72B.\ mul [ebx] \ means mul eax,[ebx] but é weird form
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas para que se negate um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $F718.\ neg [eax]

Etapas para que se negate um par de números:
  Negate o número X deste par de números.
  Negate o número Y deste par de números.

Etapas para que se negate uma fração:
  Negate o numerador desta fração.

Etapas para que se atribua um detector para uma string;
Etapas para que se converta um detector para uma string:
  Se o detector estiver ativo, atribua "yes" à string; saia. \ no momento tem que ser inglês por conta das externalized reams
  Atribua "no" à string.

Etapas para que se reassign um endereço de memória usando um quantidade de pedaços:
  Se o endereço de memória for inexistente, assign o endereço de memória usando o quantidade de pedaços; saia.
  Se o quantidade de pedaços for 0, unassign o endereço de memória; saia.
  Isole o quantidade de pedaços.
  Arredonde o quantidade de pedaços para cima para o nearest power of two.
  Call "kernel32.dll" "HeapReAlloc" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/heapapi/nf-heapapi-heaprealloc
  \Realoca um bloco de memória de um heap. Esta função permite redimensionar um bloco de memória e alterar outras propriedades do bloco de memória. A memória alocada não é móvel.
    O endereço heap [hHeap] \Um identificador para o heap do qual a memória deve ser realocada. Esse identificador é retornado pela função HeapCreate ou GetProcessHeap.
    e 8 [HEAP_ZERO_MEMORY]  [dwFlags] \As opções de realocação de heap. Se a solicitação de realocação for para um tamanho maior, 
    \a região adicional da memória além do tamanho original será inicializada para zero. O conteúdo do bloco de memória até seu tamanho original não é afetado.
    e O endereço de memória [lpMem] \Um ponteiro para o bloco de memória que a função realoca. Este ponteiro é retornado por uma chamada anterior para a função HeapAlloc ou HeapReAlloc.
    e A quantidade de pedaços [dwBytes] \O novo tamanho do bloco de memória, em bytes. O tamanho de um bloco de memória pode ser aumentado ou diminuído usando esta função.
  \Se o heap especificado pelo parâmetro hHeap for um heap "não expansível", dwBytes deve ser menor que 0x7FFF8. 
  \Você pode criar um heap não expansível chamando a função HeapCreate com um valor diferente de zero.
    devolvendo o endereço de memória. \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o bloco de memória realocado.
  \Se a função falhar e você não tiver especificado HEAP_GENERATE_EXCEPTIONS nas dwFlags (o que é o caso aqui), o valor de retorno será NULL.

Etapas para que se mostre olá mundo no console:
  Intel $B403. \mov  ah,0x3
  Intel $CD10. \int  0x10
  Intel $B001. \mov  al,0x1
  Intel $B30A. \mov  bl,0xa
  Intel $B90B00BD13.  \mov  ecx,0x13bd000b
  Intel $01B413CD10C34F. \add  DWORD PTR [ebx+edx*1+0x4fc310cd],esi
  Intel $69206D756E64.  \ imul esp,DWORD PTR [eax],0x646e756d
  Intel $6D. \  outs dx,DWORD PTR ds:[esi]
  Intel $21. \   .byte 0x21
  Intel $0D.  \   .byte 0xd
  Intel $0A.  \   .byte 0xa

Etapas para que se adicione um pedaço para um segundo pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte 67 8B 45 08
  Intel $0FB600. \ movzx eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo byte 67 8B 5D 0C
  Intel $0003. \ add [ebx],al

Etapas para que se adicione um pedaço para um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $0FB600. \ movzx eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
  Intel $0103. \ adicione [ebx],eax

Etapas para que se adicione um número para um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
  Intel $0FB60B. \ movzx ecx,[ebx]
  Intel $03C8. \ adicione ecx,eax
  Intel $880B. \ mov [ebx],cl

Etapas para que se adicione um número para um endereço de memória;
Etapas para que se adicione um número para um segundo número:
\ poderia ser escrito também assim:  Intel $8B85080000008B008B9D0C0000000103.
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o valor do endereço atual da pilha do processador + 8 no registrador de acumulação (eax)
  Intel $8B00. \ mov eax,[eax] ; ->  load memory pointed to by accumulator into accumulator
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> load the current stack address + 12 into working register
  Intel $0103. \ adicione [ebx],eax ; ->add accumulator to memory pointed to by working register

Etapas para que se conjuncione logicamente um pedaço com um segundo pedaço:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $2003. \ e [ebx],al

Etapas para que se conjuncione logicamente um pedaço com um número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $2003. \ e [ebx],al

Etapas para que se conjuncione logicamente um número com um segundo número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $2103. \ e [ebx],eax

Etapas para que se disjuncione logicamente um pedaço com um segundo pedaço:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0803. \ ou [ebx],al

Etapas para que se disjuncione logicamente um pedaço com um número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0803. \ ou [ebx],al

Etapas para que se disjuncione logicamente um número com um segundo número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $0903. \ ou [ebx],eax

Etapas para que se disjuncione seletivamente um pedaço com um segundo pedaço:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ a segunda byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $3003. \ xor [ebx],al

Etapas para que se disjuncione seletivamente um pedaço com um número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $3003. \ ou [ebx],al

Etapas para que se disjuncione seletivamente um número com um segundo número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $3103. \ xor [ebx],eax

Etapas para que se avance um percorredor:
  Intel $8B9D08000000. \ mov ebx,DWORD PTR [ebp+0x8] | mov ebx,[ebp+8]  \ salva o percorredor no registrador ebx
  Intel $FF8314000000. \ inc DWORD PTR [ebx+0x14] | inc [ebx+20] \ aumenta o valor do caractere final deste segmento inicial deste percorredor.
  Intel $FF8308000000. \ inc DWORD PTR [ebx+0x8] | inc [ebx+8] \ aumenta o valor do caractere inicial deste segmento final deste percorredor.

Etapas para que se recue um percorredor:
  Intel $8B9D08000000. \ mov ebx,[ebp+8]  \ salva o percorredor no registrador ebx
  Intel $FF8B14000000. \ dec [ebx+20] \ reduz o valor do caractere final deste segmento inicial deste percorredor.
  Intel $FF8B08000000. \ dec [ebx+8] \ reduz o valor do caractere inicial deste segmento final deste percorredor.

Etapas para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres e uma tabela de tradução (equal only):
  Intel $8BB508000000. \ mov esi,[ebp+8] \ a string
  Intel $8B36. \ mov esi,[esi] \ o caractere inicial desta string
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda string
  Intel $8B3F. \ mov edi,[edi] \ o caractere inicial desta segunda string
  Intel $8B8510000000. \ mov eax,[ebp+16] \ a quantidade de caracteres desta string
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9514000000. \ mov edx,[ebp+20] \ a quantidade de caracteres desta segunda string
  Intel $8B12. \ mov edx,[edx]
  Intel $3BD0. \ cmp eax,edx \ if o differ do quantidade de caracteres, diga não.
  Intel $0F852B000000. \ jne [Se as condições acima não puderem ser satisfeitas, então:] Diga não. \ ************************************ was 2C
  Intel $8BC8. \ mov ecx,eax \ atribua quantidade de caracteres A ecx 
  Intel $8B9D18000000. \ mov ebx,[ebp+24] \ o tabela de tradução
  Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
  \ loop:
  Intel $85C9. \ test ecx,ecx
  Intel $0F8424000000. \ jz say yes \ ************************************ was 25
   \ fetch e translate o current pedaço no segunda string
  Intel $8A07. \ mov al,[edi]
  Intel $D7. \ xlat al,[ebx]
  Intel $C1E008. \ shl eax,8 C1 E0 08
  \ fetch e translate o current pedaço no string
  Intel $8A06. \ mov al,[esi]
  Intel $D7. \ xlat al,[ebx]
   \ compare o two translated pedaços
  Intel $38E0. \ cmp al,ah
  Intel $0F8508000000. \ jne  Diga não. \ ************************************
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $E9DFFFFFFF. \ jmp loop \ ************************************ was DE
  \ Diga não.:
  Intel $C7C000000000. \ mov eax,0
  Intel $E906000000. \ jmp end
  \DIGA SIM
  Intel $C7C001000000. \ mov eax,1

 \ Rotina nova criada pelo Dahn - spanish strings 2 - which table to use?

Etapas para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres e uma tabela de tradução devolvendo um número:
  Intel $8BB508000000. \ mov esi,[ebp+8] \ a string
  Intel $8B36. \ mov esi,[esi] \ o first do string
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda string
  Intel $8B3F. \ mov edi,[edi] \ o first do segunda string
  Intel $8B8510000000. \ mov eax,[ebp+16] \ a quantidade de caracteres do string
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9514000000. \ mov edx,[ebp+20] \ a quantidade de caracteres do segunda string
  Intel $8B12. \ mov edx,[edx]
  Intel $8B9D18000000. \ mov ebx,[ebp+24] \ o tabela de tradução
  Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
  \ obtenha o minimum quantidade de caracteres
  Intel $8BC8. \ mov ecx,eax
  Intel $3BCA. \ cmp ecx,edx
  Intel $0F8602000000. \ jbe L2
  Intel $8BCA. \ mov ecx,edx
  \ if o minimum quantidade de caracteres for 0, jump para L5
  Intel $85C9. \ test ecx,ecx
  Intel $0F8428000000. \ jz L5
  \L2:
  \ loop:
  \ fetch e translate o current pedaço no string
  Intel $8A06. \ mov al,[esi]
  Intel $D7. \ xlat al,[ebx]
  Intel $88C2. \ mov dl,al
  \ fetch e translate o current pedaço no segunda string
  Intel $8A07. \ mov al,[edi]
  Intel $D7. \ xlat al,[ebx]
  Intel $88C6. \ mov dh,al
  \L3:
  \ compare o two translated pedaços
  Intel $38F2. \ cmp dl,dh
  Intel $0F8510000000. \ jne L4
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $85C9. \ test ecx,ecx
  Intel $0F8405000000. \ jz L4
  Intel $E9DEFFFFFF. \ jmp L2
  \L4:
  \ Carregue pedaços para EAX e edx por final compare
  Intel $0FB6C2. \ movzx eax,dl
  Intel $0FB6D6. \ movzx edx,dh
  \L5:
  \ subtraia either o lengths ou os last dois pedaços para abra o eax para <0, =0, >0
  Intel $2BC2. \ sub eax,edx
  Intel $8B9D1C000000. \ mov ebx,[ebp+28] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas para que se determine se um pedaço é um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o outro byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8406000000. \ je over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um pedaço é maior que um segundo pedaço;
Etapas para que se determine se um pedaço é maior do que um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8706000000. \ ja over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um pedaço é maior que um número;
Etapas para que se determine se um pedaço é maior do que um número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8F06000000. \ jg over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um pedaço é maior do que ou igual para um segundo pedaço;
Etapas para que se determine se um pedaço é maior que ou igual para um segundo pedaço;
Etapas para que se determine se um pedaço é maior ou igual para um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8306000000. \ ja over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um pedaço é menor que um segundo pedaço;
Etapas para que se determine se um pedaço é menor do que um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8206000000. \ jb over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um pedaço é menor que um número;
Etapas para que se determine se um pedaço é menor do que um número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8C06000000. \ jl over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um pedaço é menor do que ou igual para um segundo pedaço;
Etapas para que se determine se um pedaço é menor que ou igual para um segundo pedaço;
Etapas para que se determine se um pedaço é menor ou igual para um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8606000000. \ jbe over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um pedaço é um número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8406000000. \ je over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um detector é um número;
Etapas para que se determine se um detector é um segundo detector;
Etapas para que se determine se um endereço de memória é um número;
Etapas para que se determine se um endereço de memória é um segunda endereço de memória;
Etapas para que se determine se um número é um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8406000000. \ je over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um endereço de memória é maior do que um segundo endereço de memória;
Etapas para que se determine se um número é maior do que um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8F06000000. \ jg over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um endereço de memória é maior do que ou igual para um segundo endereço de memória;
Etapas para que se determine se um endereço de memória é maior que ou igual para um segundo endereço de memória;
Etapas para que se determine se um endereço de memória é igual ou maior do que um segundo endereço de memória;
Etapas para que se determine se um endereço de memória é igual ou maior que um segundo endereço de memória;
Etapas para que se determine se um endereço de memória é maior ou igual para um segundo endereço de memória;
Etapas para que se determine se um número é um segundo número ou more;
Etapas para que se determine se um número é maior do que ou igual para um segundo número;
Etapas para que se determine se um número é maior que ou igual para um segundo número;
Etapas para que se determine se um número é igual ou maior do que um segundo número;
Etapas para que se determine se um número é igual ou maior que um segundo número;
Etapas para que se determine se um número é maior ou igual para um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8D06000000. \ jge over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um endereço de memória é menor do que um segundo endereço de memória;
Etapas para que se determine se um endereço de memória é menor que um segundo endereço de memória;
Etapas para que se determine se um número é menor que um segundo número;
Etapas para que se determine se um número é menor do que um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8C06000000. \ jl over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se um endereço de memória é menor do que ou igual para um segundo endereço de memória;
Etapas para que se determine se um endereço de memória é menor que ou igual para um segundo endereço de memória;
Etapas para que se determine se um endereço de memória é menor ou igual para um segundo endereço de memória;
Etapas para que se determine se um número é um segundo número ou menos;
Etapas para que se determine se um número é um segundo número ou menor;
Etapas para que se determine se um número é menor do que ou igual para um segundo número;
Etapas para que se determine se um número é menor que ou igual para um segundo número;
Etapas para que se determine se um número é menor ou igual para um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8E06000000. \ jle over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas para que se determine se uma string está em branco:
  \ assume true
  Intel $B801000000. \ mov eax,1
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ a string
    \ if first for 0, exit
  Intel $833B00. \ cmp [ebx],0
  Intel $0F8410000000. \ je end
  \ if last for menor do que first, exit
  Intel $8B5304. \ mov edx,[ebx+4] \ last endereço de memória
  Intel $3B13. \ cmp edx,[ebx]
  Intel $0F8C05000000. \ jl end
  \Diga não.:
  Intel $B800000000. \ mov eax,0
  \ END:

Etapas para que se preencha pedaços com um pedaço começando sob um endereço de memória por um quantidade de pedaços:
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ o endereço de memória
  Intel $8B3F. \ mov edi,[edi]
  Intel $8B8D10000000. \ mov ecx,[ebp+16] \ a contagem
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $8A00. \ mov al,[eax]
  Intel $FC. \ cld
  Intel $F3AA. \ rep stosb

Etapas para que se copie pedaços desde um endereço de memória para um segundo endereço de memória por um quantidade de pedaços:
    \ copie handling overlap com 1 pedaço moves
  Intel $8BB508000000. \ mov esi,[ebp+8] \ o endereço de memória
  Intel $8B36. \ mov esi,[esi]
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda endereço de memória
  Intel $8B3F. \ mov edi,[edi]
  Intel $8B8D10000000. \ mov ecx,[ebp+16] \ o número
  Intel $8B09. \ mov ecx,[ecx]
  \ check por something para copiar
  Intel $81F900000000. \ cmp ecx,0
  Intel $0F8E39000000. \ jle end
  \ check por no overlap
  Intel $3BF7. \ cmp esi,edi
  Intel $0F8D24000000. \ jge forward
  Intel $8BC6. \ mov eax,esi
  Intel $03C1. \ adicione eax,ecx
  Intel $3BC7. \ cmp eax,edi
  Intel $0F8E18000000. \ jle forward
  \ copia backward
  Intel $03F1. \ adicione esi,ecx
  Intel $4E. \ dec esi
  Intel $03F9. \ adicione edi,ecx
  Intel $4F. \ dec esi
  \ backward
  Intel $8A16. \ mov dl,[esi]
  Intel $8817. \ mov [edi],dl
  Intel $4E. \ dec esi
  Intel $4F. \ dec edi
  Intel $49. \ dec ecx
  Intel $0F85F3FFFFFF. \ jnz backward
  Intel $E90D000000. \ jmp end
  \ forward: copia forward
  Intel $8A16. \ mov dl,[esi]
  Intel $8817. \ mov [edi],dl
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $0F85F3FFFFFF. \ jnz forward

Etapas para que se lance um subtexto sobre uma string: \assembly
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a string
  \ atribua o caractere inicial desta string ao first do subtexto
  Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o caractere inicial desta string
  Intel $898800000000. \ mov [eax+0],ecx \ o first do subtexto
  \ atribua o caractere final desta string ao caractere final deste subtexto
  Intel $8B8B04000000. \ mov ecx,[ebx+4] \ o last do string
  Intel $898804000000. \ mov [eax+4],ecx \ o caractere final deste subtexto

Etapas para que se divida um endereço de memória por um número;
Etapas para que se divida um número por um segundo número:
  Se o segundo número for 0, atribua o maior número ao número; saia.
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $99. \ cdq
  Intel $F73B. \ div [ebx] \ means div eax,[ebx] but é weird form
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas para que se divida um endereço de memória por um número usando um quociente e um resto;
Etapas para que se divida um número por um segundo número usando um quociente e um resto:
  Se o segundo número for 0, atribua o maior número ao quociente; atribua 0 ao resto; saia.
  Intel $8B8508000000. \ mov eax,[ebp+8] ; -> salva o 1º número (epb+8) no registrador eax
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] ; -> salva o 2º número (epb+12) no registrador ebx
  Intel $8B00. \ mov eax,[eax] 
  Intel $99. \ cdq
  Intel $F73B. \ idiv [ebx] ; -> é a mesma coisa que idiv eax,[ebx] mas está num formato estranho
  Intel $8B9D10000000. \ mov ebx,[ebp+16] ; ->salva o quociente (ebp+16) no registrador ebx
  Intel $8903. \ mov [ebx],eax ; -> salva eax no endereço de ebx
  Intel $8B9D14000000. \ mov ebx,[ebp+20] ; ->salva o resto (ebp+20) no registrador ebx
  Intel $8913. \ mov [ebx],edx ; -> salva o conteúdo de edx no registrador ebx

O som de aviso é uma wave igual a $524946463A02000057415645666D74201200000001000100401F0000401F000001000800000066616374040000000702000064617461070200007F7F807F7F807F7F808080807F807F7F80817F81817E7E827E7D847C79877D5F6D99B2A25D608269A5979869667F7D8D738C7D8C5E7E878F767A75868D84797278829A7D7E857A73929271657492907D7E7D787E8B887C758388827E817F7C7B89897C7A7E84838183827E7A8488877D7E8181808484817C7F84838181807E7F8283807E8081808182807F7F81818081807F7F8081818080807F7F808180807F80808080807F8080807F8080808080807F7F7F7F7F8080807F7F7F7C7B8182817C7B7D7E8082807D7D7C7F8281807F7C7D808082807E7E7E7D7E807D7B7C7B7D7D7B7A7979797875727269797A490F4571FFF4FF0C001297FBF492525BB0F5B26A001C69BEE5BA76476F9EBD953C3757BAC9BB705C7F9AA883645D7897AA9B806977959588696976999B83766F828C907F7375828E91877B757D868B837A757C858D8880787B8187847B7A7D8788807B79808486817D7C7F8384817D7C7F8484817B7B7D83847F7C7B7E8182827D7C7C8082817D7C7D7F81807F7D7D7F82817F7B7B7E8081807E7D7D7F80807E7D7D7E80807E7D7D7E7F807F7D7D7E7F807F7E7D7E7E80807F7E7D7E80807F7E7E7E7F7F7E7E7E7F7F7F7F7E7E7F7F807F7F7E7E7E7F8080807E7E7E80807F7E7E7F8081807F7F7E7F7F80807F7E7F8081807F7E7E7E80808080807F807F7F7F7F7F7F7F80808080807F7F7F808080807F80808180807F80808100.

A matriz de tons de cinza é um texto hexadecimal igual a $8716993E8716993E8716993E0000000000000000A245163FA245163FA245163F0000000000000000D578E93DD578E93DD578E93D00000000000000000000000000000000000000000000803F00000000000000000000000000000000000000000000803F.


