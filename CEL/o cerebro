\ O Cérebro - A Sociedade Osmosiana de Programadores de Linguagens Naturais - desde 2006.

\ Regras:
\ No geral, cada linha deve terminar com um ponto final.
\ As exceções são quando você está declarando uma variável do tipo conjunto, 
\ (cujas linhas podem terminar com uma vírgula, exceto no último item do conjunto)
\ Ou quando você estiver declarando um cabeçalho de rotina (que termina com sinal de dois pontos)
\ Quando um campo de texto é convertido para texto puro, 
\ o caractere especial LF é adicionado depois do caractere especial CR
\ Já quando um texto é transformado em um campo de texto, o caractere LF é removido.
\ Existe sempre uma linha, no mínimo.
\ Existe sempre um caractere CR no fim da ultima linha.

\Etapas necessárias para que se inicialize o Component Object Model:
\Mande os códigos 0 e 2 para a função "CoInitializeEx" da biblioteca "ole32.dll" [coinit_aparthreaded].

A contagem total é um número igual a 0.

O detector de ignição é um detector igual a 1.

O sinal de desligamento é um detector igual a 0.

Um abc é um conjunto com 
\ A estrutura ABC contém a largura de um caractere em uma fonte TrueType.
Um número denominado abca, \ O espaçamento A do caractere. O espaçamento A é a distância a ser adicionada à posição atual antes de desenhar o glifo do caractere.
Um número denominado abcb, \ O espaçamento B do caractere. O espaçamento B é a largura da parte desenhada do glifo do caractere.
Um número denominado abcc.\ O espaçamento C do personagem. O espaçamento C é a distância a ser adicionada à posição atual para fornecer um espaço em branco à direita do glifo do caractere.
\ A largura total de um caractere é a soma dos espaços A, B e C. Tanto o espaço A quanto o C podem ser negativos para indicar cavidades ou saliências.

Um abc endereço de memória é um endereço de memória para um abc.
\ Um ponteiro para uma matriz de estruturas ABC que recebe as larguras dos caracteres, em unidades lógicas. 
\Esta matriz deve conter, no mínimo, a mesma quantidade estruturas ABC que a quantidade de caracteres no intervalo especificado pelos parâmetros uFirstChar e uLastChar.
\ Para mais informações, veja os sistes abaixo: 
\ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-abc
\ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsa

Um abca é um número. \ O espaçamento A do caractere. O espaçamento A é a distância a ser adicionada à posição atual antes de desenhar o glifo do caractere.

Um abcc é um número. \ O espaçamento C do personagem. O espaçamento C é a distância a ser adicionada à posição atual para fornecer um espaço em branco à direita do glifo do caractere.

Um posicionamento absoluto é um número.

Etapas necessárias para que se adicione um pedaço para uma segunda pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte 67 8B 45 08
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo byte 67 8B 5D 0C
Intel $0003. \ add [ebx],al

Etapas necessárias para que se adicione um pedaço para um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
Intel $0103. \ adicione [ebx],eax

Etapas necessárias para que se adicione uma fração para uma segunda fração:
Isole a fração.
Normalize a fração e a segunda fração.
Adicione o numerador desta fração para o numerador desta segunda fração.
Reduce a segunda fração.

Etapas necessárias para que se adicione uns horizontal twips e uns vertical twips para o current spot:
Adicione o horizontal twips para a coordenada x deste spot deste context.
Adicione o vertical twips para a coordenada y deste spot deste context.

Etapas necessárias para que se adicione uma line para uma figura:
Se a figura for inexistente, crie a figura; posponha a figura para as figuras.
Adicione o start desta line para a figura.
Adicione o end desta line para a figura.

Etapas necessárias para que se adicione um nome para uns choices:
Aloque memória por uma choice.
Atribua o nome ao nome desta choice.
Atribua a choice at o end of as choices.

Etapas necessárias para que se adicione um número e uma segunda número para um pair:
Adicione o número para o número x deste pair.
Adicione a segunda número para o número y deste pair.

Etapas necessárias para que se adicione um número para uma segunda número e um terceiro número para um quarto número:
Adicione o número para a segunda número.
Adicione o terceiro número para o quarto número.

Etapas necessárias para que se adicione um número para um pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
Intel $0FB60B. \ movzx ecx,[ebx]
Intel $03C8. \ adicione ecx,eax
Intel $880B. \ mov [ebx],cl

Etapas necessárias para que se adicione um número para um fração:
Adicione o número / 1 para a fração.

Etapas necessárias para que se adicione um número para um pair:
Adicione o número para o número x deste pair.
Adicione o número para o número y deste pair.

Etapas necessárias para que se adicione um número para um endereço de memória;
Etapas necessárias para que se adicione um número para uma segunda número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda número
Intel $0103. \ adicione [ebx],eax

Etapas necessárias para que se adicione um pair para uma segunda pair:
Adicione o número x deste pair para o número x deste segunda pair.
Adicione o número y deste pair para o número y deste segunda pair.

Etapas necessárias para que se adicione um pdf object usando um categoria:
Crie o pdf object usando o categoria.
Posponha o pdf object para os objects deste pdf state.
Adicione 1 para o object número deste pdf state.
Atribua o object número deste pdf state ao número deste pdf object.

Etapas necessárias para que se adicione um quora para um terminal:
Crie o quora.
Posponha o quora para o quora deste terminal.
Se o terminal não estiver full, cancele.
Atribua o first destes quoras deste terminal a um doomed quora.
Remove o doomed quora from os quoras deste terminal.
Destrua o doomed quora.

Etapas necessárias para que se adicione um spot para um figura:
Append o spot para a figura.

Etapas necessárias para que se adicione um string para uns conjunto de textos:
Crie um conjunto de texto usando o string.
Posponha o conjunto de texto para o conjunto de textos.

Um addrinfo é um conjunto com \ https://docs.microsoft.com/en-us/windows/win32/api/ws2def/ns-ws2def-addrinfoa
\A estrutura addrinfo é usada pela função getaddrinfo para armazenar informações de endereço de host.
Um número denominado ai_flags, \Tipo: int
\ Sinalizadores que indicam opções usadas na função getaddrinfo.
\ Os valores com suporte para o membro ai_flags são definidos no arquivo de cabeçalho Ws2def.h no Windows SDK para Windows 7 e posterior. 
\ Esses valores são definidos no arquivo de cabeçalho Ws2tcpip.h no Windows SDK para Windows Server 2008 e Windows Vista. 
\ Esses valores são definidos no arquivo de cabeçalho Ws2tcpip.h no Platform SDK para Windows Server 2003 e Windows XP. 
\ Os valores com suporte para o membro ai_flags podem ser uma combinação XOR de valores hexadecimais.
Um número denominado ai_family, \A família do endereço. Os valores possíveis para a família de endereços são definidos no arquivo de cabeçalho Winsock2.h.
\ No Windows SDK lançado para Windows Vista e posterior, a organização dos arquivos de cabeçalho foi alterada e os valores possíveis para a família de endereços são definidos no arquivo de cabeçalho Ws2def.h.
\  Observe que o arquivo de cabeçalho Ws2def.h é automaticamente incluído no Winsock2.h e nunca deve ser usado diretamente.
\Os valores atualmente suportados são AF_INET ou AF_INET6, que são os formatos da família de endereços da Internet para IPv4 e IPv6. 
\Outras opções para a família de endereços (AF_NETBIOS para uso com NetBIOS, por exemplo) são suportadas se um provedor de serviços Windows Sockets para a família de endereços estiver instalado. 
\Observe que os valores para a família de endereço AF_ e constantes da família de protocolo PF_ são idênticos (por exemplo, AF_UNSPEC e PF_UNSPEC), portanto, qualquer constante pode ser usada.
Um número denominado ai_sockettype, \ O tipo de soquete. Os valores possíveis para o tipo de soquete são definidos no arquivo de cabeçalho Winsock2.h.
\No Windows Sockets 2, novos tipos de soquete foram introduzidos. 
\Um aplicativo pode descobrir dinamicamente os atributos de cada protocolo de transporte disponível por meio da função WSAEnumProtocols. 
\Portanto, um aplicativo pode determinar o tipo de soquete possível e as opções de protocolo para uma família de endereços e usar essas informações ao especificar este parâmetro. 
\As definições de tipo de soquete nos arquivos de cabeçalho Winsock2.he Ws2def.h serão atualizadas periodicamente conforme novos tipos de soquete, famílias de endereços e protocolos são definidos.
\ No Windows Sockets 1.1, os únicos tipos de soquete possíveis são SOCK_DATAGRAM (2) e SOCK_STREAM (1) .
Um número denominado ai_protocol, \ O tipo de protocolo. As opções possíveis são específicas para a família de endereços e tipo de soquete especificados. 
\Os valores possíveis para o ai_protocol são definidos nos arquivos de cabeçalho Winsock2.h e Wsrm.h.
\No Windows SDK lançado para Windows Vista e posterior, a organização dos arquivos de cabeçalho foi alterada e esse membro pode ser um dos valores do tipo de enumeração IPPROTO definido no arquivo de cabeçalho Ws2def.h. 
\Observe que o arquivo de cabeçalho Ws2def.h é automaticamente incluído no Winsock2.h e nunca deve ser usado diretamente.
\Se um valor de 0 for especificado para ai_protocol, o chamador não deseja especificar um protocolo e o provedor de serviços escolherá o ai_protocol a ser usado. 
\Para protocolos diferentes de IPv4 e IPv6, defina ai_protocol como zero.
\ Se o membro ai_family for 26 (AF_IRDA), então o ai_protocol deve ser 0.
Um número denominado ai_addrlen, \O comprimento, em bytes, do buffer apontado pelo membro ai_addr.
Um pchar denominado ai_canonname, \O nome canônico do host.
Um sockaddrptr denominado ai_addr, \Um ponteiro para uma estrutura sockaddr. 
\O membro ai_addr em cada estrutura addrinfo retornada aponta para uma estrutura de endereço de soquete preenchida. 
\O comprimento, em bytes, de cada estrutura addrinfo retornada é especificado no membro ai_addrlen.
Um addrinfoptr denominado ai_next. \Um ponteiro para a próxima estrutura em uma lista vinculada. 
\Este parâmetro é definido como NULL na última estrutura addrinfo de uma lista vinculada.

Some addrinfo routines é um conjunto com
Um getaddrinfo endereço de memória,
Um freeaddrinfo endereço de memória.

Um addrinfoptr é um endereço de memória para um addrinfo.

Etapas necessárias para que se ajuste uma caixa usando um número e um segundo número e um terceiro número e um quarto número:
Adicione o número para a coordenada esquerda desta caixa.
Adicione o segundo número para a coordenada superior desta caixa.
Adicione o terceiro número para a coordenada direita desta caixa.
Adicione o quarto número para a coordenada inferior desta caixa.

Etapas necessárias para que se ajuste um item:
Atribua os dwfileattributes deste win32finddata deste item a um número.
Conjuncione logicamente o número com 16 [file_attribute_directory].
Se o número for 0, atribua "arquivo" à categoria deste item. \; atribua "arquivo" à classe deste item.
Se o número não for 0, atribua "endereço de pasta" à categoria deste item.\; atribua "directorio" à classe deste item.
Converta o ftcreationtime deste win32finddata deste item para a creation date/time string deste item . \ adicionado para classificação de e-mails.
Atribua o endereçamento deste cfilename deste win32finddata deste item a um pchar.
Converta o pchar para o designador deste item.
Se a categoria deste item for "endereço de pasta", posponha "\" para o designador deste item.
Atribua o endereço da pasta deste item seguido de o designador deste item ao endereço completo deste item.
Extraia a extensão deste item from o designador deste item como um endereço completo.
Atribua o nfilesizelow deste win32finddata deste item ao size deste item.
Se o target deste first deste designador deste item não for o ponto final, cancele.
Obtenha o item (not first time).

Etapas necessárias para que se ajuste um line com um número e um segundo número e um terceiro número e um quarto número:
Adicione o número para o x deste start desta line.
Adicione o segundo número para o y deste start desta line.
Adicione o terceiro número para o x deste end desta line.
Adicione o quarto número para o y deste end desta line.

Etapas necessárias para que se ajuste um picture (extract caixas from gpbitmap):
Se o picture for inexistente, cancele.
Atribua 0 à coordenada esquerda desta caixa desta picture.
Atribua 0 à coordenada superior desta caixa desta picture.
Atribua a largura deste gpbitmap desta picture menos 1 times o tpp à coordenada direita desta caixa desta picture.
Atribua a altura deste gpbitmap desta picture menos 1 times o tpp à coordenada inferior desta caixa desta picture.
Atribua a caixa desta picture à uncropped caixa desta picture.

Etapas necessárias para que se ajuste spacing usando um string:
Se o quadro atual não for o printer canvas, cancele.
Call "gdi32.dll" "SetTextCharacterExtra" com 
o printer canvas \ Um identificador para o contexto do dispositivo.
e 0.  \ A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
\Se o modo de mapeamento atual não for MM_TEXT, o parâmetro nCharExtra será transformado e arredondado para o pixel mais próximo.
\quero traduzir esse comando como: Mande o printer canvas e o código 0 para a função "SetTextCharacterExtra" da biblioteca "gdi32.dll".
Call "gdi32.dll" "GetCurrentObject" com o printer canvas \ Um identificador para o contexto do dispositivo.
e 6 [obj_font]  \ O tipo de objeto a ser consultado. Este parâmetro pode ser vários valores.
\ OBJ_FONT -> Retorna a fonte selecionada no momento.
devolvendo um número identificador. \ Se a função for bem-sucedida, o valor de retorno é um identificador para o objeto especificado. Se a função falhar, o valor de retorno será NULL.
Call "gdi32.dll" "SelectObject" com o memory canvas \ Um identificador para o contexto do dispositivo.
e o número identificador. \ Uma identificador para o objeto a ser selecionado. Nesse caso é o número do comando anterior, retornado pelo GetCurrentObject acima
Obtenha um largura usando o string e o memory canvas.
Call "gdi32.dll" "SelectObject" com o memory canvas e o null número da fonte.
Obtenha uma segunda largura usando o string e o printer canvas.
Atribua o largura menos a segunda largura dividido pelo quantidade de caracteres deste string a um número.
Call "gdi32.dll" "SetTextCharacterExtra" com o printer canvas e o número.

Etapas necessárias para que se align um text usando um alinhamento:
Atribua o alinhamento ao alinhamento deste text.

Um alinhamento é um string [center, left, ou right].

Um quantia é um número.

Um anchor é um position.

Um máscara de conjunção lógica é uma mask.

Um ângulo é uns precise degrees [0 para 3599].

Etapas necessárias para que se posponha um trecho para um file:
Limpe o erro do fluxo de entrada/saída.
Call "kernel32.dll" "SetFilePointer" \Esta função armazena o ponteiro do arquivo em dois valores LONG.
com o file \ Um identificador para o arquivo.
\O identificador de arquivo deve ser criado com o direito de acesso GENERIC_READ ou GENERIC_WRITE. 
\Para obter mais informações sobre direitos de acesso, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-security-and-access-rights
e 0 [lDistanceToMove]
\Os 32 bits de ordem inferior de um valor com sinal que especifica o número de bytes para mover o ponteiro do arquivo.
\Se lpDistanceToMoveHigh não for NULL, lpDistanceToMoveHigh e lDistanceToMove formam um único valor de 64 bits com sinal que especifica a distância a ser movida.
\Se lpDistanceToMoveHigh for NULL, lDistanceToMove será um valor de 32 bits com sinal. 
\Um valor positivo para lDistanceToMove move o ponteiro do arquivo para frente no arquivo e um valor negativo move o ponteiro para trás no arquivo .
e 0 [lpDistanceToMoveHigh]
\ Um ponteiro para os 32 bits de ordem superior da distância de 64 bits com sinal a ser movida.
\Se você não precisa de 32 bits de alta ordem, este ponteiro deve ser definido como NULL.
\ Quando não é NULL, esse parâmetro também recebe o DWORD de ordem superior do novo valor do ponteiro do arquivo.
\ Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer
e 2 [file_end] [dwMoveMethod]
\ O ponto de partida para o movimento do ponteiro do arquivo.
\ Este parâmetro pode ser um dos seguintes valores.
\0 = FILE_BEGIN ->  O ponto de partida é zero ou o início do arquivo.
\ 1 = FILE_CURRENT -> O ponto de partida é o valor atual do ponteiro do arquivo.
\ 2 = FILE_END -> O ponto de partida é a posição atual de fim de arquivo.
devolvendo um result número.
\Se a função for bem-sucedida e lpDistanceToMoveHigh for NULL, o valor de retorno será o DWORD de ordem inferior do novo ponteiro de arquivo. 
\Obs: Se a função retornar um valor diferente de INVALID_SET_FILE_POINTER, a chamada para SetFilePointer foi bem-sucedida.
Se o result número for -1, atribua "Ocorreu um erro na hora de posicionar o ponteiro do arquivo." ao erro do fluxo de entrada/saída; exit.
\ Se um novo ponteiro de arquivo for um valor negativo, a função falhará, o ponteiro de arquivo não será movido e o código retornado por GetLastError será ERROR_NEGATIVE_SEEK.
Call "kernel32.dll" "WriteFile"  \ Grava dados no arquivo ou dispositivo de entrada / saída (E / S) especificado.
\ Esta função foi projetada para operação síncrona e assíncrona.
com o file [hFile]
\ Um identificador para o arquivo ou dispositivo de E / S 
\(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
\ O parâmetro hFile deve ter sido criado com o acesso de gravação. 
\Para obter mais informações, consulte os sites
\ https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/generic-access-rights
\ https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-security-and-access-rights
\ Para operações de gravação assíncrona, hFile pode ser qualquer identificador aberto com a função CreateFile usando o sinalizador FILE_FLAG_OVERLAPPED 
\ou um identificador de soquete retornado pelo soquete ou função de aceitação.
e o first deste trecho [lpBuffer]
\ Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
\ Este buffer deve permanecer válido durante a operação de gravação. 
\ O chamador não deve usar esse buffer até que a operação de gravação seja concluída.
e o quantidade de caracteres deste trecho [nNumberOfBytesToWrite]
\ O número de bytes a serem gravados no arquivo ou dispositivo.
\ Um valor zero especifica uma operação de gravação nula. 
\O comportamento de uma operação de gravação nula depende do sistema de arquivos subjacente ou da tecnologia de comunicação.
e um endereçamento desse número [lpNumberOfBytesWritten]
\Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono. 
\ WriteFile define esse valor como zero antes de fazer qualquer trabalho ou verificação de erro.
\ Use NULL para este parâmetro se esta for uma operação assíncrona para evitar resultados potencialmente errôneos.
\Este parâmetro pode ser NULL somente quando o parâmetro lpOverlapped não for NULL.
e 0 [lpOverlapped]
\Um ponteiro para uma estrutura OVERLAPPED é necessário se o parâmetro hFile foi aberto com FILE_FLAG_OVERLAPPED, caso contrário, este parâmetro pode ser NULL.
\ Para um hFile que oferece suporte a deslocamentos de byte, se você usar este parâmetro, deverá especificar um deslocamento de byte no qual iniciar a gravação no arquivo ou dispositivo. 
\Esse deslocamento é especificado definindo os membros Offset e OffsetHigh da estrutura OVERLAPPED. 
\Para um hFile que não oferece suporte a deslocamentos de byte, Offset e OffsetHigh são ignorados.
\Para gravar no final do arquivo, especifique os membros Offset e OffsetHigh da estrutura OVERLAPPED como 0xFFFFFFFF. 
\Isso é funcionalmente equivalente a chamar anteriormente a função CreateFile para abrir hFile usando o acesso FILE_APPEND_DATA.
\ Para obter mais informações sobre diferentes combinações de lpOverlapped e FILE_FLAG_OVERLAPPED, consulte:
\ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
\ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#synchronization-and-file-position
devolvendo o result número.
\ Se a função for bem-sucedida, o valor de retorno será diferente de zero (VERDADEIRO).
\ Se a função falhar ou estiver sendo concluída de forma assíncrona, o valor de retorno será zero (FALSO). 
\Para obter informações de erro estendidas, chame a função GetLastError.
\ Nota: O código GetLastError ERROR_IO_PENDING não é uma falha; indica que a operação de gravação está com conclusão pendente de forma assíncrona. 
\ Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
Se o result número for 0, atribua "Ocorreu um erro na hora de salvar o arquivo." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se posponha um pedaço para um string:
Atribua o quantidade de caracteres deste string a um quantidade de caracteres armazenados.
Reassign o first deste string usando o quantidade de caracteres deste string mais 1.
Atribua o first deste string mais o quantidade de caracteres armazenados ao last deste string.
Atribua o pedaço para o target deste last deste string.

Etapas necessárias para que se posponha um pedaço para um string usando uma contagem:
Isole a contagem.
Percorra.
Se a contagem for menor do que 1, cancele.
Posponha o pedaço para o string.
Subtraia 1 from a contagem.
Repita.

Etapas necessárias para que se posponha um detector para um string:
Converta o detector para uma segunda string.
Posponha a segunda string para o string.

Etapas necessárias para que se posponha uma fração para um string:
Converta a fração para uma segunda string.
Posponha a segunda string para o string.

Etapas necessárias para que se posponha um número para um string:
Converta o número para uma segunda string.
Posponha a segunda string para o string.

Etapas necessárias para que se posponha um endereço de memória para um string:
Converta o endereço de memória para uma segunda string.
Posponha a segunda string para o string.

Etapas necessárias para que se posponha um spot para um polígono:
Se o polígono for inexistente, cancele.
Crie um vértice usando o spot.
Posponha o vértice para os vértices deste polígono.

Etapas necessárias para que se posponha um string para uma segunda string:
Se o string estiver em branco, cancele.
Atribua o quantidade de caracteres deste string a um quantidade de caracteres agrupados.
Atribua o quantidade de caracteres deste segunda string a um quantidade de caracteres armazenados.
Adicione o quantidade de caracteres armazenados para o quantidade de caracteres agrupados.
Reassign o first deste segunda string usando o quantidade de caracteres agrupados.
Atribua o first deste segunda string mais o quantidade de caracteres armazenados a um endereço de memória.
Copie pedaços from o first deste string para o endereço de memória pelo quantidade de caracteres deste string.
Atribua o first deste segunda string mais o quantidade de caracteres agrupados menos 1 ao last deste segunda string.

Etapas necessárias para que se posponha um string para uma segunda string (handling email transparency):
Se o string estiver em branco, cancele.
Lance um percorredor sobre o string.
Percorra.
Mova o percorredor (text file rules).
Se o vocábulo deste percorredor estiver em branco, cancele.
Se o vocábulo deste percorredor começa com ".", posponha "." para a segunda string.
Posponha o vocábulo deste percorredor para a segunda string.
Repita.

Etapas necessárias para que se posponha um string para uma segunda string usando uma contagem:
Isole a contagem.
Percorra.
Se a contagem for menor do que 1, cancele.
Posponha o string para a segunda string.
Subtraia 1 from a contagem.
Repita.

Etapas necessárias para que se posponha um string para um pdf object:
\ this guys adds CRLF
Posponha o string para o data deste pdf object.
Posponha o texto CRLF para o data deste pdf object.

Etapas necessárias para que se posponha um string para um pdf object sem advancing:
Posponha o string para o data deste pdf object.

Etapas necessárias para que se posponha uns coisas para uns segunda coisas:
Atribua o first destas coisas a uma coisa.
Se a coisa for inexistente, cancele.
Remove a coisa from as coisas.
Posponha a coisa para a segunda coisas.
Repita.

Etapas necessárias para que se posponha um temporizador para um string:
Converta o temporizador para uma segunda string.
Posponha a segunda string para o string.

Etapas necessárias para que se posponha um vértice para um polígono:
Se o polígono for inexistente, cancele.
Posponha o vértice para os vértices deste polígono.

Etapas necessárias para que se posponha uma coordenada x e uma coordenada y para um polígono:
Se o polígono for inexistente, cancele.
Crie um vértice usando a coordenada x e a coordenada y.
Posponha o vértice para os vértices deste polígono.

Etapas necessárias para que se posponha zeros para um string until its quantidade de caracteres é um número:
Se o quantidade de caracteres deste string for maior do que ou igual ao número, cancele.
Posponha "0" para o string.
Repita.

O seta do mouse é um cursor.

Etapas necessárias para que se assign um endereço de memória usando um quantidade de pedaços:
Se o quantidade de pedaços for 0, esvazie o endereço de memória; exit.
Isole o quantidade de pedaços.
Arredonde o quantidade de pedaços para cima para o nearest power of two.
Call "kernel32.dll" "HeapAlloc" com o endereço heap e 8 [heap_zero_memory] e o quantidade de pedaços devolvendo o endereço de memória.
Se o endereço de memória não for inexistente, adicione 1 para a contagem do heap; exit.

Etapas necessárias para que se role automaticamente um text usando um spot e um detector:
Se o text for inexistente, desative o detector; exit.
Atribua a altura desta font deste text a um número.
Limpe um difference.
Atribua a caixa deste text a uma caixa.
Indent a caixa usando o tpp.
Se a coordenada y deste spot for menor do que a coordenada superior desta caixa, atribua o número ao número y desta difference.
Se a coordenada y deste spot for maior do que a coordenada inferior desta caixa, atribua o número ao número y desta difference; negate o número y desta difference.
Se a coordenada x deste spot for menor do que a coordenada esquerda desta caixa, atribua o número ao número x desta difference.
Se a coordenada x deste spot for maior do que a coordenada direita desta caixa, atribua o número ao número x desta difference; negate o número x desta difference.
Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número x desta difference.
Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número y desta difference.
Se a difference for 0, desative o detector; exit.
Ligue o detector.
Role o text usando a difference.
Aguarde por 50 milliseconds.

Um baseline é um número.

Etapas necessárias para que se beep:
Call "user32.dll" "MessageBeep" com 0.

Etapas necessárias para que se begin um landscape sheet:
Make o landscape sheet 1056 pixels por 816 pixels.
Begin um sheet com o landscape sheet.

Etapas necessárias para que se begin um landscape sheet usando um title string:
Se o pdf documento detector não estiver ativo, limpe o landscape sheet; exit.
Make o landscape sheet 1056 pixels por 816 pixels.
Begin o sheet usando a caixa e o title (pdf style).

Etapas necessárias para que se begin um portrait sheet:
Make o portrait sheet 816 pixels por 1056 pixels.
Begin um sheet com o portrait sheet.

Etapas necessárias para que se begin um portrait sheet usando um title string:
Se o pdf documento detector não estiver ativo, limpe o portrait sheet; exit.
Make o portrait sheet 816 pixels por 1056 pixels.
Begin o sheet usando a caixa e o title (pdf style).

Etapas necessárias para que se begin printing:
Inicialize o printer canvas.
Atribua a magnitude desse docinfo ao cbsize deste docinfo.
Atribua o first deste nome deste module ao lpszdocname deste docinfo.
Call "gdi32.dll" "StartDocA" com o printer canvas e o endereçamento deste docinfo.

Etapas necessárias para que se begin printing um pdf:
Ligue o documento detector deste pdf state.
Atribua 0 ao object número deste pdf state.
Crie o font catálogo deste pdf state usando 113.
Begin printing o pdf (start o root).
Begin printing o pdf (start o parent).

Etapas necessárias para que se begin printing um pdf (start o parent):
Adicione um parent pdf object usando "parent".
Atribua o parent ao parent deste pdf state.
Posponha o número deste parent seguido de " 0 obj" para o parent.
Posponha "<<" para o parent.
Posponha "/Type /Pages" para o parent.

Etapas necessárias para que se begin printing um pdf (start o root):
Adicione um root pdf object usando "root".
Atribua o root ao root deste pdf state.
Posponha o número deste root seguido de " 0 obj" para o root.
Posponha "<<" para o root.
Posponha "/Type /Catalog" para o root.

Etapas necessárias para que se begin um sheet:
Begin o sheet como um portrait sheet.

Etapas necessárias para que se begin um sheet usando uma caixa:
Se o documento detector deste pdf state estiver ativo, begin o sheet usando a caixa (pdf style); exit.
Call "kernel32.dll" "GlobalLock" com o número identificador do modo de dispositivo da impressora devolvendo um pdevmode.
Se o pdevmode for inexistente, cancele.
Disjuncione logicamente o dmfields deste pdevmode usando 1 [dm_orientation].
Atribua 1 [dmorient_portrait] ao dmorientation deste pdevmode .
Se a largura desta caixa for maior do que a altura desta caixa, atribua 2 [dmorient_landscape] ao dmorientation deste pdevmode .
Call "gdi32.dll" "ResetDCA" com o printer canvas e o pdevmode.
Call "kernel32.dll" "GlobalUnlock" com o número identificador do modo de dispositivo da impressora.
Call "gdi32.dll" "SetGraphicsMode" com o printer canvas e 2 [gm_advanced].
Call "gdi32.dll" "SetBkMode" com o printer canvas e 1 [transparent].
Call "gdi32.dll" "SetMapMode" com o printer canvas e 8 [mm_anisotropic].
Call "gdi32.dll" "GetDeviceCaps" com o printer canvas e 112 [physicaloffsetx] devolvendo o número x desse pair.
Call "gdi32.dll" "GetDeviceCaps" com o printer canvas e 113 [physicaloffsety] devolvendo o número y deste pair.
Negate o pair.
Call "gdi32.dll" "SetViewportOrgEx" com o printer canvas e o número x deste pair e o número y deste pair e nil.
Call "gdi32.dll" "GetDeviceCaps" com o printer canvas e 88 [logpixelsx] devolvendo o número x deste pair.
Call "gdi32.dll" "GetDeviceCaps" com o printer canvas e 90 [logpixelsy] devolvendo o número y deste pair.
Call "gdi32.dll" "SetViewportExtEx" com o printer canvas e o número x deste pair e o número y deste pair e nil.
Call "gdi32.dll" "SetWindowOrgEx" com o printer canvas e 0 e 0 e nil.
Call "gdi32.dll" "SetWindowExtEx" com o printer canvas e o tpi e o tpi e nil.
Call "gdi32.dll" "StartPage" com o printer canvas.
Atribua o printer canvas ao quadro atual.
Call "gdi32.dll" "GetDeviceCaps" com o printer canvas e 88 [logpixelsx] devolvendo um número.
Atribua o tpp ao saved tpp.
Atribua o tpi dividido pelo número ao tpp.

Etapas necessárias para que se begin um sheet usando uma caixa (pdf style):
Begin o sheet usando a caixa e "" (pdf style).

Etapas necessárias para que se begin um sheet usando uma caixa e um title string:
Begin o sheet usando a caixa e o title (pdf style).

Etapas necessárias para que se begin um sheet usando uma caixa e um title string (pdf style - start o current página):
Adicione o current página deste pdf state usando "page".
Posponha o número desta current página deste pdf state seguido de " 0 obj" para o current página deste pdf state.
Posponha "<<" para o current página deste pdf state.
Posponha "/Type /Page" para o current página deste pdf state.
Posponha "/Parent " seguido de o número deste parent deste pdf state seguido de " 0 R" para o current página deste pdf state.
Atribua a largura desta caixa menos o tpp times 72 / o tpi a um largura.
Atribua a altura desta caixa menos o tpp times 72 / o tpi a uma altura.
Posponha "/MediaBox [0 0 " seguido de o largura seguido de " " seguido de o altura seguido de "]" para o current página deste pdf state.
Atribua a altura desta caixa menos o tpp ao current altura deste pdf state.
Adicione os current contents deste pdf state usando "contents".
Posponha "/Contents " seguido de o número destes current contents deste pdf state seguido de " 0 R" para o current página deste pdf state.
Posponha "0.05 0 0 0.05 1 1 cm" para os current contents deste pdf state. \ abra matrix para scale 72/1440
Posponha "13 w 0 J 0 j 0 i" para os current contents deste pdf state. \ pincelwidth, linecap, linejoin, flatness \ 15 w sobre pincelwidth comes out para wide

Etapas necessárias para que se begin um sheet usando uma caixa e um title string (pdf style):
Ligue a página detector deste pdf state.
Atribua a cor preta ao cor da borda atual deste pdf state.
Atribua a cor preta à cor de preenchimento atual deste pdf state.
Begin o sheet usando a caixa e o title (pdf style - start o current página).
Se o title estiver em branco, cancele.
Crie um pdf outline entry usando o title e o current altura deste pdf state e o número desta current página deste pdf state.
Posponha o pdf outline entry para o outline entries deste pdf state.

Etapas necessárias para que se begin um sheet usando um title string:
Begin um portrait sheet usando o title.

O Bíblia é uma coisa com uns verses.

Um verse é uma coisa com um string.

Um big-endian unsigned wyrd é um conjunto com 2 pedaços.

Um billion é 1000 millions.

Um código binário é um string.

An bit é uma unit.

Um bitmapdata é um conjunto com
Um largura,
Um altura,
Um número denominado stride,
Um número denominado pixelformat,
Um endereço de memória denominado scan0,
Um número denominado Reserved.

Etapas necessárias para que se conjuncione logicamente um pedaço com uma segunda pedaço:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $2003. \ e [ebx],al

Etapas necessárias para que se conjuncione logicamente um pedaço com um número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $2003. \ e [ebx],al

Etapas necessárias para que se conjuncione logicamente um número com uma segunda número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $2103. \ e [ebx],eax

Etapas necessárias para que se disjuncione logicamente um pedaço com uma segunda pedaço:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0803. \ ou [ebx],al

Etapas necessárias para que se disjuncione logicamente um pedaço com um número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0803. \ ou [ebx],al

Etapas necessárias para que se disjuncione logicamente um número com uma segunda número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ a segunda número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $0903. \ ou [ebx],eax

Etapas necessárias para que se disjuncione seletivamente um pedaço com uma segunda pedaço:
Intel $8B850C000000. \ mov eax,[ebp+12] \ a segunda byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $3003. \ xor [ebx],al

Etapas necessárias para que se disjuncione seletivamente um pedaço com um número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $3003. \ ou [ebx],al

Etapas necessárias para que se disjuncione seletivamente um número com uma segunda número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $3103. \ xor [ebx],eax

Uma caixa é um conjunto com
Uma coordenada esquerda , 
Uma coordenada superior, 
Uma coordenada direita, 
Uma coordenada inferior,
Um canto superior esquerdo spot at a coordenada esquerda , e 
Um canto inferior direito spot at a coordenada direita, e
Um topo-left spot at a coordenada esquerda , e um base-right spot at a coordenada direita. 

Um brilho é uma luminosidade.

Um contagem de buckets é uma contagem.

Um bucket é um endereço de memória para um conjunto de buckets.

Um conjunto de buckets é um conjunto com uns refers.

An bucket# é um número.

Um trecho é um string.

Etapas necessárias para que se avance um pedaço limiting it para uma segunda pedaço e um terceiro pedaço:
Adicione 1 para o pedaço.
Se o pedaço for maior do que o terceiro pedaço, atribua a segunda pedaço ao pedaço.

Etapas necessárias para que se avance um número:
Adicione 1 para o número.

Etapas necessárias para que se avance um número limiting it para uma segunda número e um terceiro número:
Adicione 1 para o número.
Se o número for maior do que o terceiro número, atribua a segunda número ao número.

Etapas necessárias para que se avance um percorredor:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ comando de movimentação do percorredor?
Intel $FF8314000000. \ inc [ebx+20] \ aumenta o valor do last deste vocábulo deste percorredor.
Intel $FF8308000000. \ inc [ebx+8] \ aumenta o valor do first deste source deste percorredor.

Etapas necessárias para que se recue um percorredor:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ comando de movimentação do percorredor?
Intel $FF8B14000000. \ dec [ebx+20] \ reduz o valor do last deste vocábulo deste percorredor.
Intel $FF8B08000000. \ dec [ebx+8] \ reduz o valor do first deste source deste percorredor.

Etapas necessárias para que se avance um percorredor por um número:
Adicione o número para o last deste vocábulo deste percorredor.
Adicione o número para o first deste source deste percorredor.

Etapas necessárias para que se buzz:
Call "kernel32.dll" "Beep" com 220 e 200.

Um quantidade de pedaços é uma contagem.

Um endereço de memória do pedaço é um endereço de memória para um pedaço.

An byte# é um número.

An canvas é um hdc. \ hdc = handle device context

Etapas necessárias para que se capitalize algum tipo de rows selecionadas em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Se a row estiver em branco, repita.
Capitalize o string deste row.
Repita.

Etapas necessárias para que se capitalize um string:
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto não for irrelevante, pare.
Adicione 1 para o first deste subtexto.
Repita.
Uppercase o target deste first deste subtexto.

Etapas necessárias para que se capitalize um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from os rows deste text.
Se a row for inexistente, pare.
Capitalize o string deste row.
Repita.
Wrap o text.

Um caret é um position.

Etapas necessárias para que se centralize uma caixa at o base of uma segunda caixa:
Centralize a caixa no segunda caixa (horizontalmente).
Atribua a altura desta caixa a uma altura.
Atribua a coordenada inferior desta segunda caixa à coordenada inferior desta caixa.
Atribua a coordenada inferior desta caixa menos o altura à coordenada superior desta caixa.

Etapas necessárias para que se centralize uma caixa em uma segunda caixa (horizontalmente):
Atribua a coordenada x deste center desta segunda caixa menos a coordenada x deste center desta caixa a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova a caixa usando o número e 0.

Etapas necessárias para que se centralize uma caixa em uma segunda caixa (verticalmente):
Atribua a coordenada y deste center desta segunda caixa menos a coordenada y deste center desta caixa a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova a caixa usando 0 e o número.

Etapas necessárias para que se centralize um dot sobre o current spot:
\ need Spanish palavra por "dot"
Centralize o dot sobre o spot deste context.

Etapas necessárias para que se centralize um elipse em uma caixa (horizontalmente):
Centralize a caixa desta elipse na caixa (horizontalmente).

Etapas necessárias para que se centralize um elipse em uma caixa (verticalmente):
Centralize a caixa desta elipse na caixa (verticalmente).

Etapas necessárias para que se centralize um line em uma caixa (horizontalmente):
Atribua o x deste center desta caixa menos o x deste center desta line a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o line usando o número e 0.

Etapas necessárias para que se centralize um line em uma caixa (verticalmente):
Atribua o y deste center desta caixa menos o y deste center desta line a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o line usando 0 e o número.

Etapas necessárias para que se centralize um picture em uma caixa (horizontalmente):
Se o picture for inexistente, cancele.
Atribua a coordenada x deste center desta caixa menos a coordenada x deste center desta caixa desta picture a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o picture usando o número e 0.

Etapas necessárias para que se centralize um picture em uma caixa (verticalmente):
Se o picture for inexistente, cancele.
Atribua a coordenada y deste center desta caixa menos a coordenada y deste center desta caixa desta picture a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o picture usando 0 e o número.

Etapas necessárias para que se centralize um polígono em uma caixa (horizontalmente):
Se o polígono for inexistente, cancele.
Atribua o x deste center desta caixa menos o x deste center desta caixa deste polígono a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o polígono usando o número e 0.

Etapas necessárias para que se centralize um polígono em uma caixa (verticalmente):
Se o polígono for inexistente, cancele.
Atribua o y deste center desta caixa menos o y deste center desta caixa deste polígono a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o polígono usando 0 e o número.

Etapas necessárias para que se centralize um spot em uma caixa (horizontalmente):
Atribua o x deste center desta caixa menos a coordenada x deste spot a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o spot usando o número e 0.

Etapas necessárias para que se centralize um spot em uma caixa (verticalmente):
Atribua o y deste center desta caixa menos a coordenada y deste spot a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o spot usando 0 e o número.

Etapas necessárias para que se centralize um text em uma caixa (horizontalmente):
Se o text for inexistente, cancele.
Atribua o x deste center desta caixa menos o x deste center desta caixa deste text a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o text usando o número e 0.

Etapas necessárias para que se centralize um text em uma caixa (verticalmente):
Se o text for inexistente, cancele.
Atribua o y deste center desta caixa menos o y deste center desta caixa deste text a um número.
Arredonde o número para o múltiplo imediato of o tpp.
Mova o text usando 0 e o número.

Etapas necessárias para que se modifique o current matiz por uns points;
Etapas necessárias para que se altere o current matiz por uns points;
Etapas necessárias para que se mude o current matiz por uns points:
Mude a matiz deste context por os points.

Etapas necessárias para que se modifique um matiz por uns points;
Etapas necessárias para que se altere um matiz por uns points;
Etapas necessárias para que se mude um matiz por uns points:
Adicione o points para o matiz.

Etapas necessárias para que se modifique uma caixa arredondada usando um raio;
Etapas necessárias para que se altere uma caixa arredondada usando um raio;
Etapas necessárias para que se mude uma caixa arredondada usando um raio:
Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se modifique um text usando uma caixa;
Etapas necessárias para que se altere um text usando uma caixa;
Etapas necessárias para que se mude um text usando uma caixa:
Se o text for inexistente, cancele.
Atribua a caixa à caixa deste text.
Wrap o text.

Etapas necessárias para que se modifique um text usando uma altura da fonte;
Etapas necessárias para que se altere um text usando uma altura da fonte;
Etapas necessárias para que se mude um text usando uma altura da fonte:
Se o text for inexistente, cancele.
Subtraia a margin deste text from a coordenada x deste text.
Atribua a origin deste text dividido pela grid deste text a um pair.
Atribua o altura da fonte à altura desta font deste text.
Redimensione proporcionalmente a altura desta font deste text usando a scale deste text.
Atribua o pair times a grid deste text à origin deste text.
Adicione a margin deste text para a coordenada x deste text.
Limite o origin of o text.
Wrap o text.

Etapas necessárias para que se modifique um text usando uma nome da fonte;
Etapas necessárias para que se altere um text usando uma nome da fonte;
Etapas necessárias para que se mude um text usando uma nome da fonte:
Se o text for inexistente, cancele.
Atribua o nome da fonte ao nome desta font deste text.
Wrap o text.

Um character é um pedaço.

Uma choice é uma coisa com um nome e uma caixa.

As choices são umas choices.

Etapas necessárias para que se limpe uma caixa:
Atribua 0 e 0 e 0 e 0 ao caixa. \ caderno depends sobre this

Etapas necessárias para que se limpe um pedaço:
Atribua o null pedaço ao pedaço.

Etapas necessárias para que se limpe uma cor:
Atribua 0 e 0 e 0 à cor.

Etapas necessárias para que se limpe um elipse:
Limpe a caixa desta elipse.

Etapas necessárias para que se desative um detector;
Etapas necessárias para que se desligue um detector:
Atribua 0 ao detector. \ was "Atribua no ao detector." Value of "no" inherited from o CAL-1000 according para Dan.

Etapas necessárias para que se limpe um font:
Atribua "" e 0 ao font.

Etapas necessárias para que se limpe um fração:
Atribua 0 e 1 à fração.

Etapas necessárias para que se limpe um ip address:
Limpe o número deste ip address.
Limpe o string deste ip address.

Etapas necessárias para que se limpe um line:
Limpe o start desta line.
Limpe o end desta line.

Etapas necessárias para que se limpe um número:
Atribua 0 ao número.

Etapas necessárias para que se limpe um pair:
Atribua 0 e 0 ao pair.

Etapas necessárias para que se limpe um percorredor:
Limpe o original deste percorredor.
Limpe o source deste percorredor.
Limpe o vocábulo deste percorredor.

Etapas necessárias para que se erase o tela;
Etapas necessárias para que se branqueie o tela;
Etapas necessárias para que se apague o tela;
Etapas necessárias para que se limpe o tela:
Mostre tudo.
Pinte a caixa desta tela com a cor preta e a cor preta.
Atualize o tela.
Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe o tela para uma cor:
Mostre tudo.
Pinte a caixa desta tela com a cor e a cor.
Atualize o tela.
Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe o tela para white:
\ \ needs special handling
Mostre tudo.
Pinte a caixa desta tela com a cor branca e a cor branca.
Atualize o tela.
Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe o tela sem atualizá-la:
Mostre tudo.
Pinte a caixa desta tela com a cor preta e a cor preta.
Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe um seleção:
Limpe o anchor desta seleção.
Limpe o caret desta seleção.

Etapas necessárias para que se limpe o stack:
\ stack needs work
Destrua o stack.

Etapas necessárias para que se limpe um string:
Unassign o first desta string.
Esvazie o last deste string.

Etapas necessárias para que se limpe um subtexto:
Esvazie o first deste subtexto.
Esvazie o last deste subtexto.

Etapas necessárias para que se limpe um terminal:
Destrua os quoras deste terminal.

Etapas necessárias para que se limpe uns coisas:
Esvazie o first destas coisas.
Esvazie o last destas coisas.

Etapas necessárias para que se limpe um wyrd:
Atribua 0 ao wyrd.

Etapas necessárias para que se close um file:
Call "kernel32.dll" "CloseHandle" com o file.

Um clsid é um uuid.

Etapas necessárias para que se avise:
Toque o som de aviso.

O som de aviso é um wave igual a $524946463A02000057415645666D74201200000001000100401F0000401F000001000800000066616374040000000702000064617461070200007F7F807F7F807F7F808080807F807F7F80817F81817E7E827E7D847C79877D5F6D99B2A25D608269A5979869667F7D8D738C7D8C5E7E878F767A75868D84797278829A7D7E857A73929271657492907D7E7D787E8B887C758388827E817F7C7B89897C7A7E84838183827E7A8488877D7E8181808484817C7F84838181807E7F8283807E8081808182807F7F81818081807F7F8081818080807F7F808180807F80808080807F8080807F8080808080807F7F7F7F7F8080807F7F7F7C7B8182817C7B7D7E8082807D7D7C7F8281807F7C7D808082807E7E7E7D7E807D7B7C7B7D7D7B7A7979797875727269797A490F4571FFF4FF0C001297FBF492525BB0F5B26A001C69BEE5BA76476F9EBD953C3757BAC9BB705C7F9AA883645D7897AA9B806977959588696976999B83766F828C907F7375828E91877B757D868B837A757C858D8880787B8187847B7A7D8788807B79808486817D7C7F8384817D7C7F8484817B7B7D83847F7C7B7E8182827D7C7C8082817D7C7D7F81807F7D7D7F82817F7B7B7E8081807E7D7D7F80807E7D7D7E80807E7D7D7E7F807F7D7D7E7F807F7E7D7E7E80807F7E7D7E80807F7E7E7E7F7F7E7E7E7F7F7F7F7E7E7F7F807F7F7E7E7E7F8080807E7E7E80807F7E7E7F8081807F7F7E7F7F80807F7E7F8081807F7E7E7E80808080807F807F7F7F7F7F7F7F80808080807F7F7F808080807F80808180807F80808100.

Um column# é um número.

Etapas necessárias para que se compare um string para uma segunda string usando um quantidade de caracteres e uma segunda quantidade de caracteres e uma tabela de tradução (equal only):
Intel $8BB508000000. \ mov esi,[ebp+8] \ o string
Intel $8B36. \ mov esi,[esi] \ o first deste string
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda string
Intel $8B3F. \ mov edi,[edi] \ o first deste segunda string
Intel $8B8510000000. \ mov eax,[ebp+16] \ o quantidade de caracteres deste string
Intel $8B00. \ mov eax,[eax]
Intel $8B9514000000. \ mov edx,[ebp+20] \ o quantidade de caracteres deste segunda string
Intel $8B12. \ mov edx,[edx]
Intel $3BD0. \ cmp eax,edx \ if o differ do quantidade de caracteres, diga não.
Intel $0F852B000000. \ jne Diga não. \ ************************************ was 2C
Intel $8BC8. \ mov ecx,eax \ atribua quantidade de caracteres A ecx 
Intel $8B9D18000000. \ mov ebx,[ebp+24] \ o tabela de tradução
Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
\ loop:
Intel $85C9. \ test ecx,ecx
Intel $0F8424000000. \ jz say yes \ ************************************ was 25
 \ fetch e translate o current pedaço no segunda string
Intel $8A07. \ mov al,[edi]
Intel $D7. \ xlat al,[ebx]
Intel $C1E008. \ shl eax,8 C1 E0 08
\ fetch e translate o current pedaço no string
Intel $8A06. \ mov al,[esi]
Intel $D7. \ xlat al,[ebx]
 \ compare o two translated pedaços
Intel $38E0. \ cmp al,ah
Intel $0F8508000000. \ jne Diga não. \ ************************************
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $E9DFFFFFFF. \ jmp loop \ ************************************ was DE
\Diga não.:
Intel $C7C000000000. \ mov eax,0
Intel $E906000000. \ jmp end
\SAY YES:
Intel $C7C001000000. \ mov eax,1

\ dahn - spanish strings 2 - which table para use?
Etapas necessárias para que se compare um string para uma segunda string usando um quantidade de caracteres e uma segunda quantidade de caracteres devolvendo um número:
Compare o string para a segunda string usando o quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos ascii devolvendo o número.
\Compare o string para a segunda string usando o quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos s/ acento ascii devolvendo o número.

Etapas necessárias para que se compare um string para uma segunda string usando um quantidade de caracteres e uma segunda quantidade de caracteres e uma tabela de tradução devolvendo um número:
Intel $8BB508000000. \ mov esi,[ebp+8] \ o string
Intel $8B36. \ mov esi,[esi] \ o first do string
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda string
Intel $8B3F. \ mov edi,[edi] \ o first do segunda string
Intel $8B8510000000. \ mov eax,[ebp+16] \ o quantidade de caracteres do string
Intel $8B00. \ mov eax,[eax]
Intel $8B9514000000. \ mov edx,[ebp+20] \ o quantidade de caracteres do segunda string
Intel $8B12. \ mov edx,[edx]
Intel $8B9D18000000. \ mov ebx,[ebp+24] \ o tabela de tradução
Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
\ obtenha o minimum quantidade de caracteres
Intel $8BC8. \ mov ecx,eax
Intel $3BCA. \ cmp ecx,edx
Intel $0F8602000000. \ jbe L2
Intel $8BCA. \ mov ecx,edx
\ if o minimum quantidade de caracteres for 0, jump para L5
Intel $85C9. \ test ecx,ecx
Intel $0F8428000000. \ jz L5
\L2:
\ loop:
\ fetch e translate o current pedaço no string
Intel $8A06. \ mov al,[esi]
Intel $D7. \ xlat al,[ebx]
Intel $88C2. \ mov dl,al
\ fetch e translate o current pedaço no segunda string
Intel $8A07. \ mov al,[edi]
Intel $D7. \ xlat al,[ebx]
Intel $88C6. \ mov dh,al
\L3:
\ compare o two translated pedaços
Intel $38F2. \ cmp dl,dh
Intel $0F8510000000. \ jne L4
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $85C9. \ test ecx,ecx
Intel $0F8405000000. \ jz L4
Intel $E9DEFFFFFF. \ jmp L2
\L4:
\ Carregue pedaços para EAX e edx por final compare
Intel $0FB6C2. \ movzx eax,dl
Intel $0FB6D6. \ movzx edx,dh
\L5:
\ subtraia either o lengths ou os last dois pedaços para abra o eax para <0, =0, >0
Intel $2BC2. \ sub eax,edx
Intel $8B9D1C000000. \ mov ebx,[ebp+28] \ o número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se compativelmente handle algum tipo de message com um window um message número um w-param e um l-param:
Se o message for 006, execute algum tipo de wm-activate com o w-param; atribua 0 para EAX; exit.
Se o message for 258, execute algum tipo de wm-char com o w-param e o l-param; atribua 0 para EAX; exit.
Se o message for 001, execute algum tipo de wm-create com o window; atribua 0 para EAX; exit.
Se o message for 002, execute algum tipo de wm-destroy; atribua 0 para EAX; exit.
Se o message for 256, execute algum tipo de wm-keydown com o w-param e o l-param; atribua 0 para EAX; exit.
Se o message for 513, execute algum tipo de wm-lbuttondown com o l-param; atribua 0 para EAX; exit.
Se o message for 515, execute algum tipo de wm-lbuttondblclk com o l-param; atribua 0 para EAX; exit.
Se o message for 015, execute algum tipo de wm-paint com o window; atribua 0 para EAX; exit.
Se o message for 516, execute algum tipo de wm-rbuttondown com o l-param; atribua 0 para EAX; exit.
Se o message for 518, execute algum tipo de wm-rbuttondblclk com o l-param; atribua 0 para EAX; exit.
Se o message for 032, execute algum tipo de wm-setcursor; atribua 1 para EAX; exit.
Se o message for 260, execute algum tipo de wm-syskeydown com o w-param e o l-param; atribua 0 para EAX; exit.
Call "user32.dll" "DefWindowProcA" com o window e o message e o w-param e o l-param.

Etapas necessárias para que se compativelmente aguarde por um process endereço de memória:
Call "kernel32.dll" "WaitForSingleObject" com o target deste process endereço de memória e -1 [infinite].
Call "kernel32.dll" "CloseHandle" com o target deste process endereço de memória.
Atribua 0 ao target deste process endereço de memória.
Call "user32.dll" "GetForegroundWindow" devolvendo um window.
Se o window é o main window, atribua 0 para EAX; exit.
Call "user32.dll" "ShowWindow" com o main window e 6 [sw_minimize].
Call "user32.dll" "ShowWindow" com o main window e 9 [sw_restore].
Atribua 0 para EAX. \ abra return value of thread

\Um console é uma coisa com 
\a caixa,
\a cor da borda,
\a cor de preenchimento,
\a text,
\a grid,
\a reply string.

Um console é uma coisa com 
Um caixa, 
Um cor da borda,
Um cor de preenchimento, 
Um text, 
Um grid, 
Um reply string.

O context é um context.

An context é uma coisa com um spot, uma caixa, uma orientação, um tamanho da letra, uma cor, um número, um grossura do pincel,\ pincel largura? ***
and um letra size at o tamanho da letra, e um pincel at a cor.
\REMARK: O "grossura do pincel" não estava no context conjunto, but it deveria be.
\I will be adding it para o next version of o CAL context, e now might be a good time for you para adicione it para o PAL context conjunto.

O context stack é uns contexts.

Etapas necessárias para que se converta um posicionamento absoluto para uma position usando um text:
Se o text for inexistente, limpe o position; exit.
Isole o posicionamento absoluto.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, limpe o position; exit.
Atribua o número da linha desta row ao número da linha desta position.
Atribua o posicionamento absoluto ao column# desta position.
Subtraia o quantidade de caracteres deste string desta row from o posicionamento absoluto.
Se o posicionamento absoluto for menor do que 1, cancele.
Repita.

Etapas necessárias para que se converta um código binário Para um número:
Atribua 0 ao número.
Atribua 1 a um value número.
Percorra.
Se o código binário estiver em branco, cancele.
Obtenha um character from o código binário (backwards). \ was backwards
Se o character for "1", adicione o value para o número.
Double o value.
Repita.

Etapas necessárias para que se converta uma caixa para um string:
Limpe o string.
Posponha a coordenada esquerda desta caixa para o string.
Posponha " " para o string.
Posponha a coordenada superior desta caixa para o string.
Posponha " " para o string.
Posponha a coordenada direita desta caixa para o string.
Posponha " " para o string.
Posponha a coordenada inferior desta caixa para o string.

Etapas necessárias para que se converta um pedaço para uma cifra binária:
Atribua o pedaço à cifra binária como um pedaço.
Uppercase a cifra binária.
Se a cifra binária for maior do que o número nove, subtraia 7 from a cifra binária.
Subtraia 48 from a cifra binária.

Etapas necessárias para que se converta um pedaço para um cifra hexadecimal:
Split o pedaço a uma cifra binária e uma segunda cifra binária.
Converta a cifra binária para o cifra hexadecimal.
Converta a segunda cifra binária para uma segunda cifra hexadecimal.
Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Etapas necessárias para que se converta um pedaço para um query pedaço:
Se o pedaço estiver entre 48 e 57, atribua o pedaço ao query pedaço; exit. \ 0-9
Se o pedaço estiver entre 65 e 90, atribua o pedaço ao query pedaço; exit. \ A-Z
Se o pedaço estiver entre 97 e 122, atribua o pedaço ao query pedaço; exit. \ a-z
Se o pedaço for 32, atribua "+" ao query pedaço; exit. \ space
Converta o pedaço para um cifra hexadecimal.
Atribua "%" seguido de o cifra hexadecimal ao query pedaço.

Etapas necessárias para que se converta uma cor para um código da cor:
Se a cor estiver clear, atribua 16777215 [$00FFFFFF] ao código da cor; exit. \ pincel preto becomes white
Isole a cor.
Redimensione proporcionalmente a saturação desta cor usando 240/1000.
Limite a saturação desta cor para 1 e 239.
Redimensione proporcionalmente a luminosidade desta cor usando 240/1000.
Limite a luminosidade desta cor para 1 e 239.
Redimensione proporcionalmente a matiz desta cor usando 240/3600.
Limite a matiz desta cor para 1 e 239.
Call "shlwapi.dll" "ColorHLSToRGB" com a matiz desta cor e a luminosidade desta cor e a saturação desta cor devolvendo o código da cor.

Etapas necessárias para que se converta uma cor para um espaço de cor RGB:
Converta a cor para um código da cor.
Converta o código da cor para o espaço de cor RGB.

Etapas necessárias para que se converta um código da cor para uma cor:
Call "shlwapi.dll" "ColorRGBToHLS" com o código da cor e um endereçamento desse wyrd e uma segunda endereçamento desse wyrd e um terceiro endereçamento deste wyrd.
Atribua o wyrd à matiz desta cor.
Atribua a segunda wyrd à luminosidade desta cor.
Atribua o terceiro wyrd à saturação desta cor.
Redimensione proporcionalmente a matiz desta cor usando 3600/240.
Limite a matiz desta cor para 0 e 3600.
Redimensione proporcionalmente a saturação desta cor usando 1000/240.
Limite a saturação desta cor para 0 e 1000.
Redimensione proporcionalmente a luminosidade desta cor usando 1000/240.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se converta um código da cor para um espaço de cor RGB:
Isole o código da cor.
Shift o código da cor right 0 bits.
Atribua o código da cor ao espectro vermelho deste espaço de cor RGB.
Shift o código da cor right 8 bits.
Atribua o código da cor ao espectro verde deste espaço de cor RGB.
Shift o código da cor right 8 bits.
Atribua o código da cor ao espectro azul deste espaço de cor RGB.

Etapas necessárias para que se converta um filetime para um string:
Limpe o string.
Call "kernel32.dll" "FileTimeToSystemTime" com o endereçamento deste filetime e o endereçamento desse systemtime devolvendo um número.
Se o número for 0, cancele.
Atribua o wyear deste systemtime ao year desse date/time.
Atribua o wmonth deste systemtime ao month deste date/time.
Atribua o wdayofweek deste systemtime ao week day deste date/time.
Atribua o wday deste systemtime ao day deste date/time.
Atribua o whour deste systemtime à hour deste date/time.
Atribua o wminute deste systemtime ao minute deste date/time.
Atribua o wsecond deste systemtime ao second deste date/time.
Atribua os wmilliseconds deste systemtime ao millisecond deste date/time.
Atribua o string deste date/time ao string.

Etapas necessárias para que se converta um detector para um texto hexadecimal:
Reassign o first deste texto hexadecimal usando a magnitude deste detector.
Copie pedaços from o endereçamento deste detector para o first deste texto hexadecimal pela magnitude deste detector.
Atribua o first deste texto hexadecimal mais a magnitude deste detector menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se converta uma font para um número da fonte:
Isole o font.
Modifique através do caractere NUL o nome desta font.
Call "gdi32.dll" "CreateFontA" com - a altura desta font times 3 dividido por 4 e 0 e 0 e 0 e 0 e 0 e 0 e 0 
And 1 [default_charset] e 0 e 0 e 5 [cleartype_quality] e 4 [truetype_fonttype] e o first deste nome desta font devolvendo o número da fonte.

Etapas necessárias para que se converta uma font info para pdf em units:
Se o font info for inexistente, cancele.
Converta o internal leading desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Converta o ascent desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Converta o descent desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Converta o capheight desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
\ converta o italicangle desta font info para pdf em units usando o emsquare desta font info e o font desta font info. \não sei porque está comentado
Converta o stemv desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Converta a coordenada esquerda desta font caixa desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Converta a coordenada superior desta font caixa desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Converta a coordenada direita desta font caixa desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Converta a coordenada inferior desta font caixa desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Permute a coordenada superior desta font caixa desta font info com a coordenada inferior desta font caixa desta font info.
Converta as font larguras desta font info para pdf em units.

Etapas necessárias para que se converta umas font larguras para pdf em units:
Obtenha um outlinetextmetric usando a font destas font larguras.
Atribua os data desta font larguras a um endereço numérico.
Percorra.
Se um contador é past a contagem destas font larguras, pare.
Converta o target deste endereço numérico para pdf em units usando o otmemsquare deste outlinetextmetric e a font destas font larguras.
Adicione a magnitude desse número para o endereço numérico.
Repita.

Etapas necessárias para que se converta uma fração para um texto hexadecimal:
Reassign o first deste texto hexadecimal usando a magnitude desta fração.
Copie pedaços from o endereçamento desta fração para o first deste texto hexadecimal pela magnitude desta fração.
Atribua o first deste texto hexadecimal mais a magnitude desta fração menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se converta uma fração para um mixed:
Se o denominador desta fração for 0, atribua 0 ao whole número deste mixed; atribua 0 ao ratio deste mixed; exit.
Divida o numerador desta fração pelo denominador desta fração usando o whole número deste mixed e um resto.
Atribua o resto e o denominador desta fração ao fração deste mixed.

Etapas necessárias para que se converta uma fração para um string usando um número:
\ converts para um decimal representation com "the número" of places
Limpe o string.
Se o número for menor do que 1, cancele.
Atribua 10 a um value número.
Raise o value para o número.
Isole a fração.
Se a fração for negative, acione um detector; de-sign a fração.
Multiplique o value pela fração.
Zero fill o value usando o número e posponha it para o string.
Atribua o quantidade de caracteres deste string menos o número mais 1 a um byte#.
Insira "." ao string antes de o byte#.
Se o target deste first deste string é o ponto final, anteponha "0" para o string.
Se o detector estiver ativo, anteponha "-" para o string.

Etapas necessárias para que se converta um gpbitmap para um trecho (pdf style):
Limpe o trecho.
Se o gpbitmap for inexistente, cancele.
Lock o gpbitmap usando um bitmapdata (24-bit espaço de cor RGB).
Atribua 1 a um número da linha.
Atribua 1 a um column#.
Percorra.
Se o column# for maior do que o largura deste bitmapdata, atribua 1 ao column#; adicione 1 para o número da linha.
Se o número da linha for maior do que a altura deste bitmapdata, pare.
Obtenha um endereço de memória RGB from o bitmapdata at o número da linha e o column#.
Posponha o espectro vermelho deste endereço de memória RGB para o trecho.
Posponha o espectro verde deste endereço de memória RGB para o trecho.
Posponha o espectro azul deste endereço de memória RGB para o trecho.
Adicione 1 para o column#.
Repita.
Unlock o gpbitmap usando o bitmapdata.

Etapas necessárias para que se converta um texto hexadecimal para um fração:
Se o quantidade de caracteres deste texto hexadecimal não for a magnitude desta fração, atribua 0 e 1 ao ratio; exit.
Copie pedaços from o first deste texto hexadecimal para o endereçamento desta fração pela magnitude desta fração.

Etapas necessárias para que se converta um texto hexadecimal para um número:
Se o quantidade de caracteres deste texto hexadecimal não for a magnitude deste número, limpe o número; exit.
Copie pedaços from o first deste texto hexadecimal para o endereçamento destte número pela magnitude deste número.

Etapas necessárias para que se converta um l-param para um tecla:
\ assumes l-param from wm_char message
Atribua o l-param à tecla.
Shift a tecla right 16 bits.
Conjuncione logicamente a tecla com 255.
Call "user32.dll" "MapVirtualKeyA" com a tecla e 1 devolvendo a tecla.
Se o numlock tecla was not toggled, cancele.
Se a tecla for a tecla Insert, atribua o numpad-tecla zero à tecla; exit.
Se a tecla for a tecla Delete, atribua o numpad-period tecla à tecla; exit.
Se a tecla for a tecla Home, atribua o numpad-tecla sete à tecla; exit.
Se a tecla for a tecla End, atribua o numpad-one tecla à tecla; exit.
Se a tecla for a tecla PgUp, atribua o numpad-tecla nove à tecla; exit.
Se a tecla for a tecla PgDn, atribua o numpad-tecla três à tecla; exit.
Se a tecla for a left-arrow tecla, atribua o numpad-tecla quatro à tecla; exit.
Se a tecla for a seta pra cima, atribua o numpad-tecla oito à tecla; exit.
Se a tecla for a right-arrow tecla, atribua o numpad-tecla seis à tecla; exit.
Se a tecla for a seta pra baixo, atribua o numpad-tecla dois à tecla; exit.
Se a tecla for a tecla Clear, atribua o numpad-tecla cinco à tecla; exit.

Etapas necessárias para que se converta um l-param para um spot:
Split o l-param a um wyrd e uma segunda wyrd.
Atribua o wyrd à coordenada y deste spot.
Atribua a segunda wyrd à coordenada x deste spot.
Multiplique o spot pelo tpp.

Etapas necessárias para que se converta um mixed para um fração:
Atribua o fração deste mixed à fração.
Adicione o whole número deste mixed times o denominador desta fração para o numerador desta fração.

Etapas necessárias para que se converta uma cifra binária para um cifra hexadecimal:
Isole a cifra binária.
Se a cifra binária for maior do que 9, adicione 7 para a cifra binária.
Adicione 48 para a cifra binária.
Atribua a cifra binária ao cifra hexadecimal.

Etapas necessárias para que se converta um cifra hexadecimal para um texto hexadecimal:
Isole o cifra hexadecimal.
Limpe o texto hexadecimal.
Se o quantidade de caracteres deste cifra hexadecimal for ímpar, anteponha o número zero para o cifra hexadecimal.
Lance um subtexto sobre o cifra hexadecimal.
Percorra.
Se o subtexto estiver em branco, cancele.
Converta o target deste first deste subtexto para uma cifra binária.
Shift a cifra binária left 4 bits.
Adicione 1 para o first deste subtexto.
Converta o target deste first deste subtexto para uma segunda cifra binária.
Disjuncione logicamente a cifra binária com a segunda cifra binária.
Posponha a cifra binária para o texto hexadecimal.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se converta um número para um pedaço:
Atribua o número ao pedaço.

Etapas necessárias para que se converta um número para pdf em units usando um emsquare número e um font:
Multiplique o número pelo emsquare / a adjusted altura desta font.
Multiplique o número por 1000 / o emsquare.

Etapas necessárias para que se converta um pchar para um string:
Limpe o string.
Se o pchar for inexistente, cancele.
Isole o pchar.
Percorra.
Se o target deste pchar for o null pedaço, cancele.
Posponha o target deste pchar para o string.
Adicione 1 para o pchar.
Repita.

Etapas necessárias para que se converta um endereço de memória e um quantidade de caracteres para um string:
Limpe o string.
Se o endereço de memória for inexistente, cancele.
Se o quantidade de caracteres for 0, cancele.
Reassign o first deste string usando o quantidade de caracteres.
Copie pedaços from o endereço de memória para o first deste string pelo quantidade de caracteres.
Atribua o first deste string mais o quantidade de caracteres menos 1 ao last deste string.

Etapas necessárias para que se converta um endereço de memória para um texto hexadecimal;
Etapas necessárias para que se converta um número para um texto hexadecimal:
Reassign o first deste texto hexadecimal usando a magnitude deste número.
Copie pedaços from o endereçamento deste número para o first deste texto hexadecimal pela magnitude deste número.
Atribua o first deste texto hexadecimal mais a magnitude deste número menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se converta um endereço de memória para um cifra hexadecimal;
Etapas necessárias para que se converta um número para um cifra hexadecimal:
Split o número a um wyrd e uma segunda wyrd.
Converta o wyrd para o cifra hexadecimal.
Converta a segunda wyrd para uma segunda cifra hexadecimal.
Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Etapas necessárias para que se converta um endereço de memória para um string:
Converta o endereço de memória para o string como um cifra hexadecimal.

Etapas necessárias para que se converta uns points para uns precise degrees:
Atribua o points times 3840 dividido por 3600 ao precise degrees.

Etapas necessárias para que se converta uma position para um posicionamento absoluto usando um text:
Se o text for inexistente, limpe o posicionamento absoluto; exit.
Atribua 0 ao posicionamento absoluto.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se o número da linha desta row for menor do que o número da linha desta position, adicione o quantidade de caracteres deste string desta row para o posicionamento absoluto; repita.
Adicione o column# desta position para o posicionamento absoluto.

Etapas necessárias para que se converta uns precise degrees para uns points:
Atribua os precise degrees times 3600 dividido por 3840 ao points.

Etapas necessárias para que se converta um query string para um string:
Limpe o string.
Se o query string estiver em branco, cancele.
Lance um subtexto sobre o query string.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for o sinal de adição, posponha " " para o string; adicione 1 para o first deste subtexto; repita.
Se o target deste first deste subtexto não for o sinal de porcentagem, posponha o target deste first deste subtexto para o string; adicione 1 para o first deste subtexto; repita.
Se o quantidade de caracteres deste subtexto for menor do que 3, cancele.
Adicione 1 para o first deste subtexto.
Converta o target deste first deste subtexto para uma cifra binária.
Shift a cifra binária left 4 bits.
Adicione 1 para o first deste subtexto.
Converta o target deste first deste subtexto para uma segunda cifra binária.
Disjuncione logicamente a cifra binária com a segunda cifra binária.
Adicione 1 para o first deste subtexto.
Posponha a cifra binária para o string.
Repita.

Etapas necessárias para que se converta uns rows para um string:
Limpe o string.
Percorra.
Obtenha uma row from a rows.
Se a row for inexistente, cancele.
Posponha o string deste row para o string.
Se o target deste last deste string é o return pedaço, posponha o linefeed pedaço para o string; repita.
Repita.

Etapas necessárias para que se converta uns rows para um string (no linefeed additions):
Limpe o string.
Percorra.
Obtenha uma row from a rows.
Se a row for inexistente, cancele.
Posponha o string deste row para o string.
Repita.

Etapas necessárias para que se converta um string e um actual font info e um original font info Para um trecho por pdf output:
Limpe o trecho.
Atribua 0 a um current byte#.
Lance um subtexto sobre o first pedaço of o string.
Percorra.
Se o first deste subtexto for maior do que o last deste string, pare.
Se o last deste subtexto é o last deste string, pare.
Obtenha um current largura usando o current byte# e as font larguras desta actual font info.
Obtenha um original largura usando o target deste last deste subtexto e o font larguras desta original font info.
Atribua o original largura menos o current largura a um offset.
Se o offset for 0, adicione 1 para o last deste subtexto; adicione 1 para o current byte#; repita.
Converta o subtexto para um pdf string.
Posponha o pdf string seguido de " " seguido de o offset seguido de " " para o trecho.
Atribua o last deste subtexto mais 1 ao last deste subtexto.
Atribua o last deste subtexto ao first deste subtexto.
Adicione 1 para o current byte#.
Repita.
Se o first deste subtexto for maior do que o last deste string, cancele.
Converta o subtexto para uma segunda pdf string.
Posponha a segunda pdf string para o trecho.

Etapas necessárias para que se converta um string para um detector:
Se o string for "sí", acione o detector; exit.
Se o string for "s", acione o detector; exit.
Se o string for "sim", acione o detector; exit.
Se o string for "y", acione o detector; exit.
Se o string for "yes", acione o detector; exit.
[Se o texto não informado não for nenhuma dessas opções, então:] Desative o detector.

Etapas necessárias para que se converta um string para um fração:
Limpe a fração.
Se o string estiver em branco, cancele.
Se o string for algum tipo de integer, converta o string para o numerador desta fração; exit.
Lance um subtexto sobre o string.
Se o target deste first deste subtexto for algum tipo de sign, adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, cancele.
Split o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
Se o integer subtexto estiver em branco, atribua o subtexto à fração subtexto.
Split a fração subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
Converta o integer subtexto para um whole número.
Converta o numerador subtexto para um numerador número.
Converta o denominador subtexto para um denominador número.
Se o whole número é negative, cancele.
Se o numerador número é negative, cancele.
Se o denominador número é negative, cancele.
Se o denominador número for 0, cancele.
Se o whole número não for 0, adicione o denominador número times o whole número para o numerador número.
Atribua o numerador número ao numerador desta fração.
Atribua o denominador número ao denominador desta fração.
Se o target deste first deste string é o hífem, negate a fração.

Etapas necessárias para que se converta um string para um cifra hexadecimal:
Limpe o cifra hexadecimal.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Converta o target deste first deste subtexto para uma segunda cifra hexadecimal.
Posponha a segunda cifra hexadecimal para o cifra hexadecimal.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se converta um string para um número:
Atribua 0 ao número.
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for algum tipo de sign, adicione 1 para o first deste subtexto.
Percorra.
Se o subtexto estiver em branco, pare.
Multiplique o número por 10.
Atribua o target deste first deste subtexto a uma segunda número.
Subtraia 48 from a segunda número.
Adicione a segunda número para o número.
Adicione 1 para o first deste subtexto.
Repita.
Se o target deste first deste string é o hífem, negate o número.

Etapas necessárias para que se converta um string para um número between uma segunda número e um terceiro número:
Converta o string para o número.
Limite o número para a segunda número e o terceiro número.

Etapas necessárias para que se converta um string para um pdf string:
Atribua "(" ao pdf string.
Lance um subtexto sobre o string.
Subtraia 1 from o first deste subtexto.
Percorra.
Adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, pare.
Se o target deste first deste subtexto for o parênteses esquerdo, posponha "\(" para o pdf string; repita.
Se o target deste first deste subtexto for o parênteses direito, posponha "\)" para o pdf string; repita.
Se o target deste first deste subtexto for a barra invertida, posponha "\\" para o pdf string; repita.
Posponha o target deste first deste subtexto para o pdf string.
Repita.
Posponha ")" para o pdf string.

Etapas necessárias para que se converta um string para um endereço de memória:
\ assumes endereço de memória estiver em cifra binária format
Converta o string como um cifra hexadecimal para um texto hexadecimal.
Esvazie o endereço de memória.
Lance um subtexto sobre o texto hexadecimal.
Atribua 24 a um shift contagem.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o shift contagem for menor do que 0, cancele.
Atribua o target deste first deste subtexto a um número.
Shift o número left o shift contagem.
Disjuncione logicamente o endereço de memória como um número com o número.
Adicione 1 para o first deste subtexto.
Subtraia 8 from o shift contagem.
Repita.

Etapas necessárias para que se converta um string para um query string:
Limpe o query string.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, pare.
Converta o target deste first deste subtexto para um query pedaço.
Posponha o query pedaço para o query string.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se converta um string para uns rows:
Lance um percorredor sobre o string.
Percorra.
Mova o percorredor (text file rules).
Se o vocábulo deste percorredor estiver em branco, pare.
Crie uma row usando o vocábulo deste percorredor.
Posponha a row para a rows.
Se o target deste last deste string desta row é o linefeed pedaço, atribua o return pedaço ao target deste last deste string desta row. 
\ *dahn new para handle lines terminated por just linefeed
Repita.
Renumber a rows.

Etapas necessárias para que se converta um string para um uuid:
Converta o string para um wide string e modifique através de nulificação.
Call "ole32.dll" "CLSIDFromString" com o first deste wide string e o endereçamento deste uuid.

Etapas necessárias para que se converta um string para um wide string:
Limpe o wide string.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Posponha o target deste first deste subtexto para o wide string.
Posponha o null pedaço para o wide string.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se converta um string para um wide string e modifique através de nulificação:
Converta o string para o wide string.
Modifique através do caractere NUL o wide string.

Etapas necessárias para que se converta um url para um url conjunto:
Isole o url.
Modifique através do caractere NUL o url.
Atribua a magnitude desses urlcomponents ao dwstructsize destes urlcomponents.
Atribua 1 ao dwschemelength destes urlcomponents.
Atribua 1 ao dwhostnamelength destes urlcomponents.
Atribua 1 ao dwurlpathlength destes urlcomponents.
Atribua 1 ao dwextrainfolength destes urlcomponents.
Call "wininet.dll" "InternetCrackUrlA" com o first desta url e 0 e 0 e o endereçamento destes urlcomponents devolvendo um número.
Converta o lpszscheme destes urlcomponents e o dwschemelength destes urlcomponents para o scheme deste url conjunto.
Converta o lpszhostname destes urlcomponents e o dwhostnamelength destes urlcomponents para o host nome deste url conjunto.
Converta o lpszurlpath destes urlcomponents e o dwurlpathlength destes urlcomponents para o endereço completo deste url conjunto.
Converta o lpszextrainfo destes urlcomponents e o dwextrainfolength destes urlcomponents para o extra deste url conjunto.
Atribua o nport destes urlcomponents ao port número deste url conjunto.

Etapas necessárias para que se converta um wyrd para um cifra hexadecimal:
Split o wyrd a um pedaço e uma segunda pedaço.
Converta o pedaço para o cifra hexadecimal.
Converta a segunda pedaço para uma segunda cifra hexadecimal.
Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Uma coordenada é uns twips.

Etapas necessárias para que se copie pedaços from um endereço de memória para uma segunda endereço de memória por um quantidade de pedaços:
\ copie handling overlap com 1 pedaço moves
Intel $8BB508000000. \ mov esi,[ebp+8] \ o endereço de memória
Intel $8B36. \ mov esi,[esi]
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda endereço de memória
Intel $8B3F. \ mov edi,[edi]
Intel $8B8D10000000. \ mov ecx,[ebp+16] \ o número
Intel $8B09. \ mov ecx,[ecx]
\ check por something para copiar
Intel $81F900000000. \ cmp ecx,0
Intel $0F8E39000000. \ jle end
\ check por no overlap
Intel $3BF7. \ cmp esi,edi
Intel $0F8D24000000. \ jge forward
Intel $8BC6. \ mov eax,esi
Intel $03C1. \ adicione eax,ecx
Intel $3BC7. \ cmp eax,edi
Intel $0F8E18000000. \ jle forward
\ copia backward
Intel $03F1. \ adicione esi,ecx
Intel $4E. \ dec esi
Intel $03F9. \ adicione edi,ecx
Intel $4F. \ dec esi
\ backward
Intel $8A16. \ mov dl,[esi]
Intel $8817. \ mov [edi],dl
Intel $4E. \ dec esi
Intel $4F. \ dec edi
Intel $49. \ dec ecx
Intel $0F85F3FFFFFF. \ jnz backward
Intel $E90D000000. \ jmp end
\ forward: copia forward
Intel $8A16. \ mov dl,[esi]
Intel $8817. \ mov [edi],dl
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $0F85F3FFFFFF. \ jnz forward

Etapas necessárias para que se copie um event Para uma segunda event:
Se o event for inexistente, esvazie a segunda event; exit.
Crie a segunda event.
Atribua a categoria deste event à categoria deste segunda event.
Atribua o detector de tecla shift deste event ao detector de tecla shift deste segunda event.
Atribua o detector de tecla ctrl deste event ao detector de tecla ctrl deste segunda event.
Atribua o detector de tecla alt deste event ao detector de tecla alt deste segunda event.
Atribua o spot deste event ao spot deste segunda event.
Atribua a tecla deste event à tecla deste segunda event.
Atribua o pedaço deste event ao pedaço deste segunda event.

Etapas necessárias para que se copie um gpbitmap Para uma segunda gpbitmap:
Se o gpbitmap for inexistente, esvazie a segunda gpbitmap; exit.
Call "gdiplus.dll" "GdipCloneBitmapAreaI" com 0 e 0 e o largura deste gpbitmap e a altura deste gpbitmap e 0 [pixelformatdontcare] and the gpbitmap e o endereçamento deste segunda gpbitmap.

Etapas necessárias para que se copie o guts of um text Para uma segunda text:
Se o text for inexistente, cancele.
Se a segunda text for inexistente, cancele.
Atribua a caixa deste text à caixa deste segunda text.
Atribua a origin deste text à origin deste segunda text.
Atribua o pincel deste text ao pincel deste segunda text.
Atribua a font deste text à font deste segunda text.
Atribua o alinhamento deste text ao alinhamento deste segunda text.
Copie as rows deste text para as rows deste segunda text.
Atribua a margin deste text à margin deste segunda text.
Atribua a scale deste text à scale deste segunda text.
Atribua o wrap detector deste text ao wrap detector deste segunda text.
Atribua o horizontal scroll detector deste text ao horizontal scroll detector deste segunda text.
Atribua o vertical scroll detector deste text ao vertical scroll detector deste segunda text.
Atribua a seleção deste text à seleção deste segunda text.
Atribua o detector de alteração deste text ao detector de alteração deste segunda text.
Atribua o última operação deste text ao última operação deste segunda text.
\ dont copie undos e redos

O número de cópias é um número.

Etapas necessárias para que se copie uma picture Para uma segunda picture:
Se o picture for inexistente, esvazie a segunda picture; exit.
Aloque memória para a segunda picture.
Atribua a caixa desta picture à caixa desta segunda picture.
Atribua a uncropped caixa desta picture à uncropped caixa desta segunda picture.
Atribua o grayscale detector desta picture ao grayscale detector desta segunda picture.
Atribua o mirror detector desta picture ao mirror detector desta segunda picture.
Atribua o ângulo de rotação desta picture ao ângulo de rotação desta segunda picture.
Atribua os data desta picture aos data desta segunda picture.
Copie o gpbitmap desta picture ao gpbitmap desta segunda picture.

Etapas necessárias para que se copie um polígono Para uma segunda polígono:
Se o polígono for inexistente, esvazie a segunda polígono; exit.
Aloque memória para o segunda polígono.
Copie os vértices deste polígono aos vértices deste segunda polígono.

Etapas necessárias para que se copie uma row Para uma segunda row:
Se a row for inexistente, esvazie a segunda row; exit.
Aloque memória para o segunda row.
Atribua a número da linha desta row ao número da linha desta segunda row.
Atribua o string desta row ao string desta segunda row.

Etapas necessárias para que se copie uns rows Para uns segunda rows:
Destrua a segunda rows.
Percorra.
Obtenha uma row from a rows.
Se a row for inexistente, cancele.
Copie a row a uma segunda row.
Posponha a segunda row para a segunda rows.
Repita.

Etapas necessárias para que se copie um text Para uma segunda text:
Se o text for inexistente, esvazie a segunda text; exit.
Aloque memória para o segunda text.
Copie o guts of o text ao segunda text.

Etapas necessárias para que se copie um vértice Para uma segunda vértice:
Se o vértice for inexistente, esvazie a segunda vértice; exit.
Aloque memória para o segunda vértice.
Atribua a coordenada x deste vértice à coordenada x deste segunda vértice.
Atribua a coordenada y deste vértice à coordenada y deste segunda vértice.

Etapas necessárias para que se copie uns vértices Para uns segunda vértices:
Destrua os segunda vértices.
Percorra.
Obtenha um vértice from o vértices.
Se o vértice for inexistente, cancele.
Copie o vértice a uma segunda vértice.
Posponha a segunda vértice para a segunda vértices.
Repita.

Uma contagem é um número.

Um contador é um número.

Etapas necessárias para que se crie o connect handle of um winhttp request using um url conjunto:
Se o winhttp request for inexistente, cancele.
Converta o host nome deste url conjunto a um wide string denominado wide host nome e modifique através de nulificação.
Call "winhttp.dll" "WinHttpConnect" com a session desta request deste winhttp And o first deste wide host nome And a port deste url conjunto And 0 devolvendo a connection deste winhttp request.
Se a connection deste winhttp request for 0, atribua "Erro. Não foi possível estabelecer uma conexão." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se crie um console:
Aloque memória para o console.
Atribua a cor cinza muito claro à cor da borda deste console.
Atribua a cor cinza muito claro à cor de preenchimento deste console.
Atribua a caixa desta tela à caixa deste console.
Atribua a caixa desta tela a uma caixa.
Subtraia a altura desta fonte padrão from a coordenada inferior desta caixa.
Atribua a altura desta caixa dividido pela altura desta fonte padrão times a altura desta fonte padrão a uma altura.
Atribua a coordenada superior desta caixa mais o altura à coordenada inferior desta caixa.
Centralize a caixa na caixa desta tela (verticalmente).
Atribua a coordenada superior desta caixa à coordenada esquerda desta caixa.
Subtraia a coordenada superior desta caixa from a coordenada direita desta caixa.
Crie o text deste console.
Atribua a caixa à caixa deste text deste console.
Ligue o wrap detector deste text deste console.
Desative o horizontal scroll detector deste text deste console.
Ligue o vertical scroll detector deste text deste console.
Atribua a altura desta fonte padrão ao grid deste console.
Multiplique o número x deste grid deste console por 2.

Etapas necessárias para que se crie um crypt session com um passphrase string:
\ sets erro do fluxo de entrada/saída if failure
Limpe o erro do fluxo de entrada/saída.
Aloque memória para o crypt session.
\ acquire context
Call "advapi32.dll" "CryptAcquireContextA" com o endereçamento deste hcryptprov deste crypt session e 0 e "Microsoft Enhanced Cryptographic Provider v1.0"'s first And 1 [prov_rsa_full] e -268435456 [crypt_verifycontext] devolvendo um result número.
Se o result for 0, atribua "Erro. Não foi possível adquirir o contexto." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
\ crie hash
Call "advapi32.dll" "CryptCreateHash" com o hcryptprov deste crypt session e 32771 [calg_md5] e 0 e 0 And o endereçamento deste hcrypthash deste crypt session devolvendo o result número.
Se o result for 0, atribua "Erro. Não foi possível criar o hash." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
\ hash passphrase
Call "advapi32.dll" "CryptHashData" com o hcrypthash deste crypt session e o first desta passphrase e o quantidade de caracteres desta passphrase e 0 devolvendo o result número.
Se o result for 0, atribua "Erro. Não foi possível fazer o hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
\ derive session tecla
Call "advapi32.dll" "CryptDeriveKey" com o hcryptprov deste crypt session e 26625 [calg_rc4 stream cipher] e o hcrypthash deste crypt session And 8388608 [128 bit] e o endereçamento deste hcryptkey desta crypt session devolvendo o result número.
Se o result for 0, atribua "Erro. Não foi possível derivar a chave da sessão." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.

Etapas necessárias para que se crie um dyad:
Aloque memória para o dyad.

Etapas necessárias para que se crie um event:
Aloque memória para o event.

Etapas necessárias para que se crie uma font info usando um font:
Crie o font info usando o font (basic data).
Crie as font larguras desta font info usando o font.

Etapas necessárias para que se crie uma font info usando uma font (basic data):
Aloque memória para o font info.
Atribua o font ao font desta font info.
Obtenha um outlinetextmetric usando o font.
Atribua 32 ao flags deste font info. \ could ser updated com um more information
Atribua o tminternalleading destes otmtextmetrics deste outlinetextmetric ao internal leading desta font info.
Atribua o otmemsquare deste outlinetextmetric ao emsquare desta font info.
Atribua o tmascent deste otmtextmetrics deste outlinetextmetric ao ascent desta font info.
Atribua - o tmdescent deste otmtextmetrics deste outlinetextmetric ao descent desta font info.
Atribua o otmscapemheight deste outlinetextmetric ao capheight desta font info.
Atribua o otmitalicangle deste outlinetextmetric ao italicangle desta font info.
Atribua 0 ao stemv desta font info. \ dont know where para obtenha this from
Atribua o otmrcfontbox deste outlinetextmetric ao font caixa desta font info.

Etapas necessárias para que se crie uma font info usando uma font e um string:
\ creates larguras based sobre characters em string
Crie o font info usando a font (basic data).
Crie as font larguras desta font info usando o font e o string.

Etapas necessárias para que se crie uns font larguras usando um font:
Aloque memória para o font larguras.
Atribua o font à font destas font larguras.
Atribua 256 à contagem destas font larguras.
Assign o data destes font larguras usando a contagem destas font larguras times a magnitude desse número.
Crie o número da fonte of o memory canvas usando o font.
Assign um original abc endereço de memória usando 256 times a magnitude desse abc.
Call "gdi32.dll" "GetCharABCWidthsA" com 
o memory canvas \ Um identificador para o contexto do dispositivo.
e 
0 \ O primeiro caractere do grupo de caracteres consecutivos da fonte atual.
e 
255 \O último caractere no grupo de caracteres consecutivos da fonte atual.
e 
o original abc endereço de memória. \ Um ponteiro para uma matriz de estruturas ABC que recebe as larguras dos caracteres, em unidades lógicas. 
\Esta matriz deve conter, no mínimo, a mesma quantidade estruturas ABC que a quantidade de caracteres no intervalo especificado pelos parâmetros uFirstChar e uLastChar.
\ Para mais informações, veja os sistes abaixo: 
\ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-abc
\ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsa
Destrua o número da fonte of o memory canvas.
Atribua o original abc endereço de memória a um abc endereço de memória.
Atribua o data destes font larguras a um endereço numérico.
Percorra.
Se um contador é past 256, pare.
Atribua o abca deste abc endereço de memória ao target deste endereço numérico .
Adicione o abcb deste abc endereço de memória para o target deste endereço numérico .
Adicione o abcc deste abc endereço de memória para o target deste endereço numérico .
Adicione a magnitude deste abc para o abc endereço de memória.
Adicione a magnitude deste número para o endereço numérico.
Repita.
Unassign o original abc endereço de memória.

Etapas necessárias para que se crie uns font larguras usando uma font e um string:
Aloque memória para o font larguras.
Atribua o font à font destas font larguras.
Atribua o quantidade de caracteres deste string à contagem destas font larguras.
Se o string estiver em branco, cancele.
Atribua a magnitude desse gcpresults ao lstructsize destes gcpresults.
Atribua o quantidade de caracteres deste string ao nglyphs destes gcpresults.
Assign o lpdx destes gcpresults usando o quantidade de caracteres deste string times a magnitude desse número.
Crie o número da fonte of o memory canvas usando o font.
Call "gdi32.dll" "GetCharacterPlacementA" com o memory canvas e o first deste string And o quantidade de caracteres deste string e 0 e o endereçamento deste gcpresults e 0.
Destrua o número da fonte of o memory canvas.
Atribua o lpdx destes gcpresults ao data destes font larguras.

Etapas necessárias para que se crie um gpbitmap usando um trecho:
Limpe o erro do fluxo de entrada/saída.
Call "kernel32.dll" "GlobalAlloc" com 2 [gmem_moveable] e o quantidade de caracteres deste trecho devolvendo um número identificador.
Call "kernel32.dll" "GlobalLock" com o número identificador devolvendo um endereço de memória.
Copie pedaços from o first deste trecho para o endereço de memória pelo quantidade de caracteres deste trecho.
Call "kernel32.dll" "GlobalUnlock" com o número identificador.
Call "ole32.dll" "CreateStreamOnHGlobal" com o número identificador e 1 [true] e o endereçamento desse istream.
Call "gdiplus.dll" "GdipCreateBitmapFromStream" com o istream e o endereçamento deste gpbitmap devolvendo um número.
Se o número não for 0, atribua "Não sei como processar este tipo de imagem." ao erro do fluxo de entrada/saída; esvazie o gpbitmap.
Call o release deste vtable deste istream com o istream.

Etapas necessárias para que se crie um gpimageattributes (grayscale):
Call "gdiplus.dll" "GdipCreateImageAttributes" com o endereçamento destes gpimageattributes.
Call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" com o gpimageattributes e 0 [coloradjusttypedefault] e 1 And o first deste grayscale cor matrix e 0 e 0 [colormatrixflagsdefault].

Etapas necessárias para que se crie o hbrush of um canvas usando uma cor:
Converta a cor para um código da cor.
Se a cor estiver clear, atribua o null hbrush a um hbrush.
Se a cor não estiver clear, call "gdi32.dll" "CreateSolidBrush" com o código da cor devolvendo o hbrush.
Call "gdi32.dll" "SelectObject" com o canvas e o hbrush.

Etapas necessárias para que se crie o número da fonte of um canvas usando um font:
Converta a font para um número da fonte.
Call "gdi32.dll" "SelectObject" com o canvas e o número da fonte.

Etapas necessárias para que se crie o hpen of um canvas usando uma cor:
Converta a cor para um código da cor.
Se a cor estiver clear, atribua o null hpen a um hpen.
Atribua o tpp times o grossura do pincel a um número.
Se o canvas for o printer canvas, atribua 1 pixel times o grossura do pincel ao número.
Se a cor não estiver clear, call "gdi32.dll" "CreatePen" com 0 [ps_solid] e o número e o código da cor devolvendo o hpen.
Call "gdi32.dll" "SelectObject" com o canvas e o hpen.

Etapas necessárias para que se crie um hrgn usando uma caixa:
Isole a caixa.
Adicione o tpp para o canto inferior direito desta caixa.
Call "gdi32.dll" "BeginPath" com o quadro atual.
Call "gdi32.dll" "Rectangle" com o quadro atual e a coordenada esquerda desta caixa e a coordenada superior desta caixa e a coordenada direita desta caixa e a coordenada inferior desta caixa.
Call "gdi32.dll" "EndPath" com o quadro atual.
Call "gdi32.dll" "PathToRegion" com o quadro atual devolvendo o hrgn.

Etapas necessárias para que se crie um hrgn usando um elipse:
Atribua a caixa desta elipse a uma caixa.
Call "gdi32.dll" "BeginPath" com o quadro atual.
Call "gdi32.dll" "Ellipse" com o quadro atual e a coordenada esquerda desta caixa e a coordenada superior desta caixa e a coordenada direita desta caixa e a coordenada inferior desta caixa.
Call "gdi32.dll" "EndPath" com o quadro atual.
Call "gdi32.dll" "PathToRegion" com o quadro atual devolvendo o hrgn.

Etapas necessárias para que se crie um hrgn usando um polígono:
Se o polígono for inexistente, atribua 0 ao hrgn; exit.
Crie um vértice array usando os vértices deste polígono.
Call "gdi32.dll" "LPtoDP" com o quadro atual e o spot endereço de memória deste vértice array e a contagem deste vértice array.
Call "gdi32.dll" "CreatePolygonRgn" com o spot endereço de memória deste vértice array e a contagem deste vértice array e 2 [winding] devolvendo o hrgn.
Destrua o vértice array.

Etapas necessárias para que se crie um hrgn usando uma caixa arredondada:
Se o raio desta caixa arredondada for 0, crie o hrgn usando a caixa arredondada como uma caixa; exit.
Atribua a caixa arredondada a uma caixa.
Atribua o raio desta caixa arredondada times 2 a um diameter número.
Call "gdi32.dll" "BeginPath" com o quadro atual.
Call "gdi32.dll" "RoundRect" com o quadro atual e a coordenada esquerda desta caixa e a coordenada superior desta caixa e a coordenada direita desta caixa e a coordenada inferior desta caixa e o diameter e o diameter.
Call "gdi32.dll" "EndPath" com o quadro atual.
Call "gdi32.dll" "PathToRegion" com o quadro atual devolvendo o hrgn.

Etapas necessárias para que se crie um catálogo usando uma contagem de buckets:
Aloque memória para o catálogo.
Atribua a contagem de buckets à contagem de buckets deste catálogo.
Atribua o magnitude desse conjunto de buckets a um largura.
Atribua a contagem de buckets deste catálogo times o largura a um número.
Assign o first bucket deste catálogo usando o número.
Atribua o first bucket deste catálogo mais o número menos o largura ao last bucket deste catálogo.

Etapas necessárias para que se crie o lexicon:
Aloque memória para o lexicon.
Crie o catálogo deste lexicon usando 4027.

Etapas necessárias para que se crie o abra handle of um winhttp request:
Se o winhttp request for inexistente, cancele.
Converta o nome deste module para um wide string denominado wide module nome e modifique através de nulificação.
Call "winhttp.dll" "WinHttpOpen"
With o first deste wide module nome And 0 [winhttp_access_type_default_proxy] And 0 [winhttp_no_proxy_name] And 0 [winhttp_no_proxy_bypass] And 0 devolvendo a session desta request deste winhttp.
Se a session desta request deste winhttp for 0, atribua "Erro. Não foi possível iniciar a conexão." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos:
Se o endereço completo for endereço da pasta-format, crie o endereço completo no sistema de arquivos (pasta)[endereço]; exit.
Se o endereço completo for file-format, crie o endereço completo no sistema de arquivos (arquivo); exit.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos (pasta)[endereço]:
Isole o endereço completo.
Remove algum tipo de trailing barra invertida from o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "CreateDirectoryA" com o first deste endereço completo e 0 devolvendo um número.
Limpe o erro do fluxo de entrada/saída.
Se o número não for 0, cancele.
Atribua "Erro. Não foi possível criar a seguinte pasta: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos (arquivo):
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "CreateFileA" com o first deste endereço completo e 1073741824 [generic_write] e 0 e 0 e 1 [create_new] e 128 [file_attribute_normal] e 0 devolvendo um número identificador.
Call "kernel32.dll" "CloseHandle" com o número identificador.
Limpe o erro do fluxo de entrada/saída.
Se o número identificador não for -1 [invalid_handle_value], cancele.
Atribua "Erro. Não foi possível criar o seguinte arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se crie um pdf object usando um categoria:
Aloque memória para o pdf object.
Atribua o categoria à categoria deste pdf object.

Etapas necessárias para que se crie um pdf outline entry usando um title string e uma página altura e um destination número:
Aloque memória para o pdf outline entry.
Atribua o title string ao title deste pdf outline entry.
Atribua a página altura ao página altura deste pdf outline entry.
Atribua o destination ao destination deste pdf outline entry.

Etapas necessárias para que se crie um picture:
Aloque memória para o picture.

Etapas necessárias para que se crie um picture usando um trecho:
Crie um gpbitmap usando o trecho.
Se o gpbitmap for inexistente, esvazie o picture; exit.
Aloque memória para o picture.
Atribua o trecho ao data desta picture.
Atribua o gpbitmap ao gpbitmap desta picture.
Ajuste o picture (extract caixas from gpbitmap).

Etapas necessárias para que se crie um picture usando um gpbitmap:
Se o gpbitmap for inexistente, esvazie o picture; exit.
Aloque memória para o picture.
Atribua o gpbitmap ao gpbitmap desta picture.
Ajuste o picture (extract caixas from gpbitmap).

Etapas necessárias para que se crie um picture usando um url:
Read o url a um trecho.
Crie o picture usando o trecho.

Etapas necessárias para que se crie um polígono:
Aloque memória para o polígono.

Etapas necessárias para que se crie um quora:
Aloque memória para o quora.

Etapas necessárias para que se crie um refer:
Aloque memória para o refer.

Etapas necessárias para que se crie o request handle of um winhttp request using um url conjunto:
Se o winhttp request for inexistente, cancele.
Converta o endereço completo deste url conjunto a um wide string denominado wide endereço completo e modifique através de nulificação.
Converta "POST" para um wide string denominado wide post string e modifique através de nulificação.
Se o scheme deste url conjunto for "https", atribua 8388608 [winhttp_flag_secure] a um secure número.
Call "winhttp.dll" "WinHttpOpenRequest"
With a connection deste winhttp request
And o first deste wide post string And o first deste wide endereço completo And 0 [L"HTTP/1.1"] And 0 [winhttp_no_referer] And 0 [winhttp_default_accept_types] And o secure número devolvendo a request deste winhttp request.
Se a request deste winhttp request for 0, atribua "Erro na requisição winhttp. Não foi possível abrir a requisição." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se crie uma row usando um pedaço:
Aloque memória para a row.
Atribua o pedaço ao string deste row.

Etapas necessárias para que se crie uma row usando um string:
Aloque memória para a row.
Atribua o string ao string deste row.

Etapas necessárias para que se crie um socket usando um host string e um port número:
\ this guy creates e connects, sets erro do fluxo de entrada/saída if existe um problem
Limpe o erro do fluxo de entrada/saída.
\ obtenha sockaddr
Obtenha um sockaddr usando o host.
Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
Atribua 2 [af_inet] ao sin_family deste sockaddr.
Atribua o port ao sin_port deste sockaddr.
\ crie socket 
Call "ws2_32.dll" "socket" com 2 [af_inet] e 1 [sock_stream] e 0 [ipproto_ip] devolvendo o socket.
Se o socket é -1, atribua "Erro. Não foi possível criar o soquete." ao erro do fluxo de entrada/saída; exit.
\ connect socket
Call "ws2_32.dll" "connect" com o socket e o endereçamento deste sockaddr e a magnitude deste sockaddr devolvendo um result número.
Se o result não for 0, atribua "Erro. Falha na conexão com o soquete." ao erro do fluxo de entrada/saída; exit.
\ abra send timeout 30 seconds
Call "ws2_32.dll" "setsockopt" com o socket e 65535 e 4101 [so_sndtimo] e 30 seconds' endereçamento e 4 devolvendo o result número.
Se o result não for 0, atribua "Erro. Não foi possível definir o tempo limite de recepção 4101 so_sndtimo." ao erro do fluxo de entrada/saída; exit.
\ abra receive timeout 30 seconds
Call "ws2_32.dll" "setsockopt" com o socket e 65535 e 4102 [so_rcvtimeo] e 30 seconds' endereçamento e 4 devolvendo o result número.
Se o result não for 0, atribua "Erro. Não foi possível definir o tempo limite de recepção 4102 so_rcvtimeo." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se crie um conjunto de texto usando um string:
Aloque memória para o conjunto de texto.
Atribua o string ao string deste conjunto de texto.

Etapas necessárias para que se crie um terminal em uma caixa:
Aloque memória para o terminal.
Atribua a caixa à caixa deste terminal.
Atribua a cor verde ao output cor deste terminal.
Atribua a cor verde claríssimo ao input cor deste terminal.

Etapas necessárias para que se crie um text:
Aloque memória para o text.
Atribua a cor preta ao pincel deste text.
Atribua a fonte padrão ao font deste text.
Atribua "left" ao alinhamento deste text.
Atribua 1/1 à scale deste text.
Garanta one row no text.
Reset o origin of o text.
Reset o caret of o text.
Desselecione o text.

Etapas necessárias para que se crie um vértice:
Aloque memória para o vértice.

Etapas necessárias para que se crie um vértice array usando uma contagem:
Isole a contagem.
Aloque memória para o vértice array.
Atribua a contagem à contagem deste vértice array.
Multiplique a contagem pela magnitude desse spot.
Assign o spot endereço de memória deste vértice array usando a contagem.

Etapas necessárias para que se crie um vértice array usando uns vértices:
Crie o vértice array usando a contagem destes vértices.
Atribua o spot endereço de memória deste vértice array a um spot endereço de memória.
Percorra.
Obtenha um vértice from o vértices.
Se o vértice for inexistente, cancele.
Atribua o spot deste vértice ao target deste spot endereço de memória.
Adicione a magnitude deste spot deste vértice para o spot endereço de memória.
Repita.

Etapas necessárias para que se crie um vértice usando um spot:
Aloque memória para o vértice.
Atribua o spot ao spot deste vértice.

Etapas necessárias para que se crie um vértice usando uma coordenada x e uma coordenada y:
Aloque memória para o vértice.
Atribua a coordenada x à coordenada x deste vértice.
Atribua a coordenada y à coordenada y deste vértice.

Etapas necessárias para que se crie um winhttp request por posting para um url:
Aloque memória para o winhttp request.
Converta o url para um url conjunto.
Crie o abra handle of o winhttp request.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
Crie o connect handle of o winhttp request using o url conjunto.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
Crie o request handle of o winhttp request using o url conjunto.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.

O console é um console.

O texto CRLF é um string igual a $0D0A.

Uma crypt session é uma coisa com \documentar isso com calma depois
Um hcryptprov endereço de memória, \ O tipo de dados HCRYPTPROV é usado para representar identificadores para CSPs. 
\Esses identificadores são usados para indicar qual módulo CSP executa operações específicas.
Um hcrypthash endereço de memória, \O tipo de dados HCRYPTHASH é usado para representar identificadores para objetos hash. Esses identificadores indicam ao módulo CSP qual hash está sendo usado em uma operação específica. O
\ módulo CSP não permite a manipulação direta dos valores de hash. 
\Em vez disso, o usuário manipula os valores de hash por meio do identificador de hash.
Um hcryptkey endereço de memória. \O tipo de dados HCRYPTKEY é usado para representar identificadores para chaves criptográficas. 
\Esses identificadores são usados para indicar ao módulo CSP qual chave está sendo usada em uma operação específica. 
\O módulo CSP não permite o acesso direto aos valores-chave. 
\Em vez disso, o usuário executa funções usando o valor da chave por meio do identificador de chave.

O quadro atual é um canvas.

O evento atual é um event.

O número atual da cor do arco-íris é um número [esse número vai de 1 a 6 indicando, respectivamente, vermelho, laranja, amarelo, verde, azul, roxo].

Um cursor é um número identificador.

Etapas necessárias para que se corte um número pela metade:
Divida o número por 2.

Etapas necessárias para que se darken uma cor por um quantia:
Subtraia o quantia from a luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se darken uma cor por uns percent;
Etapas necessárias para que se darken uma cor about uns percent;
Etapas necessárias para que se darken uma cor por about uns percent;
Etapas necessárias para que se darken uma cor uns percent:
Atribua a luminosidade desta cor menos o percent à luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se darken o current cor about uns percent:
Darken a cor deste context pelo percent.

Um date/time é um conjunto com
Um year número,
Um month número,
Um week day número,
Um day número,
Um hour número,
Um minute número,
Um second número,
Um millisecond número.

Etapas necessárias para que se de-sign um fração:
De-sign o numerador desta fração.
De-sign o denominador desta fração.

Etapas necessárias para que se de-sign um número:
Se o número for o menor número, atribua o maior número ao número; exit.
Se o número for menor do que 0, negate o número.

Etapas necessárias para que se de-sign um pair:
De-sign o número x deste pair.
De-sign o número y deste pair.

Etapas necessárias para que se de-sign um string:
Se o string estiver em branco, cancele.
Se o target deste first deste string for algum tipo de sign, remove o first pedaço from o string.

Um relatório de informações é um string.
Um relatório de bugs é um string.
Um relatório de erros é um string.

Etapas necessárias para que se produza o relatório de bugs usando uma caixa;
Etapas necessárias para que se produza o relatório de erros usando uma caixa;
Etapas necessárias para que se produza o relatório de informações usando uma caixa:
Limpe um string.
Posponha "Coordenada esquerda = " para o string.
Posponha a coordenada esquerda desta caixa para o string.
Posponha ", Coordenada superior=" para o string.
Posponha a coordenada superior desta caixa para o string.
Posponha ", Coordenada direita=" para o string.
Posponha a coordenada direita desta caixa para o string.
Posponha ", Coordenada inferior=" para o string.
Posponha a coordenada inferior desta caixa para o string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando um pedaço;
Etapas necessárias para que se produza o relatório de bugs usando um pedaço;
Etapas necessárias para que se produza o relatório de informações usando um pedaço:
Atribua o pedaço a um número.
Converta o número para um string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando uma cor;
Etapas necessárias para que se produza o relatório de bugs usando uma cor;
Etapas necessárias para que se produza o relatório de informações usando uma cor:
Limpe um string.
Posponha "Matiz = " para o string.
Posponha a matiz desta cor para o string.
Posponha ", Saturação = " para o string.
Posponha a saturação desta cor para o string.
Posponha ", Luminosidade = " para o string.
Posponha a luminosidade desta cor para o string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando um detector;
Etapas necessárias para que se produza o relatório de bugs usando um detector;
Etapas necessárias para que se produza o relatório de informações usando um detector:
Converta o detector para um string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de bugs usando uma font:
Etapas necessárias para que se produza o relatório de erros usando uma font;
Etapas necessárias para que se produza o relatório de informações usando uma font:
Limpe um string.
Posponha " Nome da fonte = '" para o string seguido de "'".
Posponha o nome desta font para o string.
Posponha ", Tamanho da fonte = " para o string.
Posponha a altura desta font para o string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando uma fração;
Etapas necessárias para que se produza o relatório de bugs usando uma fração;
Etapas necessárias para que se produza o relatório de informações usando uma fração:
Limpe um string.
Posponha "Numerador = " para o string.
Posponha o numerador desta fração para o string.
Posponha ", Denominador = " para o string.
Posponha o denominador desta fração para o string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de bugs usando uma line;
Etapas necessárias para que se produza o relatório de erros usando uma line;
Etapas necessárias para que se produza o relatório de informações usando uma line:
Limpe um string.
Posponha " Começo da linha = " para o string.
Posponha o x deste start desta line para o string.
Posponha "," para o string.
Posponha o y deste start desta line para o string.
Posponha " Fim da linha = " para o string.
Posponha o x deste end desta line para o string.
Posponha "," para o string.
Posponha o y deste end desta line para o string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando um número:
Etapas necessárias para que se produza o relatório de bugs usando um número;
Etapas necessárias para que se produza o relatório de informações usando um número:
Converta o número para um string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando um número e um segundo número;
Etapas necessárias para que se produza o relatório de bugs usando um número e um segundo número;
Etapas necessárias para que se produza o relatório de informações usando um número e um segundo número:
Produza o relatório de informações usando o número seguido de ", " seguido de o segundo número.

Etapas necessárias para que se produza o relatório de erros usando um pair;
Etapas necessárias para que se produza o relatório de bugs usando um pair;
Etapas necessárias para que se produza o relatório de informações usando um pair:
Limpe um string.
Posponha "Coordenada x = " para o string.
Posponha o número x deste pair para o string.
Posponha ",Coordenada y= " para o string.
Posponha o número y deste pair para o string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando um endereço de memória;
Etapas necessárias para que se produza o relatório de bugs usando um endereço de memória;
Etapas necessárias para que se produza o relatório de informações usando um endereço de memória:
Converta o endereço de memória para um cifra hexadecimal.
Produza o relatório de informações usando "$" seguido de o cifra hexadecimal.

Etapas necessárias para que se produza o relatório de erros usando um espaço de cor RGB;
Etapas necessárias para que se produza o relatório de bugs usando um espaço de cor RGB;
Etapas necessárias para que se produza o relatório de informações usando um espaço de cor RGB:
Limpe um string.
Posponha " Red = " para o string. Atribua o espectro vermelho deste espaço de cor RGB a um número.
Posponha o número para o string.
Posponha ", Green = " para o string. Atribua o espectro verde deste espaço de cor RGB ao número.
Posponha o número para o string.
Posponha ", Bue = " para o string. Atribua o espectro azul deste espaço de cor RGB ao número.
Posponha o número para o string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando um string;
Etapas necessárias para que se produza o relatório de bugs usando um string;
Etapas necessárias para que se produza o relatório de informações usando um string:
Isole o string.
Modifique através do caractere NUL o string.
Call "user32.dll" "MessageBoxA" com 0 e o first deste string e "debug"'s first e 0. 
\\  Chame função "MessageBoxA" contida na biblioteca "user32.dll" informando os parâmetros a seguir: 0, o primeiro caractere do texto em questão, o primeiro caractere do "debug" e 0.

Etapas necessárias para que se produza o relatório de erros usando um string (quoted);
Etapas necessárias para que se produza o relatório de bugs usando um string (quoted);
Etapas necessárias para que se produza o relatório de informações usando um string (quoted):
Isole o string.
Anteponha as aspas duplas para o string.
Posponha as aspas duplas para o string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se produza o relatório de erros usando um wyrd;
Etapas necessárias para que se produza o relatório de bugs usando um wyrd;
Etapas necessárias para que se produza o relatório de informações usando um wyrd:
Atribua o wyrd a um número.
Converta o número para um string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se determine se uma caixa é uma segunda caixa:
Se a coordenada esquerda desta caixa não for a coordenada esquerda desta segunda caixa, diga não.
Se a coordenada superior desta caixa não for a coordenada superior desta segunda caixa, diga não.
Se a coordenada direita desta caixa não for a coordenada direita desta segunda caixa, diga não.
Se a coordenada inferior desta caixa não for a coordenada inferior desta segunda caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se uma caixa está still em uma segunda caixa;
Etapas necessárias para que se determine se uma caixa está em uma segunda caixa;
Etapas necessárias para que se determine se uma caixa está inside uma segunda caixa:
Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda desta segunda caixa, diga não.
Se a coordenada superior desta caixa for menor do que a coordenada superior desta segunda caixa, diga não.
Se a coordenada direita desta caixa for maior do que a coordenada direita desta segunda caixa, diga não.
Se a coordenada inferior desta caixa for maior do que a coordenada inferior desta segunda caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se uma caixa está touching uma segunda caixa:
Se a coordenada direita desta segunda caixa for menor do que a coordenada esquerda desta caixa, diga não.
Se a coordenada inferior desta segunda caixa for menor do que a coordenada superior desta caixa, diga não.
Se a coordenada esquerda desta segunda caixa for maior do que a coordenada direita desta caixa, diga não.
Se a coordenada superior desta segunda caixa for maior do que a coordenada inferior desta caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é alphanumeric:
Se o pedaço for algum tipo de letra, diga sim.
Se o pedaço for algum tipo de digit, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o outro byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8406000000. \ je over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é uma segunda pedaço ou um terceiro pedaço:
Se o pedaço for a segunda pedaço, diga sim.
Se o pedaço for o terceiro pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de consonant:
Se o pedaço estiver em "bcdfghjklmnpqrstvwxyzçñ", diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de digit:
Se o pedaço for menor do que o número zero, diga não.
Se o pedaço for maior do que o número nove, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é algum tipo de letra:
Se o pedaço estiver entre o 'A' maiúsculo e o Z maiúsculo, diga sim.
Se o pedaço estiver entre o 'a' minúsculo e o z minúsculo, diga sim.
Se o pedaço for 131 ou 138, diga sim.
Se o pedaço for 140 ou 142, diga sim.
Se o pedaço for 154 ou 156, diga sim.
Se o pedaço estiver entre 158 e 159, diga sim.
Se o pedaço estiver entre 192 e 214, diga sim.
Se o pedaço estiver entre 216 e 246, diga sim.
Se o pedaço estiver entre 248 e 255, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de numeric starter:
Se o pedaço é algum tipo de digit, diga sim.
Se o pedaço é algum tipo de sign, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de punctuation mark:
\ precisa ser aprimorado
Se o pedaço for o caractere de espaço, diga não.
Se o pedaço não for alphanumeric, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de sign:
Se o pedaço for o hífem, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de valid unidade de disco:
Atribua o pedaço a um endereço completo.
Posponha ":\" para o endereço completo.
Obtenha um categoria da unidade de disco pelo endereço completo.
Se a categoria da unidade de disco for "", diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é algum tipo de vogal:
Se o pedaço estiver em "aeiou", diga sim.
\ if o pedaço for "y", say sometimes. \ ha ha ha
Diga não.

Etapas necessárias para que se determine se um pedaço está entre uma segunda pedaço e um terceiro pedaço:
Se o pedaço for menor do que a segunda pedaço, diga não.
Se o pedaço for maior do que o terceiro pedaço, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço está entre um número e uma segunda número:
Se o pedaço for menor do que o número, diga não.
Se o pedaço for maior do que a segunda número, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é maior que uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é maior do que uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8706000000. \ ja over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é maior que um número;
Etapas necessárias para que se determine se um pedaço é maior do que um número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8F06000000. \ jg over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é maior do que ou igual para uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é maior que ou igual para uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é maior ou igual para uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8306000000. \ ja over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço estiver em um string:
Isole o pedaço.
Lowercase o pedaço.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, diga não.
Atribua o target deste first deste subtexto a uma segunda pedaço.
Lowercase a segunda pedaço.
Se a segunda pedaço é o pedaço, diga sim.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se determine se um pedaço é menor que uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é menor do que uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8206000000. \ jb over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é menor que um número;
Etapas necessárias para que se determine se um pedaço é menor do que um número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8C06000000. \ jl over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é menor do que ou igual para uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é menor que ou igual para uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é menor ou igual para uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8606000000. \ jbe over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é like uma segunda pedaço:
\ used internally por palavra wrap
Se o pedaço é whitespace, acione um detector.
Se a segunda pedaço é whitespace, acione uma segunda detector.
Se o detector é a segunda detector, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é irrelevante:
Se o pedaço for menor do que ou igual ao caractere de espaço, diga sim.
Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga sim.
Se o pedaço for o non-breaking-caractere de espaço, diga sim.
Se o pedaço for 129, diga sim.
Se o pedaço for 141, diga sim.
Se o pedaço for 143, diga sim.
Se o pedaço for 144, diga sim.
Se o pedaço for 157, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é um número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8406000000. \ je over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é um número ou uma segunda número:
Se o pedaço for o número, diga sim.
Se o pedaço for a segunda número, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é printable:
Se o pedaço for menor do que o caractere de espaço, diga não.
Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga não.
Se o pedaço for 129, diga não.
Se o pedaço for 141, diga não.
Se o pedaço for 143, diga não.
Se o pedaço for 144, diga não.
Se o pedaço for 157, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é um string:
Se o quantidade de caracteres deste string não for 1, diga não.
Isole o pedaço.
Lowercase o pedaço.
Atribua o target deste first deste string a uma segunda pedaço.
Lowercase a segunda pedaço.
Se o pedaço for a segunda pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é symbolic:
Se o pedaço estiver entre o ponto de exclamação e o slash pedaço, diga sim.
Se o pedaço estiver entre o sinal de dois pontos e o sinal de arroba, diga sim.
Se o pedaço estiver entre o colchete esquerdo e o acento grave, diga sim.
Se o pedaço estiver entre o chave esquerda e o acento til, diga sim.
Se o pedaço for 128, diga sim.
Se o pedaço for 130, diga sim.
Se o pedaço estiver entre 132 e 137, diga sim.
Se o pedaço for 139, diga sim.
Se o pedaço estiver entre 145 e 153, diga sim.
Se o pedaço for 155, diga sim.
Se o pedaço estiver entre 161 e 180, diga sim.
Se o pedaço estiver entre 183 e 191, diga sim.
Se o pedaço for 215, diga sim.
Se o pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é whitespace:
Se o pedaço for o caractere de espaço, diga sim.
Se o pedaço for o tabulação horizontal, diga sim.
Se o pedaço for o return pedaço, diga sim.
Se o pedaço for o linefeed pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se o caret of um text é at o beginning:
Se o text for inexistente, diga não.
Se o número de linhas do cursor deste text não for 1, diga não.
Se o caret column# deste text não for 1, diga não.
Diga sim.

Etapas necessárias para que se determine se o caret of um text é at o end:
Se o text for inexistente, diga não.
Se o número de linhas do cursor deste text não for a contagem destas rows deste text, diga não.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Se o caret column# deste text não for o quantidade de caracteres deste string desta row, diga não.
Diga sim.

Etapas necessárias para que se determine se o caret of um text está sobre o first line:
Se o text for inexistente, diga não.
Se o número de linhas do cursor deste text não for 1, diga não.
Diga sim.

Etapas necessárias para que se determine se o caret of um text está sobre o last line:
Se o text for inexistente, diga não.
Se as rows deste text estiverem vazio, diga não.
Se o número de linhas do cursor deste text não for o número da linha desta last row deste text, diga não.
Diga sim.

Etapas necessárias para que se determine se uma choice é um string:
Se a choice for inexistente, diga não.
Se o nome desta choice for o string, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor e uma segunda cor estão clear:
Se a cor não estiver clear, diga não.
Se a segunda cor não estiver clear, diga não.
Diga sim.

Etapas necessárias para que se determine se uma cor é uma segunda cor:
Se a matiz desta cor não for a matiz desta segunda cor, diga não.
Se a saturação desta cor não for a saturação desta segunda cor, diga não.
Se a luminosidade desta cor não for a luminosidade desta segunda cor, diga não.
Diga sim.

Etapas necessárias para que se determine se uma cor está clear:
Se a matiz desta cor for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é dark:
Se a luminosidade desta cor estiver entre 250 e 374, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é light:
Se a luminosidade desta cor estiver entre 625 e 749, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é normal:
Se a luminosidade desta cor estiver entre 375 e 624, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é very dark:
Se a luminosidade desta cor estiver entre 125 e 249, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é very light:
Se a luminosidade desta cor estiver entre 750 e 874, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é very very dark:
Se a luminosidade desta cor for menor do que ou igual a 124, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é very very light:
Se a luminosidade desta cor for maior do que ou igual a 875, diga sim.
Diga não.

Etapas necessárias para que se determine se um contador é past um número:
Adicione 1 para o contador.
Se o contador for maior do que o número, diga sim.
Diga não.

Etapas necessárias para que se determine se o current spot está above ou below uma caixa:
Se o spot deste context é above ou below a caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se o current spot está left ou right of uma caixa:
Se o spot deste context é left ou right of a caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se o current spot está para o right of uma caixa:
Se a coordenada x deste spot deste context for maior do que a coordenada direita desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se o current spot está within uns twips of uma caixa:
Se o spot deste context estiver within os twips of a caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um difference está within um grid:
Isole a difference.
De-sign a difference.
Se o número x desta difference for maior do que ou igual ao número x desta grid, diga não.
Se o número y desta difference for maior do que ou igual ao número y desta grid, diga não.
Diga sim.

Etapas necessárias para que se determine se um event é algum tipo de atalho de tecla:
Se o event for inexistente, diga não.
Se a categoria deste event não for "pressionamento de tecla", diga não.
Se o event não foi alterado, diga não.
Se a tecla deste event estiver entre a tecla A/a e a tecla Z/z, diga sim.
Diga não.

Etapas necessárias para que se determine se um event foi alterado:
Se o detector de tecla ctrl deste event estiver ativo, diga sim.
Se o detector de tecla alt deste event estiver ativo, diga sim.
Diga não.

Etapas necessárias para que se determine se um finger é past o end of um string:
Se o finger for inexistente, diga sim.
Se o finger for maior do que o last deste string, diga sim.
Diga não.

Etapas necessárias para que se determine se um detector é um número;
Etapas necessárias para que se determine se um detector é uma segunda detector;
Etapas necessárias para que se determine se um endereço de memória é um número;
Etapas necessárias para que se determine se um endereço de memória é uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8406000000. \ je over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

\Etapas necessárias para que se determine se um detector está on:
\ switch como uma segunda nome por detector also ? ***
\Se o detector estiver ativo, diga sim.
\Diga não.

Etapas necessárias para que se determine se um detector está presente;
Etapas necessárias para que se determine se um detector está em vigor;
Etapas necessárias para que se determine se um detector está levantada;
Etapas necessárias para que se determine se um detector está ligado; \foi ligado também funciona
Etapas necessárias para que se determine se um detector está ativo;
Etapas necessárias para que se determine se um detector está ativado; \foi ativado
\Etapas necessárias para que se determine se um detector já está ativado;
Etapas necessárias para que se determine se um detector já foi ativado anteriomente;
\Etapas necessárias para que se determine se um detector foi ativado anteriomente;
Etapas necessárias para que se determine se um detector está tocando;
Etapas necessárias para que se determine se um detector está soando;
Etapas necessárias para que se determine se um detector soou;
\Etapas necessárias para que se determine se um detector já soou;
Etapas necessárias para que se determine se um detector está disparando;
\Etapas necessárias para que se determine se um detector disparou;
Etapas necessárias para que se determine se um detector está alarmando;
\Etapas necessárias para que se determine se um detector disparou;
Etapas necessárias para que se determine se um detector está sendo mostrada;
Etapas necessárias para que se determine se um detector está sendo exibida;
Etapas necessárias para que se determine se um detector está verde:
Se o detector for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um detector está dormente;
Etapas necessárias para que se determine se um detector está suspenso;
Etapas necessárias para que se determine se um detector está inativo;
Etapas necessárias para que se determine se um detector está desligado;
Etapas necessárias para que se determine se um detector está desativado;
Etapas necessárias para que se determine se um detector está vermelho:
Se o detector for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração é o numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é maior que uma segunda fração;
Etapas necessárias para que se determine se uma fração é maior do que uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração for maior do que o numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é maior do que ou igual para uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração for maior do que ou igual ao numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é menor que uma segunda fração;
Etapas necessárias para que se determine se uma fração é menor do que uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração for menor do que o numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração for menor do que ou igual para uma segunda fração;
Etapas necessárias para que se determine se uma fração for menor que ou igual para uma segunda fração;
Etapas necessárias para que se determine se uma fração for menor ou igual para uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração for menor do que ou igual ao numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é negative:
Se o numerador desta fração for menor do que 0, reverse um detector.
Se o denominador desta fração for menor do que 0, reverse o detector.
\ Say o detector. \ does not work em SAL; no detector literals anymore
Se o detector estiver ativo, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é um número:
Se a fração é o número / 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um catálogo está vazia;
Etapas necessárias para que se determine se um catálogo estão vazias;
Etapas necessárias para que se determine se um catálogo estão vazios;
Etapas necessárias para que se determine se um catálogo está vazio:
Se o catálogo for inexistente, diga sim.
Percorra.
Obtenha um bucket usando o catálogo.
Se o bucket for inexistente, diga sim.
Se os refers deste bucket não estiverem vazio, diga não.
Repita.

Etapas necessárias para que se determine se um input é um clique:
Esvazie o clique.
Se a categoria deste input não for "clique", diga não.
Atribua o input ao clique.

Etapas necessárias para que se determine se um item é found:
Se a categoria deste item não estiver em branco, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de digit tecla:
Se a tecla estiver entre 48 e 57, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de letra tecla:
Se a tecla estiver entre 65 e 90, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de modifier tecla:
Se a tecla for a tecla Alt, diga sim.
Se a tecla for a tecla Ctrl, diga sim.
Se a tecla for a tecla shift ,say yes.
Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de pad tecla:
Se a tecla estiver entre 96 e 111, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de printable tecla:
Se a tecla for o barra de espaço, diga sim.
Se a tecla for algum tipo de digit tecla, diga sim.
Se a tecla for algum tipo de letra tecla, diga sim.
Se a tecla for algum tipo de pad tecla, diga sim.
Se a tecla for algum tipo de symbol tecla, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de symbol tecla:
Se a tecla estiver entre 186 e 192, diga sim.
Se a tecla estiver entre 219 e 222, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de wm-char tecla:
Se a tecla não for algum tipo de printable tecla , diga não.
Se a tecla Alt was para baixo, diga não.
Se a tecla Ctrl was para baixo, diga não.
Diga sim.

Etapas necessárias para que se determine se uma tecla está sendo pressionada:
Call "user32.dll" "GetAsyncKeyState" com a tecla devolvendo um wyrd.
Atribua o wyrd a um número.
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla está sendo pressionado:
Call "user32.dll" "GetAsyncKeyState" com a tecla devolvendo um wyrd.
Atribua o wyrd a um número.
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla was para baixo:
Call "user32.dll" "GetKeyState" com a tecla devolvendo um wyrd.
Atribua o wyrd a um número.
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla was toggled:
Call "user32.dll" "GetKeyState" com a tecla devolvendo um wyrd.
Atribua o wyrd a um número.
Conjuncione logicamente o número com 1.
Se o número for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla was para cima:
Se a tecla was para baixo, diga não.
Diga sim.

Etapas necessárias para que se determine se uma tecla com um l-param é algum tipo de repeated escape ou modifier tecla:
Atribua o l-param a um número.
Conjuncione logicamente o número com 1073741824 [$40000000].
Se o número for 0, diga não.
Se a tecla for a tecla Esc, diga sim.
Se a tecla for algum tipo de modifier tecla, diga sim.
Diga não.

Etapas necessárias para que se determine se o left mouse botão está para baixo:
Se o botão esquerdo deste mouse estiver sendo pressionado, diga sim.
Diga não.

Etapas necessárias para que se determine se um line está above uma caixa:
Se o y deste start desta line for maior do que ou igual à coordenada superior desta caixa, diga não.
Se o y deste end desta line for maior do que ou igual à coordenada superior desta caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um line está above uma coordenada:
Se o y deste start desta line for maior do que ou igual à coordenada, diga não.
Se o y deste end desta line for maior do que ou igual à coordenada, diga não.
Diga sim.

Etapas necessárias para que se determine se um line está below uma caixa:
Se o y deste start desta line for menor do que ou igual à coordenada inferior desta caixa, diga não.
Se o y deste end desta line for menor do que ou igual à coordenada inferior desta caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um line está below uma coordenada:
Se o y deste start desta line for menor do que ou igual à coordenada, diga não.
Se o y deste end desta line for menor do que ou igual à coordenada, diga não.
Diga sim.

Etapas necessárias para que se determine se um line está still em uma caixa;
Etapas necessárias para que se determine se um line estiver em uma caixa:
Se o start desta line não estiver na caixa, diga não.
Se o end desta line não estiver na caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um mixed é um número:
Converta o mixed para um fração.
Se a fração for o número, diga sim.
Diga não.

Etapas necessárias para que se determine se o mouse has been dragged from um spot usando um grid:
Se o botão esquerdo deste mouse não estiver sendo pressionado, diga não.
Atribua o spot deste mouse a uma segunda spot.
Obtenha um difference between a segunda spot e o spot.
Se a difference estiver within a grid, repita.
Diga sim.

Etapas necessárias para que se determine se o mouse estiver em uma caixa:
Se o spot deste mouse estiver na caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um número é uma segunda número e um string é uma segunda string:
Se o número não for a segunda número, diga não.
Se o string não for a segunda string, diga não.
Diga sim.

Etapas necessárias para que se determine se um número está entre uma segunda número e um terceiro número:
Se o número for menor do que a segunda número, diga não.
Se o número for maior do que o terceiro número, diga não.
Diga sim.

Etapas necessárias para que se determine se um número é par:
Se o número é ímpar, diga não.
Diga sim.

Etapas necessárias para que se determine se um número é uniformemente divisível por uma segunda número:
Isole o número.
Divida o número pelo segunda número usando um quotient e um resto.
Se o resto for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um número é um multiple of uma segunda número:
Se o número é uniformemente divisível pelo segunda número, diga sim.
Diga não.

Etapas necessárias para que se determine se um número é negative:
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um número é ímpar:
Isole o número.
Conjuncione logicamente o número com 1.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um número é positive:
Se o número for menor do que 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um número é prime:
Se o número for menor do que 2, diga não.
Se o número for 2, diga sim.
Atribua o número menos 1 a uma segunda número.
Percorra.
Se o número é uniformemente divisível pelo segunda número, diga não.
Subtraia 1 from a segunda número.
Se a segunda número for maior do que 1, repita.
Diga sim.

Etapas necessárias para que se determine se um pair é uma segunda pair:
Se o número x deste pair não for o número x deste segunda pair, diga não.
Se o número y deste pair não for o número y deste segunda pair, diga não.
Diga sim.

Etapas necessárias para que se determine se um pair é um número:
Se o número x deste pair não for o número, diga não.
Se o número y deste pair não for o número, diga não.
Diga sim.

Etapas necessárias para que se determine se um pair é um número e uma segunda número:
Se o número x deste pair não for o número, diga não.
Se o número y deste pair não for a segunda número, diga não.
Diga sim.

Etapas necessárias para que se determine se um endereço completo é endereço da pasta-format:
Se o endereço completo estiver em branco, diga não.
Se o target deste last deste endereço completo for a barra invertida, diga sim.
Diga não.

Etapas necessárias para que se determine se um endereço completo é drive-format:
Se o endereço completo começa com "\\", diga sim.
Se o quantidade de caracteres deste endereço completo não for 3, diga não.
Se o endereço completo termina com ":\", diga sim.
Diga não.

Etapas necessárias para que se determine se um endereço completo está vazia no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo estão vazias no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo estão vazios no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo está vazio no sistema de arquivos:
Se o endereço completo não estiver no sistema de arquivos, diga sim.
Obtenha uma contagem of items no endereço completo no sistema de arquivos.
Se a contagem for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um endereço completo é file-format:
Se o endereço completo estiver em branco, diga não.
Se o target deste last deste endereço completo for o sinal de dois pontos, diga não.
Se o target deste last deste endereço completo for a barra invertida, diga não.
Diga sim.

Etapas necessárias para que se determine se um endereço completo está no sistema de arquivos:
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "GetFileAttributesA" com o first deste endereço completo devolvendo um número.
Se o número for menor do que 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um endereço completo é read-only:
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "GetFileAttributesA" com o first deste endereço completo devolvendo um número.
Conjuncione logicamente o número com 1 [file_attribute_readonly].
Se o número não for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um endereço de memória pode ser found;
Etapas necessárias para que se determine se um endereço de memória está coming;
\Etapas necessárias para que se determine se um endereço de memória é found;
Etapas necessárias para que se determine se um endereço de memória foi found;
Etapas necessárias para que se determine se um endereço de memória existe;
Etapas necessárias para que se determine se um endereço de memória does exist:
Se o endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um endereço de memória é maior do que uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é maior do que uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8F06000000. \ jg over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é maior do que ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é maior que ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é maior ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é uma segunda número ou more;
Etapas necessárias para que se determine se um número é maior do que ou igual para uma segunda número;
Etapas necessárias para que se determine se um número é maior que ou igual para uma segunda número;
Etapas necessárias para que se determine se um número é maior ou igual para uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8D06000000. \ jge over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é menor do que uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor que uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é menor que uma segunda número;
Etapas necessárias para que se determine se um número é menor do que uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8C06000000. \ jl over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é menor do que ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor que ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é uma segunda número ou menos;
Etapas necessárias para que se determine se um número é uma segunda número ou menor;
Etapas necessárias para que se determine se um número é menor do que ou igual para uma segunda número;
Etapas necessárias para que se determine se um número é menor que ou igual para uma segunda número;
Etapas necessárias para que se determine se um número é menor ou igual para uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8E06000000. \ jle over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é missing;
Etapas necessárias para que se determine se um endereço de memória é null e esvazie:
Se o endereço de memória for inexistente, diga sim.
Diga não.

Etapas necessárias para que se determine se um polígono está closed:
Se o polígono for inexistente, diga não.
Se a contagem destes vértices deste polígono for menor do que 3, diga não.
Se o spot deste first vértice deste polígono for o spot deste last vértice deste polígono, diga sim.
Diga não.

Etapas necessárias para que se determine se um reply é something like uma segunda reply:
Isole o reply.
Isole a segunda reply.
Simplify o reply.
Simplify a segunda reply.
Se o reply é a segunda reply, diga sim.
Diga não.

Etapas necessárias para que se determine se uma row está em branco:
Se a row for inexistente, diga sim.
Lance um subtexto sobre o string deste row.
Percorra.
Se o subtexto estiver em branco, diga sim.
Se o target deste first deste subtexto não for irrelevante, diga não.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se determine se uma row of um text está selecionado:
Se o text for inexistente, diga não.
Se a row for inexistente, diga não.
Se nada estiver selecionado no text, diga não.
Atribua a normalized seleção deste text a uma seleção.
Se o número da linha desta row for menor do que o anchor número da linha desta seleção, diga não.
Se o número da linha desta row for maior do que o número de linhas do cursor desta seleção, diga não.
Se o número da linha desta row não for o número de linhas do cursor desta seleção, diga sim.
Se o caret column# desta seleção for 1, diga não.
Diga sim.

Etapas necessárias para que se determine se uma row of um text é visível:
Se o text for inexistente, diga não.
Se a row for inexistente, diga não.
Obtenha uma caixa usando a row e o text.
Atribua a caixa deste text a uma segunda caixa.
Ajuste a segunda caixa usando 0 e o tpp e 0 e - o tpp.
Se a caixa estiver touching a segunda caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um seleção é uma segunda seleção:
Se o anchor desta seleção não for o anchor desta segunda seleção, diga não.
Se o caret desta seleção não for o caret desta segunda seleção, diga não.
Diga sim.

Etapas necessárias para que se determine se something está selecionado em um text:
Se o anchor deste text for o caret deste text, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot é above uma caixa:
Se a coordenada y deste spot for menor do que a coordenada superior desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é above um horizontal line:
Se a coordenada y deste spot for menor do que o horizontal y deste start desta line, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é above ou below uma caixa:
Se o spot é above a caixa, diga sim.
Se o spot é below a caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é below uma caixa:
Se a coordenada y deste spot for maior do que a coordenada inferior desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é below um horizontal line:
Se a coordenada y deste spot for maior do que o horizontal y deste start desta line, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está em um elipse:
Crie um hrgn usando a elipse.
Isole o spot.
Divida o spot pelo tpp.
Call "gdi32.dll" "PtInRegion" com o hrgn e a coordenada x deste spot e a coordenada y deste spot devolvendo um número.
Destrua o hrgn.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está em um picture:
Se o picture for inexistente, diga não.
Se o spot estiver na caixa desta picture, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está em um polígono:
Se o polígono for inexistente, diga não.
Crie um vértice array usando os vértices deste polígono.
Call "gdi32.dll" "CreatePolygonRgn" com o spot endereço de memória deste vértice array e a contagem deste vértice array e 2 [winding] devolvendo um hrgn.
Call "gdi32.dll" "PtInRegion" com o hrgn e a coordenada x deste spot e a coordenada y deste spot devolvendo um número.
Call "gdi32.dll" "DeleteObject" com o hrgn.
Destrua o vértice array.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está em uns polígonos:
Obtenha um polígono from o polígonos.
Se o polígono for inexistente, diga não.
Se o spot estiver no polígono, diga sim.
Repita.

Etapas necessárias para que se determine se um spot está em uma caixa arredondada:
Isole a caixa arredondada.
Adicione o tpp para a canto inferior direito desta caixa arredondada.
Atribua o raio desta caixa arredondada times 2 a um diameter número.
Call "gdi32.dll" "CreateRoundRectRgn" com a coordenada esquerda desta caixa arredondada e a coordenada superior desta caixa arredondada e a coordenada direita desta caixa arredondada e a coordenada inferior desta caixa arredondada And o diameter e o diameter devolvendo um hrgn.
Call "gdi32.dll" "PtInRegion" com o hrgn e a coordenada x deste spot e a coordenada y deste spot devolvendo um número.
Call "gdi32.dll" "DeleteObject" com o hrgn.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está em um text:
Se o text for inexistente, diga não.
Se o spot estiver na caixa deste text, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é inside uma caixa;
Etapas necessárias para que se determine se um spot está within uma caixa;
Etapas necessárias para que se determine se um spot está em uma caixa:
Se a coordenada x deste spot for menor do que a coordenada esquerda desta caixa, diga não.
Se a coordenada y deste spot for menor do que a coordenada superior desta caixa, diga não.
Se a coordenada x deste spot for maior do que a coordenada direita desta caixa, diga não.
Se a coordenada y deste spot for maior do que a coordenada inferior desta caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot é para o left of uma caixa:
Se a coordenada x deste spot for menor do que a coordenada esquerda desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é left ou right of uma caixa:
Se o spot é para o left of a caixa, diga sim.
Se o spot é para o right of a caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está sobre uma caixa:
Atribua a caixa a uma segunda caixa.
Atribua 2 times o tpp a um número.
Outdent a segunda caixa usando o número.
Se o spot não estiver no segunda caixa, diga não.
Atribua a caixa a um terceiro caixa.
Atribua 3 times o tpp a uma segunda número.
Indent o terceiro caixa usando a segunda número.
Se o spot estiver no terceiro caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está sobre uma elipse:
Atribua a elipse a uma segunda elipse.
Atribua 2 times o tpp a um número.
Outdent a caixa desta segunda elipse usando o número.
Se o spot não estiver na segunda elipse, diga não.
Atribua a elipse a uma terceiro elipse.
Atribua 3 times o tpp a uma segunda número.
Indent a caixa desta terceiro elipse usando a segunda número.
Se o spot estiver na terceiro elipse, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está sobre um line:
Isole a line.
Atribua 3 times o tpp a um número.
Percorra.
Obtenha uma distance between o spot e o center desta line (chessboard).
Se a distance for menor do que ou igual ao número, diga sim.
Obtenha a distance between a start desta line e o end desta line (chessboard).
Se a distance for menor do que ou igual ao tpp, diga não.
Split a line à line e uma segunda line.
Obtenha a distance between o spot e o center desta line (chessboard).
Obtenha uma segunda distance between o spot e o center desta segunda line (chessboard).
Se o distance for maior do que a segunda distance, atribua a segunda line ao line.
Repita.

Etapas necessárias para que se determine se um spot está sobre um picture:
Se o picture for inexistente, diga não.
Se o spot estiver sobre a caixa desta picture, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está sobre um polígono:
Se o polígono for inexistente, diga não.
Percorra.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, diga não.
Se o next deste vértice for inexistente, diga não.
Atribua o spot deste vértice e o spot deste next deste vértice a um line.
Se o spot estiver sobre o line, diga sim.
Repita.

Etapas necessárias para que se determine se um spot está sobre uma caixa arredondada:
Atribua a caixa arredondada a uma segunda caixa arredondada.
Atribua 2 times o tpp a um número.
Outdent a segunda caixa arredondada usando o número.
Se o spot não estiver no segunda caixa arredondada, diga não.
Atribua a caixa arredondada a um terceiro caixa arredondada.
Atribua 3 times o tpp a uma segunda número.
Indent o terceiro caixa arredondada usando a segunda número.
Se o spot estiver no terceiro caixa arredondada, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot é outside uma caixa:
Se o spot é inside a caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot é para o right of uma caixa:
Se a coordenada x deste spot for maior do que a coordenada direita desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é touching uma caixa:
Se o spot estiver na caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está within um grid of uma segunda spot:
Obtenha um difference between a segunda spot e o spot.
Se a difference está within a grid, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está within uns twips of uma segunda spot:
Atribua os twips e os twips a um grid.
Se o spot estiver within a grid of a segunda spot, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está within uns twips of uma caixa:
Isole a caixa.
Outdent a caixa usando os twips.
Se o spot estiver within a caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se o stack has just one coisa sobre it:
Se a contagem deste stack for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um string does end com uma segunda string;
Etapas necessárias para que se determine se um string termina com uma segunda string:
Se o quantidade de caracteres deste segunda string for maior do que o quantidade de caracteres deste string, diga não.
Lance um subtexto sobre o string.
Atribua o last deste subtexto menos o quantidade de caracteres deste segunda string mais 1 ao first deste subtexto.
Se o subtexto for a segunda string, diga sim.
Diga não.

Etapas necessárias para que se determine se um string does start com uma segunda string;
Etapas necessárias para que se determine se um string começa com uma segunda string:
Se o quantidade de caracteres deste segunda string for maior do que o quantidade de caracteres deste string, diga não.
Lance um subtexto sobre o string.
Atribua o first deste subtexto mais o quantidade de caracteres deste segunda string menos 1 ao last deste subtexto.
Se o subtexto é a segunda string, diga sim.
Diga não.

Etapas necessárias para que se determine se um string does start com um pedaço;
Etapas necessárias para que se determine se um string começa com um pedaço:
Se o string estiver em branco, diga não.
Se o target deste first deste string é o pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string does end com um pedaço; \ added por Mike Gonta

Etapas necessárias para que se determine se um string termina com um pedaço:
Se o string estiver em branco, diga não.
Se o target deste last deste string é o pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é uma segunda string (accent-free compare):
Compare o string para a segunda string usando o quantidade de caracteres deste string e o quantidade de caracteres deste segunda string e o tabela de caracteres minúsculos s/ acento ascii (equal only).

Etapas necessárias para que se determine se um string é uma segunda string:
Compare o string para a segunda string usando o quantidade de caracteres deste string e o quantidade de caracteres deste segunda string e o tabela de caracteres minúsculos ascii (equal only).

Etapas necessárias para que se determine se um string é uma segunda string ou um terceiro string:
Se o string é a segunda string, diga sim.
Se o string é o terceiro string, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é algum tipo de fração literal;
Etapas necessárias para que se determine se um string é algum tipo de ratio literal:
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, diga não.
Se o target deste first deste subtexto não for algum tipo de numeric starter, diga não.
Se o target deste first deste subtexto for algum tipo de sign, adicione 1 para o first deste subtexto.
Split o subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
Se o numerador subtexto não for algum tipo de integer literal, diga não.
Se o denominador subtexto não for algum tipo de integer literal, diga não.
Diga sim.

\Etapas necessárias para que se determine se um string é algum tipo de integer:
\ seemed para ser um duplicate of a rotina below
\Lance um subtexto sobre o string.
\Se o subtexto estiver em branco, diga não.
\Se o target deste first deste subtexto for algum tipo de sign, adicione 1 para o first deste subtexto.
\Se o subtexto estiver em branco, diga não.
\Percorra.
\Se o target deste first deste subtexto não for algum tipo de digit, diga não.
\Adicione 1 para o first deste subtexto.
\Se o subtexto estiver em branco, diga sim.
\Repita.

Etapas necessárias para que se determine se um string é algum tipo de integer;
Etapas necessárias para que se determine se um string é algum tipo de integer literal:
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, diga não.
Se o target deste first deste subtexto for algum tipo de sign, adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, diga não.
Percorra.
Se o target deste first deste subtexto não for algum tipo de digit, diga não.
Adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, diga sim.
Repita.

Etapas necessárias para que se determine se um string é algum tipo de mixed literal:
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, diga não.
Se o target deste first deste subtexto não for algum tipo de numeric starter, diga não.
Se o target deste first deste subtexto for algum tipo de sign, adicione 1 para o first deste subtexto.
Split o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
Se o integer subtexto não for algum tipo de integer literal, diga não.
Se a fração subtexto não for algum tipo de fração literal, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é algum tipo de numeric literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string não for algum tipo de numeric starter, diga não.
Se o string é algum tipo de integer literal, diga sim.
Se o string é algum tipo de fração literal, diga sim.
Se o string é algum tipo de mixed literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é algum tipo de sign:
Se o quantidade de caracteres deste string não for 1, diga não.
Se o target deste first deste string é algum tipo de sign, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é algum tipo de palavra:
Se o quantidade de caracteres deste string for menor do que 2, diga não.
Lance um subtexto sobre o string.
Subtraia 1 from o first deste subtexto.
Percorra.
Adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, diga sim.
Se o target deste first deste subtexto for algum tipo de letra, repita.
Se o target deste first deste subtexto for o single-quote pedaço, repita.
Diga não.

Etapas necessárias para que se determine se um string está em branco:
\ assume true
Intel $B801000000. \ mov eax,1
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o string
\ if first for 0, exit
Intel $833B00. \ cmp [ebx],0
Intel $0F8410000000. \ je end
\ if last for menor do que first, exit
Intel $8B5304. \ mov edx,[ebx+4] \ last endereço de memória
Intel $3B13. \ cmp edx,[ebx]
Intel $0F8C05000000. \ jl end
\ Diga não.:
Intel $B800000000. \ mov eax,0
\ END:

Etapas necessárias para que se determine se um string é um pedaço:
Se o quantidade de caracteres deste string não for 1, diga não.
Se o target deste first deste string é o pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é dos-compatible:
Se o string estiver em branco, diga não.
Se o target deste first deste string é o ponto final, diga não.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, diga sim.
Se o target deste first deste subtexto for o slash pedaço, diga não.
Se o target deste first deste subtexto for a barra invertida, diga não.
Se o target deste first deste subtexto for o sinal de dois pontos, diga não.
Se o target deste first deste subtexto for o asterisco, diga não.
Se o target deste first deste subtexto for o ponto de interrogação, diga não.
Se o target deste first deste subtexto for as aspas duplas, diga não.
Se o target deste first deste subtexto for o left-alligator pedaço, diga não.
Se o target deste first deste subtexto for o right-alligator pedaço, diga não.
Se o target deste first deste subtexto for o barra vertical, diga não.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se determine se um string é maior que uma segunda string;
Etapas necessárias para que se determine se um string é maior do que uma segunda string:
Compare o string para a segunda string usando o quantidade de caracteres deste string e o quantidade de caracteres deste segunda string devolvendo um número.
Se o número for maior do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é maior do que]ou igual para uma segunda string;
Etapas necessárias para que se determine se um string é maior que ou igual para uma segunda string;
Etapas necessárias para que se determine se um string é maior ou igual para uma segunda string:
Compare o string para a segunda string usando o quantidade de caracteres deste string e o quantidade de caracteres deste segunda string devolvendo um número.
Se o número for maior do que ou igual a 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um string estiver em uma segunda string:
Lance um subtexto sobre a segunda string.
Atribua o first deste subtexto mais o quantidade de caracteres deste string menos 1 ao last deste subtexto.
Percorra.
Se o last deste subtexto for maior do que o last deste segunda string, diga não.
Se o subtexto é o string, diga sim.
Mova o subtexto usando 1.
Repita.

Etapas necessárias para que se determine se um string estiver em um catálogo:
Se o catálogo for inexistente, diga não.
Se o string estiver em branco, diga não.
Encontre um refer usando o string e o catálogo.
Se o refer for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é menor que uma segunda string;
Etapas necessárias para que se determine se um string é menor do que uma segunda string:
Compare o string para a segunda string usando o quantidade de caracteres deste string e o quantidade de caracteres deste segunda string devolvendo um número.
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é menor do que ou igual para uma segunda string;
Etapas necessárias para que se determine se um string é menor que ou igual para uma segunda string;
Etapas necessárias para que se determine se um string é menor ou igual para uma segunda string:
Compare o string para a segunda string usando o quantidade de caracteres deste string e o quantidade de caracteres deste segunda string devolvendo um número.
Se o número for menor do que ou igual a 0, diga sim.
Diga não.

 \ needs work por Spanish
Etapas necessárias para que se determine se um string está escrito incorretamente:
Se o lexicon for inexistente, diga não.
Se o string não for algum tipo de palavra, diga não.
Isole o string.
Se o string termina com "'s", remove os last dois pedaços from o string.
Se o string estiver no catálogo deste lexicon, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é wider do que uma caixa:
\ assumes font estiver selecionado sobre memory canvas
Obtenha um abca e um abcc usando o string e o memory canvas.
Obtenha um largura usando o string e o memory canvas.
Subtraia o abca from o largura.
Subtraia o abcc from o largura.
Se o largura for maior do que a largura desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um subtexto está sobre alguma espécie de contração:
Atribua o first deste subtexto mais 1 a um endereço de memória do pedaço .
Se o endereço de memória do pedaço for maior do que o last deste subtexto, diga não.
Se o target deste first deste subtexto não for o single-quote pedaço, diga não.
Se o target deste endereço de memória do pedaço não for algum tipo de letra, diga não.
Diga sim.

Etapas necessárias para que se determine se um terminal está full:
Atribua a altura deste terminal dividido por 24 pixels a um número.
Se a contagem destes quoras deste terminal for maior do que o número, diga sim.
Diga não.

Etapas necessárias para que se determine se um text pode ser refeito:
Se o text for inexistente, diga não.
Se o last destes redos deste text for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um text pode ser desfeito:
Se o text for inexistente, diga não.
Se o last destes undos deste text for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um text foi alterado:
Se o text for inexistente, diga não.
Se o detector de alteração deste text estiver ativo, diga sim.
Diga não.

Etapas necessárias para que se determine se existe something para backspace em um text:
Se o text for inexistente, diga não.
Se something estiver selecionado no text, diga sim.
Se o número de linhas do cursor deste text não for 1, diga sim.
Se o caret column# deste text não for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se existe something para remove em um text:
Se o text for inexistente, diga não.
Se something estiver selecionado no text, diga sim.
Se o número de linhas do cursor deste text não for a contagem de linhas deste text, diga sim.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Se o caret column# deste text não for o quantidade de caracteres deste string desta row, diga sim.
Diga não.

Etapas necessárias para que se determine se existe text sobre o área de transferência do Windows:
Call "user32.dll" "IsClipboardFormatAvailable" com 1 [cf_text] devolvendo um número.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se uns coisas estão vazio:
Se o first destas coisas for inexistente, diga sim.
Diga não.

Etapas necessárias para que se determine se um vocábulo é numeric:
Isole o vocábulo.
Remove algum tipo de leading noise from o vocábulo.
Se o vocábulo estiver em branco, diga não.
Percorra.
Obtenha um pedaço from o vocábulo.
Se o pedaço não for algum tipo de digit, diga não.
Se o vocábulo estiver em branco, diga sim.
Repita.

Etapas necessárias para que se determine se o usuário está clicking em umas choices;
Etapas necessárias para que se determine se o usuário has clicked em umas choices;
Etapas necessárias para que se determine se o usuário clicked em umas choices;
Etapas necessárias para que se determine se o usuário clicks em umas choices;
Etapas necessárias para que se determine se o usuário está clicking sobre umas choices;
Etapas necessárias para que se determine se o usuário has clicked sobre umas choices;
Etapas necessárias para que se determine se o usuário clicked sobre umas choices;
Etapas necessárias para que se determine se o usuário clicks sobre umas choices:
Etapas necessárias para que se determine se o usuário clickou sobre umas choices:
Etapas necessárias para que se determine se o usuário clicou sobre umas choices:
Etapas necessárias para que se determine se o usuário clickou em umas choices:
Etapas necessárias para que se determine se o usuário clicou em umas choices:
Percorra.
Se o botão esquerdo deste mouse não estiver para baixo, diga não.
Encontre uma choice usando o spot deste mouse.
Se a choice can't ser found, diga não.
Diga sim.

Etapas necessárias para que se determine se o usuário clicou em um command:
Se o spot deste mouse estiver em este command, diga sim.
Diga não.

Etapas necessárias para que se determine se o mouse está em cima de um command:
Atribua o spot deste mouse a um spot.
Se o spot estiver em este command, diga sim.
\Se o spot deste mouse estiver na caixa arredondada deste command, diga sim.
Diga não.

Etapas necessárias para que se determine se we pode encontre um endereço de memória:
\ deveria ser "can" not "ca", compilador bug
Se o endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se we could encontre um endereço de memória:
Se o endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se we did encontre um endereço de memória:
Se o endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se we're above uma caixa:
Se a coordenada y deste context for menor do que a coordenada superior desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're above uma coordenada:
Se a coordenada y deste context for menor do que a coordenada, diga sim.
Diga não.

Etapas necessárias para que se determine se we're above um horizontal line:
Se o spot deste context é above o horizontal line, diga sim.
Diga não.

Etapas necessárias para que se determine se we're above ou below uma caixa:
Se a coordenada y deste context for menor do que a coordenada superior desta caixa, diga sim.
Se a coordenada y deste context for maior do que a coordenada inferior desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're above um spot:
Se a coordenada y deste context for menor do que o y deste spot, diga sim.
Diga não.

Etapas necessárias para que se determine se we're below uma caixa:
Se a coordenada y deste context for maior do que a coordenada inferior desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're below uma coordenada:
Se a coordenada y deste context for maior do que a coordenada, diga sim.
Diga não.

Etapas necessárias para que se determine se we're below um horizontal line:
Se o spot deste context é below o horizontal line, diga sim.
Diga não.

Etapas necessárias para que se determine se we're below um spot:
Se a coordenada y deste context for maior do que o y deste spot, diga sim.
Diga não.

Etapas necessárias para que se determine se we're facing north:
\ *** need east, south, west
Normalize a orientação deste context.
Se a orientação deste context for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se we're left of uma caixa:
Se a coordenada x deste context for menor do que a coordenada esquerda desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're left ou right of uma caixa:
Se a coordenada x deste context for menor do que a coordenada esquerda desta caixa, diga sim.
Se a coordenada x deste context for maior do que a coordenada direita desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're outside uma caixa:
Se o spot deste context é outside a caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're right of uma caixa:
Se a coordenada x deste context for maior do que a coordenada direita desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're still em uma caixa;
Etapas necessárias para que se determine se we're em uma caixa:
Se o spot deste context estiver na caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're within uns twips of uma caixa:
Se o spot deste context está within os twips of a caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se you feel like it:
Escolha aleatoriamente um número between 1 e 100.
Se o número for menor do que 51, diga sim.
Diga não.

Etapas necessárias para que se decrypt um trecho usando um passphrase string:
\ sets erro do fluxo de entrada/saída if failure
Limpe o erro do fluxo de entrada/saída.
Crie um crypt session usando o passphrase.
Se o crypt session for inexistente, cancele.
Converta o trecho como um cifra hexadecimal para um texto hexadecimal.
Atribua o quantidade de caracteres deste texto hexadecimal a um quantidade de caracteres.
Call "advapi32.dll" "CryptDecrypt" com a hcryptkey desta crypt session e 0 e 1 e 0 e o first deste texto hexadecimal And o endereçamento deste quantidade de caracteres devolvendo um result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de tentar decifrar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
Destrua o crypt session.
Atribua o texto hexadecimal ao trecho.

O fonte padrão é uma font.

O default smtp server é "localhost".

Um degree é um número [cujos valores variam entre 0 até 359].

Um depth é uns twips.

Um description é um string.

Etapas necessárias para que se desselecione um text:
Se o text for inexistente, cancele.
Atribua o caret deste text ao anchor deste text.

Etapas necessárias para que se destrua um crypt session:
Se o crypt session for inexistente, cancele.
Call "advapi32.dll" "CryptDestroyKey" com a hcryptkey desta crypt session.
Call "advapi32.dll" "CryptDestroyHash" com o hcrypthash desta crypt session.
Call "advapi32.dll" "CryptReleaseContext" com o hcryptprov desta crypt session e 0.
Desaloque o crypt session.

Etapas necessárias para que se destrua um gpimage:
Se o gpimage for inexistente, cancele.
Call "gdiplus.dll" "GdipDisposeImage" com o gpimage.
Esvazie o gpimage.

Etapas necessárias para que se destrua um gpimageattributes:
Se o gpimageattributes for inexistente, cancele.
Call "gdiplus.dll" "GdipDisposeImageAttributes" com o gpimageattributes.
Esvazie o gpimageattributes.

Etapas necessárias para que se destrua o hbrush of um canvas:
Call "gdi32.dll" "SelectObject" com o canvas e o null hbrush devolvendo um hbrush.
Call "gdi32.dll" "DeleteObject" com o hbrush.

Etapas necessárias para que se destrua o número da fonte of um canvas:
Call "gdi32.dll" "SelectObject" com o canvas e o null número da fonte devolvendo um número da fonte.
Call "gdi32.dll" "DeleteObject" com o número da fonte.

Etapas necessárias para que se destrua o hpen of um canvas:
Call "gdi32.dll" "SelectObject" com o canvas e o null hpen devolvendo um hpen.
Call "gdi32.dll" "DeleteObject" com o hpen.

Etapas necessárias para que se destrua um hrgn:
Call "gdi32.dll" "DeleteObject" com o hrgn.

Etapas necessárias para que se destrua um catálogo:
Se o catálogo for inexistente, cancele.
Percorra.
Obtenha um bucket usando o catálogo.
Se o bucket for inexistente, pare.
Destrua os refers deste bucket.
Repita.
Unassign o first bucket deste catálogo.
Desaloque o catálogo.

Etapas necessárias para que se destrua um endereço completo no sistema de arquivos:
Defina o endereço completo para read-write mode.
Se o endereço completo é endereço da pasta-format, destrua o endereço completo no sistema de arquivos (pasta)[endereço].
Se o endereço completo é file-format, destrua o endereço completo no sistema de arquivos (arquivo).

Etapas necessárias para que se destrua um endereço completo no sistema de arquivos (pasta)[endereço]:
Percorra.
Obtenha um item from o endereço completo.
Se o item não for found, pare.
Atribua o endereço completo a uma segunda endereço completo.
Posponha o designador deste item para a segunda endereço completo.
Destrua a segunda endereço completo no sistema de arquivos.
Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
Repita.
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "RemoveDirectoryA" com o first deste endereço completo devolvendo um número.
Limpe o erro do fluxo de entrada/saída.
Se o número não for 0, cancele.
Atribua "Erro. Não foi possível apagar a pasta: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se destrua uma endereço completo no sistema de arquivos (arquivo):
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "DeleteFileA" com o first deste endereço completo devolvendo um número.
Limpe o erro do fluxo de entrada/saída.
Se o número não for 0, cancele.
Atribua "Erro. Não foi possível apagar o arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se destrua uma picture:
Se o picture for inexistente, cancele.
Destrua o gpbitmap desta picture.
Desaloque o picture.

Etapas necessárias para que se destrua um socket:
Call "ws2_32.dll" "closesocket" com o socket.

Etapas necessárias para que se destrua um vértice usando um polígono:
Se o vértice for inexistente, cancele.
Se o polígono for inexistente, cancele.
Isole o vértice.
Remove o vértice from os vértices deste polígono.
Destrua o vértice.

Etapas necessárias para que se destrua um winhttp request:
Se o winhttp request for inexistente, cancele.
Call "winhttp.dll" "WinHttpCloseHandle" com a request deste winhttp request.
Call "winhttp.dll" "WinHttpCloseHandle" com a connection deste winhttp request.
Call "winhttp.dll" "WinHttpCloseHandle" com a session desta request deste winhttp.
Deallocate o winhttp request.

Um devmode é um conjunto com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-devmodea
\A estrutura de dados DEVMODE contém informações sobre a inicialização e o ambiente de uma impressora ou dispositivo de exibição.
32 pedaços denominado dmDeviceName, \ Um array de caracteres terminado em zero que especifica o nome "amigável" da impressora ou monitor; 
\por exemplo, "PCL / HP LaserJet" no caso de PCL / HP LaserJet. 
\Esta string é única entre os drivers de dispositivo. 
\Observe que esse nome pode ser truncado para caber na matriz dmDeviceName.
Um wyrd denominado dmSpecVersion, \ O número da versão da especificação de dados de inicialização na qual a estrutura é baseada. 
\Para garantir que a versão correta seja usada para qualquer sistema operacional, use DM_SPECVERSION.
Um wyrd denominado dmDriverVersion, \ O número da versão do driver atribuído pelo desenvolvedor do driver.
Um wyrd denominado dmSize,\ Especifica o tamanho, em bytes, da estrutura DEVMODE, sem incluir nenhum dado específico do driver particular que possa seguir os membros públicos da estrutura.
\Defina este membro como sizeof (DEVMODE) para indicar a versão da estrutura DEVMODE que está sendo usada.
Um wyrd denominado dmDriverExtra, \ Contém o número de bytes de dados de driver privados que seguem esta estrutura. 
\Se um driver de dispositivo não usar informações específicas do dispositivo, defina este membro como zero.
Um número denominado dmFields, \ Especifica se determinados membros da estrutura DEVMODE foram inicializados. 
\Se um membro é inicializado, seu bit correspondente é definido, caso contrário, o bit é limpo. 
\Um driver oferece suporte apenas aos membros DEVMODE apropriados para a impressora ou tecnologia de vídeo.
Um wyrd denominado dmOrientation, \ Somente para dispositivos de impressora, seleciona a orientação do papel. 
\Este membro pode ser DMORIENT_PORTRAIT (1) ou DMORIENT_LANDSCAPE (2).
Um wyrd denominado dmPaperSize, \ Somente para dispositivos de impressora, seleciona o tamanho do papel para imprimir. 
\Este membro pode ser definido como zero se o comprimento e a largura do papel forem definidos pelos membros dmPaperLength e dmPaperWidth. 
\Caso contrário, o membro dmPaperSize pode ser definido como um valor específico do dispositivo maior ou igual a DMPAPER_USER entre outros valores possíveis.
Um wyrd denominado dmPaperLength, \Apenas para dispositivos de impressora, substitui o comprimento do papel especificado pelo membro dmPaperSize, 
\para tamanhos de papel personalizados ou para dispositivos como impressoras matriciais que podem imprimir em uma página de comprimento arbitrário. 
\Esses valores, junto com todos os outros valores nesta estrutura que especificam um comprimento físico, estão em décimos de milímetro.
Um wyrd denominado dmPaperWidth, \ Somente para dispositivos de impressora, substitui a largura do papel especificada pelo membro dmPaperSize.
Um wyrd denominado dmScale, \ Especifica o fator pelo qual a saída impressa deve ser dimensionada. 
\O tamanho aparente da página é dimensionado do tamanho da página física por um fator de dmScale / 100. 
\Por exemplo, uma página de tamanho carta com um valor dmScale de 50 conteria tantos dados quanto uma página de 17 por 22 polegadas 
\porque o texto de saída e os gráficos teriam metade da altura e largura originais.
Um wyrd denominado dmCopies, \ Seleciona o número de cópias impressas se o dispositivo oferecer suporte a cópias de várias páginas.
Um wyrd denominado dmDefaultSource, \ Especifica a origem do papel. 
\Para recuperar uma lista das origens de papel disponíveis para uma impressora, use a função DeviceCapabilities com o sinalizador DC_BINS.
\ Pode ser um valor específico do dispositivo, sendo maior do que ou igual a DMBIN_USER.
Um wyrd denominado dmPrintQuality, \ Especifica a resolução da impressora. Existem quatro valores predefinidos independentes de dispositivo:
\Se um valor positivo for especificado, ele especifica o número de pontos por polegada (DPI) e, portanto, depende do dispositivo.
Um wyrd denominado dmColor, \ Alterna entre o modo colorido e monocromático em impressoras coloridas.
Um wyrd denominado dmDuplex, \Seleciona impressão duplex ou frente e verso para impressoras com capacidade de impressão duplex.
Um wyrd denominado dmYResolution, \ Especifica a resolução y, em pontos por polegada, da impressora. 
\Se a impressora inicializar este membro, o membro dmPrintQuality especifica a resolução x, em pontos por polegada, da impressora.
Um wyrd denominado dmTTOption, \ Especifica como as fontes TrueType devem ser impressas. E
Um wyrd denominado dmCollate, \ Especifica se o agrupamento deve ser usado ao imprimir várias cópias.
\ (Este membro é ignorado, a menos que o driver da impressora indique suporte para agrupamento, definindo o membro dmFields como DM_COLLATE.)
32 pedaços denominado dmFormName, \ Uma matriz de caracteres terminada em zero que especifica o nome do formulário a ser usado; por exemplo, "Carta" ou "Legal".
\ Um conjunto completo de nomes pode ser recuperado usando a função EnumForms.
Um wyrd denominado dmLogPixels, \ O número de pixels por polegada lógica. Drivers de impressora não usam este membro.
Um número denominado dmBitsPerPel, \ Especifica a resolução da cor, em bits por pixel, do dispositivo de exibição (por exemplo: 4 bits para 16 cores, 8 bits para 256 cores ou 16 bits para 65.536 cores). 
\Os drivers de vídeo usam esse membro, por exemplo, na função ChangeDisplaySettings. Drivers de impressora não usam este membro.
Um número denominado dmPelsWidth, \ Especifica a largura, em pixels, da superfície visível do dispositivo. 
\Os drivers de vídeo usam esse membro, por exemplo, na função ChangeDisplaySettings. Drivers de impressora não usam este membro.
Um número denominado dmPelsHeight, \ Especifica a altura, em pixels, da superfície visível do dispositivo. 
\Os drivers de vídeo usam esse membro, por exemplo, na função ChangeDisplaySettings. Drivers de impressora não usam este membro.
Um número denominado dmDisplayFlags, \ Especifica o modo de exibição do dispositivo. Os drivers de vídeo usam esse membro, por exemplo, na função ChangeDisplaySettings. 
\Drivers de impressora não usam este membro.
Um número denominado dmDisplayFrequency, \ Especifica a frequência, em hertz (ciclos por segundo), do dispositivo de exibição em um modo particular. 
\Este valor também é conhecido como taxa de atualização vertical do dispositivo de exibição. Drivers de vídeo usam este membro. 
\É usado, por exemplo, na função ChangeDisplaySettings. Drivers de impressora não usam este membro.
\Quando você chama a função EnumDisplaySettings, o membro dmDisplayFrequency pode retornar com o valor 0 ou 1. 
\Esses valores representam a taxa de atualização padrão do hardware de vídeo. 
\Essa taxa padrão é normalmente definida por interruptores em uma placa de vídeo ou placa-mãe de computador, 
\ou por um programa de configuração que não usa funções de vídeo, como ChangeDisplaySettings.
Um número denominado dmICMMethod, \Especifica como o ICM é tratado. Para um aplicativo não ICM, este membro determina se o ICM está habilitado ou desabilitado. 
\Para aplicativos ICM, o sistema examina esse membro para determinar como lidar com o suporte ICM.
Um número denominado dmICMIntent, \ O driver da impressora deve fornecer uma interface de usuário para configurar este membro. 
\A maioria dos drivers de impressora suporta apenas o valor DMICMMETHOD_SYSTEM ou DMICMMETHOD_NONE. Os drivers para impressoras PostScript suportam todos os valores.
Um número denominado dmMediaType, \ Especifica qual método de correspondência de cores, ou intenção, deve ser usado por padrão. 
\Este membro é principalmente para aplicativos não ICM. Os aplicativos ICM podem estabelecer intenções usando as funções ICM.
Um número denominado dmDitherType, \ Especifica o tipo de mídia que está sendo impressa.
\Para recuperar uma lista dos tipos de mídia disponíveis para uma impressora, use a função DeviceCapabilities com o sinalizador DC_MEDIATYPES.
Um número denominado dmReserved1, \ Não usado; deve ser zero.
Um número denominado dmReserved2. \ Não usado; deve ser zero.

Um difference é um pair.

Um file é um número identificador.

Um nome do arquivo é um string. \ after o last slash para end of endereço completo = file.ext
Um nome do arquivo s/ extensão é um string. \ after o last slash para last dot ou end of endereço completo = file
Um extensão é um string. \ last dot para end of endereço completo = .ext
Um endereço da pasta é um endereço completo. \ start of endereço completo para last slash inclusive = c:\folder1\folder2\
Um endereço completo é um string. \ complete nome = c:\folder1\folder2\file.ext
Um nome do diretório é um string. \ rightmost endereço da pasta com slash = folder2\
Um designador é um string. \ rightmost endereço da pasta com slash = folder2\ ou after o last slash para end of endereço completo = file.ext
Um nome da pasta é um string. \ rightmost endereço da pasta sem slash = folder2
Um unidade de disco é um string. \ start of endereço completo para first slash = c:\ ou start of endereço completo para quarto slash = \\computer\share\
Um unidade de rede é um string. \ é basicamente o número de cópias da variável anterior.
Um categoria da unidade de disco é um string.

Um nome da unidade de disco é um string.

Um distance é uns twips.

Etapas necessárias para que se divida uma fração por uma segunda fração:
Isole a segunda fração.
Flip a segunda fração.
Multiplique a fração pela segunda fração.

Etapas necessárias para que se divida uma fração por um número:
Multiplique o denominador desta fração pelo número.
Reduce a fração.

Etapas necessárias para que se divida um número por um fração:
Isole a fração.
Flip a fração.
Multiplique o número pela fração.

Etapas necessárias para que se divida um pair por uma segunda pair:
Divida o número x deste pair pelo número x deste segunda pair.
Divida o número y deste pair pelo número y deste segunda pair.

Etapas necessárias para que se divida um pair por um número:
Divida o número x deste pair pelo número.
Divida o número y deste pair pelo número.

Etapas necessárias para que se divida um pair por um número e uma segunda número:
Divida o número x deste pair pelo número.
Divida o número y deste pair pelo segunda número.

Etapas necessárias para que se divida um endereço de memória por um número;
Etapas necessárias para que se divida um número por uma segunda número:
Se a segunda número for 0, atribua o maior número ao número; exit.
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda número
Intel $8B00. \ mov eax,[eax]
Intel $99. \ cdq
Intel $F73B. \ div [ebx] \ means div eax,[ebx] but é weird form
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se divida um endereço de memória por um número usando um quotient e um resto;
Etapas necessárias para que se divida um número por uma segunda número usando um quotient e um resto:
Se a segunda número for 0, atribua o maior número ao quotient; atribua 0 ao resto; exit.
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda número
Intel $8B00. \ mov eax,[eax]
Intel $99. \ cdq
Intel $F73B. \ idiv [ebx] \ means idiv eax,[ebx] but é weird form
Intel $8B9D10000000. \ mov ebx,[ebp+16] \ o quotient
Intel $8903. \ mov [ebx],eax
Intel $8B9D14000000. \ mov ebx,[ebp+20] \ o resto
Intel $8913. \ mov [ebx],edx

Um docinfo é um conjunto com
Um número denominado cbsize,
Um endereço de memória denominado lpszdocname,
Um endereço de memória denominado lpszoutput,
Um endereço de memória denominado lpszdatadtype,
Um número denominado fwtype.

Um dot é um elipse.

Etapas necessárias para que se double um número:
Adicione o número para o número.

Etapas necessárias para que se pinte e fill uma caixa com uma cor:
Pinte a caixa com a cor e a cor.

Etapas necessárias para que se pinte algum tipo de visível rows of um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver visível, repita.
Pinte a row of o text.
Repita.

Etapas necessárias para que se pinte algum tipo de visível rows of um text (editing):
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não for visível, repita.
Pinte a row of o text (editing).
Repita.

Etapas necessárias para que se pinte uma caixa:
Pinte a caixa com a cor preta e a cor branca.

Etapas necessárias para que se pinte uma caixa (focus style):
Isole a caixa.
Adicione o tpp para o canto inferior direito desta caixa.
Call "gdi32.dll" "LPtoDP" com o quadro atual e o endereçamento desta caixa e 2.
Converta a cor branca para um código da cor.
Call "gdi32.dll" "SetBkColor" com o quadro atual e o código da cor.
Converta a cor preta para uma segunda código da cor.
Call "gdi32.dll" "SetTextColor" com o quadro atual e a segunda código da cor.
Call "gdi32.dll" "SetMapMode" com o quadro atual e 1 [mm_text].
Call "user32.dll" "DrawFocusRect" com o quadro atual e o endereçamento desta caixa.
Normalize o quadro atual.

Etapas necessárias para que se pinte uma caixa em uma cor:
\Etapas necessárias para que se pinte uma caixa com uma cor:
Pinte a caixa com a cor e a cor preta.

Etapas necessárias para que se pinte uma caixa com uma cor da borda e uma cor de preenchimento:
Se a página detector deste pdf state estiver ativo, pinte a caixa com a cor da borda e a cor de preenchimento (pdf style); exit.
Isole a caixa.
Crie o hpen of o quadro atual usando a cor da borda.
Crie o hbrush of o quadro atual usando a cor de preenchimento.
Se a cor da borda estiver clear, adicione o tpp para o canto superior esquerdo desta caixa.
Call "gdi32.dll" "Rectangle" com o quadro atual e a coordenada esquerda desta caixa e a coordenada superior desta caixa e a coordenada direita desta caixa e a coordenada inferior desta caixa.
Destrua o hbrush of o quadro atual.
Destrua o hpen of o quadro atual.

Etapas necessárias para que se pinte uma caixa com uma cor da borda e uma cor de preenchimento (pdf style):
Se a cor da borda e a cor de preenchimento são clear, cancele.
Output setcolor usando a cor da borda e a cor de preenchimento.
Output o canto inferior esquerdo desta caixa sem advancing.
Output o x-extent desta caixa sem advancing.
Output o y-extent desta caixa sem advancing.
Output "re".
Output stroke e fill usando a cor da borda e a cor de preenchimento.

Etapas necessárias para que se pinte o caret em um text:
Se o text for inexistente, cancele.
Obtenha uma caixa pelo caret no text.
Se a caixa não for touching a caixa deste text, cancele.
Atribua o canto superior esquerdo desta caixa e o canto inferior direito desta caixa a um line.
Pinte o line com a cor preta.

Etapas necessárias para que se pinte um circle about uns twips wide;
Etapas necessárias para que se pinte um circle usando um largura;
Etapas necessárias para que se pinte um circle uns twips em largura;
Etapas necessárias para que se pinte um circle uns twips wide:
Atribua os twips times o número pi dividido por 48 a um quantidade de caracteres do segmento.
Adicione 1 para o quantidade de caracteres do segmento.
Percorra.
Pinte o quantidade de caracteres do segmento.
Vire right 1/48 of o way.
Adicione 1 para uma contagem. Se a contagem for 48, pare.
Repita.

Etapas necessárias para que se pinte um circle uns twips wide (backwards);
Etapas necessárias para que se pinte um circle uns twips wide (counterclockwise):
Atribua os twips times o número pi dividido por 48 a um quantidade de caracteres do segmento.
Adicione 1 para o quantidade de caracteres do segmento.
Percorra.
Pinte o quantidade de caracteres do segmento.
Vire left 1/48 of o way.
Adicione 1 para uma contagem. Se a contagem for 48, pare.
Repita.

Etapas necessárias para que se pinte um console:
Se o console for inexistente, cancele.
Save o quadro atual.
Cubra somente fora de a caixa deste console .
Pinte a caixa deste console com a cor da borda deste console e a cor de preenchimento deste console.
Pinte o text deste console.
Restore o quadro atual.

Etapas necessárias para que se pinte um dot uns twips wide sobre o current spot com uma cor:
Make o dot os twips wide.
Centralize o dot sobre o spot deste context.
Pinte o dot com a cor.

Etapas necessárias para que se pinte um dot uns twips wide sobre um spot com uma cor:
Make o dot os twips wide.
Centralize o dot sobre o spot.
Pinte o dot com a cor.

Etapas necessárias para que se pinte um elipse:
Pinte a elipse com a cor preta e a cor branca.

Etapas necessárias para que se pinte um elipse sobre um spot com uma cor:
Centralize a elipse sobre o spot.
Pinte a elipse com a cor e a cor preta.

Etapas necessárias para que se pinte um elipse com uma cor da borda e uma cor de preenchimento:
Se a página detector deste pdf state estiver ativo, pinte a elipse com a cor da borda e a cor de preenchimento (pdf style); exit.
Isole a elipse.
Crie o hpen of o quadro atual usando a cor da borda.
Crie o hbrush of o quadro atual usando a cor de preenchimento.
Se a cor da borda estiver clear, adicione o tpp para o canto superior esquerdo desta elipse.
Call "gdi32.dll" "Ellipse" com o quadro atual e a coordenada esquerda desta elipse e a coordenada superior desta elipse e a coordenada direita desta elipse e a coordenada inferior desta elipse.
Destrua o hbrush of o quadro atual.
Destrua o hpen of o quadro atual.

Etapas necessárias para que se pinte um elipse com uma cor da borda e uma cor de preenchimento (pdf style):
Se a cor da borda e a cor de preenchimento são clear, cancele.
Output setcolor usando a cor da borda e a cor de preenchimento.
Atribua a coordenada esquerda desta elipse e a coordenada superior desta elipse a um spot.
Adicione o y-extent desta elipse dividido por 2 para a coordenada y deste spot.
Output moveto usando o spot.
Output o arco of a elipse usando "canto superior esquerdo".
Output o arco of a elipse usando "canto superior direito".
Output o arco of a elipse usando "canto inferior direito".
Output o arco of a elipse usando "canto inferior esquerdo ".
Output stroke e fill usando a cor da borda e a cor de preenchimento.

Etapas necessárias para que se pinte um elipse com uma cor:
Pinte a elipse com a cor e a cor.

Etapas necessárias para que se pinte um fancy arrow uns twips long com uma cor:
Atribua a cor à cor deste context.
Save o context.
Pinte os twips.
Vire around.
Mova os twips dividido por 8.
Save o context.
Vire left 1/8 of o way.
Pinte um spiral starting com os twips dividido por 4.
Restore o context.
Vire right 1/8 of o way.
Pinte uma segunda spiral backwards starting com os twips dividido por 4.
Restore o context.

Etapas necessárias para que se pinte um figura com uma cor:
Pinte a figura com a cor e a cor preta.

Etapas necessárias para que se pinte um figura com uns sides about uns twips wide:
Atribua 1 e o side contagem a um fração.
Atribua os twips times o número pi dividido pelo sides a um quantidade de caracteres do segmento.
Se o sides são 4, atribua os twips times 7/8 ao quantidade de caracteres do segmento. \ what é this? ***
Percorra.
Pinte o quantidade de caracteres do segmento.
Vire a fração.
Adicione 1 para uma contagem. 
Se a contagem for os sides, pare.
Repita.

Etapas necessárias para que se pinte um figura com uns sides uns twips long;
Etapas necessárias para que se pinte um figura com uns sides e uns twips:
Atribua 1 e o sides a um fração.
Percorra.
Pinte os twips.
Vire a fração.
Adicione 1 para uma contagem. Se a contagem é o sides, pare.
Repita.

Etapas necessárias para que se pinte um figura com uns sides uns twips long using uma cor;
Etapas necessárias para que se pinte um figura com uns sides e uns twips using uma cor:
Atribua a cor à cor deste context.
Pinte a figura com o sides e os twips.

Etapas necessárias para que se pinte um gpbitmap at um spot (pdf style):
Se o gpbitmap for inexistente, cancele.
\ adicione xobject
Adicione um xobject pdf object usando "image object".
Atribua "I" seguido de o número deste xobject a um nome.
\ adicione para image resources em current página
Atribua "/" seguido de o nome seguido de " " seguido de o número deste xobject seguido de " 0 R" a um string.
Crie um new conjunto de texto usando o string.
Posponha o new conjunto de texto para os image strings desta current página deste pdf state.
\ finish setting para cima xobject
Posponha o número deste xobject seguido de " 0 obj" para o xobject.
Posponha "<<" para o xobject.
Posponha "/Type /XObject" para o xobject.
Posponha "/Subtype /Image" para o xobject.
Posponha "/ColorSpace /DeviceRGB" para o xobject.
Posponha "/Width " seguido de o largura deste gpbitmap para o xobject.
Posponha "/Height " seguido de a altura deste gpbitmap para o xobject.
Posponha "/BitsPerComponent 8" para o xobject.
Converta o gpbitmap para um trecho (pdf style).
Converta o trecho para um cifra hexadecimal.
Posponha "/Filter /ASCIIHexDecode" para o xobject.
Posponha "/Length " seguido de o quantidade de caracteres deste cifra hexadecimal para o xobject.
Posponha ">>" para o xobject.
Posponha "stream" para o xobject.
Posponha o cifra hexadecimal para o xobject.
Posponha "endstream" para o xobject.
Posponha "endobj" para o xobject.
\ pinte o image no current contents
Atribua o largura deste gpbitmap times o tpp a um largura.
Atribua a altura deste gpbitmap times o tpp a uma altura.
Atribua a coordenada x deste spot a um número x.
Atribua a current altura deste pdf state menos a coordenada y deste spot menos o altura a um número y.
Output "q".
Output o largura seguido de " 0 0 " seguido de o altura seguido de " " seguido de o número x seguido de " " seguido de o número y seguido de " cm".
Output "/" seguido de o nome seguido de " Do".
Output "Q".

Etapas necessárias para que se pinte um half circle about uns twips wide;
Etapas necessárias para que se pinte um half circle usando um size:
Atribua o size times o número pi dividido por 48 a um quantidade de caracteres do segmento.
Adicione 1 para o quantidade de caracteres do segmento.
Percorra.
Pinte o quantidade de caracteres do segmento.
Vire right 1/48 of o way.
Adicione 1 para uma contagem.
Se a contagem for 24, cancele.
Repita.

Etapas necessárias para que se pinte um half circle usando um size (backwards);
Etapas necessárias para que se pinte um half circle usando um size (counterclockwise):
Atribua o size times o número pi dividido por 48 a um quantidade de caracteres do segmento.
Adicione 1 para o quantidade de caracteres do segmento.
Percorra.
Pinte o quantidade de caracteres do segmento.
Vire left 1/48 of o way.
Adicione 1 para uma contagem.
Se a contagem for 24, cancele.
Repita.

Etapas necessárias para que se pinte um hexagon usando um side quantidade de caracteres:
Pinte o side quantidade de caracteres.
Vire right 1/6 of o way.
Adicione 1 para uma contagem. Se a contagem for 6, pare.
Repita.

Etapas necessárias para que se pinte um line:
Pinte o line com a cor deste context.

Etapas necessárias para que se pinte um line around uns twips long; \ "around" é significante here
Etapas necessárias para que se pinte um line about uns twips long: \ "about" é significante here
\ "about" é significant here
Atribua os twips dividido por 2 a uns segunda twips.
Escolha aleatoriamente uns terceiro twips between os twips menos a segunda twips e os twips mais a segunda twips.
Pinte o line o terceiro twips long.

Etapas necessárias para que se pinte um line como tall como uma caixa com uma cor:
Atribua a cor à cor deste context.
Pinte a altura desta caixa.

Etapas necessárias para que se pinte um line como wide como uma caixa com uma cor:
Atribua a cor à cor deste context.
Pinte a largura desta caixa.

Etapas necessárias para que se pinte um line between uns twips e uns segunda twips long;
Etapas necessárias para que se pinte um line between uns twips para uns segunda twips long;
Etapas necessárias para que se pinte um line uns twips para uns segunda twips long:
Escolha aleatoriamente uns terceiro twips between os twips e a segunda twips.
Pinte o line o terceiro twips long.

Etapas necessárias para que se pinte um line uns twips long:
\Aguarde pelo delay. ***
Atribua o spot deste context ao start desta line.
Atribua o spot deste context ao end desta line.
Obtenha um deslocamento vertical e um deslocamento horizontal usando a orientação deste context.
Adicione o deslocamento horizontal times os twips dividido por 10000 para a coordenada x deste end desta line.
Adicione o deslocamento vertical times os twips dividido por 10000 para a coordenada y deste end desta line.
Atribua o end desta line ao spot deste context.
Pinte o line com a cor deste context.
\Se o delay é positive, atualize o tela.

Etapas necessárias para que se pinte um line using uns twips como o quantidade de caracteres;
Etapas necessárias para que se pinte um line using uns twips pelo quantidade de caracteres:
Pinte os twips.

Etapas necessárias para que se pinte um line com uma cor:
Se a página detector deste pdf state estiver ativo, pinte o line com a cor (pdf style); exit.
Crie o hpen of o quadro atual usando a cor.
Call "gdi32.dll" "MoveToEx" com o quadro atual e a coordenada x desta start desta line e a coordenada y desta start desta line e nil.
Call "gdi32.dll" "LineTo" com o quadro atual e a coordenada x deste end desta line e a coordenada y deste end desta line.
Converta a cor para um código da cor.
Call "gdi32.dll" "SetPixelV" com o quadro atual e a coordenada x deste end desta line e a coordenada y deste end desta line e o código da cor.
Destrua o hpen of o quadro atual.

Etapas necessárias para que se pinte um line com uma cor (pdf style):
Se a cor estiver clear, cancele.
Output setcolor usando a cor e a cor preta.
Output moveto usando o start desta line.
Output lineto usando o end desta line.
Output stroke e fill usando a cor e a cor preta.

Etapas necessárias para que se pinte um line com uma cor around uns twips long; \ "around" é significant here
Etapas necessárias para que se pinte um line com uma cor about uns twips long:\ "about" é significant here
\ "about" é significant here
Atribua os twips dividido por 2 a uns segunda twips.
Escolha aleatoriamente uns terceiro twips between os twips menos a segunda twips e os twips mais a segunda twips.
Pinte o line com a cor o terceiro twips long.

Etapas necessárias para que se pinte um line com uma cor uns twips long:
Atribua a cor à cor deste context.
Atribua o spot deste context ao start desta line.
Pinte os twips.
Atribua o spot deste context ao end desta line.

Etapas necessárias para que se pinte um line com uma cor uns twips para uns segunda twips long:
Escolha aleatoriamente uns terceiro twips between os twips e a segunda twips.
Pinte o line com a cor o terceiro twips long.

Etapas necessárias para que se pinte um número em uma caixa com uma cor:
Atribua o número a um string.
Pinte o string na caixa com a cor e "center".

Etapas necessárias para que se pinte only within uma caixa;
Etapas necessárias para que se pinte only inside uma caixa;
Etapas necessárias para que se pinte only em uma caixa;
Etapas necessárias para que se pinte only within uma caixa from now on;
Etapas necessárias para que se pinte only inside uma caixa from now on;
Etapas necessárias para que se pinte only em uma caixa from now on;
Etapas necessárias para que se only pinte within uma caixa from now on;
Etapas necessárias para que se only pinte inside uma caixa from now on;
Etapas necessárias para que se only pinte em uma caixa from now on;
Etapas necessárias para que se only pinte within uma caixa;
Etapas necessárias para que se only pinte inside uma caixa;
Etapas necessárias para que se only pinte em uma caixa;
Etapas necessárias para que se pinte within uma caixa only;
Etapas necessárias para que se pinte inside uma caixa only;
Etapas necessárias para que se pinte em uma caixa only;
Etapas necessárias para que se atribua masking tape all around uma caixa;
Etapas necessárias para que se atribua masking tape around uma caixa:
\ note that this masks a cor da borda da caixa as well
Isole a caixa.
Indent a caixa 1 pixel.
Cubra externamente a caixa.
Atribua o original caixa à caixa deste context. \ *** original caixa ? ou indented one?

Etapas necessárias para que se pinte um picture:
Se a página detector deste pdf state estiver ativo, pinte o picture (pdf style); exit.
Se o picture for inexistente, cancele.
Save o quadro atual.
Cubra externamente a caixa desta picture.
Call "gdiplus.dll" "GdipCreateFromHDC" com o quadro atual e o endereçamento desse gpgraphic.
Call "gdiplus.dll" "GdipSetPageUnit" com o gpgraphic e 2 [pixels].
Pinte o picture sobre o gpgraphic at a coordenada esquerda desta uncropped caixa desta picture e a coordenada superior desta uncropped caixa desta picture.
Call "gdiplus.dll" "GdipDeleteGraphics" com o gpgraphic.
Restore o quadro atual.

Etapas necessárias para que se pinte um picture (pdf style):
Se o picture for inexistente, cancele.
Atribua a coordenada esquerda desta caixa desta picture menos a coordenada esquerda desta uncropped caixa desta picture dividido pelo tpp a um número x.
Atribua a coordenada superior desta caixa desta picture menos a coordenada superior desta uncropped caixa desta picture dividido pelo tpp a um número y.
Atribua a largura desta caixa desta picture dividido pelo tpp a um largura.
Atribua a altura desta caixa desta picture dividido pelo tpp a uma altura.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com o largura e o altura e 0 e 137224 [pixelformat24bpprgb] e 0 e o endereçamento desse gpbitmap.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" com o gpbitmap e o endereçamento desse gpgraphic.
Se o grayscale detector desta picture estiver ativo, crie um gpimageattributes (grayscale).
Call "gdiplus.dll" "GdipDrawImageRectRectI" com o gpgraphic e o gpbitmap desta picture and 0 e 0 e o largura e o altura and o número x e o número y e o largura e o altura and 2 [unitpixel] e o gpimageattributes e nil e 0.
Se o gpimageattributes não for inexistente, destrua o gpimageattributes.
Call "gdiplus.dll" "GdipDeleteGraphics" com o gpgraphic.
Pinte o gpbitmap at o canto superior esquerdo desta caixa desta picture (pdf style).
Call "gdiplus.dll" "GdipDisposeImage" com o gpbitmap.

Etapas necessárias para que se pinte um picture sobre um gpgraphic at uma coordenada x e uma coordenada y:
Se o picture for inexistente, cancele.
Se o grayscale detector desta picture estiver ativo, crie um gpimageattributes (grayscale).
Call "gdiplus.dll" "GdipDrawImageRectRectI" com o gpgraphic e o gpbitmap desta picture And a coordenada x e a coordenada y e a largura desta uncropped caixa desta picture e a altura desta uncropped caixa desta picture And 0 e 0 e a largura deste gpbitmap desta picture e a altura deste gpbitmap desta picture And 2 [unitpixel] e o gpimageattributes e nil e 0.
Se o gpimageattributes não for inexistente, destrua o gpimageattributes.

Etapas necessárias para que se pinte um polígono:
Pinte o polígono com a cor preta e a cor branca.

Etapas necessárias para que se pinte um polígono com uma cor da borda e uma cor de preenchimento:
Se a página detector deste pdf state estiver ativo, pinte o polígono com a cor da borda e a cor de preenchimento (pdf style); exit.
Se o polígono for inexistente, cancele.
Pinte o polígono com a cor de preenchimento (fill only).
Pinte o polígono com a cor da borda (border only).

Etapas necessárias para que se pinte um polígono com uma cor da borda e uma cor de preenchimento (pdf style):
Se o polígono for inexistente, cancele.
Se a cor da borda e a cor de preenchimento são clear, cancele.
Output setcolor usando a cor da borda e a cor de preenchimento.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, cancele.
Output moveto usando o spot deste vértice.
Percorra.
Obtenha o vértice from os vértices deste polígono.
Se o vértice for inexistente, pare.
Output lineto usando o spot deste vértice.
Repita.
Output stroke e fill usando a cor da borda e a cor de preenchimento.

Etapas necessárias para que se pinte um polígono com uma cor:
Pinte o polígono com a cor e a cor.

Etapas necessárias para que se pinte um polígono com uma cor (border only):
Se o polígono for inexistente, cancele.
Se a cor estiver clear, cancele.
Crie o hpen of o quadro atual usando a cor.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, cancele.
Call "gdi32.dll" "MoveToEx" com o quadro atual e a coordenada x deste vértice e a coordenada y deste vértice e nil.
Percorra.
Obtenha o vértice from os vértices deste polígono.
Se o vértice for inexistente, pare.
Call "gdi32.dll" "LineTo" com o quadro atual e a coordenada x deste vértice e a coordenada y deste vértice.
Repita.
Destrua o hpen of o quadro atual.
Se o spot deste first destes vértices deste polígono for o spot deste last destes vértices deste polígono, cancele.
Converta a cor para um código da cor.
Call "gdi32.dll" "SetPixelV" com o quadro atual e a coordenada x deste last destes vértices deste polígono e a coordenada y deste last destes vértices deste polígono e o código da cor.

Etapas necessárias para que se pinte um polígono com uma cor (fill only):
Se o polígono for inexistente, cancele.
Se a cor estiver clear, cancele.
Crie o hpen of o quadro atual usando a cor preta.
Crie o hbrush of o quadro atual usando a cor.
Call "gdi32.dll" "SetPolyFillMode" com o quadro atual e 2 [winding].
Crie um vértice array usando os vértices deste polígono.
Call "gdi32.dll" "Polygon" com o quadro atual e o spot endereço de memória deste vértice array e a contagem deste vértice array.
Destrua o vértice array.
Destrua o hbrush of o quadro atual.
Destrua o hpen of o quadro atual.

Etapas necessárias para que se pinte um quarter circle about uns twips wide;
Etapas necessárias para que se pinte um quarter circle usando um size:
Atribua o size times o número pi dividido por 48 a um quantidade de caracteres do segmento.
Adicione 1 para o quantidade de caracteres do segmento.
Percorra.
Pinte o quantidade de caracteres do segmento.
Vire right 1/48 of o way.
Adicione 1 para uma contagem.
Se a contagem for 12, cancele.
Repita.

Etapas necessárias para que se pinte um quarter circle between uns twips e uns segunda twips wide:
Escolha aleatoriamente uns terceiro twips between os twips e a segunda twips.
Pinte um quarter circle usando o terceiro twips.

Etapas necessárias para que se pinte um quarter circle usando um size (counterclockwise):
Atribua o size times o número pi dividido por 48 a um quantidade de caracteres do segmento.
Adicione 1 para o quantidade de caracteres do segmento.
Percorra.
Pinte o quantidade de caracteres do segmento.
Vire left 1/48 of o way.
Adicione 1 para uma contagem.
Se a contagem for 12, cancele.
Repita.

Etapas necessárias para que se pinte um retângulo uns twips por uns segunda twips;
Etapas necessárias para que se pinte um retângulo uns twips wide por uns segunda twips high:
Pinte a segunda twips.
Vire right.
Pinte os twips.
Vire right.
Pinte a segunda twips.
Vire right.
Pinte os twips.
Vire right.

Etapas necessárias para que se pinte uma caixa arredondada:
Pinte a caixa arredondada com a cor preta e a cor branca.

Etapas necessárias para que se pinte uma caixa arredondada com uma cor da borda e uma cor de preenchimento:
Se a página detector deste pdf state estiver ativo, pinte a caixa arredondada com a cor da borda e a cor de preenchimento (pdf style); exit.
Isole a caixa arredondada.
Crie o hpen of o quadro atual usando a cor da borda.
Crie o hbrush of o quadro atual usando a cor de preenchimento.
Se a cor da borda estiver clear, adicione o tpp para o canto superior esquerdo desta caixa arredondada.
Atribua o raio desta caixa arredondada times 2 a um diameter número.
Call "gdi32.dll" "RoundRect" com o quadro atual e a coordenada esquerda desta caixa arredondada e a coordenada superior desta caixa arredondada e a coordenada direita desta caixa arredondada e a coordenada inferior desta caixa arredondada 
And o diameter e o diameter.
Destrua o hbrush of o quadro atual.
Destrua o hpen of o quadro atual.

Etapas necessárias para que se pinte uma caixa arredondada com uma cor da borda e uma cor de preenchimento (pdf style):
Se a cor da borda e a cor de preenchimento são clear, cancele.
Se o raio desta caixa arredondada for 0, pinte a caixa arredondada como uma caixa com a cor da borda e a cor de preenchimento (pdf style); exit.
Atribua o raio desta caixa arredondada a um raio.
Atribua o raio times 2 a um offset.
Atribua a caixa arredondada a uma caixa.
Output setcolor usando a cor da borda e a cor de preenchimento.
\ initial moveto
Output moveto usando a coordenada esquerda desta caixa e a coordenada superior desta caixa mais o raio.
\ canto superior esquerdo
Atribua a coordenada esquerda desta caixa e a coordenada superior desta caixa e a coordenada esquerda desta caixa mais o offset e a coordenada superior desta caixa mais o offset a um elipse.
Output o arco of a elipse usando "canto superior esquerdo".
Output lineto usando a coordenada direita desta caixa menos o raio e a coordenada superior desta caixa.
\ canto superior direito
Atribua a coordenada direita desta caixa menos o offset e a coordenada superior desta caixa e a coordenada direita desta caixa e a coordenada superior desta caixa mais o offset ao elipse.
Output o arco of a elipse usando "canto superior direito".
Output lineto usando a coordenada direita desta caixa e a coordenada inferior desta caixa menos o raio.
\ canto inferior direito
Atribua a coordenada direita desta caixa menos o offset e a coordenada inferior desta caixa menos o offset e a coordenada direita desta caixa e a coordenada inferior desta caixa ao elipse.
Output o arco of a elipse usando "canto inferior direito".
Output lineto usando a coordenada esquerda desta caixa mais o raio e a coordenada inferior desta caixa.
\ canto inferior esquerdo 
Atribua a coordenada esquerda desta caixa e a coordenada inferior desta caixa menos o offset e a coordenada esquerda desta caixa mais o offset e a coordenada inferior desta caixa ao elipse.
Output o arco of a elipse usando "canto inferior esquerdo ".
\ finish para cima
Output "h".
Output stroke e fill usando a cor da borda e a cor de preenchimento.

Etapas necessárias para que se pinte uma caixa arredondada com uma cor:
Pinte a caixa arredondada com a cor e a cor.

Etapas necessárias para que se pinte uma row of um text:
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Obtenha uma caixa usando a row e o text.
Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas necessárias para que se pinte uma row of um text (editing):
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Pinte a caixa de seleção pela row of o text.
Obtenha uma caixa usando a row e o text.
Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas necessárias para que se pinte a caixa de seleção por uma row of um text:
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, cancele.
Obtenha uma caixa de seleção usando a row e o text.
Pinte a caixa de seleção com o hilite cor e o hilite cor.

Etapas necessárias para que se pinte um spiral backward usando uns twips;
Etapas necessárias para que se pinte um spiral backward starting com uns twips;
Etapas necessárias para que se pinte um spiral usando um size (backwards):
Isole o size.
Percorra.
Pinte um half circle usando o size (backwards).
Divida o size por 2.
Adicione 1 para uma contagem.
Se a contagem for 5, pare.
Repita.

Etapas necessárias para que se pinte um spiral starting com uns twips;
Etapas necessárias para que se pinte um spiral usando um size:
Isole o size.
Percorra.
Pinte um half circle usando o size.
Divida o size por 2.
Adicione 1 para uma contagem. Se a contagem for 5, pare.
Repita.

Etapas necessárias para que se pinte um spot:
Pinte o spot com a cor preta.

Etapas necessárias para que se pinte um spot com uma cor:
Converta a cor para um código da cor.
Call "gdi32.dll" "SetPixelV" com o quadro atual e a coordenada x deste spot e a coordenada y deste spot e o código da cor.

Etapas necessárias para que se pinte um star usando um point contagem e um size:
Atribua 1 e o point contagem a um fração.
Percorra.
Vire right 1/48 of o way.
Pinte o size.
Vire around.
Vire left 1/24 of o way.
Pinte o size.
Vire around.
Vire right 1/48 of o way.
Vire right a fração of o way.
Adicione 1 para uma contagem. 
Se a contagem for o point contagem, pare.
Repita.

Etapas necessárias para que se pinte um string at o left of uma caixa:
Pinte o string at o left of a caixa com a cor preta e a fonte padrão.

Etapas necessárias para que se pinte um string at o left of uma caixa com uma cor:
Pinte o string at o left of a caixa com a cor e a fonte padrão.

Etapas necessárias para que se pinte um string at o left of uma caixa com uma cor e um font:
Pinte o string na caixa com a cor e o font e "left".

Etapas necessárias para que se pinte um string at o left of uma caixa com um font:
Pinte o string at o left of a caixa com a cor preta e o font.

Etapas necessárias para que se pinte um string at o right of uma caixa:
Pinte o string at o right of a caixa com a cor preta e a fonte padrão.

Etapas necessárias para que se pinte um string at o right of uma caixa com uma cor:
Pinte o string at o right of a caixa com a cor e a fonte padrão.

Etapas necessárias para que se pinte um string at o right of uma caixa com uma cor e um font:
Pinte o string na caixa com a cor e o font e "right".

Etapas necessárias para que se pinte um string at o right of uma caixa com um font:
Pinte o string at o right of a caixa com a cor preta e o font.

Etapas necessárias para que se pinte um string at um spot com uma cor:
Pinte o string at o spot com a cor e a fonte padrão.

Etapas necessárias para que se pinte um string at um spot com uma cor e um font:
Se a página detector deste pdf state estiver ativo, pinte o string at o spot com a cor e o font (pdf style); exit.
Defina o código da cor of o quadro atual usando a cor.
Crie o número da fonte of o quadro atual usando o font.
Ajuste spacing usando o string.
Atribua o first deste string ao first desse subtexto.
Atribua o first deste subtexto mais o text cutoff menos 1 ao last deste subtexto.
Isole o spot.
Percorra.
Se o subtexto estiver em branco, pare.
Se o last deste subtexto for maior do que o last deste string, atribua o last deste string ao last deste subtexto.
Call "gdi32.dll" "TextOutA" com o quadro atual e a coordenada x deste spot e a coordenada y deste spot e o first deste subtexto e o quantidade de caracteres deste subtexto.
Obtenha um largura usando o subtexto e o quadro atual.
Adicione o largura para a coordenada x deste spot.
Mova o subtexto usando o text cutoff.
Repita.
Destrua o número da fonte of o quadro atual.

Etapas necessárias para que se pinte um string at um spot com uma cor e uma font (pdf style):
Se o string estiver em branco, cancele.
Isole o spot.
Include o font no current pdf.
Include o font na current página deste pdf state.
Encontre um definition pdf object usando o nome desta font e o font catálogo deste pdf state.
Se o definition for inexistente, cancele. \ erro
Crie uma font info usando o font e o string.
Output o pdf border usando a cor.
Output o pdf fill usando a cor.
Output "BT".
Output "/" seguido de o nome da fonte desta definition seguido de " " seguido de a adjusted altura desta font seguido de " Tf".
\ adicione a adjusted altura desta font menos o internal leading desta font info para o y do spot. \ just plain wrong
Adicione o ascent desta font info para a coordenada y deste spot. \ fix por line above
Output o spot sem advancing.
Output "Td".
Output "[" sem advancing.
Converta o font info para pdf em units.
Converta o string e o font info e a font info desta definition a um trecho por pdf output.
Output o trecho sem advancing.
Output "]" sem advancing.
Output " TJ".
Output "ET".
Destrua o font info.

Etapas necessárias para que se pinte um string em uma caixa:
Pinte o string na caixa com a cor preta e a fonte padrão e "left".

Etapas necessárias para que se pinte um string em uma caixa over um número com uma cor e uma font e um alinhamento:
Isole a caixa.
Se o alinhamento for "left", adicione o número para a coordenada esquerda desta caixa.
Se o alinhamento for "zquierda", adicione o número para a coordenada esquerda desta caixa.
Se o alinhamento for "derecho", subtraia o número from a coordenada direita desta caixa.
Pinte o string na caixa com a cor e o font e o alinhamento.

Etapas necessárias para que se pinte um string em uma caixa com um alinhamento:
Pinte o string na caixa com a cor preta e a fonte padrão e o alinhamento.

Etapas necessárias para que se pinte um string em uma caixa com uma cor:
Pinte o string na caixa com a cor e a fonte padrão e "left".

Etapas necessárias para que se pinte um string em uma caixa com uma cor e um alinhamento:
Pinte o string na caixa com a cor e a fonte padrão e o alinhamento.

Etapas necessárias para que se pinte um string em uma caixa com uma cor e uma font e um alinhamento:
Obtenha um offset pair usando o string e a caixa e o font e o alinhamento.
Pinte o string at o canto superior esquerdo desta caixa mais o offset pair com a cor e o font.

Etapas necessárias para que se pinte um string em uma caixa com uma font e um alinhamento:
Pinte o string na caixa com a cor preta e o font e o alinhamento.

Etapas necessárias para que se pinte um string no center of uma caixa:
Pinte o string no center of a caixa com a cor preta e a fonte padrão.

Etapas necessárias para que se pinte um string no center of uma caixa com uma cor:
Pinte o string no center of a caixa com a cor e a fonte padrão.

Etapas necessárias para que se pinte um string no center of uma caixa com uma cor e um font:
Pinte o string na caixa com a cor e o font e "center".

Etapas necessárias para que se pinte um string no center of uma caixa com um font:
Pinte o string no center of a caixa com a cor preta e o font.

Etapas necessárias para que se pinte um terminal:
Se o terminal for inexistente, cancele.
Save o quadro atual.
Cubra somente fora de a caixa deste terminal.
Pinte e fill a caixa deste terminal com a cor preta.
Escreva os quoras deste terminal na caixa deste terminal.
Restore o quadro atual.

Etapas necessárias para que se pinte um text:
Se o text for inexistente, cancele.
Save o quadro atual.
Cubra externamente a caixa deste text.
Pinte algum tipo de visível rows of o text.
Restore o quadro atual.

Etapas necessárias para que se pinte um text (editing):
Se o text for inexistente, cancele.
Save o quadro atual.
Cubra externamente a caixa deste text.
Pinte algum tipo de visível rows of o text (editing).
Pinte o caret no text.
Restore o quadro atual.

Etapas necessárias para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos:
Se o endereço completo é endereço da pasta-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (pasta)[endereço].
Se o endereço completo é file-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (arquivo).

Etapas necessárias para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (pasta)[endereço]:
Se o endereço completo estiver no segunda endereço completo, atribua "Ocorreu um erro na hora de duplicar a pasta: " seguido de o endereço completo seguido de ". - erro de recursão inválida." ao erro do fluxo de entrada/saída; exit.
Se o endereço completo não estiver no sistema de arquivos, atribua "Ocorreu um erro na hora de duplicar a pasta: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.
Se a segunda endereço completo não estiver no sistema de arquivos, crie a segunda endereço completo no sistema de arquivos.
Percorra.
Obtenha um item from o endereço completo.
Se o item não for found, cancele.
Atribua o endereço completo a um terceiro endereço completo.
Posponha o designador deste item para o terceiro endereço completo.
Atribua a segunda endereço completo a um quarto endereço completo.
Posponha o designador deste item para o quarto endereço completo.
Duplicate o terceiro endereço completo para o quarto endereço completo no sistema de arquivos.
Repita.

Etapas necessárias para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (arquivo):
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Isole a segunda endereço completo.
Modifique através do caractere NUL a segunda endereço completo.
Call "kernel32.dll" "CopyFileA" com o first deste endereço completo e o first deste segunda endereço completo e 0 devolvendo um número.
Limpe o erro do fluxo de entrada/saída.
Se o número não for 0, defina o endereço completo para read-write mode; exit.
Atribua "Ocorreu um erro na hora de duplicar o arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

An dyad é uma coisa com
Um nome,
Um value string.

Uma elipse é um conjunto com uma caixa.

Um email é um conjunto com
Um smtp server,
Um sender,
Um recipient,
Um subject,
Um message.

Etapas necessárias para que se encrypt um trecho usando um passphrase string:
\ sets erro do fluxo de entrada/saída if failure
Limpe o erro do fluxo de entrada/saída.
Crie um crypt session usando o passphrase.
Se o crypt session for inexistente, cancele.
Atribua o trecho a um temp trecho.
Atribua o quantidade de caracteres deste temp trecho a um quantidade de caracteres.
Call "advapi32.dll" "CryptEncrypt" com a hcryptkey desta crypt session e 0 e 1 e 0 e o first deste temp trecho And o endereçamento deste quantidade de caracteres e o quantidade de caracteres devolvendo um result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de criptografar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
Destrua o crypt session.
Converta o temp trecho para um cifra hexadecimal.
Atribua o cifra hexadecimal ao trecho.

Etapas necessárias para que se end printing:
Se o documento detector deste pdf state estiver ativo, end printing (pdf style); exit.
Call "gdi32.dll" "EndDoc" com o printer canvas.
Finalize o printer canvas.

Etapas necessárias para que se end printing (pdf style):
Se o documento detector deste pdf state não estiver ativo, cancele.
End printing o target deste pdf endereço de memória deste pdf state.

Etapas necessárias para que se end printing um pdf:
End printing o pdf (finish o parent).
End printing o pdf (append o outline).
End printing o pdf (finish o root).
Limpe o pdf.
End printing o pdf (append header).
End printing o pdf (offset e posponha objects).
End printing o pdf (append xref table).
End printing o pdf (append trailer).
End printing o pdf (append footer).
Destrua o font catálogo deste pdf state.
Destrua as outline entries deste pdf state.
Destrua os objects deste pdf state.
Desative o documento detector deste pdf state.

Etapas necessárias para que se end printing um pdf (append footer):
Posponha "startxref" seguido de o texto CRLF para o pdf.
Posponha o xref offset deste pdf state seguido de o texto CRLF para o pdf.
Posponha "%%EOF" para o pdf.

Etapas necessárias para que se end printing um pdf (append header):
Posponha "%PDF-1.3" seguido de o texto CRLF para o pdf.
Posponha "%âãÏÓ" seguido de o texto CRLF para o pdf.
Posponha o texto CRLF para o pdf.

Etapas necessárias para que se end printing um pdf (append o outline entries - crie o objects):
Obtenha um pdf outline entry from as outline entries deste pdf state.
Se o pdf outline entry for inexistente, cancele.
Adicione um entry pdf object usando "outline entry".
Atribua a entry ao pdf object desta pdf outline entry.
Repita.

Etapas necessárias para que se end printing um pdf (append o outline entries):
Se as outline entries deste pdf state estiverem vazio, cancele.
End printing o pdf (append o outline entries - crie o objects).
Percorra.
Obtenha um pdf outline entry from as outline entries deste pdf state.
Se o pdf outline entry for inexistente, cancele.
Atribua o pdf object desta pdf outline entry a um object pdf object.
Posponha o número deste object seguido de " 0 obj" para o object.
Posponha "<<" para o object.
Converta o title deste pdf outline entry para um pdf string.
Posponha "/Title " seguido de o pdf string para o object.
Posponha "/Parent " seguido de o número deste outline deste pdf state seguido de " 0 R" para o object.
Se o next desta pdf outline entry não for inexistente, posponha "/Next " seguido de o número deste pdf object deste next desta pdf outline entry seguido de " 0 R" para o object.
Se o previous desta pdf outline entry não for inexistente, posponha "/Prev " seguido de o número deste pdf object deste previous desta pdf outline entry seguido de " 0 R" para o object.
Posponha "/Dest [" seguido de o destination deste pdf outline entry seguido de " 0 R /XYZ null " seguido de a página altura deste pdf outline entry seguido de " null]" para o object.
Posponha ">>" para o object.
Posponha "endobj" para o object.
Repita.

Etapas necessárias para que se end printing um pdf (append o outline):
Esvazie o outline deste pdf state.
Se as outline entries deste pdf state estiverem vazio, cancele.
Adicione um outline pdf object usando "outline".
Atribua o outline ao outline deste pdf state.
End printing o pdf (append o outline entries).
Posponha o número deste outline seguido de " 0 obj" para o outline.
Posponha "<<" para o outline.
Posponha "/Type /Outlines" para o outline.
Posponha "/First " seguido de o número deste pdf object deste first destas outline entries deste pdf state seguido de " 0 R" para o outline.
Posponha "/Last " seguido de o número deste pdf object deste last destas outline entries deste pdf state seguido de " 0 R" para o outline.
Posponha "/Count " seguido de a contagem destas outline entries deste pdf state para o outline.
Posponha ">>" para o outline.
Posponha "endobj" para o outline.

Etapas necessárias para que se end printing um pdf (append trailer):
Posponha "trailer" seguido de o texto CRLF para o pdf.
Posponha "<<" seguido de o texto CRLF para o pdf.
Atribua a contagem destes objects deste pdf state mais 1 a uma contagem.
Posponha "/Size " seguido de a contagem seguido de o texto CRLF para o pdf.
Posponha "/Root " seguido de o número deste root deste pdf state seguido de " 0 R" seguido de o texto CRLF para o pdf.
Posponha ">>" seguido de o texto CRLF para o pdf.
Posponha o texto CRLF para o pdf.

Etapas necessárias para que se end printing um pdf (append xref table):
Atribua o quantidade de caracteres deste pdf ao xref offset deste pdf state.
Posponha "xref" seguido de o texto CRLF para o pdf.
Atribua a contagem destes objects deste pdf state mais 1 a uma contagem.
Posponha "0 " seguido de a contagem seguido de o texto CRLF para o pdf.
Posponha "0000000000 65535 f" seguido de o texto CRLF para o pdf.
Percorra.
Obtenha um pdf object from os objects deste pdf state.
Se o pdf object for inexistente, pare.
Zero fill o offset deste pdf object usando 10 e posponha it para o pdf.
Posponha " 00000 n" seguido de o texto CRLF para o pdf.
Repita.
Posponha o texto CRLF para o pdf.

Etapas necessárias para que se end printing um pdf (finish o parent):
Atribua o parent deste pdf state a um parent pdf object.
Posponha "/Kids [" para o parent sem advancing.
Percorra.
Obtenha um pdf object from os objects deste pdf state.
Se o pdf object for inexistente, pare.
Se a categoria deste pdf object não for "page", repita.
Se um detector estiver ativo, posponha " " para o parent sem advancing.
Posponha o número deste pdf object seguido de " 0 R" para o parent sem advancing.
Ligue o detector.
Adicione 1 para uma contagem.
Se a contagem for uniformemente divisível por 20, posponha o texto CRLF seguido de " " para o parent sem advancing.
Repita.
Posponha "]" para o parent.
Posponha "/Count " seguido de a contagem para o parent.
Posponha ">>" para o parent.
Posponha "endobj" para o parent.

Etapas necessárias para que se end printing um pdf (finish o root):
Atribua o root deste pdf state a um root pdf object.
Posponha "/Pages " seguido de o número deste parent deste pdf state seguido de " 0 R" para o root.
Encontre um pdf object usando "page".
Posponha "/OpenAction [" seguido de o número deste pdf object seguido de " 0 R /XYZ null null 1]" para o root.
Posponha "/PageMode /UseNone" para o root.
Se o outline deste pdf state não for inexistente, posponha "/Outlines " seguido de o número deste outline deste pdf state seguido de " 0 R" para o root.
Posponha ">>" para o root.
Posponha "endobj" para o root.

Etapas necessárias para que se end printing um pdf (offset e posponha objects):
Obtenha um pdf object from os objects deste pdf state.
Se o pdf object for inexistente, pare.
Atribua o quantidade de caracteres deste pdf ao offset deste pdf object.
Posponha o data deste pdf object para o pdf.
Posponha o texto CRLF para o pdf.
Repita.

Etapas necessárias para que se end um sheet:
Se o documento detector deste pdf state estiver ativo, end o sheet (pdf style); exit.
Call "gdi32.dll" "EndPage" com o printer canvas.
Atribua o memory canvas ao quadro atual.
Atribua o saved tpp ao tpp.

Etapas necessárias para que se end um sheet (pdf style - finish o current contents):
Atribua os current contents deste pdf state a um content pdf object.
Atribua os data deste content a um trecho.
Limpe os data deste content.
Posponha o número deste content seguido de " 0 obj" para o content.
Posponha "<</Length " seguido de o quantidade de caracteres deste trecho seguido de " >>" para o content.
Posponha "stream" para o content.
Posponha o trecho para os data deste content.
Posponha "endstream" para o content.
Posponha "endobj" para o content.
Desative a página detector deste pdf state.

Etapas necessárias para que se end um sheet (pdf style - finish o current página - font resources):
Atribua a current página deste pdf state a uma página pdf object.
Se as font strings desta página estiverem vazio, cancele.
Posponha "/Font <<" para a página sem advancing.
Percorra.
Obtenha um conjunto de texto from as font strings desta página.
Se o conjunto de texto for inexistente, pare.
Se um detector estiver ativo, posponha " " para a página sem advancing.
Posponha o string deste conjunto de texto para a página sem advancing.
Ligue o detector.
Repita.
Posponha ">>" para a página.

Etapas necessárias para que se end um sheet (pdf style - finish o current página - image resources):
Atribua a current página deste pdf state a uma página pdf object.
Se as image strings desta página estiverem vazio, cancele.
Posponha "/XObject <<" para a página sem advancing.
Percorra.
Obtenha um conjunto de texto from as image strings desta página.
Se o conjunto de texto for inexistente, pare.
Se um detector estiver ativo, posponha " " para a página sem advancing.
Posponha o string deste conjunto de texto para a página sem advancing.
Ligue o detector.
Repita.
Posponha ">>" para a página.

Etapas necessárias para que se end um sheet (pdf style - finish o current página):
Atribua a current página deste pdf state a uma página pdf object.
Posponha "/Resources" para a página.
Posponha "<<" para a página.
Posponha "/ProcSet [/PDF /Text /ImageC]" para a página.
End o sheet (pdf style - finish o current página - font resources).
End o sheet (pdf style - finish o current página - image resources).
Posponha ">>" para a página. \ end resources
Posponha ">>" para a página. \ end página
Posponha "endobj" para a página.

Etapas necessárias para que se end um sheet (pdf style):
End o sheet (pdf style - finish o current página).
End o sheet (pdf style - finish o current contents).

Etapas necessárias para que se enlarge uma caixa por uns twips:
Subtraia os twips from o canto superior esquerdo desta caixa.
Adicione os twips para o canto inferior direito desta caixa.

Etapas necessárias para que se enlarge um elipse por uns twips:
Subtraia os twips from o canto superior esquerdo desta elipse.
Adicione os twips para o canto inferior direito desta elipse.

Etapas necessárias para que se enfileire um event:
Posponha o event para a fila de eventos.

Etapas necessárias para que se erase o insides of uma caixa;
Etapas necessárias para que se erase inside uma caixa;
Etapas necessárias para que se limpe inside uma caixa:
Pinte a caixa com a cor preta e a cor branca.

Etapas necessárias para que se estimate um deslocamento vertical e um deslocamento horizontal usando uma orientação:
Atribua a orientação a um low orientação.
Arredonde o low orientação para baixo para o múltiplo imediato of 20.
Obtenha um low deslocamento vertical e um low deslocamento horizontal usando o low orientação.
Atribua a orientação a um high orientação.
Arredonde o high orientação para cima para o múltiplo imediato of 20.
Obtenha um high deslocamento vertical e um high deslocamento horizontal usando o high orientação.
Atribua o low deslocamento vertical mais o high deslocamento vertical dividido por 2 ao deslocamento vertical.
Atribua o low deslocamento horizontal mais o high deslocamento horizontal dividido por 2 ao deslocamento horizontal.

\Um event é uma coisa com
\a categoria,
\a detector de tecla shift,
\a detector de tecla ctrl,
\um detector de tecla alt,
\a spot,
\a tecla, um pedaço.

An event é uma coisa com
Uma categoria [atualização de tela, mostrar seta, pressionamento de tecla, clique, clique duplo, clique direito, right double click, deactivate, activate, done], \ English
\Um clase [refrescar, cursor, tecla abajo, clic izquierdo, clic izquierdo doble, clic derecho, clic derecho doble, desactivar, activar, hecho], \ categoria em Spanish
Um detector de tecla shift, 
Um detector de tecla ctrl, 
Um detector de tecla alt, 
Um spot, 
Uma tecla, 
Um pedaço.

A fila de eventos é uma fila de eventos.

Uma fila de eventos é uns events.

Etapas necessárias para que se extend algum tipo de seleção em um text usando um spot:
Se o text for inexistente, cancele.
Obtenha o caret deste text usando o spot e o text.
Limpe a última operação deste text.

Etapas necessárias para que se extend uma caixa para include uma segunda caixa:
Se a coordenada esquerda desta segunda caixa for menor do que a coordenada esquerda desta caixa, atribua a coordenada esquerda desta segunda caixa à coordenada esquerda desta caixa.
Se a coordenada superior desta segunda caixa for menor do que a coordenada superior desta caixa, atribua a coordenada superior desta segunda caixa à coordenada superior desta caixa.
Se a coordenada direita desta segunda caixa for maior do que a coordenada direita desta caixa, atribua a coordenada direita desta segunda caixa à coordenada direita desta caixa.
Se a coordenada inferior desta segunda caixa for maior do que a coordenada inferior desta caixa, atribua a coordenada inferior desta segunda caixa à coordenada inferior desta caixa.

Some extra points são uns points.

Etapas necessárias para que se extraia um designador from um endereço completo:
Limpe o designador.
Extraia um unidade de disco from o endereço completo.
Lance um endereço completo subtexto sobre o endereço completo.
Adicione o quantidade de caracteres desta unidade de disco para o first deste endereço completo subtexto.
Se o endereço completo subtexto estiver em branco, atribua o unidade de disco ao designador; exit.
Lance um subtexto sobre o last pedaço of o endereço completo subtexto.
Se o target deste first deste subtexto for a barra invertida, subtraia 1 from o first deste subtexto.
Percorra.
Se o first deste subtexto for menor do que o first deste endereço completo subtexto, pare.
Se o target deste first deste subtexto for a barra invertida, pare.
Subtraia 1 from o first deste subtexto.
Repita.
Adicione 1 para o first deste subtexto.
Atribua o subtexto ao designador.

Etapas necessárias para que se extraia um endereço da pasta from um endereço completo:
Limpe o endereço da pasta.
Extraia um unidade de disco from o endereço completo.
Se o unidade de disco estiver em branco, cancele.
Lance um subtexto sobre o endereço completo.
Adicione o quantidade de caracteres desta unidade de disco para o first deste subtexto.
Se o subtexto estiver em branco, cancele.
Se o target deste last deste subtexto for a barra invertida, subtraia 1 from o last deste subtexto.
Percorra.
Se o subtexto estiver em branco, pare.
Se o target deste last deste subtexto for a barra invertida, pare.
Subtraia 1 from o last deste subtexto.
Repita.
Atribua a unidade de disco seguido de o subtexto ao endereço da pasta.

Etapas necessárias para que se extraia um nome do diretório from um endereço completo:
Limpe o nome do diretório.
Se o endereço completo não for endereço da pasta-format, cancele.
Extraia o nome do diretório como um designador from o endereço completo.

Etapas necessárias para que se extraia um nome da pasta from um endereço completo:
Extraia o nome da pasta como um nome do diretório from o endereço completo.
Se o nome da pasta estiver em branco, cancele.
Remove o last pedaço from o nome da pasta.

Etapas necessárias para que se extraia um unidade de disco from um endereço completo:
Limpe o unidade de disco.
Se o quantidade de caracteres deste endereço completo for menor do que 3, cancele.
Lance um subtexto sobre o first pedaço of o endereço completo.
Adicione 2 para o last deste subtexto.
Se o subtexto termina com ":\", atribua o subtexto ao unidade de disco; exit.
Se o subtexto não começa com "\\", cancele.
Lance o subtexto sobre o first pedaço of o endereço completo.
Percorra.
Se o last deste subtexto for maior do que o last deste endereço completo, cancele.
Se o target deste last deste subtexto for a barra invertida, adicione 1 para uma contagem.
Se a contagem for 4, pare. \ "\\computer\share\"
Adicione 1 para o last deste subtexto.
Repita.
Atribua o subtexto ao unidade de disco.

Etapas necessárias para que se extraia um extensão from um endereço completo:
Limpe o extensão.
Se o endereço completo estiver em branco, cancele.
Lance um subtexto sobre o last pedaço of o endereço completo.
Percorra.
Se o first deste subtexto for menor do que o first deste endereço completo, cancele.
Se o target deste first deste subtexto for o sinal de dois pontos, cancele.
Se o target deste first deste subtexto for a barra invertida, cancele.
Se o target deste first deste subtexto for o ponto final, pare.
Subtraia 1 from o first deste subtexto.
Repita.
Atribua o subtexto ao extensão.

Etapas necessárias para que se extraia um nome do arquivo from um endereço completo:
Limpe o nome do arquivo.
Se o endereço completo não for file-format, cancele.
Extraia o nome do arquivo como um designador from o endereço completo.

Etapas necessárias para que se extraia um nome do arquivo s/ extensão from um endereço completo:
Extraia o nome do arquivo s/ extensão como um nome do arquivo from o endereço completo.
Extraia um extensão from o endereço completo.
Remove trailing pedaços from o nome do arquivo s/ extensão usando o quantidade de caracteres desta extensão.

Etapas necessárias para que se extraia um picture usando uma caixa:
Atribua a largura desta caixa dividido pelo tpp a um largura.
Atribua a altura desta caixa dividido pelo tpp a uma altura.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com o largura e o altura e 0 e 137224 [pixelformat24bpprgb] e 0 e o endereçamento desse gpbitmap.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" com o gpbitmap e o endereçamento desse gpgraphic.
Call "gdiplus.dll" "GdipGetDC" com o gpgraphic e o endereçamento desse bitmap canvas.
Normalize o bitmap canvas.
Call "gdi32.dll" "BitBlt" com o bitmap canvas e 0 e 0 e a largura desta caixa e a altura desta caixa 
And o quadro atual e a coordenada esquerda desta caixa e a coordenada superior desta caixa e 13369376 [srccopy].
Call "gdiplus.dll" "GdipReleaseDC" com o gpgraphic e o bitmap canvas.
Call "gdiplus.dll" "GdipDeleteGraphics" com o gpgraphic.
Crie o picture usando o gpbitmap.
Atribua a caixa à caixa desta picture.
Atribua a caixa à uncropped caixa desta picture.

Etapas necessárias para que se extraia um string from um text:
Se o text for inexistente, limpe o string; exit.
Converta as rows deste text para o string.
Remove algum tipo de trailing linefeed pedaço from o string.
Remove algum tipo de trailing return pedaço from o string.

Etapas necessárias para que se extraia um string from um text (no linefeed additions):
Se o text for inexistente, limpe o string; exit.
Converta as rows deste text para o string (no linefeed additions).
Remove algum tipo de trailing return pedaço from o string.

Etapas necessárias para que se extraia um string from um text (pedaços selecionados):
Limpe o string.
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
Se o subtexto estiver em branco, repita.
Posponha o subtexto para o string.
Se o target deste last deste subtexto for o return pedaço, posponha o linefeed pedaço para o string.
Repita.

Etapas necessárias para que se face algum tipo de way you want;
Etapas necessárias para que se face algum tipo de which way:
Escolha aleatoriamente uma orientação.

Etapas necessárias para que se face east:
Atribua 960 à orientação deste context.

Etapas necessárias para que se face north:
Atribua 0 à orientação deste context.

Etapas necessárias para que se face south:
Atribua 1920 à orientação deste context.

Etapas necessárias para que se face west:
Atribua 2880 à orientação deste context.

Um fancy arrow é um figura.

Um figura é um polígono.

As figuras são uns polígonos.

Um filetime é um conjunto com
Um número denominado dwlowdatetime,
Um número denominado dwhighdatetime.

Etapas necessárias para que se fill uma caixa com uma cor:
Pinte a caixa com a cor preta e a cor.

Etapas necessárias para que se fill pedaços com um pedaço starting at um endereço de memória por um quantidade de pedaços:
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ o endereço de memória
Intel $8B3F. \ mov edi,[edi]
Intel $8B8D10000000. \ mov ecx,[ebp+16] \ a contagem
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $8A00. \ mov al,[eax]
Intel $FC. \ cld
Intel $F3AA. \ rep stosb

Etapas necessárias para que se fill um elipse sobre um spot com uma cor:
Centralize a elipse sobre o spot.
Pinte a elipse com a cor preta e a cor.

Etapas necessárias para que se fill um string com um pedaço usando uma contagem:
Reassign o first deste string usando a contagem.
Fill pedaços com o pedaço starting at o first deste string pela contagem.
Atribua o first deste string mais a contagem menos 1 ao last deste string.

Etapas necessárias para que se finalize after run:
Se a contagem do heap for 0, cancele.
Atribua a contagem do heap a uma contagem.
Atribua a contagem seguido de " drip(s)." a um string.
Produza o relatório de informações usando o string.

Etapas necessárias para que se finalize o canvases:
Finalize o memory canvas.
Finalize o tela canvas.

Etapas necessárias para que se finalize o cgi:
Call "kernel32.dll" "FreeConsole".

Etapas necessárias para que se finalize a cors:

Etapas necessárias para que se finalize com:
Call "ole32.dll" "CoUninitialize".

Etapas necessárias para que se finalize um context:
Destrua o choices.
Destrua as figuras.
Destrua o context stack.
Destrua o context.

Etapas necessárias para que se finalize o cursors:
Call "user32.dll" "DestroyCursor" com o i-beam cursor. \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroycursor
Call "user32.dll" "DestroyCursor" com o hand cursor.
Call "user32.dll" "DestroyCursor" com a seta do mouse.

Etapas necessárias para que se finalize o fonts:
\Call "gdi32.dll" "RemoveFontMemResourceEx" com o osmosian font resource.
\Call "gdi32.dll" "RemoveFontMemResourceEx" com o Segoe UI resource.
Call "gdi32.dll" "RemoveFontMemResourceEx" com o recurso de fonte Tahoma. \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-removefontmemresourceex

Etapas necessárias para que se finalize gdi+:
Call "gdiplus.dll" "GdiplusShutdown" com o gptoken. \https://docs.microsoft.com/en-us/windows/win32/api/gdiplusinit/nf-gdiplusinit-gdiplusshutdown

Etapas necessárias para que se finalize o memory canvas:
Call "gdi32.dll" "SelectObject" com o memory canvas e o saved memory hbitmap devolvendo um hbitmap. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
Call "gdi32.dll" "DeleteObject" com o hbitmap. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
Call "gdi32.dll" "DeleteDC" com o memory canvas. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deletedc

Etapas necessárias para que se finalize o module:

Etapas necessárias para que se finalize o mouse:

Etapas necessárias para que se finalize o printer canvas:
Call "kernel32.dll" "GlobalFree" \https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalfree
com o número identificador do modo de dispositivo da impressora.
\ Um identificador para o objeto de memória global. 
\Esse identificador é retornado pela função GlobalAlloc ou GlobalReAlloc. 
\Não é seguro liberar memória alocada com LocalAlloc.
Atribua 0 ao printer canvas.

Etapas necessárias para que se finalize o tela:

Etapas necessárias para que se finalize o tela canvas:

Etapas necessárias para que se finalize um talker:
Se o talker for inexistente, cancele.
Call a release desta vtable deste talker com o talker.
Atribua nil ao talker.

Etapas necessárias para que se finalize o window:
Call "user32.dll" "DestroyWindow" com o main window. \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow
Percorra.
Call "user32.dll" "GetMessageA" \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea
com o endereçamento dessa msg \Um ponteiro para uma estrutura MSG que recebe informações da mensagem da fila de mensagens do segmento.
e 0 \Um identificador para a janela cujas mensagens devem ser recuperadas. A janela deve pertencer ao segmento atual.
\Se hWnd for NULL, GetMessage recuperará mensagens para qualquer janela que pertença ao segmento atual 
\e quaisquer mensagens na fila de mensagens do segmento atual cujo valor hwnd seja NULL (consulte a estrutura MSG). https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-msg
\Portanto, se hWnd for NULL, as mensagens da janela e as mensagens do thread serão processadas.
e 0 \O valor inteiro do menor valor da mensagem a ser recuperado. 
\Use WM_KEYFIRST (0x0100) para especificar a primeira mensagem do teclado ou WM_MOUSEFIRST (0x0200) para especificar a primeira mensagem do mouse.
e 0 \O valor inteiro do maior valor da mensagem a ser recuperado. 
\Use WM_KEYLAST para especificar a última mensagem do teclado ou WM_MOUSELAST para especificar a última mensagem do mouse.
\Se wMsgFilterMin e wMsgFilterMax forem 0, GetMessage retorna todas as mensagens disponíveis (ou seja, nenhuma filtragem de intervalo é executada).
devolvendo um número. \Se a função recuperar uma mensagem diferente de WM_QUIT, o valor de retorno será diferente de zero.
\Se a função recuperar a mensagem WM_QUIT, o valor de retorno será zero.
\Se houver um erro, o valor de retorno é -1. 
\Por exemplo, a função falhará se hWnd for um identificador de janela inválido ou lpMsg for um ponteiro inválido. 
\Para obter informações de erro estendidas, use a função GetLastError. https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror
\\ Execute a função "GetMessageA" da biblioteca "user32.dll" usando como argumentos os seguintes parâmetros: 
\\ o endereçamento dessa msg e os valores 0, 0 e 0, esperando um número como resultado.
Se o número for menor do que 1, pare.
Call "user32.dll" "TranslateMessage" \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage
com o endereçamento desta msg. \Um ponteiro para uma estrutura MSG que contém informações de mensagem recuperadas da fila de mensagens do thread de chamada usando a função GetMessage ou PeekMessage.
Call "user32.dll" "DispatchMessageA" \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagea
 com o endereçamento desta msg. \Um ponteiro para uma estrutura que contém a mensagem.
Repita.
Desmanche a fila de eventos.
Destrua o evento atual.

Etapas necessárias para que se finalize winsock:
Call "ws2_32.dll" "WSACleanup".\https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsacleanup

O find anchor é um anchor.

Etapas necessárias para que se encontre uma choice usando um spot:
Start com nada no choice.
Percorra.
Obtenha o [first/next] choice from as choices.
Se o choice for missing, cancele.
Se o spot estiver na caixa desta choice, pare.
Repita.

Etapas necessárias para que se encontre um dyad usando uns dyads e um nome:
Esvazie o dyad.
Percorra.
Obtenha o dyad from o dyads.
Se o dyad for inexistente, cancele.
Se o nome deste dyad for o nome, cancele.
Repita.

Etapas necessárias para que se encontre next usando uma row e um text e um detector:
Desative o detector.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Lance um subtexto sobre o string deste row.
Atribua o first deste subtexto mais o quantidade de caracteres deste find string menos 1 ao last deste subtexto.
Se o número da linha desta row for o número da linha deste find anchor, mova o subtexto usando o column# deste find anchor menos 1.
Percorra.
Se o last deste subtexto for maior do que ou igual ao last deste string desta row, cancele.
Se o subtexto for o find string (accent-free compare), pare. \ for spanish incremental find
Mova o subtexto usando 1.
Repita.
Ligue o detector.
Atribua o first deste subtexto menos o first deste string desta row mais 1 ao anchor column# deste text.
Atribua o número da linha desta row ao anchor número da linha deste text .
Atribua o last deste subtexto menos o first deste string desta row mais 2 ao caret column# deste text.
Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas necessárias para que se encontre next usando um text e um detector:
Se o wrap detector deste text estiver ativo, encontre next usando o text e o detector (wrapped text); exit.
Desative o detector.
Se o text for inexistente, cancele.
Se o quantidade de caracteres deste find string for 0, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
Encontre next usando a row e o text e o detector.
Se o detector estiver ativo, cancele.
Repita.

Etapas necessárias para que se encontre next usando um text e um detector (wrapped text):
Desative o detector.
Se o text for inexistente, cancele.
Converta o find anchor para um posicionamento absoluto denominado offset usando o text.
Extraia um string from o text (no linefeed additions).
Atribua o first deste string mais o offset menos 1 ao first desse subtexto.
Atribua o first deste subtexto mais o quantidade de caracteres deste find string menos 1 ao last deste subtexto.
Percorra.
Se o last deste subtexto for maior do que o last deste string, cancele.
Se o subtexto é o find string (accent-free compare), pare. \ para o spanish incremental find
Mova o subtexto usando 1.
Repita.
Ligue o detector.
Atribua o first deste subtexto menos o first deste string mais 1 a um anchor posicionamento absoluto.
Atribua o last deste subtexto menos o first deste string mais 2 a um caret posicionamento absoluto.
Converta o anchor posicionamento absoluto para o anchor deste text usando o text.
Converta o caret posicionamento absoluto para o caret deste text usando o text.

Etapas necessárias para que se encontre o next misspelling usando uma row e um text e um detector:
Desative o detector.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Lance um percorredor sobre o string deste row.
Se o número da linha desta row é o número da linha deste find anchor, adicione o column# deste find anchor menos 1 para o first deste source deste percorredor.
Se o first deste source deste percorredor não for o first deste string desta row, skip palavra characters no source deste percorredor.
Percorra.
Mova o percorredor (spell checking rules).
Se o vocábulo deste percorredor estiver em branco, cancele.
Se o vocábulo deste percorredor não estiver escrito incorretamente, repita.
Ligue o detector.
Atribua o first deste vocábulo deste percorredor menos o first deste string desta row mais 1 ao anchor column# deste text.
Atribua o número da linha desta row ao anchor número da linha deste text .
Atribua o last deste vocábulo deste percorredor menos o first deste string desta row mais 2 ao caret column# deste text.
Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas necessárias para que se encontre o next misspelling em um text usando um detector:
Desative o detector.
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
Encontre o next misspelling usando a row e o text e o detector.
Se o detector estiver ativo, cancele.
Repita.

Etapas necessárias para que se encontre um pdf object usando um categoria:
Esvazie o pdf object.
Percorra.
Obtenha o pdf object usando os objects deste pdf state.
Se o pdf object for inexistente, pare.
Se a categoria deste pdf object é o categoria, pare.
Repita.

Etapas necessárias para que se encontre um endereço de memória usando um string e um catálogo:
Encontre um refer usando o string e o catálogo.
Se o refer não for inexistente, atribua o endereço de memória deste refer ao endereço de memória; exit.
Esvazie o endereço de memória.

Etapas necessárias para que se encontre um refer usando um string e um catálogo:
Se o catálogo for inexistente, cancele.
Se o string estiver em branco, esvazie o refer; exit.
Obtenha um bucket usando o string e o catálogo.
Encontre o refer usando o string e os refers deste bucket.

Etapas necessárias para que se encontre um refer usando um string e uns refers:
Esvazie o refer.
Percorra.
Obtenha o refer from o refers.
Se o refer for inexistente, cancele.
Se o string for o string deste refer, cancele.
Repita.

Etapas necessárias para que se encontre um sector usando um grid e um spot:
Atribua a coordenada x deste spot dividido pelo número x desta grid times o número x desta grid à coordenada x deste sector.
Atribua a coordenada y deste spot dividido pelo número y desta grid times o número y desta grid à coordenada y deste sector.

Etapas necessárias para que se encontre um square root of um número:
\ rounds para baixo
Isole o número.
De-sign o número.
Se o número for 0, atribua 0 ao square root; exit.
Se o número for 1, atribua 1 ao square root; exit.
Atribua 1 a um square número.
Atribua 3 a um delta número.
Percorra.
Se o square for maior do que o número, pare.
Adicione o delta para o square.
Adicione 2 para o delta.
Repita.
Atribua o delta dividido por 2 menos 1 ao square root.

Etapas necessárias para que se encontre um string usando uns conjunto de textos e um string#:
Limpe o string.
Percorra.
Obtenha um conjunto de texto from o conjunto de textos.
Se o conjunto de texto for inexistente, cancele.
Adicione 1 para uma contagem.
Se a contagem não for o string#, repita.
Atribua o string deste conjunto de texto ao string.

O find string é um string.

Etapas necessárias para que se encontre um conjunto de texto usando um string e uns conjunto de textos:
Esvazie o conjunto de texto.
Percorra.
Obtenha o conjunto de texto usando o conjunto de textos.
Se o conjunto de texto for inexistente, pare.
Se o string deste conjunto de texto é o string, pare.
Repita.

Etapas necessárias para que se encontre um subtexto em um string usando uma segunda string:
Lance o subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o subtexto começa com a segunda string, pare.
Adicione 1 para o first deste subtexto.
Repita.
Atribua o first deste subtexto mais o quantidade de caracteres deste segunda string menos 1 ao last deste subtexto.

Etapas necessárias para que se encontre um value string usando uns dyads e um nome:
Encontre um dyad usando o dyads e o nome.
Se o dyad for inexistente, limpe o value; exit.
Atribua o value deste dyad ao value.

Etapas necessárias para que se encontre um value string usando o environment variáveis e um nome:
Isole o nome.
Modifique através do caractere NUL o nome.
Atribua 32767 a um quantidade de caracteres. \ max size por environment variável
Reassign o first deste value usando o quantidade de caracteres.
Call "kernel32.dll" "GetEnvironmentVariableA" com o first deste nome e o first deste value e o quantidade de caracteres devolvendo o quantidade de caracteres.
Atribua o first deste value mais o quantidade de caracteres menos 1 ao last deste value.

Um finger é um endereço de memória do pedaço .

\Um flag has 4 pedaços.
Um detector é uma coisa com 4 pedaços. \é um conjunto com

Etapas necessárias para que se flip um fração:
Permute o numerador desta fração com o denominador desta fração.

Etapas necessárias para que se flip o gpbitmap em um picture:
Se o picture for inexistente, cancele.
Reverse o mirror detector desta picture.
Adicione 1800 para o ângulo de rotação desta picture.
Normalize o ângulo de rotação desta picture.
Flip o gpbitmap desta picture.

Etapas necessárias para que se flip um gpimage:
Call "gdiplus.dll" "GdipImageRotateFlip" com o gpimage e 6 [rotatenoneflipy aka rotate180flipx].

Etapas necessárias para que se flip um picture:
Se o picture for inexistente, cancele.
Atribua a coordenada y deste center desta caixa desta picture menos a coordenada y deste center desta uncropped caixa desta picture ao número y desse pair.
Multiplique o número y deste pair por 2.
Mova a uncropped caixa desta picture usando o pair.
Flip o gpbitmap no picture.

Etapas necessárias para que se flip um polígono:
Se o polígono for inexistente, cancele.
Atribua a caixa deste polígono a uma caixa.
Percorra.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, cancele.
Subtraia a coordenada superior desta caixa from a coordenada y deste vértice.
Atribua a coordenada inferior desta caixa menos a coordenada y deste vértice à coordenada y deste vértice.
Repita.

Etapas necessárias para que se desmanche all input;
Etapas necessárias para que se desmanche all inputs;
Etapas necessárias para que se desmanche all events:
Desmanche algum tipo de messages.
Desmanche a fila de eventos.

Etapas necessárias para que se desmanche algum tipo de messages:
Call "user32.dll" "PeekMessageA" com o endereçamento dessa msg e 0 e 0 e 0 e 1 [pm_remove] devolvendo um número.
Se o número for 0, cancele.
Se a message desta msg for 15 [wm_paint], call "user32.dll" "ValidateRect" com o main window e 0.
Repita.

Etapas necessárias para que se desmanche um fila de eventos:
Obtenha um event from a fila de eventos.
Se o event for inexistente, cancele.
Remove o event from a fila de eventos.
Destrua o event.
Repita.

Um font é um conjunto com um nome e uma altura.

Um altura da fonte é uns twips. \ indicates line altura - o letras will fit nicely em uma caixa of this altura

Um font info é uma coisa com \ used na pdf conversion
Um font,
Um emsquare número,
Um internal leading número,
Um flags número,
Um ascent número,
Um descent número,
Um capheight número,
Um italicangle número,
Um stemv número,
Um font caixa,
Some font larguras.

Um font resource é um número identificador.

Some font larguras é uma coisa com \ used por pdf conversion
Um font,
Um contagem,
Um endereço numérico denominado data.

Um pé são 12 polegadas.

Etapas necessárias para que se format um número e um singular string ou um plural string Para um string:
Converta o número para o string.
Posponha o caractere de espaço para o string.
Se o número for 1, posponha o singular para o string.
Se o número não for 1, posponha o plural para o string.

Um fração é um conjunto com um numerador número e um denominador número, e um topo número at o numerador e um base número at o denominador.

Um fração pair é um conjunto com uma fração e uma segunda fração.

Um máximo divisor comum é um número.

Um gcpresults é um conjunto com
Um número denominado lstructsize,
Um pchar denominado lpoutstring,
Um endereço numérico denominado lporder,
Um endereço numérico denominado lpdx,
Um endereço numérico denominado lpcaretpos,
Um endereço de memória denominado lpclass,
Um endereço de memória denominado lpglyphs,
Um número denominado nglyphs,
Um número denominado maxfit.

Um gdiplusstartupinput é um conjunto com
Um número denominado gdiplusversion,
Um endereço de memória denominado debugeventcallback,
Um número denominado suppressbackgroundthread,
Um número denominado suppressexternalcodecs.

Um figura geométrica é um figura.

Etapas necessárias para que se obtenha um abca e um abcc usando um string e um canvas:
Atribua 0 ao abca.
Atribua 0 ao abcc.
Se o quantidade de caracteres deste string for menor do que 1, cancele.
Call "gdi32.dll" "GetCharABCWidthsA" com o canvas e o target deste first deste string e o target deste first deste string e o endereçamento desse abc.
Atribua o abca deste abc ao abca.
Call "gdi32.dll" "GetCharABCWidthsA" com o canvas e o target deste last deste string e o target deste last deste string e o endereçamento desse segunda abc.
Atribua o abcc deste segunda abc ao abcc.

Etapas necessárias para que se obtenha um abca usando um string e um canvas:
Atribua 0 ao abca.
Se o quantidade de caracteres deste string for menor do que 1, cancele.
Call "gdi32.dll" "GetCharABCWidthsA" com o canvas e o target deste first deste string e o target deste first deste string e o endereçamento desse abc.
Atribua o abca deste abc ao abca.

Etapas necessárias para que se obtenha uns addrinfo routines:
Limpe o erro do fluxo de entrada/saída.
Call "kernel32.dll" "LoadLibraryA" com "ws2_32.dll"'s first devolvendo um número identificador.
Se o número identificador for 0, atribua "No se pudo leer ws2_32.dll." ao erro do fluxo de entrada/saída; exit.
Call "kernel32.dll" "GetProcAddress" com o número identificador e "getaddrinfo"'s first devolvendo um endereço de memória.
Se o endereço de memória for inexistente, atribua "Lamento que estas rutinas solo funcionan en Windows XP o superior." ao erro do fluxo de entrada/saída; exit.
Atribua o endereço de memória ao getaddrinfo endereço de memória destas addrinfo routines.
Call "kernel32.dll" "GetProcAddress" com o número identificador e "freeaddrinfo"'s first devolvendo o endereço de memória.
Se o endereço de memória for inexistente, atribua "Infelizmente essas rotinas só funcionam no Windows XP ou numa versão superior do Windows." ao erro do fluxo de entrada/saída; exit.
Atribua o endereço de memória ao freeaddrinfo endereço de memória destas addrinfo routines.

Etapas necessárias para que se obtenha uma caixa pelo caret em um text:
Se o text for inexistente, zero a caixa; exit.
Obtenha um spot usando o caret deste text e o text.
Atribua o spot e o spot ao caixa.
Adicione a altura da linha deste text para a coordenada inferior desta caixa.
Ajuste a caixa usando 0 e o tpp e 0 e - o tpp.
Atribua a globalized origin deste text a um origin.
Se a coordenada esquerda desta caixa for menor do que a coordenada x desta origin, atribua a coordenada x desta origin à coordenada esquerda desta caixa; atribua a coordenada x desta origin à coordenada direita desta caixa.
Se o wrap detector deste text não estiver ativo, cancele.
Limite a coordenada esquerda desta caixa para a coordenada esquerda deste text e a coordenada direita deste text.
Limite a coordenada direita desta caixa para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas necessárias para que se obtenha uma caixa por um line:
Atribua o start desta line ao canto superior esquerdo desta caixa.
Atribua o end desta line ao canto inferior direito desta caixa.
Normalize a caixa.

Etapas necessárias para que se obtenha uma caixa usando uma row e um text:
Se o text for inexistente, zero a caixa; exit.
Se a row for inexistente, zero a caixa; exit.
Atribua a globalized origin deste text ao canto superior esquerdo desta caixa.
Adicione o número da linha desta row menos 1 times a altura da linha deste text para a coordenada superior desta caixa.
Atribua a coordenada direita deste text à coordenada direita desta caixa.
Atribua a coordenada superior desta caixa mais a altura da linha deste text à coordenada inferior desta caixa.

Etapas necessárias para que se obtenha um bucket usando um bucket# e um catálogo:
\ if o catálogo for inexistente, esvazie o bucket; exit. \ para make compilador faster
Atribua o first bucket deste catálogo ao bucket.
Adicione o bucket# times a magnitude desse conjunto de buckets para o bucket.

Etapas necessárias para que se obtenha um bucket usando um catálogo:
\Se o catálogo for inexistente, esvazie o bucket; exit. \ para fazer o compilador mais rápido
Se o bucket for inexistente, atribua o first bucket deste catálogo ao bucket; exit.
Se o bucket for o last bucket deste catálogo, esvazie o bucket; exit.
Adicione a magnitude desse conjunto de buckets para o bucket.

Etapas necessárias para que se obtenha um bucket usando um string e um catálogo:
\ if o catálogo for inexistente, esvazie o bucket; exit. \ para make compilador faster
Obtenha um bucket# usando o string e o catálogo.
Obtenha o bucket usando o bucket# e o catálogo.

Etapas necessárias para que se obtenha um bucket# usando um string e um catálogo:
\ based sobre o djb2 algorithm
\ if o catálogo for inexistente, atribua 0 ao bucket#; exit. \ para make compilador faster
Atribua o quantidade de caracteres deste string ao bucket#.
Se o bucket# for 0, cancele.
Adicione 5381 para o bucket#.
Lance um subtexto sobre o string.
Percorra.
Atribua o target deste first deste subtexto a um pedaço.
Lowercase o pedaço.
Atribua o bucket# a um número.
Shift o bucket# left 5 bits.
Adicione o número para o bucket#.
Adicione o pedaço para o bucket#.
Adicione 3 para o first deste subtexto.
Se o subtexto estiver em branco, pare.
Repita.
Conjuncione logicamente o bucket# com o maior número.
Divida o bucket# pela contagem de buckets deste catálogo usando um quotient e o bucket#.

Etapas necessárias para que se obtenha um pedaço from um string:
Se o string estiver em branco, atribua o null pedaço ao pedaço; exit.
Atribua o target deste first deste string ao pedaço.
Remove o first pedaço from o string.

Etapas necessárias para que se obtenha um pedaço from um string (backwards):
Se o string estiver em branco, atribua o null pedaço ao pedaço; exit.
Atribua o target deste last deste string ao pedaço.
Remove o last pedaço from o string.

Etapas necessárias para que se obtenha um center spot usando um spot e uma segunda spot:
Atribua o spot e a segunda spot a um line.
Atribua o center desta line ao center.

Etapas necessárias para que se obtenha uma cor usando um spot:
Call "gdi32.dll" "GetPixel" com o quadro atual e a coordenada x deste spot e a coordenada y deste spot devolvendo um código da cor.
Converta o código da cor para a cor.

Etapas necessárias para que se obtenha um column# usando uma row e um spot e um text:
Atribua 0 ao column#.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Obtenha uma caixa usando a row e o text.
Se a coordenada y deste spot for maior do que a coordenada inferior desta caixa, atribua o quantidade de caracteres deste string desta row ao column#; exit. \ only happens sobre last row of text
Crie o número da fonte of o memory canvas usando o font deste text.
Obtenha um start largura e um subtexto usando a row e o spot e o text (for "get um column# usando uma row...").
Percorra.
Se o last deste subtexto é o last deste string desta row, pare.
Obtenha um largura usando o subtexto e o memory canvas.
Adicione o start largura para o largura.
Obtenha uma segunda largura usando o target deste last deste subtexto e o memory canvas.
Divida a segunda largura por 2.
Subtraia a segunda largura from o largura.
Se a coordenada x deste spot for menor do que o largura, pare.
Adicione 1 para o last deste subtexto.
Repita.
Atribua o last deste subtexto menos o first deste string desta row mais 1 ao column#.
Destrua o número da fonte of o memory canvas.

Etapas necessárias para que se obtenha uma contagem of items em um endereço completo no sistema de arquivos:
Atribua 0 à contagem.
Percorra.
Obtenha um item from o endereço completo.
Se o item não for found, cancele.
Adicione 1 para a contagem.
Repita.

Etapas necessárias para que se obtenha um description por um endereço completo:
Limpe o description.
Obtenha um categoria da unidade de disco pelo endereço completo.
Atribua o categoria da unidade de disco ao description.
Obtenha um nome da unidade de disco pelo endereço completo.
Se o nome da unidade de disco não estiver em branco, atribua o nome da unidade de disco ao description.
Lowercase o description.

Etapas necessárias para que se obtenha um difference between um pair e uma segunda pair:
Atribua o pair à difference.
Subtraia a segunda pair from a difference.

Etapas necessárias para que se obtenha um difference between um pair e uma segunda pair usando um grid pair:
Obtenha a difference between o pair e a segunda pair.
Arredonde a difference para a grid.

Etapas necessárias para que se obtenha um distance between um spot e uma segunda spot (approximate):
Atribua a coordenada x deste spot menos o x deste segunda spot a um número.
De-sign o número.
Atribua a coordenada y deste spot menos o y deste segunda spot a uma segunda número.
De-sign a segunda número.
Atribua o número times o número ao distance.
Adicione a segunda número times a segunda número para o distance.
Encontre um square root of o distance.
Atribua o square root ao distance.
Se a tecla D/d estiver sendo pressionada, produza o relatório de informações usando o distance.

Etapas necessárias para que se obtenha um distance between um spot e uma segunda spot (chessboard):
Atribua a coordenada x deste spot menos a coordenada x deste segunda spot a um número.
De-sign o número.
Atribua a coordenada y deste spot menos a coordenada y deste segunda spot a uma segunda número.
De-sign a segunda número.
Atribua o número ao distance.
Se a segunda número for maior do que o número, atribua a segunda número ao distance.

Etapas necessárias para que se obtenha um categoria da unidade de disco por um endereço completo:
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "GetDriveTypeA" com o first deste endereço completo devolvendo um número.
Se o número for 2 [drive_removable], atribua "Disco removível" à categoria da unidade de disco; exit. \ removable drive
Se o número for 3 [drive_fixed], atribua "Disco Rígido / Pendrive" à categoria da unidade de disco; exit.\ hard disk / flash drive
Se o número for 4 [drive_remote], atribua "Unidade de rede" à categoria da unidade de disco; exit. \ network drive
Se o número for 5 [drive_cdrom], atribua "Unidade de CD/DVD" à categoria da unidade de disco; exit. \ cd-rom / dvd drive
Se o número for 6 [drive_ramdisk], atribua "Unidade virtual na memória" à categoria da unidade de disco; exit. \ virtual unidade de disco em memory
Atribua "" à categoria da unidade de disco.

Etapas necessárias para que se obtenha um nome da unidade de disco por um endereço completo:
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Atribua 512 a um quantidade de caracteres.
Reassign o first desse trecho usando o quantidade de caracteres.
Call "kernel32.dll" "GetVolumeInformationA" com o first deste endereço completo e o first deste trecho e o quantidade de caracteres e 0 e 0 e 0 e 0 e 0 devolvendo um número.
Se o número for 0, limpe o nome da unidade de disco; exit.
Converta o first deste trecho como um pchar para o nome da unidade de disco.

Etapas necessárias para que se obtenha o first-eighth equivalent of uma orientação:
Obtenha o first-quarter equivalent of a orientação.
Se a orientação for menor do que 480, cancele.
Subtraia 960 from a orientação.
De-sign a orientação.

Etapas necessárias para que se obtenha o first-quarter equivalent of uma orientação:
Se a orientação for menor do que 960, cancele.
Subtraia 960 from a orientação.
Repita.

Etapas necessárias para que se obtenha fresh random números;
Etapas necessárias para que se obtenha new random números;
Etapas necessárias para que se seed o random número generator:
Atribua a contagem de ticks do sistema à seed.

Etapas necessárias para que se obtenha um máximo divisor comum usando um número e uma segunda número:
Atribua o número a um dividend número.
Atribua a segunda número ao máximo divisor comum.
De-sign o dividend número.
De-sign o máximo divisor comum.
Se o dividend for menor do que o máximo divisor comum, permute o dividend com o máximo divisor comum.
Se o máximo divisor comum for 0, atribua 1 ao máximo divisor comum; exit.
Percorra.
Divida o dividend pelo máximo divisor comum usando um quotient e um resto.
Se o resto for 0, cancele.
Atribua o máximo divisor comum ao dividend.
Atribua o resto ao máximo divisor comum.
Repita.

Etapas necessárias para que se obtenha um ip address usando um host string:
Limpe o ip address.
Obtenha um sockaddr usando o host string.
Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
Atribua o s_addr deste sin_addr deste sockaddr ao número deste ip address.
Call "ws2_32.dll" "inet_ntoa" com o número deste ip address devolvendo um pchar.
Converta o pchar para o string deste ip address.

Etapas necessárias para que se obtenha um item (not first time):
Limpe o erro do fluxo de entrada/saída.
Call "kernel32.dll" "FindNextFileA" com o número identificador deste item e o endereçamento deste win32finddata deste item devolvendo um número.
Se o número não for 0, ajuste o item; exit.
Limpe a categoria deste item.
Call "kernel32.dll" "FindClose" com o número identificador deste item.

Etapas necessárias para que se obtenha um item from um endereço completo:
Se o endereço completo não for endereço da pasta-format, cancele.
Atribua o endereço completo ao endereço da pasta deste item.
Se a categoria deste item estiver em branco, obtenha o item from o endereço completo (first time); exit.
Obtenha o item (not first time).

Etapas necessárias para que se obtenha um item from um endereço completo (first time):
Limpe o erro do fluxo de entrada/saída.
Isole o endereço completo.
Posponha "*.*" para o endereço completo.
Modifique através do caractere NUL o endereço completo.
Limpe a categoria deste item.
Call "kernel32.dll" "FindFirstFileA" com o first deste endereço completo e o endereçamento deste win32finddata deste item devolvendo o número identificador deste item.
Se o número identificador deste item for -1 [invalid_handle_value], cancele.
Ajuste o item.

Etapas necessárias para que se obtenha um mínimo múltiplo comum usando um número e uma segunda número:
Obtenha um máximo divisor comum usando o número e a segunda número.
Call "kernel32.dll" "MulDiv" com o número e a segunda número e o máximo divisor comum devolvendo o mínimo múltiplo comum.

Etapas necessárias para que se obtenha um letra from o alphabet:
Atribua o next letra ao letra.
Avance o next letra limiting it para o 'A' maiúsculo e o Z maiúsculo.
Adicione 1 para o next letra.
Se o next letra for maior do que o Z maiúsculo, atribua o 'A' maiúsculo à next letra.

Etapas necessárias para que se obtenha um número from a stack:
Atribua 0 ao número.
Obtenha um stack entry from o stack.
Se a stack entry for inexistente, cancele.
Converta o string desta stack entry para o número.
Remove a stack entry from o stack.
Destrua a stack entry.

Etapas necessárias para que se obtenha um offset pair usando um string e uma caixa e uma font e um alinhamento:
Crie o número da fonte of o memory canvas usando o font.
Obtenha o offset pair usando o string e a caixa e o font e o alinhamento (fast).
Destrua o número da fonte of o memory canvas.

Etapas necessárias para que se obtenha um offset pair usando um string e uma caixa e uma font e um alinhamento (fast):
Se o alinhamento for "left", obtenha o número x deste offset pair usando o string e a caixa (fast - left).
Se o alinhamento for "right", obtenha o número x deste offset pair usando o string e a caixa (fast - right).
Se o alinhamento for "center", obtenha o número x deste offset pair usando o string e a caixa (fast - center).
Call "gdi32.dll" "GetTextMetricsA" com o memory canvas e o endereçamento desse textmetric.
Adicione a altura desta caixa menos a tmheight deste textmetric dividido por 2 para o número y deste offset pair.

Etapas necessárias para que se obtenha um outlinetextmetric usando um font:
Crie o número da fonte of o memory canvas usando o font.
Call "gdi32.dll" "GetOutlineTextMetricsA" com o memory canvas e 0 e 0 devolvendo um result número.
Assign um poutlinetextmetric usando o result.
Call "gdi32.dll" "GetOutlineTextMetricsA" com o memory canvas e o result e o poutlinetextmetric.
Atribua o target deste poutlinetextmetric ao outlinetextmetric.
Destrua o número da fonte of o quadro atual.
Unassign o poutlinetextmetric.

Etapas necessárias para que se obtenha uma position usando um spot e um text:
Se o text for inexistente, limpe o position; exit.
Obtenha uma row usando o spot e o text.
Atribua o número da linha desta row ao número da linha desta position.
Obtenha o column# desta position usando a row e o spot e o text.

Etapas necessárias para que se obtenha um endereço de memória RGB from um bitmapdata at um número da linha e um column#:
\ 1 based
Atribua o scan0 deste bitmapdata ao endereço de memória RGB.
Adicione o número da linha menos 1 times o stride deste bitmapdata para o endereço de memória RGB.
Adicione o column# menos 1 times a magnitude desse espaço de cor RGB para o endereço de memória RGB.

Etapas necessárias para que se obtenha um deslocamento vertical e um deslocamento horizontal usando uma orientação: \deslocamento horizontal e vertical?
\ veja https://pt.wikipedia.org/wiki/Trigonometria_racional
\ https://pt.wikipedia.org/wiki/Física_digital
\ A trigonometria racional evita o uso direto de funções transcendentes, como seno e cosseno, substituindo-as por seus equivalentes quadráticos.
Isole a orientação.
Normalize a orientação.
Normalize o original orientação.
Se a orientação não for uniformemente divisível por 20, estimate o deslocamento vertical e o deslocamento horizontal usando a orientação; exit.
\ special cases
Se a orientação for 0, atribua -10000 no deslocamento vertical; atribua -0 no deslocamento horizontal; exit. \ 0 graus
Se a orientação for 960, atribua 10000 no deslocamento horizontal; atribua -0 no deslocamento vertical; exit. \ 90 graus
Se a orientação for 1920, atribua 10000 no deslocamento vertical; atribua 0 no deslocamento horizontal; exit. \ 180 graus
Se a orientação for 2880, atribua -10000 no deslocamento horizontal; atribua 0 no deslocamento vertical; exit. \ 270 graus
Se a orientação for 3840, produza o relatório de informações usando "orientação inválida"; produza o relatório de informações usando a orientação; produza o relatório de informações usando o original orientação.
\ force it ao first eighth of o circle
Obtenha o first-eighth equivalent of a orientação.
\ encontre o first eighth of o circle unsigned values
Se a orientação for 20, atribua 0327 no deslocamento horizontal; atribua 9995 no deslocamento vertical; break. \ 1.875 degrees
Se a orientação for 40, atribua 0654 no deslocamento horizontal; atribua 9979 no deslocamento vertical; break. \ 3.75 degrees
Se a orientação for 60, atribua 0980 no deslocamento horizontal; atribua 9952 no deslocamento vertical; break. \ 5.625 degrees = 1/64 of o way
Se a orientação for 80, atribua 1305 no deslocamento horizontal; atribua 9914 no deslocamento vertical; break. \7.5 degrees
Se a orientação for 100, atribua 1629 no deslocamento horizontal; atribua 9866 no deslocamento vertical; break. \ 9.375 degrees
Se a orientação for 120, atribua 1951 no deslocamento horizontal; atribua 9808 no deslocamento vertical; break. \ 11.25 degrees = 2/64 of o way
Se a orientação for 140, atribua 2271 no deslocamento horizontal; atribua 9739 no deslocamento vertical; break. \ 13.125 degrees
Se a orientação for 160, atribua 2588 no deslocamento horizontal; atribua 9659 no deslocamento vertical; break. \ 15 degrees
Se a orientação for 180, atribua 2903 no deslocamento horizontal; atribua 9569 no deslocamento vertical; break. \ 16.875 degrees = 3/64 of o way
Se a orientação for 200, atribua 3214 no deslocamento horizontal; atribua 9469 no deslocamento vertical; break. \ 18.75 degrees
Se a orientação for 220, atribua 3523 no deslocamento horizontal; atribua 9359 no deslocamento vertical; break. \ 20.625 degrees
Se a orientação for 240, atribua 3827 no deslocamento horizontal; atribua 9239 no deslocamento vertical; break. \ 22.5 degrees = 4/64 of o way
Se a orientação for 260, atribua 4127 no deslocamento horizontal; atribua 9109 no deslocamento vertical; break. \ 24.375 degrees
Se a orientação for 280, atribua 4423 no deslocamento horizontal; atribua 8969 no deslocamento vertical; break. \ 26.25 degrees
Se a orientação for 300, atribua 4714 no deslocamento horizontal; atribua 8819 no deslocamento vertical; break. \ 28.125 degrees = 5/64 of o way
Se a orientação for 320, atribua 5000 no deslocamento horizontal; atribua 8660 no deslocamento vertical; break. \ 30 degrees
Se a orientação for 340, atribua 5281 no deslocamento horizontal; atribua 8492 no deslocamento vertical; break. \ 31.875 degrees
Se a orientação for 360, atribua 5556 no deslocamento horizontal; atribua 8315 no deslocamento vertical; break. \ 33.75 degrees = 6/64 of o way
Se a orientação for 380, atribua 5825 no deslocamento horizontal; atribua 8128 no deslocamento vertical; break. \ 35.625 degrees
Se a orientação for 400, atribua 6088 no deslocamento horizontal; atribua 7934 no deslocamento vertical; break. \ 37.5 degrees
Se a orientação for 420, atribua 6344 no deslocamento horizontal; atribua 7730 no deslocamento vertical; break. \ 39.375 degrees = 7/64 of o way
Se a orientação for 440, atribua 6593 no deslocamento horizontal; atribua 7518 no deslocamento vertical; break. \ 41.25 degrees
Se a orientação for 460, atribua 6836 no deslocamento horizontal; atribua 7299 no deslocamento vertical; break. \ 43.125 degrees
Se a orientação for 480, atribua 7071 no deslocamento horizontal; atribua 7071 no deslocamento vertical; break. \ 45 degrees = 8/64 of o way
Repita. \ não é realmente um comando de repetição, é apenas um marcador para as "breaks" aí de cima.
\ ajuste por segunda eighths of o circle
Se o original orientação estiver entre 0 e 480, negate o deslocamento vertical; exit. \ 1st eighth (12:00 para 1:30)
Se o original orientação estiver entre 480 e 960, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento vertical; exit. \ 2nd eighth (1:30 para 3:00)
Se o original orientação estiver entre 960 e 1440, permute o deslocamento horizontal com o deslocamento vertical; exit. \ 3rd eighth (3:00 para 4:30)
Se o original orientação estiver entre 1440 e 1920, cancele. \ 4th eighth (4:30 para 6:00)
Se o original orientação estiver entre 1920 e 2400, negate o deslocamento horizontal; exit. \ 5th eighth (6:00 para 7:30)
Se o original orientação estiver entre 2400 e 2880, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; exit. \ 6th eighth (7:30 para 9:00)
Se o original orientação estiver entre 2880 e 3360, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; negate o deslocamento vertical; exit. \ 7th eighth (9:00 para 10:30)
Se o original orientação estiver entre 3360 e 3840, negate o deslocamento horizontal; negate o deslocamento vertical; exit. \ 8th eighth (10:30 para 12:00)

Etapas necessárias para que se obtenha uma row usando um número da linha e um text:
Esvazie a row.
Se o text for inexistente, cancele.
Percorra.
Obtenha a row from as rows deste text.
Se a row for inexistente, cancele.
Se o número da linha desta row for o número da linha, cancele.
Repita.

Etapas necessárias para que se obtenha uma row usando um spot e um text:
Se o text for inexistente, esvazie a row; exit.
Atribua a coordenada y deste spot a uma coordenada y.
Limite a coordenada y para a coordenada superior deste text e a coordenada inferior deste text.
Atribua a coordenada y menos a coordenada y desta globalized origin deste text dividido pela altura da linha deste text mais 1 a um número da linha.
Limite o número da linha para 1 e a contagem de linhas deste text.
Obtenha a row usando o número da linha e o text.

Etapas necessárias para que se obtenha uma caixa de seleção usando uma row e um text:
Limpe a caixa de seleção.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Obtenha uma caixa usando a row e o text.
Atribua a caixa ao caixa de seleção.
Obtenha a caixa de seleção usando a row e o text (lado esquerdo).
Obtenha a caixa de seleção usando a row e o text (lado direito).

Etapas necessárias para que se obtenha uma caixa de seleção usando uma row e um text (lado esquerdo):
Atribua a normalized seleção deste text a um seleção.
Atribua a coordenada x desta globalized origin deste text à coordenada esquerda desta caixa de seleção.
Se o anchor número da linha desta seleção for o número da linha desta row, obtenha um spot usando o anchor desta seleção e o text; atribua a coordenada x deste spot à coordenada esquerda desta caixa de seleção.
Limite a coordenada esquerda desta caixa de seleção para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas necessárias para que se obtenha uma caixa de seleção usando uma row e um text (lado direito):
Atribua a normalized seleção deste text a um seleção.
Atribua a coordenada direita deste text à coordenada direita desta caixa de seleção.
Se o número de linhas do cursor desta seleção for o número da linha desta row, obtenha um spot usando o caret desta seleção e o text; atribua a coordenada x deste spot à coordenada direita desta caixa de seleção.
Limite a coordenada direita desta caixa de seleção para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos:
Se o endereço completo for endereço da pasta-format, obtenha o size usando o endereço completo no sistema de arquivos (pasta)[endereço].
Se o endereço completo for file-format, obtenha o size usando o endereço completo no sistema de arquivos (arquivo).

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos (pasta)[endereço]:
Atribua 0 ao size.
Percorra.
Obtenha um item from o endereço completo.
Se o item não for found, cancele.
Se a categoria deste item for "arquivo", adicione o size deste item para o size; repita.
Atribua o endereço completo a uma segunda endereço completo.
Posponha o designador deste item para a segunda endereço completo.
Obtenha uma segunda size usando a segunda endereço completo no sistema de arquivos.
Adicione a segunda size para o size.
Repita.

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos (arquivo):
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "GetFileAttributesExA" com o first deste endereço completo e 0 e o endereçamento desse win32finddata.
Atribua o nfilesizelow deste win32finddata ao size.

Etapas necessárias para que se obtenha um sockaddr usando um host string:
Limpe o erro do fluxo de entrada/saída.
\ prepare strings
Isole o host string.
Modifique através do caractere NUL o host string.
\ obtenha o function addresses
Obtenha uns addrinfo routines.
Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
\ obtenha o sockaddr
Atribua 2 [af_inet] ao ai_family desse addrinfo.
Atribua 1 [sock_stream] ao ai_sockettype deste addrinfo.
Atribua 6 [ipproto_tcp] ao ai_protocol deste addrinfo.
Call o getaddrinfo destas addrinfo routines com o first deste host string e 0 e o endereçamento deste addrinfo e o endereçamento desse addrinfoptr devolvendo um result número.
Se o result número não for 0, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " seguido de o host seguido de "." ao erro do fluxo de entrada/saída; exit.
Se o addrinfoptr for inexistente, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " seguido de o host seguido de "." ao erro do fluxo de entrada/saída; exit.
Atribua o target deste ai_addr deste addrinfoptr ao sockaddr.
Call o freeaddrinfo destas addrinfo routines com o addrinfoptr.

Etapas necessárias para que se obtenha um spot usando uma position e um text:
Limpe o spot.
Se o text for inexistente, cancele.
Obtenha uma row usando o número da linha desta position e o text.
Obtenha uma caixa usando a row e o text.
Atribua a coordenada superior desta caixa à coordenada y deste spot.
Atribua o first deste string desta row ao first desse subtexto.
Atribua o first deste subtexto mais o column# desta position menos 2 ao last deste subtexto.
Obtenha um largura usando o subtexto e o memory canvas e o font deste text.
Atribua a coordenada esquerda desta caixa mais o largura à coordenada x deste spot.
Obtenha um offset pair usando o working string desta row e a caixa e a font deste text e o alinhamento deste text.
Adicione o número x deste offset pair para a coordenada x deste spot.

Etapas necessárias para que se obtenha um start largura e um subtexto usando uma row e um spot e um text (for "get um column# usando uma row..."):
Limpe o start largura.
Limpe o subtexto.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Obtenha uma caixa usando a row e o text.
Lance o subtexto sobre o working string desta row.
Obtenha um offset pair usando o subtexto e a caixa e a font deste text e o alinhamento deste text (fast).
Atribua a coordenada x desta globalized origin deste text mais o número x deste offset pair ao start largura.
Atribua o first deste subtexto mais o text cutoff menos 1 ao last deste subtexto.
Percorra.
Se o last deste subtexto for maior do que ou igual ao last deste string desta row, pare.
Obtenha um largura usando o subtexto e o memory canvas.
Atribua o start largura mais o largura a uma segunda largura.
Se a coordenada x deste spot for menor do que ou igual ao segunda largura, pare.
Adicione o largura para o start largura.
Mova o subtexto usando o text cutoff.
Repita.
Atribua o first deste subtexto ao last deste subtexto.

Etapas necessárias para que se obtenha um string from o stack:
Limpe o string.
Obtenha um stack entry from o stack.
Se o stack entry for inexistente, atribua "ERROR" ao string; exit.
Atribua o string desta stack entry para o string.
Remove o stack entry from o stack.
Destrua o stack entry.

Etapas necessárias para que se obtenha um string from o área de transferência do Windows:
Limpe o string.
Call "user32.dll" "OpenClipboard" com o main window.
Call "user32.dll" "GetClipboardData" com 1 [cf_text] devolvendo um número identificador.
Se o número identificador for 0, call "user32.dll" "CloseClipboard"; exit.
Call "kernel32.dll" "GlobalLock" com o número identificador devolvendo um pchar.
Converta o pchar para o string.
Call "kernel32.dll" "GlobalUnlock" com o número identificador.
Call "user32.dll" "CloseClipboard".

Etapas necessárias para que se obtenha uma coisa from umas coisas:
Se  as coisas estiverem vazio, esvazie a coisa; exit.
Se a coisa for inexistente, atribua o first destas coisas à coisa; exit.
Atribua o next desta coisa à coisa.

Etapas necessárias para que se obtenha uma coisa from umas coisas (backwards):
Se  as coisas estiverem vazio, esvazie a coisa; exit.
Se a coisa for inexistente, atribua o last destas coisas à coisa; exit.
Atribua o previous desta coisa à coisa.

Etapas necessárias para que se obtenha um vocábulo from um reply:
Remove algum tipo de leading noise from o reply.
Limpe o vocábulo.
Percorra.
Se o reply estiver em branco, cancele.
Obtenha um pedaço from o reply.
Se o pedaço for o caractere de espaço, cancele.
Posponha o pedaço para o vocábulo.
Repita.

Etapas necessárias para que se obtenha um largura usando um pedaço e um canvas:
Call "gdi32.dll" "GetTextExtentPoint32A" com o canvas e o endereçamento deste pedaço e 1 e o endereçamento desse pair.
Atribua o número x deste pair ao largura.

Etapas necessárias para que se obtenha um largura usando um pedaço e uns font larguras:
Atribua o pedaço a um número.
Obtenha o largura usando o número e o font larguras.

Etapas necessárias para que se obtenha um largura usando um número e uns font larguras:
\ indexes são 0 based
Se o font larguras são nil, limpe o largura; exit.
Atribua o data destes font larguras a um endereço numérico.
Adicione o número times a magnitude deste número para o endereço numérico.
Atribua o target deste endereço numérico ao largura.

Etapas necessárias para que se obtenha um largura usando um string e um canvas:
\ assumes font é already selecionado em canvas
Call "gdi32.dll" "GetTextExtentPoint32A" com o canvas e o first deste string e o quantidade de caracteres deste string e o endereçamento desse pair.
Atribua o número x deste pair ao largura.

Etapas necessárias para que se obtenha um largura usando um string e um canvas e um font:
Crie o número da fonte of o canvas usando o font.
Obtenha o largura usando o string e o canvas.
Destrua o número da fonte of o canvas.

Etapas necessárias para que se obtenha um largura usando um string e um font:
\ assumes memory canvas
Obtenha o largura usando o string e o memory canvas e o font.

Etapas necessárias para que se obtenha uma coordenada x usando um string e uma caixa (fast - center):
Obtenha um largura usando o string e o memory canvas.
Obtenha um abca e um abcc usando o string e o memory canvas.
Atribua o largura menos o abca menos o abcc ao largura.
Atribua a largura desta caixa menos o largura dividido por 2 menos o abca à coordenada x.

Etapas necessárias para que se obtenha uma coordenada x usando um string e uma caixa (fast - left):
Obtenha um abca usando o string e o memory canvas.
Atribua - o abca à coordenada x.

Etapas necessárias para que se obtenha uma coordenada x usando um string e uma caixa (fast - right):
Obtenha um abca e um abcc usando o string e o memory canvas.
Obtenha um largura usando o string e o memory canvas.
Atribua o largura menos o abca menos o abcc ao largura.
Atribua a largura desta caixa menos o largura menos o abca à coordenada x.

Um gigabyte é 1024 megabytes.

Etapas necessárias para que se globalize uma caixa usando um pair:
Mova a caixa usando o pair.

Etapas necessárias para que se globalize um spot usando um pair:
Mova o spot usando o pair.

Etapas necessárias para que se go back para where we were:
Restore o context.

Um gpbitmap é um gpimage.

Um gpgraphic é um endereço de memória.

Um gpimage é um endereço de memória.

An gpimageattributes é um endereço de memória.

Um gprect é um conjunto com
Um número denominado x,
Um número denominado y,
Um número denominado largura,
Um número denominado altura.

O gptoken é um gptoken.

Um gptoken é um número.

An grain é 10 milliseconds.

O grayscale cor matrix é um texto hexadecimal igual a $8716993E8716993E8716993E0000000000000000A245163FA245163FA245163F0000000000000000D578E93DD578E93DD578E93D00000000000000000000000000000000000000000000803F00000000000000000000000000000000000000000000803F.

Um grid é um pair.

Etapas necessárias para que se garanta one row em um text:
Se o text for inexistente, cancele.
Se as rows deste text não estiverem vazio, cancele.
Crie uma row usando o return pedaço.
Posponha a row para as rows deste text.
Renumber as rows deste text.

Um guid é um uuid.

O hand cursor é um cursor.

Etapas necessárias para que se mude alinhamento usando um text e um alinhamento:
Se o text for inexistente, cancele.
Relembre o text com "alinhamento".
Align o text usando o alinhamento.

Etapas necessárias para que se execute algum tipo de wm-activate com um w-param:
Split o w-param a um wyrd e uma segunda wyrd.
Atribua a segunda wyrd a um número.
Se o número for 0, execute algum tipo de wm-activate com o w-param (deactivate); exit.
Execute algum tipo de wm-activate com o w-param (activate).

Etapas necessárias para que se execute algum tipo de wm-activate com um w-param (activate):
Call "user32.dll" "SetFocus" com o main window.
Call "user32.dll" "ClipCursor" com 0.
\ seterrormode(sem_failcriticalerrors) \ keeps certain disk erros from appearing
Crie um event.
Atribua "activate" à categoria deste event.
\Atribua "activar" à categoria deste event.
Enfileire o event.
Call "user32.dll" "PostMessageA" com o main window e 0 [wm_null] e 0 e 0.

Etapas necessárias para que se execute algum tipo de wm-activate com um w-param (deactivate):
Crie um event.
Atribua "deactivate" à categoria deste event.
\Atribua "desactivar" à categoria deste event.
Enfileire o event.
Call "user32.dll" "PostMessageA" com o main window e 0 [wn_null] e 0 e 0.

Etapas necessárias para que se execute algum tipo de wm-char com um w-param e um l-param:
\Se a tecla Alt was para baixo, cancele. \ removed por Spanish teclaboard AltGr e ctrl+alt characters
\Se a tecla Ctrl was para baixo, cancele. \ removed por Spanish teclaboard AltGr e ctrl+alt characters
Atribua o w-param a um pedaço.
Se o pedaço não for printable, cancele.
Crie um event.
Atribua "pressionamento de tecla" à categoria deste event.
\Atribua "tecla abajo" à categoria deste event.
Se a tecla shift was para baixo, acione o detector de tecla shift deste event.
Atribua o pedaço ao pedaço deste event.
Converta o l-param para a tecla deste event.
Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-create com um window:
Atribua o window ao main window.

Etapas necessárias para que se execute algum tipo de wm-destroy:
Call "user32.dll" "PostQuitMessage" com 0.

Etapas necessárias para que se execute algum tipo de wm-lbuttondblclk com um l-param:
Crie um event.
Atribua "clique duplo" à categoria deste event.
\Atribua "clic izquierdo doble" à categoria deste event.
Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
Se a tecla shift was para baixo, acione o detector de tecla shift deste event.
Converta o l-param para o spot deste event.
Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-lbuttondown com um l-param:
Crie um event.
Atribua "clique" à categoria deste event.
\Atribua "clic izquierdo" à categoria deste event.
Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
Se a tecla shift was para baixo, acione o detector de tecla shift deste event.
Converta o l-param para o spot deste event.
Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-paint com um window:
Call "user32.dll" "BeginPaint" com o window e o endereçamento desse paintstruct.
Call "user32.dll" "EndPaint" com o window e o endereçamento desta paintstruct.
Crie um event.
Atribua "atualização de tela" à categoria deste event.
\Atribua "refrescar" à categoria deste event.
Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-rbuttondblclk com um l-param:
Crie um event.
Atribua "right double click" à categoria deste event.
\Atribua "clic derecho doble" à categoria deste event.
Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
Se a tecla shift was para baixo, acione o detector de tecla shift deste event.
Converta o l-param para o spot deste event.
Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-rbuttondown com um l-param:
Crie um event.
Atribua "clique direito" à categoria deste event.
\Atribua "clic derecho" à categoria deste event.
Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
Se a tecla shift was para baixo, acione o detector de tecla shift deste event.
Converta o l-param para o spot deste event.
Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-setcursor:
Atualize o cursor.

Etapas necessárias para que se execute algum tipo de wm-syskeydown com um w-param e um l-param;
Etapas necessárias para que se execute algum tipo de wm-keydown com um w-param e um l-param:
Atribua o w-param a um tecla.
Se a tecla com o l-param é algum tipo de repeated escape ou modifier tecla, cancele.
Se a tecla for algum tipo de wm-char tecla, cancele.
Crie um event.
Atribua "pressionamento de tecla" à categoria deste event.
\Atribua "tecla abajo" à categoria deste event.
Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
Se a tecla shift was para baixo, acione o detector de tecla shift deste event.
Atribua a tecla à tecla deste event.
Enfileire o event.

Etapas necessárias para que se execute capitalize usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Relembre o text com "capitalize".
Capitalize algum tipo de rows selecionadas no text.
Square para cima algum tipo de seleção no text.
Wrap o text.

Etapas necessárias para que se efetue cópias usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Extraia um string from o text (pedaços selecionados).
Atribua o string sobre o área de transferência do Windows.

Etapas necessárias para que se execute cut usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Relembre o text.
Extraia um string from o text (pedaços selecionados).
Atribua o string sobre o área de transferência do Windows.
Remove algum tipo de pedaços selecionados no text.
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um console:
Se o console for inexistente, cancele.
Se a categoria deste event for "pressionamento de tecla", execute o event usando o console (pressionamento de tecla); exit.
Se a categoria deste event for "atualização de tela", execute o event usando o console (atualização de tela); exit.
Se a categoria deste event for "clique direito", execute o event usando o console (clique direito); exit.
Se a categoria deste event for "mostrar seta", execute o event usando o console (mostrar seta do mouse); exit.

Etapas necessárias para que se execute um event usando um console (tecla backspace):
Se o reply deste console estiver em branco, cancele.
Se o event foi alterado, cancele.
Execute o event usando o text deste console (tecla backspace).
Remove o last pedaço from o reply deste console.
Mostre o console.

Etapas necessárias para que se execute um event usando um console (seta pra baixo):
Role o text deste console para baixo one line.
Mostre o console.

Etapas necessárias para que se execute um event usando um console (tecla End):
Role o text deste console para o base.
Mostre o console.

Etapas necessárias para que se execute um event usando um console (tecla Enter):
Execute o event usando o text deste console (tecla Enter).
Relinquish control.

Etapas necessárias para que se execute um event usando um console (tecla Home):
Role o text deste console para o topo.
Mostre o console.

Etapas necessárias para que se execute um event usando um console (pressionamento de tecla):
Se a tecla deste event for a tecla backspace, execute o event usando o console (tecla backspace); exit.
Se a tecla deste event for a seta pra baixo, execute o event usando o console (seta pra baixo); exit.
Se a tecla deste event for a tecla End, execute o event usando o console (tecla End); exit.
Se a tecla deste event for a tecla Enter, execute o event usando o console (tecla Enter); exit.
Se a tecla deste event for a tecla Home, execute o event usando o console (tecla Home); exit.
Se a tecla deste event for a tecla PgDn, execute o event usando o console (tecla Page Down); exit.
Se a tecla deste event for a tecla PgUp, execute o event usando o console (tecla Page Up); exit.
Se a tecla deste event for a seta pra cima, execute o event usando o console (seta pra cima); exit.
Se o pedaço deste event não for printable, cancele.
Posponha o pedaço deste event para o reply deste console.
Execute o event usando o text deste console (caracteres gráficos).
Mostre o console.

Etapas necessárias para que se execute um event usando um console (tecla Page Down):
Role o text deste console para baixo one página.
Mostre o console.

Etapas necessárias para que se execute um event usando um console (tecla Page Up):
Role o text deste console para cima one página.
Mostre o console.

Etapas necessárias para que se execute um event usando um console (atualização de tela):
Mostre o console.

Etapas necessárias para que se execute um event usando um console (clique direito):
Mostre o hand cursor.
Role o console usando o event.
Atualize o cursor.

Etapas necessárias para que se execute um event usando um console (mostrar seta do mouse):
Mostre a seta do mouse.

Etapas necessárias para que se execute um event usando um console (seta pra cima):
Role o text deste console para cima one line.
Mostre o console.

Etapas necessárias para que se execute um event usando um terminal:
Se o terminal for inexistente, cancele.
Se a categoria deste event for "pressionamento de tecla", execute o event usando o terminal (pressionamento de tecla); exit.
Se a categoria deste event for "atualização de tela", execute o event usando o terminal (atualização de tela); exit.
Se a categoria deste event for "mostrar seta", execute o event usando o terminal (mostrar seta do mouse); exit.
Se a categoria deste event for "clique", relinquish control. \ *** added por invisível turtle book questionable

Etapas necessárias para que se execute um event usando um terminal (tecla backspace):
Se o reply deste terminal estiver em branco, cancele.
Se o event foi alterado, cancele.
Remove o last pedaço from o reply deste terminal.
Remove o last pedaço from o string deste last deste quora deste terminal.
Mostre o terminal.

Etapas necessárias para que se execute um event usando um terminal (tecla Enter):
Relinquish control. \Abdique

Etapas necessárias para que se execute um event usando um terminal (pressionamento de tecla):
Se a tecla deste event for a tecla backspace, execute o event usando o terminal (tecla backspace); exit.
Se a tecla deste event for a tecla Enter, execute o event usando o terminal (tecla Enter); exit.
Se o pedaço deste event não for printable, cancele.
Posponha o pedaço deste event para o reply deste terminal.
Posponha o pedaço deste event para o string deste last deste quora deste terminal.
Mostre o terminal.

Etapas necessárias para que se execute um event usando um terminal (atualização de tela):
Mostre o terminal.

Etapas necessárias para que se execute um event usando um terminal (mostrar seta do mouse):
Mostre a seta do mouse.

Etapas necessárias para que se execute um event usando um text (tecla backspace):
Se o text for inexistente, cancele.
Se não existir something para backspace no text, cancele.
Relembre o text com "backspace".
Se o event foi alterado, remova pedaços de o text (backspace com jump).
Se o event não foi alterado, remova pedaços de o text (backspace).
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Delete):
Se o text for inexistente, cancele.
Se não existir something para remove no text, cancele.
Relembre o text com "delete".
Se o event foi alterado, remova pedaços de o text (forward delete com jump).
Se o event não foi alterado, remova pedaços de o text (forward delete).
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (seta pra baixo):
Se o text for inexistente, cancele.
Se o caret of o text é sobre o last line, acione um detector.
Se o detector estiver ativo, mova o caret para o last pedaço of o text.
Se o detector não estiver ativo, mova o caret para baixo no text.
Se o detector de tecla shift deste event não estiver ativo, desselecione o text.
Limpe a última operação deste text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla End):
Se o text for inexistente, cancele.
Se o event foi alterado, mova o caret para o last pedaço of o text.
Se o event não foi alterado, mova o caret para o last pedaço of o current row of o text.
Se o detector de tecla shift deste event não estiver ativo, desselecione o text.
Limpe a última operação deste text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Enter):
Se o text for inexistente, cancele.
Relembre o text com "insert return".
Remove algum tipo de pedaços selecionados no text.
Insira o return pedaço ao text.
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Esc):
Se o text for inexistente, cancele.
Desselecione o text.

Etapas necessárias para que se execute um event usando um text (tecla Home):
Se o text for inexistente, cancele.
Se o event foi alterado, mova o caret para o first pedaço of o text.
Se o event não foi alterado, mova o caret para o first pedaço of o current row of o text.
Se o detector de tecla shift deste event não estiver ativo, desselecione o text.
Limpe a última operação deste text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (clique duplo):
Se o text for inexistente, cancele.
Desselecione o text.
Mova o caret right para algum tipo de non-alphanumeric pedaço no text.
Mova o anchor left para algum tipo de non-alphanumeric pedaço no text.

Etapas necessárias para que se execute um event usando um text (seta esquerda):
Se o text for inexistente, cancele.
Se o event foi alterado, jump o caret left no text.
Se o event não foi alterado, mova o caret left no text.
Se o detector de tecla shift deste event não estiver ativo, desselecione o text.
Limpe a última operação deste text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Page Down):
Se o text for inexistente, cancele.
Role o text para baixo one página.
Mova o caret para baixo one página no text.
Se o detector de tecla shift deste event não estiver ativo, desselecione o text.
Limpe a última operação deste text.

Etapas necessárias para que se execute um event usando um text (tecla Page Up):
Se o text for inexistente, cancele.
Role o text para cima one página.
Mova o caret para cima one página no text.
Se o detector de tecla shift deste event não estiver ativo, desselecione o text.
Limpe a última operação deste text.

Etapas necessárias para que se execute um event usando um text (caracteres gráficos):
Relembre o text com "insert".
Remove algum tipo de pedaços selecionados no text.
Insira o pedaço deste event ao text.
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (seta direita):
Se o text for inexistente, cancele.
Se o event foi alterado, jump o caret right no text.
Se o event não foi alterado, mova o caret right no text.
Se o detector de tecla shift deste event não estiver ativo, desselecione o text.
Limpe a última operação deste text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Tab):
Se o text for inexistente, cancele.
Relembre o text com "insert".
Remove algum tipo de pedaços selecionados no text.
Insira o caractere de espaço ao text.
Divida o caret column# deste text por 2 usando um quotient e um resto.
Se o resto for 0, insira o caractere de espaço ao text.
Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (seta pra cima):
Se o text for inexistente, cancele.
Mova o caret para cima no text.
Se o detector de tecla shift deste event não estiver ativo, desselecione o text.
Limpe a última operação deste text.
Role o text para o caret.

Etapas necessárias para que se execute events usando um console:
Se o console for inexistente, cancele.
Percorra.
Desenfileire um event.
Se o event for inexistente, cancele.
Execute o event usando o console.
Repita.

Etapas necessárias para que se execute events usando um terminal:
Se o terminal for inexistente, cancele.
Percorra.
Desenfileire um event.
Se o event for inexistente, cancele.
Execute o event usando o terminal.
Repita.

Etapas necessárias para que se mude tamanho usando um text e uma caixa e uma altura da fonte:
Se o text for inexistente, cancele.
Relembre o text com "altura da fonte".
Mude o text usando a caixa.
Mude o text usando o altura da fonte.

Etapas necessárias para que se mude tamanho usando um text e uma altura da fonte:
Se o text for inexistente, cancele.
Relembre o text com "altura da fonte".
Mude o text usando o altura da fonte.

Etapas necessárias para que se mude nome da fonte usando um text e uma nome da fonte:
Se o text for inexistente, cancele.
Relembre o text com "nome da fonte".
Mude o text usando o nome da fonte.

Etapas necessárias para que se execute indent usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Relembre o text com "dent".
Indent algum tipo de rows selecionadas no text.
Square para cima algum tipo de seleção no text.
Wrap o text.

Um número identificador é um número.

Etapas necessárias para que se execute lowercase usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Relembre o text com "case".
Lowercase algum tipo de pedaços selecionados no text.
Wrap o text.

Etapas necessárias para que se execute outdent usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Relembre o text com "dent".
Outdent algum tipo de rows selecionadas no text.
Square para cima algum tipo de seleção no text.
Wrap o text.

Etapas necessárias para que se execute paste usando um text:
Se o text for inexistente, cancele.
Se não existir text sobre o área de transferência do Windows, cancele.
Relembre o text.
Remove algum tipo de pedaços selecionados no text.
Obtenha um string from o área de transferência do Windows.
Insira o string ao text.
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se efetue alteração de cor usando um text e uma cor:
Se o text for inexistente, cancele.
Relembre o text com "pincel".
Atribua a cor ao pincel deste text.

Etapas necessárias para que se execute redo usando um text:
Se o text for inexistente, cancele.
Se o last destes redos deste text for inexistente, cancele.
Copie o text a uma segunda text.
Posponha a segunda text para os undos deste text.
Atribua o last destes redos deste text a um terceiro text.
Remove o terceiro text from os redos deste text.
Copie o guts of o terceiro text ao text.
Destrua o terceiro text.
Ligue o detector de alteração deste text.

Etapas necessárias para que se execute reverse usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Relembre o text com "reverse".
Reverse algum tipo de rows selecionadas of o text.
Square para cima algum tipo de seleção no text.
Wrap o text.

Etapas necessárias para que se execute select all usando um text:
Se o text for inexistente, cancele.
Selecione cada pedaço no text.

Etapas necessárias para que se execute classifique algum tipo de rows selecionadas usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Relembre o text com "classifique rows selecionadas".
Classifique algum tipo de rows selecionadas no text.
Square para cima algum tipo de seleção no text.
Wrap o text.

Etapas necessárias para que se execute undo usando um text:
Se o text for inexistente, cancele.
Se o last destes undos deste text for inexistente, cancele.
Copie o text a uma segunda text.
Posponha a segunda text para os redos deste text.
Atribua o last destes undos deste text a um terceiro text.
Remove o terceiro text from os undos deste text.
Copie o guts of o terceiro text ao text.
Destrua o terceiro text.
Ligue o detector de alteração deste text.

Etapas necessárias para que se execute uppercase usando um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Relembre o text com "case".
Uppercase algum tipo de pedaços selecionados no text.
Wrap o text.

Um hbitmap é um número identificador.

Um hbrush é um número identificador.

Um hdc é um número identificador.

Um orientação é uns points.

O contagem do heap é um número.

O endereço heap é um endereço de memória.

Um altura é uns twips.

Um texto hexadecimal é um string.

Um número da fonte é um número identificador.

Um hicon é um número identificador.

Etapas necessárias para que se hide o cursor:
Call "user32.dll" "ShowCursor" com 0 devolvendo um número.
Se o número for menor do que 0, cancele.
Repita.

Um horizontal line é um line.

Um hour é 60 minutes.

Um hpen é um número identificador.

Um hrgn é um número identificador.

Um matiz é uns precise degrees [0 para 3599].

An hundred é 100 units.

O i-beam cursor é um cursor.

\the erro do fluxo de entrada/saída é um string.

Um iid é um uuid.

Etapas necessárias para que se imagine uma caixa uns twips por uns segunda twips;
Etapas necessárias para que se make uma caixa uns twips por uns segunda twips:
Atribua 0 à coordenada esquerda desta caixa.
Atribua 0 à coordenada superior desta caixa.
Atribua os twips à coordenada direita desta caixa.
Atribua a segunda twips à coordenada inferior desta caixa.

Etapas necessárias para que se imagine uma caixa uns twips high por uns segunda twips wide;
Etapas necessárias para que se make uma caixa uns twips high por uns segunda twips wide:
Atribua 0 e 0 e a segunda twips e os twips ao caixa.

Etapas necessárias para que se imagine uma caixa uns twips smaller do que uma segunda caixa;
Etapas necessárias para que se make uma caixa uns twips smaller do que uma segunda caixa:
Atribua a segunda caixa ao caixa.
Indent a caixa pelo twips dividido por 2.

Etapas necessárias para que se imagine uma caixa uns twips smaller do que uma segunda caixa sobre cada side:
Atribua a segunda caixa ao caixa.
Indent a caixa pelo twips.

Etapas necessárias para que se imagine uma caixa uns twips wide por uns segunda twips high;
Etapas necessárias para que se make uma caixa uns twips wide por uns segunda twips high:
Atribua 0 e 0 e os twips e a segunda twips ao caixa.

Etapas necessárias para que se imagine uma caixa com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior;
Etapas necessárias para que se make uma caixa com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior:
Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior ao caixa.

Etapas necessárias para que se imagine uma caixa com um spot e uma segunda spot;
Etapas necessárias para que se make uma caixa com um spot e uma segunda spot:
Atribua o spot e a segunda spot ao caixa.

Etapas necessárias para que se imagine uma cor from um matiz e um saturação e um luminosidade;
Etapas necessárias para que se make uma cor from um matiz e um saturação e um luminosidade:
Atribua o matiz e o saturação e o luminosidade à cor.

Etapas necessárias para que se imagine um dot about uns twips wide;
Etapas necessárias para que se make um dot about uns twips wide;
Etapas necessárias para que se make um dot uns twips wide:
Make o dot os twips pelo twips.

Etapas necessárias para que se imagine um dot between uns twips e uns segunda twips wide;
Etapas necessárias para que se make um dot between uns twips e uns segunda twips wide:
Escolha aleatoriamente uns terceiro twips between os twips e a segunda twips.
Make o dot o terceiro twips wide.

Etapas necessárias para que se imagine um elipse usando uma caixa;
Etapas necessárias para que se make um elipse usando uma caixa:
Atribua a caixa à caixa desta elipse.

Etapas necessárias para que se imagine um elipse uns twips por uns segunda twips;
Etapas necessárias para que se make um elipse uns twips por uns segunda twips:
Atribua 0 à coordenada esquerda desta elipse.
Atribua 0 à coordenada superior desta elipse.
Atribua os twips à coordenada direita desta elipse.
Atribua a segunda twips à coordenada inferior desta elipse.

Etapas necessárias para que se imagine um elipse com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior;
Etapas necessárias para que se make um elipse com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior:
Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior ao elipse.

Etapas necessárias para que se imagine um elipse com um spot e uma segunda spot;
Etapas necessárias para que se make um elipse com um spot e uma segunda spot:
Atribua o spot e a segunda spot ao elipse.

Etapas necessárias para que se imagine uma figura using um string e um spot;
Etapas necessárias para que se make uma figura using um string e um spot;
Etapas necessárias para que se crie uma figura using um string e um center spot:
Crie a figura.
Posponha a figura para as figuras.
Isole o string.
Lowercase o string.
Lance um subtexto sobre o string.
Percorra.
Skip algum tipo de leading noise no subtexto.
Se o quantidade de caracteres deste subtexto for menor do que 2, cancele.
Atribua o target deste first deste subtexto a um pedaço.
Atribua o pedaço menos o 'a' minúsculo ao y desse spot.
Adicione 1 para o first deste subtexto.
Atribua o target deste first deste subtexto ao pedaço.
Atribua o pedaço menos o 'a' minúsculo ao x deste spot.
Multiplique o spot por 24 px.
Adicione o x deste center spot menos 299 pixels para o x deste spot.
Adicione o y deste center spot menos 299 pixels para o y deste spot.
Posponha o spot para a figura.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se imagine um horizontal line uma fração of o way para cima from o base of uma caixa;
Etapas necessárias para que se make um horizontal line uma fração of o way para cima from o base of uma caixa:
Imagine o horizontal line across a caixa a fração of o way para cima from o base.

Etapas necessárias para que se imagine um line across o base of uma caixa;
Etapas necessárias para que se make um line across o base of uma caixa;
Etapas necessárias para que se imagine um line along o base of uma caixa;
Etapas necessárias para que se make um line along o base of uma caixa:
Atribua a coordenada inferior desta caixa line ao line.

Etapas necessárias para que se imagine um line across uma caixa uma fração of o way para cima from o base;
Etapas necessárias para que se make um line across uma caixa uma fração of o way para cima from o base:
Atribua a coordenada esquerda desta caixa ao x deste start desta line.
Atribua a coordenada direita desta caixa ao x deste end desta line.
Atribua a coordenada inferior desta caixa times a fração a uns twips.
Atribua a coordenada inferior desta caixa menos os twips ao y deste start desta line.
Atribua a coordenada inferior desta caixa menos os twips ao y deste end desta line.

Etapas necessárias para que se imagine um line across o topo of uma caixa;
Etapas necessárias para que se make um line across o topo of uma caixa;
Etapas necessárias para que se imagine um line along o topo of uma caixa;
Etapas necessárias para que se make um line along o topo of uma caixa:
Atribua a coordenada superior desta caixa line ao line.

Etapas necessárias para que se imagine um line no middle of uma caixa;
Etapas necessárias para que se make um line no middle of uma caixa;
Etapas necessárias para que se imagine um line across o middle of uma caixa;
Etapas necessárias para que se make um line across o middle of uma caixa;
Etapas necessárias para que se imagine um line no center of uma caixa;
Etapas necessárias para que se make um line no center of uma caixa;
Etapas necessárias para que se imagine um line across o center of uma caixa;
Etapas necessárias para que se make um line across o center of uma caixa:
Atribua a coordenada esquerda desta caixa ao x deste start desta line.
Atribua a coordenada direita desta caixa ao x deste end desta line.
Atribua o y deste center desta caixa ao y deste start desta line.
Atribua o y deste center desta caixa ao y deste end desta line.

Etapas necessárias para que se imagine um line uns twips para cima from o base of uma caixa;
Etapas necessárias para que se make um line uns twips para cima from o base of uma caixa:
Atribua a coordenada esquerda desta caixa ao x deste start desta line.
Atribua a coordenada direita desta caixa ao x deste end desta line.
Atribua a coordenada inferior desta caixa menos os twips ao y deste start desta line.
Atribua a coordenada inferior desta caixa menos os twips ao y deste end desta line.

Etapas necessárias para que se imagine um line com um spot e uma segunda spot;
Etapas necessárias para que se make um line com um spot e uma segunda spot:
Atribua o spot e a segunda spot ao line.

Etapas necessárias para que se imagine um line com uma coordenada x e uma coordenada y e uma segunda coordenada x e uma segunda coordenada y;
Etapas necessárias para que se make um line com uma coordenada x e uma coordenada y e uma segunda coordenada x e uma segunda coordenada y:
Atribua a coordenada x e a coordenada y e a segunda coordenada x e a segunda coordenada y ao line.

Etapas necessárias para que se imagine uma caixa arredondada from uma caixa e um raio;
Etapas necessárias para que se make uma caixa arredondada from uma caixa e um raio:
Atribua a caixa e o raio ao caixa arredondada.

Etapas necessárias para que se imagine uma caixa arredondada uns twips por uns segunda twips;
Etapas necessárias para que se make uma caixa arredondada uns twips por uns segunda twips com um raio:
Atribua 0 à coordenada esquerda desta caixa arredondada.
Atribua 0 à coordenada superior desta caixa arredondada.
Atribua os twips à coordenada direita desta caixa arredondada.
Atribua a segunda twips à coordenada inferior desta caixa arredondada.
Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se imagine uma caixa arredondada com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior e um raio;
Etapas necessárias para que se make uma caixa arredondada com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior e um raio:
Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior e o raio ao caixa arredondada.

Etapas necessárias para que se imagine uma caixa arredondada com um spot e uma segunda spot e um raio;
Etapas necessárias para que se make uma caixa arredondada com um spot e uma segunda spot e um raio:
Atribua o spot e a segunda spot e o raio ao caixa arredondada.

Etapas necessárias para que se imagine um spot com uma coordenada x e uma coordenada y;
Etapas necessárias para que se make um spot com uma coordenada x e uma coordenada y:
Atribua a coordenada x e a coordenada y ao spot.

Etapas necessárias para que se include uma font no current pdf:
Encontre um pdf object usando o nome desta font e o font catálogo deste pdf state.
Se o pdf object não for inexistente, cancele.
Crie uma font info usando o font.
Converta o font info para pdf em units.
\ stream
Atribua o actual data of o font a um trecho.
Converta o trecho para um cifra hexadecimal.
Adicione um stream pdf object usando "font stream".
Posponha o número deste stream seguido de " 0 obj" para o stream.
Posponha "<<" para o stream sem advancing.
Posponha "/Filter /ASCIIHexDecode" para o stream sem advancing.
Posponha " /Length " seguido de o quantidade de caracteres deste cifra hexadecimal para o stream sem advancing.
Posponha " /Length1 " seguido de o quantidade de caracteres deste trecho para o stream sem advancing.
Posponha ">>" para o stream.
Posponha "stream" para o stream.
Posponha o cifra hexadecimal para o stream.
Posponha "endstream" para o stream.
Posponha "endobj" para o stream.
\ descriptor
Adicione um descriptor pdf object usando "font descriptor".
Atribua "F" seguido de o número deste descriptor a uma nome da fonte.
Atribua o nome desta font a uma font base nome.
Replace o caractere de espaço com o underscore pedaço no font base nome.
Posponha o número deste descriptor seguido de " 0 obj" para o descriptor.
Posponha "<<" para o descriptor.
Posponha "/Type /FontDescriptor" para o descriptor.
Posponha "/FontNomeie /" seguido de o font base nome para o descriptor.
Posponha "/FontFile2 " seguido de o número deste stream seguido de " 0 R" para o descriptor.
Posponha "/alarmes " seguido de o flags deste font info para o descriptor.
Posponha "/FontBBox [" seguido de a font caixa desta font info seguido de "]" para o descriptor.
Posponha "/Ascent " seguido de o ascent desta font info para o descriptor.
Posponha "/Descent " seguido de o descent desta font info para o descriptor.
Posponha "/CapHeight " seguido de o capheight desta font info para o descriptor.
Posponha "/ItalicAngle " seguido de o italicangle desta font info para o descriptor.
Posponha "/StemV " seguido de o stemv desta font info para o descriptor.
Posponha ">>" para o descriptor.
Posponha "endobj" para o descriptor.
\ definition
Adicione um definition pdf object usando "font definition".
Atribua o nome da fonte ao nome da fonte desta definition.
Posponha o número desta definition seguido de " 0 obj" para o definition.
Posponha "<<" para o definition.
Posponha "/Type /Font" para o definition.
Posponha "/Subtype /TrueType" para o definition.
Posponha "/Nomeie /" seguido de o nome da fonte para o definition.
Posponha "/BaseFont /" seguido de o font base nome para o definition.
Posponha "/Encoding /WinAnsiEncoding" para o definition.
Posponha "/FontDescriptor " seguido de o número deste descriptor seguido de " 0 R" para o definition.
Posponha "/FirstChar 0" para o definition.
Posponha "/LastChar 255" para o definition.
Atribua as font larguras desta font info a uma segunda trecho.
Posponha "/Widths [" para o definition.
Posponha a segunda trecho seguido de "]" para o definition.
Posponha ">>" para o definition.
Posponha "endobj" para o definition.
Atribua o font info à font info desta definition.
Catalogue o definition usando o nome desta font e o font catálogo deste pdf state.

Etapas necessárias para que se include uma font em um pdf object:
Se o pdf object for inexistente, cancele.
Encontre uma font pdf object usando o nome desta font e o font catálogo deste pdf state.
Se o font pdf object for inexistente, cancele.
Atribua "/" seguido de o nome da fonte deste font pdf object seguido de " " seguido de o número deste font pdf object seguido de " 0 R" a um string.
Encontre um conjunto de texto usando o string e os font strings deste pdf object.
Se o conjunto de texto não for inexistente, cancele.
Crie um new conjunto de texto usando o string.
Posponha o new conjunto de texto para os font strings deste pdf object.

Etapas necessárias para que se indent algum tipo de rows selecionadas em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Se a row estiver em branco, repita.
Anteponha o caractere de espaço para o string deste row.
Anteponha o caractere de espaço para o string deste row.
Repita.

Um indent é uma contagem.

An catálogo é uma coisa com
Um contagem de buckets,
Um first bucket e um last bucket.

Etapas necessárias para que se catalogue um endereço de memória usando um string e um catálogo:
\ if o catálogo for inexistente, cancele. \ para make compilador faster
Se o quantidade de caracteres deste string for 0, cancele.
Obtenha um bucket usando o string e o catálogo.
Crie um refer.
Posponha o refer para os refers deste bucket.
Atribua o string ao string deste refer.
Atribua o endereço de memória ao endereço de memória deste refer.

Etapas necessárias para que se catalogue um string em um catálogo:
\ if o catálogo for inexistente, cancele. \ para make compilador faster
Catalogue nil usando o string e o catálogo.

Etapas necessárias para que se initalize o terminal:
Crie o terminal na caixa desta tela.

Etapas necessárias para que se initialize before run:
Call "user32.dll" "DisableProcessWindowsGhosting".
Call "kernel32.dll" "GetProcessHeap" devolvendo o endereço heap.
Call "kernel32.dll" "LoadLibraryA" com "kernel32.dll"'s first devolvendo um número identificador.
Se o número identificador não for 0, call "kernel32.dll" "GetProcAddress" com o número identificador e "HeapSetInformation"'s first devolvendo um endereço de memória.
Se o endereço de memória não for inexistente, call o endereço de memória com o endereço heap e 0 e 2's endereçamento e 4.

Etapas necessárias para que se inicialize o canvases:
Inicialize o tela canvas.
Inicialize o memory canvas.
Atribua o memory canvas ao quadro atual.

Etapas necessárias para que se inicialize o cgi:
Call "kernel32.dll" "AllocConsole".
Call "kernel32.dll" "GetStdHandle" com -10 [std_input_handle] devolvendo o número identificador do fluxo de entrada padrão.
Call "kernel32.dll" "GetStdHandle" com -11 [std_output_handle] devolvendo o número identificador do fluxo de saída padrão.

Etapas necessárias para que se inicialize o Component Object Model:
Call "ole32.dll" "CoInitializeEx" com 0 e 2 [coinit_apartmentthreaded].

Etapas necessárias para que se inicialize um context:
Aloque memória para o context.
Atribua o center desta tela ao spot deste context.
Atribua 0 à orientação deste context.
Atribua a cor verde à cor deste context.
Atribua o tamanho de letra pequena à tamanho da letra deste context.
\Atribua 1/60 second ao delay. ***
Seed o random número generator.

Etapas necessárias para que se inicialize os cursors:
Inicialize o cursors (seta do mouse).
Inicialize o cursors (hand cursor).
Inicialize o cursors (i-beam cursor).
\Atribua a seta do mouse ao cursor flecha.
\Atribua o hand cursor ao cursor mano.
\Atribua o i-beam cursor ao cursor rayo-i.
Hide o cursor.

Etapas necessárias para que se inicialize os cursors (seta do mouse):
Posponha $00000000000000004000000060000000 para um máscara de disjunção exclusiva.
Posponha $70000000780000007C0000007E000000 para o máscara de disjunção exclusiva.
Posponha $7F0000007F8000007C0000006C000000 para o máscara de disjunção exclusiva.
Posponha $46000000060000000300000003000000 para o máscara de disjunção exclusiva.
Posponha $01800000018000000000000000000000 para o máscara de disjunção exclusiva.
Posponha $00 para o máscara de disjunção exclusiva usando 48.
Posponha $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF para um máscara de conjunção lógica.
Posponha $07FFFFFF03FFFFFF01FFFFFF00FFFFFF para o máscara de conjunção lógica.
Posponha $007FFFFF003FFFFF001FFFFF01FFFFFF para o máscara de conjunção lógica.
Posponha $10FFFFFF30FFFFFF787FFFFFF87FFFFF para o máscara de conjunção lógica.
Posponha $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF para o máscara de conjunção lógica.
Posponha $FF para o máscara de conjunção lógica usando 48.
Call "user32.dll" "CreateCursor" com o número identificador deste module e 0 e 0 e 32 e 32 e o first desta máscara de conjunção lógica e o first desta máscara de disjunção exclusiva devolvendo a seta do mouse.

Etapas necessárias para que se inicialize o cursors (hand cursor):
Posponha $000000000180000019B0000019B00000 para um máscara de disjunção exclusiva.
Posponha $0DB200000DB6000007F6000067FE0000 para o máscara de disjunção exclusiva.
Posponha $7FFC00003FFC00001FFC00001FF80000 para o máscara de disjunção exclusiva.
Posponha $0FF8000007F0000003F0000003F00000 para o máscara de disjunção exclusiva.
Posponha $00 para o máscara de disjunção exclusiva usando 64.
Posponha $FE7FFFFFE40FFFFFC007FFFFC005FFFF para um máscara de conjunção lógica.
Posponha $E000FFFFE000FFFF9000FFFF0000FFFF para o máscara de conjunção lógica.
Posponha $0001FFFF8001FFFFC001FFFFC003FFFF para o máscara de conjunção lógica.
Posponha $E003FFFFF007FFFFF807FFFFF807FFFF para o máscara de conjunção lógica.
Posponha $FF para o máscara de conjunção lógica usando 64.
Call "user32.dll" "CreateCursor" com o número identificador deste module e 2 e 1 e 32 e 32 e o first desta máscara de conjunção lógica e o first desta máscara de disjunção exclusiva devolvendo o hand cursor.

Etapas necessárias para que se inicialize o cursors (i-beam cursor):
Posponha $EE000000100000001000000010000000 para um máscara de disjunção exclusiva.
Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
Posponha $100000001000000010000000EE000000 para o máscara de disjunção exclusiva.
Posponha $00 para o máscara de disjunção exclusiva usando 64.
Posponha $FF para um máscara de conjunção lógica usando 128.
Call "user32.dll" "CreateCursor" com o número identificador deste module e 3 e 7 e 32 e 32 e o first desta máscara de conjunção lógica e o first desta máscara de disjunção exclusiva devolvendo o i-beam cursor.

Etapas necessárias para que se inicialize as fonts:
Call "gdi32.dll" "GetStockObject" com 11 [ansi_fixed_font] devolvendo o null número da fonte.
\Call "gdi32.dll" "AddFontMemResourceEx" com o first desta osmosian font source e o quantidade de caracteres desta osmosian font source e 0 e o endereçamento desse número devolvendo o osmosian font resource.
\Call "gdi32.dll" "AddFontMemResourceEx" com o first desta fonte Segoe UI e o quantidade de caracteres desta fonte Segoe UI e 0 e o endereçamento desse número devolvendo o Segoe UI resource.
Call "gdi32.dll" "AddFontMemResourceEx" com o first desta fonte Tahoma e o quantidade de caracteres desta fonte Tahoma e 0 e o endereçamento desse número devolvendo o recurso de fonte Tahoma.
\Atribua "Segoe UI" e 1/6 polegada à fonte padrão.
\Atribua "osmosian" e 24 pixels à fonte padrão.
Atribua "Tahoma" e 20 pixels à fonte padrão.
\ stroked fonts below
Atribua 12 pixels ao tamanho de letra pequena.
Atribua 24 pixels ao tamanho de letra médio.
Atribua 48 pixels ao tamanho de letra grande.

Etapas necessárias para que se inicialize gdi+:
Atribua 1 ao GdiplusVersion desse GdiplusStartupInput.
Call "gdiplus.dll" "GdiplusStartup" com o endereçamento deste gptoken e o endereçamento deste GdiplusStartupInput e 0.
\Windows GDI+ é uma API baseada em classe para programadores C/C++. 
\Ela permite que os aplicativos usem elementos gráficos e texto formatado na exibição de vídeo e na impressora. 
\Aplicativos baseados na API do Microsoft Win32 não acessam diretamente o hardware gráfico. 
\Em vez disso, GDI+ interage com drivers de dispositivo em nome de aplicativos. 
\GDI+ também é suportado pelo Microsoft Win64.

Etapas necessárias para que se inicialize o memory canvas:
Call "gdi32.dll" "CreateCompatibleDC" com o tela canvas devolvendo o memory canvas.
Call "gdi32.dll" "GetCurrentObject" com o memory canvas e 7 [obj_bitmap] devolvendo o saved memory hbitmap.
Call "gdi32.dll" "CreateCompatibleBitmap" com o tela canvas e a pixel largura desta tela e a pixel altura desta tela devolvendo um hbitmap.
Call "gdi32.dll" "SelectObject" com o memory canvas e o hbitmap.
Normalize o memory canvas.

Etapas necessárias para que se inicialize o module:
\ temp endereço completo
Atribua 512 a um quantidade de caracteres.
Reassign o first deste temp endereço completo usando o quantidade de caracteres.
Call "kernel32.dll" "GetTempPathA" com o quantidade de caracteres e o first deste temp endereço completo devolvendo o quantidade de caracteres.
Atribua o first deste temp endereço completo mais o quantidade de caracteres menos 1 ao last deste temp endereço completo.
Modifique através do caractere NUL o temp endereço completo.
\ module handle
Call "kernel32.dll" "GetModuleHandleA" com 0 devolvendo o número identificador deste module.
\ module nome
Atribua 512 ao quantidade de caracteres.
Reassign o first deste endereço completo deste module usando o quantidade de caracteres.
Call "kernel32.dll" "GetModuleFileNameA" com o número identificador deste module e o first deste endereço completo deste module e o quantidade de caracteres devolvendo o quantidade de caracteres.
Atribua o first deste endereço completo deste module mais o quantidade de caracteres menos 1 ao last deste endereço completo deste module.
Se o endereço completo deste module começa com "\\?\", remove leading pedaços from o endereço completo deste module usando 4.
Lowercase o endereço completo deste module.
Modifique através do caractere NUL o endereço completo deste module. \ segunda endereço completo pieces deste module
Extraia o nome deste module from o endereço completo deste module.
Modifique através do caractere NUL o nome deste module.
Extraia o endereço da pasta deste module from o endereço completo deste module.
Modifique através do caractere NUL o endereço da pasta deste module.
Extraia o root endereço da pasta deste module from o endereço da pasta deste module.
Modifique através do caractere NUL o root endereço da pasta deste module.

Etapas necessárias para que se inicialize o mouse:
Atribua 1 ao botão esquerdo deste mouse.
Atribua 2 ao botão direito deste mouse.
Call "user32.dll" "GetSystemMetrics" com 23 [sm_swapbutton] devolvendo um número.
Se o número for 0, cancele.
Permute o botão esquerdo deste mouse com o botão direito deste mouse.

Etapas necessárias para que se inicialize o printer canvas:
Atribua a magnitude desse printdlgex ao lstructsize deste printdlgex.
Atribua o main window ao hwndowner deste printdlgex.
Atribua 1288 [pd_returndc + pd_returndefault + pd_nopageenums] ao flags deste printdlgex.
Atribua -1 [start_page_general] ao nstartpage deste printdlgex.
Call "comdlg32.dll" "PrintDlgExA" com o endereçamento deste printdlgex.
Call "kernel32.dll" "GlobalFree" com o hdevnames deste printdlgex.
Atribua o hdevmode deste printdlgex ao número identificador do modo de dispositivo da impressora.
Atribua o hdc deste printdlgex ao printer canvas.

Etapas necessárias para que se inicialize o tela:
Call "user32.dll" "GetSystemMetrics" com 0 [sm_cxscreen] devolvendo a pixel largura desta tela.
Call "user32.dll" "GetSystemMetrics" com 1 [sm_cyscreen] devolvendo a pixel altura desta tela.
Atribua 96 ao ppi.
Atribua o tpi dividido pelo ppi ao tpp.
Atribua a pixel largura desta tela times o tpp a um largura.
Atribua a pixel altura desta tela times o tpp a uma altura.
Atribua 0 e 0 e o largura e o altura à caixa desta tela.
Subtraia o tpp from o canto inferior direito desta tela.

Etapas necessárias para que se inicialize o tela canvas:
Call "user32.dll" "GetDC" com o main window devolvendo o tela canvas.
Normalize o tela canvas.

Etapas necessárias para que se inicialize um talker:
Converta "{96749377-3391-11D2-9EE3-00C04F797396}" [clsid_spvoice] para um clsid.
Converta "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [iid_ispvoice] para um iid.
Call "ole32.dll" "CoCreateInstance" com o endereçamento deste clsid e 0 e 7 [clsctx_all] e o endereçamento deste iid e o endereçamento deste talker.

Etapas necessárias para que se inicialize a window: \\ para inicializar a janela
Atribua a magnitude dessa window class ao cbsize deste window class.
Atribua 40 [cs_owndc + cs_dblclks] ao style deste window class.
Point o lpfnwndproc deste window class para rotina handle algum tipo de message com um window um message número um w-param e um l-param.
Atribua o número identificador deste module ao hinstance desta window class.
Atribua o first deste nome deste module ao lpszclassname desta window class.
Call "user32.dll" "RegisterClassExA" com o endereçamento deste window class.
Call "user32.dll" "CreateWindowExA" com 
0  \\  o estilo opcional da janela, como transparências por exemplo. veja mais detalhes em  https://docs.microsoft.com/en-us/windows/desktop/winmsg/extended-window-styles
e o first deste nome deste module  \\ O nome da classe da janela
e o first deste nome deste module  \\ O texto da janela
e 2147483648 [13565952  WS_OVERLAPPEDWINDOW]  [-2147483648 = ws_popup]   \\  aqui define o tipo da janela. Use valores em decimal;  
\\para isso Converta os valores hexadecimais da lista  https://www.autoitscript.com/autoit3/docs/appendix/GUIStyles.htm para decimal;
\\ O valor na documentação do windows está em hexadecimal (ou em string), mas esse compilador usa números inteiros (longint). 
\\ Para colocar a barra padrão, use o valor 13565952
e 0  \\ posição horizontal inicial da janela
e 0  \\ // posição vertical inicial da janela
e a pixel largura desta tela  \\ A largura da janela em pixels;
e a pixel altura desta tela  \\ A altura da janela em pixels
e 0  \\ opcional. Informa o número identificador do controle pai da janela (se existir) ou da janela em si
e 0 \\ a mesma coisa, só que identifica o número do menu da janela.
e o número identificador deste module  \\ descrição auto explicável
e 0. \\ aqui é um ponteiro que passa a informação pra janela. Usamos um valor nulo pq não precisamos dele.

\\ HWND CreateWindowExA(
\\  DWORD     dwExStyle,  \\ The extended window style of the window being created. For a liste of possible values, see https://docs.microsoft.com/en-us/windows/desktop/winmsg/extended-window-styles
\\   LPCSTR    lpClassName,  \\ A null-terminated string or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. 
\\ The atom must be in the low-order word of lpClassName; the high-order word must be zero. 
\\ If lpClassNomeie is a string, it specifies the window class nome. 
\\The class nome can be algum tipo de nome registered with RegisterClass or RegisterClassEx, provided that the module that registers the class is also the module that creates the window. 
\\ The class nome can also be algum tipo de of the predefined system class names.
 \\ LPCSTR    lpWindowName, \\ The window nome. 
 \\ If the window style specifies a title bar, the window title pointed to by lpWindowNomeie is displayed in the title bar. 
 \\ When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use lpWindowNomeie to specify the text of the control. When creating a static control with the SS_ICON style, use lpWindowNomeie to specify the icon nome or identifier. To specify an identifier, use the syntax "#num".
 \\ DWORD     dwStyle,  \\ The style of the window being created. 
 \\ This parameter can be a combination of the window style values, plus the control styles indicated in the Remarks section.
\\  int       X,\\  The initial horizontal position of the window. 
\\ For an overlapped or pop-para cima window, the x parameter is the initial x-coordinate of the window's upper-left corner, in screen coordinates. 
\\For a child window, x is the x-coordinate of the upper-left corner of the window relative to the upper-left corner of the parent window's client area. 
\\If x is set to CW_USEDEFAULT, the system selects the default position for the window's upper-left corner and ignores the y parameter. 
\\CW_USEDEFAULT is valid only for overlapped windows; if it is specified for a pop-para cima or child window, the x and y parameters are set to zero.
\\  int       Y,
\\  int       nWidth,
\\  int       nHeight,
\\  HWND      hWndParent,
\\  HMENU     hMenu,
\\  HINSTANCE hInstance,
\\  LPVOID    lpParam
\\);

Call "user32.dll" "ShowWindow" com o main window e 1 [sw_shownormal].

Etapas necessárias para que se inicialize winsock:
Call "ws2_32.dll" "WSAStartup" com 2 e o endereçamento desse wsadata.

Um input é um event.

Etapas necessárias para que se insira um pedaço Para um text:
Se o text for inexistente, cancele.
Atribua o pedaço a um string.
Insira o string ao text.

Etapas necessárias para que se insira um spot Para um polígono after um vértice:
Se o polígono for inexistente, cancele.
Crie uma segunda vértice usando o spot.
Insira a segunda vértice aos vértices deste polígono after o vértice.

Etapas necessárias para que se insira um string Para uma segunda string antes de um byte#:
Se o quantidade de caracteres deste string for 0, cancele.
Isole o byte#.
Limite o byte# para 1 e o quantidade de caracteres deste segunda string mais 1.
Lance um subtexto sobre a segunda string. \ left side
Atribua o first deste subtexto mais o byte# menos 2 ao last deste subtexto.
Lance uma segunda subtexto sobre a segunda string. \ right side
Atribua o first deste segunda subtexto mais o byte# menos 1 ao first deste segunda subtexto.
Atribua o quantidade de caracteres deste segunda string mais o quantidade de caracteres deste string a um quantidade de caracteres agrupados.
Reassign um endereço de memória usando o quantidade de caracteres agrupados.
Atribua o endereço de memória ao first desse terceiro subtexto.
Copie pedaços from o first deste subtexto para o first deste terceiro subtexto pelo quantidade de caracteres deste subtexto.
Adicione o quantidade de caracteres deste subtexto para o first deste terceiro subtexto.
Copie pedaços from o first deste string para o first deste terceiro subtexto pelo quantidade de caracteres deste string.
Adicione o quantidade de caracteres deste string para o first deste terceiro subtexto.
Copie pedaços from o first deste segunda subtexto para o first deste terceiro subtexto pelo quantidade de caracteres deste segunda subtexto.
Unassign o first deste segunda string. \ dont use atribua um string a um string para prevent extra allocating e copying
Atribua o endereço de memória ao first deste segunda string.
Atribua o first deste segunda string mais o quantidade de caracteres agrupados menos 1 ao last deste segunda string.

Etapas necessárias para que se insira um string Para um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Atribua o quantidade de caracteres deste string desta row menos o caret column# deste text a um número.
Atribua o string deste row a uma segunda string.
Insira o string ao segunda string antes de o caret column# deste text.
Converta a segunda string para uns rows.
Atribua o last destas rows a uma segunda row.
Insira a rows A as rows deste text antes de a row.
Remove a row from as rows deste text.
Destrua a row.
Renumber as rows deste text.
Atribua o número da linha desta segunda row ao número de linhas do cursor deste text.
Atribua o quantidade de caracteres deste string desta segunda row menos o número ao caret column# deste text.
Desselecione o text.

Etapas necessárias para que se insira uma coisa para uns coisas after uma segunda coisa:
Se a coisa for inexistente, cancele.
Se a segunda coisa for inexistente, anteponha a coisa para as coisas; exit.
Insira a coisa a as coisas antes de o next desta segunda coisa.

Etapas necessárias para que se insira uma coisa para uns coisas antes de uma segunda coisa:
Se a coisa for inexistente, cancele.
Se as coisas estiverem vazio, posponha a coisa para as coisas; exit.
Se a segunda coisa for inexistente, posponha a coisa para as coisas; exit.
Se a segunda coisa for o first destas coisas, anteponha a coisa para as coisas; exit.
Atribua a coisa a uma new coisa.
Atribua a segunda coisa a uma previous coisa.
Atribua a new coisa ao next deste previous desta previous coisa.
Atribua a previous coisa ao next desta new coisa.
Atribua o previous desta previous coisa ao previous desta new coisa.
Atribua o new coisa ao previous desta previous coisa.

Etapas necessárias para que se insira uns coisas para uns segunda coisas after um coisa:
Se a coisa for inexistente, anteponha  as coisas para a segunda coisas; exit.
Insira  as coisas ao segunda coisas antes de o next desta coisa.

Etapas necessárias para que se insira uns coisas para uns segunda coisas antes de um coisa:
Isole o coisa.
Percorra.
Atribua o first destas coisas a uma segunda coisa.
Se a segunda coisa for inexistente, cancele.
Remove a segunda coisa from as coisas.
Insira a segunda coisa ao segunda coisas antes de o coisa.
Repita.

Etapas necessárias para que se insira um vértice para um polígono after uma segunda vértice:
Se o polígono for inexistente, cancele.
Se o vértice for inexistente, cancele.
Insira o vértice aos vértices deste polígono after a segunda vértice.

Etapas necessárias para que se insira um vértice para um polígono at um spot:
Se o polígono for inexistente, cancele.
Se o vértice for inexistente, cancele.
Percorra.
Obtenha uma segunda vértice from os vértices deste polígono.
Se a segunda vértice for inexistente, cancele.
Se o next deste segunda vértice for inexistente, cancele.
Atribua o spot deste segunda vértice e o spot deste next deste segunda vértice a uma line.
Se o spot não estiver sobre a line, repita.
Insira o vértice aos vértices deste polígono after a segunda vértice.

Etapas necessárias para que se insira um vértice para um polígono antes de uma segunda vértice:
Se o polígono for inexistente, cancele.
Se o vértice for inexistente, cancele.
Insira o vértice aos vértices deste polígono antes de a segunda vértice.

Etapas necessárias para que se intersect uma caixa com uma segunda caixa usando um terceiro caixa:
\ caixas does not touch
Limpe o terceiro caixa.
Se a coordenada esquerda desta caixa for maior do que a coordenada direita desta segunda caixa, cancele.
Se a coordenada superior desta caixa for maior do que a coordenada inferior desta segunda caixa, cancele.
Se a coordenada direita desta caixa for menor do que a coordenada esquerda desta segunda caixa, cancele.
Se a coordenada inferior desta caixa for menor do que a coordenada superior desta segunda caixa, cancele.
\ caixas touch
Atribua a caixa ao terceiro caixa.
Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda desta segunda caixa, atribua a coordenada esquerda desta segunda caixa à coordenada esquerda desta terceiro caixa.
Se a coordenada superior desta caixa for menor do que a coordenada superior desta segunda caixa, atribua a coordenada superior desta segunda caixa à coordenada superior desta terceiro caixa.
Se a coordenada direita desta caixa for maior do que a coordenada direita desta segunda caixa, atribua a coordenada direita desta segunda caixa à coordenada direita desta terceiro caixa.
Se a coordenada inferior desta caixa for maior do que a coordenada inferior desta segunda caixa, atribua a coordenada inferior desta segunda caixa à coordenada inferior desta terceiro caixa.

\Etapas necessárias para que se invert um detector:
\ see "reverse um detector"
\Se o detector for yes, atribua no ao detector; exit.
\Atribua yes ao detector.

Um in_addr é um conjunto com \https://docs.microsoft.com/en-us/windows/win32/api/inaddr/ns-inaddr-in_addr
\A estrutura in_addr representa um endereço IPv4.
Um pedaço denominado s_b1, \ O endereço IPv4 do host formatado como quatro u_chars.
Um pedaço denominado s_b2,
Um pedaço denominado s_b3,
Um pedaço denominado s_b4,
Um wyrd [unsigned] denominado s_w1 at o s_b1, \O endereço IPv4 do host formatado como dois u_shorts.
Um wyrd [unsigned] denominado s_w2 at o s_b3,
Um número denominado s_addr at o s_b1. \Endereço do host formatado como u_long.

Um ip address é um conjunto com
Um número, 
Um string. 

Um istream é um endereço de memória para um istream object.

Um istream object é um conjunto com um istream vtable denominado vtable.

Um istream vtable é um endereço de memória para um istream vtable conjunto.

Um istream vtable conjunto é um conjunto com
\ iunknown \https://docs.microsoft.com/en-us/windows/win32/api/objidl/nn-objidl-istream
Um endereço de memória denominado queryinterface,
Um endereço de memória denominado addref,
Um endereço de memória denominado release, \ function(this:istream):number; stdcall;
\ istream
Um endereço de memória denominado read,
Um endereço de memória denominado write,
Um endereço de memória denominado seek,
Um endereço de memória denominado setsize,
Um endereço de memória denominado copyto,
Um endereço de memória denominado commit,
Um endereço de memória denominado revert,
Um endereço de memória denominado lockregion,
Um endereço de memória denominado unlockregion,
Um endereço de memória denominado stat,
Um endereço de memória denominado clone.

Um item é um conjunto com
Um categoria [directory, file], \ English
\Um clase [directorio, archivo], \ Spanish categoria
Um endereço completo, um endereço da pasta, um designador, um extensão,
Um size, 
Um creation date/time string,
Um win32finddata e um número identificador.

Etapas necessárias para que se jump o caret left em um text:
Se o text for inexistente, cancele.
Mova o caret left para algum tipo de non-noise pedaço no text.
Se o caret column# deste text for 1, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Atribua o first deste string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço for alphanumeric, mova o caret left para algum tipo de non-alphanumeric pedaço no text.
Se o target deste endereço de memória do pedaço não for alphanumeric, mova o caret left para algum tipo de non-symbolic pedaço no text.
Mova o caret left para algum tipo de non-noise pedaço no text.

Etapas necessárias para que se jump o caret right em um text:
Se o text for inexistente, cancele.
Mova o caret right para algum tipo de non-noise pedaço no text.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Se o caret column# deste text é o quantidade de caracteres deste string desta row, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço é alphanumeric, mova o caret right para algum tipo de non-alphanumeric pedaço no text.
Se o target deste endereço de memória do pedaço não for alphanumeric, mova o caret right para algum tipo de non-symbolic pedaço no text.
Mova o caret right para algum tipo de non-noise pedaço no text.

Um key é um número.

Um kilobyte é 1024 units.

Um categoria é um string.

Um l-param é um número.

Um landscape sheet é um sheet.

O tamanho de letra grande é um tamanho da letra.

O maior número é 2147483647.

Um mínimo múltiplo comum é um número.

Um clique é um input.

Um left é uns twips.

Uma quantidade de caracteres é uns twips.

Um tamanho da letra é uns twips. \ indicates actual altura of um typical uppercase letra

Uma letra é um pedaço.

O lexicon é uma coisa com um catálogo.

Etapas necessárias para que se clareie uma cor por um quantia:
Adicione o quantia para a luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se clareie uma cor por uns percent;
Etapas necessárias para que se clareie uma cor about uns percent;
Etapas necessárias para que se clareie uma cor por about uns percent;
Etapas necessárias para que se clareie uma cor uns percent:
Atribua a luminosidade desta cor mais o percent à luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se clareie o current cor about uns percent:
Clareie a cor deste context pelo percent.

Etapas necessárias para que se clareie um matiz por uns degrees:
Adicione o degrees para o matiz.

Etapas necessárias para que se clareie um matiz por uns points:
Converta o matiz para uns segunda points.
Adicione o points para a segunda points.
Converta a segunda points para o matiz.

Um luminosidade é um número [que vai desde o número 0 até o número 1000].

Etapas necessárias para que se limite uma caixa para uma segunda caixa:
Limite a coordenada esquerda desta caixa para a coordenada esquerda desta segunda caixa e a coordenada direita desta segunda caixa.
Limite a coordenada superior desta caixa para a coordenada superior desta segunda caixa e a coordenada inferior desta segunda caixa.
Limite a coordenada direita desta caixa para a coordenada esquerda desta segunda caixa e a coordenada direita desta segunda caixa.
Limite a coordenada inferior desta caixa para a coordenada superior desta segunda caixa e a coordenada inferior desta segunda caixa.

Etapas necessárias para que se limite o caret em um text:
Se o text for inexistente, cancele.
Limite o número de linhas do cursor deste text para 1 e a contagem de linhas deste text.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Limite o caret column# deste text para 1 e o quantidade de caracteres deste string desta row.

Etapas necessárias para que se limite um número para uma segunda número e um terceiro número:
Se o número for menor do que a segunda número, atribua a segunda número ao número; exit.
Se o número for maior do que o terceiro número, atribua o terceiro número ao número.

Etapas necessárias para que se limite o origin of um text:
Se o text for inexistente, cancele.
Limite a coordenada x deste text para o menor número e a margin deste text.
Atribua a contagem de linhas deste text menos 1 times a altura da linha deste text a um número.
Limite a coordenada y deste text para - o número e 0.

Etapas necessárias para que se limite um spot para uma caixa:
Se a coordenada x deste spot for menor do que a coordenada esquerda desta caixa, atribua a coordenada esquerda desta caixa à coordenada x deste spot.
Se a coordenada y deste spot for menor do que a coordenada superior desta caixa, atribua a coordenada superior desta caixa à coordenada y deste spot.
Se a coordenada x deste spot for maior do que a coordenada direita desta caixa, atribua a coordenada direita desta caixa à coordenada x deste spot.
Se a coordenada y deste spot for maior do que a coordenada inferior desta caixa, atribua a coordenada inferior desta caixa à coordenada y deste spot.

Etapas necessárias para que se limite uns texts para uma contagem:
Atribua a contagem destes texts a uma segunda contagem.
Percorra.
Se a segunda contagem for menor do que ou igual à contagem, cancele.
Atribua o first destes texts a um text.
Remove o text from o texts.
Destrua o text.
Subtraia 1 from a segunda contagem.
Repita.

Um line é um conjunto com um start spot e um end spot.

Etapas necessárias para que se liste umas choices em uma caixa;
Etapas necessárias para que se pinte umas choices em uma caixa:
\Pinte really fast. ***
Obtenha um [first/next] choice from as choices.
Se a choice estiver missing [because we have drawn them all], cancele.
Atribua a coordenada esquerda desta caixa mais 24 pixels à coordenada esquerda desta choice.
Atribua a coordenada direita desta caixa menos 24 pixels à coordenada direita desta choice.
Se a choice for o first desta choice, atribua a coordenada superior desta caixa mais 24 pixels à coordenada superior desta choice.
Se a choice não for o first desta choice, atribua a coordenada inferior deste previous desta choice à coordenada superior desta choice.
Atribua a coordenada superior desta choice mais 24 pixels à coordenada inferior desta choice.
\Pinte a caixa desta choice com a cor púrpura. \ temp ***
Pinte o nome desta choice na caixa desta choice com a cor deste context.
Repita.

Etapas necessárias para que se liste uns choices em uma caixa com uma cor;
Etapas necessárias para que se pinte uns choices em uma caixa com uma cor:
Atribua a cor à cor deste context.
Pinte o choices na caixa.

Etapas necessárias para que se carregue o lexicon:
Se o lexicon não for inexistente, cancele.
Extraia um endereço da pasta from o endereço completo deste module.
Percorra.
Se o endereço da pasta estiver em branco, cancele.
Atribua o endereço da pasta seguido de "lexicon\" a um endereço completo.
Se o endereço completo estiver no sistema de arquivos, Carregue o lexicon usando o endereço completo; exit.
Extraia o endereço da pasta from o endereço da pasta.
Repita.

Etapas necessárias para que se carregue o lexicon usando um trecho:
Se o lexicon for inexistente, crie o lexicon.
Lance um percorredor sobre o trecho.
Percorra.
Mova o percorredor (catálogo lexicon rules).
Se o vocábulo deste percorredor estiver em branco, cancele.
Catalogue o vocábulo deste percorredor no catálogo deste lexicon.
Repita.

Etapas necessárias para que se carregue o lexicon usando um endereço completo:
Obtenha um item from o endereço completo.
Se o item não for found, cancele.
Se a categoria deste item não for "arquivo", repita.
Read o endereço completo deste item a um trecho.
Se o erro do fluxo de entrada/saída não estiver em branco, repita.
Carregue o lexicon usando o trecho.
Repita.

Etapas necessárias para que se localize uma caixa usando um pair:
Isole o pair.
Negate o pair.
Mova a caixa usando o pair.

Etapas necessárias para que se localize um spot usando um pair:
Isole o pair.
Negate o pair.
Mova o spot usando o pair.

Etapas necessárias para que se lock um gpbitmap usando um bitmapdata (24-bit espaço de cor RGB):
Atribua o gprect deste gpbitmap a um gprect.
Call "gdiplus.dll" "GdipBitmapLockBits" com o gpbitmap e o endereçamento deste gprect e 3 [imagelockmoderead ou imagelockmodewrite] And 137224 [pixelformat24bpprgb] e o endereçamento deste bitmapdata.

Um logbrush é um conjunto com
Um número denominado lbstyle,
Um código da cor denominado lbcolor,
Um número denominado lbhatch.

Etapas necessárias para que se lowercase algum tipo de pedaços selecionados em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
Lowercase o subtexto.
Repita.

Etapas necessárias para que se lowercase um pedaço:
\Add 32 to each letter in the string between "A" and "Z".
Translate o pedaço usando o tabela de caracteres minúsculos ascii .

Etapas necessárias para que se lowercase o character depois de um finger e atribua it para um string:
Se o finger for inexistente, cancele.
Atribua o target deste finger ao string.
Lowercase o string.

Etapas necessárias para que se lowercase um string:
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Lowercase o target deste first deste subtexto.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se lowercase um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, pare.
Lowercase o string deste row.
Repita.
Wrap o text.

O main window é um window.

Etapas necessárias para que se make uma fração com um número e uma segunda número:
Atribua o número ao numerador desta fração.
Atribua a segunda número ao denominador desta fração.

Etapas necessárias para que se make um ratio pair usando uma caixa e uma segunda caixa;
Etapas necessárias para que se make uma fração pair usando uma caixa e uma segunda caixa:
Atribua o x-extent desta caixa à numerador desta fração deste fração pair.
Atribua o x-extent desta segunda caixa ao denominador desta fração deste fração pair.
Atribua o y-extent desta caixa ao numerador desta segunda fração deste fração pair.
Atribua o y-extent desta segunda caixa ao denominador desta segunda fração deste fração pair.

Um margin é um número.

Etapas necessárias para que se cubra internamente uma caixa:
Crie um hrgn usando a caixa.
Cubra internamente o hrgn.
Destrua o hrgn.

Etapas necessárias para que se cubra internamente um elipse:
Crie um hrgn usando a elipse.
Cubra internamente o hrgn.
Destrua o hrgn.

Etapas necessárias para que se cubra internamente um hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" com o quadro atual e o hrgn e 4 [rgn_diff].

Etapas necessárias para que se cubra internamente um polígono:
Crie um hrgn usando o polígono.
Cubra internamente o hrgn.
Destrua o hrgn.

Etapas necessárias para que se cubra internamente uma caixa arredondada:
Crie um hrgn usando a caixa arredondada.
Cubra internamente o hrgn.
Destrua o hrgn.

Um mask é um texto hexadecimal.

Etapas necessárias para que se cubra somente dentro de uma caixa:
Mostre tudo.
Cubra internamente a caixa.

Etapas necessárias para que se cubra somente dentro de um elipse:
Mostre tudo.
Cubra internamente a elipse.

Etapas necessárias para que se cubra somente dentro de um polígono:
Mostre tudo.
Cubra internamente o polígono.

Etapas necessárias para que se cubra somente dentro de uma caixa arredondada:
Mostre tudo.
Cubra internamente a caixa arredondada.

Etapas necessárias para que se cubra somente fora de uma caixa:
Mostre tudo.
Cubra externamente a caixa.

Etapas necessárias para que se cubra somente fora de um elipse:
Mostre tudo.
Cubra externamente a elipse.

Etapas necessárias para que se cubra somente fora de um polígono:
Mostre tudo.
Cubra externamente o polígono.

Etapas necessárias para que se cubra somente fora de uma caixa arredondada:
Mostre tudo.
Cubra externamente a caixa arredondada.

Etapas necessárias para que se cubra externamente uma caixa:
Crie um hrgn usando a caixa.
Cubra externamente o hrgn.
Destrua o hrgn.

Etapas necessárias para que se cubra externamente um elipse:
Crie um hrgn usando a elipse.
Cubra externamente o hrgn.
Destrua o hrgn.

Etapas necessárias para que se cubra externamente um hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" com o quadro atual e o hrgn e 1 [rgn_and].

Etapas necessárias para que se cubra externamente um polígono:
Crie um hrgn usando o polígono.
Cubra externamente o hrgn.
Destrua o hrgn.

Etapas necessárias para que se cubra externamente uma caixa arredondada:
Crie um hrgn usando a caixa arredondada.
Cubra externamente o hrgn.
Destrua o hrgn.

O max text undos é uma contagem igual a 32.

O tamanho de letra médio é um tamanho da letra.

Um megabyte é 1024 kilobytes.

O memory canvas é um canvas.

Um message é um string.

An million é 1000 thousands.

An millisecond é um número.

Etapas necessárias para que se minimize um window:
Call "user32.dll" "ShowWindow" com o window e 6 [sw_minimize].

Um minute é 60 seconds.

Etapas necessárias para que se mirror o gpbitmap em um picture:
Se o picture for inexistente, cancele.
Reverse o mirror detector desta picture.
Mirror o gpbitmap desta picture.

Etapas necessárias para que se mirror um gpimage:
Call "gdiplus.dll" "GdipImageRotateFlip" com o gpimage e 4 [rotatenoneflipx].

Etapas necessárias para que se mirror um picture:
Se o picture for inexistente, cancele.
Atribua a coordenada x deste center desta caixa desta picture menos a coordenada x deste center desta uncropped caixa desta picture ao número x desse pair.
Multiplique o número x deste pair por 2.
Mova a uncropped caixa desta picture usando o pair.
Mirror o gpbitmap no picture.

Etapas necessárias para que se mirror um polígono:
Se o polígono for inexistente, cancele.
Atribua a caixa deste polígono a uma caixa.
Percorra.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, cancele.
Subtraia a coordenada esquerda desta caixa from a coordenada x deste vértice.
Atribua a coordenada direita desta caixa menos a coordenada x deste vértice à coordenada x deste vértice.
Repita.

Um mixed é um conjunto com um whole número e um ratio e uma fração at o ratio.

O module é um conjunto com
Um número identificador,
Um endereço completo,
Um endereço da pasta,
Um root endereço da pasta, \ uma pasta acima do qual o exe está sendo executado. eexemplo: C:\1\2\a.exe o endereço seria c:\1\
Um nome do arquivo s/ extensão denominado nome.

O mouse é um conjunto com
Um tecla denominado botão esquerdo, 
Um tecla denominado botão direito.

Etapas necessárias para que se mova o anchor left para algum tipo de non-alphanumeric pedaço em um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o anchor número da linha deste text e o text.
Percorra.
Se o anchor column# deste text for 1, cancele.
Atribua o first deste string desta row mais o anchor column# deste text menos 2 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for alphanumeric, cancele.
Subtraia 1 from o anchor column# deste text.
Repita.

Etapas necessárias para que se mova back uns twips:
Vire around.
Mova os twips.
Vire around.

Etapas necessárias para que se mova uma caixa para o base of uma segunda caixa:
Mova a caixa para baixo a coordenada inferior desta segunda caixa menos a coordenada inferior desta caixa.

Etapas necessárias para que se mova uma caixa close para o left side of uma segunda caixa;
Etapas necessárias para que se mova uma caixa close para o left of uma segunda caixa:
Mova a caixa para o left of a segunda caixa.
Escolha aleatoriamente um quantidade de caracteres between 0 e a largura desta caixa times 3/4.
Mova a caixa right o quantidade de caracteres.

Etapas necessárias para que se mova uma caixa para baixo uns twips:
Mova a caixa usando 0 e os twips.

Etapas necessárias para que se mova uma caixa usando um pair:
Mova a caixa usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova uma caixa usando um ratio pair e um spot;
Etapas necessárias para que se mova uma caixa usando uma fração pair e um spot:
Obtenha um difference between o canto superior esquerdo desta caixa e o spot.
Atribua a difference a uma segunda difference.
Redimensione proporcionalmente a segunda difference usando o fração pair.
Subtraia a difference from a segunda difference.
Mova a caixa usando a segunda difference.

Some x-twips são uns twips.
Some y-twips são uns twips.

Etapas necessárias para que se mova uma caixa usando uns x-twips e uns y-twips:
Adicione o x-twips para a coordenada esquerda desta caixa.
Adicione o y-twips para a coordenada superior desta caixa.
Adicione o x-twips para a coordenada direita desta caixa.
Adicione o y-twips para a coordenada inferior desta caixa.

Etapas necessárias para que se mova uma caixa left para uma coordenada:
Mova a caixa left a coordenada esquerda desta caixa menos a coordenada.

Etapas necessárias para que se mova uma caixa para o left side of uma segunda caixa;
Etapas necessárias para que se mova uma caixa para o left of uma segunda caixa:
Mova a caixa left a coordenada esquerda desta caixa menos a coordenada esquerda desta segunda caixa.

Etapas necessárias para que se mova uma caixa left uns twips:
Mova a caixa usando - os twips e 0.

Etapas necessárias para que se mova uma caixa para o right side of uma segunda caixa;
Etapas necessárias para que se mova uma caixa para o right of uma segunda caixa:
Mova a caixa right a coordenada direita desta segunda caixa menos a coordenada direita desta caixa.

Etapas necessárias para que se mova uma caixa right uns twips:
Mova a caixa usando os twips e 0.

Etapas necessárias para que se mova uma caixa para um spot:
Obtenha um difference between o spot e o canto superior esquerdo desta caixa.
Mova a caixa usando a difference.

Etapas necessárias para que se mova uma caixa para o topo left corner of uma segunda caixa:
Mova a caixa para a coordenada esquerda desta segunda caixa-top.

Etapas necessárias para que se mova uma caixa para o topo of uma segunda caixa:
Mova a caixa para cima a coordenada superior desta caixa menos a coordenada superior desta segunda caixa.

Etapas necessárias para que se mova uma caixa para cima uns twips:
Mova a caixa usando 0 e - os twips.

Etapas necessárias para que se mova o caret para baixo em um text:
Se o text for inexistente, cancele.
Adicione 1 para o número de linhas do cursor deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret para baixo one página em um text:
Se o text for inexistente, cancele.
Adicione as rows/box deste text para o número de linhas do cursor deste text.
Subtraia 1 from o número de linhas do cursor deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret para o first pedaço of o current row of um text:
Se o text for inexistente, cancele.
Atribua 1 ao caret column# deste text.

Etapas necessárias para que se mova o caret para o first pedaço of um text:
Se o text for inexistente, cancele.
Atribua 1 e 1 ao caret deste text.

Etapas necessárias para que se mova o caret para o last pedaço of o current row of um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Atribua o quantidade de caracteres deste string desta row ao caret column# deste text.

Etapas necessárias para que se mova o caret para o last pedaço of um text:
Se o text for inexistente, cancele.
Atribua a contagem de linhas deste text ao número de linhas do cursor deste text.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Atribua o quantidade de caracteres deste string desta row ao caret column# deste text.

Etapas necessárias para que se mova o caret left para algum tipo de non-alphanumeric pedaço em um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Percorra.
Se o caret column# deste text for 1, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for alphanumeric, cancele.
Subtraia 1 from o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret left para algum tipo de non-noise pedaço em um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Percorra.
Se o caret column# deste text for 1, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for irrelevante, cancele.
Subtraia 1 from o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret left para algum tipo de non-symbolic pedaço em um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Percorra.
Se o caret column# deste text for 1, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for symbolic, cancele.
Subtraia 1 from o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret left em um text:
Se o text for inexistente, cancele.
Subtraia 1 from o caret column# deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret right para algum tipo de non-alphanumeric pedaço em um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Percorra.
Se o caret column# deste text é o quantidade de caracteres deste string desta row, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for alphanumeric, cancele.
Adicione 1 para o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret right para algum tipo de non-noise pedaço em um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Percorra.
Se o caret column# deste text é o quantidade de caracteres deste string desta row, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for irrelevante, cancele.
Adicione 1 para o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret right para algum tipo de non-symbolic pedaço em um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Percorra.
Se o caret column# deste text é o quantidade de caracteres deste string desta row, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for symbolic, cancele.
Adicione 1 para o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret right em um text:
Se o text for inexistente, cancele.
Adicione 1 para o caret column# deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret para cima em um text:
Se o text for inexistente, cancele.
Subtraia 1 from o número de linhas do cursor deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret para cima one página em um text:
Se o text for inexistente, cancele.
Subtraia as rows/box deste text from o número de linhas do cursor deste text.
Adicione 1 para o número de linhas do cursor deste text.
Limite o caret no text.

Etapas necessárias para que se mova um elipse para baixo uns twips:
Mova a elipse usando 0 e os twips.

Etapas necessárias para que se mova um elipse usando um pair:
Mova a elipse usando o x deste pair e o y deste pair.

Etapas necessárias para que se mova um elipse usando uns x-twips e uns y-twips:
Mova a caixa desta elipse usando o x-twips e o y-twips.

Etapas necessárias para que se mova um elipse left uns twips:
Mova a elipse usando - os twips e 0.

Etapas necessárias para que se mova um elipse right uns twips:
Mova a elipse usando os twips e 0.

Etapas necessárias para que se mova um elipse para um spot:
Obtenha um difference between o spot e o canto superior esquerdo desta elipse.
Mova a elipse usando a difference.

Etapas necessárias para que se mova um elipse para cima uns twips:
Mova a elipse usando 0 e - os twips.

Etapas necessárias para que se mova um finger over um número:
Se o finger for inexistente, cancele.
Adicione 1 para o finger.

Etapas necessárias para que se mova para o left uns twips e para baixo uns segunda twips;
Etapas necessárias para que se mova left uns twips e para baixo uns segunda twips;
Etapas necessárias para que se mova uns twips para o left e uns segunda twips para baixo;
Etapas necessárias para que se mova uns twips left e uns segunda twips para baixo:
Mova o spot deste context left os twips.
Mova o spot deste context para baixo a segunda twips.

Etapas necessárias para que se mova para o left uns twips e para cima uns segunda twips;
Etapas necessárias para que se mova left uns twips e para cima uns segunda twips;
Etapas necessárias para que se mova uns twips para o left e uns segunda twips para cima;
Etapas necessárias para que se mova uns twips left e uns segunda twips para cima:
Mova o spot deste context left os twips.
Mova o spot deste context para cima a segunda twips.

Etapas necessárias para que se mova um line para baixo uns twips:
Mova o line usando 0 e os twips.

Etapas necessárias para que se mova um line usando um pair:
Mova o line usando o x deste pair e o y deste pair.

Etapas necessárias para que se mova um line usando uns x-twips e uns y-twips:
Adicione o x-twips para a coordenada x desta start desta line.
Adicione o y-twips para a coordenada y desta start desta line.
Adicione o x-twips para a coordenada x deste end desta line.
Adicione o y-twips para a coordenada y deste end desta line.

Etapas necessárias para que se mova um line left uns twips:
Mova o line usando - os twips e 0.

Etapas necessárias para que se mova um line para um spot:
Obtenha um difference between o spot e o start desta line.
Mova o line usando a difference.

Etapas necessárias para que se mova um line uns twips para o right;
Etapas necessárias para que se mova um line right uns twips:
Mova o line usando os twips e 0.

Etapas necessárias para que se mova um line para cima uns twips:
Mova o line usando 0 e - os twips.

Etapas necessárias para que se mova para o middle;
Etapas necessárias para que se start no middle;
Etapas necessárias para que se mova para o center;
Etapas necessárias para que se start no center:
Atribua o center desta caixa deste context ao spot deste context.

Etapas necessárias para que se mova para o middle of uma caixa;
Etapas necessárias para que se start no middle of uma caixa;
Etapas necessárias para que se mova para o center of uma caixa;
Etapas necessárias para que se start no center of uma caixa:
Atribua o center desta caixa ao spot deste context.

Etapas necessárias para que se mova um picture para baixo uns twips:
Mova o picture usando 0 e os twips.

Etapas necessárias para que se mova um picture usando um pair:
Mova o picture usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um picture usando uns x-twips e uns y-twips:
Se o picture for inexistente, cancele.
Mova a caixa desta picture usando o x-twips e o y-twips.
Mova a uncropped caixa desta picture usando o x-twips e o y-twips.

Etapas necessárias para que se mova um picture left uns twips:
Mova o picture usando - os twips e 0.

Etapas necessárias para que se mova um picture right uns twips:
Mova o picture usando os twips e 0.

Etapas necessárias para que se mova um picture para um spot:
Se o picture for inexistente, cancele.
Obtenha um difference between o spot e o canto superior esquerdo desta picture.
Mova o picture usando a difference.

Etapas necessárias para que se mova um picture para cima uns twips:
Mova o picture usando 0 e - os twips.

Etapas necessárias para que se mova um polígono para baixo uns twips:
Mova o polígono usando 0 e os twips.

Etapas necessárias para que se mova um polígono usando um pair:
Mova o polígono usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um polígono usando uns x-twips e uns y-twips:
Se o polígono for inexistente, cancele.
Percorra.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, cancele.
Mova o vértice usando o x-twips e o y-twips.
Repita.

Etapas necessárias para que se mova um polígono left uns twips:
Mova o polígono usando - os twips e 0.

Etapas necessárias para que se mova um polígono left uns twips e para baixo uns segunda twips:
Mova o polígono left os twips.
Mova o polígono para baixo a segunda twips.

Etapas necessárias para que se mova um polígono left uns twips e para cima uns segunda twips:
Mova o polígono left os twips.
Mova o polígono para cima a segunda twips.

Etapas necessárias para que se mova um polígono right uns twips:
Mova o polígono usando os twips e 0.

Etapas necessárias para que se mova um polígono right uns twips e para baixo uns segunda twips:
Mova o polígono right os twips.
Mova o polígono para baixo a segunda twips.

Etapas necessárias para que se mova um polígono right uns twips e para cima uns segunda twips:
Mova o polígono right os twips.
Mova o polígono para cima a segunda twips.

Etapas necessárias para que se mova um polígono para um spot:
Se o polígono for inexistente, cancele.
Obtenha um difference between o spot e o canto superior esquerdo desta caixa deste polígono.
Mova o polígono usando a difference.

Etapas necessárias para que se mova um polígono para cima uns twips:
Mova o polígono usando 0 e - os twips.

Etapas necessárias para que se mova um percorredor (catálogo lexicon rules):
Skip algum tipo de leading noise no source deste percorredor.
Posicione o vocábulo deste percorredor sobre o source deste percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Avance o percorredor.
Se o target deste first deste source deste percorredor for irrelevante, cancele.
Repita.

Etapas necessárias para que se mova um percorredor (quoted string rules):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor não for as aspas duplas, repita.
Se o first deste source deste percorredor é o last deste source deste percorredor, avance o percorredor; exit.
Avance o percorredor.
Se o target deste first deste source deste percorredor não for as aspas duplas, cancele.
Repita.

Etapas necessárias para que se mova um percorredor (spell checking rules):
Skip algum tipo de non-alphanumeric pedaços no source deste percorredor.
Posicione o vocábulo deste percorredor sobre o source deste percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Avance o percorredor.
Se o source deste percorredor está sobre alguma espécie de contração, avance o percorredor; repita.
Se o target deste first deste source deste percorredor não for alphanumeric, cancele.
Repita.

Etapas necessárias para que se mova um percorredor (text file rules):
Posicione o vocábulo deste percorredor sobre o source deste percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, avance o percorredor; break.
Se o target deste first deste source deste percorredor for o linefeed pedaço, avance o percorredor; exit. \ *dahn new para handle lines terminated por just linefeed
Avance o percorredor.
Repita.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o linefeed pedaço, adicione 1 para o first deste source deste percorredor.

Etapas necessárias para que se mova um percorredor (word wrapping rules):
Posicione o vocábulo deste percorredor sobre o source deste percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, avance o percorredor; exit.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, cancele.
Se o vocábulo deste percorredor estiver em branco, avance o percorredor; repita.
Se o target deste first deste source deste percorredor for like o target deste last deste vocábulo deste percorredor, avance o percorredor; repita.

Etapas necessárias para que se mova um percorredor usando uma caixa (word wrapping rules):
Skip algum tipo de leading linefeed pedaço no source deste percorredor.
Posicione o vocábulo deste percorredor sobre o source deste percorredor.
Se o source deste percorredor estiver em branco, cancele.
Lance uma segunda percorredor sobre o percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Mova a segunda percorredor (word wrapping rules).
Se o vocábulo deste segunda percorredor estiver em branco, cancele.
Se o target deste first deste vocábulo deste segunda percorredor for o return pedaço, avance o percorredor; exit.
Se o target deste first deste vocábulo deste segunda percorredor for whitespace, avance o percorredor pelo quantidade de caracteres deste vocábulo deste segunda percorredor; repita.
Se o vocábulo deste percorredor estiver em branco, avance o percorredor pelo quantidade de caracteres deste vocábulo deste segunda percorredor; repita.
Se o vocábulo deste percorredor seguido de o vocábulo deste segunda percorredor forem wider do que a caixa, cancele.
Avance o percorredor pelo quantidade de caracteres deste vocábulo deste segunda percorredor.
Repita.

Etapas necessárias para que se mova um percorredor usando um separator pedaço:
Posicione o vocábulo deste percorredor sobre o source deste percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o separator pedaço, adicione 1 para o first deste source deste percorredor; exit.
Avance o percorredor.
Repita.

Etapas necessárias para que se mova para o right uns twips e para baixo uns segunda twips;
Etapas necessárias para que se mova right uns twips e para baixo uns segunda twips;
Etapas necessárias para que se mova uns twips para o right e uns segunda twips para baixo;
Etapas necessárias para que se mova uns twips right e uns segunda twips para baixo:
Mova o spot deste context right os twips.
Mova o spot deste context para baixo a segunda twips.

Etapas necessárias para que se mova para o right uns twips e para cima uns segunda twips;
Etapas necessárias para que se mova right uns twips e para cima uns segunda twips;
Etapas necessárias para que se mova uns twips para o right e uns segunda twips para cima;
Etapas necessárias para que se mova uns twips right e uns segunda twips para cima:
Mova o spot deste context right os twips.
Mova o spot deste context para cima a segunda twips.

Etapas necessárias para que se mova para um spot:
Atribua o spot ao spot deste context.

Etapas necessárias para que se mova um spot about uns twips em algum tipo de direction:
Escolha aleatoriamente uma segunda spot within os twips of o spot.
Atribua a segunda spot ao spot.

Etapas necessárias para que se mova um spot para uma segunda spot:
Atribua a segunda spot ao spot.

Etapas necessárias para que se mova um spot usando um pair:
Mova o spot usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um spot usando uns x-twips e uns y-twips:
Adicione o x-twips para a coordenada x deste spot.
Adicione o y-twips para a coordenada y deste spot.

Etapas necessárias para que se mova um spot uns twips para baixo;
Etapas necessárias para que se mova um spot para baixo uns twips:
Mova o spot usando 0 e os twips.

Etapas necessárias para que se mova um spot uns twips para o left;
Etapas necessárias para que se mova um spot uns twips left;
Etapas necessárias para que se mova um spot left uns twips:
Mova o spot usando - os twips e 0.

Etapas necessárias para que se mova um spot uns twips right;
Etapas necessárias para que se mova um spot uns twips para o right;
Etapas necessárias para que se mova um spot right uns twips:
Mova o spot usando os twips e 0.

Etapas necessárias para que se mova um spot uns twips para o right e uns segunda twips para baixo;
Etapas necessárias para que se mova um spot uns twips right e uns segunda twips para baixo:
Adicione os twips para o x deste spot.
Adicione a segunda twips para o y deste spot.

Etapas necessárias para que se mova um spot uns twips para cima;
Etapas necessárias para que se mova um spot para cima uns twips:
Mova o spot usando 0 e - os twips.

Etapas necessárias para que se mova uns squares:
Mova o square size times o squares dividido por 1 square. \ squares são scaled para cima por precision hence o division at o end

Etapas necessárias para que se mova uns squares diagonally;
Etapas necessárias para que se mova uns squares slantways:
Mova o square size times o squares times o raiz de dois dividido por 1 square. \ squares são scaled para cima por precision hence o division at o end

Etapas necessárias para que se mova um subtexto usando um número:
Adicione o número para o first deste subtexto.
Adicione o número para o last deste subtexto.

Etapas necessárias para que se mova um text para baixo uns twips:
Mova o text usando 0 e os twips.

Etapas necessárias para que se mova um text usando um pair:
Mova o text usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um text usando uns x-twips e uns y-twips:
Se o text for inexistente, cancele.
Mova a caixa deste text usando o x-twips e o y-twips.

Etapas necessárias para que se mova um text left uns twips:
Mova o text usando - os twips e 0.

Etapas necessárias para que se mova um text right uns twips:
Mova o text usando os twips e 0.

Etapas necessárias para que se mova um text para um spot:
Se o text for inexistente, cancele.
Obtenha um difference between o spot e o canto superior esquerdo deste text.
Mova o text usando a difference.

Etapas necessárias para que se mova um text para cima uns twips:
Mova o text usando 0 e - os twips.

Etapas necessárias para que se mova uma coisa from uns coisas para uns segunda coisas:
Se a coisa for inexistente, cancele.
Isole o coisa.
Remove a coisa from as coisas.
Posponha a coisa para a segunda coisas.

Etapas necessárias para que se mova uns coisas para uns segunda coisas:
Atribua o first destas coisas ao first destas segunda coisas.
Atribua o last destas coisas ao last destas segunda coisas.
Limpe as coisas.

Etapas necessárias para que se mova uns twips:
\Aguarde pelo delay. ***
Atribua o spot deste context ao start dessa line.
Atribua o spot deste context ao end desta line.
Obtenha um deslocamento vertical e um deslocamento horizontal usando a orientação deste context.
Adicione o deslocamento horizontal times os twips dividido por 10000 para a coordenada x deste end desta line.
Adicione o deslocamento vertical times os twips dividido por 10000 para a coordenada y deste end desta line.
Atribua o end desta line ao spot deste context.

Etapas necessárias para que se mova uns twips para baixo;
Etapas necessárias para que se mova para baixo uns twips:
Adicione os twips para a coordenada y deste context.

Etapas necessárias para que se mova uns twips para o left;
Etapas necessárias para que se mova uns twips left;
Etapas necessárias para que se mova left uns twips:
Subtraia os twips from a coordenada x deste context.

Etapas necessárias para que se mova uns twips para o right;
Etapas necessárias para que se mova uns twips right;
Etapas necessárias para que se mova right uns twips:
Adicione os twips para a coordenada x deste context.

Etapas necessárias para que se mova uns twips para cima;
Etapas necessárias para que se mova para cima uns twips:
Subtraia os twips from a coordenada y deste context.

Etapas necessárias para que se mova um vértice para baixo uns twips:
Mova o vértice usando 0 e os twips.

Etapas necessárias para que se mova um vértice usando um pair:
Mova o vértice usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um vértice usando uns x-twips e uns y-twips:
Se o vértice for inexistente, cancele.
Adicione o x-twips para a coordenada x deste vértice.
Adicione o y-twips para a coordenada y deste vértice.

Etapas necessárias para que se mova um vértice left uns twips:
Mova o vértice usando - os twips e 0.

Etapas necessárias para que se mova um vértice right uns twips:
Mova o vértice usando os twips e 0.

Etapas necessárias para que se mova um vértice para um spot:
Se o vértice for inexistente, cancele.
Atribua o spot ao spot deste vértice.

Etapas necessárias para que se mova um vértice para cima uns twips:
Mova o vértice usando 0 e - os twips.

Etapas necessárias para que se mova um window left:
Call "user32.dll" "GetWindowRect" com o main window e o endereçamento dessa caixa.
Subtraia a pixel largura desta tela from a coordenada esquerda desta caixa.
Call "user32.dll" "MoveWindow" com o window e a coordenada esquerda desta caixa e a coordenada superior desta caixa e a pixel largura desta tela e a pixel altura desta tela e 1.

Etapas necessárias para que se mova um window right:
Call "user32.dll" "GetWindowRect" com o main window e o endereçamento dessa caixa.
Adicione a pixel largura desta tela para a coordenada esquerda desta caixa.
Call "user32.dll" "MoveWindow" com o window e a coordenada esquerda desta caixa e a coordenada superior desta caixa e a pixel largura desta tela e a pixel altura desta tela e 1.

Um ms é 1 millisecond.

Um msg é um conjunto com
Um window denominado hwnd,
Um número denominado message,
Um w-param denominado wparam,
Um l-param denominado lparam,
Um número denominado time,
Um spot denominado pt.

Um multiple é um número.

Etapas necessárias para que se multiplique uma fração por um número:
Multiplique o numerador desta fração pelo número.
Reduce a fração.

Etapas necessárias para que se multiplique um número por um fração;
Etapas necessárias para que se redimensione proporcionalmente um número usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um número usando um fração:
Se o denominador desta fração for 0, cancele.
Call "kernel32.dll" "MulDiv" com o número e o numerador desta fração e o denominador desta fração devolvendo o número.

Etapas necessárias para que se multiplique um pair por uma segunda pair:
Multiplique o número x deste pair pelo número x deste segunda pair.
Multiplique o número y deste pair pelo número y deste segunda pair.

Etapas necessárias para que se multiplique um pair por um número:
Multiplique o número x deste pair pelo número.
Multiplique o número y deste pair pelo número.

Etapas necessárias para que se multiplique um pair por um número e uma segunda número:
Multiplique o número x deste pair pelo número.
Multiplique o número y deste pair pelo segunda número.

Etapas necessárias para que se multiplique um endereço de memória por um número;
Etapas necessárias para que se multiplique um número por uma segunda número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda número
Intel $F72B.\ mul [ebx] \ means mul eax,[ebx] but é weird form
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8903. \ mov [ebx],eax

Um nome é um string.

Etapas necessárias para que se negate um fração:
Negate o numerador desta fração.

Etapas necessárias para que se negate um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $F718.\ neg [eax]

Etapas necessárias para que se negate um pair:
Negate o número x deste pair.
Negate o número y deste pair.

O next letra é um letra igual a 65 [the big-a byte].

Um cifra binária é um pedaço. \ only low order 4 bits são valid

Um cifra hexadecimal é um string. \ $0010A0...

Etapas necessárias para que se non-destructively redimensione um picture usando um ratio pair;
Etapas necessárias para que se non-destructively redimensione um picture usando uma fração pair:
Se o picture for inexistente, cancele.
Mova a uncropped caixa desta picture usando o fração pair e o canto superior esquerdo desta caixa desta picture.
Redimensione a uncropped caixa desta picture usando o fração pair.
Redimensione a caixa desta picture usando o fração pair.
Se a coordenada direita desta picture for menor do que a coordenada esquerda desta picture, mirror o gpbitmap no picture.
Se a coordenada inferior desta picture for menor do que a coordenada superior desta picture, flip o gpbitmap no picture.

Etapas necessárias para que se non-destructively redimensione um picture usando um twip pair:
Se o picture for inexistente, cancele.
Atribua a caixa desta picture a uma caixa.
Redimensione a caixa usando o twip pair.
Make uma fração pair usando a caixa e a caixa desta picture.
Non-destructively redimensione o picture usando o fração pair.

Etapas necessárias para que se normalize um ângulo:
Divida o ângulo por 3600 usando um quotient e o ângulo.

Etapas necessárias para que se normalize uma caixa:
Se a coordenada direita desta caixa for menor do que a coordenada esquerda desta caixa, permute a coordenada esquerda desta caixa com a coordenada direita desta caixa.
Se a coordenada inferior desta caixa for menor do que a coordenada superior desta caixa, permute a coordenada superior desta caixa com a coordenada inferior desta caixa.

Etapas necessárias para que se normalize um canvas:
Call "gdi32.dll" "SetGraphicsMode" com o canvas e 2 [gm_advanced].
Call "gdi32.dll" "SetBkMode" com o canvas e 1 [transparent].
Call "gdi32.dll" "SetMapMode" com o canvas e 8 [mm_anisotropic].
Call "gdi32.dll" "SetViewportOrgEx" com o canvas e 0 e 0 e nil.
Call "gdi32.dll" "SetViewportExtEx" com o canvas e o ppi e o ppi e nil.
Call "gdi32.dll" "SetWindowOrgEx" com o canvas e 0 e 0 e nil.
Call "gdi32.dll" "SetWindowExtEx" com o canvas e o tpi e o tpi e nil.

Etapas necessárias para que se normalize um elipse:
Normalize a caixa desta elipse.

Etapas necessárias para que se normalize uma fração e uma segunda fração:
Obtenha um mínimo múltiplo comum usando o denominador desta fração e o denominador desta segunda fração.
Multiplique o numerador desta fração pelo mínimo múltiplo comum dividido pelo denominador desta fração.
Atribua o mínimo múltiplo comum ao denominador desta fração.
Multiplique o numerador desta segunda fração pelo mínimo múltiplo comum dividido pelo denominador desta segunda fração.
Atribua o mínimo múltiplo comum ao denominador desta segunda fração.

Etapas necessárias para que se normalize uma orientação:
Divida a orientação por 3840 usando um quotient e um resto.
Atribua o resto à orientação.
Se a orientação for menor do que 0, adicione 3840 para a orientação.

Etapas necessárias para que se normalize um horizontal line:
Se o end desta line for menor do que o start desta line, permute o end desta line com o start desta line.

Etapas necessárias para que se normalize um matiz:
Divida o matiz por 3600 usando um quotient e um resto.
Atribua o resto ao matiz.
Se o matiz for menor do que 0, adicione 3600 para o matiz.

Etapas necessárias para que se normalize um picture:
Se o picture for inexistente, cancele.
Normalize a caixa desta picture.
Normalize a uncropped caixa desta picture.

Etapas necessárias para que se normalize um seleção:
Se o anchor número da linha desta seleção for menor do que o número de linhas do cursor desta seleção, cancele.
Se o anchor número da linha desta seleção for maior do que o número de linhas do cursor desta seleção, permute o anchor desta seleção com o caret desta seleção; exit.
Se o anchor column# desta seleção for maior do que o caret column# desta seleção, permute o anchor column# desta seleção com o caret column# desta seleção.

Etapas necessárias para que se normalize um text:
Se o text for inexistente, cancele.
Normalize a caixa deste text.

Etapas necessárias para que se normalize um vertical line:
Se o end desta line for menor do que o start desta line, permute o end desta line com o start desta line.

O null hbrush é um hbrush.

O null número da fonte é um número da fonte.

O null hpen é um hpen.

Etapas necessárias para que se modifique através do caractere NUL um string:
Atribua o quantidade de caracteres deste string a um quantidade de caracteres armazenados.
Reassign o first deste string usando o quantidade de caracteres armazenados mais 1.
Atribua o first deste string mais o quantidade de caracteres armazenados menos 1 ao last deste string.
Atribua o last deste string mais 1 a um endereço de memória do pedaço .
Atribua o null pedaço ao target deste endereço de memória do pedaço.

Etapas necessárias para que se modifique através do caractere NUL um wide string:
Atribua o quantidade de caracteres deste wide string a um quantidade de caracteres armazenados.
Reassign o first deste wide string usando o quantidade de caracteres armazenados mais 2.
Atribua o first deste wide string mais o quantidade de caracteres armazenados menos 1 ao last deste wide string.

Um número é um conjunto com
Um first pedaço,
Um second pedaço,
Um terceiro pedaço,
Um quarto pedaço,
Um low wyrd at o first pedaço,
Um high wyrd at o terceiro pedaço.

Um endereço numérico é um endereço de memória para um número.

Um offset é um número.

Etapas necessárias para que se abra um file usando um endereço completo:
Limpe o erro do fluxo de entrada/saída.
Extraia um endereço da pasta from o endereço completo.
Se o endereço da pasta não estiver no sistema de arquivos, atribua "A Pasta: " seguido de o endereço da pasta seguido de " não existe." ao erro do fluxo de entrada/saída; exit.
Ligue o endereço completo para read-write mode.
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "CreateFileA" com o first deste endereço completo e -1073741824 [generic_read+generic_write] e 0 e 0 e 4 [open_always] 
And -2147483520 [file_flag_write_through ou file_attribute_normal] e 0 devolvendo o file.
Se o file é -1 [invalid_handle_value], atribua "Ocorreu um erro na hora de abrir o arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se abra um file usando um endereço completo e uns milliseconds:
Start um temporizador.
Percorra.
Abra o file usando o endereço completo.
Se o erro do fluxo de entrada/saída estiver em branco, cancele.
Se os ticks deste temporizador forem greater do que os milliseconds, cancele.
Repita.

Um operação é um string.

Um origin é um spot.

\O osmosian font resource é uma font resource.

A fonte Tahoma é um texto hexadecimal igual a $00. \ quando se usa uma fonte do windows não é necesário inserir o código hexadecimal da mesma no fonte.
O recurso de fonte Tahoma é um font resource.

Etapas necessárias para que se outdent algum tipo de rows selecionadas em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Se o target deste first deste string desta row for o caractere de espaço, remove o first pedaço from o string deste row.
Se o target deste first deste string desta row for o caractere de espaço, remove o first pedaço from o string deste row.
Repita.

Etapas necessárias para que se outdent uma caixa uns twips;
Etapas necessárias para que se outdent uma caixa usando uns twips:
Subtraia os twips from a coordenada esquerda desta caixa.
Subtraia os twips from a coordenada superior desta caixa.
Adicione os twips para a coordenada direita desta caixa.
Adicione os twips para a coordenada inferior desta caixa.

Um outdent é um número.

Etapas necessárias para que se outline uma caixa com uma cor:
Pinte a caixa com a cor e a cor preta.

Um OUTLINETEXTMETRIC é um conjunto com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-outlinetextmetrica
\A estrutura OUTLINETEXTMETRIC contém métricas que descrevem uma fonte TrueType.
Um número denominado otmSize, \ O tamanho, em bytes, da estrutura OUTLINETEXTMETRIC.
Um TEXTMETRIC denominado otmTextMetrics, \ Uma estrutura TEXTMETRIC contendo mais informações sobre a fonte.
3 pedaços, \ otmFiller deve certificar-se de que o próximo campo comece no limite DWORD. 
\Na verdade, existem três bytes de preenchimento, em vez de um único byte, pois OUTLINETEXTMETRIC deve ser compilado com pack(4)
Um pedaço denominado otmFiller, \ Um valor que faz com que a estrutura seja alinhada por bytes.
Um panose denominado otmPanoseNumber, \ O número PANOSE para esta fonte.
1 pedaço, \ needed para align structure
Um número denominado otmfsSelection, \ A natureza do padrão da fonte. 0=itálico, 1=sublinhado, 2= plano de fundo trocado com a letra, 3= contorno, 4=tachado, 5=negrito
Um número denominado otmfsType, \Indica se a fonte está licenciada. As fontes licenciadas não devem ser modificadas ou trocadas.
Um número denominado otmsCharSlopeRise, \A inclinação do cursor. Este valor é 1 se a inclinação for vertical. 
Um número denominado otmsCharSlopeRun, \A inclinação do cursor. Este valor é zero se a inclinação for vertical.
\Os aplicativos podem usar esses valores acima para criar um cursor em itálico com a mesma inclinação do ângulo itálico principal (especificado pelo número otmItalicAngle).
Um número denominado otmItalicAngle, \ O ângulo itálico principal da fonte, em décimos de grau no sentido anti-horário a partir da vertical. 
\Fontes regulares (romanas) têm valor zero. As fontes em itálico geralmente têm um ângulo itálico negativo (ou seja, inclinam-se para a direita).
Um número denominado otmEMSquare, \O número de unidades lógicas que definem a dimensão x ou y do "quadrado em" para esta fonte.
\ (O número de unidades nas direções x e y são sempre iguais para um quadrado em.)
Um número denominado otmAscent, \ Os caracteres de distância máxima nesta fonte se estendem acima da linha de base. Esta é a ascensão tipográfica da fonte.
Um número denominado otmDescent, \ Os caracteres de distância máxima nesta fonte se estendem abaixo da linha de base. Esta é a descida tipográfica da fonte.
Um número denominado otmLineGap, \ O espaçamento entre linhas tipográficas.
Um número denominado otmsCapEmHeight, \ O Windows não provê esse recurso
Um número denominado otmsXHeight,\ O Windows não provê esse recurso
Um caixa denominado otmrcFontBox, \rect - A caixa delimitadora da fonte.
Um número denominado otmMacAscent, \ Os caracteres de distância máxima nesta fonte se estendem acima da linha de base para o computador Macintosh.
Um número denominado otmMacDescent, \ Os caracteres de distância máxima nesta fonte se estendem abaixo da linha de base para o computador Macintosh.
Um número denominado otmMacLineGap, \ As informações de espaçamento de linha para o computador Macintosh.
Um número denominado otmusMinimumPPEM, \ O menor tamanho recomendado para esta fonte, em pixels por quadrado EM.
Um spot denominado otmptSubscriptSize, \ point -  O tamanho horizontal e vertical recomendado para subscritos nesta fonte.
Um spot denominado otmptSubscriptOffset, \ O deslocamento horizontal e vertical recomendado para subscritos nesta fonte. O deslocamento do subscrito é medido da origem do caractere até a origem do caractere subscrito.
Um spot denominado otmptSuperscriptSize, \   O tamanho horizontal e vertical recomendado para sobrescritos nesta fonte.
Um spot denominado otmptSuperscriptOffset, \  O deslocamento horizontal e vertical recomendado para sobrescritos nesta fonte. O deslocamento sobrescrito é medido da linha de base do caractere até a linha de base do caractere sobrescrito.
Um número denominado otmsStrikeoutSize, \  A largura do traço do tachado para esta fonte. Normalmente, essa é a largura do travessão da fonte.
Um número denominado otmsStrikeoutPosition, \A posição do traço do tachado em relação à linha de base desta fonte. Os valores positivos estão acima da linha de base e os valores negativos estão abaixo.
Um número denominado otmsUnderscoreSize, \ A espessura do caractere de sublinhado para esta fonte.
Um número denominado otmsUnderscorePosition, \ The position of the underscore character for this font.
Um endereço de memória denominado otmpFamilyName, \ O deslocamento do início da estrutura para uma string especificando o nome da família da fonte.
Um endereço de memória denominado otmpFaceName, \ O deslocamento do início da estrutura para uma string especificando o nome do tipo de fonte. (Este nome de tipo de letra corresponde ao nome especificado na estrutura LOGFONT.)
Um endereço de memória denominado otmpStyleName, \ O deslocamento do início da estrutura para uma string especificando o nome do estilo da fonte.
Um endereço de memória denominado otmpFullName. \ O deslocamento do início da estrutura para uma string especificando o nome completo da fonte. Este nome é exclusivo para a fonte e geralmente contém um número de versão ou outras informações de identificação.

Um x-offset é um offset.
Um y-offset é um offset.

Etapas necessárias para que se output o arco of uma elipse usando um string: \\ interessante.
Atribua 2761/10000 a um fração. \ 2/3*(sqrt(2)-1)
Atribua o center desta elipse a um center spot.
Atribua o x-extent desta elipse dividido por 2 a um half largura.
Atribua o y-extent desta elipse dividido por 2 a um half altura.
Atribua o x-extent desta elipse times a fração a um x-offset.
Atribua o y-extent desta elipse times a fração a um y-offset.
\ control point 1
Se o string for "canto superior esquerdo", atribua a coordenada esquerda desta elipse e a coordenada y deste center menos o y-offset a um first control spot.
Se o string for "canto superior direito", atribua a coordenada x deste center mais o x-offset e a coordenada superior desta elipse ao first control spot.
Se o string for "canto inferior direito", atribua a coordenada direita desta elipse e a coordenada y deste center mais o y-offset ao first control spot.
Se o string for "canto inferior esquerdo ", atribua a coordenada x deste center menos o x-offset e a coordenada inferior desta elipse ao first control spot.
\ control point 2
Se o string for "canto superior esquerdo", atribua a coordenada x deste center menos o x-offset e a coordenada superior desta elipse a um second control spot.
Se o string for "canto superior direito", atribua a coordenada direita desta elipse e a coordenada y deste center menos o y-offset ao second control spot.
Se o string for "canto inferior direito", atribua a coordenada x deste center mais o x-offset e a coordenada inferior desta elipse ao second control spot.
Se o string for "canto inferior esquerdo ", atribua a coordenada esquerda desta elipse e a coordenada y deste center mais o y-offset ao second control spot.
\ ending point
Se o string for "canto superior esquerdo", atribua a coordenada esquerda desta elipse mais o half largura e a coordenada superior desta elipse a um ending spot.
Se o string for "canto superior direito", atribua a coordenada direita desta elipse e a coordenada superior desta elipse mais o half altura ao ending spot.
Se o string for "canto inferior direito", atribua a coordenada direita desta elipse menos o half largura e a coordenada inferior desta elipse ao ending spot.
Se o string for "canto inferior esquerdo ", atribua a coordenada esquerda desta elipse e a coordenada inferior desta elipse menos o half altura ao ending spot.
\ spit it out
Output o first control spot sem advancing.
Output o second control spot sem advancing.
Output o ending spot sem advancing.
Output "c".

Etapas necessárias para que se output uma cor sem advancing:
Converta a cor para um espaço de cor RGB.
Atribua o espectro vermelho deste espaço de cor RGB / 255 a um fração.
Converta a fração para um red string usando 4.
Atribua o espectro verde deste espaço de cor RGB / 255 à fração.
Converta a fração para um green string usando 4.
Atribua o espectro azul deste espaço de cor RGB / 255 à fração.
Converta a fração para um blue string usando 4.
Output o red string seguido de " " seguido de o green string seguido de " " seguido de o blue string sem advancing.

Etapas necessárias para que se output lineto usando um spot:
Output o spot sem advancing.
Output "l".

Etapas necessárias para que se output lineto usando um número x e um número y:
Atribua o número x e o número y a um spot.
Output lineto usando o spot.

Etapas necessárias para que se output moveto usando um spot:
Output o spot sem advancing.
Output "m".

Etapas necessárias para que se output moveto usando um número x e um número y:
Atribua o número x e o número y a um spot.
Output moveto usando o spot.

Etapas necessárias para que se output um número sem advancing:
Converta o número para um string.
Output o string sem advancing.
Output " " sem advancing.

Etapas necessárias para que se output o pdf border usando uma cor:
Se a cor for a cor da borda atual deste pdf state, cancele.
Output a cor sem advancing.
Output " RG".
Atribua a cor à cor da borda atual deste pdf state.

Etapas necessárias para que se output o pdf fill usando uma cor:
Se a cor for a cor de preenchimento atual deste pdf state, cancele.
Output a cor sem advancing.
Output " rg".
Atribua a cor à cor de preenchimento atual deste pdf state.

Etapas necessárias para que se output setcolor usando uma cor da borda e uma cor de preenchimento:
Se a cor de preenchimento não estiver clear, output o pdf fill usando a cor de preenchimento.
Se a cor da borda não estiver clear, output o pdf border usando a cor da borda.

Etapas necessárias para que se output um spot sem advancing:
Output a coordenada x deste spot sem advancing.
Output a current altura deste pdf state menos a coordenada y deste spot sem advancing.

Etapas necessárias para que se output um string:
Posponha o string para os current contents deste pdf state.

Etapas necessárias para que se output um string sem advancing:
Posponha o string para os current contents deste pdf state sem advancing.

Etapas necessárias para que se output stroke e fill usando uma cor da borda e uma cor de preenchimento:
Atribua "B" a um string. \ stroke e fill
Se a cor de preenchimento estiver clear, atribua "S" ao string. \ stroke
Se a cor da borda estiver clear, atribua "f" ao string. \ fill
Output o string.

Um pabc é um endereço de memória para um abc.

Um paintstruct é um conjunto com
Um hdc denominado hdc,
Um número denominado ferase,
Um caixa denominado rcpaint,
Um número denominado frestore,
Um número denominado fincupdate,
32 pedaços.

Um número x é um número.
Um número y é um número.

Um pair é um conjunto com um número x e um número y.

Um panose é um conjunto com
Um pedaço denominado bfamilytype,
Um pedaço denominado bserifstyle,
Um pedaço denominado bweight,
Um pedaço denominado bproportion,
Um pedaço denominado bcontrast,
Um pedaço denominado bstrokevariation,
Um pedaço denominado barmstyle,
Um pedaço denominado bletterform,
Um pedaço denominado bmidline,
Um pedaço denominado bxheight.

Um pchar é um endereço de memória do pedaço .

Um pdevmode é um endereço de memória para um devmode.

Um pdf é um trecho.

An pdf object é uma coisa com
Um categoria [contents, font definition, font descriptor, font streamoutline, image object, outline entry, página, parent, root],
Um número,
Um offset,
Um data trecho,
Um nome da fonte [font definition],
Um font info [font definition],
Some conjunto de textos denominado font strings [page],
Some conjunto de textos denominado image strings [page].

An pdf outline entry é uma coisa com
Um pdf object (reference),
Um title string,
Um página altura,
Um destination número.

Um pdf endereço de memória é um endereço de memória para um pdf.

Um pdf state é um conjunto com
Um pdf endereço de memória,
Um documento detector,
Um página detector,
Um object número,
Some pdf objects denominado objects,
Um xref offset,
Um outline pdf object (reference),
Some pdf outline entries denominado outline entries,
Um root pdf object (reference),
Um parent pdf object (reference),
Um current contents pdf object (reference),
Um current página pdf object (reference),
Um current altura,
Um cor da borda atual,
Um cor de preenchimento atual,
Um font catálogo.

O pdf state é um pdf state.

Um pdf string é um string. \ string surrounded por ( ) e has \( por left paren, \) por right paren, \\ por barra invertida

O grossura do pincel é um número.

Um percent é um número. \ um scale com 100 no denominador

Etapas necessárias para que se escolha aleatoriamente um brilho between um percent e uma segunda percent;
Etapas necessárias para que se vary uma luminosidade between um percent e uma segunda percent;
Etapas necessárias para que se escolha aleatoriamente uam luminosidade between um percent e uma segunda percent:
Escolha aleatoriamente um número between o percent e a segunda percent.
Atribua o número times 10 à luminosidade.
Atribua a luminosidade à luminosidade deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor amarronzada:
Escolha aleatoriamente a matiz desta cor amarronzada between 250 e 350.
Escolha aleatoriamente a saturação desta cor amarronzada between 500 e 1000.
Escolha aleatoriamente o brilho desta cor amarronzada between 125 e 375.
Atribua a cor amarronzada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor amarronzada about uns percent of o time:
\ *** generalize this por all cors
Escolha aleatoriamente um número between 1 e 100.
Se o número for maior do que o percent, cancele.
Escolha aleatoriamente a cor amarronzada.
Atribua a cor amarronzada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor:
Escolha aleatoriamente a matiz desta cor between 0 e 3600.
Escolha aleatoriamente a saturação desta cor between 0 e 1000.
Escolha aleatoriamente a luminosidade desta cor between 0 e 1000.
Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor between uma segunda cor e um terceiro cor:
Escolha aleatoriamente a matiz desta cor between a matiz desta segunda cor e a matiz desta terceiro cor.
Escolha aleatoriamente a saturação desta cor between a saturação desta segunda cor e a saturação desta terceiro cor.
Escolha aleatoriamente a luminosidade desta cor between a luminosidade desta segunda cor e a luminosidade desta terceiro cor.
Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor like uma segunda cor:
Atribua a segunda cor à cor.
Escolha aleatoriamente um número between -100 e 100.
Adicione o número para a matiz desta cor.
Limite a matiz desta cor para 0 e 3599.
Defina a saturação desta cor para something between 100 e 1000.
Defina a luminosidade desta cor para something between 0 e 800.
Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor escura:
\Etapas necessárias para que se escolha aleatoriamente uma cor escura:
Escolha aleatoriamente a matiz desta cor escura between 0 e 3599.
Atribua 1000 à saturação desta cor escura.
Atribua 375 à luminosidade desta cor escura.
Atribua a cor escura à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor esverdeada:
Escolha aleatoriamente a matiz desta cor esverdeada between 900 e 1200.
Escolha aleatoriamente a saturação desta cor esverdeada between 500 e 1000.
Escolha aleatoriamente o brilho desta cor esverdeada between 250 e 875.
Atribua a cor esverdeada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor esverdeada about uns percent of o time:
\ *** generalize this por all cors
Escolha aleatoriamente um número between 1 e 100.
Se o número for maior do que o percent, cancele.
Escolha aleatoriamente a cor esverdeada.
Atribua a cor esverdeada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma orientação:
Escolha aleatoriamente a orientação between 0 e 3839.
Atribua a orientação à orientação deste context.

Etapas necessárias para que se escolha aleatoriamente um tamanho da letra between uns twips e uns segunda twips:
Escolha aleatoriamente um random número between os twips e a segunda twips.
Atribua o random número ao tamanho da letra.
Atribua o random número à tamanho da letra deste context.

Etapas necessárias para que se escolha aleatoriamente um letra of o alphabet:
\ atribua letra A context? ***
Escolha aleatoriamente um número between 65 e 90.
Atribua o número ao letra.

Etapas necessárias para que se escolha aleatoriamente um claro cor:
Escolha aleatoriamente a matiz desta claro cor between 0 e 3599.
Atribua 1000 à saturação desta claro cor.
Atribua 625 à luminosidade desta claro cor.
Atribua o claro cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um número:
Escolha aleatoriamente o número between 0 e o maior número.
Atribua o número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente um número within um quantia of uma segunda número:
Escolha aleatoriamente o número between a segunda número menos o quantia e a segunda número mais o quantia.
Atribua o número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor pastel:
Escolha aleatoriamente a matiz desta cor pastel between 0 e 3599.
Atribua 1000 à saturação desta cor pastel.
Atribua 875 à luminosidade desta cor pastel.
Atribua a cor pastel à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um rainbow cor:
Adicione 1 para o número atual da cor do arco-íris.
Se o número atual da cor do arco-íris for maior do que 6, atribua 1 ao número atual da cor do arco-íris.
Se o número atual da cor do arco-íris for 1, atribua a cor vermelha ao rainbow cor.
Se o número atual da cor do arco-íris for 2, atribua a cor laranja ao rainbow cor.
Se o número atual da cor do arco-íris for 3, atribua a cor amarela ao rainbow cor.
Se o número atual da cor do arco-íris for 4, atribua a cor verde ao rainbow cor.
Se o número atual da cor do arco-íris for 5, atribua a cor azul ao rainbow cor.
Se o número atual da cor do arco-íris for 6, atribua a cor púrpura ao rainbow cor.
Atribua o rainbow cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um solid cor:
Escolha aleatoriamente o matiz desta solid cor between 0 e 3599.
Atribua 1000 à saturação desta solid cor.
Atribua 500 à luminosidade desta solid cor.
Atribua o solid cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere no base uma fração of uma caixa;
Etapas necessárias para que se escolha aleatoriamente um spot no base uma fração of uma caixa:
Isole a caixa.
Atribua a altura desta caixa times a fração a uns twips.
Atribua a coordenada inferior desta caixa menos os twips à coordenada superior desta caixa.
Escolha aleatoriamente o spot na caixa.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere em uma caixa:
Escolha aleatoriamente a coordenada x deste spot between a coordenada esquerda desta caixa e a coordenada direita desta caixa.
Escolha aleatoriamente a coordenada y deste spot between a coordenada superior desta caixa e a coordenada inferior desta caixa.
Atribua o spot ao spot deste context.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere no middle uma fração of uma caixa;
Etapas necessárias para que se escolha aleatoriamente um spot no middle uma fração of uma caixa:
Isole a caixa.
Atribua o y deste center desta caixa a uma coordenada.
Atribua a altura desta caixa times a fração dividido por 2 a um número.
Atribua a coordenada menos o número à coordenada superior desta caixa.
Atribua a coordenada mais o número à coordenada inferior desta caixa.
Escolha aleatoriamente o spot na caixa.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere no topo half of uma caixa;
Etapas necessárias para que se escolha aleatoriamente um spot no topo half of uma caixa:
Isole a caixa.
Atribua o y deste center desta caixa à coordenada inferior desta caixa.
Escolha aleatoriamente o spot na caixa.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere no topo middle uma fração of uma caixa;
Etapas necessárias para que se escolha aleatoriamente um spot no topo middle uma fração of uma caixa:
Isole a caixa.
Atribua o y deste center desta caixa a uma coordenada.
Atribua a altura desta caixa times a fração a um número.
Atribua a coordenada menos o número à coordenada superior desta caixa.
Atribua a coordenada à coordenada inferior desta caixa.
Escolha aleatoriamente o spot na caixa.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere sobre um horizontal line;
Etapas necessárias para que se escolha aleatoriamente um spot sobre um horizontal line:
Escolha aleatoriamente a coordenada x deste spot between o horizontal x deste start desta line e o x deste end desta horizontal line.
Atribua o y desta horizontal line ao y deste spot.

Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa:
Escolha aleatoriamente a coordenada x deste spot between a coordenada esquerda desta caixa e a coordenada direita desta caixa.
Escolha aleatoriamente a coordenada y deste spot between a coordenada superior desta caixa e a coordenada inferior desta caixa.
Atribua o spot ao spot deste context.

Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa about uns twips above o middle;
Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa about uns twips above o center:
Atribua a caixa a um bounding caixa.
Atribua os twips dividido por 2 a uns segunda twips.
Atribua o y deste center desta caixa menos a segunda twips à coordenada inferior desta bounding caixa.
Atribua a coordenada inferior desta bounding caixa menos os twips à coordenada superior desta bounding caixa.
Escolha aleatoriamente o spot anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa about uns twips below o middle;
Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa about uns twips below o center:
Atribua a caixa a um bounding caixa.
Atribua os twips dividido por 2 a uns segunda twips.
Atribua o y deste center desta caixa mais a segunda twips à coordenada superior desta bounding caixa.
Atribua a coordenada superior desta bounding caixa mais os twips à coordenada inferior desta bounding caixa.
Escolha aleatoriamente o spot anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa uns twips para uns segunda twips above o middle;
Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa uns twips para uns segunda twips above o center:
Atribua a caixa a um bounding caixa.
Atribua o y deste center desta caixa menos os twips à coordenada inferior desta bounding caixa.
Atribua a coordenada inferior desta bounding caixa menos a segunda twips à coordenada superior desta bounding caixa.
Escolha aleatoriamente o spot anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa uns twips para uns segunda twips below o middle;
Etapas necessárias para que se escolha aleatoriamente um spot em uma caixa uns twips para uns segunda twips below o center:
Atribua a caixa a um bounding caixa.
Atribua o y deste center desta caixa mais os twips à coordenada superior desta bounding caixa.
Atribua a coordenada superior desta bounding caixa mais a segunda twips à coordenada inferior desta bounding caixa.
Escolha aleatoriamente o spot anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente um spot within um distance of uma segunda spot:
Escolha aleatoriamente a coordenada x deste spot within o distance of a coordenada x deste segunda spot.
Escolha aleatoriamente a coordenada y deste spot within o distance of a coordenada y deste segunda spot.
Atribua o spot ao spot deste context.

Etapas necessárias para que se escolha aleatoriamente uns twips between uns min twips e uns segunda twips; \ são all these necessary? ***
Etapas necessárias para que se escolha aleatoriamente um número between uns min twips e uns segunda twips;
Etapas necessárias para que se escolha aleatoriamente um número between um min número e um max número;
Etapas necessárias para que se escolha aleatoriamente um número from um min número para um max número;
Etapas necessárias para que se defina um número para something between uma segunda número e um terceiro número;
Etapas necessárias para que se escolha aleatoriamente um random número between um min número e um max número:
Atribua o endereçamento deste seed para EAX.
\ atribua address of randseed A ecx
Intel $8BC8. \ mov ecx,eax
\ calculate zero based max
Intel $8B8510000000. \ mov eax,[ebp+16] \ o max
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o min
Intel $2B03. \ sub eax,[ebx]
Intel $40. \ inc eax
\ ajuste randseed
Intel $691105840808. \ imul edx,[ecx],134775813
Intel $42. \ inc edx
Intel $8911. \ mov [ecx],edx
\ mul adjusted randseed pelo zero based max
Intel $F7E2. \ mul edx
\ adicione o min para an-zero base o número
Intel $0313. \ adicione edx,[ebx] o min
\ store o result
Intel $8B9D08000000. \ mov ebx,[ebp+08] \ o random número
Intel $8913. \ mov [ebx],edx
Atribua o random número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente um cor muito escura;
Etapas necessárias para que se escolha aleatoriamente um really cor escura:
Escolha aleatoriamente a matiz desta really cor escura between 0 e 3599.
Atribua 500 à saturação desta really cor escura.
Atribua 250 à luminosidade desta really cor escura.
Atribua o really cor escura à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor muito clara;
Etapas necessárias para que se escolha aleatoriamente um really claro cor:
Escolha aleatoriamente a matiz desta really claro cor between 0 e 3599.
Atribua 1000 à saturação desta really claro cor.
Atribua 750 à luminosidade desta really claro cor.
Atribua o really claro cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor escuríssima;
Etapas necessárias para que se escolha aleatoriamente um really really cor escura:
Escolha aleatoriamente a matiz desta really really cor escura between 0 e 3599.
Atribua 500 à saturação desta really really cor escura.
Atribua 125 à luminosidade desta really really cor escura.
Atribua o really really cor escura à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor claríssima;
Etapas necessárias para que se escolha aleatoriamente um really really claro cor:
Escolha aleatoriamente a matiz desta really really claro cor between 0 e 3599.
Atribua 1000 à saturação desta really really claro cor.
Atribua 875 à luminosidade desta really really claro cor.
Atribua o really really claro cor à cor deste context.

Um picture é uma coisa com
\ all caixa s são em twits
Um caixa [location of cropped picture sobre a página], 
Um uncropped caixa [location of entire picture sobre a página],
Um grayscale detector,
Um mirror detector,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal denominado data [original pedaços em original format],
Um gpbitmap.

Um imagem é uma coisa com
\ all caixa s são em twits
Um caixa [location of cropped picture sobre a página], 
Um uncropped caixa [location of entire picture sobre a página],
Um grayscale detector,
Um mirror detector,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal denominado data [original pedaços em original format],
Um gpbitmap.

\Um figura é uma coisa com
\ all caixas são em twits
\Um caixa [location of cropped picture sobre a página], 
\Um uncropped caixa [location of entire picture sobre a página],
\Um grayscale detector,
\Um mirror detector,
\Um ângulo de rotação, \ rotation é clockwise
\Um texto hexadecimal denominado data [original pedaços em original format],
\Um gpbitmap.

Etapas necessárias para que se toque um wave:
Call "winmm.dll" "PlaySound" com o first desta wave e 0 e 5 [snd_memory+snd_async].

Etapas necessárias para que se toque um wave e wait:
Call "winmm.dll" "PlaySound" com o first desta wave e 0 e 4 [snd_memory+snd_sync].

Etapas necessárias para que se toque um wave file:
Isole o wave file.
Modifique através do caractere NUL o wave file.
Call "winmm.dll" "PlaySound" com o first deste wave file e 0 e 131073 [snd_filename+snd_async].

Etapas necessárias para que se toque um wave file e wait:
Isole o wave file.
Modifique através do caractere NUL o wave file.
Call "winmm.dll" "PlaySound" com o first deste wave file e 0 e 131072 [snd_filename+snd_sync].

An point é um número [0 para 3839; por dividing um circle A compass points; 0 é noon; 960 points per quarter].

Um endereço de memória é um conjunto com 4 pedaços.

Um polígono é uma coisa com uns vértices.

Um portrait sheet é um sheet.

Um position é um pair com um column# e um número da linha.

Etapas necessárias para que se posicione um subtexto sobre um string:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o string
\ atribua o first deste string ao first des te subtexto
Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o first do string
Intel $898800000000. \ mov [eax+0],ecx \ o first do subtexto
\ atribua o first deste string menos 1 ao last deste subtexto
Intel $49. \ dec ecx
Intel $898804000000. \ mov [eax+4],ecx \ o last deste subtexto

Etapas necessárias para que se post um data string para um url e receive um response string:
\ only works com http e https
Limpe o response.
Limpe o erro do fluxo de entrada/saída.
Crie um winhttp request por posting para o url.
Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
Send o data para o winhttp request.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
Receive o response from o winhttp request.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
Read o response from o winhttp request.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
Destrua o winhttp request.

Um poutlinetextmetric é um endereço de memória para um outlinetextmetric.

O ppi é uns twips.

An precise degree é um número [0 para 3599].

Etapas necessárias para que se anteponha um pedaço para um string:
Atribua o quantidade de caracteres deste string a um quantidade de caracteres armazenados.
Reassign o first deste string usando o quantidade de caracteres deste string mais 1.
Copie pedaços from o first deste string para o first deste string mais 1 pelo quantidade de caracteres armazenados.
Atribua o first deste string mais o quantidade de caracteres armazenados ao last deste string.
Atribua o pedaço ao target deste first deste string.

Etapas necessárias para que se anteponha um string para uma segunda string:
Atribua o quantidade de caracteres deste segunda string mais o quantidade de caracteres deste string a um quantidade de caracteres agrupados.
Reassign um endereço de memória usando o quantidade de caracteres agrupados.
Atribua o endereço de memória ao first desse subtexto.
Copie pedaços from o first deste string para o first deste subtexto pelo quantidade de caracteres deste string.
Adicione o quantidade de caracteres deste string para o first deste subtexto.
Copie pedaços from o first deste segunda string para o first deste subtexto pelo quantidade de caracteres deste segunda string.
Unassign o first deste segunda string. \ para que se esvazie extra allocates e copies
Atribua o endereço de memória ao first deste segunda string.
Atribua o first deste segunda string mais o quantidade de caracteres agrupados menos 1 ao last deste segunda string.

Etapas necessárias para que se anteponha uma coisa para uns coisas:
Se a coisa for inexistente, cancele.
Atribua o first destas coisas ao next desta coisa.
Se  as coisas não for vazio, atribua a coisa ao previous deste first destas coisas.
Se  as coisas estiverem vazio, atribua a coisa ao last destas coisas.
Atribua a coisa ao first destas coisas.

\Etapas necessárias para que se anteponha uns coisas para umas segunda coisas:
\ bug found por Mike Gonta - corrected version below
\Obtenha uma coisa from  as coisas (backwards).
\Se a coisa for inexistente, cancele.
\Remove a coisa from as coisas.
\Anteponha a coisa para a segunda coisas.
\Repita.

Etapas necessárias para que se anteponha uns coisas para umas segunda coisas:
Atribua o last destas coisas a uma coisa.
Se a coisa for inexistente, cancele.
Remove a coisa from as coisas.
Anteponha a coisa para a segunda coisas.
Repita.

An printdlgex é um conjunto com \ falta documentar isso aqui
Um número denominado lstructsize,
Um window denominado hwndowner,
Um número identificador denominado hdevmode,
Um número identificador denominado hdevnames,
Um canvas denominado hdc,
Um número denominado flags,
Um número denominado flags2,
Um número denominado exclusionflags,
Um número denominado npageranges,
Um número denominado nmaxpageranges,
Um endereço de memória denominado lppageranges,
Um número denominado nminpage,
Um número denominado nmaxpage,
Um número denominado ncopies,
Um número identificador denominado hinstance,
Um endereço de memória denominado lpprinttemplatename,
Um endereço de memória denominado lpcallback,
Um número denominado npropertypages,
Um endereço de memória denominado lphpropertypages,
Um número denominado nstartpage,
Um número denominado dwresultaction.

O printer canvas é um canvas.

O número identificador do modo de dispositivo da impressora é um número identificador.

Um process é um número identificador.

Um process endereço de memória é um endereço de memória para um process.

Um processinfo é um conjunto com
Um número identificador denominado hprocess,
Um número identificador denominado hthread,
Um número denominado dwprocessid,
Um número denominado dwthreadid.

Um punch line é um string.

Etapas necessárias para que se atribua o actual data of uma font para um trecho:
\ only works com true/abra type fonts
Crie o número da fonte of o memory canvas usando o font.
Call "gdi32.dll" "GetFontData" com o memory canvas e 0 e 0 e nil e 0 devolvendo uma contagem.
Reassign o first deste trecho usando a contagem.
Call "gdi32.dll" "GetFontData" com o memory canvas e 0 e 0 e o first deste trecho e a contagem.
Atribua o first deste trecho mais a contagem menos 1 ao last deste trecho.
Destrua o número da fonte of o memory canvas.

Etapas necessárias para que se atribua o base of uma caixa para um horizontal line;
Etapas necessárias para que se atribua o base edge of uma caixa para um horizontal line;
Etapas necessárias para que se atribua o base side of uma caixa para um horizontal line:
Atribua o canto inferior esquerdo desta caixa ao start desta horizontal line.
Atribua o canto inferior direito desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o base of uma caixa para um line:
Make o line com o canto inferior esquerdo desta caixa e o canto inferior direito desta caixa.

Etapas necessárias para que se atribua uma caixa e um raio para uma caixa arredondada:
Atribua a coordenada esquerda desta caixa à coordenada esquerda desta caixa arredondada.
Atribua a coordenada superior desta caixa à coordenada superior desta caixa arredondada.
Atribua a coordenada direita desta caixa à coordenada direita desta caixa arredondada.
Atribua a coordenada inferior desta caixa à coordenada inferior desta caixa arredondada.
Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se atribua uma caixa no center of uma segunda caixa;
Etapas necessárias para que se centralize uma caixa em uma segunda caixa:
Centralize a caixa no segunda caixa (horizontalmente).
Centralize a caixa no segunda caixa (verticalmente).

Etapas necessárias para que se atribua uma caixa no center of o tela;
Etapas necessárias para que se centralize uma caixa sobre o tela:
Centralize a caixa na caixa desta tela.

Etapas necessárias para que se atribua uma caixa para uma segunda caixa:
Atribua a coordenada esquerda desta caixa à coordenada esquerda desta segunda caixa.
Atribua a coordenada superior desta caixa à coordenada superior desta segunda caixa.
Atribua a coordenada direita desta caixa à coordenada direita desta segunda caixa.
Atribua a coordenada inferior desta caixa à coordenada inferior desta segunda caixa.

Etapas necessárias para que se atribua uma caixa sobre um spot;
Etapas necessárias para que se centralize uma caixa sobre um spot:
Obtenha um difference between o spot e o center desta caixa.
Arredonde a difference para o múltiplo imediato of o tpp.
Mova a caixa usando a difference.

Etapas necessárias para que se atribua uma caixa uns twips por uns segunda twips no center of uma segunda caixa;
Etapas necessárias para que se centralize uma caixa uns twips por uns segunda twips em uma segunda caixa:
Make a caixa os twips pelo segunda twips.
Centralize a caixa no segunda caixa.

Etapas necessárias para que se atribua a linha de baixo dessa caixa para uma horizontal line:
\ e "vertical" por left e right
Atribua a coordenada esquerda desta caixa e a coordenada inferior desta caixa ao start desta horizontal line.
Atribua a coordenada direita desta caixa e a coordenada inferior desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o base-center dessa caixa para um spot:
\ *** need these sem dashs too
Atribua o x deste center desta caixa ao x deste spot.
Atribua a coordenada inferior desta caixa ao y deste spot.

Etapas necessárias para que se atribua o center dessa caixa para um spot:
Atribua a coordenada esquerda desta caixa mais a coordenada direita desta caixa à coordenada x deste spot.
Atribua a coordenada superior desta caixa mais a coordenada inferior desta caixa à coordenada y deste spot.
Divida o spot por 2.

Etapas necessárias para que se atribua o center-base dessa caixa para um spot:
Atribua a coordenada x deste center desta caixa à coordenada x deste spot.
Atribua a coordenada inferior desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua o center-top dessa caixa para um spot:
Atribua a coordenada x deste center desta caixa à coordenada x deste spot.
Atribua a coordenada superior desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua a altura dessa caixa para uma altura:
Atribua a coordenada inferior desta caixa ao altura.
Subtraia a coordenada superior desta caixa from o altura.
Adicione o tpp para o altura.

Etapas necessárias para que se atribua a left line dessa caixa para um line:
Atribua a coordenada esquerda desta caixa e a coordenada superior desta caixa ao start desta line.
Atribua a coordenada esquerda desta caixa e a coordenada inferior desta caixa ao end desta line.

Etapas necessárias para que se atribua a canto inferior esquerdo dessa caixa para um spot:
Atribua a coordenada esquerda desta caixa à coordenada x deste spot.
Atribua a coordenada inferior desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua o left-center dessa caixa para um spot:
Atribua a coordenada esquerda desta caixa à coordenada x deste spot.
Atribua a coordenada y deste center desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua o right line dessa caixa para uma line:
Atribua a coordenada direita desta caixa e a coordenada superior desta caixa ao start desta line.
Atribua a coordenada direita desta caixa e a coordenada inferior desta caixa ao end desta line.

Etapas necessárias para que se atribua o right-center dessa caixa para um spot:
Atribua a coordenada direita desta caixa à coordenada x deste spot.
Atribua a coordenada y deste center desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua o canto superior direito dessa caixa para um spot:
Atribua a coordenada direita desta caixa à coordenada x deste spot.
Atribua a coordenada superior desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua a linha de cima dessa caixa para uma horizontal line:
Atribua a coordenada esquerda desta caixa e a coordenada superior desta caixa ao start desta horizontal line.
Atribua a coordenada direita desta caixa e a coordenada superior desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o topo-center dessa caixa para um spot:
Atribua a coordenada x deste center desta caixa à coordenada x deste spot.
Atribua a coordenada superior desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua a largura dessa caixa para uma largura:
Atribua a coordenada direita desta caixa ao largura.
Subtraia a coordenada esquerda desta caixa from o largura.
Adicione o tpp para o largura.

Etapas necessárias para que se atribua o x-extent dessa caixa para uma largura:
Atribua a coordenada direita desta caixa ao largura.
Subtraia a coordenada esquerda desta caixa from o largura.

Etapas necessárias para que se atribua o y-extent dessa caixa para uma altura:
Atribua a coordenada inferior desta caixa ao altura.
Subtraia a coordenada superior desta caixa from o altura.

Etapas necessárias para que se atribua um pedaço e um número para um fração:
Atribua o pedaço ao numerador desta fração.
Atribua o número ao denominador desta fração.

Etapas necessárias para que se atribua um pedaço para uma segunda pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda byte
Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um pedaço para eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0FB603. \ movzx eax,byte ptr [ebx]

Etapas necessárias para que se atribua um pedaço para um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,byte ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se atribua um pedaço para um string:
Atribua 1 a um quantidade de caracteres.
Reassign o first deste string usando o quantidade de caracteres.
Atribua o pedaço ao target deste first deste string.
Atribua o first deste string ao last deste string.

Etapas necessárias para que se atribua um pedaço para um wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $660FB600. \ movzx eax,byte ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o wyrd
Intel $668903. \ mov [ebx],ah

Etapas necessárias para que se atribua o character depois de um finger para um character:
Se o finger for inexistente, limpe o character; exit.
Atribua o target deste finger ao character.

Etapas necessárias para que se atribua uma cor para uma segunda cor:
Atribua a matiz desta cor à matiz desta segunda cor.
Atribua a saturação desta cor à saturação desta segunda cor.
Atribua a luminosidade desta cor à luminosidade desta segunda cor.

Etapas necessárias para que se atribua um date/time para uma segunda date/time:
Atribua o year deste date/time ao year deste segunda date/time.
Atribua o month deste date/time ao month deste segunda date/time.
Atribua o week day deste date/time ao week day segunda date/time.
Atribua o day deste date/time ao day deste segunda date/time.
Atribua a hour deste date/time à hour deste segunda date/time.
Atribua o minute deste date/time ao minute deste segunda date/time.
Atribua o second deste date/time ao second deste segunda date/time.
Atribua o millisecond deste date/time ao millisecond deste segunda date/time.

Etapas necessárias para que se atribua o string dessa date/time para um string:
Limpe o string.
Posponha o year deste date/time para o string.
Posponha "/" para o string.
Zero fill o month deste date/time usando 2 e posponha it para o string.
Posponha "/" para o string.
Zero fill o day deste date/time usando 2 e posponha it para o string.
Posponha " " para o string.
Zero fill a hour deste date/time usando 2 e posponha it para o string.
Posponha ":" para o string.
Zero fill o minute deste date/time usando 2 e posponha it para o string.
Posponha ":" para o string.
Zero fill o second deste date/time usando 2 e posponha it para o string.
Posponha ":" para o string.
Zero fill o millisecond deste date/time usando 3 e posponha it para o string.

Etapas necessárias para que se atribua eax para um pedaço:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua eax para um detector;
Etapas necessárias para que se atribua eax para um endereço de memória;
Etapas necessárias para que se atribua eax para um número:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se atribua eax para um wyrd:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o wyrd
Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua uma elipse no middle of uma caixa;
Etapas necessárias para que se centralize uma elipse em uma caixa:
Centralize a elipse na caixa (horizontalmente).
Centralize a elipse na caixa (verticalmente).

Etapas necessárias para que se atribua um elipse para uma segunda elipse:
Atribua a caixa desta elipse à caixa desta segunda elipse.

Etapas necessárias para que se atribua um elipse sobre um spot;
Etapas necessárias para que se centralize um elipse sobre um spot:
Centralize a caixa desta elipse sobre o spot.

Etapas necessárias para que se atribua um finger sobre o first character of um string:
Atribua o first deste string ao finger.

Etapas necessárias para que se atribua um detector para uma segunda detector;
Etapas necessárias para que se atribua um detector para um número;
Etapas necessárias para que se atribua um endereço de memória para um número;
Etapas necessárias para que se atribua um endereço de memória para uma segunda endereço de memória;
Etapas necessárias para que se atribua um número para um detector;
Etapas necessárias para que se atribua um número para um endereço de memória;
Etapas necessárias para que se atribua um número para uma segunda número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se atribua um detector para eax;
Etapas necessárias para que se atribua um endereço de memória para eax;
Etapas necessárias para que se atribua um número para eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B03. \ mov eax,[ebx]

Etapas necessárias para que se atribua um detector para um string;
Etapas necessárias para que se converta um detector para um string:
Se o detector estiver ativo, atribua "yes" ao string; exit. \ no momento tem que ser inglês por conta das externalized reams
Atribua "no" ao string.

Etapas necessárias para que se atribua uma font para uma segunda font:
Atribua o nome desta font ao nome desta segunda font.
Atribua a altura desta font à altura desta segunda font.

Etapas necessárias para que se atribua uns font larguras para um trecho:
\ used em pdf conversion
Limpe o trecho.
Se o font larguras forem inexistente, cancele.
Atribua o data destes font larguras a um endereço numérico.
Percorra.
Se um contador é past a contagem destas font larguras, pare.
Posponha o target deste endereço numérico seguido de " " para o trecho.
Adicione 1 para uma contagem.
Se a contagem for uniformemente divisível por 16, posponha o texto CRLF para o trecho.
Adicione a magnitude desse número para o endereço numérico.
Repita.

Etapas necessárias para que se atribua a adjusted altura dessa font para uma altura:
Atribua a altura desta font times 3/4 à altura.

Etapas necessárias para que se atribua uma fração para uma segunda fração:
Atribua o numerador desta fração ao numerador desta segunda fração.
Atribua o denominador desta fração ao denominador desta segunda fração.

Etapas necessárias para que se atribua uma fração para um string;
Etapas necessárias para que se converta uma fração para um string:
Limpe o string.
Isole a fração.
Se a fração é negative, atribua "-" ao string; de-sign a fração.
Reduce a fração.
Converta a fração para um mixed.
Se o mixed for 0, posponha "0" para o string; exit.
Se o whole número deste mixed não for 0, posponha o whole número deste mixed para o string.
Se o fração deste mixed for 0, cancele.
Se o string não estiver em branco, posponha o hífem para o string.
Posponha o numerador deste mixed seguido de "/" seguido de o denominador deste mixed para o string.

Etapas necessárias para que se atribua uma fração pair para uma segundo fração pair:
Atribua a fração deste fração pair à fração deste segundo fração pair.
Atribua a segunda fração deste fração pair à segunda fração deste segundo fração pair.

Etapas necessárias para que se atribua o absolute value dessa fração para uma segunda fração:
Atribua a fração à segunda fração.
De-sign a segunda fração.

Etapas necessárias para que se atribua o gprect desse gpimage para um gprect:
Atribua 0 ao x deste gprect.
Atribua 0 ao y deste gprect.
Atribua a largura desta gpimage ao largura deste gprect.
Atribua a altura desta gpimage à altura deste gprect.

Etapas necessárias para que se atribua a altura desse gpimage para uma altura:
Se o gpimage for inexistente, atribua 0 ao altura; exit.
Call "gdiplus.dll" "GdipGetImageHeight" com o gpimage e o endereçamento desta altura.

Etapas necessárias para que se atribua a largura desse gpimage para uma largura:
Se o gpimage for inexistente, atribua 0 ao largura; exit.
Call "gdiplus.dll" "GdipGetImageWidth" com o gpimage e o endereçamento desta largura.

Etapas necessárias para que se atribua um gprect para uma segunda gprect:
Atribua o x deste gprect ao x deste segunda gprect.
Atribua o y deste gprect ao y deste segunda gprect.
Atribua o largura deste gprect ao largura deste segunda gprect.
Atribua a altura deste gprect à altura deste segunda gprect.

Etapas necessárias para que se atribua um matiz e um saturação e um luminosidade para uma cor:
Atribua o matiz à matiz desta cor.
Se a matiz desta cor não for -1, limite a matiz desta cor para 0 e 3599. \ -1 estiver clear
Atribua o saturação à saturação desta cor.
Limite a saturação desta cor para 0 e 1000.
Atribua o luminosidade à luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se atribua a contagem desse catálogo para uma contagem:
Atribua 0 à contagem.
Se o catálogo for inexistente, cancele.
Percorra.
Obtenha um bucket usando o catálogo.
Se o bucket for inexistente, cancele.
Adicione a contagem destes refers deste bucket para a contagem.
Repita.

Etapas necessárias para que se atribua a used contagem de buckets desse catálogo para uma contagem:
Atribua 0 à contagem.
Se o catálogo for inexistente, cancele.
Percorra.
Obtenha um bucket usando o catálogo.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Adicione 1 para a contagem.
Repita.

Etapas necessárias para que se atribua uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior e um raio para uma caixa arredondada:
Atribua a coordenada esquerda à coordenada esquerda desta caixa arredondada.
Atribua a coordenada superior à coordenada superior desta caixa arredondada.
Atribua a coordenada direita à coordenada direita desta caixa arredondada.
Atribua a coordenada inferior à coordenada inferior desta caixa arredondada.
Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se atribua uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior para uma caixa:
Atribua a coordenada esquerda à coordenada esquerda desta caixa.
Atribua a coordenada superior à coordenada superior desta caixa.
Atribua a coordenada direita à coordenada direita desta caixa.
Atribua a coordenada inferior à coordenada inferior desta caixa.

Etapas necessárias para que se atribua uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior para um elipse:
Atribua a coordenada esquerda à coordenada esquerda desta elipse.
Atribua a coordenada superior à coordenada superior desta elipse.
Atribua a coordenada direita à coordenada direita desta elipse.
Atribua a coordenada inferior à coordenada inferior desta elipse.

Etapas necessárias para que se atribua a coordenada esquerda of uma caixa para um vertical line;
Etapas necessárias para que se atribua a coordenada esquerda edge of uma caixa para um vertical line;
Etapas necessárias para que se atribua a coordenada esquerda side of uma caixa para um vertical line:
Atribua o canto superior esquerdo desta caixa ao start desta vertical line.
Atribua o canto inferior esquerdo desta caixa ao end desta vertical line.

Etapas necessárias para que se atribua um line no middle of uma caixa;
Etapas necessárias para que se centralize um line em uma caixa:
Centralize o line na caixa (horizontalmente).
Centralize o line na caixa (verticalmente).

Etapas necessárias para que se atribua um line para uma segunda line:
Atribua o start desta line ao start desta segunda line.
Atribua o end desta line ao end desta segunda line.

Etapas necessárias para que se atribua a base dessa line para uma coordenada:
Atribua o y deste start desta line à coordenada.
Se o y deste end desta line for maior do que o y deste start desta line, atribua o y deste end desta line à coordenada.

Etapas necessárias para que se atribua a caixa dessa line para uma caixa:
Atribua o start desta line ao canto superior esquerdo desta caixa.
Atribua o end desta line ao canto inferior direito desta caixa.
Normalize a caixa.

Etapas necessárias para que se atribua o center dessa line para um spot:
Atribua a coordenada x desta start desta line mais a coordenada x deste end desta line à coordenada x deste spot.
Atribua a coordenada y desta start desta line mais a coordenada y deste end desta line à coordenada y deste spot.
Divida o spot por 2.

Etapas necessárias para que se atribua a coordenada esquerda dessa line para uma coordenada:
Atribua a coordenada x desta start desta line à coordenada.
Se a coordenada x deste end desta line for menor do que a coordenada x desta start desta line, atribua a coordenada x deste end desta line à coordenada.

Etapas necessárias para que se atribua o right dessa line para uma coordenada:
Atribua a coordenada x desta start desta line à coordenada.
Se a coordenada x deste end desta line for maior do que a coordenada x desta start desta line, atribua a coordenada x deste end desta line à coordenada.

Etapas necessárias para que se atribua o topo dessa line para uma coordenada:
Atribua a coordenada y desta start desta line à coordenada.
Se a coordenada y deste end desta line for menor do que a coordenada y desta start desta line, atribua a coordenada y deste end desta line à coordenada.

Etapas necessárias para que se atribua masking tape below um figura:
Se a figura for inexistente, cancele.
Se a contagem destes vértices desta figura for menor do que 2, cancele.
Copie a figura para uma segunda figura.
Atribua a coordenada inferior desta tela à  coordenada y desse spot.
Atribua a coordenada x deste last desta figura à coordenada x deste spot.
Posponha o spot para a segunda figura.
Atribua a coordenada x deste first desta figura à coordenada x deste spot.
Posponha o spot para a segunda figura.
Posponha o spot deste first desta figura para a segunda figura.
Cubra internamente a segunda figura.
Destrua a segunda figura.

Etapas necessárias para que se atribua o middle of um line sobre um spot;
Etapas necessárias para que se centralize um line sobre um spot:
Obtenha um difference between o spot e o center desta line.
Arredonde a difference para o múltiplo imediato of o tpp.
Mova o line usando a difference.

Etapas necessárias para que se atribua o spot deste mouse para um spot:
Call "user32.dll" "GetCursorPos" com o endereçamento deste spot.
Call "user32.dll" "ScreenToClient" com o main window e o endereçamento deste spot. \ em case window é sobre uma segunda monitor.
Call "gdi32.dll" "DPtoLP" com o tela canvas e o endereçamento deste spot e 1.

Etapas necessárias para que se atribua um nome e uma altura para um font:
Atribua o nome ao nome desta font.
Atribua o altura à altura desta font.

Etapas necessárias para que se atribua um nome para uma font:
Atribua o nome ao nome desta font.

Etapas necessárias para que se atribua um número e uma segunda número para um pair:
Atribua o número ao número x deste pair.
Atribua a segunda número ao número y deste pair.

Etapas necessárias para que se atribua um número para um big-endian unsigned wyrd:
Atribua o número a um wyrd.
Atribua o wyrd ao big-endian unsigned wyrd.

Etapas necessárias para que se atribua um número para um pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um número para um fração:
Atribua o número ao numerador desta fração.
Atribua 1 ao denominador desta fração.

Etapas necessárias para que se atribua um número para um pair:
Atribua o número ao número x deste pair.
Atribua o número ao número y deste pair.

Etapas necessárias para que se atribua um número para um string;
Etapas necessárias para que se converta um número para um string:
Limpe o string.
Isole o número.
De-sign o número.
Percorra.
Divida o número por 10 usando um quotient e um resto.
Adicione 48 para o resto.
Atribua o resto a um pedaço.
Anteponha o pedaço para o string.
Se o quotient for 0, pare.
Atribua o quotient ao número.
Repita.
Se o original número for menor do que 0, anteponha o hífem para o string.

Etapas necessárias para que se atribua um número para um wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o wyrd
Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua um número sobre o stack:
Converta o número para um vocábulo.
Atribua o vocábulo sobre o stack.

Etapas necessárias para que se atribua um número over uma segunda número em uma fração;
Etapas necessárias para que se atribua um número e uma segunda número para uma fração:
Atribua o número ao numerador desta fração.
Atribua a segunda número ao denominador desta fração.

Etapas necessárias para que se atribua o absolute value desse número para uma segunda número:
Atribua o número ao segunda número.
De-sign a segunda número.

Etapas necessárias para que se atribua um outlinetextmetric para uma segunda outlinetextmetric:
Copie pedaços from o endereçamento deste outlinetextmetric para o endereçamento deste segunda outlinetextmetric pela magnitude deste outlinetextmetric.

Etapas necessárias para que se atribua um pair para uma segunda pair:
Atribua o número x deste pair ao número x deste segunda pair.
Atribua o número y deste pair ao número y deste segunda pair.

Etapas necessárias para que se atribua o absolute value desse pair para uma segunda pair:
Atribua o pair ao segunda pair.
De-sign a segunda pair.

 \ unclear why this does not get denominado properly when I replace hoja apaisada com caja ***

Etapas necessárias para que se atribua um picture no middle of uma caixa;
Etapas necessárias para que se centralize um picture em uma caixa:
Se o picture for inexistente, cancele.
Centralize o picture na caixa (horizontalmente).
Centralize o picture na caixa (verticalmente).

Etapas necessárias para que se atribua um picture sobre um spot;
Etapas necessárias para que se centralize um picture sobre um spot:
Se o picture for inexistente, cancele.
Obtenha um difference between o spot e o center desta caixa desta picture.
Arredonde a difference para o múltiplo imediato of o tpp.
Mova o picture usando a difference.

Etapas necessárias para que se atribua um polígono no middle of uma caixa;
Etapas necessárias para que se centralize um polígono em uma caixa:
Se o polígono for inexistente, cancele.
Centralize o polígono na caixa (horizontalmente).
Centralize o polígono na caixa (verticalmente).

Etapas necessárias para que se atribua um polígono no middle of o tela;
Etapas necessárias para que se centralize um polígono sobre o tela:
Centralize o polígono na caixa desta tela.

Etapas necessárias para que se atribua um polígono sobre um spot;
Etapas necessárias para que se centralize um polígono sobre um spot:
Se o polígono for inexistente, cancele.
Obtenha um difference between o spot e o center desta caixa deste polígono.
Arredonde a difference para o múltiplo imediato of o tpp.
Mova o polígono usando a difference.

Etapas necessárias para que se atribua a caixa desse polígono para uma caixa:
Se o polígono for inexistente, zero a caixa; exit.
Se os vértices deste polígono estiverem vazio, zero a caixa; exit.
Atribua o maior número e o maior número e o menor número e o menor número ao caixa.
Percorra.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, pare.
Se a coordenada x deste vértice for menor do que a coordenada esquerda desta caixa, atribua a coordenada x deste vértice à coordenada esquerda desta caixa.
Se a coordenada y deste vértice for menor do que a coordenada superior desta caixa, atribua a coordenada y deste vértice à coordenada superior desta caixa.
Se a coordenada x deste vértice for maior do que a coordenada direita desta caixa, atribua a coordenada x deste vértice à coordenada direita desta caixa.
Se a coordenada y deste vértice for maior do que a coordenada inferior desta caixa, atribua a coordenada y deste vértice à coordenada inferior desta caixa.
Repita.

Etapas necessárias para que se atribua o center desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o center desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua o center-base desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o center-base  desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua o center-top desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o center-top desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua a altura desse polígono para uma altura:
Se o polígono for inexistente, limpe o altura; exit.
Atribua a altura desta caixa deste polígono à altura.

Etapas necessárias para que se atribua o canto inferior esquerdo desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o canto inferior esquerdo desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua o left-center desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o left-center desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua o canto superior esquerdo desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o canto superior esquerdo desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua o canto inferior direito desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o canto inferior direito desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua o right-center desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o right-center desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua o canto superior direito desse polígono para um spot:
Se o polígono for inexistente, limpe o spot; exit.
Atribua o canto superior direito desta caixa deste polígono ao spot.

Etapas necessárias para que se atribua a largura desse polígono para uma largura:
Se o polígono for inexistente, limpe o largura; exit.
Atribua a largura desta caixa deste polígono à largura.

Etapas necessárias para que se atribua o x-extent desse polígono para uma largura:
Se o polígono for inexistente, limpe o largura; exit.
Atribua o x-extent desta caixa deste polígono ao largura.

Etapas necessárias para que se atribua o y-extent desse polígono para uma altura:
Se o polígono for inexistente, limpe o altura; exit.
Atribua o y-extent desta caixa deste polígono ao altura.

Etapas necessárias para que se atribua um percorredor para uma segunda percorredor:
Copie pedaços from o endereçamento deste percorredor para o endereçamento deste segunda percorredor pela magnitude deste percorredor.

Etapas necessárias para que se atribua o right of uma caixa para uma vertical line;
Etapas necessárias para que se atribua o right edge of uma caixa para uma vertical line;
Etapas necessárias para que se atribua o right side of uma caixa para uma vertical line:
Atribua o canto superior direito desta caixa ao start desta vertical line.
Atribua o canto inferior direito desta caixa ao end desta vertical line.

Etapas necessárias para que se atribua uma caixa arredondada para uma segunda caixa arredondada:
Atribua a coordenada esquerda desta caixa arredondada à coordenada esquerda desta segunda caixa arredondada.
Atribua a coordenada superior desta caixa arredondada à coordenada superior desta segunda caixa arredondada.
Atribua a coordenada direita desta caixa arredondada à coordenada direita desta segunda caixa arredondada.
Atribua a coordenada inferior desta caixa arredondada à coordenada inferior desta segunda caixa arredondada.
Atribua o raio desta caixa arredondada ao raio desta segunda caixa arredondada.

Etapas necessárias para que se atribua o working string dessa row para um subtexto:
Se a row for inexistente, limpe o subtexto; exit.
Lance o subtexto sobre o string deste row.
Subtraia 1 from o last deste subtexto.

Etapas necessárias para que se atribua um seleção para uma segunda seleção:
Atribua o anchor desta seleção ao anchor desta segunda seleção.
Atribua o caret desta seleção ao caret desta segunda seleção.

Etapas necessárias para que se atribua um sockaddr para uma segunda sockaddr:
Copie pedaços from o endereçamento deste sockaddr para o endereçamento deste segunda sockaddr pela magnitude deste sockaddr.

Etapas necessárias para que se atribua um spot e uma segunda spot e um raio para uma caixa arredondada:
Atribua o spot ao canto superior esquerdo desta caixa arredondada.
Atribua a segunda spot à canto inferior direito desta caixa arredondada.
Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se atribua um spot e uma segunda spot para uma caixa:
Atribua o spot ao canto superior esquerdo desta caixa.
Atribua a segunda spot ao canto inferior direito desta caixa.

Etapas necessárias para que se atribua um spot e uma segunda spot para uma elipse:
Atribua o spot ao canto superior esquerdo desta elipse.
Atribua a segunda spot ao canto inferior direito desta elipse.

Etapas necessárias para que se atribua um spot e uma segunda spot para uma line:
Atribua o spot ao start desta line.
Atribua a segunda spot ao end desta line.

Etapas necessárias para que se atribua um spot no middle of uma caixa;
Etapas necessárias para que se centralize um spot em uma caixa:
Centralize o spot na caixa (horizontalmente).
Centralize o spot na caixa (verticalmente).

Etapas necessárias para que se atribua um string para uma segunda string:
Atribua o quantidade de caracteres deste string a um quantidade de caracteres armazenados.
Assign um endereço de memória usando o quantidade de caracteres armazenados.
Copie pedaços from o first deste string para o endereço de memória pelo quantidade de caracteres armazenados.
Unassign o first deste segunda string.
Atribua o endereço de memória ao first deste segunda string.
Atribua o first deste segunda string mais o quantidade de caracteres armazenados menos 1 ao last deste segunda string.

Etapas necessárias para que se atribua um string para uma letra:
Atribua o target deste first deste string ao letra.

Etapas necessárias para que se atribua um string para um text:
Se o text for inexistente, cancele.
Destrua as rows deste text.
Reset o origin of o text.
Reset o caret of o text.
Desselecione o text.
Isole o string.
Posponha o return pedaço para o string.
Converta o string para as rows deste text.
Wrap o text.

Etapas necessárias para que se atribua um string sobre o área de transferência do Windows:
Call "user32.dll" "OpenClipboard" com o main window.
Call "user32.dll" "EmptyClipboard".
Atribua o quantidade de caracteres deste string mais 1 a um número.
Call "kernel32.dll" "GlobalAlloc" com 66 [ghnd] e o número devolvendo um número identificador.
Call "kernel32.dll" "GlobalLock" com o número identificador devolvendo um endereço de memória.
Copie pedaços from o first deste string para o endereço de memória pelo quantidade de caracteres deste string.
Call "kernel32.dll" "GlobalUnlock" com o número identificador.
Call "user32.dll" "SetClipboardData" com 1 [cf_text] e o número identificador.
Call "user32.dll" "CloseClipboard".

Etapas necessárias para que se atribua o quantidade de caracteres dessa string para um quantidade de caracteres:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o string
\ Carregue default result
Intel $B900000000. \ mov ecx,0
\ if first for 0, store 0
Intel $833B00. \ cmp [ebx],0
Intel $0F8414000000. \ je store it
\ if last for menor do que first, store 0
Intel $8B5304. \ mov edx,[ebx+4] \ last endereço de memória
Intel $3B13. \ cmp edx,[ebx]
Intel $0F8C09000000. \ jl store it
\ calc quantidade de caracteres
Intel $8B8B04000000. \ mov ecx,[ebx+4] \ last endereço de memória
Intel $2B0B. \ sub ecx,[ebx] \ subtraia first
Intel $41. \ inc ecx \ adicione 1
\ STORE IT:
Intel $8B950C000000. \ mov edx,[ebp+12] \ o número
Intel $890A. \ mov [edx],ecx

Etapas necessárias para que se atribua a largura dessa string para uma largura:
\Consegui traduzir como:
\Etapas necessárias para que se atribua uma largura desse string para uma segunda largura:
Obtenha o largura usando o string e o memory canvas e a fonte padrão.

\ \ leave out - causes Spanish string atribuas para resolva here instead of "Atribua um string a uma segunda string"
Etapas necessárias para que se atribua um subtexto para uma segunda subtexto:
Copie pedaços from o endereçamento deste subtexto para o endereçamento deste segunda subtexto pela magnitude deste subtexto.

Etapas necessárias para que se atribua o date/time do system para um date/time:
Call "kernel32.dll" "GetLocalTime" com o endereçamento desse systemtime.
Atribua o wyear deste systemtime ao year deste date/time.
Atribua o wmonth deste systemtime ao month deste date/time.
Atribua o wdayofweek deste systemtime ao week day deste date/time.
Atribua o wday deste systemtime ao day deste date/time.
Atribua o whour deste systemtime à hour deste date/time.
Atribua o wminute deste systemtime ao minute deste date/time.
Atribua o wsecond deste systemtime ao second deste date/time.
Atribua os wmilliseconds deste systemtime ao millisecond deste date/time.

Etapas necessárias para que se atribua o last erro do system para um número:
Call "kernel32.dll" "GetLastError" devolvendo o número.

Etapas necessárias para que se atribua o last winsock erro do system para um número:
Call "ws2_32.dll" "WSAGetLastError" devolvendo o número.

Etapas necessárias para que se atribua a contagem de ticks do sistema para uns ticks:
\ wraps cada 24.8 days ou so
Call "kernel32.dll" "GetTickCount" devolvendo os ticks.
Conjuncione logicamente os ticks com o maior número.

Etapas necessárias para que se atribua um terminal no middle of uma caixa;
Etapas necessárias para que se centralize um terminal em uma caixa:
Isole a caixa.
Indent a caixa 24 px.
Atribua a caixa à caixa deste terminal.

Etapas necessárias para que se atribua um text no middle of uma caixa;
Etapas necessárias para que se centralize um text em uma caixa:
Se o text for inexistente, cancele.
Centralize o text na caixa (horizontalmente).
Centralize o text na caixa (verticalmente).

Etapas necessárias para que se atribua um text sobre um spot;
Etapas necessárias para que se centralize um text sobre um spot:
Se o text for inexistente, cancele.
Obtenha um difference between o spot e o center desta caixa deste text.
Arredonde a difference para o múltiplo imediato of o tpp.
Mova o text usando a difference.

Etapas necessárias para que se atribua a first line desse text para um string:
Se o text for inexistente, limpe o string; exit.
Atribua o string desta first row deste text ao string.
Remove o last pedaço from o string.

Etapas necessárias para que se atribua a first non-em branco line desse text para um string:
\ *** new
Limpe o string.
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Atribua o string deste row ao string.
Remove o last pedaço from o string. \ cr ou space (see text rules)
Remove algum tipo de leading noise from o string.
Remove algum tipo de trailing noise from o string.
Se o string estiver em branco, repita.

Etapas necessárias para que se atribua a globalized origin desse text para um spot:
Se o text for inexistente, limpe o spot; exit.
Atribua a origin deste text ao spot.
Globalize o spot usando o canto superior esquerdo deste text.

Etapas necessárias para que se atribua a grid desse text para um grid:
Se o text for inexistente, limpe a grid; exit.
Atribua a altura desta font deste text times 4 ao número x desta grid.
Atribua a altura desta font deste text ao número y desta grid.

Etapas necessárias para que se atribua a normalized seleção desse text para um seleção:
Se o text for inexistente, cancele.
Atribua a seleção deste text ao seleção.
Normalize o seleção.

Etapas necessárias para que se atribua a contagem de linhas desse text para uma contagem:
Se o text for inexistente, atribua 0 à contagem; exit.
Se as rows deste text estiverem vazio, atribua 0 à contagem; exit.
Atribua o número da linha deste last destas rows deste text à contagem.

Etapas necessárias para que se atribua a altura da linha desse text para uma altura:
Se o text for inexistente, atribua 0 ao altura; exit.
Atribua a altura desta font deste text ao altura.

Etapas necessárias para que se atribua a rows/box desse text para uma contagem:
Se o text for inexistente, atribua 0 à contagem; exit.
Atribua a altura desta caixa deste text dividido pela altura da linha deste text à contagem.

Etapas necessárias para que se atribua a quantidade de caracteres selecionados desse text para uma contagem:
Atribua 0 à contagem.
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
Adicione o quantidade de caracteres deste subtexto para a contagem.
Repita.

Etapas necessárias para que se atribua a selecionado contagem de linhas desse text para uma contagem:
Atribua 0 à contagem.
Se o text for inexistente, cancele.
Atribua a normalized seleção deste text a um seleção.
Se o anchor número da linha desta seleção é o número de linhas do cursor desta seleção, cancele.
Atribua o número de linhas do cursor desta seleção à contagem.
Subtraia o anchor número da linha desta seleção from a contagem.
Se o caret column# desta seleção não for 1, adicione 1 para a contagem.

Etapas necessárias para que se atribua o painel de informações string desse text para um string:
Se o text for inexistente, limpe o string; exit.
Atribua a selecionado contagem de linhas deste text a uma contagem.
Se a contagem não for 0, format a contagem e "linha selecionada" ou "linhas selecionadas" ao string; exit.
Atribua a quantidade de caracteres selecionados deste text a uma segunda contagem.
Se a segunda contagem não for 0, format a segunda contagem e "pedaço" ou "pedaços" ao string; exit.
Converta o número de linhas do cursor deste text para o string.
Posponha ":" para o string.
Posponha o caret column# deste text para o string.

Etapas necessárias para que se atribua uma coisa at o end of uns coisas;
Etapas necessárias para que se posponha uma coisa para uns coisas:
Se a coisa for inexistente, cancele.
Atribua o last destas coisas ao previous desta coisa.
Se as coisas não estiverem vazio, atribua a coisa ao next deste last destas coisas.
Se as coisas estiverem vazio, atribua a coisa ao first destas coisas.
Atribua a coisa ao last destas coisas.

Etapas necessárias para que se atribua umas coisas para umas segunda coisas:
Atribua o first destas coisas ao first destas segunda coisas.
Atribua o last destas coisas ao last destas segunda coisas.

Etapas necessárias para que se atribua a contagem dessas coisas  para uma contagem:
Atribua 0 à contagem.
Percorra.
Obtenha uma coisa from as coisas.
Se a coisa for inexistente, cancele.
Adicione 1 para a contagem.
Repita.

Etapas necessárias para que se atribua um temporizador para um string;
Etapas necessárias para que se converta um temporizador para um string:
Converta os ticks deste temporizador para o string.

Etapas necessárias para que se atribua o string desse temporizador para um string:
Converta os ticks deste temporizador para o string.

Etapas necessárias para que se atribua os ticks desse temporizador para uns ticks:
Atribua os total ticks deste temporizador aos ticks.
Se a contagem deste temporizador for 0, cancele.
Atribua a contagem de ticks do sistema a uns segunda ticks. 
Subtraia os start ticks deste temporizador from os segunda ticks.
Adicione os segunda ticks para os ticks.

Etapas necessárias para que se atribua um vocábulo sobre o stack:
Aloque memória por um stack entry.
Atribua o vocábulo ao string desta stack entry.
Anteponha o stack entry para o stack.

Etapas necessárias para que se atribua o topo of uma caixa para um horizontal line;
Etapas necessárias para que se atribua o topo edge of uma caixa para um horizontal line;
Etapas necessárias para que se atribua o topo side of uma caixa para um horizontal line:
Atribua o canto superior esquerdo desta caixa ao start desta horizontal line.
Atribua o canto superior direito desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o topo of uma caixa para um line:
Make o line com o canto superior esquerdo desta caixa e o canto superior direito desta caixa.

Etapas necessárias para que se atribua um wyrd para uma segunda wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $668B00. \ mov ax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda wyrd
Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua um wyrd para um big-endian unsigned wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $668B00. \ mov ax,word ptr [eax]
Intel $86E0. \ xchg al,ah
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o big-endian unsigned wyrd
Intel $668903. \ mov palavra ptr [ebx],ax

Etapas necessárias para que se atribua um wyrd para um pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $668B00. \ mov ax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um wyrd para eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o wyrd
Intel $0FBF03. \ movsx eax,word ptr [ebx]

Etapas necessárias para que se atribua um wyrd para um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $0FBF00. \ movsx eax,wyrd ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
Intel $8903. \ mov [ebx],eax

Uma coordenada x é uma coordenada.
Uma coordenada y é uma coordenada.

Etapas necessárias para que se atribua uma coordenada x e uma coordenada y e uma segunda coordenada x e uma segunda coordenada y para uma line:
Atribua a coordenada x à coordenada x desta start desta line.
Atribua a coordenada y à coordenada y desta start desta line.
Atribua a segunda coordenada x à coordenada x deste end desta line.
Atribua a segunda coordenada y à coordenada y deste end desta line.

Um query pedaço é um query string.

Um query string é um string.

Etapas necessárias para que se quit;
Etapas necessárias para que se relinquish control:
Desmanche a fila de eventos.
Crie um event.
Atribua "fechamento do programa" à categoria deste event.
Enfileire o event.

Um quora é uma coisa com um string e uma cor. \ quora é short por "question ou answer"

Etapas necessárias para que se quote um string:
\ inserts leading, trailing e nested double-quotes
Atribua as aspas duplas a uma segunda string.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, pare.
Posponha o target deste first deste subtexto para a segunda string.
Se o target deste first deste subtexto for as aspas duplas, posponha as aspas duplas para a segunda string.
Adicione 1 para o first deste subtexto.
Repita.
Posponha as aspas duplas para a segunda string.
Atribua a segunda string ao string.

Um quotient é um número.

Um raio é uns twips.

Etapas necessárias para que se raise um número para uma segunda número:
Se a segunda número for 0, atribua 1 ao número; exit.
Se a segunda número for menor do que 0, atribua 0 ao número; exit. \ deveria ser 1/the raised result, but always comes out 0 com números
Atribua 1 a um result número.
Percorra.
Se um contador é past a segunda número, pare.
Multiplique o result pelo número.
Repita.
Atribua o result ao número.

Um random número é um número.

Um ratio é um fração.

Um ratio pair é uma fração pair.

Etapas necessárias para que se read o Bíblia:
Se o Bíblia não for inexistente, cancele.
Extraia um endereço da pasta from o endereço completo deste module.
Percorra.
Se o endereço da pasta estiver em branco, cancele.
Atribua o endereço da pasta seguido de "Bíblia.txt" a um endereço completo.
Se o endereço completo estiver no sistema de arquivos, read o Bíblia usando o endereço completo; exit.
Extraia o endereço da pasta from o endereço da pasta.
Repita.

Etapas necessárias para que se read a Bíblia usando um endereço completo:
Se o Bíblia não for inexistente, cancele.
Read o endereço completo a um trecho.
Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
Aloque memória para o Bíblia.
Lance um percorredor sobre o trecho.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Aloque memória por um verse. Posponha o verse para os verses desta Bíblia.
Mova o percorredor (text file rules).
Atribua o vocábulo deste percorredor ao string deste verse.
Remove algum tipo de leading noise from o string deste verse.
Remove algum tipo de trailing noise from o string deste verse.
Repita.

Etapas necessárias para que se read um pedaço from um console:
Read um string from o console.
Se o string estiver em branco, atribua o null pedaço ao pedaço; exit.
Atribua o target deste first deste string ao pedaço.

Etapas necessárias para que se read um console para um string:
Se o console for inexistente, limpe o string; exit.
Desmanche all events.
Limpe o reply deste console.
Mostre o console.
Execute events usando o console.
Atribua o reply deste console ao string.
Desmanche all events.
Atualize o cursor.

Etapas necessárias para que se read um file para um trecho:
Limpe o erro do fluxo de entrada/saída.
Call "kernel32.dll" "GetFileSize" com o file e nil devolvendo um size.
Reassign o first deste trecho usando o size.
Atribua o first deste trecho mais o size menos 1 ao last deste trecho.
Call "kernel32.dll" "ReadFile" com o file e o first deste trecho e o size e o endereçamento desse número e 0 devolvendo um result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de tentar ler o arquivo." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se read um detector from um console:
Read um string from o console.
Converta o string para o detector.

Etapas necessárias para que se read uma fração from um console:
Read um string from o console.
Converta o string para a fração.

Etapas necessárias para que se read um número from um console:
Read um string from o console.
Converta o string para o número.

Etapas necessárias para que se carregue um endereço completo para um trecho;
Etapas necessárias para que se read um endereço completo para um trecho:
Limpe o erro do fluxo de entrada/saída.
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Se o endereço completo não estiver no sistema de arquivos, atribua "O Arquivo: " seguido de o endereço completo seguido de " não existe." ao erro do fluxo de entrada/saída; exit.
\ abra o endereço completo para read-write mode.
Call "kernel32.dll" "CreateFileA" com o first deste endereço completo e -2147483648 [generic_read] e 3 [file_share_read+file_share_write] e 0 
And 3 [open_existing] e 0 e 0 devolvendo um número identificador.
Se o número identificador for -1 [invalid_handle_value], atribua "Ocorreu um erro na hora de tentar abrir o arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.
Call "kernel32.dll" "GetFileSize" com o número identificador e nil devolvendo um size.
Reassign o first deste trecho usando o size.
Atribua o first deste trecho mais o size menos 1 ao last deste trecho.
Call "kernel32.dll" "ReadFile" com o número identificador e o first deste trecho e o size e o endereçamento desse número e 0 devolvendo o número.
Call "kernel32.dll" "CloseHandle" com o número identificador.
Se o número não for 0, cancele.
Atribua "Ocorreu um erro na hora de tentar ler o arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se carregue um endereço completo para um picture:

Etapas necessárias para que se read um endereço completo para um picture:
Read o endereço completo a um trecho.
Se o erro do fluxo de entrada/saída não estiver em branco, esvazie o picture; exit.
Crie o picture usando o trecho.

Etapas necessárias para que se read um reply from um terminal:
Se o terminal for inexistente, limpe o reply; exit.
Desmanche all events.
Limpe o reply deste terminal.
Adicione um quora para o terminal.
Atribua "> " ao string deste quora.
Atribua a input cor deste terminal à cor deste quora.
Mostre o terminal.
Execute events usando o terminal.
\ mostre o terminal.
Atribua o reply deste terminal ao reply.
Remove algum tipo de leading noise from o reply.
Remove algum tipo de trailing noise from o reply.
Desmanche all events.
\ questionable below
Crie um event.
Atribua "clique" à categoria deste event.
\Atribua "clic izquierdo" à categoria deste event.
Atribua o spot deste mouse ao spot deste event.
Enfileire o event.
Atualize o cursor.

Etapas necessárias para que se read um response string from um winhttp request:
Se o winhttp request for inexistente, cancele.
Limpe o response.
Atribua 8 kilopedaços a um trecho size.
Percorra.
Atribua 0 a um size.
Call "winhttp.dll" "WinHttpqueryDataAvailable"
With a request deste winhttp request e o endereçamento deste size devolvendo um result número.
Se o result for 0, atribua "Erro. Não foi possível consultar os dados disponíveis." ao erro do fluxo de entrada/saída; limpe o response; break.
Atribua o quantidade de caracteres desta response a um quantidade de caracteres armazenados.
Reassign o first desta response usando o quantidade de caracteres armazenados mais o trecho size.
Atribua o first desta response mais o quantidade de caracteres armazenados a um endereço de memória.
Call "winhttp.dll" "WinHttpReadData" com a request deste winhttp request e o endereço de memória And o trecho size e o endereçamento dessa contagem devolvendo o result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de ler os dados." ao erro do fluxo de entrada/saída; limpe o response; break.
Atribua o endereço de memória mais a contagem menos 1 ao last desta response.
Se a contagem for 0, pare.
Repita.

Etapas necessárias para que se read stdin para um trecho:
Limpe o erro do fluxo de entrada/saída.
Limpe o trecho.
Encontre um string usando o environment variáveis e "CONTENT_LENGTH".
Se o string estiver em branco, atribua "Ocorreu um erro na hora de obter o conteúdo de comprimento CONTENT_LENGTH." ao erro do fluxo de entrada/saída; exit.
Converta o string a um quantidade de caracteres.
Se o quantidade de caracteres for 0, cancele.
Reassign o first deste trecho usando o quantidade de caracteres.
Call "kernel32.dll" "ReadFile" com o stdin handle e o first deste trecho e o quantidade de caracteres e o endereçamento desse número e nil.
Se o número não for o quantidade de caracteres, atribua "Erro ao ler dados do fluxo de entrada padrão stdin." ao erro do fluxo de entrada/saída; limpe o trecho; exit.
Atribua o first deste trecho mais o quantidade de caracteres menos 1 ao last deste trecho.

Etapas necessárias para que se read um string from um console:
Read o console ao string.

Etapas necessárias para que se read um url para um trecho:
\ prepare
Limpe o trecho.
Limpe o erro do fluxo de entrada/saída.
\ internet abra
Call "wininet.dll" "InternetOpenA" com o first deste nome deste module e 0 [internet_open_type_preconfig] e nil e nil devolvendo um internet número identificador.
Se o internet handle for 0, atribua "Erro. Não foi possível se conectar à internet. Verifique sua conexão" ao erro do fluxo de entrada/saída; exit.
\ internet abra url
Isole o url.
Modifique através do caractere NUL o url.
Call "wininet.dll" "InternetOpenUrlA" com o internet handle e o first desta url e nil e 0 e 0 e 0 devolvendo um url número identificador.
Se o url handle for 0, atribua "Erro. Não foi possível acessar a URL: " seguido de o url seguido de "." ao erro do fluxo de entrada/saída; call "wininet.dll" "InternetCloseHandle" com o internet handle; exit.
\ read o file
Atribua 64 kilopedaços a um trecho size.
Percorra.
Atribua o quantidade de caracteres deste trecho a um quantidade de caracteres armazenados.
Reassign o first deste trecho usando o quantidade de caracteres armazenados mais o trecho size.
Atribua o first deste trecho mais o quantidade de caracteres armazenados a um endereço de memória.
Call "wininet.dll" "InternetReadFile" com o url handle e o endereço de memória e o trecho size e o endereçamento dessa contagem devolvendo um result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de ler a URL: " seguido de o url seguido de "." ao erro do fluxo de entrada/saída; break.
Atribua o endereço de memória mais a contagem menos 1 ao last deste trecho.
Se a contagem for 0, pare.
Repita.
\ clean para cima
Call "wininet.dll" "InternetCloseHandle" com o url número identificador.
Call "wininet.dll" "InternetCloseHandle" com o internet número identificador.

Etapas necessárias para que se reassign um endereço de memória usando um quantidade de pedaços:
Se o endereço de memória for inexistente, assign o endereço de memória usando o quantidade de pedaços; exit.
Se o quantidade de pedaços for 0, unassign o endereço de memória; exit.
Isole o quantidade de pedaços.
Arredonde o quantidade de pedaços para cima para o nearest power of two.
Call "kernel32.dll" "HeapReAlloc" com o endereço heap e 8 [heap_zero_memory] e o endereço de memória e o quantidade de pedaços devolvendo o endereço de memória.

Etapas necessárias para que se receive um trecho from um socket:
Limpe o erro do fluxo de entrada/saída.
Limpe o trecho.
Atribua 8 kilopedaços a um trecho size.
Percorra.
Atribua 0 a um size.
Atribua o quantidade de caracteres deste trecho a um quantidade de caracteres armazenados.
Reassign o first deste trecho usando o quantidade de caracteres armazenados mais o trecho size.
Atribua o first deste trecho mais o quantidade de caracteres armazenados a um endereço de memória.
Call "ws2_32.dll" "recv" com o socket e o endereço de memória e o trecho size e 0 devolvendo uma contagem.
Se a contagem não for -1 [socket_error], atribua o endereço de memória mais a contagem menos 1 ao last deste trecho; exit.
Se o last winsock erro do system não for 10040 [wsamsgsize], atribua "Ocorreu um erro no recebimento dos dados." ao erro do fluxo de entrada/saída; limpe o trecho; exit.
\Se o last winsock erro desse system não for 10040 [wsamsgsize], atribua "Ocorreu um erro no recebimento dos dados." ao erro do fluxo de entrada/saída; limpe o trecho; exit.
Atribua o endereço de memória mais a contagem menos 1 ao last deste trecho.
Repita.

Etapas necessárias para que se receive o response from um winhttp request:
Se o winhttp request for inexistente, cancele.
Call "winhttp.dll" "WinHttpReceiveResponse"
With a request deste winhttp request
And 0
devolvendo um result número.
Se o result for 0, atribua "No pude enviar o pedido." ao erro do fluxo de entrada/saída; exit.

Um recipient é um string.

Um retângulo é um figura.
Um skinny retângulo é um retângulo.
Um diamond é um figura.
Um desert landscape é uma coisa.
Um octagon é um figura.
Um arco é um figura.
Um circle é um figura.
Um fractal forest é uma coisa.
Um joke é uma coisa.
Um triangle é um figura.
Um heptagon é um figura. \ 7 sides
Um nonagon é um figura. \ 9 sides
Um decagon é um figura. \ 10 sides
Um hexagon é um figura.
Um koch curve é um figura.
Um twelve-sided figura é um figura.
Um half circle é um figura.
Um half circle flower é um figura.
Um quarter circle é um figura.
Um spiral é um figura.
Um leaf é um figura.
Um half leaf é um figura.
Um five pointed star é um figura.
Um six pointed star é um figura.
Um left crescent é um figura.
Um right crescent é um figura.
Um pinceltagon é um figura.
Um solid é um figura.
Um star é uma coisa.
Um cube é um figura.
Um yew tree é um figura.
Um tree é um figura.

Etapas necessárias para que se reduce um fração:
Obtenha um máximo divisor comum usando o numerador desta fração e o denominador desta fração.
Divida o numerador desta fração pelo máximo divisor comum.
Divida o denominador desta fração pelo máximo divisor comum.

An refer é uma coisa com um string e um endereço de memória (reference).

Etapas necessárias para que se atualize o cursor:
Crie um event.
Atribua "mostrar seta" à categoria deste event.
\Atribua "cursor" à categoria deste event.
Se a tecla Alt estiver sendo pressionada, acione o detector de tecla alt deste event.
Se a tecla Ctrl estiver sendo pressionada, acione o detector de tecla ctrl deste event.
Se a tecla shift estiver sendo pressionada, acione o detector de tecla shift deste event.
Atribua o spot deste mouse ao spot deste event.
Enfileire o event.

Etapas necessárias para que se atualize o tela usando uma caixa:
Call "gdi32.dll" "BitBlt" com o tela canvas e a coordenada esquerda desta caixa e a coordenada superior desta caixa e a largura desta caixa e a altura desta caixa 
And o quadro atual e a coordenada esquerda desta caixa e a coordenada superior desta caixa e 13369376 [srccopy].

Um resto é um número.

Etapas necessárias para que se relembre um text:
Se o text for inexistente, cancele.
Destrua os redos deste text.
Copie o text a uma segunda text.
Redimensione proporcionalmente a segunda text para 1/1.
Posponha a segunda text para os undos deste text.
Limite os undos deste text para o max text undos.
Ligue o detector de alteração deste text.

Etapas necessárias para que se relembre um text com um operação:
Se o text for inexistente, cancele.
Se o última operação deste text for a operação, acione o detector de alteração deste text; exit.
Relembre o text.
Atribua o operação à última operação deste text.

Etapas necessárias para que se relembre where we are:
Save o context.

O remembered pdf endereço completo é um endereço completo.

Etapas necessárias para que se remove algum tipo de pedaços selecionados em um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Atribua a seleção deste text a um seleção.
Normalize o seleção.
Obtenha uma row usando o anchor número da linha desta seleção e o text.
Lance um subtexto sobre o string deste row.
Atribua o first deste subtexto mais o anchor column# desta seleção menos 2 ao last deste subtexto.
Obtenha uma segunda row usando o número de linhas do cursor desta seleção e o text.
Lance uma segunda subtexto sobre o string desta segunda row.
Atribua o first deste segunda subtexto mais o caret column# desta seleção menos 1 ao first deste segunda subtexto.
Atribua o subtexto seguido de a segunda subtexto ao string desta row.
Remove as rows of o text between o next desta row e a segunda row.
Atribua o anchor desta seleção ao caret deste text.
Desselecione o text.

Etapas necessárias para que se remove algum tipo de trailing barra invertida from um string:
Se o string estiver em branco, cancele.
Se o target deste last deste string não for a barra invertida, cancele.
Remove o last pedaço from o string.

Etapas necessárias para que se remove algum tipo de trailing linefeed pedaço from um string:
Se o string estiver em branco, cancele.
Se o target deste last deste string não for o linefeed pedaço, cancele.
Remove o last pedaço from o string.

Etapas necessárias para que se remove algum tipo de trailing return pedaço from um string:
Se o string estiver em branco, cancele.
Se o target deste last deste string não for o return pedaço, cancele.
Remove o last pedaço from o string.

Etapas necessárias para que se remova pedaços de um string usando um subtexto:
Se o string estiver em branco, cancele.
Se o subtexto estiver em branco, cancele.
Atribua o last deste string menos o last deste subtexto a um quantidade de caracteres.
Atribua o last deste subtexto mais 1 a um endereço de memória.
Copie pedaços from o endereço de memória para o first deste subtexto pelo quantidade de caracteres.
Atribua o quantidade de caracteres deste string menos o quantidade de caracteres deste subtexto a um new quantidade de caracteres.
Reassign o first deste string usando o new quantidade de caracteres.
Atribua o first deste string mais o new quantidade de caracteres menos 1 ao last deste string.

Etapas necessárias para que se remova pedaços de um text (backspace over um return):
Se o text for inexistente, cancele.
Se o número de linhas do cursor deste text for 1, cancele.
Obtenha uma row usando o número de linhas do cursor deste text menos 1 e o text.
Atribua o quantidade de caracteres deste string desta row e o número de linhas do cursor deste text menos 1 ao caret deste text.
Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (backspace com jump):
Se o text for inexistente, cancele.
Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
Se o caret column# deste text for 1, remova pedaços de o text (backspace over um return); exit.
Jump o caret left no text.
Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (backspace):
Se o text for inexistente, cancele.
Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
Se o caret column# deste text for 1, remova pedaços de o text (backspace over um return); exit.
Mova o caret left no text.
Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (forward delete um return):
Se o text for inexistente, cancele.
Se o número de linhas do cursor deste text for a contagem de linhas deste text, cancele.
Atribua 1 e o número de linhas do cursor deste text mais 1 ao caret deste text.
Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (forward delete com jump):
Se o text for inexistente, cancele.
Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Se o caret column# deste text é o quantidade de caracteres deste string desta row, remova pedaços de o text (forward delete um return); exit.
Jump o caret right no text.
Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (forward delete):
Se o text for inexistente, cancele.
Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Se o caret column# deste text é o quantidade de caracteres deste string desta row, remova pedaços de o text (forward delete um return); exit.
Mova o caret right no text.
Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remove cada pedaço em um text:
Se o text for inexistente, cancele.
Atribua "" ao text.

Etapas necessárias para que se remove o first pedaço from um string:
Lance um subtexto sobre o first pedaço of o string.
Remova pedaços de o string usando o subtexto.

 
Etapas necessárias para que se remove o last pedaço from um string:
Lance um subtexto sobre o last pedaço of o string.
Remova pedaços de o string usando o subtexto.

Etapas necessárias para que se remove os last dois pedaços from um string:
Remove trailing pedaços from o string usando 2.

Etapas necessárias para que se remove leading pedaços from um string usando uma contagem:
Isole a contagem.
Se a contagem for maior do que o quantidade de caracteres deste string, limpe o string; exit.
Lance um subtexto sobre o first pedaço of o string.
Atribua o first deste subtexto mais a contagem menos 1 ao last deste subtexto.
Remova pedaços de o string usando o subtexto.

Etapas necessárias para que se remove leading noise from um string;
Etapas necessárias para que se remove algum tipo de leading noise from um string:
Se o string estiver em branco, cancele.
Se o target deste first deste string não for irrelevante, cancele.
Remove o first pedaço from o string.
Repita.

Etapas necessárias para que se remove a rows of um text between uma row e uma segunda row:
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Se a segunda row for inexistente, cancele.
Se o número da linha desta row for maior do que o número da linha desta segunda row, cancele.
Isole a row.
Atribua o next desta segunda row a uma stop row.
Percorra.
Se a row for a stop row, pare.
Atribua o next desta row a um next row.
Remove a row from as rows deste text.
Destrua a row.
Atribua o next row à row.
Repita.
Renumber as rows deste text.

Etapas necessárias para que se remove uma coisa from uns coisas:
Se a coisa for inexistente, cancele.
Se a coisa for o first destas coisas, atribua o next desta coisa ao first destas coisas.
Se a coisa for o last destas coisas, atribua o previous desta coisa ao last destas coisas.
Se o next desta coisa não for inexistente, atribua o previous desta coisa ao previous deste next desta coisa.
Se o previous desta coisa não for inexistente, atribua o next desta coisa ao next deste previous desta coisa.
Esvazie o next desta coisa.
Esvazie o previous desta coisa.

Etapas necessárias para que se remove trailing pedaços from um string usando uma contagem:
Isole a contagem.
Se a contagem for maior do que o quantidade de caracteres deste string, limpe o string; exit.
Lance um subtexto sobre o last pedaço of o string.
Atribua o last deste subtexto menos a contagem mais 1 ao first deste subtexto.
Remova pedaços de o string usando o subtexto.

Etapas necessárias para que se remove trailing noise from um string;
Etapas necessárias para que se remove algum tipo de trailing noise from um string:
Se o string estiver em branco, cancele.
Se o target deste last deste string não for irrelevante, cancele.
Remove o last pedaço from o string.
Repita.

Etapas necessárias para que se rename um endereço completo para uma segunda endereço completo no sistema de arquivos:
Isole o endereço completo.
Remove algum tipo de trailing barra invertida from o endereço completo.
Modifique através do caractere NUL o endereço completo.
Isole a segunda endereço completo.
Remove algum tipo de trailing barra invertida from a segunda endereço completo.
Modifique através do caractere NUL a segunda endereço completo.
Call "kernel32.dll" "MoveFileA" com o first deste endereço completo e o first deste segunda endereço completo devolvendo um número.
Limpe o erro do fluxo de entrada/saída.
Se o número não for 0, cancele.
Atribua "Ocorreu um erro ao renomear o arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se renumber uns rows:
Obtenha uma row from a rows.
Se a row for inexistente, cancele.
Adicione 1 para um número da linha.
Atribua o número da linha ao número da linha desta row.
Repita.

Etapas necessárias para que se replace um pedaço com uma segunda pedaço em um string:
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto não for o pedaço, adicione 1 para o first deste subtexto; repita.
Atribua a segunda pedaço ao target deste first deste subtexto.
Adicione 1 para o first deste subtexto.
Repita.

O reply é um reply.

Um reply é um string.

Etapas necessárias para que se reenfileire um event:
Copie o event a uma segunda event.
Enfileire a segunda event.

Etapas necessárias para que se reset o alphabet:
Atribua o 'A' maiúsculo ao next letra.

Etapas necessárias para que se reset o caret of um text:
Se o text for inexistente, cancele.
Atribua 1 e 1 ao caret deste text.

Etapas necessárias para que se reset o context:
Restore o context.
Save o context.

Etapas necessárias para que se reset uma contagem:
Atribua 0 à contagem.

Etapas necessárias para que se reset o drawing origin:
Defina o drawing origin para o zero spot.

Etapas necessárias para que se reset um detector:
Desative o detector.

Etapas necessárias para que se reset o origin of um text:
Se o text for inexistente, cancele.
Atribua a margin deste text à coordenada x deste text.
Atribua 0 à coordenada y deste text.

Etapas necessárias para que se reset um endereço de memória;
Etapas necessárias para que se reset um endereço de memória pelo next time around;
Etapas necessárias para que se esvazie um endereço de memória:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o endereço de memória
Intel $C70000000000. \ mov [eax],0

Etapas necessárias para que se reset o rainbow cors:
Atribua 0 ao número atual da cor do arco-íris.

Etapas necessárias para que se reset um temporizador:
Atribua 0 à contagem deste temporizador.
Atribua 0 aos start ticks deste temporizador.
Atribua 0 aos total ticks deste temporizador.

Etapas necessárias para que se redimensione uma caixa usando um ratio pair;
Etapas necessárias para que se redimensione uma caixa usando uma fração pair:
Atribua o x-extent desta caixa a um largura.
Atribua o y-extent desta caixa a uma altura.
Redimensione proporcionalmente o largura usando a fração deste fração pair.
Redimensione proporcionalmente o altura usando a segunda fração deste fração pair.
Atribua a coordenada esquerda desta caixa mais o largura à coordenada direita desta caixa.
Atribua a coordenada superior desta caixa mais o altura à coordenada inferior desta caixa.

Etapas necessárias para que se redimensione uma caixa usando um twip pair:
Adicione o número x deste twip pair para a coordenada direita desta caixa.
Adicione o número y deste twip pair para a coordenada inferior desta caixa.

Etapas necessárias para que se redimensione um elipse usando um ratio pair;
Etapas necessárias para que se redimensione um elipse usando uma fração pair:
Redimensione a caixa desta elipse usando o fração pair.

Etapas necessárias para que se redimensione um elipse usando um twip pair:
Redimensione a caixa desta elipse usando o twip pair.

Etapas necessárias para que se redimensione um line usando um ratio pair;
Etapas necessárias para que se redimensione um line usando uma fração pair:
Atribua a caixa desta line a uma caixa.
Subtraia o canto superior esquerdo desta caixa from o start desta line.
Redimensione proporcionalmente o start desta line usando o fração pair.
Adicione o canto superior esquerdo desta caixa para o start desta line.
Subtraia o canto superior esquerdo desta caixa from o end desta line.
Redimensione proporcionalmente o end desta line usando o fração pair.
Adicione o canto superior esquerdo desta caixa para o end desta line.

Etapas necessárias para que se redimensione um line usando um twip pair:
Atribua a caixa desta line a uma caixa.
Atribua a caixa a uma segunda caixa.
Redimensione a segunda caixa usando o twip pair.
Make uma fração pair usando a segunda caixa e a caixa.
Redimensione o line usando o fração pair.

Etapas necessárias para que se redimensione um picture para um largura por uma altura:
Se o picture for inexistente, cancele.
Atribua o largura dividido pelo tpp a um pixel largura.
Atribua o altura dividido pelo tpp a um pixel altura.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com o pixel largura e o pixel altura e 0 e 137224 [pixelformat24bpprgb] e 0 e o endereçamento desse gpbitmap.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" com o gpbitmap e o endereçamento desse gpgraphic.
Call "gdiplus.dll" "GdipDrawImageRectRectI" com o gpgraphic e o gpbitmap desta picture.
And 0 e 0 e o pixel largura e o pixel altura
And 0 e 0 e a largura deste gpbitmap desta picture menos 1 e a altura deste gpbitmap desta picture menos 1
And 2 [unitpixel] e nil e nil e 0.
Call "gdiplus.dll" "GdipDeleteGraphics" com o gpgraphic.
Destrua o gpbitmap desta picture.
Atribua o gpbitmap ao gpbitmap desta picture.
Ajuste o picture (extract caixas from gpbitmap).
Limpe o data desta picture.

Etapas necessárias para que se redimensione um polígono usando um ratio pair;
Etapas necessárias para que se redimensione um polígono usando uma fração pair:
Se o polígono for inexistente, cancele.
Atribua a caixa deste polígono a uma caixa.
Percorra.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, cancele.
Subtraia o canto superior esquerdo desta caixa from o spot deste vértice.
Redimensione proporcionalmente o spot deste vértice usando o fração pair.
Adicione o canto superior esquerdo desta caixa para o spot deste vértice.
Repita.

Etapas necessárias para que se redimensione um polígono usando um twip pair:
Se o polígono for inexistente, cancele.
Atribua a caixa deste polígono a uma caixa.
Atribua a caixa a uma segunda caixa.
Redimensione a segunda caixa usando o twip pair.
Make uma fração pair usando a segunda caixa e a caixa.
Redimensione o polígono usando o fração pair.

Etapas necessárias para que se redimensione um text usando um ratio pair;
Etapas necessárias para que se redimensione um text usando uma fração pair:
Se o text for inexistente, cancele.
Redimensione a caixa deste text usando o fração pair.
Wrap o text.

Etapas necessárias para que se redimensione um text usando um twip pair:
Se o text for inexistente, cancele.
Redimensione a caixa deste text usando o twip pair.
Wrap o text.

Etapas necessárias para que se restart um temporizador:
Adicione 1 para a contagem deste temporizador.
Se a contagem deste temporizador não for 1, cancele.
Atribua a contagem de ticks do sistema aos start ticks deste temporizador. \ a tick contagem deste system

Etapas necessárias para que se restore um canvas:
Call "gdi32.dll" "RestoreDC" com o canvas e -1. \ need para use -1, windows documentoation é wrong

Etapas necessárias para que se restore um context:
Obtenha um saved context from o context stack.
Se o saved context for inexistente, cancele.
Atribua o spot deste saved context ao spot deste context.
Atribua a orientação deste saved context à orientação deste context.
Atribua a tamanho da letra deste saved context à tamanho da letra deste context.
Atribua a cor deste saved context à cor deste context.
Atribua o número deste saved context ao número deste context.
Remove o saved context from o context stack.
Destrua o saved context.

Etapas necessárias para que se restore um window:
Call "user32.dll" "ShowWindow" com o window e 9 [sw_restore].

Etapas necessárias para que se reverse algum tipo de rows selecionadas of um text:
Se o text for inexistente, cancele.
Split a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
Reverse o rows selecionadas.
Posponha a rows para as rows deste text.
Posponha o rows selecionadas para as rows deste text.
Posponha a segunda rows para as rows deste text.
Renumber as rows deste text.

Etapas necessárias para que se reverse uma cor:
Se a cor é a cor preta, atribua a cor branca ao cor; exit.
Se a cor é a cor branca, atribua a cor preta ao cor; exit.
Atribua 1000 menos a luminosidade desta cor à luminosidade desta cor.
\Atribua 1000 menos a saturação desta cor à saturação desta cor.
Adicione 1800 para a matiz desta cor. Normalize a matiz desta cor.

Etapas necessárias para que se invert um detector;
Etapas necessárias para que se reverse um detector:
Se o detector for 1, atribua 0 ao detector; exit.
Atribua 1 ao detector.

Etapas necessárias para que se reverse um número;
Etapas necessárias para que se invert um número:
Multiplique o número por -1.

Etapas necessárias para que se reverse um string:
\ could ser more efficient
Isole o string.
Limpe o original string.
Percorra.
Se o string estiver em branco, pare.
Obtenha um character from o string (backwards).
Posponha o character para o original string.
Repita.

Etapas necessárias para que se reverse uns coisas:
Permute  as coisas com uns segunda coisas.
Percorra.
Atribua o last destas segunda coisas a uma coisa.
Se a coisa for inexistente, cancele.
Mova a coisa from a segunda coisas para as coisas.
Repita.

Um espaço de cor RGB é um conjunto com
Um pedaço denominado espectro azul,
Um pedaço denominado espectro verde,
Um pedaço denominado espectro vermelho.

Um endereço de memória RGB é um endereço de memória para um espaço de cor RGB.

Um percorredor é um conjunto com \ conserte "avance um percorredor" e "recue um percorredor" se você alterar isso aqui
Um subtexto original,
Um source subtexto, 
Um vocábulo subtexto.

Um deslocamento vertical é um número.
Um deslocamento horizontal é um número.

Etapas necessárias para que se rotate uma caixa:
Atribua o center desta caixa a um center spot.
Atribua a caixa a uma segunda caixa.
Atribua a coordenada y deste center menos a coordenada superior desta segunda caixa mais a coordenada x deste center à coordenada direita desta caixa.
Atribua a coordenada esquerda desta segunda caixa menos a coordenada x deste center mais a coordenada y deste center à coordenada superior desta caixa.
Atribua a coordenada y deste center menos a coordenada inferior desta segunda caixa mais a coordenada x deste center à coordenada esquerda desta caixa.
Atribua a coordenada direita desta segunda caixa menos a coordenada x deste center mais a coordenada y deste center à coordenada inferior desta caixa.

Etapas necessárias para que se rotate um elipse:
Rotate a caixa desta elipse.

Etapas necessárias para que se rotate um gpimage:
Se o gpimage for inexistente, cancele.
Call "gdiplus.dll" "GdipImageRotateFlip" com o gpimage e 1 [rotate90flipnone].

Etapas necessárias para que se rotate um gpimage usando um ângulo:
\ ângulo pode ser 0, 900, 1800, 2700
Se o gpimage for inexistente, cancele.
Atribua 0 [rotatenoneflipnone] a um número.
Se o ângulo for 900, atribua 1 [rotate90flipnone] ao número.
Se o ângulo for 1800, atribua 2 [rotate180flipnone ] ao número.
Se o ângulo for 2700, atribua 3 [rotate270flipnone ] ao número.
Call "gdiplus.dll" "GdipImageRotateFlip" com o gpimage e o número.

Etapas necessárias para que se rotate um line:
Atribua o center desta line a um center spot.
Rotate o start desta line around o center.
Rotate o end desta line around o center.

Etapas necessárias para que se rotate um picture:
Se o picture for inexistente, cancele.
Adicione 900 para o ângulo de rotação desta picture.
Se o mirror detector desta picture estiver ativo, adicione 1800 para o ângulo de rotação desta picture.
Normalize o ângulo de rotação desta picture.
Rotate a caixa desta picture.
Rotate a uncropped caixa desta picture.
Atribua o center desta caixa desta picture a um center spot.
Atribua o center desta uncropped caixa desta picture a uma segunda center spot.
Atribua a coordenada y deste center menos a coordenada y deste segunda center mais a coordenada x deste center ao número x desse twip pair.
Subtraia a coordenada x deste segunda center from o número x deste twip pair.
Atribua a coordenada y deste center mais a coordenada x deste segunda center menos a coordenada x deste center ao número y deste twip pair.
Subtraia a coordenada y deste segunda center from o número y deste twip pair.
Mova a uncropped caixa desta picture usando o twip pair.
Rotate o gpbitmap desta picture.

Etapas necessárias para que se rotate um polígono:
Se o polígono for inexistente, cancele.
Atribua o center deste polígono a um center spot.
Percorra.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, cancele.
Rotate o spot deste vértice around o center.
Repita.

Etapas necessárias para que se rotate um spot around um center spot:
Atribua o spot a uma segunda spot.
Atribua a coordenada y deste center menos a coordenada y deste segunda spot mais a coordenada x deste center à coordenada x deste spot.
Atribua a coordenada x deste segunda spot menos a coordenada x deste center mais a coordenada y deste center à coordenada y deste spot.

Etapas necessárias para que se rotate um text:
Se o text for inexistente, cancele.
Rotate a caixa deste text.
Wrap o text.

Etapas necessárias para que se arredonde um número para uma segunda número:
Arredonde o número para o múltiplo imediato of a segunda número.

Etapas necessárias para que se arredonde um número para baixo para o múltiplo imediato of uma segunda número:
Divida o número pelo segunda número.
Multiplique o número pelo segunda número.

Etapas necessárias para que se arredonde um número para o múltiplo imediato of uma segunda número:
Se a segunda número for 0, cancele.
Isole a segunda número.
Divida o número pelo segunda número usando um quotient e um resto.
Divida a segunda número por 2.
Se o resto for maior do que ou igual ao segunda número, arredonde o número para cima para o múltiplo imediato of o original segunda número; exit.
Arredonde o número para baixo para o múltiplo imediato of o original segunda número.

Etapas necessárias para que se arredonde um número para cima para o múltiplo imediato of uma segunda número:
Divida o número pelo segunda número usando um quotient e um resto.
Se o resto for 0, cancele.
Adicione a segunda número menos o resto para o número.

Etapas necessárias para que se arredonde um número para cima para o nearest power of two:
Intel $8B8D08000000. \ mov ecx,[ebp+8] \ o número
Intel $8B09. \ mov ecx,[ecx]
Intel $49. \ dec ecx
Intel $0FBDC9. \ bsr ecx,ecx
Intel $41. \ inc ecx
Intel $81F904000000. \ cmp ecx,4
Intel $0F8F05000000. \ jg over o next 1 statement
Intel $B904000000. \ mov ecx,4
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $C70001000000. \ mov [eax],1
Intel $D320. \ shl [eax],ecx 

Etapas necessárias para que se arredonde um pair para uma segunda pair:
Arredonde o pair para o múltiplo imediato of a segunda pair.

Etapas necessárias para que se arredonde um pair para o múltiplo imediato of uma segunda pair:
Arredonde o número x deste pair para o múltiplo imediato of o número x deste segunda pair.
Arredonde o número y deste pair para o múltiplo imediato of o número y deste segunda pair.

Etapas necessárias para que se arredonde um pair para o múltiplo imediato of um número:
Arredonde o número x deste pair para o múltiplo imediato of o número.
Arredonde o número y deste pair para o múltiplo imediato of o número.

Etapas necessárias para que se arredonde um pair para um número:
Arredonde o pair para o múltiplo imediato of o número.

Um caixa arredondada é uma caixa com
Uma coordenada esquerda , uma coordenada superior, uma coordenada direita, uma coordenada inferior,
Um canto superior esquerdo spot at a coordenada esquerda , um canto inferior direito spot at a coordenada direita, e 
Um raio.

An row é uma coisa com um número da linha e um string.

Um número da linha é um número.

Um saturação é um número [0 para 1000].

Etapas necessárias para que se save um canvas:
Call "gdi32.dll" "SaveDC" com o canvas.

Etapas necessárias para que se save um context:
Aloque memória por um saved context.
Atribua o spot deste context ao spot deste saved context.
Atribua a orientação deste context à orientação deste saved context.
Atribua a tamanho da letra deste context à tamanho da letra deste saved context.
Atribua a cor deste context à cor deste saved context.
Atribua o número deste context ao número deste saved context.
Anteponha o saved context para o context stack.

O saved memory hbitmap é um hbitmap.

O saved tpp é um número.

Etapas necessárias para que se say um número:
Atribua o número a um string.
Say o string.

Etapas necessárias para que se say um string;
Etapas necessárias para que se speak um string:
Se o silent detector estiver ativo, cancele.
\Se la bandera silenciosa estiver ativo, cancele.
Se o talker for inexistente, cancele.
Se o string estiver em branco, cancele.
Converta o string para um wide string.
Modifique através do caractere NUL o wide string.
Call o speak desta vtable deste talker com o talker e o first deste wide string e 17 [svsfdefault+svsflagsasyn+svsfisnotxml] e 0.

Etapas necessárias para que se say um string e wait;
Etapas necessárias para que se speak um string e wait:
Se o silent detector estiver ativo, cancele.
Se la bandera silenciosa estiver ativo, cancele.
Se o talker for inexistente, cancele.
Se o string estiver em branco, cancele.
Converta o string para um wide string.
Modifique através do caractere NUL o wide string.
Call o speak desta vtable deste talker com o talker e o first deste wide string e 16 [svsfdefault+svsfisnotxml] e 0.

Etapas necessárias para que se redimensione proporcionalmente uma caixa usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente uma caixa usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a coordenada esquerda desta caixa usando a fração.
Redimensione proporcionalmente a coordenada superior desta caixa usando a fração.
Redimensione proporcionalmente a coordenada direita desta caixa usando a fração.
Redimensione proporcionalmente a coordenada inferior desta caixa usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma caixa para um percent:
Atribua o percent / 100 a um fração.
Redimensione proporcionalmente a caixa usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um elipse usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um elipse usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a caixa desta elipse usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um elipse para um percent:
Atribua o percent / 100 a um fração.
Redimensione proporcionalmente a elipse usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma font usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente uma font usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a altura desta font usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma fração usando uma segunda fração;
Etapas necessárias para que se multiplique uma fração por uma segunda fração:
Multiplique o numerador desta fração pelo numerador desta segunda fração.
Multiplique o denominador desta fração pelo denominador desta segunda fração.
Reduce a fração.

Etapas necessárias para que se redimensione proporcionalmente um line usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um line usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente o start desta line usando a fração.
Redimensione proporcionalmente o end desta line usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um line para um percent:
Atribua o percent / 100 a um fração.
Redimensione proporcionalmente o line usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um pair usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um pair usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente o número x deste pair usando a fração.
Redimensione proporcionalmente o número y deste pair usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um pair usando um ratio pair;
Etapas necessárias para que se redimensione proporcionalmente um pair usando uma fração pair:
Redimensione proporcionalmente o número x deste pair usando a fração deste fração pair.
Redimensione proporcionalmente o número y deste pair usando a segunda fração deste fração pair.

Etapas necessárias para que se redimensione proporcionalmente um pair para um percent:
Atribua o percent / 100 a um fração.
Redimensione proporcionalmente o pair usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um picture usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um picture usando um fração:
Se o picture for inexistente, cancele.
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a caixa desta picture usando a fração.
Redimensione proporcionalmente a uncropped caixa desta picture usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um picture para um percent:
Se o picture for inexistente, cancele.
Atribua o percent / 100 a um fração.
Redimensione proporcionalmente o picture usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um polígono usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um polígono usando um fração:
Se o polígono for inexistente, cancele.
Se a fração for 1/1, cancele.
Percorra.
Obtenha um vértice from os vértices deste polígono.
Se o vértice for inexistente, cancele.
Redimensione proporcionalmente o vértice usando a fração.
Repita.

Etapas necessárias para que se redimensione proporcionalmente um polígono para um percent:
Se o polígono for inexistente, cancele.
Atribua o percent / 100 a um fração.
Redimensione proporcionalmente o polígono usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma caixa arredondada usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente uma caixa arredondada usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a caixa arredondada como uma caixa usando a fração.
Redimensione proporcionalmente o raio desta caixa arredondada usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma caixa arredondada para um percent:
Atribua o percent / 100 a um fração.
Redimensione proporcionalmente a caixa arredondada usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um text para um fração:
\ absolute
Se o text for inexistente, cancele.
Atribua a scale deste text a uma segunda fração.
Flip a segunda fração.
Multiplique a segunda fração pela fração.
Redimensione proporcionalmente o text usando a segunda fração.

Etapas necessárias para que se redimensione proporcionalmente um text usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um text usando um fração:
Se o text for inexistente, cancele.
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a caixa deste text usando a fração.
Redimensione proporcionalmente a origin deste text usando a fração.
Redimensione proporcionalmente a font deste text usando a fração.
Redimensione proporcionalmente a scale deste text usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um text para um percent:
Se o text for inexistente, cancele.
Atribua o percent / 100 a um fração.
Redimensione proporcionalmente o text usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um vértice usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um vértice usando um fração:
Se o vértice for inexistente, cancele.
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a coordenada x deste vértice usando a fração.
Redimensione proporcionalmente a coordenada y deste vértice usando a fração.

O tela canvas é um canvas.
\O tela canvas é um canvas.

A tela é um conjunto com uma caixa, um pixel altura e um pixel largura.
\O screen has uma caixa, um pixel altura e um pixel largura.

Etapas necessárias para que se role um console usando um event:
Se o console for inexistente, cancele.
Encontre um sector usando a grid deste console e o spot deste event.
Percorra.
Se o botão direito deste mouse não estiver sendo pressionado, cancele.
Encontre uma segunda sector usando a grid deste console e o spot deste mouse.
Obtenha um difference between a segunda sector e o sector.
Se a difference for 0, repita.
Role o text deste console usando a difference.
Mostre o console.
Adicione a difference para o sector.
Repita.

Etapas necessárias para que se role um text para o base:
Se o text for inexistente, cancele.
Se o vertical scroll detector deste text não estiver ativo, cancele.
Atribua a contagem de linhas deste text menos 1 a um número.
Atribua - o número times a altura da linha deste text à coordenada y deste text.
Limite o origin of o text.

Etapas necessárias para que se role um text para o caret:
Se o text for inexistente, cancele.
Se o column# deste caret deste text for 1, atribua a margin deste text à coordenada x deste text.
Obtenha uma caixa pelo caret no text.
Ajuste a caixa usando 0 e - o tpp e 0 e o tpp. \ caret caixas do not fill entire row
Se a coordenada superior desta caixa for menor do que a coordenada superior deste text, atribua a coordenada superior deste text menos a coordenada superior desta caixa ao número y dessa difference.
Se a coordenada inferior desta caixa for maior do que a coordenada inferior deste text, atribua a coordenada inferior deste text menos a coordenada inferior desta caixa ao número y desta difference.
Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda deste text , atribua a coordenada esquerda deste text menos a coordenada esquerda desta caixa ao número x desta difference.
Se a coordenada direita desta caixa for maior do que a coordenada direita deste text, atribua a coordenada direita deste text menos a coordenada direita desta caixa ao número x desta difference.
Se a difference for 0, cancele.
Role o text usando a difference.

Etapas necessárias para que se role um text para o caret e center it:
Se o text for inexistente, cancele.
Atribua a margin deste text à coordenada x deste text.
Obtenha uma caixa pelo caret no text.
Se a caixa estiver inside a caixa deste text, cancele.
Ajuste a caixa usando 0 e - o tpp e 0 e o tpp. \ caret caixas don not fill entire row
Atribua o y-extent desta caixa deste text dividido por 2 a uma altura.
Arredonde o altura para baixo para o múltiplo imediato of a altura da linha deste text.
Atribua a coordenada superior desta caixa deste text mais o altura a uma coordenada superior.
Atribua a coordenada superior mais a altura da linha deste text a uma coordenada inferior.
Se a coordenada superior desta caixa for menor do que a coordenada superior, atribua a coordenada superior menos a coordenada superior desta caixa ao número y dessa difference.
Se a coordenada inferior desta caixa for maior do que a coordenada inferior, atribua a coordenada inferior menos a coordenada inferior desta caixa ao número y desta difference.
Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda deste text , atribua a coordenada esquerda deste text menos a coordenada esquerda desta caixa ao número x desta difference.
Se a coordenada direita desta caixa for maior do que a coordenada direita deste text, atribua a coordenada direita deste text menos a coordenada direita desta caixa ao número x desta difference.
Se a difference for 0, cancele.
Role o text usando a difference.

Etapas necessárias para que se role um text para baixo one line:
Se o text for inexistente, cancele.
Se o vertical scroll detector deste text não estiver ativo, cancele.
Atribua - a altura da linha deste text ao número y dessa difference.
Role o text usando a difference.

Etapas necessárias para que se role um text para baixo one página:
Se o text for inexistente, cancele.
Se o vertical scroll detector deste text não estiver ativo, cancele.
Subtraia o y-extent desta caixa deste text from a coordenada y deste text.
Adicione a altura da linha deste text para a coordenada y deste text.
Limite o origin of o text.

Etapas necessárias para que se role um text usando um difference:
Se o text for inexistente, cancele.
Isole a difference.
Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número x desta difference.
Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número y desta difference.
Se a difference for 0, cancele.
Mova a origin deste text usando a difference.
Limite o origin of o text.

Etapas necessárias para que se role um text para o topo:
Se o text for inexistente, cancele.
Se o vertical scroll detector deste text não estiver ativo, cancele.
Atribua 0 à coordenada y deste text.
Limite o origin of o text.

Etapas necessárias para que se role um text para cima one line:
Se o text for inexistente, cancele.
Se o vertical scroll detector deste text não estiver ativo, cancele.
Atribua a altura da linha deste text ao número y dessa difference.
Role o text usando a difference.

Etapas necessárias para que se role um text para cima one página:
Se o text for inexistente, cancele.
Se o vertical scroll detector deste text não estiver ativo, cancele.
Adicione o y-extent desta caixa deste text para a coordenada y deste text.
Subtraia a altura da linha deste text from a coordenada y deste text.
Limite o origin of o text.

\Um segundo for 1000 milisegundos.

An second é 1000 milliseconds.

Um sector é um pair com uma coordenada x e uma coordenada y [indicating o canto superior esquerdo of o sector].

O seed é um número.

Etapas necessárias para que se selecione cada pedaço em um text:
Se o text for inexistente, cancele.
Atribua 1 e 1 ao anchor deste text.
Atribua o quantidade de caracteres deste string deste last destas rows deste text e a contagem de linhas deste text ao caret deste text.

Etapas necessárias para que se selecione um número da linha usando um text:
Se o text for inexistente, cancele.
Obtenha uma row usando o número da linha e o text.
Se a row for inexistente, cancele.
Atribua o número da linha ao anchor número da linha deste text .
Atribua 1 ao anchor column# deste text.
Atribua o número da linha ao número de linhas do cursor deste text.
Atribua o quantidade de caracteres deste string desta row ao caret column# deste text.

Um caixa de seleção é uma caixa.

Um seleção é um conjunto com 
Um anchor column#, um anchor número da linha, um anchor at o anchor column#,
Um caret column#, um número de linhas do cursor, um caret at o caret column#.

Etapas necessárias para que se send um trecho para um socket:
Limpe o erro do fluxo de entrada/saída.
Atribua o first deste trecho a um endereço de memória.
Atribua o quantidade de caracteres deste trecho a um quantidade de caracteres.
Percorra.
Se o quantidade de caracteres for 0, pare.
Call "ws2_32.dll" "send" com o socket e o endereço de memória e o quantidade de caracteres e 0 devolvendo um número.
Se o número é -1 [socket_error], atribua "Ocorreu um erro na hora de enviar dados." ao erro do fluxo de entrada/saída; exit.
Subtraia o número from o quantidade de caracteres.
Adicione o número para o endereço de memória.
Repita.

Etapas necessárias para que se send um data string para um winhttp request:
Se o winhttp request for inexistente, cancele.
Call "winhttp.dll" "WinHttpSendRequest" com a request deste winhttp request 
And 0 [winhttp_no_additional_headers] And 0 And o first destes data And o quantidade de caracteres destes data And o quantidade de caracteres destes data And 0 devolvendo um result número.
Se o result for 0, atribua "Erro. Não foi possível enviar a solicitação." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se send um email:
Limpe o erro do fluxo de entrada/saída.
\ crie socket
Crie um socket usando o smtp server deste email e 25.
Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
\ initial receive here por date/time stuff from server
Receive um response string from o socket.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
\ send HELO
Send "HELO " seguido de o nome deste module seguido de o texto CRLF para o socket e receive o response string.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
\ send MAIL FROM: <xxx>
Send "MAIL FROM: <" seguido de o sender deste email seguido de ">" seguido de o texto CRLF para o socket e receive o response string.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
\ send RCPT TO: <xxx>
Send "RCPT TO: <" seguido de o recipient deste email seguido de ">" seguido de o texto CRLF para o socket e receive o response string.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
\ send DATA
Send "DATA" seguido de o texto CRLF para o socket e receive o response string.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
\ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
Limpe um temp string.
Posponha "De: " seguido de o sender deste email seguido de o texto CRLF para o temp string.
Posponha "Para: " seguido de o recipient deste email seguido de o texto CRLF para o temp string.
Posponha "Assunto: " seguido de o subject deste email seguido de o texto CRLF ao temp string.
Posponha "Reply-To: " seguido de o sender deste email seguido de o texto CRLF ao temp string.
Posponha o texto CRLF para o temp string.
Posponha a message deste email para o temp string (handling email transparency).
Posponha o texto CRLF seguido de "." seguido de o texto CRLF para o temp string.
Send o temp string para o socket e receive o response string.
Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
\ send QUIT
Send "QUIT" seguido de o texto CRLF para o socket.
\ destrua socket
Destrua o socket.

Etapas necessárias para que se send um message from um sender para um recipient:
Send o message para o recipient from o sender.

Etapas necessárias para que se send um message from um sender para um recipient via um smtp server:
Send o message para o recipient from o sender via o smtp server.

Etapas necessárias para que se send um message from um sender para um recipient com um subject:
Send o message para o recipient from o sender com o subject.

Etapas necessárias para que se send um message from um sender para um recipient com um subject via um smtp server:
Send o message para o recipient from o sender com o subject via o smtp server.

Etapas necessárias para que se send um message para um recipient from um sender:
Atribua o default smtp server ao smtp server desse email.
Atribua o recipient ao recipient deste email.
Atribua o sender ao sender deste email.
Atribua o message à message deste email.
Send o email.

Etapas necessárias para que se send um message para um recipient from um sender via um smtp server:
Atribua o smtp server ao smtp server desse email.
Atribua o recipient ao recipient deste email.
Atribua o sender ao sender deste email.
Atribua o message à message deste email.
Send o email.

Etapas necessárias para que se send um message para um recipient from um sender com um subject:
Atribua o default smtp server ao smtp server desse email.
Atribua o recipient ao recipient deste email.
Atribua o sender ao sender deste email.
Atribua o subject ao subject deste email.
Atribua o message à message deste email.
Send o email.

Etapas necessárias para que se send um message para um recipient from um sender com um subject via um smtp server:
Atribua o smtp server ao smtp server desse email.
Atribua o recipient ao recipient deste email.
Atribua o sender ao sender deste email.
Atribua o subject ao subject deste email.
Atribua o message à message deste email.
Send o email.

Etapas necessárias para que se send um string para um socket e receive um response string:
Limpe o response string.
Send o string para o socket.
Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
Receive o response string from o socket.

Um sender é um string.

Etapas necessárias para que se defina o código da cor of um canvas usando uma cor:
Converta a cor para um código da cor.
Call "gdi32.dll" "SetTextColor" com o canvas e o código da cor.

Etapas necessárias para que se defina o drawing origin para um spot:
Call "gdi32.dll" "GetDeviceCaps" com o quadro atual e 112 [physicaloffsetx] devolvendo o número x desse pair.
Call "gdi32.dll" "GetDeviceCaps" com o quadro atual e 113 [physicaloffsety] devolvendo o número y deste pair.
Negate o pair.
Se o quadro atual não for o printer canvas, limpe o pair.
Call "gdi32.dll" "SetViewportOrgEx" com o quadro atual e o número x deste pair e o número y deste pair e nil.
Isole o spot.
Call "gdi32.dll" "LPtoDP" com o quadro atual e o endereçamento deste spot e 1.
Call "gdi32.dll" "SetViewportOrgEx" com o quadro atual e a coordenada x deste spot e a coordenada y deste spot e nil.

Etapas necessárias para que se acione um detector;
Etapas necessárias para que se ative um detector;
Etapas necessárias para que se dispare um detector;
Etapas necessárias para que se toque um detector;
Etapas necessárias para que se ligue um detector:
Atribua 1 ao detector. \ era "Atribua sim ao detector." O valor binário do termo sim era herdado do CAL-1000 de acordo com o Dan.

Etapas necessárias para que se defina um endereço completo para read-write mode:
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "GetFileAttributesA" com o first deste endereço completo devolvendo um número.
Conjuncione logicamente o número com -2 [everything except file_attribute_readonly].
Call "kernel32.dll" "SetFileAttributesA" com o first deste endereço completo e o número.

Um sheet é uma caixa.

Etapas necessárias para que se shift um pedaço left uns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $D220. \ shl endereço de memória do pedaço [eax],ecx

Etapas necessárias para que se shift um pedaço right uns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $D228. \ shr endereço de memória do pedaço [eax],ecx

Etapas necessárias para que se shift um número left uns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $D320. \ shl [eax],ecx

Etapas necessárias para que se shift um número right uns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $D328. \ shr [eax],ecx

Etapas necessárias para que se shift um wyrd left uns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $66D320. \ shl palavra ptr [eax],ecx

Etapas necessárias para que se shift um wyrd right uns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $66D328. \ shr palavra ptr [eax],ecx

Etapas necessárias para que se mostre um console:
Se o console for inexistente, cancele.
Save o quadro atual.
Pinte o console.
Atualize o tela usando a caixa deste console.
Restore o quadro atual.

Etapas necessárias para que se mostre um cursor:
Call "user32.dll" "SetCursor" com o cursor.
Call "user32.dll" "ShowCursor" com 1 devolvendo um número.
Se o número for maior do que 0, cancele.
Repita.

Etapas necessárias para que se mostre um terminal:
Se o terminal for inexistente, cancele.
Save o quadro atual.
Pinte o terminal.
Atualize o tela usando a caixa deste terminal.
Restore o quadro atual.

Etapas necessárias para que se shrink uma caixa por uns twips;
Etapas necessárias para que se indent uma caixa uns twips;
Etapas necessárias para que se indent uma caixa por uns twips;
Etapas necessárias para que se indent uma caixa uns twips sobre cada side;
Etapas necessárias para que se indent uma caixa usando uns twips:
Adicione os twips para a coordenada esquerda desta caixa.
Adicione os twips para a coordenada superior desta caixa.
Subtraia os twips from a coordenada direita desta caixa.
Subtraia os twips from a coordenada inferior desta caixa.

Etapas necessárias para que se feche o programa;
Etapas necessárias para que se feche o nosso programa;
Etapas necessárias para que se feche nosso programa;
Etapas necessárias para que se feche tudo;
Etapas necessárias para que se shut para baixo:
Destrua o Bíblia.
Destrua o stack.
Destrua o lexicon.
Destrua o console.
\Destrua o consola.
Destrua o terminal.
Finalize o context.
Finalize os canvases.
Finalize o mouse.
Finalize os cursors.
Finalize as fonts.
Finalize a window.
Finalize o tela.
Finalize as cors.
Finalize o module.
Finalize o talker.
Finalize gdi+.
Finalize winsock.
Finalize COM.

Etapas necessárias para que se shut para baixo o cgi:
Finalize o cgi.
Finalize o module.
Finalize winsock.

Um side é 1 unit.

O silent detector é um detector.

Etapas necessárias para que se simplify um reply:
Se o reply estiver em branco, pare.
Obtenha um pedaço from o reply.
Se o pedaço é algum tipo de punctuation mark, repita.
Posponha o pedaço para um string.
Repita.
Atribua o string ao reply.

Um size é uns twips.

Etapas necessárias para que se skip algum tipo de leading linefeed pedaço em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto não for o linefeed pedaço, cancele.
Adicione 1 para o first deste subtexto.

Etapas necessárias para que se skip algum tipo de leading noise em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto não for irrelevante, cancele.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se skip algum tipo de non-alphanumeric pedaços em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for alphanumeric, cancele.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se skip um line sobre o terminal:
Escreva "" sobre o terminal.

Etapas necessárias para que se skip palavra characters em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o subtexto está sobre alguma espécie de contração, adicione 1 para o first deste subtexto; repita.
Se o target deste first deste subtexto não for alphanumeric, cancele.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se lance um percorredor sobre uma segunda percorredor:
Lance o source deste percorredor sobre o source deste segunda percorredor.
Posicione o vocábulo deste percorredor sobre o source deste percorredor.

Etapas necessárias para que se lance um percorredor sobre um string:
Lance o original deste percorredor sobre o string.
Lance o source deste percorredor sobre o string.
Posicione o vocábulo deste percorredor sobre o source deste percorredor.

Etapas necessárias para que se lance um subtexto sobre algum tipo de pedaços selecionados em uma row of um text:
Limpe o subtexto.
Se o text for inexistente, cancele.
Se a row of o text não estiver selecionado, cancele.
Lance o subtexto sobre o string deste row.
Atribua a normalized seleção deste text a um seleção.
Se o número da linha desta row é o número de linhas do cursor desta seleção, atribua o first deste subtexto mais o caret column# desta seleção menos 2 ao last deste subtexto.
Se o número da linha desta row é o anchor número da linha desta seleção, atribua o first deste subtexto mais o anchor column# desta seleção menos 1 ao first deste subtexto.

Etapas necessárias para que se lance um subtexto sobre o first pedaço of um string:
Lance o subtexto sobre o string.
Se o string estiver em branco, cancele.
Atribua o first deste string ao last deste subtexto.

Etapas necessárias para que se lance um subtexto sobre o last pedaço of um string:
Lance o subtexto sobre o string.
Se o string estiver em branco, cancele.
Atribua o last deste string ao first deste subtexto.

Etapas necessárias para que se lance um subtexto sobre um string:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o string
\ atribua o first deste string ao first do subtexto
Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o first desta string
Intel $898800000000. \ mov [eax+0],ecx \ o first do subtexto
\ atribua o last deste string ao last deste subtexto
Intel $8B8B04000000. \ mov ecx,[ebx+4] \ o last do string
Intel $898804000000. \ mov [eax+4],ecx \ o last deste subtexto

O tamanho de letra pequena é um tamanho da letra.

O menor número é -2147483648.

Etapas necessárias para que se suavize um polígono:
Se o polígono for inexistente, cancele.
Se a contagem destes vértices deste polígono for menor do que 3, cancele.
Se o polígono estiver closed, posponha o spot deste next deste first vértice deste polígono para o polígono; ative um detector.
Atribua o first vértice deste polígono a um left vértice.
Percorra.
Se o next deste left vértice for inexistente, pare.
Atribua o next deste left vértice a um right vértice.
Obtenha um center spot usando o spot deste left vértice e o spot deste right vértice.
Insira o center ao polígono after o left vértice.
Atribua o next deste left vértice a um new vértice.
Se o previous deste left vértice for inexistente, atribua o right vértice ao left vértice; repita.
Obtenha uma segunda center spot usando o spot deste previous deste left vértice e o spot deste new vértice.
Obtenha um difference between a segunda center e o spot deste left vértice.
Divida a difference por 2.
Adicione a difference para o spot deste left vértice.
Atribua o right vértice ao left vértice.
Repita.
Se o detector não estiver ativo, cancele.
Destrua o first vértice deste polígono usando o polígono.
Destrua o last vértice deste polígono usando o polígono.

Etapas necessárias para que se suavize um polígono uns times; 
Etapas necessárias para que se suavize um polígono uns vezes:
\ this use para "times" é um fluke, I think -- see "some times é um número"
Isole o times.
Percorra.
Se o times for 0, cancele.
Suavize o polígono.
Subtraia 1 from o times.
Repita.

Some vezes é um número.

Um smtp server é um string.

Um SOCKADDR é um conjunto com \ A estrutura SOCKADDR_IN especifica um endereço de transporte e uma porta para a família de endereços AF_INET.
\ Todos os dados na estrutura SOCKADDR_IN, exceto para a família de endereços (parâmetro sin*_family), devem ser especificados na ordem de byte da rede (big-endian).
\As funções do Winsock usando SOCKADDR não são estritamente interpretadas para serem ponteiros para uma estrutura sockaddr. 
\A estrutura é interpretada de forma diferente no contexto de famílias de endereços diferentes. 
Um wyrd denominado sin_family, \A família de endereços para o endereço de transporte. Este membro deve sempre ser definido como AF_INET.
Um big-endian unsigned wyrd denominado sin_port, \ Um número de porta de protocolo de transporte.
Um in_addr denominado sin_addr, \ Uma estrutura IN_ADDR que contém um endereço de transporte IPv4.
8 pedaços denominado sin_zero. \ Reservado para uso do sistema. Um aplicativo WSK deve definir o conteúdo desse array como zero.

Um sockaddrptr é um endereço de memória para um sockaddr.

Um socket é um endereço de memória.

Etapas necessárias para que se classifique algum tipo de rows selecionadas em um text:
Se o text for inexistente, cancele.
Split a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
Classifique o rows selecionadas.
Posponha a rows para as rows deste text.
Posponha o rows selecionadas para as rows deste text.
Posponha a segunda rows para as rows deste text.
Renumber as rows deste text.

Etapas necessárias para que se classifique uns rows:
Se o first destas rows for o last destas rows, cancele.
Split a rows a uns left rows e umas right rows.
Classifique as left rows.
Classifique as right rows.
Percorra.
Atribua o first destas left rows a uma left row.
Atribua o first destas right rows a uma right row.
Se a left row for inexistente, posponha as right rows para as rows; exit.
Se a right row for inexistente, posponha as left rows para as rows; exit.
Se o string desta left row for maior do que o string desta right row, mova a right row from as right rows para as rows; repita.
Mova a left row from as left rows para as rows.
Repita.

Etapas necessárias para que se space between caracteres:
Vire right.
Mova 3 squares.
Vire left.

O texto de espaço é um string igual a " ".

Etapas necessárias para que se split um trecho para uns dyads:
Destrua o dyads.
Se o trecho estiver em branco, cancele.
Lance um percorredor sobre o trecho.
Percorra.
Mova o percorredor usando o & comercial.
Se o vocábulo deste percorredor estiver em branco, cancele.
Crie um dyad.
Posponha o dyad para o dyads.
Split o vocábulo deste percorredor a um nome subtexto e um query subtexto usando o sinal de igualdade.
Atribua o nome subtexto ao nome deste dyad.
Converta o query subtexto como um query string ao value deste dyad.
Repita.

Etapas necessárias para que se split um pedaço para uma cifra binária e uma segunda cifra binária:
Atribua o pedaço à cifra binária.
Shift a cifra binária right 4 bits.
Atribua o pedaço ao segunda cifra binária.
Conjuncione logicamente a segunda cifra binária com 15.

Etapas necessárias para que se split um line para uma segunda line e um terceiro line:
Isole o line.
Atribua o center desta line a um center spot.
Atribua o start desta line e o center ao segunda line.
Atribua o center e o end desta line ao terceiro line.

Etapas necessárias para que se split um número para um wyrd e uma segunda wyrd:
Isole o número.
Shift o número right 16 bits.
Atribua o número ao wyrd.
Atribua o original número ao segunda wyrd.

Etapas necessárias para que se split a rows of um text para uns rows e uns rows selecionadas e uns segunda rows:
Se o text for inexistente, limpe as rows; limpe o rows selecionadas; limpe as segunda rows; exit.
Percorra.
Atribua o first destas rows deste text a uma row.
Se a row for inexistente, cancele.
Remove a row from as rows deste text.
Se a row of o text estiver selecionado, acione um detector; posponha a row para o rows selecionadas; repita.
Se o detector estiver ativo, posponha a row para a segunda rows; repita.
Posponha a row para a rows.
Repita.

Etapas necessárias para que se split um string para um left subtexto e um right subtexto usando um separator pedaço:
Limpe o left.
Limpe o right.
Se o string estiver em branco, cancele.
Atribua o first deste string ao first desse subtexto.
Atribua o first deste subtexto menos 1 ao last deste subtexto.
Percorra.
Se o last deste subtexto for maior do que o last deste string, cancele.
Adicione 1 para o last deste subtexto.
Se o target deste last deste subtexto for o separator pedaço, pare.
Repita.
Atribua o first deste subtexto ao first deste left.
Atribua o last deste subtexto menos 1 ao last deste left.
Atribua o last deste subtexto mais 1 ao first deste right.
Atribua o last deste string ao last deste right.

Etapas necessárias para que se split um string para uns conjunto de textos usando um separator pedaço:
Destrua o conjunto de textos.
Se o string estiver em branco, cancele.
Lance um percorredor sobre o string.
Percorra.
Mova o percorredor usando o separator pedaço.
Adicione o vocábulo deste percorredor para o conjunto de textos.
Se o source deste percorredor estiver em branco, pare.
Repita.
Se o target deste last deste string não for o separator pedaço, cancele.
Adicione "" para o conjunto de textos.

Etapas necessárias para que se split uns coisas para uns left coisas e uns right coisas:
Se  as coisas estiverem vazio, limpe o left coisas; limpe o right coisas; exit.
Atribua a contagem destas coisas dividido por 2 a uma contagem.
Percorra.
Obtenha uma coisa from as coisas.
Se a contagem for 0, pare.
Subtraia 1 from a contagem.
Repita.
Split  as coisas ao left coisas e o right coisas at o coisa.

Etapas necessárias para que se split uns coisas para uns left coisas e uns right coisas at um coisa:
Limpe o left coisas.
Limpe o right coisas.
Se a coisa for inexistente, permute  as coisas com o left coisas; exit.
Se o previous desta coisa for inexistente, permute  as coisas com o left coisas; exit.
\ abra para cima o left chain
Atribua o first destas coisas ao first destas left coisas.
Atribua o previous desta coisa ao last destas left coisas.
Esvazie o next deste previous desta coisa.
\ abra para cima o right chain
Atribua a coisa ao first destas right coisas.
Esvazie o previous desta coisa.
Atribua o last destas coisas ao last destas right coisas.
\ fix o original chain
Limpe as coisas.

Etapas necessárias para que se split um wyrd para um pedaço e uma segunda pedaço:
Isole o wyrd.
Shift o wyrd right 8 bits.
Atribua o wyrd ao pedaço.
Atribua o original wyrd ao segunda pedaço.

Um spot é um pair com uma coordenada x e uma coordenada y e um left at a coordenada x e um topo at a coordenada y.

Um spot endereço de memória é um endereço de memória para um spot.

Um square é 1440 units. \ número alto para facilitar as divisões. Podia ser qualquer número

Um square root é um número.

O square size é uns twips.

Etapas necessárias para que se square para cima algum tipo de seleção em um text:
Se o text for inexistente, cancele.
Se nada estiver selecionado no text, cancele.
Normalize a seleção deste text.
Obtenha uma row usando o número de linhas do cursor deste text e o text.
Atribua 1 ao anchor column# deste text.
Se o caret column# deste text não for 1, adicione 1 para o número de linhas do cursor deste text; atribua 1 ao caret column# deste text.
Se o número de linhas do cursor deste text for menor do que ou igual à contagem de linhas deste text, cancele.
Atribua a contagem de linhas deste text ao número da linha deste caret deste text.
Atribua o quantidade de caracteres deste string desta row ao column# deste caret deste text.

\A raiz de dois é uma fração igual a 99/70.
A raiz de dois é uma fração igual a 1414213562/1000000000.
A raiz de três é uma fração igual a 1732050807/1000000000.
\A raiz de cinco é uma fração igual a 161/72.
A raiz de cinco é uma fração igual a 2236067977/1000000000.
A raiz de seis é uma fração igual a 2449489742/1000000000.
A raiz de sete é uma fração igual a 2645751311/1000000000.
A raiz de oito é uma fração igual a 2828427124/1000000000.
A raiz de dez é uma fração igual a 3162277660/1000000000.
A raiz de onze é uma fração igual a 3316624790/1000000000.
\2147483647
\O número pi é uma fração igual a 355/113. \número pi
O número pi é uma fração igual a 3141592653/1000000000.
O número de Euler é uma fração igual a 271828182846/1000000000.
O número neperiano é uma fração igual a 271828182846/1000000000.
A proporção dourada é uma fração igual a 1618033988/1000000000.

An stack entry é uma coisa com um string.

O stack é uns stack entries.

Etapas necessárias para que se start anywhere em uma caixa:
Escolha aleatoriamente o spot deste context na caixa.

Etapas necessárias para que se start anywhere sobre um horizontal line:
Escolha aleatoriamente um spot sobre o horizontal line.
Atribua o spot ao spot deste context.

Etapas necessárias para que se start at o base left corner of uma caixa facing east:
Atribua o canto inferior esquerdo desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start at o base left corner of uma caixa facing north:
Atribua o canto inferior esquerdo desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start at o base left corner of uma caixa facing south:
Atribua o canto inferior esquerdo desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start at o base left corner of uma caixa facing west:
Atribua o canto inferior esquerdo desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start at o base of um horizontal line:
Atribua o end desta vertical line ao spot deste context.

Etapas necessárias para que se start at o base right corner of uma caixa facing east:
Atribua o canto inferior direito desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start at o base right corner of uma caixa facing north:
Atribua o canto inferior direito desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start at o base right corner of uma caixa facing south:
Atribua o canto inferior direito desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start at o base right corner of uma caixa facing west:
Atribua o canto inferior direito desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start at o left of um horizontal line:
Atribua o start desta horizontal line ao spot deste context.

Etapas necessárias para que se start at o middle of o base of uma caixa;
Etapas necessárias para que se start no middle of o base of uma caixa;
Etapas necessárias para que se start at o center of o base of uma caixa;
Etapas necessárias para que se start no center of o base of uma caixa:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada inferior desta caixa aa coordenada y deste spot deste context.

Etapas necessárias para que se start at o middle of o base of uma caixa facing east;
Etapas necessárias para que se start no middle of o base of uma caixa facing east;
Etapas necessárias para que se start at o center of o base of uma caixa facing east;
Etapas necessárias para que se start no center of o base of uma caixa facing east:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada inferior desta caixa aa coordenada y deste spot deste context.
Face east.

Etapas necessárias para que se start at o middle of o base of uma caixa facing north;
Etapas necessárias para que se start no middle of o base of uma caixa facing north;
Etapas necessárias para que se start at o center of o base of uma caixa facing north;
Etapas necessárias para que se start no center of o base of uma caixa facing north:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada inferior desta caixa aa coordenada y deste spot deste context.
Face north.

Etapas necessárias para que se start at o middle of o base of uma caixa facing south;
Etapas necessárias para que se start no middle of o base of uma caixa facing south;
Etapas necessárias para que se start at o center of o base of uma caixa facing south;
Etapas necessárias para que se start no center of o base of uma caixa facing south:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada inferior desta caixa aa coordenada y deste spot deste context.
Face south.

Etapas necessárias para que se start at o middle of o base of uma caixa facing west;
Etapas necessárias para que se start no middle of o base of uma caixa facing west;
Etapas necessárias para que se start at o center of o base of uma caixa facing west;
Etapas necessárias para que se start no center of o base of uma caixa facing west:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada inferior desta caixa aa coordenada y deste spot deste context.
Face west.

Etapas necessárias para que se start at o middle of o left of uma caixa facing east;
Etapas necessárias para que se start no middle of o left of uma caixa facing east;
Etapas necessárias para que se start at o center of o left of uma caixa facing east;
Etapas necessárias para que se start no center of o left of uma caixa facing east:
Atribua a coordenada esquerda desta caixa aa coordenada x deste spot deste context.
Atribua o y deste center desta caixa aa coordenada y deste spot deste context.
Face east.

Etapas necessárias para que se start at o middle of o left of uma caixa facing north;
Etapas necessárias para que se start no middle of o left of uma caixa facing north;
Etapas necessárias para que se start at o center of o left of uma caixa facing north;
Etapas necessárias para que se start no center of o left of uma caixa facing north:
Atribua a coordenada esquerda desta caixa aa coordenada x deste spot deste context.
Atribua o y deste center desta caixa aa coordenada y deste spot deste context.
Face north.

Etapas necessárias para que se start at o middle of o left of uma caixa facing south;
Etapas necessárias para que se start no middle of o left of uma caixa facing south;
Etapas necessárias para que se start at o center of o left of uma caixa facing south;
Etapas necessárias para que se start no center of o left of uma caixa facing south:
Atribua a coordenada esquerda desta caixa aa coordenada x deste spot deste context.
Atribua o y deste center desta caixa aa coordenada y deste spot deste context.
Face south.

Etapas necessárias para que se start at o middle of o left of uma caixa facing west;
Etapas necessárias para que se start no middle of o left of uma caixa facing west;
Etapas necessárias para que se start at o center of o left of uma caixa facing west;
Etapas necessárias para que se start no center of o left of uma caixa facing west:
Atribua a coordenada esquerda desta caixa aa coordenada x deste spot deste context.
Atribua o y deste center desta caixa aa coordenada y deste spot deste context.
Face west.

Etapas necessárias para que se start at o middle of o right of uma caixa facing east;
Etapas necessárias para que se start no middle of o right of uma caixa facing east;
Etapas necessárias para que se start at o center of o right of uma caixa facing east;
Etapas necessárias para que se start no center of o right of uma caixa facing east:
Atribua a coordenada direita desta caixa aa coordenada x deste spot deste context.
Atribua o y deste center desta caixa aa coordenada y deste spot deste context.
Face east.

Etapas necessárias para que se start at o middle of o right of uma caixa facing north;
Etapas necessárias para que se start no middle of o right of uma caixa facing north;
Etapas necessárias para que se start at o center of o right of uma caixa facing north;
Etapas necessárias para que se start no center of o right of uma caixa facing north:
Atribua a coordenada direita desta caixa aa coordenada x deste spot deste context.
Atribua o y deste center desta caixa aa coordenada y deste spot deste context.
Face north.

Etapas necessárias para que se start at o middle of o right of uma caixa facing south;
Etapas necessárias para que se start no middle of o right of uma caixa facing south;
Etapas necessárias para que se start at o center of o right of uma caixa facing south;
Etapas necessárias para que se start no center of o right of uma caixa facing south:
Atribua a coordenada direita desta caixa aa coordenada x deste spot deste context.
Atribua o y deste center desta caixa aa coordenada y deste spot deste context.
Face south.

Etapas necessárias para que se start at o middle of o right of uma caixa facing west;
Etapas necessárias para que se start no middle of o right of uma caixa facing west;
Etapas necessárias para que se start at o center of o right of uma caixa facing west;
Etapas necessárias para que se start no center of o right of uma caixa facing west:
Atribua a coordenada direita desta caixa aa coordenada x deste spot deste context.
Atribua o y deste center desta caixa aa coordenada y deste spot deste context.
Face west.

Etapas necessárias para que se start at o middle of o topo of uma caixa;
Etapas necessárias para que se start no middle of o topo of uma caixa;
Etapas necessárias para que se start at o center of o topo of uma caixa;
Etapas necessárias para que se start no center of o topo of uma caixa:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada superior desta caixa aa coordenada y deste spot deste context.

Etapas necessárias para que se start at o middle of o topo of uma caixa facing east;
Etapas necessárias para que se start no middle of o topo of uma caixa facing east;
Etapas necessárias para que se start at o center of o topo of uma caixa facing east;
Etapas necessárias para que se start no center of o topo of uma caixa facing east:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada superior desta caixa aa coordenada y deste spot deste context.
Face east.

Etapas necessárias para que se start at o middle of o topo of uma caixa facing north;
Etapas necessárias para que se start no middle of o topo of uma caixa facing north;
Etapas necessárias para que se start at o center of o topo of uma caixa facing north;
Etapas necessárias para que se start no center of o topo of uma caixa facing north:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada superior desta caixa aa coordenada y deste spot deste context.
Face north.

Etapas necessárias para que se start at o middle of o topo of uma caixa facing south;
Etapas necessárias para que se start no middle of o topo of uma caixa facing south;
Etapas necessárias para que se start at o center of o topo of uma caixa facing south;
Etapas necessárias para que se start no center of o topo of uma caixa facing south:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada superior desta caixa aa coordenada y deste spot deste context.
Face south.

Etapas necessárias para que se start at o middle of o topo of uma caixa facing west;
Etapas necessárias para que se start no middle of o topo of uma caixa facing west;
Etapas necessárias para que se start at o center of o topo of uma caixa facing west;
Etapas necessárias para que se start no center of o topo of uma caixa facing west:
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada superior desta caixa aa coordenada y deste spot deste context.
Face west.

Etapas necessárias para que se start at o right of um horizontal line:
Atribua o end desta horizontal line ao spot deste context.

Etapas necessárias para que se start at um spot:
Atribua o spot ao spot deste context.

Etapas necessárias para que se start at um spot facing east:
Atribua o spot ao spot deste context.
Face east.

Etapas necessárias para que se start at um spot facing north:
Atribua o spot ao spot deste context.
Face north.

Etapas necessárias para que se start at um spot facing south:
Atribua o spot ao spot deste context.
Face south.

Etapas necessárias para que se start at um spot facing west:
Atribua o spot ao spot deste context.
Face west.

Etapas necessárias para que se start at o topo left corner of uma caixa facing east:
Atribua o canto superior esquerdo desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start at o topo left corner of uma caixa facing north:
Atribua o canto superior esquerdo desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start at o topo left corner of uma caixa facing south:
Atribua o canto superior esquerdo desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start at o topo left corner of uma caixa facing west:
Atribua o canto superior esquerdo desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start at o topo of um vertical line:
Atribua o start desta vertical line ao spot deste context.

Etapas necessárias para que se start at o topo right corner of uma caixa facing east:
Atribua o canto superior direito desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start at o topo right corner of uma caixa facing north:
Atribua o canto superior direito desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start at o topo right corner of uma caixa facing south:
Atribua o canto superior direito desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start at o topo right corner of uma caixa facing west:
Atribua o canto superior direito desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start no middle of uma caixa facing east;
Etapas necessárias para que se start at o middle of uma caixa facing east;
Etapas necessárias para que se mova para o middle of uma caixa facing east;
Etapas necessárias para que se mova para o middle of uma caixa e face east;
Etapas necessárias para que se start no center of uma caixa facing east;
Etapas necessárias para que se start at o center of uma caixa facing east;
Etapas necessárias para que se mova para o center of uma caixa facing east;
Etapas necessárias para que se mova para o center of uma caixa e face east:
Atribua o center desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start no middle of uma caixa facing north;
Etapas necessárias para que se start at o middle of uma caixa facing north;
Etapas necessárias para que se mova para o middle of uma caixa facing north;
Etapas necessárias para que se mova para o middle of uma caixa e face north;
Etapas necessárias para que se start no center of uma caixa facing north;
Etapas necessárias para que se start at o center of uma caixa facing north;
Etapas necessárias para que se mova para o center of uma caixa facing north;
Etapas necessárias para que se mova para o center of uma caixa e face north:
Atribua o center desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start no middle of uma caixa facing north menos uns points;
Etapas necessárias para que se start no center of uma caixa facing north menos uns points:
Atribua o center desta caixa ao spot deste context.
Face north.
Vire left o points.

Etapas necessárias para que se start no middle of uma caixa facing south;
Etapas necessárias para que se start at o middle of uma caixa facing south;
Etapas necessárias para que se mova para o middle of uma caixa facing south;
Etapas necessárias para que se mova para o middle of uma caixa e face south;
Etapas necessárias para que se start no center of uma caixa facing south;
Etapas necessárias para que se start at o center of uma caixa facing south;
Etapas necessárias para que se mova para o center of uma caixa facing south;
Etapas necessárias para que se mova para o center of uma caixa e face south:
Atribua o center desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start no middle of uma caixa facing west;
Etapas necessárias para que se start at o middle of uma caixa facing west;
Etapas necessárias para que se mova para o middle of uma caixa facing west;
Etapas necessárias para que se mova para o middle of uma caixa e face west;
Etapas necessárias para que se start no center of uma caixa facing west;
Etapas necessárias para que se start at o center of uma caixa facing west;
Etapas necessárias para que se mova para o center of uma caixa facing west;
Etapas necessárias para que se mova para o center of uma caixa e face west:
Atribua o center desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start um process usando um endereço completo:
\ must ser denominado com um global variável
Limpe o erro do fluxo de entrada/saída.
Se o process não for 0, atribua "Erro. Este processo já está sendo executado." ao erro do fluxo de entrada/saída; exit.
Atribua a magnitude dessa startupinfo ao cb desta startupinfo.
Extraia um endereço da pasta from o endereço completo.
Modifique através do caractere NUL o endereço da pasta.
Isole o endereço completo. modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "CreateProcessA" com o first deste endereço completo e 0 e 0 e 0 e 0 e 67108904 [create_default_error_mode + normal_priority_class + detached_process] e 0 
And o first deste endereço da pasta e o endereçamento desta startupinfo e um processinfo's endereçamento devolvendo um número.
Se o número for 0, atribua "Erro. Não foi possível executar o programa." ao erro do fluxo de entrada/saída; exit.
Atribua o hprocess deste processinfo ao process.
Call "kernel32.dll" "CloseHandle" com o hthread deste processinfo.
Point um endereço de memória para rotina aguarde por um process endereço de memória.
Call "kernel32.dll" "CreateThread" com 0 e 0 e o endereço de memória e o endereçamento deste process e 0 e uma segunda número's endereçamento devolvendo um número identificador.
Call "kernel32.dll" "CloseHandle" com o número identificador. \ does not end o thread, just dumps o handle

Etapas necessárias para que se start um temporizador:
Reset o temporizador.
Restart o temporizador.

Etapas necessárias para que se start uns twips above o middle of o base of uma caixa:
\ incomplete abra of these
Atribua o x deste center desta caixa aa coordenada x deste spot deste context.
Atribua a coordenada inferior desta caixa menos os twips aa coordenada y deste spot deste context.

Etapas necessárias para que se start uns twips para baixo from um spot;
Etapas necessárias para que se start uns twips below um spot:
Atribua a coordenada x deste spot ao x deste context.
Atribua a coordenada y deste spot mais os twips ao y deste context.

Etapas necessárias para que se start uns twips from o center of uma caixa:
Atribua o center desta caixa ao spot deste context.
Mova os twips.

Etapas necessárias para que se start uns twips para o left e uns segunda twips para baixo from um spot;
Etapas necessárias para que se start uns twips left e uns segunda twips para baixo from um spot:
Atribua a coordenada x deste spot menos os twips ao x deste context.
Atribua a coordenada y deste spot mais a segunda twips ao y deste context.

Etapas necessárias para que se start uns twips left e uns segunda twips para cima from um spot:
Atribua a coordenada x deste spot menos os twips ao x deste context.
Atribua a coordenada y deste spot menos a segunda twips ao y deste context.

Etapas necessárias para que se start uns twips para o left e uns segunda twips para cima from um spot;
Etapas necessárias para que se start uns twips para o left of um spot;
Etapas necessárias para que se start uns twips left of um spot:
Atribua a coordenada x deste spot menos os twips ao x deste context.

Etapas necessárias para que se start uns twips para o right e uns segunda twips para baixo from um spot;
Etapas necessárias para que se start uns twips right e uns segunda twips para baixo from um spot:
Atribua a coordenada x deste spot mais os twips ao x deste context.
Atribua a coordenada y deste spot mais a segunda twips ao y deste context.

Etapas necessárias para que se start uns twips para o right e uns segunda twips para cima from um spot;
Etapas necessárias para que se start uns twips right e uns segunda twips para cima from um spot:
Atribua a coordenada x deste spot mais os twips ao x deste context.
Atribua a coordenada y deste spot menos a segunda twips ao y deste context.

Etapas necessárias para que se start uns twips para cima from uma coordenada:
Atribua a coordenada menos os twips ao y deste context.

Etapas necessárias para que se start uns twips para cima from um spot;
Etapas necessárias para que se start uns twips above um spot:
Atribua a coordenada y deste spot ao y deste context.
Subtraia os twips from a coordenada y deste context.

Etapas necessárias para que se carregue as biliotecas padrão do sistema;
Etapas necessárias para que se start para cima:
inicialize o Component Object Model.
Inicialize winsock.
Inicialize gdi+.
Inicialize o talker.
Inicialize o module.
Inicialize as cors.
Inicialize o tela.
Inicialize a window.
Inicialize as fonts.
Inicialize os cursors.
Inicialize o mouse.
Inicialize os canvases.
Inicialize o context.
Initalize o terminal.
Crie o console.

\Passos necessários para a execução do programa:
\inicialize o Component Object Model.
\Inicialize winsock.
\Inicialize gdi+.
\Inicialize o talker.
\Inicialize o module.
\Inicialize a cors.
\Inicialize o tela.
\Inicialize o window.
\Inicialize o fonts.
\Inicialize o cursors.
\Inicialize o mouse.
\Inicialize o canvases.
\Inicialize o context.
\Initalize o terminal.
\Crie o console.

Etapas necessárias para que se start para cima o cgi:
Inicialize winsock.
Inicialize o module.
Inicialize o cgi.

Etapas necessárias para que se start com uma cor:
Atribua a cor à cor deste context.

Etapas necessárias para que se start com nada em um endereço de memória:
Esvazie o endereço de memória.

Um startupinfo é um conjunto com \ falta documentar aqui
Um número denominado cb,
Um endereço de memória denominado lIsoled,
Um endereço de memória denominado lpdesktop,
Um endereço de memória denominado lptitle,
Um número denominado dwx,
Um número denominado dwy,
Um número denominado dwxsize,
Um número denominado dwysize,
Um número denominado dwxcountchars,
Um número denominado cwycountchars,
Um número denominado dwfillattribute,
Um número denominado dwflags,
Um wyrd denominado wshowwindow,
Um wyrd denominado cbreserved2,
Um endereço de memória denominado lIsoled2,
Um número identificador denominado hstdinput,
Um número identificador denominado hstdoutput,
Um número identificador denominado hstderror.

O número identificador do fluxo de entrada padrão é um número identificador.

O número identificador do fluxo de saída padrão é um número identificador.

Etapas necessárias para que se suspenda um process:
Se o process for 0, cancele.
Call "kernel32.dll" "TerminateProcess" com o process e 0.
Atribua 0 ao process.

Etapas necessárias para que se suspenda um temporizador:
Se a contagem deste temporizador for 0, cancele.
Subtraia 1 from a contagem deste temporizador.
Se a contagem deste temporizador não for 0, cancele.
Atribua a contagem de ticks do sistema a uns ticks.
Subtraia os start ticks deste temporizador from o ticks.
Adicione o ticks para os total ticks deste temporizador.

Um string é um conjunto com um first endereço de memória do pedaço e um last endereço de memória do pedaço .

An conjunto de texto é uma coisa com um string.

An string# é um número.

Etapas necessárias para que se pinte o turtle text grid:
\ this é denominado pelo temporary line no "Stoke a ___ caractere" rotina
Save o context. Atribua o grossura do pincel A an saved grossura do pincel. \ see REMARK below
Use o pincel cinza claro.
Atribua a tamanho da letra deste context dividido por 4 A an size.
Vire around. Mova o size. Vire around.
Pinte o turtle text grid caixa es.
Vire right. Mova o size. Vire left.
Pinte o turtle text grid caixa es.
Restore o context. Atribua o saved grossura do pincel ao grossura do pincel. \ see REMARK below
 
Etapas necessárias para que se pinte o turtle text grid caixa es:
\ this é denominado from a rotina above para pinte one column of grid caixa es
Atribua a tamanho da letra deste context dividido por 4 A an size.
Save o context.
Use o skinny pincel.
Percorra.
Pinte o size. Vire right.
Pinte o size. Vire right.
Pinte o size. Vire right.
Pinte o size. Vire right.
Mova o size.
Adicione 1 para an contagem. Se a contagem for menor do que 6, repita.
Restore o context.

Etapas necessárias para que se pinte o accent caractere:
Save o context.
Mova 4 squares.
Vire right.
Vire right 7/96 of o way.
Pinte 9/4 square.
Restore o context.

Etapas necessárias para que se pinte o asterisk caractere:
Save o context.
Mova 2 squares.
Vire right.
Pinte 2 squares.
Vire left.
Mova 1 square.
Vire left.
Mova 1 square.
Vire left.
Pinte 2 squares.
Reset o context.
Mova 1 square.
Vire right 1/8.
Pinte 2 squares slantways.
Reset o context.
Mova 3 squares.
Vire right 3/8.
Pinte 2 squares slantways.
Restore o context.

Etapas necessárias para que se pinte o sinal de arroba caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 3/8.
Pinte 1/2 square slantways.
Vire left.
Pinte 1/2 square slantways.
Vire left.
Pinte 1/2 square slantways.
Vire left.
Pinte 1/2 square slantways.
Restore o context.

Etapas necessárias para que se pinte a barra invertida caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Vire left 7/96 of o way.
Pinte 9/2 square.
Restore o context.

Etapas necessárias para que se pinte o big-a caractere:
Save o context.
Pinte 2-2/3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-a-acute caractere:
Save o context.
Pinte 2-2/3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/16 squares.
Vire right.
Mova 1-14/16 square.
Vire left.
Vire right 4/32.
Pinte 1 square menos 1/2 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-a-circumflex caractere:
Save o context.
Pinte 2-2/3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/16 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-a-diaeresis caractere:
Save o context.
Pinte 2-2/3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/3 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-a-grave caractere:
Save o context.
Pinte 2-2/3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-2/8 squares.
Vire right.
Mova 1/100 square.
\Vire left.
Vire right 4/32.
Pinte 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-a-tilde caractere:
Save o context.
Pinte 2-2/3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 1/6 square. Vire left.
Vire right 1/8.
Pinte 9/16 square.
Vire right 3/16.
Pinte 1 square.
Vire left 3/16.
Pinte 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-b caractere:
Save o context.
Pinte 3-6/8 squares.
Vire right.
Pinte 1 square.
Vire right 1/10.
Pinte 3/4 square slantways.
Vire right.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire right.
Vire right 1/100.
Pinte 1 square slantways.
Vire left 85/100. Pinte 1-1/3 squares.
Restore o context. Save o context.
Mova 2 squares. Vire right. Pinte 1-1/4 squares.
Restore o context.

Etapas necessárias para que se pinte o big-c caractere:
Save o context.
Mova 1-3/4 squares.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Reset o context.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o Ç maiúsculo caractere:
Save o context.
Mova 1-3/4 squares.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Reset o context.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
\ start cedilla mark
Restore o context. Save o context.
Vire right.
Mova 1 square.
Vire right.
Pinte 1/2 square.
Vire left.
Pinte 1/2 square.
Vire right.
Pinte 1/2 square.
Vire right.
Pinte 1/2 square.
\ end cedilla mark
Restore o context.

Etapas necessárias para que se pinte o big-d caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-1/2 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o big-e caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Pinte 1 square.
Reset o context.
Vire right.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-e-acute caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Pinte 1 square.
Reset o context.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1-1/2 square.
Vire left.
Vire right 4/32.
Pinte 1 square menos 1/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-e-circumflex caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Pinte 1 square.
Reset o context.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-e-diaeresis caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Pinte 1 square.
Reset o context.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/3 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-e-grave caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Pinte 1 square.
Reset o context.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 49/100 square.
\Vire left.
Vire right 4/32.
Pinte 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-e-tilde caractere:
Save o context.
Pinte 4 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 2 squares.
Vire right.
Pinte 1 square.
Reset o context.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right 1/8.
Pinte 9/16 square.
Vire right 3/16.
Pinte 1 square.
Vire left 3/16.
Pinte 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-f caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 2 squares.
Vire right.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o big-g caractere:
Save o context.
Mova 1-7/8 squares.
Pinte 7/8 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Reset o context.
Mova 1-6/8 squares.
Vire around.
Pinte 7/8 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 7/8 square.
Vire left.
Pinte 7/8 square.
Vire left.
Pinte 1/32 square.
Restore o context.

Etapas necessárias para que se pinte o big-h caractere:
Save o context.
Pinte 3-1/2 squares.
Reset o context.
Mova 1-80/100 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 3-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-i caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 3-1/2 squares.
Reset o context.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-i-acute caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 3-1/2 squares.
Reset o context.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1 square.
Vire left.
Vire right 4/32.
Pinte 1 square menos 1/2 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-i-circumflex caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 3-1/2 squares.
Reset o context.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-i-diaeresis caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 3-1/2 squares.
Reset o context.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/3 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-i-grave caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 3-1/2 squares.
Reset o context.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 68/100 square.
\Vire left.
Vire right 4/32.
Pinte 1 square menos 3/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-j caractere:
Save o context.
Mova 1-7/8 squares.
Vire around.
Pinte 6/8 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 2-5/8 squares.
Restore o context.

Etapas necessárias para que se pinte o big-k caractere:
Save o context.
Pinte 3-3/4 squares.
Vire around.
Mova 1-3/4 squares.
Vire left.
Pinte 1 square.
Save o context.
Vire left 1/8.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 3/4 square.
Restore o context.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o big-l caractere:
Save o context.
Mova 3-5/8 squares.
Vire around.
Pinte 3-5/8 squares.
Vire left.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-m caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right 41/96.
Pinte 9/4 square.
Vire right 62/96.
Pinte 9/4 square.
Vire right 41/96.
Pinte 3-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-n caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right 41/96.
Pinte 8/2 square.
Vire left 41/96.
Pinte 3-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-n-tilde caractere:
Save o context.
Pinte 3-1/2 squares.
Vire right 41/96.
Pinte 8/2 square.
Vire left 41/96.
Pinte 3-1/2 squares.
Restore o context.
\ start accent mark
Restore o context. Save o context.
Mova 4 squares.
Vire right 1/8.
Pinte 9/16 square.
Vire right 3/16.
Pinte 1 square.
Vire left 3/16.
Pinte 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-o caractere:
Save o context.
Mova 1 square.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o big-o-acute caractere:
Save o context.
Mova 1 square.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right.
Mova 1-14/16 square.
Vire left.
Vire right 4/32.
Pinte 1 square menos 1/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-o-circumflex caractere:
Save o context.
Mova 1 square.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-o-diaeresis caractere:
Save o context.
Mova 1 square.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/3 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-o-grave caractere:
Save o context.
Mova 1 square.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
\Mova 5/100 square.
\Vire left.
Vire right 4/32.
Pinte 1 square menos 3/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-o-tilde caractere:
Save o context.
Mova 1 square.
Pinte 2 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right. Mova 1/8 square. Vire left.
Vire right 1/8.
Pinte 9/16 square.
Vire right 3/16.
Pinte 1 square.
Vire left 3/16.
Pinte 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-p caractere:
Save o context.
Pinte 3-4/8 squares.
Vire right.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o big-q caractere:
Save o context.
Mova 1 square.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-6/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Reset o context.
Mova 1 square.
Vire right.
Mova 1 square.
Vire right 1/8 of o way.
Pinte 1-1/2 square.
Restore o context.

Etapas necessárias para que se pinte o big-r caractere:
Save o context.
Pinte 3-4/8 squares.
Vire right.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire left 1/8.
Vire left 7/96.
Pinte 3/2 square.
Restore o context.

Etapas necessárias para que se pinte o big-s caractere:
Save o context.
Mova 7/8 square.
Vire around.
Vire left 1/8.
Pinte 7/8 square slantways.
Vire left.
Pinte 7/8 square slantways.
Vire left.
Pinte 2 squares slantways.
Vire right.
Pinte 7/8 square slantways.
Vire right.
Pinte 7/8 square slantways.
Restore o context.

Etapas necessárias para que se pinte o big-t caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 3-4/8 squares.
Vire left.
Mova 1 square.
Vire around.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-u caractere:
Save o context.
Mova 3-1/2 squares.
Vire around.
Pinte 3-1/2 squares.
Vire left.
Pinte 2 squares.
Vire left.
Pinte 3-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-u-acute caractere:
Save o context.
Mova 3-1/2 squares.
Vire around.
Pinte 3-1/2 squares.
Vire left.
Pinte 2 squares.
Vire left.
Pinte 3-1/2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/5 squares.
Vire right.
Mova 1 square.
Vire left.
Vire right 4/32.
Pinte 1 square menos 1/2 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-u-circumflex caractere:
Save o context.
Mova 3-1/2 squares.
Vire around.
Pinte 3-1/2 squares.
Vire left.
Pinte 2 squares.
Vire left.
Pinte 3-1/2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 1/8 squares. Vire left.
Vire right. Mova 1/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-u-diaeresis caractere:
Save o context.
Mova 3-1/2 squares.
Vire around.
Pinte 3-1/2 squares.
Vire left.
Pinte 2 squares.
Vire left.
Pinte 3-1/2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/2 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-u-grave caractere:
Save o context.
Mova 3-1/2 squares.
Vire around.
Pinte 3-1/2 squares.
Vire left.
Pinte 2 squares.
Vire left.
Pinte 3-1/2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 50/100 square.
\Vire left.
Vire right 4/32.
Pinte 1 square menos 1/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-v caractere:
Save o context.
Mova 3-1/2 squares.
Vire around.
Pinte 2-1/2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 2-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-w caractere:
Save o context.
Mova 3-1/2 squares.
Vire around.
Pinte 3-1/2 squares.
Vire left 41/96.
Pinte 9/4 square.
Vire left 61/96.
Pinte 9/4 square.
Restore o context. Save o context.
Vire right.
Mova 2 squares.
Vire left 2/3 squares.
Pinte 3-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o big-x caractere:
Save o context.
Pinte 6/8 square.
Vire right 1/8.
Pinte 2 squares slantways.
Vire left 1/8.
Pinte 6/8 square.
Reset o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 6/8 square.
Vire left 1/8.
Pinte 2 squares slantways.
Vire right 1/8.
Pinte 6/8 square.
Restore o context.

Etapas necessárias para que se pinte o big-y caractere:
Save o context.
Mova 3-5/8 squares.
Vire around.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Reset o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 1-5/8 squares.
Restore o context.

Etapas necessárias para que se pinte o big-y-acute caractere:
Save o context.
Mova 3-5/8 squares.
Vire around.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Reset o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 1-5/8 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4 squares.
Vire right.
Mova 1 square.
Vire left.
Vire right 4/32.
Pinte 1 square menos 1/2 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o big-z caractere:
Save o context.
Mova 3-5/8 squares.
Vire right.
Pinte 2 squares.
Vire right.
Pinte 5/8 square.
Vire right 1/8.
Pinte 2 squares slantways.
Vire left 1/8.
Pinte 5/8 square.
Vire left.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte uma caixa com uma cor:
Atribua a cor à cor deste context.
Atribua o canto inferior esquerdo desta caixa ao spot deste context.
Face north.
Pinte a altura desta caixa.
Vire right.
Pinte a largura desta caixa.
Vire right.
Pinte a altura desta caixa.
Vire right.
Pinte a largura desta caixa.

Etapas necessárias para que se pinte um pedaço:
\\ Essa rotina aqui "DESENHA" uma letra.
Atribua a tamanho da letra deste context dividido por 4 ao square size. \ ***
\Pinte o turtle text grid. \ for testing -- adicione me now, delete me later -- see below
\LETRAS MAIÚSCULAS
Se o pedaço for o acento grave, pinte o accent caractere.
Se o pedaço for o asterisco, pinte o asterisk caractere.
Se o pedaço for o sinal de arroba, pinte o sinal de arroba caractere.
Se o pedaço for a barra invertida, pinte a barra invertida caractere.
Se o pedaço for o 'A' maiúsculo, pinte o big-a caractere.
Se o pedaço for o Á maiúsculo, pinte o big-a-acute caractere. \ *** new line
Se o pedaço for o Â maiúsculo, pinte o big-a-circumflex caractere. \ *** new line
Se o pedaço for o Ä maiúsculo, pinte o big-a-diaeresis caractere. \ *** new line
Se o pedaço for o 'À' maiúsculo, pinte o big-a-grave caractere. \ *** new line
Se o pedaço for o Ã maiúsculo, pinte o big-a-tilde caractere. \ *** new line
Se o pedaço for o B maiúsculo, pinte o big-b caractere.
Se o pedaço for o C maiúsculo, pinte o big-c caractere.
Se o pedaço for o Ç maiúsculo, pinte o Ç maiúsculo caractere.
Se o pedaço for o D maiúsculo, pinte o big-d caractere.
Se o pedaço for o 'E' maiúsculo, pinte o big-e caractere.
Se o pedaço for o 'É' maiúsculo, pinte o big-e-acute caractere. \ *** new line
Se o pedaço for o Ê maiúsculo, pinte o big-e-circumflex caractere. \ *** new line
Se o pedaço for o Ë maiúsculo, pinte o big-e-diaeresis caractere. \ *** new line
Se o pedaço for o È maiúsculo, pinte o big-e-grave caractere. \ *** new line
Se o pedaço for o F maiúsculo, pinte o big-f caractere.
Se o pedaço for o G maiúsculo, pinte o big-g caractere.
Se o pedaço for o H maiúsculo, pinte o big-h caractere.
Se o pedaço for o I maiúsculo, pinte o big-i caractere.
Se o pedaço for o Í maiúsculo, pinte o big-i-acute caractere. \ *** new line
Se o pedaço for o Î maiúsculo, pinte o big-i-circumflex caractere. \ *** new line
Se o pedaço for o Ï maiúsculo, pinte o big-i-diaeresis caractere. \ *** new line
Se o pedaço for o Ì maiúsculo, pinte o big-i-grave caractere. \ *** new line
Se o pedaço for o J maiúsculo, pinte o big-j caractere.
Se o pedaço for o K maiúsculo, pinte o big-k caractere.
Se o pedaço for o L maiúsculo, pinte o big-l caractere.
Se o pedaço for o M maiúsculo, pinte o big-m caractere.
Se o pedaço for o N maiúsculo, pinte o big-n caractere.
Se o pedaço for o Ñ maiúsculo, pinte o big-n-tilde caractere.
Se o pedaço for o 'O' maiúsculo, pinte o big-o caractere.
Se o pedaço for o Ó maiúsculo, pinte o big-o-acute caractere. \ *** new line
Se o pedaço for o Ô maiúsculo, pinte o big-o-circumflex caractere. \ *** new line
Se o pedaço for o Ö maiúsculo, pinte o big-o-diaeresis caractere. \ *** new line
Se o pedaço for o Ò maiúsculo, pinte o big-o-grave caractere. \ *** new line
Se o pedaço for o Õ maiúsculo, pinte o big-o-tilde caractere. \ *** new line
Se o pedaço for o P maiúsculo, pinte o big-p caractere.
Se o pedaço for o Q maiúsculo, pinte o big-q caractere.
Se o pedaço for o R maiúsculo, pinte o big-r caractere.
Se o pedaço for o S maiúsculo, pinte o big-s caractere.
Se o pedaço for o T maiúsculo, pinte o big-t caractere.
Se o pedaço for o U maiúsculo, pinte o big-u caractere.
Se o pedaço for o Ú maiúsculo, pinte o big-u-acute caractere. \ *** new line
Se o pedaço for o Û maiúsculo, pinte o big-u-circumflex caractere. \ *** new line
Se o pedaço for o Ù maiúsculo, pinte o big-u-grave caractere. \ *** new line
Se o pedaço for o Ü maiúsculo, pinte o big-u-diaeresis caractere. \ *** new line
Se o pedaço for o V maiúsculo, pinte o big-v caractere.
Se o pedaço for o W maiúsculo, pinte o big-w caractere.
Se o pedaço for o x maiúsculo, pinte o big-x caractere.
Se o pedaço for o Y maiúsculo, pinte o big-y caractere.
Se o pedaço for o Ý maiúsculo, pinte o big-y-acute caractere. \ *** new line
Se o pedaço for o Z maiúsculo, pinte o big-z caractere.
\FIM DAS LETRAS MAIÚSCULAS
\SÍMBOLOS
Se o pedaço for o caret pedaço, pinte o caret caractere.
Se o pedaço for o sinal de dois pontos, pinte o colon caractere.
Se o pedaço for o vírgula, pinte o comma caractere.
Se o pedaço for o cifrão, pinte o dollar-sign caractere.
Se o pedaço for as aspas duplas, pinte o double-quote caractere.
Se o pedaço for o número oito, pinte o eight caractere.
Se o pedaço for o sinal de igualdade, pinte o equal-sign caractere.
Se o pedaço for o ponto de exclamação, pinte o exclamation-mark caractere.
Se o pedaço for o número cinco, pinte o five caractere.
Se o pedaço for o número quatro, pinte o four caractere.
Se o pedaço for o left-alligator pedaço, pinte o left-alligator caractere.
Se o pedaço for o chave esquerda, pinte o left-brace caractere.
Se o pedaço for o colchete esquerdo, pinte o left-bracket caractere.
Se o pedaço for o parênteses esquerdo, pinte o left-paren caractere.
\letras minúsculas
Se o pedaço for o 'a' minúsculo, pinte o little-a caractere.
Se o pedaço for o 'á' minúsculo, pinte o little-a-acute caractere. \ *** new line
Se o pedaço for o 'â' minúsculo, pinte o little-a-circumflex caractere. \ *** new line
Se o pedaço for o 'ä' minúsculo, pinte o little-a-diaeresis caractere. \ *** new line
Se o pedaço for o 'à' minúsculo, pinte o little-a-grave caractere. \ *** new line
Se o pedaço for o 'ã' minúsculo, pinte o little-a-tilde caractere. \ *** new line
Se o pedaço for o little-b pedaço, pinte o little-b caractere.
Se o pedaço for o little-c pedaço, pinte o little-c caractere.
Se o pedaço for o little-c-sinal de cedilha, pinte o little-c-cedilla caractere. \new line
Se o pedaço for o little-d pedaço, pinte o little-d caractere.
Se o pedaço for o little-e pedaço, pinte o little-e caractere.
Se o pedaço for o little-e-acute pedaço, pinte o little-e-acute caractere. \ *** new line
Se o pedaço for o little-e-circumflex pedaço, pinte o little-e-circumflex caractere. \ *** new line
Se o pedaço for o little-e-trema, pinte o little-e-diaeresis caractere. \ *** new line
Se o pedaço for o little-e-grave pedaço, pinte o little-e-grave caractere. \ *** new line
Se o pedaço for o little-f pedaço, pinte o little-f caractere.
Se o pedaço for o little-g pedaço, pinte o little-g caractere.
Se o pedaço for o little-h pedaço, pinte o little-h caractere.
Se o pedaço for o little-i pedaço, pinte o little-i caractere.
Se o pedaço for o little-i-acute pedaço, pinte o little-i-acute caractere. \ *** new line
Se o pedaço for o little-i-circumflex pedaço, pinte o little-i-circumflex caractere. \ *** new line
Se o pedaço for o little-i-trema, pinte o little-i-diaeresis caractere. \ *** new line
Se o pedaço for o little-i-grave pedaço, pinte o little-i-grave caractere. \ *** new line
Se o pedaço for o little-j pedaço, pinte o little-j caractere.
Se o pedaço for o little-k pedaço, pinte o little-k caractere.
Se o pedaço for o little-l pedaço, pinte o little-l caractere.
Se o pedaço for o little-m pedaço, pinte o little-m caractere.
Se o pedaço for o little-n pedaço, pinte o little-n caractere.
Se o pedaço for o little-n-tilde pedaço, pinte o little-n-tilde caractere.
Se o pedaço for o little-o pedaço, pinte o little-o caractere.
Se o pedaço for o little-o-acute pedaço, pinte o little-o-acute caractere. \ *** new line
Se o pedaço for o little-o-circumflex pedaço, pinte o little-o-circumflex caractere. \ *** new line
Se o pedaço for o little-o-trema, pinte o little-o-diaeresis caractere. \ *** new line
Se o pedaço for o little-o-grave pedaço, pinte o little-o-grave caractere. \ *** new line
Se o pedaço for o little-o-tilde pedaço, pinte o little-o-tilde caractere. \ *** new line
Se o pedaço for o little-p pedaço, pinte o little-p caractere.
Se o pedaço for o little-q pedaço, pinte o little-q caractere.
Se o pedaço for o little-r pedaço, pinte o little-r caractere.
Se o pedaço for o s minúsculo, pinte o little-s caractere.
Se o pedaço for o little-t pedaço, pinte o little-t caractere.
Se o pedaço for o little-u pedaço, pinte o little-u caractere.
Se o pedaço for o little-u-acute pedaço, pinte o little-u-acute caractere. \ *** new line
Se o pedaço for o little-u-circumflex pedaço, pinte o little-u-circumflex caractere. \ *** new line
Se o pedaço for o little-u-trema, pinte o little-u-diaeresis caractere. \ *** new line
Se o pedaço for o little-u-grave pedaço, pinte o little-u-grave caractere. \ *** new line
Se o pedaço for o little-v pedaço, pinte o little-v caractere.
Se o pedaço for o little-w pedaço, pinte o little-w caractere.
Se o pedaço for o little-x pedaço, pinte o little-x caractere.
Se o pedaço for o little-y pedaço, pinte o little-y caractere.
Se o pedaço for o little-y-acute pedaço, pinte o little-y-acute caractere.
Se o pedaço for o z minúsculo, pinte o little-z caractere.
Se o pedaço for o minus-sign pedaço, pinte o minus-sign caractere.
Se o pedaço for o número nove, pinte o nine caractere.
Se o pedaço for o número-sign pedaço, pinte o número-sign caractere.
Se o pedaço for o one pedaço, pinte o one caractere.
Se o pedaço for o sinal de porcentagem, pinte o percent-sign caractere.
Se o pedaço for o ponto final, pinte o period caractere.
Se o pedaço for o plus-sign pedaço, pinte o plus-sign caractere.
Se o pedaço for o ponto de interrogação, pinte o question-mark caractere.
Se o pedaço for o right-alligator pedaço, pinte o right-alligator caractere.
Se o pedaço for o right-brace pedaço, pinte o right-brace caractere.
Se o pedaço for o right-bracket pedaço, pinte o right-bracket caractere.
Se o pedaço for o parênteses direito, pinte o right-paren caractere.
Se o pedaço for o ponto&vírgula, pinte o semi-colon caractere.
Se o pedaço for o número sete, pinte o seven caractere.
Se o pedaço for o single-quote pedaço, pinte o single-quote caractere.
Se o pedaço for o número seis, pinte o six caractere.
Se o pedaço for o slash pedaço, pinte o slash caractere.
Se o pedaço for o número três, pinte o three caractere.
Se o pedaço for o acento til, pinte o tilde caractere.
Se o pedaço for o número dois, pinte o two caractere.
Se o pedaço for o underscore pedaço, pinte o underscore caractere.
Se o pedaço for o vertical-bar pedaço, pinte o vertical-bar caractere.
Se o pedaço for o número zero, pinte o zero caractere.
\ Atualize o tela. \ *** questionable does not work screws para cima console.

Etapas necessárias para que se pinte o caret caractere:
Save o context.
Mova 3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o colon caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 1/2 square.
Mova 1/2 square.
Mova 1 square.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o comma caractere:
Save o context.
Vire around.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o dollar-sign caractere:
Save o context.
Mova 1 square.
Vire around.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left.
Pinte 2 squares slantways.
Vire right.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Reset o context.
Vire right.
Mova 1 square.
Vire right.
Mova 1/2 square.
Vire around.
Pinte 5 squares.
Restore o context.

Etapas necessárias para que se pinte o double-quote caractere:
Save o context.
Vire right.
Mova 1/2 square.
Vire left.
Mova 2-1/2 squares.
Pinte 1-1/2 squares.
Reset o context.
Vire right.
Mova 1-1/2 squares.
Vire left.
Mova 2-1/2 squares.
Pinte 1-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o eight caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left 3/8.
Pinte 9/10 square slantways.
Vire right.
Pinte 178/100 squares slantways.
Vire left.
Pinte 9/10 square slantways.
Vire left.
Pinte 9/10 square slantways.
Vire left.
Pinte 178/100 squares slantways.
Vire right.
Pinte 9/10 square slantways.
Restore o context.

Etapas necessárias para que se pinte o equal-sign caractere:
Save o context.
Mova 1-1/2 squares.
Vire right.
Pinte 2 squares.
Vire left.
Mova 1 square.
Vire left.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o exclamation-mark caractere:
Save o context.
Mova 4 squares.
Vire right.
Mova 1 square.
Vire right.
Pinte 3 squares.
Mova 1 square.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o five caractere:
Save o context.
Vire right.
Pinte 1 square. Vire left.
Vire around.
\Mova 1 square.
Vire left 3/8.
Pinte 1 squares slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire right.
Pinte 1-5/8 squares.
Vire right.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o four caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 3-5/8 squares.
Vire left 3/8.
Pinte 2 squares slantways.
Vire left 3/8.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o left-alligator caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 17/96 of o way.
Pinte 9/4 square.
Vire right 34/96 of o way.
Pinte 9/4 square.
Restore o context.

Etapas necessárias para que se pinte o left-brace caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire right.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire right.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o left-bracket caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire right.
Pinte 4 squares.
Vire right.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o left-paren caractere:
Save o context.
Vire right.
Mova 1-1/2 squares.
Vire left 3/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2 squares.
Vire right 1/8.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte um line como high como uma caixa;
Etapas necessárias para que se pinte um line como tall como uma caixa:
Pinte a altura desta caixa.

Etapas necessárias para que se pinte um line como wide como uma caixa:
Pinte a largura desta caixa.

Etapas necessárias para que se pinte o little-a caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o little-a-acute caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-8/16 squares.
Vire right.
Mova 1-10/16 square.
Vire left.
Vire right 4/32.
Pinte 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-a-circumflex caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right. Mova 3/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-a-diaeresis caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/3 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-a-grave caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right.
Mova 1/100 square.
Vire right 4/32.
Pinte 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-a-tilde caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/8 squares.
Vire right 1/8.
Mova 1/2 square.
Pinte 9/16 square.
Vire right 3/16.
Pinte 1 square.
Vire left 3/16.
Pinte 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-b caractere:
Save o context.
Pinte 4 squares.
Vire around.
Mova 2 squares.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o little-c caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o little-c-cedilla caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
\ start cedilla mark
Restore o context. Save o context.
Vire right.
Mova 1 square.
Vire right.
Pinte 1/2 square.
Vire left.
Pinte 1/2 square.
Vire right.
Pinte 1/2 square.
Vire right.
Pinte 1/2 square.
\ end cedilla mark
Restore o context.

Etapas necessárias para que se pinte o little-d caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 4 squares.
Vire around.
Mova 2 squares.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o little-e caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1/2 square.
Vire right.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o little-e-acute caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1/2 square.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-8/16 squares.
Vire right.
Mova 1-10/16 square.
Vire left.
Vire right 4/32.
Pinte 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-e-circumflex caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1/2 square.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/16 squares.
Vire right. Mova 3/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-e-diaeresis caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1/2 square.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/3 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-e-grave caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1/2 square.
Vire right.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right.
Mova 1/100 square.
Vire right 4/32.
Pinte 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-f caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Save o context.
Vire around.
Vire right 1/8.
Pinte 1/2 square slantways.
Restore o context.
Pinte 3 squares.
Vire right 1/8.
Pinte 1/2 square slantways.
Vire right.
Pinte 1/2 square slantways.
Reset o context.
Mova 1-6/8 squares.
Vire right.
Mova 1/3 square.
Pinte 1-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o little-g caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2/3 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Reset o context.
Mova 3 squares.
Vire right.
Mova 2 squares.
Vire right.
Pinte 3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 2/20.
Pinte 5/10 square.
Restore o context.

Etapas necessárias para que se pinte o little-h caractere:
Save o context.
Pinte 3-3/4 squares.
Vire around.
Mova 2 squares.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-3/4 squares.
Restore o context.

Etapas necessárias para que se pinte o little-i caractere:
Save o context.
Vire right.
Pinte 2 squares.
Vire around.
Mova 1 square.
Vire right.
Pinte 2-1/2 squares.
Vire left.
Pinte 1 square.
Vire around.
Mova 1 square.
Vire left.
Mova 1/2 square.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o little-i-acute caractere:
Save o context.
Vire right.
Pinte 2 squares.
Vire around.
Mova 1 square.
Vire right.
Pinte 2-1/2 squares.
Vire left.
Pinte 1 square.
Vire around.
Mova 1 square.
Vire left.
Mova 1/2 square.
\Pinte 1/2 square. \removido o ponto do i
\ start accent mark
Restore o context. Save o context.
Mova 2-15/16 squares.
Vire right.
Mova 1-2/16 square.
Vire left.
Vire right 4/32.
Pinte 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-i-circumflex caractere:
Save o context.
Vire right.
Pinte 2 squares.
Vire around.
Mova 1 square.
Vire right.
Pinte 2-1/2 squares.
Vire left.
Pinte 1 square.
Vire around.
Mova 1 square.
Vire left.
Mova 1/2 square.
\Pinte 1/2 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/16 squares.
Vire right. \Mova 1/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-i-diaeresis caractere:
Save o context.
Vire right.
Pinte 2 squares.
Vire around.
Mova 1 square.
Vire right.
Pinte 2-1/2 squares.
Vire left.
Pinte 1 square.
\Vire around.
\Mova 1 square.
\Vire left.
\Mova 1/2 square.
\Pinte 1/2 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/16 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-i-grave caractere:
Save o context.
Vire right.
Pinte 2 squares.
Vire around.
Mova 1 square.
Vire right.
Pinte 2-1/2 squares.
Vire left.
Pinte 1 square.
Vire around.
Mova 1 square.
Vire left.
Mova 1/2 square.
\Pinte 1/2 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right.
Mova 29/100 square.
Vire right 4/32.
Pinte 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-j caractere:
Save o context.
Mova 1 square.
Vire around.
Pinte 1 square.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 2-5/8 squares.
Mova 1/2 square.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o little-k caractere:
Save o context.
Pinte 3-1/4 squares.
Vire around.
Mova 1-2/4 squares.
Vire left 1/8.
Pinte 1-3/4 squares slantways.
Reset o context.
Mova 1-2/4 squares.
Vire right 14/96.
Pinte 9/4 square.
Restore o context.

Etapas necessárias para que se pinte o little-l caractere:
Save o context.
Vire right.
Pinte 2 squares.
Vire around.
Mova 1 square.
Vire right.
Pinte 3-1/2 squares.
Vire left.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o little-m caractere:
Save o context.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right 3/8.
Pinte 2 squares.
Vire around.
Mova 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 3/8.
Pinte 3 squares.
Restore o context.

Etapas necessárias para que se pinte o little-n caractere:
Save o context.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o little-n-tilde caractere:
Save o context.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right. Mova 1/6 square. Vire left.
Vire right 1/8.
Pinte 9/16 square.
Vire right 3/16.
Pinte 1 square.
Vire left 3/16.
Pinte 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-o caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o little-o-acute caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/16 squares.
Vire right.
Mova 1-10/16 square.
Vire left.
Vire right 4/32.
Pinte 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-o-circumflex caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/16 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-o-diaeresis caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/3 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-o-grave caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right.
Mova 1/100 square.
Vire right 4/32.
Pinte 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-o-tilde caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/8 squares.
Vire right 1/8.
Mova 1/2 square.
Pinte 9/16 square.
Vire right 3/16.
Pinte 1 square.
Vire left 3/16.
Pinte 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-p caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 4 squares.
Vire around.
Mova 3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o little-q caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire left 3/8.
Mova 1 square.
Vire around.
Pinte 4 squares.
Restore o context.

Etapas necessárias para que se pinte o little-r caractere:
Save o context.
Pinte 3 squares.
Vire around.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o little-s caractere:
Save o context.
Mova 1 square.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Reset o context.
Mova 2 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Reset o context.
Mova 2 squares.
Vire right 31/96.
Pinte 9/4 squares.
Restore o context.

Etapas necessárias para que se pinte o little-t caractere:
Save o context.
Vire right.
Mova 1 square.
Vire right 1/8.
Pinte 1/2 square slantways.
Vire left 2/8.
Pinte 1/2 square slantways.
Reset o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 3-1/2 squares.
Vire around.
Mova 1 square.
Vire right.
Mova 2/3 square.
Vire around.
Pinte 1-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o little-u caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Pinte 3 squares.
Restore o context.

Etapas necessárias para que se pinte o little-u-acute caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Pinte 3 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-5/16 squares.
Vire right.
Mova 1-1/16 square.
Vire left.
Vire right 4/32.
Pinte 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-u-circumflex caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Pinte 3 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right. Mova 3/8 square.
Vire left 3/32.
Pinte 7/8 square.
Vire right 6/32.
Pinte 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-u-diaeresis caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Pinte 3 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/3 square.
Pinte 1/8 square.
Mova 1 square.
Pinte 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-u-grave caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Pinte 3 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-6/8 squares.
Vire right.
Mova 59/100 square.
Vire right 4/32.
Pinte 1 square menos 1/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-v caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o little-w caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 3 squares.
Vire around.
Vire right 7/96.
Pinte 9/4 squares.
Vire right 34/96.
Pinte 9/4 squares.
Vire left 41/96.
Pinte 3 squares.
Restore o context.

Etapas necessárias para que se pinte o little-x caractere:
Save o context.
Pinte 1 square.
Vire right 17/96.
Pinte 9/4 square.
Vire left 17/96.
Pinte 1 square.
Reset o context.
Vire right.
Mova 2 squares.
Vire left.
Pinte 1 square.
Vire left 17/96.
Pinte 9/4 square.
Vire right 17/96.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o little-y caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 1-1/2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Mova 1-1/2 squares.
Vire around.
Pinte 3 squares.
Vire right 1/8.
Pinte 1 squares slantways.
Vire right.
Pinte 1 squares.
Restore o context.

Etapas necessárias para que se pinte o little-y-acute caractere:
Save o context.
Mova 3 squares.
Vire around.
Pinte 1-1/2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Mova 1-1/2 squares.
Vire around.
Pinte 3 squares.
Vire right 1/8.
Pinte 1 squares slantways.
Vire right.
Pinte 1 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/16 squares.
Vire right.
Mova 1-1/16 square.
Vire left.
Vire right 4/32.
Pinte 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se pinte o little-z caractere:
Save o context.
Mova 3 squares.
Vire right.
Pinte 2 squares.
Vire right.
Pinte 1 square.
Vire right 17/96.
Pinte 9/4 square.
Vire left 17/96.
Pinte 1 square.
Vire left.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o minus-sign caractere:
Save o context.
Mova 2 squares.
Vire right.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o nine caractere:
Save o context.
Mova 1 square.
Vire right 3/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1-5/8 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o número-sign caractere:
Save o context.
Mova 3 squares.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 1 square.
Vire right.
Pinte 2 squares.
Reset o context.
Vire right.
Mova 1/2 square.
Vire left.
Pinte 4 squares.
Reset o context.
Vire right.
Mova 1-1/2 squares.
Vire left.
Pinte 4 squares.
Restore o context.

Etapas necessárias para que se pinte o one caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 3-2/8 squares.
Reset o context.
Vire right.
Pinte 2 squares.
Reset o context.
Mova 3 squares menos 5/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o percent-sign caractere:
Save o context.
Vire right 7/96.
Pinte 9/2 squares.
Reset o context.
Mova 2-1/2 squares.
Pinte 1/2 square.
Reset o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o period caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o plus-sign caractere:
Save o context.
Mova 2 squares.
Vire right.
Pinte 2 squares.
Vire left.
Mova 1 square.
Vire left.
Mova 1 square.
Vire left.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o question-mark caractere:
Save o context.
Mova 3 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1 square.
Mova 1 square.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o right-alligator caractere:
Save o context.
Mova 1 square.
Vire right 17/96 of o way.
Pinte 9/4 square.
Vire left 34/96 of o way.
Pinte 9/4 square.
Restore o context.

Etapas necessárias para que se pinte o right-brace caractere:
Save o context.
Vire right.
Pinte 1 square.
Vire left.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1 square.
Vire left.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o right-bracket caractere:
Save o context.
Vire right.
Pinte 1 square.
Vire left.
Pinte 4 squares.
Vire left.
Pinte 1 square.
Restore o context.

Etapas necessárias para que se pinte o right-paren caractere:
Save o context.
Vire right.
Mova 1/2 square.
Vire left.
Vire right 1/8.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 2 squares.
Vire left 1/8.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o semi-colon caractere:
Save o context.
Vire around.
Mova 1 square.
Vire left 3/8.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1/2 square.
Mova 1/2 square.
Mova 1 square.
Pinte 1/2 square.
Restore o context.

Etapas necessárias para que se pinte o seven caractere:
Save o context.
Mova 2-4/8 squares.
Pinte 1 square.
Vire right.
Pinte 2 squares.
Vire right.
Pinte 1 square.
Vire right 1/8.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1-4/8 squares.
Restore o context.

Etapas necessárias para que se pinte o single-quote caractere:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Mova 2-1/2 squares.
Pinte 1-1/2 squares.
Restore o context.

Etapas necessárias para que se pinte o six caractere:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 2-6/8 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left 1/8.
Pinte 1-6/8 squares.
Vire left 1/8.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Vire left.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o slash caractere:
Save o context.
Vire right 7/96 of o way.
Pinte 9/2 square.
Restore o context.

Etapas necessárias para que se pinte uns squares:
Pinte o square size times o squares dividido por 1 square. \ squares são scaled para cima por precision hence o division at o end

Etapas necessárias para que se pinte uns squares diagonally;
Etapas necessárias para que se pinte uns squares slantways:
Pinte o square size times o squares times o raiz de dois dividido por 1 square. \ squares são scaled para cima por precision hence o division at o end

Etapas necessárias para que se pinte o three caractere:
Save o context.
Mova 2-2/4 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right.
Pinte 75/100 square slantways.
Vire left.
Pinte 75/100 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Restore o context.

Etapas necessárias para que se pinte o tilde caractere:
Save o context.
Mova 2 squares.
Vire right 7/96 of o way.
Pinte 9/8 square.
Vire right.
Pinte 9/6 square.
Vire left.
Pinte 9/8 square.
Restore o context.

Etapas necessárias para que se pinte uns twips:
Pinte um line os twips long.

Etapas necessárias para que se pinte o two caractere:
Save o context.
Mova 2-4/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right.
Pinte 1 square slantways.
Vire right.
Pinte 2 squares slantways.
Vire left 1/8.
Pinte 4/8 square.
Vire left.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o underscore caractere:
Save o context.
Vire around.
Mova 1 square.
Vire left.
Pinte 2 squares.
Restore o context.

Etapas necessárias para que se pinte o vertical-bar caractere:
Save o context.
Vire right.
Mova 1 square.
Vire right.
Mova 1 square.
Vire around.
Pinte 5 squares.
Restore o context.

Etapas necessárias para que se pinte o zero caractere:
Save o context.
Mova 1 square.
Pinte 1-3/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Pinte 1-3/8 squares.
Vire right 1/8.
Pinte 1 square slantways.
Vire right 1/4.
Pinte 1 square slantways.
Vire right 1/8.
Mova 70/100 square.
Vire right.
Mova 1 square.
Pinte 1 pixel.
Restore o context.

Um subject é um string.

\Um substring é um string.
Um subtexto é um string.

Etapas necessárias para que se subtraia um pedaço from uma segunda pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda byte
Intel $2803. \ sub [ebx],al

Etapas necessárias para que se subtraia um pedaço from um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
Intel $2903. \ sub [ebx],eax

Etapas necessárias para que se subtraia uma fração from uma segunda fração:
Isole a fração.
Normalize a fração e a segunda fração.
Subtraia o numerador desta fração from o numerador desta segunda fração.
Reduce a segunda fração.

Etapas necessárias para que se subtraia um número e uma segunda número from um pair:
Subtraia o número from o x deste pair.
Subtraia a segunda número from o y deste pair.

Etapas necessárias para que se subtraia um número from um pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
Intel $0FB60B. \ movzx ecx,[ebx]
Intel $2BC8. \ sub ecx,eax
Intel $880B. \ mov [ebx],cl

Etapas necessárias para que se subtraia um número from um fração:
Subtraia o número / 1 from a fração.

Etapas necessárias para que se subtraia um número from um pair:
Subtraia o número from o número x deste pair.
Subtraia o número from o número y deste pair.

Etapas necessárias para que se subtraia um pair from uma segunda pair:
Subtraia o número x deste pair from o número x deste segunda pair.
Subtraia o número y deste pair from o número y deste segunda pair.

Etapas necessárias para que se subtraia um endereço de memória from uma segunda endereço de memória;
Etapas necessárias para que se subtraia um número from um endereço de memória;
Etapas necessárias para que se subtraia um número from uma segunda número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda número
Intel $2903. \ sub [ebx],eax

Etapas necessárias para que se permute uma cor com uma segunda cor:
Permute a matiz desta cor com a matiz desta segunda cor.
Permute a saturação desta cor com a saturação desta segunda cor.
Permute a luminosidade desta cor com a luminosidade desta segunda cor.

Etapas necessárias para que se permute um pair com uma segunda pair:
Permute o número x deste pair com o número x deste segunda pair.
Permute o número y deste pair com o número y deste segunda pair.

Etapas necessárias para que se permute um endereço de memória com uma segunda endereço de memória;
Etapas necessárias para que se permute um número com uma segunda número:
Atribua o número a um terceiro número.
Atribua a segunda número ao número.
Atribua o terceiro número ao segunda número.

Etapas necessárias para que se permute uns coisas com uns segunda coisas:
Permute o first destas coisas com o first destas segunda coisas.
Permute o last destas coisas com o last destas segunda coisas.

Um systemtime é um conjunto com \ https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-systemtime
\Especifica uma data e hora, usando membros individuais para o mês, dia, ano, dia da semana, hora, minuto, segundo e milissegundo. 
\A hora está na hora universal coordenada (UTC) ou na hora local, dependendo da função que está sendo chamada.
Um wyrd denominado wYear, \ O ano. Os valores válidos para este membro são de 1601 a 30827.
Um wyrd denominado wMonth, \ O mês. De 1 a 12
Um wyrd denominado wDayOfWeek, \ O dia da semana. De 0 a 6, começando no Domingo
Um wyrd denominado wDay, \ O dia do mês. De 1 a 31
Um wyrd denominado wHour, \ A hora. de 0 a 23
Um wyrd denominado wMinute, \ O minuto. De 0 a 59.
Um wyrd denominado wSecond, \ O segundo. De 0 a 59.
Um wyrd denominado wMilliseconds. \ O milissegundo. De 0 a 999.

Etapas necessárias para que se take off all o masking tape:
Mostre tudo.

Etapas necessárias para que se take off algum tipo de masking tape:
Mostre tudo.

Um talker é um endereço de memória para um talker object.

O talker é um talker.

Um talker object é um conjunto com um talker vtable denominado vtable.

Um talker vtable é um endereço de memória para um talker vtable conjunto.

Um talker vtable conjunto é um conjunto com \ documentar https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ee413476(v=vs.85)
\ iunknown
Um endereço de memória denominado queryinterface,
Um endereço de memória denominado addref,
Um endereço de memória denominado release, \ em this:pspvoice out número
\ italker
Um endereço de memória denominado setnotifysink,
Um endereço de memória denominado setnotifywindowmessage,
Um endereço de memória denominado setnotifycallbackfunction,
Um endereço de memória denominado setnotifycallbackinterface,
Um endereço de memória denominado setnotifywin32event,
Um endereço de memória denominado waitfornotifyevent,
Um endereço de memória denominado getnotifyevendu quedle,
Um endereço de memória denominado setinterest,
Um endereço de memória denominado getevents,
Um endereço de memória denominado getinfo,
Um endereço de memória denominado setoutput,
Um endereço de memória denominado getoutputobjecttoken,
Um endereço de memória denominado getoutputstream,
Um endereço de memória denominado pause,
Um endereço de memória denominado resume,
Um endereço de memória denominado setvoice,
Um endereço de memória denominado getvoice,
Um endereço de memória denominado speak, \ em this:pspvoice; pwcs:pwchar; dwflags:number; pulstreamnumber:pnumber out número
Um endereço de memória denominado speakstream,
Um endereço de memória denominado getstatus,
Um endereço de memória denominado skip,
Um endereço de memória denominado setpriority,
Um endereço de memória denominado getpriority,
Um endereço de memória denominado setalertboundary,
Um endereço de memória denominado getalertboundary,
Um endereço de memória denominado setrate,
Um endereço de memória denominado getrate,
Um endereço de memória denominado setvolume,
Um endereço de memória denominado getvolume,
Um endereço de memória denominado waituntildone,
Um endereço de memória denominado setsyncspeaktimeout,
Um endereço de memória denominado getsyncspeaktimeout,
Um endereço de memória denominado speakcompleteevent,
Um endereço de memória denominado isuisupported,
Um endereço de memória denominado displayui.

O temp endereço completo é um endereço completo.

O terminal é um terminal.

Um terminal é uma coisa com uma caixa, uns quoras, um output cor, um input cor, e um reply string.

O text cutoff é um número igual a 500.

An text é uma coisa com 
Um caixa,
Um origin,
Um pincel cor,
Um font,
Um alinhamento,
Some rows,
Um margin,
Um scale fração,
Um wrap detector,
Um horizontal scroll detector,
Um vertical scroll detector,
Um seleção,
Um detector de alteração,
Um última operação,
Some texts denominado undos,
Some texts denominado redos.

Um TEXTMETRIC é um conjunto com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-textmetrica
\A estrutura TEXTMETRIC contém informações básicas sobre uma fonte física. 
\Todos os tamanhos são especificados em unidades lógicas; ou seja, eles dependem do modo de mapeamento atual do contexto de exibição.
Um número denominado tmHeight, \ A altura (subida + descida) de caracteres.
Um número denominado tmAscent, \ A subida (unidades acima da linha de base) de caracteres.
Um número denominado tmDescent, \A descida (unidades abaixo da linha de base) de caracteres
Um número denominado tmInternalLeading, \ A quantidade de entrelinhas (espaço) dentro dos limites definidos pelo membro tmHeight. 
\Marcas de acento e outros caracteres diacríticos podem ocorrer nesta área. O designer pode definir esse número como sendo zero.
Um número denominado tmExternalLeading, \ A quantidade de entrelinhas extras (espaço) que o aplicativo adiciona entre as linhas. 
\Como essa área está fora da fonte, ela não contém marcas e não é alterada por chamadas de saída de texto no modo OPACO ou TRANSPARENTE. 
\O designer pode definir esse número como zero.
Um número denominado tmAveCharWidth, \A largura média dos caracteres da fonte (geralmente definida como a largura da letra x). 
\Este valor não inclui a largura necessária para caracteres em negrito ou itálico.
Um número denominado tmMaxCharWidth, \ A largura do caractere mais largo da fonte.
Um número denominado tmWeight, \ O "peso numérico" da fonte.
Um número denominado tmOverhang, \A largura extra por string que pode ser adicionada a algumas fontes sintetizadas. 
\Ao sintetizar alguns atributos, como negrito ou itálico, a interface de dispositivo gráfico (GDI) ou um dispositivo pode ter que adicionar largura a uma string em cada caractere e em cada string. 
\ Por exemplo, GDI torna uma seqüência de caracteres em negrito, expandindo o espaçamento de cada caractere e overstriking ele por um valor de deslocamento; 
\ele coloca uma fonte em itálico, cortando a string. 
\Em ambos os casos, há uma saliência além da string básica. 
\Para strings em negrito, a saliência é a distância pela qual o overstrike é compensado. 
\Para strings em itálico, a saliência é a quantidade que a parte superior da fonte é cortada além da parte inferior da fonte.
\O membro tmOverhang permite que o aplicativo determine quanto da largura do caractere retornada por uma chamada de função GetTextExtentPoint32 em um único caractere é a largura real do caractere e quanto é a largura extra por string. 
\A largura real é a extensão menos a saliência.
Um número denominado tmDigitizedAspectX, \ O aspecto horizontal do dispositivo para o qual a fonte foi projetada.
Um número denominado tmDigitizedAspectY, \ O aspecto vertical do dispositivo para o qual a fonte foi projetada. 
\A proporção dos membros tmDigitizedAspectX e tmDigitizedAspectY é a proporção do dispositivo para o qual a fonte foi projetada.
Um pedaço denominado tmFirstChar, \ O valor do primeiro caractere definido na fonte.
Um pedaço denominado tmLastChar, \ O valor do último caractere definido na fonte.
Um pedaço denominado tmDefaultChar, \ O valor do caractere a ser substituído por caracteres que não estão na fonte.
Um pedaço denominado tmBreakChar, \ O valor do caractere que será usado para definir quebras de palavra para justificação de texto.
Um pedaço denominado tmItalic, \ Especifica uma fonte em itálico se for diferente de zero.
Um pedaço denominado tmUnderlined, \ Especifica uma fonte sublinhada se for diferente de zero.
Um pedaço denominado tmStruckOut, \ Uma fonte tachada se for diferente de zero.
Um pedaço denominado tmPitchAndFamily, \ Especifica informações sobre o pitch, a tecnologia e a família de uma fonte física.
\Os quatro bits de ordem inferior deste membro especificam informações sobre o pitch e a tecnologia da fonte. 
\Uma constante é definida para cada um dos quatro bits.
\Um aplicativo deve testar cuidadosamente as qualidades codificadas nesses bits de ordem inferior, sem fazer suposições arbitrárias. 
\Por exemplo, além de ter seus próprios bits definidos, as fontes TrueType e PostScript definem o bit TMPF_VECTOR. 
\Uma fonte de bitmap monoespaçada tem todos esses bits de ordem inferior limpos; uma fonte de bitmap proporcional define o bit TMPF_FIXED_PITCH. 
\Uma fonte de dispositivo de impressora PostScript define os bits TMPF_DEVICE, TMPF_VECTOR e TMPF_FIXED_PITCH.
\Os quatro bits de ordem superior de tmPitchAndFamily designam a família da fonte da fonte. 
\Um aplicativo pode usar o valor 0xF0 e o operador AND bit a bit para mascarar os quatro bits de ordem inferior de tmPitchAndFamily, obtendo assim um valor que pode ser comparado diretamente com nomes de família de fontes para encontrar uma correspondência idêntica. 
\Para obter informações sobre famílias de fontes, consulte a descrição da estrutura LOGFONT. https://docs.microsoft.com/en-us/windows/desktop/api/wingdi/ns-wingdi-logfonta
Um pedaço denominado tmCharSet.\ O conjunto de caracteres da fonte.

Uma coisa é um endereço de memória para uma coisa conjunto.

Uma coisa conjunto é um conjunto com um next coisa e um previous coisa.

Some coisas é um conjunto com um first coisa e um last coisa.

An thousand é 10 hundreds.

An tick é um número.

Um temporizador é um conjunto com uma contagem, uns start ticks e uns total ticks.

Some times é um número. \ this é um fluke, I think -- see "suavize um polígono uns times"

Um vocábulo é um string.

Um topo é uns twips.

O tpi é uns twips igual a 1440.

O tpp é uns twips.

Etapas necessárias para que se trim um string:
Remove algum tipo de leading noise from o string.
Remove algum tipo de trailing noise from o string.

Etapas necessárias para que se dê meia volta:
Etapas necessárias para que se vire around:
Vire right 1/2.

Etapas necessárias para que se vire uma fração igual para um número over uma segunda número:
Atribua o número à coordenada superior desta fração.
Atribua a segunda número à coordenada inferior desta fração.
Vire a fração.

\Etapas necessárias para que se vire uma fração do caminho;
Etapas necessárias para que se vire uma fração of o way;
Etapas necessárias para que se vire uma fração of o way around;
Etapas necessárias para que se vire uma fração:
Se a fração for 1/1, cancele.
Atribua 3840 times a fração mais a orientação deste context à orientação deste context.
Normalize a orientação deste context.

Etapas necessárias para que se vire pra left;
Etapas necessárias para que se vire para a left;
\Etapas necessárias para que se vire à left;
Etapas necessárias para que se vire left:
Vire -1/4.

\Etapas necessárias para que se vire à left uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire pra left uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire para a left uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire left uma fração igual para um número over uma segunda número:
Atribua o número à coordenada superior desta fração.
Atribua a segunda número à coordenada inferior desta fração.
Vire left a fração.

\Etapas necessárias para que se vire uma fração à left do caminho;
\Etapas necessárias para que se vire uma fração pra left do caminho;
Etapas necessárias para que se vire uma fração para a left do caminho;
Etapas necessárias para que se vire left uma fração of o way;
Etapas necessárias para que se vire left uma fração of o way around;
Etapas necessárias para que se vire left um fração:
Isole a fração.
Negate a fração.
Vire a fração.

\Etapas necessárias para que se vire à left uns points;
Etapas necessárias para que se vire pra left uns points;
Etapas necessárias para que se vire para a left uns points;
Etapas necessárias para que se vire left uns points:
Atribua o points e 3840 a um fração.
Vire left a fração.

\Etapas necessárias para que se vire à right;
Etapas necessárias para que se vire pra right;
Etapas necessárias para que se vire para a right;
Etapas necessárias para que se vire right:
Vire 1/4.

\Etapas necessárias para que se vire uns degrees à right;
\Etapas necessárias para que se vire uns degrees pra right;
Etapas necessárias para que se vire uns degrees para a right;
Etapas necessárias para que se vire right uns degrees:
Atribua o degrees times 10 e 3600 a um fração.
Vire right a fração.

Etapas necessárias para que se vire uns degrees:
Atribua o degrees times 10 e 3600 a um fração.
\Se o degrees forem negative, vire left o fração; exit.
Vire right a fração.

\Etapas necessárias para que se vire à right uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire pra right uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire para a right uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire right uma fração igual para um número over uma segunda número:
Atribua o número à coordenada superior desta fração.
Atribua a segunda número à coordenada inferior desta fração.
Vire right a fração.

\Etapas necessárias para que se vire à right uma fração of o way;
Etapas necessárias para que se vire pra right uma fração of o way;
Etapas necessárias para que se vire para a right uma fração of o way;
Etapas necessárias para que se vire right uma fração of o way;
Etapas necessárias para que se vire right uma fração of o way around;
Etapas necessárias para que se vire right um fração:
Vire a fração.

Etapas necessárias para que se vire right uma fração of o way uns percent of o time;
Etapas necessárias para que se vire right uma fração about uns percent of o time;
Etapas necessárias para que se vire right uma fração of o way about uns percent of o time;
Etapas necessárias para que se vire right uma fração uns percent of o time:
Escolha aleatoriamente um número between 1 e 100.
Se o número for maior do que o percent, cancele.
Vire right a fração.

\Etapas necessárias para que se vire uns points à right;
\Etapas necessárias para que se vire uns points pra right;
Etapas necessárias para que se vire uns points para a right;
Etapas necessárias para que se vire right uns points:
Atribua o points e 3840 a um fração.
Vire right a fração.

Etapas necessárias para que se unassign um endereço de memória:
Se o endereço de memória for inexistente, cancele.
Call "kernel32.dll" "HeapFree" com o endereço heap e 0 [no options] e o endereço de memória devolvendo um número.
Se o número for 0, cancele.
Esvazie o endereço de memória.
Subtraia 1 from a contagem do heap.

An unit é um número.

Etapas necessárias para que se unlock um gpbitmap usando um bitmapdata:
Call "gdiplus.dll" "GdipBitmapUnlockBits" com o gpbitmap e o endereçamento deste bitmapdata.

Etapas necessárias para que se mostre tudo:
Call "gdi32.dll" "SelectClipRgn" com o quadro atual e 0.

Etapas necessárias para que se mostre dentro de uma caixa:
Crie um hrgn usando a caixa.
Mostre dentro de o hrgn.
Destrua o hrgn.

Etapas necessárias para que se mostre dentro de um elipse:
Crie um hrgn usando a elipse.
Mostre dentro de o hrgn.
Destrua o hrgn.

Etapas necessárias para que se mostre dentro de um hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" com o quadro atual e o hrgn e 2 [rgn_or].

Etapas necessárias para que se mostre dentro de um polígono:
Crie um hrgn usando o polígono.
Mostre dentro de o hrgn.
Destrua o hrgn.

Etapas necessárias para que se mostre dentro de uma caixa arredondada:
Crie um hrgn usando a caixa arredondada.
Mostre dentro de o hrgn.
Destrua o hrgn.

Etapas necessárias para que se mostre fora de uma caixa:
Crie um hrgn usando a caixa.
Mostre fora de o hrgn.
Destrua o hrgn.

Etapas necessárias para que se mostre fora de um elipse:
Crie um hrgn usando a elipse.
Mostre fora de o hrgn.
Destrua o hrgn.

Etapas necessárias para que se mostre fora de um hrgn:
Crie um old hrgn usando o zero caixa.
Call "gdi32.dll" "GetClipRgn" com o quadro atual e o old hrgn devolvendo um número.
Se o número não for 1, limpe o old hrgn.
Call "gdi32.dll" "SelectClipRgn" com o quadro atual e 0.
Call "gdi32.dll" "ExtSelectClipRgn" com o quadro atual e o hrgn e 4 [rgn_diff].
Call "gdi32.dll" "ExtSelectClipRgn" com o quadro atual e o old hrgn e 2 [rgn_or].
Destrua o old hrgn.

Etapas necessárias para que se mostre fora de um polígono:
Crie um hrgn usando o polígono.
Mostre fora de o hrgn.
Destrua o hrgn.

Etapas necessárias para que se mostre fora de uma caixa arredondada:
Crie um hrgn usando a caixa arredondada.
Mostre fora de o hrgn.
Destrua o hrgn.

Etapas necessárias para que se unquote um string:
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, pare.
Se o target deste first deste subtexto não for as aspas duplas, cancele.
Adicione 1 para o first deste subtexto.
Percorra.
Se o subtexto estiver em branco, pare.
Se o first deste subtexto é o last deste subtexto, pare.
Posponha o target deste first deste subtexto para uma segunda string.
Se o target deste first deste subtexto for as aspas duplas, adicione 1 para o first deste subtexto.
Adicione 1 para o first deste subtexto.
Repita.
Atribua a segunda string ao string.

Etapas necessárias para que se update o tela;
Etapas necessárias para que se mostre it;
Etapas necessárias para que se mostre it all;
Etapas necessárias para que se mostre reveal o canvas;
Etapas necessárias para que se atualize o tela:
Atualize o tela usando a caixa desta tela.

Etapas necessárias para que se uppercase algum tipo de pedaços selecionados em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
Uppercase o subtexto.
Repita.

Etapas necessárias para que se uppercase um pedaço:
Translate o pedaço using o tabela de caracteres maiúsculos ascii .

Etapas necessárias para que se translate um pedaço using um translation texto hexadecimal:
Intel $8B8D08000000. \ mov ecx,[ebp+8] \ o endereço de memória do pedaço 
Intel $8B01. \ mov eax,[ecx] \ o byte
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o tabela de tradução
Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
Intel $D7. \ xlat al,[ebx]
Intel $8901. \ mov [ecx],eax

Etapas necessárias para que se uppercase o character depois de um finger e atribua it para um string:
Se o finger for inexistente, cancele.
Atribua o target deste finger ao string.
Uppercase o string.

Etapas necessárias para que se uppercase um string:
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Uppercase o target deste first deste subtexto.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se uppercase um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha uma row from as rows deste text.
Se a row for inexistente, pare.
Uppercase o string deste row.
Repita.
Wrap o text.

An url é um string.

Um url conjunto é um conjunto com
Um scheme string,
Um host nome string,
Um endereço completo string,
Um extra string,
Um port número.

Um URLCOMPONENTS é um conjunto com
\Contém as partes constituintes de um URL. 
\Essa estrutura é usada com as funções InternetCrackUrl e InternetCreateUrl.
Um número denominado dwStructSize, \ O ramanho dessa estrutura, em bytes.
Um pchar denominado lpszScheme, \ Ponteiro para uma string que contém o nome do esquema.
Um número denominado dwSchemeLength, \ Tamanho do nome do esquema, em TCHARs.
Um número denominado nScheme, \ Valor INTERNET_SCHEME que indica o esquema de protocolo da Internet. https://docs.microsoft.com/en-us/windows/win32/api/wininet/ne-wininet-internet_scheme
Um pchar denominado lpszHostName, \ Ponteiro para uma string que contém o nome do host.
Um número denominado dwHostNameLength, \ Tamanho do nome do host, em TCHARs.
Um número denominado nPort, \ Número da porta convertido. isto é considerado como um wyrd na documentação do Windows (INTERNET_PORT), mas não funciona. Parece ser um WORD
Um pchar denominado lpszUserName, \ Ponteiro para um valor de string que contém o nome do usuário.
Um número denominado dwUserNameLength, \ Tamanho do nome do usuário, em TCHARs.
Um pchar denominado lpszPassword, \ Ponteiro para uma string que contém a senha.
Um número denominado dwPasswordLength, \ Tamanho da senha, em TCHARs.
Um pchar denominado lpszUrlPath, \ Ponteiro para uma string que contém o caminho do URL.
Um número denominado dwUrlPathLength, \ Tamanho do caminho do URL, em TCHARs.
Um pchar denominado lpszExtraInfo, \ Ponteiro para uma string que contém as informações extras (por exemplo, ?string ou #string).
Um número denominado dwExtraInfoLength. \ Tamanho das informações extras, em TCHARs.

Etapas necessárias para que se use uma cor:
Atribua a cor à cor deste context.

Etapas necessárias para que se use o pincel grosso:
Atribua 3 ao grossura do pincel.

Etapas necessárias para que se use um tamanho da letra:
Atribua o tamanho da letra à tamanho da letra deste context.

Etapas necessárias para que se use um tamanho da letra of uns twips:
Atribua os twips ao tamanho da letra.
Atribua os twips à tamanho da letra deste context.

Etapas necessárias para que se use um pincel:
Atribua o pincel ao pincel deste context.

Etapas necessárias para que se use o skinny pincel:
Atribua 1 ao grossura do pincel.

Etapas necessárias para que se use small pointy letras:
\ como opposed para "roundy letras" not yet implemented
Use small letras.

Um UUID é um conjunto com
\ A estrutura UUID define um identificador exclusivo universal (UUID). 
\Um UUID fornece uma designação exclusiva de um objeto, como uma interface, um vetor de ponto de entrada do gerenciador ou um objeto cliente.
\A estrutura UUID é um sinônimo typedefizado para a estrutura GUID.
Um número denominado d1, \unsigned long
\ Especifica os primeiros 8 dígitos hexadecimais da GUID.
Um wyrd denominado d2, \unsigned short
\ Especifica o primeiro grupo de 4 dígitos hexadecimais.
Um wyrd denominado d3, \unsigned short
\ Especifica o segundo grupo de 4 dígitos hexadecimais.
8 pedaços denominado d4. \unsigned char
\ Array de 8 bytes. 
\ Os primeiros 2 bytes contêm o terceiro grupo de 4 dígitos hexadecimais. 
\ Os 6 bytes restantes contêm os 12 dígitos hexadecimais finais.

Um vértice array é um endereço de memória para um vértice array conjunto.

Um vértice array conjunto é um conjunto com uma contagem e um spot endereço de memória.

Um vértice é uma coisa com uma coordenada x, uma coordenada y, um spot at a coordenada x.

Um w-param é um número.

Etapas necessárias para que se aguarde por um event;
Etapas necessárias para que se desenfileire um event:
Yield para windows.
Atribua o first desta fila de eventos ao event.
Se o event for inexistente, repita.
Remove o event from a fila de eventos.
Se a categoria deste event for "fechamento do programa", destrua o event; exit.
Destrua o evento atual.
Atribua o event ao evento atual.

Etapas necessárias para que se aguarde uns milliseconds;
Etapas necessárias para que se espere uns milliseconds;
Etapas necessárias para que se aguarde por uns milliseconds:
Se o milliseconds forem menor do que ou igual para 0, cancele.
Call "kernel32.dll" "Sleep" com o milliseconds. \ https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep

Etapas necessárias para que se aguarde por uma tecla para come back para cima:
Se a tecla estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde por uma tecla para come para cima:
Se a tecla estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde por uma tecla para go para baixo:
Se a tecla não estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde sobre that there tecla com o ESC sobre it:
Aguarde pela tecla Esc.

Etapas necessárias para que se aguarde until speaking é done:
Se o talker for inexistente, cancele.
Call o waituntildone desta vtable deste talker com o talker e -1.

Etapas necessárias para que se aguarde until we hit um tecla;
Etapas necessárias para que se aguarde por um tecla:
Etapas necessárias para que se aguarde uma tecla:
Aguarde pela tecla para go para baixo.
Aguarde pela tecla para come para cima.
Desmanche all events.

Um wave file é um endereço completo.

Um wave é um texto hexadecimal.

Um wide string é um string.

Uma largura é uns twips.

Um WIN32FINDDATA é um conjunto com \Contém informações sobre o arquivo localizado pela função FindFirstFile, FindFirstFileEx ou FindNextFile.
Um número denominado dwFileAttributes,
\Os atributos de arquivo de um arquivo.
\Para valores possíveis e suas descrições, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-attribute-constants
\O atributo FILE_ATTRIBUTE_SPARSE_FILE no arquivo é definido se qualquer um dos fluxos do arquivo já foi esparso.
Um filetime denominado ftCreationTime,
\Uma estrutura FILETIME que especifica quando um arquivo ou diretório foi criado.
\Se o sistema de arquivos subjacente não suportar a hora de criação, este valor será zero.
Um filetime denominado ftLastAccessTime,
\Uma estrutura FILETIME.
\Para um arquivo, a estrutura especifica quando o arquivo foi lido pela última vez, gravado ou executado para arquivos executáveis.
\Para um diretório, a estrutura especifica quando o diretório é criado. 
\Se o sistema de arquivos subjacente não suportar a hora do último acesso, esse membro será zero.
\No sistema de arquivos FAT, a data especificada para arquivos e diretórios está correta, mas a hora do dia é sempre definida para meia-noite.
Um filetime denominado ftLastWriteTime,
\Uma estrutura FILETIME.
\Para um arquivo, a estrutura especifica quando o arquivo foi gravado, truncado ou substituído pela última vez, por exemplo, quando WriteFile ou SetEndOfFile são usados. 
\ A data e a hora não são atualizadas quando os atributos do arquivo ou descritores de segurança são alterados.
\Para um diretório, a estrutura especifica quando o diretório é criado. 
\Se o sistema de arquivos subjacente não suportar a hora da última gravação, esse valor será zero.
Um número denominado nFileSizeHigh,
\O valor DWORD de ordem superior do tamanho do arquivo, em bytes.
\Este valor é zero, a menos que o tamanho do arquivo seja maior que MAXDWORD.
\O tamanho do arquivo é igual a (nFileSizeHigh * (MAXDWORD + 1)) + nFileSizeLow.
Um número denominado nFileSizeLow,
\ O valor DWORD de ordem inferior do tamanho do arquivo, em bytes.
Um número denominado dwReserved0,
\Se o membro dwFileAttributes inclui o atributo FILE_ATTRIBUTE_REPARSE_POINT, este membro especifica a marca de ponto de nova análise.
\Caso contrário, este valor é indefinido e não deve ser usado.
\Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/reparse-point-tags
Um número denominado dwReserved1,
\Reservado para uso futuro.
260 pedaços denominado cFileName,
\ O nome do arquivo.
14 pedaços denominado cAlternateFileName.
\ Um nome alternativo para o arquivo.
\ Este nome está no formato clássico de nome de arquivo 8.3.

Um window class é um conjunto com
\Contém informações de classe de janela. 
\É usado com as funções RegisterClassEx e GetClassInfoEx.
\A estrutura WNDCLASSEX é semelhante à estrutura WNDCLASS. 
\Existem duas diferenças. 
\WNDCLASSEX inclui o membro cbSize, que especifica o tamanho da estrutura, e o membro hIconSm, que contém um identificador para um pequeno ícone associado à classe de janela.
Um número denominado cbSize,
\ O tamanho, em bytes, dessa estrutura. 
\ Defina este membro como sizeof (WNDCLASSEX). 
\ Certifique-se de definir esse membro antes de chamar a função GetClassInfoEx. https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getclassinfoexa
Um número denominado style,
\ O (s) estilo (s) da classe. 
\ Este membro pode ser qualquer combinação dos estilos de classe. https://docs.microsoft.com/en-us/windows/desktop/winmsg/about-window-classes
Um endereço de memória denominado lpfnWndProc,
\ Um ponteiro para o procedimento da janela.
\Você deve usar a função CallWindowProc para chamar o procedimento de janela. 
\Para obter mais informações, consulte https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms633573(v=vs.85)
Um número denominado cbClsExtra,
\ O número de bytes extras a serem alocados seguindo a estrutura da classe da janela. O sistema inicializa os bytes para zero.
Um número denominado cbWndExtra,
\ O número de bytes extras a serem alocados após a instância da janela.
\ O sistema inicializa os bytes para zero.
\ Se um aplicativo usa WNDCLASSEX para registrar uma caixa de diálogo criada usando a diretiva CLASS no arquivo de recurso, ele deve definir este membro como DLGWINDOWEXTRA.
Um número identificador denominado hInstance,
\ Um identificador para a instância que contém o procedimento de janela para a classe.
Um hicon denominado hIcon,
\ Uma alça para o ícone da classe.
\ Este membro deve ser um identificador para um recurso de ícone.
\ Se este membro for NULL, o sistema fornecerá um ícone padrão.
Um cursor denominado hCursor,
\ Um identificador para o cursor da classe. Este membro deve ser um identificador para um recurso de cursor.
\ Se este membro for NULL, um aplicativo deve definir explicitamente a forma do cursor sempre que o mouse se move para a janela do aplicativo.
Um hbrush denominado hbrBackground,
\ Um identificador para o pincel de plano de fundo da classe.
\ Este membro pode ser um identificador para o pincel a ser usado para pintar o plano de fundo ou pode ser um valor de cor. 
\ Um valor de cor deve ser uma das seguintes cores padrão do sistema (o valor 1 deve ser adicionado à cor escolhida). 
\Se um valor de cor for fornecido, você deve convertê-lo em um dos seguintes tipos de HBRUSH:
    \COLOR_ACTIVEBORDER
    \COLOR_ACTIVECAPTION
    \COLOR_APPWORKSPACE
    \COLOR_BACKGROUND
    \COLOR_BTNFACE
    \COLOR_BTNSHADOW
    \COLOR_BTNTEXT
    \COLOR_CAPTIONTEXT
    \COLOR_GRAYTEXT
    \COLOR_HIGHLIGHT
    \COLOR_HIGHLIGHTTEXT
    \COLOR_INACTIVEBORDER
    \COLOR_INACTIVECAPTION
    \COLOR_MENU
    \COLOR_MENUTEXT
    \COLOR_SCROLLBAR
    \COLOR_WINDOW
    \COLOR_WINDOWFRAME
    \COLOR_WINDOWTEXT
\ O sistema exclui automaticamente os pincéis de segundo plano da classe quando o registro da classe é cancelado usando UnregisterClass.  https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-unregisterclassa
\ Um aplicativo não deve excluir esses pincéis.
\ Quando esse membro é NULL, um aplicativo deve pintar seu próprio plano de fundo sempre que for solicitado a pintar em sua área de cliente. 
\ Para determinar se o plano de fundo deve ser pintado, um aplicativo pode processar a mensagem WM_ERASEBKGND https://docs.microsoft.com/en-us/windows/desktop/winmsg/wm-erasebkgnd
\ ou testar o membro fErase da estrutura PAINTSTRUCT https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-paintstruct
\ preenchida pela função BeginPaint. https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-beginpaint
Um endereço de memória denominado lpszMenuName,
\ Ponteiro para uma cadeia de caracteres terminada em nulo que especifica o nome do recurso do menu da classe, conforme o nome aparece no arquivo de recurso. 
\ Se você usar um número inteiro para identificar o menu, use a macro MAKEINTRESOURCE. https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-makeintresourcea
\ Se este membro for NULL, as janelas pertencentes a esta classe não terão menu padrão.
Um endereço de memória denominado lpszClassName,
\ Um ponteiro para uma string terminada em nulo ou é um átomo. 
\Se este parâmetro for um átomo, ele deve ser um átomo de classe criado por uma chamada anterior à função RegisterClass ou RegisterClassEx.  https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registerclassa
\O átomo deve estar na palavra de ordem inferior de lpszClassName; a palavra de ordem superior deve ser zero.
\Se lpszClassName for uma string, ele especifica o nome da classe da janela.  https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-registerclassexa
\O nome da classe pode ser qualquer nome registrado com RegisterClass ou RegisterClassEx, ou qualquer um dos nomes de classe de controle predefinidos. 
\O comprimento máximo para lpszClassName é 256. 
\Se lpszClassName for maior que o comprimento máximo, a função RegisterClassEx falhará.
Um hicon denominado hIconSm.
\ Um identificador para um pequeno ícone associado à classe da janela. 
\ Se este membro for NULL, o sistema pesquisa o recurso de ícone especificado pelo membro hIcon para um ícone do tamanho apropriado para usar como o ícone pequeno.

O window class é um window class.

Um window é um número identificador.

Um winhttp request é uma coisa com
Um session número identificador,
Um connection número identificador,
Um request número identificador.

Um palavra é um subtexto.

Etapas necessárias para que se wrap um text:
Se o text for inexistente, cancele.
Se o wrap detector deste text não estiver ativo, cancele.
Converta o anchor deste text para um posicionamento absoluto usando o text.
Converta o caret deste text para uma segunda posicionamento absoluto usando o text.
Atribua a scale deste text a um fração.
Redimensione proporcionalmente o text para 1/1.
Extraia um string from o text.
Posponha o return pedaço para o string.
Destrua as rows deste text.
Lance um percorredor sobre o string.
Crie o número da fonte of o memory canvas usando o font deste text.
Percorra.
Mova o percorredor usando a caixa deste text (word wrapping rules).
Se o vocábulo deste percorredor estiver em branco, pare.
Crie uma row usando o vocábulo deste percorredor.
Posponha a row para as rows deste text.
Repita.
Destrua o número da fonte of o memory canvas.
Renumber as rows deste text.
Redimensione proporcionalmente o text para a fração.
Converta o posicionamento absoluto para o anchor deste text usando o text.
Converta a segunda posicionamento absoluto para o caret deste text usando o text.
Limite o origin of o text.

Etapas necessárias para que se store um trecho em um file;
Etapas necessárias para que se escreva um trecho para um file:
Limpe o erro do fluxo de entrada/saída.
Call "kernel32.dll" "SetFilePointer" com o file e 0 e 0 e 0 [file_begin] devolvendo um result número.
Se o result número é -1, atribua "Ocorreu um erro durante o posicionamento do ponteiro do arquivo." ao erro do fluxo de entrada/saída; exit.
Call "kernel32.dll" "WriteFile" com o file e o first deste trecho e o quantidade de caracteres deste trecho e um número's endereçamento e 0 devolvendo o result número.
Se o result número for 0, atribua "Ocorreu um erro durante a gravação do arquivo." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se store um trecho em um endereço completo;
Etapas necessárias para que se escreva um trecho para um endereço completo:
Limpe o erro do fluxo de entrada/saída.
Extraia um endereço da pasta from o endereço completo.
Se o endereço da pasta não estiver no sistema de arquivos, atribua "A pasta: " seguido de o endereço da pasta seguido de " não existe." ao erro do fluxo de entrada/saída; exit.
Defina o endereço completo para read-write mode.
Isole o endereço completo.
Modifique através do caractere NUL o endereço completo.
Call "kernel32.dll" "CreateFileA" com o first deste endereço completo e 1073741824 [generic_write] 
And 0 e 0 e 2 [create_always] e -2147483520 [file_flag_write_through ou file_attribute_normal] e 0 devolvendo um número identificador.
Se o número identificador for -1 [invalid_handle_value], atribua "Ocorreu um erro ao tentar abrir o arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.
Call "kernel32.dll" "WriteFile" com o número identificador e o first deste trecho e o quantidade de caracteres deste trecho e um número's endereçamento e 0 devolvendo o número.
Call "kernel32.dll" "CloseHandle" com o número identificador.
Se o número não for 0, cancele.
Atribua "Ocorreu um erro ao tentar salvar o arquivo: " seguido de o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se escreva um pedaço:
Atribua o pedaço a um string.
Escreva o string.

Etapas necessárias para que se escreva um pedaço para stdout:
Call "kernel32.dll" "WriteFile" com o stdout handle e o endereçamento deste pedaço e 1 e um número's endereçamento e nil.

Etapas necessárias para que se escreva um pedaço sem advancing:
Atribua o pedaço a um string.
Escreva o string sem advancing.

 \ will translate para English because "Converta um detector" é used para externalize reams pelo caderno
Etapas necessárias para que se escreva um detector:
Converta o detector para um string.
Escreva o string.

Etapas necessárias para que se escreva um detector sem advancing:
Converta o detector para um string.
Escreva o string sem advancing.

Etapas necessárias para que se escreva um fração:
Converta a fração para um string.
Escreva o string.

Etapas necessárias para que se escreva uma fração sem advancing:
Converta a fração para um string.
Escreva o string sem advancing.

Etapas necessárias para que se escreva um número:
Converta o número para um string.
Escreva o string.

Etapas necessárias para que se escreva um número sem advancing:
Converta o número para um string.
Escreva o string sem advancing.

Etapas necessárias para que se escreva um número sobre um console:
Converta o número para um string.
Escreva o string sobre o console.

Etapas necessárias para que se escreva uns quoras em uma caixa:
\Pinte a caixa com a cor vermelha e a cor preta. \ temp ***
Atribua a caixa a um quora caixa.
Atribua a coordenada superior desta quora caixa mais 24 pixels à coordenada inferior desta quora caixa.
Percorra.
Obtenha um quora from o quoras.
Se o quora for inexistente, pare.
\pinte really fast. ***
\ Pinte o quora caixa com a cor amarela. \ temp ***
Escreva a string deste quora no quora caixa com a cor deste quora.
Mova o quora caixa para baixo 24 px.
Repita.

Etapas necessárias para que se escreva um string;
Etapas necessárias para que se pinte um string:
Isole o string.
Percorra.
Se o string estiver em branco, cancele.
Obtenha um pedaço from o string.
Pinte o pedaço.
Se o string não estiver em branco, space between caracteres.
Repita.

Etapas necessárias para que se escreva um string around um center spot at um raio;
Etapas necessárias para que se escreva um string usando um center spot e um raio;
Etapas necessárias para que se pinte um string around um center spot at um raio;
Etapas necessárias para que se pinte um string usando um center spot e um raio:
Isole o string.
Atribua 1 e o quantidade de caracteres deste string a um fração.
Percorra.
Se o string estiver em branco, cancele.
Obtenha um pedaço from o string.
Start at o center spot.
Mova o raio.
Pinte o pedaço.
Vire a fração.
Repita.

Etapas necessárias para que se escreva um string at um spot com uma cor:
\Etapas necessárias para que se pinte um string at um spot com uma cor:
Start at o spot.
Atribua a cor à cor deste context.
Pinte o string.

Etapas necessárias para que se escreva um string sobre um console:
Se o console for inexistente, cancele.
Insira o string ao text deste console.
Insira o return pedaço ao text deste console.
Wrap o text deste console.
Role o text deste console para o caret.
Mostre o console.

Etapas necessárias para que se escreva um string para um console sem advancing;
Etapas necessárias para que se escreva um string sobre um console sem advancing:
Se o console for inexistente, cancele.
Insira o string ao text deste console.
Wrap o text deste console.
Role o text deste console para o caret.
Mostre o console.

Etapas necessárias para que se escreva um string em uma caixa:
\Etapas necessárias para que se pinte um string em uma caixa:
Pinte o string na caixa com a cor deste context.

Etapas necessárias para que se escreva um string em uma caixa com uma cor:
\Etapas necessárias para que se pinte um string em uma caixa com uma cor:
Atribua a cor à cor deste context.
Atribua o canto inferior esquerdo desta caixa ao spot deste context.
Atribua a altura desta caixa dividido por 2 à tamanho da letra deste context.
\Atribua a altura desta caixa à tamanho da letra deste context.
Face north.
Mova a altura desta caixa dividido por 4. \ was 4 e still é now! ***
Pinte o string.

Etapas necessárias para que se escreva um string no middle of uma caixa;
Etapas necessárias para que se pinte um string no middle of uma caixa:
Atribua a tamanho da letra deste context dividido por 4 a um square size. \ was 4 ***
\ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o quantidade de caracteres deste string times o square size times 3 menos o square size a um largura.
Divida o largura por 2.
Start no middle of a caixa.
Mova para baixo a tamanho da letra deste context dividido por 2. \ was 2 ***
Mova left o largura.
Face north.
Pinte o string.

Etapas necessárias para que se escreva um string no middle of o tela:
Pinte o string no middle of a caixa desta tela.
Atualize o tela.

Etapas necessárias para que se escreva um string sobre um terminal:
Se o terminal for inexistente, cancele.
Adicione um quora para o terminal.
Atribua o string à string deste quora.
Atribua a output cor deste terminal à cor deste quora.
Mostre o terminal.

Etapas necessárias para que se escreva um string um raio away from um center spot;
Etapas necessárias para que se escreva um string um raio around um center spot;
Etapas necessárias para que se escreva um string about um raio from um center spot;
Etapas necessárias para que se escreva um string um raio from um center spot;
Etapas necessárias para que se pinte um string um raio away from um center spot;
Etapas necessárias para que se pinte um string um raio around um center spot;
Etapas necessárias para que se pinte um string about um raio from um center spot;
Etapas necessárias para que se pinte um string um raio from um center spot:
Pinte o string usando o center spot e o raio.

Etapas necessárias para que se escreva um string um raio away from o middle of uma caixa;
Etapas necessárias para que se escreva um string um raio around o middle of uma caixa;
Etapas necessárias para que se escreva um string about um raio from o middle of uma caixa;
Etapas necessárias para que se escreva um string um raio from o middle of uma caixa;
Etapas necessárias para que se pinte um string um raio away from o middle of uma caixa;
Etapas necessárias para que se pinte um string um raio around o middle of uma caixa;
Etapas necessárias para que se pinte um string about um raio from o middle of uma caixa;
Etapas necessárias para que se pinte um string um raio from o middle of uma caixa:
Pinte o string usando o center desta caixa e o raio.

Etapas necessárias para que se escreva um string para stdout:
Call "kernel32.dll" "WriteFile" com o stdout handle e o first deste string e o quantidade de caracteres deste string e um número's endereçamento e nil.

Etapas necessárias para que se escreva um string while turning uma fração of o way;
Etapas necessárias para que se escreva um string while turning uma fração of o way around;
Etapas necessárias para que se escreva um string while turning um fração;
Etapas necessárias para que se pinte um string while turning uma fração of o way;
Etapas necessárias para que se pinte um string while turning uma fração of o way around;
Etapas necessárias para que se pinte um string while turning um fração:
Isole o string.
Percorra.
Se o string estiver em branco, cancele.
Obtenha um pedaço from o string.
Pinte o pedaço.
Vire a fração.
Se o string não estiver em branco, space between caracteres.
Repita.

Etapas necessárias para que se escreva um string com uma cor;
Etapas necessárias para que se pinte um string com uma cor:
Atribua a cor à cor deste context.
Pinte o string.

Etapas necessárias para que se escreva um string com uma cor at o base of uma caixa;
Etapas necessárias para que se pinte um string com uma cor at o base of uma caixa:
Atribua a tamanho da letra deste context dividido por 4 a um square size. \ ***
\ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o quantidade de caracteres deste string times o square size times 3 menos o square size a um largura.
Divida o largura por 2.
Start no middle of o base of a caixa.
Mova para cima a tamanho da letra deste context times 2. \ was sem o times 2 ***
Mova left o largura.
Face north.
Pinte o string com a cor.

Etapas necessárias para que se escreva um string com uma cor at o topo of uma caixa;
Etapas necessárias para que se pinte um string com uma cor at o topo of uma caixa:
Atribua a tamanho da letra deste context dividido por 4 a um square size. \ ***
\ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o quantidade de caracteres deste string times o square size times 3 menos o square size a um largura.
Divida o largura por 2.
Start no middle of o topo of a caixa.
Mova para baixo a tamanho da letra deste context times 4. \ was times 2 ***
Mova left o largura.
Face north.
Pinte o string com a cor.

Etapas necessárias para que se escreva um string com uma cor no middle of uma caixa;
Etapas necessárias para que se pinte um string com uma cor no middle of uma caixa:
Atribua a tamanho da letra deste context dividido por 4 a um square size. \ was 4 ***
\ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o quantidade de caracteres deste string times o square size times 3 menos o square size a um largura.
Divida o largura por 2.
Start no middle of a caixa.
Mova para baixo a tamanho da letra deste context dividido por 2. \ was 2 ***
Mova left o largura.
Face north.
Pinte o string com a cor.

Etapas necessárias para que se escreva um string com uma cor um raio away from um center spot;
Etapas necessárias para que se escreva um string com uma cor um raio around um center spot;
Etapas necessárias para que se escreva um string com uma cor about um raio from um center spot;
Etapas necessárias para que se escreva um string com uma cor um raio from um center spot;
Etapas necessárias para que se pinte um string com uma cor um raio away from um center spot;
Etapas necessárias para que se pinte um string com uma cor um raio around um center spot;
Etapas necessárias para que se pinte um string com uma cor about um raio from um center spot;
Etapas necessárias para que se pinte um string com uma cor um raio from um center spot:
Atribua a cor à cor deste context.
Pinte o string usando o center spot e o raio.

Etapas necessárias para que se escreva um string com uma cor uns twips para baixo from o topo of uma caixa;
Etapas necessárias para que se escreva um string com uma cor uns twips para baixo from o topo center of uma caixa;
Etapas necessárias para que se pinte um string com uma cor uns twips para baixo from o topo of uma caixa;
Etapas necessárias para que se pinte um string com uma cor uns twips para baixo from o topo center of uma caixa:
Atribua a tamanho da letra deste context dividido por 4 a um square size. \ was 4 ***
\ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o quantidade de caracteres deste string times o square size times 3 menos o square size a um largura.
Divida o largura por 2.
Start no middle of o topo of a caixa.
Mova para baixo os twips.
Mova left o largura.
Face north.
Pinte o string com a cor.

Etapas necessárias para que se escreva um string com uma font e um size e uma cor e um spot:
Atribua o size à altura desta font.
Atribua o largura desta string a um largura.
Atribua o spot e o spot a uma caixa.
Subtraia o largura dividido por 2 from a coordenada esquerda desta caixa.
Adicione o largura dividido por 2 para a coordenada direita desta caixa.
Subtraia o size dividido por 2 from a coordenada superior desta caixa.
Adicione o size dividido por 2 para a coordenada inferior desta caixa.
Pinte o string na caixa com a cor e o font e "center".
Atualize o tela.

Etapas necessárias para que se use letras de tamanho grande;
Etapas necessárias para que se escreva com letras grandes;
Etapas necessárias para que se escreva com letras de tamanho grande;
Etapas necessárias para que se use letras grandes:
Atribua o tamanho de letra grande ao tamanho da letra deste context.

Etapas necessárias para que se use letras de tamanho médio;
Etapas necessárias para que se use letras de tamanho regular;
Etapas necessárias para que se escreva com letras de tamanho médio;
Etapas necessárias para que se escreva com letras de tamanho normal;
Etapas necessárias para que se escreva com letras de tamanho regular;
Etapas necessárias para que se use letras de tamanho normal:
Atribua o tamanho de letra médio à tamanho da letra deste context.

Etapas necessárias para que se use letras de tamanho pequeno;
Etapas necessárias para que se escreva com letras pequenas;
Etapas necessárias para que se escreva com letras de tamanho pequeno;
Etapas necessárias para que se use letras pequenas:
Atribua o tamanho de letra pequena ao tamanho da letra deste context.

Um WSADATA é um conjunto com
\A estrutura WSADATA contém informações sobre a implementação do Windows Sockets.
Um wyrd denominado wVersion,
\ A versão da especificação do Windows Sockets que o Ws2_32.dll espera que o chamador use. 
\O byte de alta ordem especifica o número da versão secundária; o byte de ordem inferior especifica o número da versão principal.
Um wyrd denominado wHighVersion,
\ A versão mais recente da especificação do Windows Sockets que o Ws2_32.dll pode oferecer suporte. 
\O byte de alta ordem especifica o número da versão secundária; o byte de ordem inferior especifica o número da versão principal.
\Possui o mesmo valor que o membro wVersion caso a versão solicitada no parâmetro wVersionRequested 
\(que é passado para a função WSAStartup) seja a versão mais alta da especificação Windows Sockets que o Ws2_32.dll pode suportar.
257 pedaços denominado szDescription,
\Uma string ASCII terminada em NULL na qual o Ws2_32.dll copia uma descrição da implementação do Windows Sockets. 
\O texto (até 256 caracteres de comprimento) pode conter qualquer caractere, exceto caracteres de controle e de formatação. 
\O uso mais provável que um aplicativo teria para este membro é exibi-lo (possivelmente truncado) em uma mensagem de status.
127 pedaços denominado szSystemStatus,
\ Uma string ASCII terminada em NULL na qual o Ws2_32.dll copia o status ou as informações de configuração relevantes. 
\O Ws2_32.dll deve usar este parâmetro apenas se as informações forem úteis para o usuário ou equipe de suporte.
\ Este membro não deve ser considerado uma extensão do parâmetro szDescription .
Um wyrd [unsigned] denominado iMaxSockets,
\O número máximo de soquetes que podem ser abertos. Este membro deve ser ignorado para Windows Sockets versão 2 e posterior.
\O membro iMaxSockets é mantido para compatibilidade com a especificação 1.1 do Windows Sockets, mas não deve ser usado ao desenvolver novos aplicativos. 
\Nenhum valor único pode ser apropriado para todos os provedores de serviços subjacentes. 
\A arquitetura do Windows Sockets mudou na versão 2 para oferecer suporte a vários provedores, e a estrutura WSADATA não se aplica mais à pilha de um único fornecedor.
Um wyrd [unsigned] denominado iMaxUdpDg,
\O tamanho máximo da mensagem de datagrama. Este membro é ignorado para Windows Sockets versão 2 e posterior.
\O membro iMaxUdpDg é mantido para compatibilidade com a especificação 1.1 do Windows Sockets, mas não deve ser usado ao desenvolver novos aplicativos. 
\A arquitetura do Windows Sockets mudou na versão 2 para oferecer suporte a vários provedores, e a estrutura WSADATA não se aplica mais à pilha de um único fornecedor. 
\Para o tamanho máximo real da mensagem específico para um determinado provedor de serviços do Windows Sockets e tipo de soquete, 
\os aplicativos devem usar getsockopt para recuperar o valor da opção SO_MAX_MSG_SIZE após a criação de um soquete.
Um endereço de memória denominado lpVendorInfo.
\Um ponteiro para informações específicas do fornecedor. 
\Este membro deve ser ignorado para Windows Sockets versão 2 e posterior.
\O membro lpVendorInfo é mantido para compatibilidade com a especificação 1.1 do Windows Sockets. 
\A arquitetura do Windows Sockets mudou na versão 2 para oferecer suporte a vários provedores, e a estrutura WSADATA não se aplica mais à pilha de um único fornecedor. 
\Os aplicativos que precisam acessar informações de configuração específicas do fornecedor devem usar getsockopt para recuperar o valor da opção PVD_CONFIG para informações específicas do fornecedor.

Um wyrd has 
um pedaço inicial [high byte] e 
um pedaço final [low byte].

Um máscara de disjunção exclusiva é um mask.

Etapas necessárias para que se yield para windows:
Se a fila de eventos não for vazio, cancele.
Call "user32.dll" "GetMessageA" com um msg's endereçamento e 0 e 0 e 0 devolvendo um número.
Se o número for 0, cancele.
Call "user32.dll" "TranslateMessage" com o endereçamento desta msg.
Call "user32.dll" "DispatchMessageA" com o endereçamento desta msg.

Etapas necessárias para que se zero uma caixa:
\ was clear uma caixa, got confounded com "clear uma caixa " (which deveria pinte a caixa all black como does "clear o tela")
Atribua 0 à coordenada esquerda desta caixa.
Atribua 0 à coordenada superior desta caixa.
Atribua 0 à coordenada direita desta caixa.
Atribua 0 à coordenada inferior desta caixa.

O zero caixa é uma caixa.

Etapas necessárias para que se zero fill um número usando uma contagem e posponha it para um string:
Converta o número para uma segunda string.
Zero fill a segunda string usando a contagem.
Posponha a segunda string para o string.

Etapas necessárias para que se zero fill um string usando uma contagem:
Se o quantidade de caracteres deste string for maior do que ou igual à contagem, cancele.
Anteponha o número zero para o string.
Repita.

O zero line é um line. \ tracer

O zero spot é um spot.

Um tabela de tradução é um texto hexadecimal.

O tabela ascii é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF.

O tabela de caracteres minúsculos s/ acento ascii é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F406162636465666768696A6B6C6D6E6F707172737475767778797A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788899A8B9C8D9E8F909192939495969798999A9B9C9D9E79A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF616161616161E6636565656569696969F06E6F6F6F6F6FD7F87575757579FEDF616161616161E6636565656569696969F06E6F6F6F6F6FF7F87575757579FE79.

O tabela de caracteres minúsculos ascii é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F406162636465666768696A6B6C6D6E6F707172737475767778797A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788899A8B9C8D9E8F909192939495969798999A9B9C9D9EFFA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6D7F8F9FAFBFCFDFEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF.

O tabela de caracteres maiúsculos ascii é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F604142434445464748494A4B4C4D4E4F505152535455565758595A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798998A9B8C9D8E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6F7D8D9DADBDCDDDE9F.

An twip é um número.
\ Twip (em inglês "Twentieth of a Point" ou "um vinte avos de um ponto") é uma medida tipográfica. 
\Também usada como medida padrão no Visual Basic 6 e outras versões anteriores 
\quando no modo "Fontes pequenas" do Windows, 15 twips são iguais a um pixel, e 567 twips equivale a 1 cm ou 17.64 µm
\ Twips são unidades independentes de tela para garantir que a proporção dos elementos da tela seja a mesma em todos os sistemas de exibição. 
\Um TWIP é definida como sendo 1 / 1440 de uma polegada (cerca de 0,0176 milímetros).
Um pixel são 15 twips.
Uns pixels são 15 twips.
Um px são 15 twips.
Uns pxs são 15 twips.
Um píxel são 15 twips.
An inch são 1440 twips.
Uma polegada são 1440 twips.
\ Um twip seriam 1,76389 milímetros
\900.000 twips dá 625 polegadas
\Um cm é 56693/100 twips. \ O certo seira 567 / 566,93 cm 
\Um centímetro é 56693/100 twips.
Um cm são 254/100 polegadas.
Um centímetro são 254/100 polegadas.
Um mm é 1/10 centímetros. \ creio que pela lógica seriam 56,7
Um milímetro é 1/10 centímetros. \
Um micrômetro é 1/1000 milímetros. 
Um metro são 100 centímetros.
\Um m são 100 centímetros.
\Um km são 1000 metros.
\Um quilômetro são 1000 metros.
\Um kilômetro são 1000 metros.

O erro do fluxo de entrada/saída é um string.
