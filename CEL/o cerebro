\ O Cérebro - A Sociedade Osmosiana de Programadores de Linguagens Naturais - desde 2006.

\ Regras:
\ No geral, cada linha deve terminar com um ponto final.
\ As exceções são quando você está declarando uma variável do tipo conjunto, 
\ (cujas linhas podem terminar com uma vírgula, exceto no último item do conjunto)
\ Ou quando você estiver declarando um cabeçalho de rotina (que termina com sinal de dois pontos)
\ Quando um campo de texto é convertido para texto puro, 
\ o caractere especial LF é adicionado depois do caractere especial CR
\ Já quando um texto é transformado em um campo de texto, o caractere LF é removido.
\ Existe sempre uma linha, no mínimo.
\ Existe sempre um caractere CR no fim da ultima linha.
\obs: tentar traduzir linha reta como reta. Assim, row pode ser traduzido como linha.

\o verbo "criar" envolve alocação de memória
\o verbo fazer usa a memória já alocada

An URL é uma string.

Um intervalo é um número.
\Um intervalo inicial é um intervalo.
\Um intervalo total é um intervalo.

An text é uma coisa com 
  Uma caixa,
  Uma origem,
  Uma pincel cor,
  Uma font,
  Um alinhamento,
  Some rows,
  Uma margem,
  Uma scale fração,
  Um wrap detector,
  Um horizontal scroll detector,
  Um vertical scroll detector,
  Uma seleção,
  Um detector de alteração,
  Uma última operação,
  Some texts denominado undos,
  Some texts denominado redos.

An string# é um número.

An stack entry é uma coisa com uma string.

O stack é uns stack entries.

An row é uma coisa com 
  Um número da linha e 
  Uma string.

An refer é uma coisa com 
  Uma string e 
  Um endereço de memória (reference).

An grain é 10 milliseconds.

An GpImageAttributes é um endereço de memória.

An event é uma coisa com
Uma categoria [atualização de tela, mostrar seta, pressionamento de tecla, clique, clique duplo, clique direito, clique direito duplo, deactivate, activate, done], \ 
Um detector de tecla Shift, 
Um detector de tecla Ctrl, 
Um detector de tecla Alt, 
Uma localização, 
Uma tecla, 
Um pedaço.

An dyad é uma coisa com
  Um nome,
  Uma value string.

An context é uma coisa com 
  Uma localização, 
  Uma caixa, 
  Uma orientação, 
  Um tamanho da letra, 
  Uma cor, 
  Um número, 
  Uma grossura do pincel,\ pincel largura? ***
  e um letra size sob o tamanho da letra, 
  e um pincel sob a cor.
  \REMARK: A "grossura do pincel" não estava no context conjunto, but it deveria be.
  \I will be adding it para o next version of o CAL context, e now might be a good time for you para adicione it para o PAL context conjunto.

An byte# é um número.

An canvas é um hdc. \ hdc = handle device context

An bucket# é um número.

An bit é uma unidade.

Um percorredor é um conjunto com \ conserte "avance um percorredor" e "recue um percorredor" se você alterar isso aqui
  Um subtexto original,
  Um segmento final, 
  Um segmento inicial.

Um segmento inicial é um subtexto.
Um segmento final é um subtexto.

Etapas para que se avance um percorredor até encontrar o próximo espaço;
Etapas para que se avance um percorredor até o próximo espaço:
  Avance o percorredor.
  Se o conteúdo deste last endereço de memória do pedaço deste segmento inicial deste percorredor não for o caractere de espaço, repita.
  \Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for o caractere de espaço, repita.

Etapas para que se recue um percorredor até o próximo espaço;
Etapas para que se recue um percorredor até encontrar o próximo espaço:
  Recue o percorredor.
  Recue o percorredor.
  Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for o caractere de espaço, repita.
  \Se o conteúdo deste last endereço de memória do pedaço deste segmento inicial deste percorredor não for o caractere de espaço, repita.

Etapas para que se recue um percorredor por um número:
  Subtraia o número desde o first endereço de memória do pedaço deste segmento inicial deste percorredor.
  Subtraia o número desde o last endereço de memória do pedaço deste segmento final deste percorredor.

A contagem total é um número igual a 0.

O detector de ignição é um detector igual a 1.

O sinal de desligamento é um detector igual a 0.

Um posicionamento absoluto é um número.

Etapas para que se adicione uma fração para uma segunda fração:
  Isole a fração.
  Normalize a fração e a segunda fração.
  Adicione o numerador desta fração para o numerador desta segunda fração.
  Reduza a segunda fração.

Uns twips horizontais são uns twips.
Uns twips verticais são uns twips.
Uma localização atual é uma localização.

Etapas para que se adicione uns twips horizontais e uns twips verticais para a localização atual:
  Adicione os twips horizontais para a coordenada X desta localização deste context.
  Adicione os twips verticais para a coordenada Y desta localização deste context.

\ linha, traço, risco, traçado, listra
Etapas para que se adicione uma linha reta para uma figura:
  Se a figura for inexistente, crie a figura; posponha a figura para as figuras.
  Adicione a localização inicial desta linha reta para a figura.
  Adicione a localização final desta linha reta para a figura.

Etapas para que se adicione um nome para umas choices:
  Aloque memória para uma choice.
  Atribua o nome ao nome desta choice.
  Atribua a choice sob o end of as choices.

Etapas para que se adicione um número e um segundo número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o segundo número para o número Y deste par de números.

Etapas para que se adicione um número para um segundo número e um terceiro número para um quarto número:
  Adicione o número para o segundo número.
  Adicione o terceiro número para o quarto número.

Etapas para que se adicione um número para uma fração:
  Adicione o número / 1 para a fração. \ não seria o caso de apenas adicionar o número para a fração?
  \ Eu faria assim:
  \ Converta o número para uma nova fração.
  \ Adicione a nova fração à primeira fração.

Etapas para que se adicione um número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o número para o número Y deste par de números.

Etapas para que se adicione um par de números para um segundo par de números:
  Adicione o número X deste par de números para o número X deste segundo par de números.
  Adicione o número Y deste par de números para o número Y deste segundo par de números.

Etapas para que se adicione um quora para um terminal:
  Crie o quora.
  Posponha o quora para o quora deste terminal.
  Se o terminal não estiver totalmente prenchido, cancele.
  Atribua o first destes quoras deste terminal a um doomed quora.
  Remove o doomed quora desde os quoras deste terminal.
  Destrua o doomed quora.

Etapas para que se adicione uma localização para um figura:
  Posponha a localização para a figura.

Etapas para que se adicione uma string para uns conjunto de textos:
  Crie um conjunto de texto usando a string.
  Posponha o conjunto de texto para o conjunto de textos. \plural bacana aqui

\O título ideal seria algo como: Etapas para que se ajuse o posicionamento de uma caixa a partir de 4 diferentes números:
Etapas para que se ajuste uma caixa usando um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para a coordenada X do canto superior esquerdo desta caixa.
  Adicione o segundo número para a coordenada Y do canto superior esquerdo desta caixa.
  Adicione o terceiro número para a coordenada X do canto inferior direito desta caixa.
  Adicione o quarto número para a coordenada Y do canto inferior direito desta caixa.

Etapas para que se ajuste um item:
  Atribua os dwFileAttributes deste WIN32FINDDATA deste item a um número.
  Conjuncione logicamente o número com 16 [FILE_ATTRIBUTE_DIRECTORY].
  Se o número for 0, atribua "arquivo" à categoria deste item. \
  Se o número não for 0, atribua "endereço de pasta" à categoria deste item.\
  Converta o ftCreationTime deste WIN32FINDDATA deste item para a grupo data/hora de criação deste item . \ adicionado para classificação de e-mails.
  Atribua o endereçamento deste cFileName deste WIN32FINDDATA deste item a um endereçamento de caractere.
  Converta o endereçamento de caractere para o designador deste item.
  Se a categoria deste item for "endereço de pasta", posponha "\" para o designador deste item.
  Atribua o endereço da pasta deste item junto com o designador deste item ao endereço completo deste item.
  Extraia a extensão deste item desde o designador deste item como um endereço completo.
  Atribua o nFileSizeLow deste WIN32FINDDATA deste item ao size deste item.
  Se o conteúdo deste first deste designador deste item não for o ponto final, cancele.
  Obtenha o item (novamente).

Etapas para que se ajuste uma linha reta com um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para a coordenada X desta localização inicial desta linha reta.
  Adicione o segundo número para a coordenada Y desta localização inicial desta linha reta.
  Adicione o terceiro número para a coordenada X desta localização final desta linha reta.
  Adicione o quarto número para a coordenada Y desta localização final desta linha reta.

Etapas para que se ajuste uma imagem (extraindo as caixas do gpBitmap):
  Se a imagem for inexistente, cancele.
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa desta imagem.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa desta imagem.
  Atribua a largura deste gpBitmap desta imagem menos 1 times a quantidade de twips/pixel à coordenada X do canto inferior direito desta caixa desta imagem.
  Atribua a altura deste gpBitmap desta imagem menos 1 times a quantidade de twips/pixel à coordenada Y do canto inferior direito desta caixa desta imagem.
  Atribua a caixa desta imagem à caixa intacta desta imagem.

Etapas para que se ajuste espaçamento da fonte usando uma string:
  Se o quadro atual não for a área de impressão, cancele.
  Call "gdi32.dll" "SetTextCharacterExtra" com  \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-settextcharacterextra
  \A função SetTextCharacterExtra define o espaçamento entre caracteres e adiciona espaço extra para cada célula de caractere na fonte selecionada, 
  \incluindo o caractere de quebra,  quando o sistema grava uma linha de texto.
    A área de impressão  [hdc]\ Um identificador para o contexto do dispositivo.
    e 0. [extra]   \ A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
    \quero traduzir esse comando como: Mande a área de impressão e o código 0 para a função "SetTextCharacterExtra" da biblioteca "gdi32.dll".
  Call "gdi32.dll" "GetCurrentObject" com  \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcurrentobject
  \A função GetCurrentObject retorna um identificador que identifica a caneta, pincel, paleta, bitmap ou fonte atual e a função GetObject inicializa uma estrutura contendo os atributos desse objeto. 
  \Algumas impressoras fornecem canetas, pincéis e fontes residentes que podem ser usados para melhorar a velocidade de desenho em um aplicativo.
    A área de impressão [hdc] \ Um identificador para o contexto do dispositivo.
    e 6 [type OBJ_FONT]    \ O tipo de objeto a ser consultado. Este parâmetro pode ser vários valores.
    \ OBJ_FONT -> Retorna a fonte selecionada no momento.
    devolvendo um número identificador. [h] \ Se a função for bem-sucedida, o valor de retorno é um identificador para o objeto especificado. Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hdc] \ Um identificador para o contexto do dispositivo.
    e O número identificador. [h] \ Um identificador para o objeto a ser selecionado. Nesse caso é o número do comando anterior (a fonte selecionada no momento), retornado pelo GetCurrentObject acima
  Obtenha um largura usando a string e o memory canvas.
  Call "gdi32.dll" "SelectObject" com 
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hdc] \ Um identificador para o contexto do dispositivo.
    e O null número da fonte.  [h] \ Um identificador para o objeto a ser selecionado. 
    \Nesse caso é também é um número identificador de fonte, mas  este valor é o da função GetStockObject 
    \O sistema oferece seis fontes de estoque. Uma fonte de estoque é uma fonte lógica que um aplicativo pode obter chamando a função GetStockObject e especificando a fonte solicitada. 
    \Esse valor corresponde à ANSI_FIXED_FONT que especifica uma fonte monoespaçada baseada no conjunto de caracteres ANSI do Windows. Uma fonte Courier é normalmente usada.
  Obtenha uma segunda largura usando a string e a área de impressão.
  Atribua a largura menos a segunda largura dividido pelo quantidade de caracteres desta string a um número.
  Call "gdi32.dll" "SetTextCharacterExtra" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-settextcharacterextra
    \A função SetTextCharacterExtra define o espaçamento entre caracteres. 
    \O espaçamento entre caracteres é adicionado a cada caractere, incluindo caracteres de quebra, quando o sistema grava uma linha de texto.
    A área de impressão [hdc] \Um identificador para o contexto do dispositivo.
    e O número. [extra] \A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
    \Se o modo de mapeamento atual não for MM_TEXT, o parâmetro nCharExtra é transformado e arredondado para o pixel mais próximo.

Etapas para que se alinhe um text usando um alinhamento:
  Atribua o alinhamento ao alinhamento deste text.

Um alinhamento é uma string [centro, esquerda ou direita].

Uma quantia é um número.

Uma anchor é um position.

Uma máscara de conjunção lógica é uma mask.

Um ângulo é uns precise degrees. [cujos valores variam ente 0 e 3599]

Etapas para que se posponha um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" com \https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer
  \Esta função armazena o ponteiro do arquivo em dois valores LONG.
  \Quando um arquivo é aberto, o Windows associa um ponteiro de arquivo com o fluxo padrão. 
  \Esse ponteiro de arquivo é um valor de deslocamento que especifica o próximo byte a ser lido ou o local para receber o próximo byte escrito.
    O file [hFile]\ O número identificador do arquivo.
    e 0 [lDistanceToMove] \ Um valor positivo para lDistanceToMove move o ponteiro do arquivo para frente no arquivo 
    \e um valor negativo move o ponteiro para trás no arquivo .
    e 0 [lpDistanceToMoveHigh] \Serve apenas para operações com 64 bits. Quando não é utilizado, esse valor deve ser 0 (NULL).        
    e 2 [file_end] [dwMoveMethod] \ O ponto de partida para o movimento do ponteiro do arquivo.
    \ Este parâmetro pode ser um dos seguintes valores.
    \0 = FILE_BEGIN ->  O ponto de partida é zero ou o início do arquivo.
    \ 1 = FILE_CURRENT -> O ponto de partida é o valor atual do ponteiro do arquivo.
    \ 2 = FILE_END -> O ponto de partida é a posição atual de fim de arquivo.
    devolvendo um número resultante.
    \Se a função for bem-sucedida e lpDistanceToMoveHigh for NULL, o valor de retorno será o DWORD de ordem inferior do novo ponteiro de arquivo. 
    \Obs: Se a função retornar qualquer valor que não seja -1 (INVALID_SET_FILE_POINTER), isso significa que a chamada para SetFilePointer foi bem-sucedida.
  Se o número resultante for -1, atribua "Ocorreu um erro na hora de posicionar o ponteiro do arquivo." ao erro do fluxo de entrada/saída; volte.
    \ Se o ponteiro de arquivo for um valor negativo, a função falhará, o ponteiro de arquivo não será movido e o código retornado por GetLastError será ERROR_NEGATIVE_SEEK.
    \Observação: Como o valor -1 (INVALID_SET_FILE_POINTER) é um valor válido para o DWORD de ordem inferior do novo ponteiro de arquivo, 
   \O certo seria verificar o valor de retorno da função e o código de erro retornado por GetLastError para determinar se um erro ocorreu ou não. 
    \Se ocorreu um erro, o valor de retorno de SetFilePointer será -1 (INVALID_SET_FILE_POINTER) e a função GetLastError retornará um valor diferente de 0 (NO_ERROR ).  
  Call "kernel32.dll" "WriteFile" com \https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile
  \ Essa função serve pra gravar dados no arquivo ou dispositivo de entrada / saída (E/S) especificado.
    O file [hFile]  \ Um identificador para o arquivo ou dispositivo de E/S 
    \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    e O first endereço de memória do pedaço deste trecho [lpBuffer]  \ Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    e A quantidade de caracteres deste trecho [nNumberOfBytesToWrite] \ O número de bytes a serem gravados no arquivo ou dispositivo.
    \ Um valor zero especifica uma operação de gravação nula. 
    \O comportamento de uma operação de gravação nula depende do sistema de arquivos subjacente ou da tecnologia de comunicação.
    [Creio que seja preciso corrigir o texto abaixo]
    e um [o] endereçamento desse número [lpNumberOfBytesWritten]  \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono. 
    \ WriteFile define esse valor como zero antes de fazer qualquer trabalho ou verificação de erro.
    \ Use NULL para este parâmetro se esta for uma operação assíncrona para evitar resultados potencialmente errôneos.
    \Este parâmetro pode ser NULL somente quando o próximo parâmetro [lpOverlapped] não for 0 (NULL).
    e 0 [lpOverlapped]  \ utilizado somente quando se deseja gravar em outro lugar do arquivo, como por exemplo, no final. 
    \ Se não for o caso, esse parâmetro pode ser 0 (NULL)
    devolvendo o número resultante. \ Se a função for bem-sucedida, o valor de retorno será diferente de 0 (VERDADEIRO).
    \ Se a função falhar ou estiver sendo concluída de forma assíncrona, o valor de retorno será 0 (FALSO). 
    \Para obter informações de erro estendidas, chame a função GetLastError.
    \ Nota: Se GetLastError fornecer um valor igual a 997 ou -2147023899 (ERROR_IO_PENDING), isso não indica uma falha na gravação do arquivo; 
    \indica apenas que a operação de gravação ainda está com conclusão pendente devido ser uma operação de gravação de forma assíncrona. 
    \ Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
  Se o número resultante for 0, atribua "Ocorreu um erro na hora de salvar o arquivo." ao erro do fluxo de entrada/saída; volte.

Etapas para que se posponha um pedaço para uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres desta string mais 1.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres armazenados ao last endereço de memória do pedaço desta string.
  Atribua o pedaço para o conteúdo deste last endereço de memória do pedaço desta string.

Etapas para que se posponha um pedaço para uma string usando uma contagem:
  Isole a contagem.
  Percorra. [o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha o pedaço para a string.
    Subtraia 1 desde a contagem.
  Repita. [o código acima]

Etapas para que se posponha um detector para uma string:
  Converta o detector para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha uma fração para uma string:
  Converta a fração para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um número para uma string:
  Converta o número para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um endereço de memória para uma string:
  Converta o endereço de memória para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha uma localização para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a localização.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha uma string para uma segunda string:
  Se a string estiver em branco, cancele.
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Atribua a quantidade de caracteres desta segunda string a uma quantidade de caracteres armazenados.
  Adicione a quantidade de caracteres armazenados para a quantidade de caracteres agrupados.
  Reassign o first endereço de memória do pedaço desta segunda string usando a quantidade de caracteres agrupados.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres armazenados a um endereço de memória.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o endereço de memória pelo quantidade de caracteres desta string.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres agrupados menos 1 ao last endereço de memória do pedaço desta segunda string.

Etapas para que se posponha uma string para uma segunda string (handling email transparency):
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor (text file rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor começa com ".", posponha "." para a segunda string.
    Posponha o segmento inicial deste percorredor para a segunda string.
  Repita. [o código acima]

Etapas para que se posponha uma string para uma segunda string usando uma contagem:
  Isole a contagem.
  Percorra. [o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha a string para a segunda string.
    Subtraia 1 desde a contagem.
  Repita. [o código acima]

Etapas para que se posponha uns coisas para uns segunda coisas:
  Atribua o first destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Posponha a coisa para a segunda coisas.
  Repita. [o código acima]

Etapas para que se posponha um temporizador para uma string:
  Converta o temporizador para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um vértice para um polígono:
  Se o polígono for inexistente, cancele.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha uma coordenada X e uma coordenada Y para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a coordenada X e a coordenada Y.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha zeros para uma string até que its quantidade de caracteres é um número:
  Se a quantidade de caracteres desta string for maior do que ou igual ao número, cancele.
  Posponha "0" para a string.
  Repita. [o código acima]

Etapas para que se assign um endereço de memória usando um quantidade de pedaços:  \Assinale? Institua? Instale? Instaure? Crie? Inaugure? Monte? Componha? Constitua? Designe? Declare?
  Se o quantidade de pedaços for 0, esvazie o endereço de memória; volte.
  Isole o quantidade de pedaços.
  Arredonde o quantidade de pedaços para cima para o nearest power of two.
  Call "kernel32.dll" "HeapAlloc" com \https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc
  \Aloca um bloco de memória de um heap. A memória alocada não é móvel.
    O endereço heap [hHeap] \ Um identificador para o heap do qual a memória será alocada. Esse identificador é retornado pela função HeapCreate ou GetProcessHeap .
    e 8 [dwFlags ] \As opções de alocação de heap. A especificação de qualquer um desses valores substituirá o valor correspondente especificado quando o heap foi criado com HeapCreate . 
    [8 = HEAP_ZERO_MEMORY]  \A memória alocada será inicializada em zero. Caso contrário, a memória não é inicializada para zero.
    e A quantidade de pedaços [dwBytes] \O número de bytes a serem alocados.
    devolvendo o endereço de memória. [LPVOID ] \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o bloco de memória alocado.
  Se o endereço de memória não for inexistente, adicione 1 para a contagem do heap; volte.

Etapas para que se role automaticamente um text usando uma localização e um detector:
  Se o text for inexistente, desative o detector; volte.
  Atribua a altura desta font deste text a um número.
  Limpe um difference.
  Atribua a caixa deste text a uma caixa.
  Indent a caixa usando a quantidade de twips/pixel .
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua o número ao número Y desta difference.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua o número ao número Y desta difference; negate o número Y desta difference.
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua o número ao número X desta difference.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, atribua o número ao número X desta difference; negate o número X desta difference.
  Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número X desta difference.
  Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, desative o detector; volte.
  Ligue o detector.
  Role o text usando a difference.
  Aguarde por 50 milliseconds.

\Um baseline é um número. \ variável não utilizada


Etapas para que se faça bi-bi:
  Call "user32.dll" "MessageBeep" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebeep
  \Reproduz um som waveform. O som waveform para cada tipo de som é identificado por uma entrada no registro.
  0. [uType] \O som a ser reproduzido. Os sons são definidos pelo usuário por meio do aplicativo de painel de controle de Som e, a seguir, armazenados no registro.
  \O valor 0 é o som especificado como o som Beep padrão do Windows.
  Call "user32.dll" "MessageBeep" com 
  0.

Etapas para que se inicie uma folha modo paisagem:
  Faça a folha modo paisagem 1056 pixels por 816 pixels.
  Inicie uma folha com a folha modo paisagem.

Etapas para que se inicie uma folha modo retrato:
  Faça a folha modo retrato 816 pixels por 1056 pixels.
  \para referência, uma folha A4 possui 3508 x 2480 px, praticamente 10x maio
  Inicie uma folha com a folha modo retrato.

Etapas para que se inicie a impressão:
  Inicialize a área de impressão.
  Atribua a magnitude desse DOCINFO ao cbSize deste DOCINFO.
  Atribua o first deste nome deste module ao lpszDocName deste DOCINFO.
  Call "gdi32.dll" "StartDocA" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-startdoca
  \A função StartDoc inicia um trabalho de impressão.
    A área de impressão [hdc] \Um identificador para o contexto do dispositivo para o trabalho de impressão.
    e O endereçamento deste DOCINFO. [*lpdi] \Um ponteiro para uma estrutura DOCINFO contendo o nome do arquivo de documento e o nome do arquivo de saída.

Etapas para que se inicie uma folha:
  Inicie a folha como uma folha modo retrato.

Um título de índice remissivo é uma string.

Etapas para que se inicie uma folha usando um título de índice remissivo:
  Inicie uma folha modo retrato usando o título de índice remissivo.

A Bíblia é uma coisa com uns versos.

Um verso é uma coisa com uma string.

Uma word big-endian unsigned é um conjunto com 2 pedaços.

Um código binário é uma string.

Uma caixa é um conjunto com
  Uma coordenada X do canto superior esquerdo , 
  Uma coordenada Y do canto superior esquerdo, 
  Uma coordenada X do canto inferior direito, 
  Uma coordenada Y do canto inferior direito,
  Um canto superior esquerdo localização sob a coordenada X do canto superior esquerdo , e 
  Um canto inferior direito localização sob a coordenada X do canto inferior direito, e
  Uma topo-left localização sob a coordenada X do canto superior esquerdo , e  \verificar a possibilidade de remover o comentário abaixo
  Uma base-right localização sob a coordenada X do canto inferior direito. 

Um brilho é uma luminosidade.

Um contagem de buckets é uma contagem.
Um conjunto de buckets é um conjunto com uns refers.
Um bucket é um endereço de memória para um conjunto de buckets.

Um trecho é uma string.

\Etapas para que se avance um pedaço limitando-a para um segundo pedaço e um terceiro pedaço;
Etapas para que se avance um pedaço limitando-o para um segundo pedaço e um terceiro pedaço:
  Adicione 1 para o pedaço.
  Se o pedaço for maior do que o terceiro pedaço, atribua o segundo pedaço ao pedaço.

Etapas para que se avance um número:
  Adicione 1 para o número.

\Etapas para que se avance um número limitando-a para um segundo número e um terceiro número;
Etapas para que se avance um número limitando-o para um segundo número e um terceiro número:
  Adicione 1 para o número.
  Se o número for maior do que o terceiro número, atribua o segundo número ao número.

Etapas para que se avance um percorredor por um número:
  Adicione o número para o last endereço de memória do pedaço deste segmento inicial deste percorredor.
  Adicione o número para o first endereço de memória do pedaço deste segmento final deste percorredor.

Etapas para que se assobie:
  Call "kernel32.dll" "Beep" com \https://docs.microsoft.com/en-us/windows/win32/api/utilapiset/nf-utilapiset-beep
    \Gera tons simples no alto-falante. A função é síncrona; ele executa uma espera alertável e não retorna o controle para seu chamador até que o som termine.
    220 [dwFreq] \A frequência do som, em hertz. Este parâmetro deve estar no intervalo de 37 a 32.767 (0x25 a 0x7FFF).
    e 200. [dwDuration] \A duração do som, em milissegundos

Uma quantidade de pedaços é uma contagem.

Um endereço de memória do pedaço é um endereço de memória para um pedaço.

Etapas para que se capitalize algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Se a row estiver em branco, repita.
    Capitalize a string deste row.
  Repita. [o código acima]

Etapas para que se capitalize uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, pare.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Uppercase o conteúdo deste first endereço de memória do pedaço deste subtexto.

Etapas para que se capitalize um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde os rows deste text.
    Se a row for inexistente, pare.
    Capitalize a string deste row.
  Repita. [o código acima]
  Wrap o text.

Um caret é um position.

Etapas para que se centralize uma caixa sob o base of uma segunda caixa:
  Centralize a caixa no segunda caixa (horizontalmente).
  Atribua a altura desta caixa a uma altura.
  Atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto inferior direito desta caixa menos a altura à coordenada Y do canto superior esquerdo desta caixa.

Etapas para que se centralize uma caixa em uma segunda caixa (horizontalmente):
  Atribua a coordenada X deste center desta segunda caixa menos a coordenada X deste center desta caixa a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa usando o número e 0.

Etapas para que se centralize uma caixa em uma segunda caixa (verticalmente):
  Atribua a coordenada Y deste center desta segunda caixa menos a coordenada Y deste center desta caixa a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa usando 0 e o número.

Etapas para que se centralize um dot sobre a localização atual:
  Centralize o dot sobre a localização deste context.

Etapas para que se centralize uma elipse em uma caixa (horizontalmente):
  Centralize a caixa desta elipse na caixa (horizontalmente).

Etapas para que se centralize uma elipse em uma caixa (verticalmente):
  Centralize a caixa desta elipse na caixa (verticalmente).

Etapas para que se centralize um linha reta em uma caixa (horizontalmente):
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta linha reta a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o linha reta usando o número e 0.

Etapas para que se centralize um linha reta em uma caixa (verticalmente):
  Atribua a coordenada Y deste center desta caixa menos a coordenada Y deste center desta linha reta a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o linha reta usando 0 e o número.

Etapas para que se centralize um imagem em uma caixa (horizontalmente):
  Se a imagem for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando o número e 0.

Etapas para que se centralize um imagem em uma caixa (verticalmente):
  Se a imagem for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa menos a coordenada Y deste center desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando 0 e o número.

Etapas para que se centralize um polígono em uma caixa (horizontalmente):
  Se o polígono for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o polígono usando o número e 0.

Etapas para que se centralize um polígono em uma caixa (verticalmente):
  Se o polígono for inexistente, cancele.
  Atribua o y deste center desta caixa menos o y deste center desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o polígono usando 0 e o número.

Etapas para que se centralize uma localização em uma caixa (horizontalmente):
  Atribua a coordenada X deste center desta caixa menos a coordenada X desta localização a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a localização usando o número e 0.

Etapas para que se centralize uma localização em uma caixa (verticalmente):
  Atribua o y deste center desta caixa menos a coordenada Y desta localização a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a localização usando 0 e o número.

Etapas para que se centralize um text em uma caixa (horizontalmente):
  Se o text for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa deste text a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o text usando o número e 0.

Etapas para que se centralize um text em uma caixa (verticalmente):
  Se o text for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa menos a coordenada Y deste center desta caixa deste text a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o text usando 0 e o número.

Etapas para que se modifique o current matiz por uns points;
Etapas para que se altere o current matiz por uns points;
Etapas para que se mude o current matiz por uns points:
  Mude a matiz deste context por os points.

Etapas para que se modifique um matiz por uns points;
Etapas para que se altere um matiz por uns points;
Etapas para que se mude um matiz por uns points:
  Adicione o points para o matiz.

Etapas para que se modifique uma caixa arredondada usando um raio;
Etapas para que se altere uma caixa arredondada usando um raio;
Etapas para que se mude uma caixa arredondada usando um raio:
  Atribua o raio ao raio desta caixa arredondada.

Etapas para que se modifique um text usando uma caixa;
Etapas para que se altere um text usando uma caixa;
Etapas para que se mude um text usando uma caixa:
  Se o text for inexistente, cancele.
  Atribua a caixa à caixa deste text.
  Wrap o text.

Etapas para que se modifique um text usando uma altura da fonte;
Etapas para que se altere um text usando uma altura da fonte;
Etapas para que se mude um text usando uma altura da fonte:
  Se o text for inexistente, cancele.
  Subtraia a margem deste text desde a coordenada X deste text.
  Atribua a origem deste text dividido pela malha deste text a um par de números.
  Atribua a altura da fonte à altura desta font deste text.
  Redimensione proporcionalmente a altura desta font deste text usando a scale deste text.
  Atribua o par de números times a malha deste text à origem deste text.
  Adicione a margem deste text para a coordenada X deste text.
  Limite a origem of o text.
  Wrap o text.

Etapas para que se modifique um text usando uma nome da fonte;
Etapas para que se altere um text usando uma nome da fonte;
Etapas para que se mude um text usando uma nome da fonte:
  Se o text for inexistente, cancele.
  Atribua o nome da fonte ao nome desta font deste text.
  Wrap o text.

Um character é um pedaço.

Uma choice é uma coisa com um nome e uma caixa.

As choices são umas choices.

Etapas para que se limpe uma caixa:
  Atribua 0 e 0 e 0 e 0 ao caixa. \ caderno depends disso

Etapas para que se limpe um pedaço:
  Atribua o caractere null ao pedaço.

Etapas para que se limpe uma cor:
  Atribua 0 e 0 e 0 à cor.

Etapas para que se limpe um elipse:
  Limpe a caixa desta elipse.

Etapas para que se desative um detector;
Etapas para que se desligue um detector:
  Atribua 0 ao detector. \ era "Atribua no ao detector." O valor da keyword "no" estava no executável do CAL-1000, de acordo com o  Dahn.

Etapas para que se limpe uma font:
  Atribua "" e 0 à font.

Etapas para que se limpe um fração:
  Atribua 0 e 1 à fração.

Etapas para que se limpe um Endereço IP:
  Limpe o número deste Endereço IP.
  Limpe a string deste Endereço IP.

Etapas para que se limpe uma linha reta:
  Limpe a localização inicial desta linha reta.
  Limpe a localização final desta linha reta.

Etapas para que se limpe um número:
  Atribua 0 ao número.

Etapas para que se limpe um par de números:
  Atribua 0 e 0 ao par de números.

Etapas para que se limpe um percorredor:
  Limpe o subtexto original deste percorredor.
  Limpe o segmento final deste percorredor.
  Limpe o segmento inicial deste percorredor.

Etapas para que se erase a tela;
Etapas para que se escureça a tela;
Etapas para que se apague a tela;
Etapas para que se limpe a tela:
  Exponha tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se pinte a tela com uma cor; \ pinte a tela de uma só cor [ou] pinte a tela com uma só cor, etc
Etapas para que se limpe a tela usando uma cor:
  Exponha tudo.
  Pinte a caixa desta tela com a cor e a cor.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se branqueie a tela;
Etapas para que se pinte a tela de branco;
Etapas para que se limpe a tela usando a cor branca:
  \ \ needs special handling
  Exponha tudo.
  Pinte a caixa desta tela com a cor branca e a cor branca.
  Atualize o tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se limpe a tela sem atualizá-la:
  Exponha tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se limpe uma seleção:
  Limpe o anchor desta seleção.
  Limpe o caret desta seleção.

Etapas para que se limpe o stack:
  \ necessário aprimoramentos
  Destrua o stack.

Etapas para que se limpe uma string:
  Unassign o first endereço de memória do pedaço desta string.
  Esvazie o last endereço de memória do pedaço desta string.

Etapas para que se limpe um subtexto:
  Esvazie o first endereço de memória do pedaço deste subtexto.
  Esvazie o last endereço de memória do pedaço deste subtexto.

Etapas para que se limpe um terminal:
  Destrua os quoras deste terminal.

Etapas para que se limpe umas coisas:
  Esvazie o first destas coisas.
  Esvazie o last destas coisas.

Etapas para que se limpe uma word:
  Atribua 0 ao word.

Etapas para que se close um file:
  Call "kernel32.dll" "CloseHandle" com \ https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
  \Em geral, CloseHandle invalida o identificador do objeto especificado, diminui a contagem do identificador do objeto e executa verificações de retenção do objeto. 
  \Depois que o último identificador para um objeto é fechado, o objeto é removido do sistema. .
    O file. [hObject] \Um identificador válido para um objeto aberto.

Etapas para que se avise:
  Toque o som de aviso.

Um número de coluna é um número.

Etapas para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres devolvendo um número:
  Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos ascii devolvendo o número.
  \Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos s/ acento ascii devolvendo o número.

Etapas para que se compativelmente handle algum tipo de message com um janela do programa um message número um wParam e um lParam:
  Se a message for 006 [WM_ACTIVATE], execute algum tipo de WM_ACTIVATE com o wParam; [especifica se a janela está sendo ativada ou desativada]
   Atribua 0 para EAX; volte.
  Se a message for 258 [WM_CHAR hex 102], execute algum tipo de WM_CHAR com o wParam [O código do caractere da tecla.] e o lParam;  
  [lParam é a contagem de repetição, código de varredura, sinalizador de chave estendida, código de contexto, sinalizador de estado da chave anterior ou sinalizador de estado de transição]
  \ Essa mensagem é enviada para a janela com o foco do teclado quando uma mensagem WM_KEYDOWN é traduzida pela função TranslateMessage. 
  \A mensagem WM_CHAR contém o código de caractere da tecla que foi pressionada.
  atribua 0 para EAX; volte.
  Se a message for 001 [WM_CREATE], execute algum tipo de WM_CREATE com a janela do programa; 
  \Enviado quando um aplicativo solicita que uma janela seja criada chamando a função CreateWindowEx ou CreateWindow.   
  \O procedimento de janela da nova janela recebe essa mensagem depois que a janela é criada, mas antes que a janela se torne visível.
  \Uma janela recebe essa mensagem por meio de sua função WindowProc.
  atribua 0 para EAX; volte.
  Se a message for 002 [WM_DESTROY], execute algum tipo de WM_DESTROY; atribua 0 para EAX; volte.
  \ Enviado quando uma janela está sendo destruída. 
  \É enviado para o procedimento de janela da janela sendo destruída após a janela ser removida da tela. 
  \Essa mensagem é enviada primeiro para a janela que está sendo destruída e, em seguida, para as janelas filhas (se houver) à medida que são destruídas. 
  \Durante o processamento da mensagem, pode-se supor que todas as janelas filho ainda existam.
  Se a message for 256 [WM_KEYDOWN Hex 100], execute algum tipo de WM_KEYDOWN 
  \Essa mensagem é enviada para a janela com o foco do teclado quando uma tecla não pertencente ao sistema é pressionada. 
  \Uma tecla que não é do sistema é aquela que é pressionada quando a tecla ALT não está pressionada.
  com O wParam [O código de tecla virtual da tecla não pertencente ao sistema. Consulte Códigos de teclas virtuals ]\-> https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
    e O lParam; [Pode ser a contagem de repetição, um código de varredura, sinalizador de chave estendida, código de contexto, sinalizador de estado-chave anterior e sinalizador de estado de transição,]
  \ veja detalhes aqui: https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown
   atribua 0 para EAX; volte.
  Se a message for 513 [WM_LBUTTONDOWN Hex 201], execute algum tipo de WM_LBUTTONDOWN
  \Postado quando o usuário pressiona o botão esquerdo do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. 
  \Caso contrário, a mensagem é postada na janela que capturou o mouse.
  \Uma janela recebe essa mensagem por meio de sua função WindowProc.
  \ o wParam Indica se as teclas virtuais estão pressionadas ou não, podendo ser mais de uma
   com o lParam;  \ especifica a coordenada do cursor. A coordenada é relativa ao canto superior esquerdo da área do cliente.
   atribua 0 para EAX; volte.
  Se a message for 515 [WM_LBUTTONDBLCLK Hex 203], execute algum tipo de WM_LBUTTONDBLCLK com o lParam; atribua 0 para EAX; volte.
  \Postado quando o usuário clica duas vezes com o botão esquerdo do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 015 [WM_PAINT Hex 0000000F], execute algum tipo de WM_PAINT com o janela do programa; atribua 0 para EAX; volte.
  \A mensagem WM_PAINT é enviada quando o sistema ou outro aplicativo faz uma solicitação para pintar uma parte da janela de um aplicativo. 
  \A mensagem é enviada quando a função UpdateWindow ou RedrawWindow é chamada 
  \ou pela função DispatchMessage quando o aplicativo obtém uma mensagem WM_PAINT usando a função GetMessage ou PeekMessage .
  Se a message for 516 [WM_RBUTTONDOWN Hex 204], execute algum tipo de WM_RBUTTONDOWN com o lParam; atribua 0 para EAX; volte.
  \Postado quando o usuário pressiona o botão direito do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 518 [WM_RBUTTONDBLCLK Hex 206], execute algum tipo de WM_RBUTTONDBLCLK com o lParam; atribua 0 para EAX; volte.
  \Postado quando o usuário clica duas vezes com o botão direito do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 032 [WM_SETCURSOR Hex 20], execute algum tipo de WM_SETCURSOR; atribua 1 para EAX; volte.
  \Enviado para uma janela se o mouse fizer com que o cursor se mova dentro de uma janela e a entrada do mouse não for capturada.
  Se a message for 260 [WM_SYSKEYDOWN Hex 104], execute algum tipo de WM_SYSKEYDOWN com o wParam e o lParam; atribua 0 para EAX; volte.
  \Postado na janela com o foco do teclado quando o usuário pressiona a tecla F10 (que ativa a barra de menus) ou mantém pressionada a tecla ALT e pressiona outra tecla. 
  \Também ocorre quando nenhuma janela tem o foco do teclado; neste caso, a mensagem WM_SYSKEYDOWN é enviada para a janela ativa. 
  \A janela que recebe a mensagem pode distinguir entre esses dois contextos, verificando o código de contexto no parâmetro lParam .
  Call "user32.dll" "DefWindowProcA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowproca
  \Chama o procedimento de janela padrão para fornecer processamento padrão para todas as mensagens de janela que um aplicativo não processa. 
  \Esta função garante que todas as mensagens sejam processadas. DefWindowProc é chamado com os mesmos parâmetros recebidos pelo procedimento de janela.
    A janela do programa [hWnd] \Um identificador para o procedimento de janela que recebeu a mensagem.
    e A message [Msg] \A mensagem em si.
    e O wParam [wParam] \Informações adicionais da mensagem. O conteúdo deste parâmetro depende do valor do parâmetro Msg.
    e O lParam. [lParam] \Informações adicionais da mensagem. O conteúdo deste parâmetro depende do valor do parâmetro Msg.

Etapas para que se compativelmente aguarde por um process endereço de memória:
  Call "kernel32.dll" "WaitForSingleObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject
  \Espera até que o objeto especificado esteja no estado sinalizado ou o intervalo de tempo limite expire.
    O conteúdo deste process endereço de memória [hHandle]  \o número identificador do objeto
    e -1. [dwMilliseconds]  \intervalo de tempo limite, em milisegundos.  O valor -1 informa que a função retornará apenas quando o objeto for sinalizado.]
  Call "kernel32.dll" "CloseHandle" com  \ https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
    O conteúdo deste process endereço de memória. [hObject]  \Um identificador válido para um objeto aberto.
  Atribua 0 ao conteúdo deste process endereço de memória. \  
  Call "user32.dll" "GetForegroundWindow" \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getforegroundwindow
  \Recupera um identificador para a janela do primeiro plano (a janela com a qual o usuário está trabalhando atualmente). 
  \O sistema atribui uma prioridade um pouco mais alta ao encadeamento que cria a janela de primeiro plano do que aos outros encadeamentos.
    devolvendo uma janela do programa. \O valor de retorno é um identificador para a janela do primeiro plano. 
   \A janela de primeiro plano pode ser NULL em certas circunstâncias, como quando uma janela está perdendo a ativação.
  Se a janela do programa for a janela principal do programa, atribua 0 para EAX; volte.
  Call "user32.dll" "ShowWindow" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow
 \Define o estado de exibição da janela especificada.
    A janela principal do programa [hWnd] \Um número identificador para a janela.
    e 6 [nCmdShow SW_MINIMIZE]. \Controla como a janela deve ser exibida. 
    \SW_MINIMIZE Minimiza a janela especificada e ativa a próxima janela de nível superior na ordem Z.
  Call "user32.dll" "ShowWindow" com 
    A janela principal do programa [hWnd]  \Um número identificador para a janela.
    e 9 [nCmdShow SW_RESTORE]. \Ativa e exibe a janela. 
    \Se a janela for minimizada ou maximizada, o sistema a restaurará para seu tamanho e posição originais. 
    \Um aplicativo deve especificar este sinalizador ao restaurar uma janela minimizada.
  Atribua 0 para EAX. \ abra return value of thread

Um console é uma coisa com 
  Uma caixa, 
  Uma cor da borda,
  Uma cor de preenchimento, 
  Um text, 
  Uma malha, 
  Um reply string.

O context é um context.



O context stack é uns contexts.

Etapas para que se converta um posicionamento absoluto para uma position usando um text:
  Se o text for inexistente, limpe o position; volte.
  Isole o posicionamento absoluto.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, limpe o position; volte.
    Atribua o número da linha desta row ao número da linha desta position.
    Atribua o posicionamento absoluto ao número de coluna desta position.
    Subtraia a quantidade de caracteres desta string desta row desde o posicionamento absoluto.
    Se o posicionamento absoluto for menor do que 1, cancele.
  Repita. [o código acima]

Etapas para que se converta um código binário Para um número:
  Atribua 0 ao número.
  Atribua 1 a um value número.
  Percorra. [o código abaixo]
    Se o código binário estiver em branco, cancele.
    Obtenha um character desde o código binário (backwards). \ was backwards
    Se o character for "1", adicione o value para o número.
    Double o value.
  Repita. [o código acima]

Etapas para que se converta uma caixa para uma string:
  Limpe a string.
  Posponha a coordenada X do canto superior esquerdo desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada Y do canto superior esquerdo desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada X do canto inferior direito desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada Y do canto inferior direito desta caixa para a string.

Etapas para que se converta um pedaço para uma cifra binária:
  Atribua o pedaço à cifra binária como um pedaço.
  Uppercase a cifra binária.
  Se a cifra binária for maior do que o número nove, subtraia 7 desde a cifra binária.
  Subtraia 48 desde a cifra binária.

Etapas para que se converta um pedaço para um cifra hexadecimal:
  Separe o pedaço a uma cifra binária e uma segunda cifra binária.
  Converta a cifra binária para o cifra hexadecimal.
  Converta a segunda cifra binária para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Etapas para que se converta um pedaço para um query pedaço:
  Se o pedaço estiver entre 48 e 57, atribua o pedaço ao query pedaço; volte. \ 0-9
  Se o pedaço estiver entre 65 e 90, atribua o pedaço ao query pedaço; volte. \ A-Z
  Se o pedaço estiver entre 97 e 122, atribua o pedaço ao query pedaço; volte. \ a-z
  Se o pedaço for 32, atribua "+" ao query pedaço; volte. \ space
  Converta o pedaço para um cifra hexadecimal.
  Atribua "%" junto com a cifra hexadecimal ao query pedaço.

Etapas para que se converta uma cor para um código da cor:
  Se a cor estiver clear, atribua 16777215 [$00FFFFFF] ao código da cor; volte. \ a cor transparente fica branca 
  Isole a cor.
  Redimensione proporcionalmente a saturação desta cor usando 240/1000.
  Limite a saturação desta cor para 1 e 239.
  Redimensione proporcionalmente a luminosidade desta cor usando 240/1000.
  Limite a luminosidade desta cor para 1 e 239.
  Redimensione proporcionalmente a matiz desta cor usando 240/3600.
  Limite a matiz desta cor para 1 e 239.
  Call "shlwapi.dll" "ColorHLSToRGB" com \https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-colorhlstorgb
  \ Converte cores de matiz-luminância-saturação (HLS) para o formato RGB.
    A matiz desta cor [wHue] \O valor de matiz HLS original.
    e A luminosidade desta cor  [wLuminance] \O valor de luminância HLS original.
    e A saturação desta cor [wSaturation] \O valor de saturação HLS original.
    devolvendo o código da cor. [COLORREF] \Retorna o valor RGB.

Etapas para que se converta uma cor para um espaço de cor RGB:
  Converta a cor para um código da cor.
  Converta o código da cor para o espaço de cor RGB.

Etapas para que se converta um código da cor para uma cor:
  Call "shlwapi.dll" "ColorRGBToHLS" com \https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-colorrgbtohls
    O código da cor e [clrRGB] \ A cor RGB original.
    O endereçamento desse word [*pwHue] \ Um ponteiro para um valor que, quando esse método retorna com êxito, recebe o valor de matiz HLS.
    e O endereçamento dessa segunda word [*pwLuminance] \ Um ponteiro para um valor que, quando este método retorna com sucesso, recebe o valor de luminância HLS.
    e O endereçamento desse terceiro word.[*pwSaturation] \ Um ponteiro para um valor que, quando este método retorna com sucesso, recebe o valor de saturação HLS.
  Atribua o word à matiz desta cor.
  Atribua a segunda word à luminosidade desta cor.
  Atribua o terceiro word à saturação desta cor.
  Redimensione proporcionalmente a matiz desta cor usando 3600/240.
  Limite a matiz desta cor para 0 e 3600.
  Redimensione proporcionalmente a saturação desta cor usando 1000/240.
  Limite a saturação desta cor para 0 e 1000.
  Redimensione proporcionalmente a luminosidade desta cor usando 1000/240.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se converta um código da cor para um espaço de cor RGB:
  Isole o código da cor.
  Desloque o código da cor right 0 bits.
  Atribua o código da cor ao espectro vermelho deste espaço de cor RGB.
  Desloque o código da cor right 8 bits.
  Atribua o código da cor ao espectro verde deste espaço de cor RGB.
  Desloque o código da cor right 8 bits.
  Atribua o código da cor ao espectro azul deste espaço de cor RGB.

Etapas para que se converta um filetime para uma string:
  Limpe a string.
  Call "kernel32.dll" "FileTimeToSystemTime" com \https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-filetimetosystemtime
  \ Converte a hora do arquivo em formato de hora do sistema. A hora do sistema é baseada na hora universal coordenada (UTC).
    O endereçamento deste filetime [*lpFileTime] \ Um ponteiro para uma estrutura FILETIME contendo a hora do arquivo a ser convertida para o formato de data e hora do sistema (UTC).
    e O endereçamento desse SYSTEMTIME [lpSystemTime] \ Um ponteiro para uma estrutura SYSTEMTIME para receber a hora do arquivo convertido.
    devolvendo um número. \ Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Se o número for 0, cancele. \Se a função falhar, o valor de retorno é zero.
  Atribua o wYear deste SYSTEMTIME ao year desse date/time.
  Atribua o wMonth deste SYSTEMTIME ao month deste date/time.
  Atribua o wDayOfWeek deste SYSTEMTIME ao week day deste date/time.
  Atribua o wDay deste SYSTEMTIME ao day deste date/time.
  Atribua o wHour deste SYSTEMTIME à hour deste date/time.
  Atribua o wMinute deste SYSTEMTIME ao minute deste date/time.
  Atribua o wSecond deste SYSTEMTIME ao second deste date/time.
  Atribua os wMilliseconds deste SYSTEMTIME ao millisecond deste date/time.
  Atribua a string deste date/time à string.

Etapas para que se converta um detector para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude deste detector.
  Copie pedaços desde o endereçamento deste detector para o first deste texto hexadecimal pela magnitude deste detector.
  Atribua o first deste texto hexadecimal mais a magnitude deste detector menos 1 ao last deste texto hexadecimal.

Etapas para que se converta uma font para um número da fonte:
  Isole a font.
  Termine com o caractere NULL o nome desta font.
  Call "gdi32.dll" "CreateFontA" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createfonta
  \A função CreateFont cria uma fonte lógica com as características especificadas. A fonte lógica pode ser posteriormente selecionada como a fonte para qualquer dispositivo.
   - a altura desta font times 3 [e depois] dividido por 4 [cHeight] \A altura, em unidades lógicas, da célula ou caractere da fonte. 
   \O valor da altura do caractere (também conhecido como altura EM) é o valor da altura da célula do caractere menos o principal valor interno.
   \Para todas as comparações de altura, o mapeador de fonte procura a maior fonte que não exceda o tamanho solicitado.
    \Esse mapeamento ocorre quando a fonte é usada pela primeira vez.
    e 0 [cWidth] \A largura média, em unidades lógicas, de caracteres na fonte solicitada. 
   \Se este valor for zero, o mapeador de fonte escolhe um valor de correspondência mais próximo. 
   \O valor de correspondência mais próximo é determinado 
   \comparando os valores absolutos da diferença entre a proporção de aspecto do dispositivo atual e a proporção de aspecto digitalizado das fontes disponíveis.
    e 0 [cEscapement] \O ângulo, em décimos de graus, entre o vetor de escape e o eixo x do dispositivo. 
    \O vetor de escape é paralelo à linha de base de uma linha de texto.
    e 0 [cOrientation] \O ângulo, em décimos de graus, entre a linha de base de cada personagem e o eixo x do dispositivo.
    e 0 [cWeight] \A espessura da fonte no intervalo de 0 a 1000. Por exemplo, 400 é normal e 700 é negrito. Se este valor for zero, um peso padrão é usado.
    e 0 [bItalic] \Especifica uma fonte em itálico se definida como TRUE.
    e 0 [bUnderline] \Especifica uma fonte sublinhada se definida como TRUE.
    e 0 [bStrikeOut] \Especifica uma fonte riscada se definida como TRUE.
    e 1 [iCharSet = DEFAULT_CHARSET]  \O conjunto de caracteres. 
    \DEFAULT_CHARSET é definido com um valor baseado na localidade do sistema atual. 
    \Por exemplo, quando a localidade do sistema é inglês (Estados Unidos), ela é definida como ANSI_CHARSET.
    e 0 [iOutPrecision] \A precisão de saída. 
    \A precisão da saída define o quanto a saída deve corresponder à altura, largura, orientação do caractere, escape, densidade e tipo de fonte da fonte solicitada.
    e 0 [iClipPrecision] \A precisão do recorte. A precisão de recorte define como recortar caracteres que estão parcialmente fora da região de recorte.
    e 5 [iQuality = CLEARTYPE_QUALITY]  \A qualidade da saída. 
    \A qualidade de saída define com que cuidado o GDI deve tentar corresponder os atributos de fonte lógica aos de uma fonte física real.
    \Se CLEARTYPE_QUALITY for definido, o texto é renderizado (quando possível) usando o método de suavização ClearType.
    e 4 [iPitchAndFamily = TRUETYPE_FONTTYPE]  \O pitch e a família da fonte.
    e O first deste nome desta font [pszFaceName] \Um ponteiro para uma string terminada em nulo que especifica o nome do tipo da fonte. 
    \O comprimento desta string não deve exceder 32 caracteres, incluindo o caractere nulo de terminação.
    devolvendo o número da fonte. \Se a função for bem-sucedida, o valor de retorno é um identificador para uma fonte lógica.
    \Se a função falhar, o valor de retorno será NULL.

Etapas para que se converta uma fração para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude desta fração.
  Copie pedaços desde o endereçamento desta fração para o first deste texto hexadecimal pela magnitude desta fração.
  Atribua o first deste texto hexadecimal mais a magnitude desta fração menos 1 ao last deste texto hexadecimal.

Etapas para que se converta uma fração para um mixed:
  Se o denominador desta fração for 0, atribua 0 ao whole número deste mixed; atribua 0 ao ratio deste mixed; volte.
  Divida o numerador desta fração pelo denominador desta fração usando o whole número deste mixed e um resto.
  Atribua o resto e o denominador desta fração ao fração deste mixed.

Etapas para que se converta uma fração para uma string usando um número:
  \ converts para um decimal representation com "the número" of places
  Limpe a string.
  Se o número for menor do que 1, cancele.
  Atribua 10 a um value número.
  Raise o value para o número.
  Isole a fração.
  Se a fração for negative, acione um detector; de-sign a fração.
  Multiplique o value pela fração.
  Zero fill o value usando o número e posponha it para a string.
  Atribua a quantidade de caracteres desta string menos o número mais 1 a um byte#.
  Insira "." à string antes de o byte#.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o ponto final, anteponha "0" para a string.
  Se o detector estiver ativo, anteponha "-" para a string.

Etapas para que se converta um texto hexadecimal para um fração:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude desta fração, atribua 0 e 1 ao ratio; volte.
  Copie pedaços desde o first deste texto hexadecimal para o endereçamento desta fração pela magnitude desta fração.

Etapas para que se converta um texto hexadecimal para um número:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude deste número, limpe o número; volte.
  Copie pedaços desde o first deste texto hexadecimal para o endereçamento destte número pela magnitude deste número.

Etapas para que se converta um lParam para um tecla:
  \ assumes lParam desde wm_char message
  Atribua o lParam à tecla.
  Desloque a tecla right 16 bits.
  \https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
  Conjuncione logicamente a tecla com 255. \11111111 ou FF
  Call "user32.dll" "MapVirtualKeyA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-mapvirtualkeya
  \Traduz (mapeia) um código de tecla virtual em um código de varredura ou valor de caractere, ou traduz um código de varredura em um código de tecla virtual.
    A tecla [uCode] \O código de chave virtual ou código de leitura de uma chave. 
    \Como esse valor é interpretado depende do valor do parâmetro uMapType.
    \A partir do Windows Vista, o byte alto do valor uCode pode conter 0xe0 ou 0xe1 para especificar o código de verificação estendida.
    e 1 [uMapType MAPVK_VSC_TO_VK]  \A tradução a ser executada. O valor deste parâmetro depende do valor do parâmetro uCode.
    \ Usando MAPVK_VSC_TO_VK, O parâmetro uCode é um código de varredura e é traduzido em um código de tecla virtual que não distingue entre as teclas esquerda e direita. Se não houver tradução, a função retorna 0.
    devolvendo a tecla. \O valor de retorno é um código de varredura, um código de chave virtual ou um valor de caractere, dependendo do valor de uCode e uMapType. 
    \Se não houver tradução, o valor de retorno é zero.
  Se a tecla NumLock was not toggled, cancele.
  Se a tecla for a tecla Insert, atribua a tecla zero do teclado numérico à tecla; volte.
  Se a tecla for a tecla Delete, atribua a numpad-period tecla à tecla; volte.
  Se a tecla for a tecla Home, atribua a tecla sete do teclado numérico à tecla; volte.
  Se a tecla for a tecla End, atribua a tecla End do teclado numérico à tecla; volte.
  Se a tecla for a tecla PgUp, atribua a tecla nove do teclado numérico à tecla; volte.
  Se a tecla for a tecla PgDn, atribua a tecla três do teclado numérico à tecla; volte.
  Se a tecla for a left-arrow tecla, atribua a tecla quatro do teclado numérico à tecla; volte.
  Se a tecla for a seta pra cima, atribua a tecla oito do teclado numérico à tecla; volte.
  Se a tecla for a right-arrow tecla, atribua a tecla seis do teclado numérico à tecla; volte.
  Se a tecla for a seta pra baixo, atribua a tecla dois do teclado numérico à tecla; volte.
  Se a tecla for a tecla Clear, atribua a tecla cinco do teclado numérico à tecla; volte.

Etapas para que se converta um lParam para uma localização:
  Separe o lParam a um word e uma segunda word.
  Atribua o word à coordenada Y desta localização.
  Atribua a segunda word à coordenada X desta localização.
  Multiplique a localização pelo quantidade de twips/pixel .

Etapas para que se converta um mixed para um fração:
  Atribua o fração deste mixed à fração.
  Adicione o whole número deste mixed times o denominador desta fração para o numerador desta fração.

Etapas para que se converta uma cifra binária para um cifra hexadecimal:
  Isole a cifra binária.
  Se a cifra binária for maior do que 9, adicione 7 para a cifra binária.
  Adicione 48 para a cifra binária.
  Atribua a cifra binária ao cifra hexadecimal.

Etapas para que se converta um cifra hexadecimal para um texto hexadecimal:
  Isole o cifra hexadecimal.
  Limpe o texto hexadecimal.
  Se a quantidade de caracteres deste cifra hexadecimal for ímpar, anteponha o número zero para o cifra hexadecimal.
  Lance um subtexto sobre o cifra hexadecimal.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma cifra binária.
    Desloque a cifra binária left 4 bits.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Posponha a cifra binária para o texto hexadecimal.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se converta um número para um pedaço:
  Atribua o número ao pedaço.

Etapas para que se converta um endereçamento de caractere para uma string:
  Limpe a string.
  Se o endereçamento de caractere for inexistente, cancele.
  Isole o endereçamento de caractere.
  Percorra. [o código abaixo]
    Se o conteúdo deste endereçamento de caractere for o caractere null, cancele.
    Posponha o conteúdo deste endereçamento de caractere para a string.
    Adicione 1 para o endereçamento de caractere.
  Repita. [o código acima]

Etapas para que se converta um endereço de memória e uma quantidade de caracteres para uma string:
  Limpe a string.
  Se o endereço de memória for inexistente, cancele.
  Se a quantidade de caracteres for 0, cancele.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres.
  Copie pedaços desde o endereço de memória para o first endereço de memória do pedaço desta string pelo quantidade de caracteres.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres menos 1 ao last endereço de memória do pedaço desta string.

Etapas para que se converta um endereço de memória para um texto hexadecimal;
Etapas para que se converta um número para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude deste número.
  Copie pedaços desde o endereçamento deste número para o first deste texto hexadecimal pela magnitude deste número.
  Atribua o first deste texto hexadecimal mais a magnitude deste número menos 1 ao last deste texto hexadecimal.

Etapas para que se converta um endereço de memória para um cifra hexadecimal;
Etapas para que se converta um número para um cifra hexadecimal:
  Separe o número a um word e uma segunda word.
  Converta o word para o cifra hexadecimal.
  Converta a segunda word para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Etapas para que se converta um endereço de memória para uma string:
  Converta o endereço de memória para a string como um cifra hexadecimal.

Etapas para que se converta uns points para uns precise degrees:
  Atribua o points times 3840 dividido por 3600 ao precise degrees.

Etapas para que se converta uma position para um posicionamento absoluto usando um text:
  Se o text for inexistente, limpe o posicionamento absoluto; volte.
  Atribua 0 ao posicionamento absoluto.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha desta position, adicione a quantidade de caracteres desta string desta row para o posicionamento absoluto; repita.
  Adicione o número de coluna desta position para o posicionamento absoluto.

Etapas para que se converta uns precise degrees para uns points:
  Atribua os precise degrees times 3600 dividido por 3840 ao points.

Etapas para que se converta um texto de consulta para uma string:
  Limpe a string.
  Se o texto de consulta estiver em branco, cancele.
  Lance um subtexto sobre o texto de consulta.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de adição, posponha " " para a string; adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o sinal de porcentagem, posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a string; adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Se a quantidade de caracteres deste subtexto for menor do que 3, cancele.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma cifra binária.
    Desloque a cifra binária left 4 bits.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Posponha a cifra binária para a string.
  Repita. [o código acima]

Etapas para que se converta uns rows para uma string:
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Posponha a string deste row para a string.
    Se o conteúdo deste last endereço de memória do pedaço desta string é o retorno de carro, posponha a quebra de linha para a string; repita.
  Repita. [o código acima]

Etapas para que se converta uns rows para uma string (no linefeed additions):
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Posponha a string deste row para a string.
  Repita. [o código acima]

Etapas para que se converta uma string para um detector:
  Se a string for "s", acione o detector; volte.
  Se a string for "sim", acione o detector; volte.
  Se a string for "y", acione o detector; volte.
  Se a string for "yes", acione o detector; volte.
  [Se o texto informado não for nenhuma dessas opções, então:] 
  Desative o detector.

Etapas para que se converta uma string para um fração:
  Limpe a fração.
  Se a string estiver em branco, cancele.
  Se a string for algum tipo de integer, converta a string para o numerador desta fração; volte.
  Lance um subtexto sobre a string.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Separe o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto estiver em branco, atribua o subtexto à fração subtexto.
  Separe a fração subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
  Converta o integer subtexto para um whole número.
  Converta o numerador subtexto para um numerador número.
  Converta o denominador subtexto para um denominador número.
  Se o whole número é negative, cancele.
  Se o numerador número é negative, cancele.
  Se o denominador número é negative, cancele.
  Se o denominador número for 0, cancele.
  Se o whole número não for 0, adicione o denominador número times o whole número para o numerador número.
  Atribua o numerador número ao numerador desta fração.
  Atribua o denominador número ao denominador desta fração.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o hífem, negate a fração.

Etapas para que se converta uma string para um cifra hexadecimal:
  Limpe o cifra hexadecimal.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra hexadecimal.
    Posponha a segunda cifra hexadecimal para o cifra hexadecimal.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para um número:
  Atribua 0 ao número.
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Multiplique o número por 10.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um segundo número.
    Subtraia 48 desde o segundo número.
    Adicione o segundo número para o número.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Se o conteúdo deste first endereço de memória do pedaço desta string for o hífem, negate o número.

Etapas para que se converta uma string para um número entre um segundo número e um terceiro número:
  Converta a string para o número.
  Limite o número para o segundo número e o terceiro número.

Etapas para que se converta uma string para um endereço de memória:
  \ presume que o endereço de memória está em cifra binária format
  Converta a string como um cifra hexadecimal para um texto hexadecimal.
  Esvazie o endereço de memória.
  Lance um subtexto sobre o texto hexadecimal.
  Atribua 24 a um contagem de deslocamentos.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se a contagem de deslocamentos for menor do que 0, cancele.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um número.
    Desloque o número left o contagem de deslocamentos.
    Disjuncione logicamente o endereço de memória como um número com o número.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Subtraia 8 desde o contagem de deslocamentos.
  Repita. [o código acima]

Etapas para que se converta uma string para um texto de consulta:
  Limpe o texto de consulta.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
  Se o subtexto estiver em branco, pare.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para um query pedaço.
    Posponha o query pedaço para o texto de consulta.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para uns rows:
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor (text file rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma row usando o segmento inicial deste percorredor.
    Posponha a row para a rows.
    Se o conteúdo deste last endereço de memória do pedaço desta string desta row for a quebra de linha [LF], atribua o retorno de carro [CR] ao conteúdo deste last endereço de memória do pedaço desta string desta row. 
    \ *Rotina nova criada pelo Dahn para abranger linhas que terminam apenas com um LF
  Repita. [o código acima]
  Renumere a rows.

Etapas para que se converta uma string para um UUID:
  Converta a string para um wide string e termine com o caractere NULL.
  Call "ole32.dll" "CLSIDFromString" com \https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-clsidfromstring
  \Converte uma seqüência de caracteres gerada pela função StringFromCLSID de volta pro CLSID original.
    O first endereço de memória do pedaço desta wide string [lpsz] \A representação da seqüência de caracteres do CLSID.
    e O endereçamento deste UUID. [pclsid] \Um ponteiro para o CLSID.

Etapas para que se converta uma string para um wide string:
  Limpe a wide string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a wide string.
    Posponha o caractere null para a wide string.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para um wide string e termine com o caractere NULL:
  Converta a string para a wide string.
  Termine com o caractere NULL a wide string.

Etapas para que se converta uma URL para uma URL simplificada:
  Isole a URL.
  Termine com o caractere NULL a URL.
  Atribua a magnitude desses URL_COMPONENTS ao dwStructSize destes URL_COMPONENTS.
  Atribua 1 ao dwSchemeLength destes URL_COMPONENTS.
  Atribua 1 ao dwHostNameLength destes URL_COMPONENTS.
  Atribua 1 ao dwUrlPathLength destes URL_COMPONENTS.
  Atribua 1 ao dwExtraInfoLength destes URL_COMPONENTS.
  Call "wininet.dll" "InternetCrackUrlA" com \https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetcrackurla
  \"Racha" uma URL em suas partes componentes.
    O first endereço de memória do pedaço desta URL [lpszUrl] \ Ponteiro para uma string que contém a URL canônica a ser quebrada.
    e 0 [dwUrlLength] \ Tamanho da string lpszUrl, em TCHARs, ou zero se lpszUrl for uma string ASCIIZ.
    e 0 [dwFlags] \ Controla a operação.
    e O endereçamento destes URL_COMPONENTS [lpUrlComponents] \Pointer to a URL_COMPONENTS structure that receives the URL components.
    devolvendo um número. \Retorna TRUE se a função for bem-sucedida ou FALSE caso contrário.
  Converta o lpszScheme destes URL_COMPONENTS e o dwSchemeLength destes URL_COMPONENTS para o nome do protocolo desta URL simplificada.
  Converta o lpszHostName destes URL_COMPONENTS e o dwHostNameLength destes URL_COMPONENTS para o nome de host desta URL simplificada.
  Converta o lpszUrlPath destes URL_COMPONENTS e o dwUrlPathLength destes URL_COMPONENTS para o endereço de recurso desta URL simplificada.
  Converta o lpszExtraInfo destes URL_COMPONENTS e o dwExtraInfoLength destes URL_COMPONENTS para a parâmetro de consulta desta URL simplificada.
  Atribua o nPort destes URL_COMPONENTS ao número de porta desta URL simplificada.

Etapas para que se converta um word para um cifra hexadecimal:
  Separe o word a um pedaço e um segundo pedaço.
  Converta o pedaço para o cifra hexadecimal.
  Converta o segundo pedaço para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Uma coordenada é uns twips.

Etapas para que se copie um event para um segundo event: \ mudar o "segunda" aqui
  Se o event for inexistente, esvazie o segundo event; volte.
  Crie o segundo event.
  Atribua a categoria deste event à categoria deste segundo event.
  Atribua o detector de tecla Shift deste event ao detector de tecla Shift deste segundo event.
  Atribua o detector de tecla ctrl deste event ao detector de tecla Ctrl deste segundo event.
  Atribua o detector de tecla alt deste event ao detector de tecla Alt deste segundo event.
  Atribua a localização deste event à localização deste segundo event.
  Atribua a tecla deste event à tecla deste segundo event.
  Atribua o pedaço deste event ao pedaço deste segundo event.

Etapas para que se copie um gpBitmap Para um segundo gpBitmap: \verificar
  Se o gpBitmap for inexistente, esvazie o segundo gpBitmap; volte.
  Call "gdiplus.dll" "GdipCloneBitmapAreaI" com 
    0 [x]
    e 0 [y]
    e A largura deste gpBitmap [width]
    e A altura deste gpBitmap [height]
    e 0 [format = PixelFormatDontCare] 
    e O gpBitmap [*srcBitmap]
    e O endereçamento deste segundo gpBitmap. [**dstBitmap]

Etapas para que se copie o guts of um text Para um segundo text:
  Se o text for inexistente, cancele.
  Se o segundo text for inexistente, cancele.
  Atribua a caixa deste text à caixa deste segundo text.
  Atribua a origem deste text à origem deste segundo text.
  Atribua o pincel deste text ao pincel deste segundo text.
  Atribua a font deste text à font deste segundo text.
  Atribua o alinhamento deste text ao alinhamento deste segundo text.
  Copie as rows deste text para as rows deste segundo text.
  Atribua a margem deste text à margem deste segundo text.
  Atribua a scale deste text à scale deste segundo text.
  Atribua o wrap detector deste text ao wrap detector deste segundo text.
  Atribua o horizontal scroll detector deste text ao horizontal scroll detector deste segundo text.
  Atribua o vertical scroll detector deste text ao vertical scroll detector deste segundo text.
  Atribua a seleção deste text à seleção deste segundo text.
  Atribua o detector de alteração deste text ao detector de alteração deste segundo text.
  Atribua o última operação deste text ao última operação deste segundo text.
  \ dont copie undos e redos

O número de cópias é um número.

Etapas para que se copie uma imagem Para uma segunda imagem:
  Se a imagem for inexistente, esvazie a segunda imagem; volte.
  Aloque memória para a segunda imagem.
  Atribua a caixa desta imagem à caixa desta segunda imagem.
  Atribua a caixa intacta desta imagem à caixa intacta desta segunda imagem.
  Atribua o grayscale detector desta imagem ao grayscale detector desta segunda imagem.
  Atribua o mirror detector desta imagem ao mirror detector desta segunda imagem.
  Atribua o ângulo de rotação desta imagem ao ângulo de rotação desta segunda imagem.
  Atribua os data desta imagem aos data desta segunda imagem.
  Copie o gpBitmap desta imagem ao gpBitmap desta segunda imagem.

Etapas para que se copie um polígono Para um segundo polígono:
  Se o polígono for inexistente, esvazie o segundo polígono; volte.
  Aloque memória para o segundo polígono.
  Copie os vértices deste polígono aos vértices deste segundo polígono.

Etapas para que se copie uma row Para uma segunda row:
  Se a row for inexistente, esvazie a segunda row; volte.
  Aloque memória para o segunda row.
  Atribua a número da linha desta row ao número da linha desta segunda row.
  Atribua a string desta row à string desta segunda row.

Etapas para que se copie uns rows Para uns segunda rows:
  Destrua a segunda rows.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Copie a row a uma segunda row.
    Posponha a segunda row para a segunda rows.
  Repita. [o código acima]

Etapas para que se copie um text Para um segundo text:
  Se o text for inexistente, esvazie o segundo text; volte.
  Aloque memória para o segundo text.
  Copie o guts of o text ao segundo text.

Etapas para que se copie um vértice Para um segundo vértice:
  Se o vértice for inexistente, esvazie o segundo vértice; volte.
  Aloque memória para o segundo vértice.
  Atribua a coordenada X deste vértice à coordenada X deste segundo vértice.
  Atribua a coordenada Y deste vértice à coordenada Y deste segundo vértice.

Etapas para que se copie uns vértices Para uns segundo vértices:
  Destrua os segundo vértices.
  Percorra. [o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Copie o vértice a um segundo vértice.
    Posponha o segundo vértice para o segundo vértices.
  Repita. [o código acima]

Uma contagem é um número.

Um contador é um número.

Etapas para que se crie o connect handle of um requisição WinHTTP using uma URL simplificada:
  Se o requisição WinHTTP for inexistente, cancele.
  Converta o nome de host desta URL simplificada a um wide string denominado wide host nome e termine com o caractere NULL.
  Call "WinHTTP.dll" "WinHttpConnect" com \https://docs.microsoft.com/en-us/windows/win32/api/WinHTTP/nf-WinHTTP-winhttpconnect
    \A função WinHttpConnect faz 2 coisas:
    \1. Especifica o servidor de destino inicial de uma solicitação HTTP e;
    \2. Retorna um identificador de conexão HINTERNET de uma sessão HTTP para esse destino inicial.
    O número identificador de sessão deste número identificador de requisição desta requisição WinHTTP [hSession] 
    \Um identificador de sessão WinHTTP HINTERNET válido retornado por uma chamada anterior para WinHttpOpen.
    e o first endereço de memória do pedaço deste wide host nome [pswzServerName] 
    \Ponteiro para uma string terminada em nulo que contém o nome do host de um servidor HTTP. 
    \Como alternativa, a string pode conter o endereço IP do site em ASCII, por exemplo, 10.0.1.45. 
    \Observe que WinHttp não aceita nomes de host internacionais sem convertê-los primeiro para Punycode.
    e o número de porta desta URL simplificada [nServerPort] \ 80 = http / 443 = https
    \Inteiro não assinado que especifica a porta TCP / IP no servidor ao qual a conexão é feita. Este parâmetro pode ser qualquer número de porta TCP / IP válido
    e 0 [dwReserved] \Este parâmetro é reservado e seu valor deve ser igual 0.
    devolvendo o número identificador de conexão deste requisição WinHTTP.
    \Retorna um identificador de conexão válido para a sessão HTTP se a conexão for bem-sucedida ou NULL caso contrário.
  Se o número identificador de conexão deste requisição WinHTTP for 0, atribua "Erro. Não foi possível estabelecer uma conexão." ao erro do fluxo de entrada/saída; volte.

Etapas para que se crie um console:
  Aloque memória para o console.
  Atribua a cor de borda de janela à cor da borda deste console.
  Atribua a cor preta à cor de preenchimento deste console.
  Atribua a caixa desta tela à caixa deste console.
  Atribua a caixa desta tela a uma caixa.
  Subtraia a altura desta fonte padrão desde a coordenada Y do canto inferior direito desta caixa.
  Atribua a altura desta caixa dividido pela altura desta fonte padrão times a altura desta fonte padrão a uma altura.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura à coordenada Y do canto inferior direito desta caixa.
  Centralize a caixa na caixa desta tela (verticalmente).
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada X do canto superior esquerdo desta caixa.
  Subtraia a coordenada Y do canto superior esquerdo desta caixa desde a coordenada X do canto inferior direito desta caixa.
  Crie o text deste console.
  Atribua a caixa à caixa deste text deste console.
  Ligue o wrap detector deste text deste console.
  Desative o horizontal scroll detector deste text deste console.
  Ligue o vertical scroll detector deste text deste console.
  Atribua a altura desta fonte padrão ao malha deste console.
  Multiplique o número X deste malha deste console por 2.

O nome do provedor criptográfico é uma string.
  
Etapas para que se crie um crypt session com uma passphrase string:
  \ define o erro do fluxo de entrada/saída em caso de falha
  Limpe o erro do fluxo de entrada/saída.
  Aloque memória para o crypt session.
  Atribua "Microsoft Enhanced Cryptographic Provider v1.0" ao nome do provedor criptográfico. [MS_ENHANCED_PROV] \https://docs.microsoft.com/en-us/windows/win32/seccertenroll/cryptoapi-cryptographic-service-providers
  \ aquisição do contexto
  Call "advapi32.dll" "CryptAcquireContextA" com \https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta
    \A função CryptAcquireContext é usada para adquirir um identificador para um contêiner de chave específico em um determinado provedor de serviços criptográficos (CSP). 
    \Este identificador retornado é usado em chamadas para funções CryptoAPI que usam o CSP selecionado.
    O endereçamento deste HCRYPTPROV deste crypt session [*phProv] \Um ponteiro para um identificador de um provedor de serviços criptográficos (CSP). 
    e 0 [szContainer] \O nome do contêiner de chave. Esta é uma string terminada em nulo que identifica o contêiner de chave para o CSP.
    \Na maioria dos casos, quando dwFlags é definido como -268435456 (CRYPT_VERIFYCONTEXT), pszContainer deve ser definido como NULL.
    e o first endereço de memória do pedaço deste nome do provedor criptográfico [szProvider]  
    \Uma string terminada em nulo que contém o nome do CSP a ser usado.
    \Se este parâmetro for NULL, o provedor padrão do usuário será usado. 
    \Para obter mais informações, consulte Contextos do provedor de serviços criptográficos.
    \Para obter uma lista de provedores criptográficos disponíveis, consulte Nomes de provedores criptográficos.
    e 1 [dwProvType PROV_RSA_FULL]  \Especifica o tipo de provedor a ser adquirido. 
    \Os tipos de provedor definidos são discutidos em Tipos de provedor criptográfico.
    \O tipo de provedor PROV_RSA_FULL oferece suporte a assinaturas digitais e criptografia de dados. 
    \É considerado um CSP de propósito geral. O algoritmo de chave pública RSA é usado para todas as operações de chave pública.
    e -268435456 [dwFlags CRYPT_VERIFYCONTEXT]  \Valores de sinalização. 
    \Este parâmetro geralmente é definido como zero, mas existe uma gama de valores possíveis.
    \CRYPT_VERIFYCONTEXT
    \Esta opção se destina a aplicativos que usam chaves efêmeras ou aplicativos que não requerem acesso a chaves privadas persistentes, 
    \como aplicativos que executam apenas hash, criptografia e verificação de assinatura digital. 
    \Apenas os aplicativos que criam assinaturas ou decriptografam mensagens precisam de acesso a uma chave privada. 
   \Na maioria dos casos, é esse sinalizador deve ser escolhido.
    devolvendo um número resultante. \Se a função for bem-sucedida, ela retornará um valor diferente de zero (VERDADEIRO).
    \Se a função falhar, ele retorna zero (FALSO).
  Se o número resultante for 0, atribua "Erro. Não foi possível adquirir o identificador do contêiner de chave do provedor de serviços criptográficos ." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
  \ criação do hash
  Call "advapi32.dll" "CryptCreateHash" com \https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptcreatehash
    \A função CryptCreateHash inicializa o hash de um fluxo de dados. 
    \Ele cria e retorna ao aplicativo de chamada um identificador para um objeto hash do provedor de serviços de criptografia (CSP).
    o HCRYPTPROV deste crypt session [hProv] \Um identificador para um CSP criado por uma chamada feita para a função CryptAcquireContext acima.
    e 32771 [Algid CALG_MD5]  \Um valor ALG_ID que identifica o algoritmo de hash a ser usado. 
    \O tipo de dados ALG_ID especifica um identificador de algoritmo. Os parâmetros desse tipo de dados são passados para a maioria das funções na CryptoAPI.
    \Os valores válidos para este parâmetro variam, dependendo do CSP usado.
    \CALG_MD5 é um Algoritmo de hash MD5. Este algoritmo é suportado pelo Microsoft Base Cryptographic Provider.
    e 0 [hKey] \A chave para o hash é passada neste parâmetro. Para algoritmos não chaveados, este parâmetro deve ser definido como zero.
    e 0 [dwFlags] \O seguinte valor de sinalizador é definido:
    \Valor CRYPT_SECRETDIGEST (0x00000001)  Significado: Este sinalizador não é usado.
    e o endereçamento deste HCRYPTHASH deste crypt session [*phHash] \O endereço para o qual a função copia um identificador para o novo objeto hash.
    devolvendo o número resultante. \Se a função for bem-sucedida, ela retornará TRUE.
    \Se a função falhar, ele retornará FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível criar o hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
  \ hash passphrase
  Call "advapi32.dll" "CryptHashData" com \https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-crypthashdata
    \A função CryptHashData adiciona dados a um objeto hash especificado. 
    \ Esta função e CryptHashSessionKey podem ser chamadas várias vezes para calcular o hash de fluxos de dados longos ou descontínuos.
    O HCRYPTHASH deste crypt session [hHash] \O número dentificador do objeto hash.
    e O first desta passphrase [*pbData] \Um ponteiro para um buffer que contém os dados a serem adicionados ao objeto hash.
    e A quantidade de caracteres desta passphrase [dwDataLen] \Número de bytes de dados a serem adicionados. 
    \Deve ser zero se o sinalizador CRYPT_USERDATA estiver definido.
    e 0 [dwFlags] \Todos os provedores criptográficos da Microsoft ignoram esse parâmetro. 
    \Para qualquer CSP que não ignore este parâmetro, se este sinalizador for definido, o CSP solicita que o usuário insira os dados diretamente. 
   \Esses dados são adicionados ao hash. O aplicativo não tem permissão para acessar os dados. 
    \Este sinalizador pode ser usado para permitir que o usuário insira um PIN no sistema.
    devolvendo o número resultante. \Se a função for bem-sucedida, o valor de retorno será TRUE.
    \Se a função falhar, o valor de retorno será FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível adicionar dados ao hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
 \ gera a chave da sessão criptográfica
  Call "advapi32.dll" "CryptDeriveKey" com  \https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey
  \A função CryptDeriveKey gera chaves de sessão criptográficas derivadas de um valor de dados base. 
  \Esta função garante que quando o mesmo provedor de serviços criptográficos (CSP) e algoritmos são usados, as chaves geradas a partir da mesma base de dados são idênticas. 
  \Os dados da base podem ser uma senha ou quaisquer outros dados do usuário.
    O HCRYPTPROV deste crypt session [hProv] \Um identificador HCRYPTPROV de um CSP criado por uma chamada para CryptAcquireContext.
    e 26625 [CALG_RC4  Stream Cipher Algid] \Uma estrutura ALG_ID que identifica o algoritmo de criptografia simétrica para o qual a chave deve ser gerada. 
    \Os algoritmos disponíveis provavelmente serão diferentes para cada CSP. 
    \Para obter mais informações sobre qual identificador de algoritmo é usado pelos diferentes provedores para as especificações de chave AT_KEYEXCHANGE e AT_SIGNATURE, consulte ALG_ID. 
    e O HCRYPTHASH deste crypt session [hBaseData] \Um identificador para um objeto hash que foi alimentado com os dados de base exatos.
    e 8388608 [dwFlags Key length: 128 bit]  \Especifica o tipo de chave gerada. Os tamanhos de uma chave de sessão podem ser definidos quando a chave é gerada. O tamanho da chave, representando o comprimento do módulo da chave em bits, é definido com os 16 bits superiores deste parâmetro. Assim, se uma chave de sessão RC4 de 128 bits deve ser gerada, o valor 0x00800000 é combinado com qualquer outro valor predefinido dwFlags com um operati bit a bit OR
    e O endereçamento deste hcryptkey desta crypt session  [phKey] \Um ponteiro para uma variável HCRYPTKEY para receber o endereço do identificador da chave recém-gerada.
    devolvendo o número resultante. \Se a função for bem-sucedida, o valor de retorno será TRUE.
    \Se a função falhar, o valor de retorno será FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível derivar a chave da sessão." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.

Etapas para que se crie um dyad:
  Aloque memória para o dyad.

Etapas para que se crie um event:
  Aloque memória para o event.

Etapas para que se crie uma font info usando um font:
  Crie a font info usando a font (basic data).
  Crie as font larguras desta font info usando a font.

Etapas para que se crie uma font info usando uma font (basic data):
  Aloque memória para a font info.
  Atribua a font ao font desta font info.
  Obtenha um OutlineTextmetric usando a font.
  Atribua 32 aos flags deste font info. \ poderia ser atualizado com mais uma informação
  Atribua o tmInternalLeading destes otmTextMetrics deste OutlineTextmetric ao internal leading desta font info.
  Atribua o otmEMSquare deste OutlineTextmetric ao emsquare desta font info.
  Atribua o tmAscent deste otmTextMetrics deste OutlineTextmetric ao ascent desta font info.
  Atribua - o tmDescent deste otmTextMetrics deste OutlineTextmetric ao descent desta font info.
  Atribua o otmsCapEmHeight deste OutlineTextmetric ao capheight desta font info.
  Atribua o otmItalicAngle deste OutlineTextmetric ao italicangle desta font info.
  Atribua 0 ao StemV desta font info. \ dont know where para obtenha this desde
  Atribua o otmrcFontBox deste OutlineTextmetric ao font caixa desta font info.

Etapas para que se crie uma font info usando uma font e uma string:
  \ cria larguras baseadas nos caracteres da string
  Crie a font info usando a font (basic data).
  Crie as font larguras desta font info usando a font e a string.

Etapas para que se crie umas font larguras usando um font:
  Aloque memória para a font larguras.
  Atribua a font à font destas font larguras.
  Atribua 256 à contagem destas font larguras.
  Assign o data destes font larguras usando a contagem destas font larguras times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando a font.
  Assign um original ABC endereço de memória usando 256 times a magnitude desse ABC.
  Call "gdi32.dll" "GetCharABCWidthsA" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsa
    \ A função GetCharABCWidths recupera as larguras, em unidades lógicas, de caracteres consecutivos em um intervalo especificado da fonte TrueType atual. 
    \ Esta função é só funciona com fontes TrueType.
    O memory canvas [hdc] \ Um identificador para o contexto do dispositivo.
    e 0 [wFirst] \ O primeiro caractere do grupo de caracteres consecutivos da fonte atual.
    e 255 [wLast] \O último caractere no grupo de caracteres consecutivos da fonte atual.
    e o original ABC endereço de memória. [lpABC] \ Um ponteiro para uma matriz de estruturas ABC que recebe as larguras dos caracteres, em unidades lógicas. 
    \Esta matriz deve conter, no mínimo, a mesma quantidade estruturas ABC que a quantidade de caracteres no intervalo especificado pelos parâmetros uFirstChar e uLastChar.
    \ Para obter mais informações, veja o site abaixo: 
    \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-ABC
  Destrua o número da fonte of o memory canvas.
  Atribua o original ABC endereço de memória a um ABC endereço de memória.
  Atribua o data destes font larguras a um endereço numérico.
  Percorra. [o código abaixo]
    Se um contador estiver past 256, pare.
    Atribua o abcA deste ABC endereço de memória ao conteúdo deste endereço numérico .
    Adicione o abcB deste ABC endereço de memória para o conteúdo deste endereço numérico .
    Adicione o abcC deste ABC endereço de memória para o conteúdo deste endereço numérico .
    Adicione a magnitude deste ABC para o ABC endereço de memória.
    Adicione a magnitude deste número para o endereço numérico.
  Repita. [o código acima]
  Unassign o original ABC endereço de memória.

Etapas para que se crie uns font larguras usando uma font e uma string:
  Aloque memória para a font larguras.
  Atribua a font à font destas font larguras.
  Atribua a quantidade de caracteres desta string à contagem destas font larguras.
  Se a string estiver em branco, cancele.
  Atribua a magnitude desse GcpResults ao lstructsize destes GcpResults.
  Atribua a quantidade de caracteres desta string ao nglyphs destes GcpResults.
  Assign o lpDX destes GcpResults usando a quantidade de caracteres desta string times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando a font.
  Call "gdi32.dll" "GetCharacterPlacementA" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementa
    \A função GetCharacterPlacement recupera informações sobre uma string de caracteres, tais como larguras de caracteres, posicionamento de circunflexo, ordenação dentro da string e renderização de glifo.
    \A função copia as informações para a estrutura GCP_RESULTS especificada ou para uma ou mais matrizes especificadas pela estrutura.
    \Embora essa função já tenha sido adequada para trabalhar com cadeias de caracteres, 
    \ a necessidade de trabalhar com um número crescente de linguagens e sistemas de escrita a tornou obsoleta. 
    \Ela foi substituído pela funcionalidade do módulo Uniscribe. Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/Intl/uniscribe
    O memory canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O first endereço de memória do pedaço desta string [lpString] \Um ponteiro para a sequência de caracteres a ser processada. 
    \A string acima não precisa ser terminada em zero, pois nCount especifica o comprimento da string.
    e A quantidade de caracteres desta string [nCount] \O comprimento da string apontada por lpString.
    e 0 [nMexExtent] \A extensão máxima (em unidades lógicas) na qual a string é processada. 
    \Os caracteres que, se processados, excederiam essa extensão são ignorados. 
     \Os cálculos para qualquer pedido obrigatório ou matrizes de glifos aplicam-se apenas aos caracteres incluídos. 
     \ Este parâmetro é usado apenas se o valor GCP_MAXEXTENT for especificado no parâmetro dwFlags.
     \ Conforme a função processa a string de entrada, cada caractere e sua extensão são adicionados à saída, à extensão e à outras matrizes
     \  apenas se a extensão total ainda não tiver excedido o máximo. Assim que o limite for atingido, o processamento será interrompido.
    e O endereçamento deste GcpResults [lpResults] \Um ponteiro para uma estrutura GCP_RESULTS que recebe os resultados da função.
    e 0. [dwFlags] \ serve para especificar como processar a string nas matrizes necessárias. nesse caso não foi especificado (valor nulo/ inválido)
  Destrua o número da fonte of o memory canvas.
  Atribua o lpDX destes GcpResults ao data destes font larguras.

Etapas para que se crie um gpBitmap usando um trecho:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "GlobalAlloc" com \https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalalloc
    \Aloca o número especificado de bytes do heap.
  2 [uFlags GMEM_MOVEABLE] \Os atributos de alocação de memória. Se zero for especificado, o padrão é GMEM_FIXED.
  \GMEM_MOVEABLE = 0x0002
   \Aloca memória móvel. Os blocos de memória nunca são movidos na memória física, mas podem ser movidos dentro do heap padrão.
    \O valor de retorno é um identificador para o objeto de memória. Para converter o identificador em um ponteiro, use a função GlobalLock.
    \Este valor não pode ser combinado com GMEM_FIXED.
    e A quantidade de caracteres deste trecho [dwBytes] \O número de bytes a serem alocados. 
    \Se este parâmetro for zero e o parâmetro uFlags especificar GMEM_MOVEABLE, 
    \a função retornará um identificador para um objeto de memória que está marcado como descartado.
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno será um identificador para o objeto de memória recém-alocado.
    \Se a função falhar, o valor de retorno será NULL. 
\A função GlobalLock bloqueia um objeto de memória global e aumenta a contagem de bloqueios em um. 
\A função GlobalUnlock o desbloqueia e diminui a contagem de bloqueios em um. 
\Para obter a contagem de bloqueios de um objeto de memória global, use a função GlobalFlags.
  Call "kernel32.dll" "GlobalLock" com \https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globallock
    \Bloqueia um objeto de memória global e retorna um ponteiro para o primeiro byte do bloco de memória do objeto.
    \Observação: As funções globais têm maior sobrecarga e fornecem menos recursos do que outras funções de gerenciamento de memória. 
    \Novos aplicativos devem usar as funções de heap, a menos que a documentação indique que uma função global deve ser usada.
    O número identificador [hMem] \Um identificador para o objeto de memória global. Nese caso o identificador é número identificador retornado pela função GlobalAlloc .
    devolvendo um endereço de memória. \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o primeiro byte do bloco de memória.
    \Se a função falhar, o valor de retorno será NULL.
\Observações
\As estruturas de dados internas para cada objeto de memória incluem uma contagem de bloqueio que é inicialmente zero. 
\Para objetos de memória móvel, GlobalLock aumenta a contagem em um e a função GlobalUnlock diminui a contagem em um. 
\Cada chamada bem-sucedida que um processo faz ao GlobalLock para um objeto deve ser correspondida por uma chamada correspondente ao GlobalUnlock. 
\A memória bloqueada não será movida ou descartada, a menos que o objeto de memória seja realocado usando a função GlobalReAlloc. 
\O bloco de memória de um objeto de memória bloqueado permanece bloqueado até que sua contagem de bloqueios diminua para zero, momento em que pode ser movido ou descartado.
  Copie pedaços desde o first endereço de memória do pedaço deste trecho para o endereço de memória pelo quantidade de caracteres deste trecho.
  Call "kernel32.dll" "GlobalUnlock" com \https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalunlock
    \Diminui a contagem de bloqueios associada a um objeto de memória que foi alocado com GMEM_MOVEABLE. Esta função não tem efeito em objetos de memória alocados com GMEM_FIXED.
    O número identificador. [hMem] \Um identificador para o objeto de memória global. Nese caso o identificador é número identificador retornado pela função GlobalAlloc .
    \Se o objeto de memória ainda estiver bloqueado após diminuir a contagem de bloqueios, o valor de retorno será um valor diferente de zero. 
    \Se o objeto de memória for desbloqueado após diminuir a contagem de bloqueios, a função retornará zero e GetLastError retornará 0 (NO_ERROR).
    \Um processo não deve depender do valor de retorno para determinar o número de vezes que ele deve subsequentemente chamar GlobalUnlock para um objeto de memória.
  Call "ole32.dll" "CreateStreamOnHGlobal" com \https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-createstreamonhglobal
    \A função CreateStreamOnHGlobal cria um objeto de fluxo que usa um identificador de memória HGLOBAL para armazenar o conteúdo do fluxo. 
    \Este objeto é a implementação da interface IStream fornecida por OLE.
    \O objeto de fluxo retornado oferece suporte para leitura e gravação, não é transacionado e não oferece suporte para bloqueio de região. 
    \O objeto chama a função GlobalReAlloc para aumentar o bloco de memória conforme necessário.
    \Dica: Considere o uso da função SHCreateMemStream, que produz melhor desempenho,
    O número identificador [hGlobal] \Um identificador de memória alocado pela função GlobalAlloc ou, se NULL, um novo identificador deve ser alocado. 
    \O identificador deve ser alocado como móvel e não descartável.
    e 1 [fDeleteOnRelease = TRUE] \Um valor que indica se o identificador subjacente para este objeto de fluxo deve ser liberado automaticamente quando o objeto de fluxo é liberado. 
    \Se definido como FALSE, o chamador deve liberar o hGlobal após a versão final. 
    \Se definido como TRUE, a versão final irá liberar automaticamente o identificador subjacente.
    e O endereçamento desse istream. [*ppstm] \O endereço da variável de ponteiro IStream*  (LPSTREAM) que recebe o ponteiro de interface para o novo objeto de fluxo. Seu valor não pode ser NULL.
    \Observações
    \Se hGlobal for NULL, a função aloca um novo identificador de memória e o fluxo está inicialmente vazio.
    \Se hGlobal não for NULL, o conteúdo inicial do fluxo será o conteúdo atual do bloco de memória. 
    \Portanto, CreateStreamOnHGlobal pode ser usado para abrir um fluxo existente na memória. 
    \O identificador de memória e seu conteúdo não são perturbados pela criação do novo objeto de fluxo.
    \O tamanho inicial do fluxo é o tamanho de hGlobal conforme retornado pela função GlobalSize. 
    \Por causa do arredondamento, este não é necessariamente o mesmo tamanho que foi originalmente alocado para o identificador.
  Call "gdiplus.dll" "GdipCreateBitmapFromStream" com 
    O istream [stream] \Ponteiro para uma interface IStream COM.
    e O endereçamento deste gpBitmap [**bitmap] \Ponteiro para uma variável DWORD (endereçamento) que recebe um ponteiro para um objeto Bitmap (o gpBitmap).
    devolvendo um número.
  Se o número não for 0, atribua "Não sei como processar este tipo de imagem." ao erro do fluxo de entrada/saída; esvazie o gpBitmap.
  Call o release deste vtable deste istream com o istream.

Etapas para que se crie um GpImageAttributes (escala de cinza):
  Call "gdiplus.dll" "GdipCreateImageAttributes" com 
    \Um objeto ImageAttributes contém informações sobre como as cores de bitmap e metarquivo são manipuladas durante a renderização.
    O endereçamento destes GpImageAttributes. [**imageattr] \Ponteiro para uma variável (GpImageAttributes).
    \Essa variável contém um ponteiro para o objeto ImageAttributes. 
    \( ou seja, o número identificador do objeto ImageAttributes)
  Call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" com 
    O GpImageAttributes [ imageattr] \Ponteiro para o objeto ImageAttributes.
   e 0 [type = ColorAdjustTypeDefault ] \Elemento da enumeração ColorAdjustType que especifica a categoria para a qual a matriz de ajuste de cor é definida. O valor padrão é ColorAdjustTypeDefault.
   e 1 [enableFlag] \Valor booleano que especifica se um ajuste de cor separado está habilitado para a categoria especificada pelo parâmetro type (ColorAdjustTypeDefault).
   e o first desta matriz de tons de cinza [colorMatrix] \Ponteiro para uma matriz 5x5 de ajuste de cor .
   e 0 [grayMatrix] \Especifica uma matriz a ser usada para ajustar os tons de cinza quando o valor do parâmetro flags é igual ColorMatrixFlagsAltGray.
   e 0 [flags = ColorMatrixFlagsDefault]. \Elemento da enumeração ColorMatrixFlags que especifica o tipo de imagem e a cor que serão afetados pela matriz de ajuste de cor.

Etapas para que se crie o HBRUSH of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor for clear, atribua o null HBRUSH a um HBRUSH.
  Se a cor não for clear, Call "gdi32.dll" "CreateSolidBrush" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createsolidbrush
    \A função CreateSolidBrush cria um pincel lógico que possui a cor sólida especificada.
    O código da cor [color] \A cor do pincel. Para criar um valor de cor COLORREF, use a macro RGB.
    devolvendo o HBRUSH. \Se a função for bem-sucedida, o valor de retorno identifica um pincel lógico.
    \Se a função falhar, o valor de retorno será NULL.
    \Um pincel sólido é um bitmap que o sistema usa para pintar o interior de formas preenchidas.
     \Depois que um aplicativo cria um pincel chamando CreateSolidBrush, ele pode selecionar esse pincel em qualquer contexto de dispositivo chamando a função SelecionarObjeto
  Call "gdi32.dll" "SelectObject" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O HBRUSH. [h] \Um identificador para o objeto a ser selecionado.

Etapas para que se crie o número da fonte of um canvas usando um font:
  Converta a font para um número da fonte.
  Call "gdi32.dll" "SelectObject" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O número da fonte. [h] \Um número identificador para o objeto a ser selecionado.

Etapas para que se crie o hpen of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor estiver clear, atribua o null hpen a um hpen.
  Atribua a quantidade de twips/pixel times o grossura do pincel a um número.
  Se o canvas for a área de impressão, atribua 1 pixel times o grossura do pincel ao número.
  Se a cor não estiver clear, Call "gdi32.dll" "CreatePen" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpen
  \A função CreatePen cria uma caneta lógica que possui o estilo, largura e cor especificados. 
  \A caneta pode ser posteriormente selecionada em um contexto de dispositivo e usada para desenhar linhas e curvas.
    0 [iStyle = PS_SOLID]  \O estilo da caneta. PS_SOLID = A linha da caneta é "sólida" (sem traços ou pontilhados).
    e O número [cWidth] \A largura da caneta, em unidades lógicas. Se nWidth é zero, a caneta tem um único pixel de largura, independentemente da transformação atual.
    e O código da cor [color]  \Uma referência de cor para a cor da caneta. Para gerar uma estrutura COLORREF, use a macro RGB.
    devolvendo o hpen. \Se a função for bem-sucedida, o valor de retorno é um identificador que identifica uma caneta lógica.
    \Se a função falhar, o valor de retorno será NULL.
     \Depois que um aplicativo cria uma caneta lógica, ele pode selecionar essa caneta em um contexto de dispositivo chamando a função SelecionarObjeto. 
      \Depois que uma caneta é selecionada em um contexto de dispositivo, ela pode ser usada para desenhar linhas e curvas.
  Call "gdi32.dll" "SelectObject" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O hpen. [h] \Um número identificador para o objeto a ser selecionado.

Etapas para que se crie um hRgn usando uma caixa:
  Isole a caixa.
  Adicione a quantidade de twips/pixel para o canto inferior direito desta caixa.
  Call "gdi32.dll" "BeginPath" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-beginpath
  \A função BeginPath abre um suporte de caminho no contexto de dispositivo especificado.
    O quadro atual.[hdc] \Um identificador para o contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "Rectangle" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-rectangle
  \A função Retângulo desenha um retângulo. O retângulo é delineado com a caneta (pincel) atual e preenchido com o pincel (brush) atual.
    O quadro atual [hdc] \Um identificador para o contexto do dispositivo.
    e A coordenada X do canto superior esquerdo desta caixa [left] \A coordenada X, em coordenadas lógicas, do canto superior esquerdo do retângulo.
    e A coordenada Y do canto superior esquerdo desta caixa [top] \A coordenada Y, em coordenadas lógicas, do canto superior esquerdo do retângulo.
    e A coordenada X do canto inferior direito desta caixa [right] \A coordenada X, em coordenadas lógicas, do canto inferior direito do retângulo.
    e A coordenada Y do canto inferior direito desta caixa.[bottom] \A coordenada Y, em coordenadas lógicas, do canto inferior direito do retângulo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
    Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual devolvendo o hRgn.

Etapas para que se crie um hRgn usando um elipse:
  Atribua a caixa desta elipse a uma caixa.
  Call "gdi32.dll" "BeginPath" com 
    O quadro atual.
  Call "gdi32.dll" "Ellipse" com 
    O quadro atual 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A coordenada X do canto inferior direito desta caixa 
    e A coordenada Y do canto inferior direito desta caixa.
  Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual 
    devolvendo o hRgn.

Etapas para que se crie um hRgn usando um polígono:
  Se o polígono for inexistente, atribua 0 ao hRgn; volte.
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e A localização endereço de memória deste vértice array 
    e A contagem deste vértice array.
  Call "gdi32.dll" "CreatePolygonRgn" com  \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn
    A localização endereço de memória deste vértice array 
    e A contagem deste vértice array 
    e 2 [WINDING]  \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn#parameters
    devolvendo o hRgn.
  Destrua o vértice array.

Etapas para que se crie um hRgn usando uma caixa arredondada:
  Se o raio desta caixa arredondada for 0, crie o hRgn usando a caixa arredondada como uma caixa; volte.
  Atribua a caixa arredondada a uma caixa.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "BeginPath" com 
    O quadro atual.
  Call "gdi32.dll" "RoundRect" com 
    O quadro atual 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A coordenada X do canto inferior direito desta caixa 
    e A coordenada Y do canto inferior direito desta caixa 
    e O diameter 
    e O diameter.
  Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual 
    devolvendo o hRgn.

Etapas para que se crie um catálogo usando uma contagem de buckets:
  Aloque memória para o catálogo.
  Atribua a contagem de buckets à contagem de buckets deste catálogo.
  Atribua o magnitude desse conjunto de buckets a um largura.
  Atribua a contagem de buckets deste catálogo times a largura a um número.
  Assign o first bucket deste catálogo usando o número.
  Atribua o first bucket deste catálogo mais o número menos a largura ao last bucket deste catálogo.

Etapas para que se crie o dicionário léxico:
  Aloque memória para o dicionário léxico.
  Crie o catálogo deste dicionário léxico usando 4027.

Etapas para que se crie o abra handle of um requisição WinHTTP:
  Se o requisição WinHTTP for inexistente, cancele.
  Converta o nome deste module para um wide string denominado wide module nome e termine com o caractere NULL.
  Call "WinHTTP.dll" "WinHttpOpen" com 
    O first endereço de memória do pedaço deste wide module nome 
    e 0 [WINHTTP_ACCESS_TYPE_DEFAULT_PROXY] 
    e 0 [WINHTTP_NO_PROXY_NAME] 
    e 0 [WINHTTP_NO_PROXY_BYPASS] 
    e 0 
    devolvendo o número identificador de sessão desta número identificador de requisição deste WinHTTP.
  Se a session desta número identificador de requisição deste WinHTTP for 0, atribua "Erro. Não foi possível iniciar a conexão." ao erro do fluxo de entrada/saída; volte.

Etapas para que se crie um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, crie o endereço completo no sistema de arquivos (pasta)[endereço]; volte.
  Se o endereço completo for file-format, crie o endereço completo no sistema de arquivos (arquivo); volte.

Etapas para que se crie um endereço completo no sistema de arquivos (pasta)[endereço]:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateDirectoryA" com 
    O first deste endereço completo 
    e 0 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível criar a seguinte pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se crie um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com 
    O first deste endereço completo 
    e 1073741824 [GENERIC_WRITE] 
    e 0 
    e 0 
    e 1 [CREATE_NEW] 
    e 128 [FILE_ATTRIBUTE_NORMAL] 
    e 0 
    devolvendo um número identificador.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador.
  Limpe o erro do fluxo de entrada/saída.
  Se o número identificador não for -1 [INVALID_HANDLE_VALUE], cancele.
  Atribua "Erro. Não foi possível criar o seguinte arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se crie um imagem:
  Aloque memória para a imagem.

Etapas para que se crie um imagem usando um trecho:
  Crie um gpBitmap usando o trecho.
  Se o gpBitmap for inexistente, esvazie a imagem; volte.
  Aloque memória para a imagem.
  Atribua o trecho ao data desta imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).

Etapas para que se crie um imagem usando um gpBitmap:
  Se o gpBitmap for inexistente, esvazie a imagem; volte.
  Aloque memória para a imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).

Etapas para que se crie um imagem usando uma URL:
  Read o URL a um trecho.
  Crie a imagem usando o trecho.

Etapas para que se crie um polígono:
  Aloque memória para o polígono.

Etapas para que se crie um quora:
  Aloque memória para o quora.

Etapas para que se crie um refer:
  Aloque memória para o refer.

Etapas para que se crie o request handle of um requisição WinHTTP using uma URL simplificada:
  Se o requisição WinHTTP for inexistente, cancele.
  Converta o endereço de recurso desta URL simplificada a um wide string denominado wide endereço completo e termine com o caractere NULL.
  Converta "POST" para um wide string denominado wide post string e termine com o caractere NULL.
  Se o nome do protocolo desta URL simplificada for "https", atribua 8388608 [WINHTTP_FLAG_SECURE] a um secure número.
  Call "WinHTTP.dll" "WinHttpOpenRequest" com 
    O número identificador de conexão deste requisição WinHTTP 
    e O first deste wide post string 
    e O first deste wide endereço completo 
    e 0 [L"HTTP/1.1"] 
    e 0 [WINHTTP_NO_REFERER] 
    e 0 [WINHTTP_DEFAULT_ACCEPT_TYPES] 
    e O secure número 
    devolvendo o número identificador de requisição deste requisição WinHTTP.
  Se o número identificador de requisição deste requisição WinHTTP for 0, atribua "Erro ao chamar a função 'WinHttpOpenRequest' da biblioteca 'WinHTTP.dll'. Não foi possível abrir a requisição." ao erro do fluxo de entrada/saída; volte.

Etapas para que se crie uma row usando um pedaço:
  Aloque memória para a row.
  Atribua o pedaço à string deste row.

Etapas para que se crie uma row usando uma string:
  Aloque memória para a row.
  Atribua a string à string deste row.

Etapas para que se crie um socket usando um host string e um número de porta:
  \ esta rotina cria, conecta e define o erro se houver um problema
  Limpe o erro do fluxo de entrada/saída.
  \ obtém o sockaddr
  Obtenha um sockaddr usando o host.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua 2 [AF_INET ] ao sin_family deste sockaddr.
  Atribua o port ao sin_port deste sockaddr.
  \ cria o socket 
  Call "ws2_32.dll" "socket" com \https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket
  \A função de soquete cria um soquete que está vinculado a um provedor de serviços de transporte específico.
    2 [af AF_INET ]  
    \ A família de endereços para o endereço de transporte. AF_INET é usado para endereços ipv4
    e 1 [type SOCK_STREAM ]  
    \Um tipo de soquete que fornece fluxos de bytes sequenciados, confiáveis, bidirecionais e baseados em conexão com um mecanismo de transmissão de dados OOB. 
    \Este tipo de soquete usa o TCP para a família de endereços da Internet
    e 0 [protocol IPPROTO_IP]  
   \O protocolo a ser usado. Se um valor de 0 for especificado, o chamador não deseja especificar um protocolo e o provedor de serviços escolherá o protocolo a ser usado.
   \Normalmente, existe apenas um único protocolo para oferecer suporte a um determinado tipo de soquete dentro de uma determinada família de protocolos; nesse caso, o protocolo pode ser especificado como 0.
    devolvendo o socket. \WSAAPI 
  Se o socket for -1 [INVALID_SOCKET ], atribua "Erro. Não foi possível criar o soquete." ao erro do fluxo de entrada/saída; volte.
  \ connect socket
  Call "ws2_32.dll" "connect" com \https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect
  \A função connect estabelece uma conexão com um soquete especificado.
    O socket [s] \Um descritor que identifica um soquete não conectado.
    e O endereçamento deste sockaddr [*name] \Um ponteiro para a estrutura sockaddr com a qual a conexão deve ser estabelecida.
    e A magnitude deste sockaddr [namelen] \O comprimento, em bytes, da estrutura sockaddr apontada pelo parâmetro name.
    devolvendo um número resultante.
  Se o número resultante não for 0 [SOCKET_ERROR], atribua "Erro. Falha na conexão com o soquete." ao erro do fluxo de entrada/saída; volte.
  \ abra send timeout 30 seconds
  Call "ws2_32.dll" "setsockopt" com \https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-setsockopt
  \A função setsockopt define uma opção de socket.
    O socket [s] \Um descritor que identifica um soquete.
    e 65535 [level] \O nível em que a opção é definida (por exemplo, SOL_SOCKET).
    e 4101 [optname SO_SNDTIMEO 0x00001005]  \A opção de soquete para a qual o valor deve ser definido (por exemplo, SO_BROADCAST). 
    \O parâmetro optname deve ser uma opção de soquete definida dentro do nível especificado, ou o comportamento é indefinido.
    \O tempo limite, em milissegundos, para bloquear chamadas enviadas.
    e 30 seconds' endereçamento [*optval] \Um ponteiro para o buffer no qual o valor da opção solicitada é especificado.
    e 4 [optlen] \O tamanho, em bytes, do buffer apontado pelo parâmetro optval.
    devolvendo o número resultante.
  Se o número resultante não for 0 [SOCKET_ERROR ], atribua "Erro na função 'setsockopt' da biblioteca 'Ws2_32.dll'. Valor do parâmetro optname: SO_SNDTIMEO (4101)." ao erro do fluxo de entrada/saída; volte.
  \ abra receive timeout 30 seconds
  Call "ws2_32.dll" "setsockopt" com 
    O socket 
    e 65535 
    e 4102 [optname SO_RCVTIMEO  0x00001006]    \Define o tempo limite, em milissegundos, para bloquear chamadas recebidas.
    e 30 seconds' endereçamento e 
    4 
    devolvendo o número resultante.
  Se o número resultante não for 0, atribua "Erro na função 'setsockopt' da biblioteca 'Ws2_32.dll'. Não foi possível definir o tempo limite de recepção. Valor do parâmetro optname: SO_RCVTIMEO (4102) ." ao erro do fluxo de entrada/saída; volte.

Etapas para que se crie um conjunto de texto usando uma string:
  Aloque memória para o conjunto de texto.
  Atribua a string à string deste conjunto de texto.

Etapas para que se crie um terminal em uma caixa:
  Aloque memória para o terminal.
  Atribua a caixa à caixa deste terminal.
  Atribua a cor verde ao output cor deste terminal.
  Atribua a cor verde claríssimo ao input cor deste terminal.

Etapas para que se crie um text:
  Aloque memória para o text.
  Atribua a cor preta ao pincel deste text.
  Atribua a fonte padrão ao font deste text.
  Atribua "left" ao alinhamento deste text.
  Atribua 1/1 à scale deste text.
  Garanta one row no text.
  Reset a origem of o text.
  Reset o caret of o text.
  Desvencilhe-se de o text.

Etapas para que se crie um vértice:
  Aloque memória para o vértice.

Etapas para que se crie um vértice array usando uma contagem:
  Isole a contagem.
  Aloque memória para o vértice array.
  Atribua a contagem à contagem deste vértice array.
  Multiplique a contagem pela magnitude desse localização.
  Assign a localização endereço de memória deste vértice array usando a contagem.

Etapas para que se crie um vértice array usando uns vértices:
  Crie o vértice array usando a contagem destes vértices.
  Atribua a localização endereço de memória deste vértice array a uma localização endereço de memória.
  Percorra. [o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Atribua a localização deste vértice ao conteúdo desta localização endereço de memória.
    Adicione a magnitude desta localização deste vértice para a localização endereço de memória.
  Repita. [o código acima]

Etapas para que se crie um vértice usando uma localização:
  Aloque memória para o vértice.
  Atribua a localização à localização deste vértice.

Etapas para que se crie um vértice usando uma coordenada X e uma coordenada Y:
  Aloque memória para o vértice.
  Atribua a coordenada X à coordenada X deste vértice.
  Atribua a coordenada Y à coordenada Y deste vértice.

Etapas para que se crie um requisição WinHTTP por posting para uma URL:
  Aloque memória para o requisição WinHTTP.
  Converta o URL para uma URL simplificada.
  Crie o abra handle of o requisição WinHTTP.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o requisição WinHTTP; volte.
  Crie o connect handle of o requisição WinHTTP using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o requisição WinHTTP; volte.
  Crie o request handle of o requisição WinHTTP using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o requisição WinHTTP; volte.

O console é um console.

O quadro atual é um canvas.

O evento atual é um event.

Um cursor é um número identificador.

Etapas para que se corte um número pela metade:
  Divida o número por 2.

Um date/time é um conjunto com
  Um year número,
  Um month número,
  Um week day número,
  Um day número,
  Um hour número,
  Um minute número,
  Um second número,
  Um millisecond número.

Etapas para que se de-sign um fração:
  De-sign o numerador desta fração.
  De-sign o denominador desta fração.

Etapas para que se de-sign um número:
  Se o número for o menor número, atribua o maior número ao número; volte.
  Se o número for menor do que 0, negate o número.

Etapas para que se de-sign um par de números:
  De-sign o número X deste par de números.
  De-sign o número Y deste par de números.

Etapas para que se de-sign uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço desta string for tipo de sinal aritmético, remove o first pedaço desde a string.

Um relatório é uma string.
Um relatório de informações é uma string.
Um relatório de bugs é uma string.
Um relatório de erros é uma string.
Um relatório de falhas é uma string.
Um relatório de panes é uma string.

Etapas para que se produza o relatório de bugs usando uma caixa;
Etapas para que se produza o relatório de falhas usando uma caixa;
Etapas para que se produza o relatório de panes usando uma caixa;
Etapas para que se produza o relatório de erros usando uma caixa;
Etapas para que se produza o relatório de informações usando uma caixa:
  Limpe um relatório.
  Posponha "Coordenada esquerda = " para o relatório.
  Posponha a coordenada X do canto superior esquerdo desta caixa para o relatório.
  Posponha ", Coordenada superior = " para o relatório.
  Posponha a coordenada Y do canto superior esquerdo desta caixa para o relatório.
  Posponha ", Coordenada direita = " para o relatório.
  Posponha a coordenada X do canto inferior direito desta caixa para o relatório.
  Posponha ", Coordenada inferior = " para o relatório.
  Posponha a coordenada Y do canto inferior direito desta caixa para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um pedaço;
Etapas para que se produza o relatório de falhas usando um pedaço;
Etapas para que se produza o relatório de panes usando um pedaço;
Etapas para que se produza o relatório de bugs usando um pedaço;
Etapas para que se produza o relatório de informações usando um pedaço:
  Atribua o pedaço a um número.
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma cor;
Etapas para que se produza o relatório de falhas usando uma cor;
Etapas para que se produza o relatório de panes usando uma cor;
Etapas para que se produza o relatório de bugs usando uma cor;
Etapas para que se produza o relatório de informações usando uma cor:
  Limpe um relatório.
  Posponha "Matiz = " para o relatório.
  Posponha a matiz desta cor para o relatório.
  Posponha ", Saturação = " para o relatório.
  Posponha a saturação desta cor para o relatório.
  Posponha ", Luminosidade = " para o relatório.
  Posponha a luminosidade desta cor para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um detector;
Etapas para que se produza o relatório de falhas usando um detector;
Etapas para que se produza o relatório de panes usando um detector;
Etapas para que se produza o relatório de bugs usando um detector;
Etapas para que se produza o relatório de informações usando um detector:
  Converta o detector para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de bugs usando uma font;
Etapas para que se produza o relatório de erros usando uma font;
Etapas para que se produza o relatório de falhas usando uma font;
Etapas para que se produza o relatório de panes usando uma font;
Etapas para que se produza o relatório de informações usando uma font:
  Limpe um relatório.
  Posponha " Nome da fonte = '" para o relatório seguido de "'".
  Posponha o nome desta font para o relatório.
  Posponha ", Tamanho da fonte = " para o relatório.
  Posponha a altura desta font para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma fração;
Etapas para que se produza o relatório de falhas usando uma fração;
Etapas para que se produza o relatório de panes usando uma fração;
Etapas para que se produza o relatório de bugs usando uma fração;
Etapas para que se produza o relatório de informações usando uma fração:
  Limpe um relatório.
  Posponha "Numerador = " para o relatório.
  Posponha o numerador desta fração para o relatório.
  Posponha ", Denominador = " para o relatório.
  Posponha o denominador desta fração para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de bugs usando uma linha reta;
Etapas para que se produza o relatório de falhas usando uma linha reta;
Etapas para que se produza o relatório de panes usando uma linha reta;
Etapas para que se produza o relatório de erros usando uma linha reta;
Etapas para que se produza o relatório de informações usando uma linha reta:
  Limpe um relatório.
  Posponha " Começo da linha = " para o relatório.
  Posponha a coordenada X desta localização inicial desta linha reta para o relatório.
  Posponha "," para o relatório.
  Posponha a coordenada Y desta localização inicial desta linha reta para o relatório.
  Posponha " Fim da linha = " para o relatório.
  Posponha a coordenada X desta localização final desta linha reta para o relatório.
  Posponha "," para o relatório.
  Posponha a coordenada Y desta localização final desta linha reta para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de falhas usando um número;
Etapas para que se produza o relatório de panes usando um número;
Etapas para que se produza o relatório de erros usando um número;
Etapas para que se produza o relatório de bugs usando um número;
Etapas para que se produza o relatório de informações usando um número:
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um número e um segundo número;
Etapas para que se produza o relatório de falhas usando um número e um segundo número;
Etapas para que se produza o relatório de panes usando um número e um segundo número;
Etapas para que se produza o relatório de bugs usando um número e um segundo número;
Etapas para que se produza o relatório de informações usando um número e um segundo número:
  Produza o relatório de informações usando o número seguido de ", " junto com o segundo número.

Etapas para que se produza o relatório de falhas usando um par de números;
Etapas para que se produza o relatório de panes usando um par de números;
Etapas para que se produza o relatório de erros usando um par de números;
Etapas para que se produza o relatório de bugs usando um par de números;
Etapas para que se produza o relatório de informações usando um par de números:
  Limpe um relatório.
  Posponha "Coordenada X = " para o relatório.
  Posponha o número X deste par de números para o relatório.
  Posponha ", Coordenada Y = " para o relatório.
  Posponha o número Y deste par de números para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de panes usando um endereço de memória;
Etapas para que se produza o relatório de falhas usando um endereço de memória;
Etapas para que se produza o relatório de erros usando um endereço de memória;
Etapas para que se produza o relatório de bugs usando um endereço de memória;
Etapas para que se produza o relatório de informações usando um endereço de memória:
  Converta o endereço de memória para um cifra hexadecimal.
  Produza o relatório de informações usando "$" junto com o cifra hexadecimal.
  Produza o relatório de informações usando "0x" junto com o cifra hexadecimal.

Etapas para que se produza o relatório de panes usando um espaço de cor RGB;
Etapas para que se produza o relatório de falhas usando um espaço de cor RGB;
Etapas para que se produza o relatório de erros usando um espaço de cor RGB;
Etapas para que se produza o relatório de bugs usando um espaço de cor RGB;
Etapas para que se produza o relatório de informações usando um espaço de cor RGB:
  Limpe um relatório.
  Posponha "Vermelho = " para o relatório. Atribua o espectro vermelho deste espaço de cor RGB a um número.
  Posponha o número para o relatório.
  Posponha ", Verde = " para o relatório. Atribua o espectro verde deste espaço de cor RGB ao número.
  Posponha o número para o relatório.
  Posponha ", Azul = " para o relatório. Atribua o espectro azul deste espaço de cor RGB ao número.
  Posponha o número para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de falhas usando um relatório;
Etapas para que se produza o relatório de panes usando um relatório;
Etapas para que se produza o relatório de erros usando um relatório;
Etapas para que se produza o relatório de bugs usando um relatório;
Etapas para que se produza o relatório de informações usando um relatório:
  Isole o relatório.
  Termine com o caractere NULL o relatório.
  Atribua "Detalhes: " a um relatório de erros.
  Call "user32.dll" "MessageBoxA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa
  \Exibe uma caixa de diálogo modal que contém um ícone do sistema, um conjunto de botões e uma breve mensagem específica do aplicativo, como status ou informações de erro. 
  \A caixa de mensagem retorna um valor inteiro que indica em qual botão o usuário clicou.
    0 [hWnd] \Um identificador para a janela do proprietário da caixa de mensagem a ser criada. 
    \Se este parâmetro for 0 [NULL], a caixa de mensagem não terá janela do proprietário.
    e O first endereço de memória do pedaço deste relatório [lpText] \A mensagem a ser exibida. 
    \Se a string consistir em mais de uma linha, você pode separar as linhas usando um retorno de carro e / ou um caractere de avanço de linha entre cada linha.
    e O first endereço de memória do pedaço deste relatório de erros [lpCaption] \ O título da caixa de diálogo. Se este parâmetro for NULL, o título padrão é Erro.
    e 0. [uType] \O conteúdo e o comportamento da caixa de diálogo. Quando o valor é igual a 0 a caixa de mensagem contém apenas um botão: OK. Este é o  valor padrão.
  \  Chame função "MessageBoxA" contida na biblioteca "user32.dll" informando os parâmetros a seguir: 0, o primeiro caractere do texto em questão, o primeiro caractere de "debug" e 0.

Etapas para que se produza o relatório de erros usando um relatório (com aspas);
Etapas para que se produza o relatório de panes usando um relatório (com aspas);
Etapas para que se produza o relatório de falhas usando um relatório (com aspas);
Etapas para que se produza o relatório de bugs usando um relatório (com aspas);
Etapas para que se produza o relatório de informações usando um relatório (com aspas):
  Isole o relatório.
  Anteponha as aspas duplas para o relatório.
  Posponha as aspas duplas para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma word;
Etapas para que se produza o relatório de panes usando uma word;
Etapas para que se produza o relatório de falhas usando uma word;
Etapas para que se produza o relatório de bugs usando uma word;
Etapas para que se produza o relatório de informações usando uma word:
  Atribua o word a um número.
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se determine se uma caixa é uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta caixa não for a coordenada X do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta caixa não for a coordenada Y do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada X do canto inferior direito desta caixa não for a coordenada X do canto inferior direito desta segunda caixa, diga não.
  Se a coordenada Y do canto inferior direito desta caixa não for a coordenada Y do canto inferior direito desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa está still em uma segunda caixa;
Etapas para que se determine se uma caixa está em uma segunda caixa;
Etapas para que se determine se uma caixa está inside uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, diga não.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa está touching uma segunda caixa:
  Se a coordenada X do canto inferior direito desta segunda caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y do canto inferior direito desta segunda caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada X do canto superior esquerdo desta segunda caixa for maior do que a coordenada X do canto inferior direito desta caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta segunda caixa for maior do que a coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é alfanumérico:
  Se o pedaço for algum tipo de letra, diga sim.
  Se o pedaço for algum tipo de digit, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é um segundo pedaço ou um terceiro pedaço:
  Se o pedaço for o segundo pedaço, diga sim.
  Se o pedaço for o terceiro pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é alguma consoante:
  Se o pedaço estiver em "bcdfghjklmnpqrstvwxyzçñ", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de digit:
  Se o pedaço for menor do que o número zero, diga não.
  Se o pedaço for maior do que o número nove, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é algum tipo de letra:
  Se o pedaço estiver entre o 'A' maiúsculo e o Z maiúsculo, diga sim.
  Se o pedaço estiver entre o 'a' minúsculo e o z minúsculo, diga sim.
  Se o pedaço for 131 ou 138, diga sim.
  Se o pedaço for 140 ou 142, diga sim.
  Se o pedaço for 154 ou 156, diga sim.
  Se o pedaço estiver entre 158 e 159, diga sim.
  Se o pedaço estiver entre 192 e 214, diga sim.
  Se o pedaço estiver entre 216 e 246, diga sim.
  Se o pedaço estiver entre 248 e 255, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de indicador numérico:
  Se o pedaço é algum tipo de digit, diga sim.
  Se o pedaço é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de sinal de pontuação:
  \ precisa ser aprimorado
  Se o pedaço for o caractere de espaço, diga não.
  Se o pedaço não for alfanumérico, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é tipo de sinal aritmético:
  Se o pedaço for o sinal de adição, diga sim.
  Se o pedaço for o sinal de subtração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de unidade de disco válida:
  Atribua o pedaço a um endereço completo.
  Posponha ":\" para o endereço completo.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Se a categoria da unidade de disco for "", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é algum tipo de vogal:
  Se o pedaço estiver em "aeiouyáéíóúýãõäëïöüÿâêîôûàèìòù", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço está entre um segundo pedaço e um terceiro pedaço:
  Se o pedaço for menor do que o segundo pedaço, diga não.
  Se o pedaço for maior do que o terceiro pedaço, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço está entre um número e um segundo número:
  Se o pedaço for menor do que o número, diga não.
  Se o pedaço for maior do que o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço estiver em uma string:
  Isole o pedaço.
  Lowercase o pedaço.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga não.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um segundo pedaço.
    Lowercase o segundo pedaço.
    Se o segundo pedaço for o pedaço, diga sim.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se um pedaço é like um segundo pedaço:
  \ used internally para palavra wrap
  Se o pedaço for whitespace, acione um detector.
  Se o segundo pedaço for whitespace, acione um segundo detector.
  Se o detector for o segundo detector, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é irrelevante:
  Se o pedaço for menor do que ou igual ao caractere de espaço, diga sim.
  Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga sim.
  Se o pedaço for o espaço rígido, diga sim.
  Se o pedaço for 129, diga sim.
  Se o pedaço for 141, diga sim.
  Se o pedaço for 143, diga sim.
  Se o pedaço for 144, diga sim.
  Se o pedaço for 157, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é um número ou um segundo número:
  Se o pedaço for o número, diga sim.
  Se o pedaço for o segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é imprimível:
  Se o pedaço for menor do que o caractere de espaço, diga não.
  Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga não.
  Se o pedaço for 129, diga não.
  Se o pedaço for 141, diga não.
  Se o pedaço for 143, diga não.
  Se o pedaço for 144, diga não.
  Se o pedaço for 157, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é uma string:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Isole o pedaço.
  Lowercase o pedaço.
  Atribua o conteúdo deste first endereço de memória do pedaço desta string a um segundo pedaço.
  Lowercase o segundo pedaço.
  Se o pedaço for o segundo pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é symbolic:
  Se o pedaço estiver entre o ponto de exclamação e o slash pedaço, diga sim.
  Se o pedaço estiver entre o sinal de dois pontos e o sinal de arroba, diga sim.
  Se o pedaço estiver entre o colchete esquerdo e o acento grave, diga sim.
  Se o pedaço estiver entre o chave esquerda e o acento til, diga sim.
  Se o pedaço for 128, diga sim.
  Se o pedaço for 130, diga sim.
  Se o pedaço estiver entre 132 e 137, diga sim.
  Se o pedaço for 139, diga sim.
  Se o pedaço estiver entre 145 e 153, diga sim.
  Se o pedaço for 155, diga sim.
  Se o pedaço estiver entre 161 e 180, diga sim.
  Se o pedaço estiver entre 183 e 191, diga sim.
  Se o pedaço for 215, diga sim.
  Se o pedaço for 247, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é whitespace:
  Se o pedaço for o caractere de espaço, diga sim.
  Se o pedaço for o tabulação horizontal, diga sim.
  Se o pedaço for o retorno de carro, diga sim.
  Se o pedaço for a quebra de linha, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o caret of um text é sob o beginning:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for 1, diga não.
  Se o caret número de coluna deste text não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o caret of um text é sob o end:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for a contagem destas rows deste text, diga não.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret número de coluna deste text não for a quantidade de caracteres desta string desta row, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o caret of um text está sobre o first linha reta:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o caret of um text está sobre o last linha reta:
  Se o text for inexistente, diga não.
  Se as rows deste text estiverem vazio, diga não.
  Se o número de linhas do cursor deste text não for o número da linha desta last row deste text, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma choice é uma string:
  Se a choice for inexistente, diga não.
  Se o nome desta choice for a string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor e uma segunda cor estão clear:
  Se a cor não for clear, diga não.
  Se a segunda cor não for clear, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma cor é uma segunda cor:
  Se a matiz desta cor não for a matiz desta segunda cor, diga não.
  Se a saturação desta cor não for a saturação desta segunda cor, diga não.
  Se a luminosidade desta cor não for a luminosidade desta segunda cor, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma cor está clear:
  Se a matiz desta cor for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é escura:
  Se a luminosidade desta cor estiver entre 250 e 374, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é clara:
  Se a luminosidade desta cor estiver entre 625 e 749, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é normal:
  Se a luminosidade desta cor estiver entre 375 e 624, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muito escura:
  Se a luminosidade desta cor estiver entre 125 e 249, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muito clara:
  Se a luminosidade desta cor estiver entre 750 e 874, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muitíssimo escura:
  Se a luminosidade desta cor for menor do que ou igual para 124, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muitíssimo clara:
  Se a luminosidade desta cor for maior do que ou igual para 875, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um contador é past um número:
  Adicione 1 para o contador.
  Se o contador for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está above ou below uma caixa:
  Se a localização deste context é above ou below a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está left ou right of uma caixa:
  Se a localização deste context é left ou right of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está para o right of uma caixa:
  Se a coordenada X desta localização deste context for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está within uns twips of uma caixa:
  Se a localização deste context estiver within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um difference está within um malha:
  Isole a difference.
  De-sign a difference.
  Se o número X desta difference for maior do que ou igual ao número X desta malha, diga não.
  Se o número Y desta difference for maior do que ou igual ao número Y desta malha, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um event é algum tipo de atalho de tecla:
  Se o event for inexistente, diga não.
  Se a categoria deste event não for "pressionamento de tecla", diga não.
  Se o event não foi alterado, diga não.
  Se a tecla deste event estiver entre a tecla A/a e a tecla Z/z, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um event foi alterado:
  Se o detector de tecla ctrl deste event estiver ativo, diga sim.
  Se o detector de tecla alt deste event estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um finger é past o end of uma string:
  Se o finger for inexistente, diga sim.
  Se o finger for maior do que o last endereço de memória do pedaço desta string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se um detector está on:
\ alterne como uma segunda nome por detector also ? ***
\Se o detector estiver ativo, diga sim.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um detector está presente;
Etapas para que se determine se um detector está em vigor;
Etapas para que se determine se um detector está levantada;
Etapas para que se determine se um detector está ligado; \foi ligado também funciona
Etapas para que se determine se um detector está ativo;
Etapas para que se determine se um detector está ativado; \foi ativado
\Etapas para que se determine se um detector já está ativado;
Etapas para que se determine se um detector já foi ativado anteriomente;
\Etapas para que se determine se um detector foi ativado anteriomente;
Etapas para que se determine se um detector está tocando;
Etapas para que se determine se um detector está soando;
Etapas para que se determine se um detector soou;
\Etapas para que se determine se um detector já soou;
Etapas para que se determine se um detector está disparando;
\Etapas para que se determine se um detector disparou;
Etapas para que se determine se um detector está alarmando;
\Etapas para que se determine se um detector disparou;
Etapas para que se determine se um detector está sendo mostrada;
Etapas para que se determine se um detector está sendo exibida;
Etapas para que se determine se um detector está verde:
  Se o detector for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um detector está dormente;
Etapas para que se determine se um detector está suspenso;
Etapas para que se determine se um detector está inativo;
Etapas para que se determine se um detector está desligado;
Etapas para que se determine se um detector está desativado;
Etapas para que se determine se um detector está vermelho:
  Se o detector for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração é o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é maior que uma segunda fração;
Etapas para que se determine se uma fração é maior do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é maior do que ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é menor que uma segunda fração;
Etapas para que se determine se uma fração é menor do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração for menor do que ou igual para uma segunda fração;
Etapas para que se determine se uma fração for menor que ou igual para uma segunda fração;
Etapas para que se determine se uma fração for menor ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é negative:
  Se o numerador desta fração for menor do que 0, reverse um detector.
  Se o denominador desta fração for menor do que 0, reverse o detector.
  \ Say o detector. \ does not work em SAL; no detector literals anymore
  Se o detector estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é um número:
  Se a fração é o número / 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um catálogo está vazia;
Etapas para que se determine se um catálogo estão vazias;
Etapas para que se determine se um catálogo estão vazios;
Etapas para que se determine se um catálogo está vazio:
  Se o catálogo for inexistente, diga sim.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, diga sim.
    Se os refers deste bucket não estiverem vazio, diga não.
  Repita. [o código acima]

Etapas para que se determine se um input é um clique:
  Esvazie o clique.
  Se a categoria deste input não for "clique", diga não.
  Atribua o input ao clique.

Etapas para que se determine se um item é found:
  Se a categoria deste item não estiver em branco, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de digit tecla:
  Se a tecla estiver entre 48 e 57, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de letra tecla:
  Se a tecla estiver entre 65 e 90, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de modifier tecla:
  Se a tecla for a tecla Alt, diga sim.
  Se a tecla for a tecla Ctrl, diga sim.
  Se a tecla for a tecla Shift, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de pad tecla:
  Se a tecla estiver entre 96 e 111, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de tecla imprimível:
  Se a tecla for o barra de espaço, diga sim.
  Se a tecla for algum tipo de digit tecla, diga sim.
  Se a tecla for algum tipo de letra tecla, diga sim.
  Se a tecla for algum tipo de pad tecla, diga sim.
  Se a tecla for algum tipo de symbol tecla, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de symbol tecla:
  Se a tecla estiver entre 186 e 192, diga sim.
  Se a tecla estiver entre 219 e 222, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de WM_CHAR tecla:
  Se a tecla não for algum tipo de tecla imprimível , diga não.
  Se a tecla Alt was para baixo, diga não.
  Se a tecla Ctrl was para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma tecla está sendo pressionada:
  Call "user32.dll" "GetAsyncKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla está sendo pressionado:
  Call "user32.dll" "GetAsyncKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla was para baixo:
  Call "user32.dll" "GetKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla was toggled:
  Call "user32.dll" "GetKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Conjuncione logicamente o número com 1.
  Se o número for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla was para cima:
  Se a tecla was para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma tecla com um lParam é algum comando de repetiçãoed escape ou modifier tecla:
  Atribua o lParam a um número.
  Conjuncione logicamente o número com 1073741824 [$40000000].
  Se o número for 0, diga não.
  Se a tecla for a tecla Esc, diga sim.
  Se a tecla for algum tipo de modifier tecla, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o left mouse botão está para baixo:
  Se o botão esquerdo deste mouse estiver sendo pressionado, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um linha reta está above uma caixa:
  Se a coordenada Y desta localização inicial desta linha reta for maior do que ou igual à coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y desta localização final desta linha reta for maior do que ou igual à coordenada Y do canto superior esquerdo desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um linha reta está above uma coordenada:
  Se a coordenada Y desta localização inicial desta linha reta for maior do que ou igual à coordenada, diga não.
  Se a coordenada Y desta localização final desta linha reta for maior do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um linha reta está below uma caixa:
  Se a coordenada Y desta localização inicial desta linha reta for menor do que ou igual à coordenada Y do canto inferior direito desta caixa, diga não.
  Se a coordenada Y desta localização final desta linha reta for menor do que ou igual à coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um linha reta está below uma coordenada:
  Se a coordenada Y desta localização inicial desta linha reta for menor do que ou igual à coordenada, diga não.
  Se a coordenada Y desta localização final desta linha reta for menor do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um linha reta está still em uma caixa;
Etapas para que se determine se um linha reta estiver em uma caixa:
  Se a localização inicial desta linha reta não estiver na caixa, diga não.
  Se a localização final desta linha reta não estiver na caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um mixed é um número:
  Converta o mixed para um fração.
  Se a fração for o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o mouse has been dragged desde uma localização usando um malha:
  Se o botão esquerdo deste mouse não estiver sendo pressionado, diga não.
  Atribua a localização deste mouse a uma segunda localização.
  Obtenha um difference entre a segunda localização e a localização.
  Se a difference estiver within a malha, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o mouse estiver em uma caixa:
  Se a localização deste mouse estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é um segundo número e uma string é uma segunda string:
  Se o número não for o segundo número, diga não.
  Se a string não for a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número está entre um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, diga não.
  Se o número for maior do que o terceiro número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é par:
  Se o número é ímpar, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é uniformemente divisível por um segundo número:
  Isole o número.
  Divida o número pelo segundo número usando um quociente e um resto.
  Se o resto for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é um múltiplo of um segundo número:
  Se o número for uniformemente divisível pelo segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é negative:
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é ímpar:
  Isole o número.
  Conjuncione logicamente o número com 1.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é positive:
  Se o número for menor do que 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é prime:
  Se o número for menor do que 2, diga não.
  Se o número for 2, diga sim.
  Atribua o número menos 1 a um segundo número.
  Percorra. [o código abaixo]
    Se o número é uniformemente divisível pelo segundo número, diga não.
    Subtraia 1 desde o segundo número.
    Se o segundo número for maior do que 1, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um segundo par de números:
  Se o número X deste par de números não for o número X deste segundo par de números, diga não.
  Se o número Y deste par de números não for o número Y deste segundo par de números, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um número e um segundo número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo é endereço da pasta-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste last deste endereço completo for a barra invertida, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo é drive-format:
  Se o endereço completo começa com "\\", diga sim.
  Se a quantidade de caracteres deste endereço completo não for 3, diga não.
  Se o endereço completo termina com ":\", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo está vazia no sistema de arquivos;
Etapas para que se determine se um endereço completo estão vazias no sistema de arquivos;
Etapas para que se determine se um endereço completo estão vazios no sistema de arquivos;
Etapas para que se determine se um endereço completo está vazio no sistema de arquivos:
  Se o endereço completo não estiver no sistema de arquivos, diga sim.
  Obtenha uma contagem of items no endereço completo no sistema de arquivos.
  Se a contagem for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo é file-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste last deste endereço completo for o sinal de dois pontos, diga não.
  Se o conteúdo deste last deste endereço completo for a barra invertida, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo está no sistema de arquivos:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Se o número for menor do que 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo é read-only:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Conjuncione logicamente o número com 1 [FILE_ATTRIBUTE_READONLY].
  Se o número não for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço de memória pode ser found;
Etapas para que se determine se um endereço de memória está coming;
\Etapas para que se determine se um endereço de memória é found;
Etapas para que se determine se um endereço de memória foi found;
Etapas para que se determine se um endereço de memória existe;
Etapas para que se determine se um endereço de memória does exist:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.





Etapas para que se determine se um endereço de memória é missing;
Etapas para que se determine se um endereço de memória é null e esvazie:
  Se o endereço de memória for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um polígono está closed:
  Se o polígono for inexistente, diga não.
  Se a contagem destes vértices deste polígono for menor do que 3, diga não.
  Se a localização deste first vértice deste polígono for a localização deste last vértice deste polígono, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um reply é something like uma segunda reply:
  Isole o reply.
  Isole a segunda reply.
  Simplify o reply.
  Simplify a segunda reply.
  Se o reply é a segunda reply, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma row está em branco:
  Se a row for inexistente, diga sim.
  Lance um subtexto sobre a string deste row.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se uma row of um text está selecionado:
  Se o text for inexistente, diga não.
  Se a row for inexistente, diga não.
  Se nada estiver selecionado no text, diga não.
  Atribua a normalized seleção deste text a uma seleção.
  Se o número da linha desta row for menor do que o anchor número da linha desta seleção, diga não.
  Se o número da linha desta row for maior do que o número de linhas do cursor desta seleção, diga não.
  Se o número da linha desta row não for o número de linhas do cursor desta seleção, diga sim.
  Se o caret número de coluna desta seleção for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma row of um text é visível:
  Se o text for inexistente, diga não.
  Se a row for inexistente, diga não.
  Obtenha uma caixa usando a row e o text.
  Atribua a caixa deste text a uma segunda caixa.
  Ajuste a segunda caixa usando 0 e a quantidade de twips/pixel e 0 e - a quantidade de twips/pixel .
  Se a caixa estiver touching a segunda caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma seleção é uma segunda seleção:
  Se o anchor desta seleção não for o anchor desta segunda seleção, diga não.
  Se o caret desta seleção não for o caret desta segunda seleção, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se something está selecionado em um text:
  Se o anchor deste text for o caret deste text, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é above uma caixa:
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é above um horizontal linha reta:
  Se a coordenada Y desta localização for menor do que o horizontal y desta localização inicial desta linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é above ou below uma caixa:
  Se a localização é above a caixa, diga sim.
  Se a localização é below a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é below uma caixa:
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é below um horizontal linha reta:
  Se a coordenada Y desta localização for maior do que o horizontal y desta localização inicial desta linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está em um elipse:
  Crie um hRgn usando a elipse.
  Isole a localização.
  Divida a localização pelo quantidade de twips/pixel .
  Call "gdi32.dll" "PtInRegion" com 
    O hRgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Destrua o hRgn.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em um imagem:
  Se a imagem for inexistente, diga não.
  Se a localização estiver na caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está em um polígono:
  Se o polígono for inexistente, diga não.
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "CreatePolygonRgn" com 
    A localização endereço de memória deste vértice array 
    e A contagem deste vértice array 
    e 2 [WINDING] devolvendo um hRgn.
  Call "gdi32.dll" "PtInRegion" com 
    O hRgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Call "gdi32.dll" "DeleteObject" com 
    O hRgn.
  Destrua o vértice array.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em uns polígonos:
  Obtenha um polígono desde o polígonos.
  Se o polígono for inexistente, diga não.
  Se a localização estiver no polígono, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma localização está em uma caixa arredondada:
  Isole a caixa arredondada.
  Adicione a quantidade de twips/pixel para a canto inferior direito desta caixa arredondada.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "CreateRoundRectRgn" com 
    A coordenada X do canto superior esquerdo desta caixa arredondada 
    e A coordenada Y do canto superior esquerdo desta caixa arredondada 
    e A coordenada X do canto inferior direito desta caixa arredondada 
    e A coordenada Y do canto inferior direito desta caixa arredondada 
    e O diameter 
    e O diameter 
    devolvendo um hRgn.
  Call "gdi32.dll" "PtInRegion" com 
    O hRgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Call "gdi32.dll" "DeleteObject" com 
    O hRgn.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em um text:
  Se o text for inexistente, diga não.
  Se a localização estiver na caixa deste text, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está inside uma caixa;
Etapas para que se determine se uma localização está within uma caixa;
Etapas para que se determine se uma localização está em uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, diga não.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está para o left of uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está left ou right of uma caixa:
  Se a localização é para o left of a caixa, diga sim.
  Se a localização é para o right of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está sobre uma caixa:
  Atribua a caixa a uma segunda caixa.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a segunda caixa usando o número.
  Se a localização não estiver no segunda caixa, diga não.
  Atribua a caixa a um terceiro caixa.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent o terceiro caixa usando o segundo número.
  Se a localização estiver no terceiro caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está sobre uma elipse:
  Atribua a elipse a uma segunda elipse.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a caixa desta segunda elipse usando o número.
  Se a localização não estiver na segunda elipse, diga não.
  Atribua a elipse a uma terceiro elipse.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent a caixa desta terceiro elipse usando o segundo número.
  Se a localização estiver na terceiro elipse, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está sobre uma linha reta:
  Isole a linha reta.
  Atribua 3 times a quantidade de twips/pixel a um número.
  Percorra. [o código abaixo]
    Obtenha uma distance entre a localização e o center desta linha reta (chessboard).
    Se a distance for menor do que ou igual ao número, diga sim.
    Obtenha a distance entre a localização inicial desta linha reta e a localização final desta linha reta (chessboard).
    Se a distance for menor do que ou igual ao quantidade de twips/pixel , diga não.
    Separe a linha reta à linha reta e uma segunda linha reta.
    Obtenha a distance entre a localização e o center desta linha reta (chessboard).
    Obtenha uma segunda distance entre a localização e o center desta segunda linha reta (chessboard).
    Se a distance for maior do que a segunda distance, atribua a segunda linha reta ao linha reta.
  Repita. [o código acima]

Etapas para que se determine se uma localização está sobre um imagem:
  Se a imagem for inexistente, diga não.
  Se a localização estiver sobre a caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está sobre um polígono:
  Se o polígono for inexistente, diga não.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, diga não.
    Se o next deste vértice for inexistente, diga não.
    Atribua a localização deste vértice e a localização deste next deste vértice a um linha reta.
    Se a localização estiver sobre o linha reta, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma localização está sobre uma caixa arredondada:
  Atribua a caixa arredondada a uma segunda caixa arredondada.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a segunda caixa arredondada usando o número.
  Se a localização não estiver no segunda caixa arredondada, diga não.
  Atribua a caixa arredondada a um terceiro caixa arredondada.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent o terceiro caixa arredondada usando o segundo número.
  Se a localização estiver no terceiro caixa arredondada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é outside uma caixa:
  Se a localização é inside a caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é para o right of uma caixa:
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é touching uma caixa:
  Se a localização estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within um malha of uma segunda localização:
  Obtenha um difference entre a segunda localização e a localização.
  Se a difference está within a malha, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uns twips of uma segunda localização:
  Atribua os twips e os twips a um malha.
  Se a localização estiver within a malha of a segunda localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uns twips of uma caixa:
  Isole a caixa.
  Outdent a caixa usando os twips.
  Se a localização estiver within a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o stack has just one coisa sobre it:
  Se a contagem deste stack for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se uma string does end com uma segunda string;
Etapas para que se determine se uma string termina com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o last endereço de memória do pedaço deste subtexto menos a quantidade de caracteres desta segunda string mais 1 ao first endereço de memória do pedaço deste subtexto.
  Se o subtexto for a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does start com uma segunda string;
Etapas para que se determine se uma string começa com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Se o subtexto é a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does start com um pedaço;
Etapas para que se determine se uma string começa com um pedaço:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does end com um pedaço; \ adicionado por Mike Gonta
Etapas para que se determine se uma string termina com um pedaço:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste last endereço de memória do pedaço desta string for o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é uma segunda string (accent-free compare):
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos s/ acento ascii (equal only).

Etapas para que se determine se uma string é uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos ascii (equal only).

Etapas para que se determine se uma string é uma segunda string ou um terceiro string:
  Se a string é a segunda string, diga sim.
  Se a string é o terceiro string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de fração literal;
Etapas para que se determine se uma string é algum tipo de ratio literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Separe o subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
  Se o numerador subtexto não for algum tipo de integer literal, diga não.
  Se o denominador subtexto não for algum tipo de integer literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

\Etapas para que se determine se uma string é algum tipo de inteiro:
\ parece ser uma duplicata da rotina abaixo
\Lance um subtexto sobre a string.
\Se o subtexto estiver em branco, diga não.
\Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
\Se o subtexto estiver em branco, diga não.
\Percorra. [o código abaixo]
 \Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de digit, diga não.
 \Adicione 1 para o first endereço de memória do pedaço deste subtexto.
\Se o subtexto estiver em branco, diga sim.
\Repita. [o código acima]

Etapas para que se determine se uma string é algum tipo de integer;
Etapas para que se determine se uma string é algum tipo de integer literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Percorra. [o código abaixo]
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de digit, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma string é algum tipo de mixed literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Separe o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto não for algum tipo de integer literal, diga não.
  Se a fração subtexto não for algum tipo de fração literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum tipo de numeric literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string não for algum tipo de indicador numérico, diga não.
  Se a string é algum tipo de integer literal, diga sim.
  Se a string é algum tipo de fração literal, diga sim.
  Se a string é algum tipo de mixed literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é tipo de sinal aritmético:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de palavra:
  Se a quantidade de caracteres desta string for menor do que 2, diga não.
  Lance um subtexto sobre a string.
  Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for algum tipo de letra, repita.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o single-quote pedaço, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.



Etapas para que se determine se uma string é um pedaço:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é dos-compatible:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é o ponto final, diga não.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o slash pedaço, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de dois pontos, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o asterisco, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o ponto de interrogação, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for as aspas duplas, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o símbolo menor do que, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o símbolo maior do que, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o barra vertical, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se uma string é maior que uma segunda string;
Etapas para que se determine se uma string é maior do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é maior do que ou igual para uma segunda string;
Etapas para que se determine se uma string é maior que ou igual para uma segunda string;
Etapas para que se determine se uma string é maior ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string estiver em uma segunda string:
  Lance um subtexto sobre a segunda string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta segunda string, diga não.
    Se o subtexto é a string, diga sim.
    Mova o subtexto usando 1.
  Repita. [o código acima]

Etapas para que se determine se uma string estiver em um catálogo:
  Se o catálogo for inexistente, diga não.
  Se a string estiver em branco, diga não.
  Encontre um refer usando a string e o catálogo.
  Se o refer for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é menor que uma segunda string;
Etapas para que se determine se uma string é menor do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é menor do que ou igual para uma segunda string;
Etapas para que se determine se uma string é menor que ou igual para uma segunda string;
Etapas para que se determine se uma string é menor ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\ needs work por Spanish
Etapas para que se determine se uma string está escrito incorretamente:
  Se o dicionário léxico for inexistente, diga não.
  Se a string não for algum tipo de palavra, diga não.
  Isole a string.
  Se a string termina com "'s", remove os last dois pedaços desde a string.
  Se a string estiver no catálogo deste dicionário léxico, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é wider do que uma caixa:
  \ presume que a font esteja selecionada no memory canvas
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Obtenha um largura usando a string e o memory canvas.
  Subtraia o abcA desde a largura.
  Subtraia o abcC desde a largura.
  Se a largura for maior do que a largura desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um subtexto está sobre alguma espécie de contração:
  Atribua o first endereço de memória do pedaço deste subtexto mais 1 a um endereço de memória do pedaço .
  Se o endereço de memória do pedaço for maior do que o last endereço de memória do pedaço deste subtexto, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o single-quote pedaço, diga não.
  Se o conteúdo deste endereço de memória do pedaço não for algum tipo de letra, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um terminal está totalmente prenchido:
  Atribua a altura deste terminal dividido por 24 pixels a um número.
  Se a contagem destes quoras deste terminal for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um text pode ser refeito:
  Se o text for inexistente, diga não.
  Se o last destes redos deste text for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um text pode ser desfeito:
  Se o text for inexistente, diga não.
  Se o last destes undos deste text for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um text foi alterado:
  Se o text for inexistente, diga não.
  Se o detector de alteração deste text estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe something para backspace em um text:
  Se o text for inexistente, diga não.
  Se something estiver selecionado no text, diga sim.
  Se o número de linhas do cursor deste text não for 1, diga sim.
  Se o caret número de coluna deste text não for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe something para remove em um text:
  Se o text for inexistente, diga não.
  Se something estiver selecionado no text, diga sim.
  Se o número de linhas do cursor deste text não for a contagem de linhas deste text, diga sim.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret número de coluna deste text não for a quantidade de caracteres desta string desta row, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe text sobre o área de transferência do Windows:
  Call "user32.dll" "IsClipboardFormatAvailable" com 
  1 [CF_TEXT] 
    devolvendo um número.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se umas coisas estão vazios;
Etapas para que se determine se umas coisas estão vazias;
Etapas para que se determine se umas coisas estão vazia;
Etapas para que se determine se uns coisas estão vazio:
  Se o first destas coisas for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um segmento inicial é numeric:
  Isole o segmento inicial.
  Remove algum tipo de leading noise desde o segmento inicial.
  Se o segmento inicial estiver em branco, diga não.
  Percorra. [o código abaixo]
    Obtenha um pedaço desde o segmento inicial.
    Se o pedaço não for algum tipo de digit, diga não.
    Se o segmento inicial estiver em branco, diga sim.
  Repita. [o código acima]

Etapas para que se determine se o usuário está clicking em umas choices;
Etapas para que se determine se o usuário has clicked em umas choices;
Etapas para que se determine se o usuário clicked em umas choices;
Etapas para que se determine se o usuário clicks em umas choices;
Etapas para que se determine se o usuário está clicking sobre umas choices;
Etapas para que se determine se o usuário has clicked sobre umas choices;
Etapas para que se determine se o usuário clicked sobre umas choices;
Etapas para que se determine se o usuário clicks sobre umas choices:
Etapas para que se determine se o usuário clickou sobre umas choices:
Etapas para que se determine se o usuário clicou sobre umas choices:
Etapas para que se determine se o usuário clickou em umas choices:
Etapas para que se determine se o usuário clicou em umas choices:
  Percorra. [o código abaixo]
  Se o botão esquerdo deste mouse não estiver para baixo, diga não.
  Encontre uma choice usando a localização deste mouse.
  Se a choice can't ser found, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

  

Etapas para que se determine se we pode encontre um endereço de memória:
  \ deveria ser "can" not "ca", compilador bug
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we could encontre um endereço de memória:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we did encontre um endereço de memória:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we're above uma caixa:
  Se a coordenada Y deste context for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're above uma coordenada:
  Se a coordenada Y deste context for menor do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're above um horizontal linha reta:
  Se a localização deste context é above o horizontal linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're above ou below uma caixa:
  Se a coordenada Y deste context for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
  Se a coordenada Y deste context for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're above uma localização:
  Se a coordenada Y deste context for menor do que a coordenada Y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're below uma caixa:
  Se a coordenada Y deste context for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're below uma coordenada:
  Se a coordenada Y deste context for maior do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're below um horizontal linha reta:
  Se a localização deste context é below o horizontal linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're below uma localização:
  Se a coordenada Y deste context for maior do que a coordenada Y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're facing north:
  \ *** need east, south, west
  Normalize a orientação deste context.
  Se a orientação deste context for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're left of uma caixa:
  Se a coordenada X deste context for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're left ou right of uma caixa:
  Se a coordenada X deste context for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
  Se a coordenada X deste context for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're outside uma caixa:
  Se a localização deste context é outside a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're right of uma caixa:
  Se a coordenada X deste context for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're still em uma caixa;
Etapas para que se determine se we're em uma caixa:
  Se a localização deste context estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're within uns twips of uma caixa:
  Se a localização deste context está within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se you feel like it:
  Escolha aleatoriamente um número entre 1 e 100.
  Se o número for menor do que 51, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se decrypt um trecho usando um passphrase string:
  \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie uma crypt session usando o passphrase.
  Se a crypt session for inexistente, cancele.
  Converta o trecho como uma cifra hexadecimal para um texto hexadecimal.
  Atribua a quantidade de caracteres deste texto hexadecimal a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptDecrypt" com 
    A hcryptkey desta crypt session 
    e 0 
    e 1 
    e 0 
    e O first deste texto hexadecimal 
    e O endereçamento deste quantidade de caracteres 
    devolvendo um número resultante.
  Se o número resultante for 0, atribua "Ocorreu um erro na hora de tentar decifrar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
  Destrua o crypt session.
  Atribua o texto hexadecimal ao trecho.

O fonte padrão é uma font.

O default smtp server é "localhost".

Um degree é um número [cujos valores variam entre 0 até 359].

Um depth é uns twips.

Um description é uma string.

Etapas para que se desvencilhe-se de um text:
  Se o text for inexistente, cancele.
  Atribua o caret deste text ao anchor deste text.

Etapas para que se destrua um crypt session:
  Se o crypt session for inexistente, cancele.
  Call "advapi32.dll" "CryptDestroyKey" com 
    A hcryptkey desta crypt session.
  Call "advapi32.dll" "CryptDestroyHash" com 
    O hcrypthash desta crypt session.
  Call "advapi32.dll" "CryptReleaseContext" com 
    O hcryptprov desta crypt session 
    e 0.
  Desaloque o crypt session.

Etapas para que se destrua um GpImage:
  Se o GpImage for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImage" com o GpImage.
  Esvazie o GpImage.

Etapas para que se destrua um GpImageAttributes:
  Se o GpImageAttributes for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImageAttributes" com o GpImageAttributes.
  Esvazie o GpImageAttributes.

Etapas para que se destrua o HBRUSH of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null HBRUSH 
    devolvendo um HBRUSH.
  Call "gdi32.dll" "DeleteObject" com 
    O HBRUSH.

Etapas para que se destrua o número da fonte of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null número da fonte 
    devolvendo um número da fonte.
  Call "gdi32.dll" "DeleteObject" com 
    O número da fonte.

Etapas para que se destrua o hpen of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null hpen 
    devolvendo um hpen.
  Call "gdi32.dll" "DeleteObject" com 
    O hpen.

Etapas para que se destrua um hRgn:
  Call "gdi32.dll" "DeleteObject" com 
    O hRgn.

Etapas para que se destrua um catálogo:
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, pare.
    Destrua os refers deste bucket.
  Repita. [o código acima]
  Unassign o first bucket deste catálogo.
  Desaloque o catálogo.

Etapas para que se destrua um endereço completo no sistema de arquivos:
  Defina o endereço completo para read-write mode.
  Se o endereço completo é endereço da pasta-format, destrua o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, destrua o endereço completo no sistema de arquivos (arquivo).

Etapas para que se destrua um endereço completo no sistema de arquivos (pasta)[endereço]:
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, pare.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Destrua a segunda endereço completo no sistema de arquivos.
    Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Repita. [o código acima]
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "RemoveDirectoryA" com 
    O first deste endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível apagar a pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se destrua uma endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "DeleteFileA" com 
    O first deste endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível apagar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se destrua uma imagem:
  Se a imagem for inexistente, cancele.
  Destrua o gpBitmap desta imagem.
  Desaloque a imagem.

Etapas para que se destrua um socket:
  Call "ws2_32.dll" "closesocket" com 
    O socket.

Etapas para que se destrua um vértice usando um polígono:
  Se o vértice for inexistente, cancele.
  Se o polígono for inexistente, cancele.
  Isole o vértice.
  Remove o vértice desde os vértices deste polígono.
  Destrua o vértice.

Etapas para que se destrua um requisição WinHTTP:
  Se o requisição WinHTTP for inexistente, cancele.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com 
    O número identificador de requisição deste requisição WinHTTP.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com 
    O número identificador de conexão deste requisição WinHTTP.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com 
    O número identificador de sessão desta número identificador de requisição deste WinHTTP.
  Deallocate o requisição WinHTTP.

Um difference é um par de números.

Um file é um número identificador.

Um nome do arquivo é uma string. \ after o last slash para end of endereço completo = file.ext
Um nome do arquivo s/ extensão é uma string. \ after o last slash para last dot ou end of endereço completo = file
Um extensão é uma string. \ last dot para end of endereço completo = .ext
Um endereço da pasta é um endereço completo. \ start of endereço completo para last slash inclusive = c:\folder1\folder2\
Um endereço completo é uma string. \ complete nome = c:\folder1\folder2\file.ext
Um nome do diretório é uma string. \ rightmost endereço da pasta com slash = folder2\
Um designador é uma string. \ rightmost endereço da pasta com slash = folder2\ ou after o last slash para end of endereço completo = file.ext
Um nome da pasta é uma string. \ rightmost endereço da pasta sem slash = folder2
Um unidade de disco é uma string. \ start of endereço completo para first slash = c:\ ou start of endereço completo para quarto slash = \\computer\share\
Um unidade de rede é uma string. \ é basicamente o número de cópias da variável anterior.
Um categoria da unidade de disco é uma string.
Um nome da unidade de disco é uma string.

Um distance é uns twips.

Etapas para que se divida uma fração por uma segunda fração:
  Isole a segunda fração.
  Flip a segunda fração.
  Multiplique a fração pela segunda fração.

Etapas para que se divida uma fração por um número:
  Multiplique o denominador desta fração pelo número.
  Reduza a fração.

Etapas para que se divida um número por um fração:
  Isole a fração.
  Flip a fração.
  Multiplique o número pela fração.

Etapas para que se divida um par de números por um segundo par de números:
  Divida o número X deste par de números pelo número X deste segundo par de números.
  Divida o número Y deste par de números pelo número Y deste segundo par de números.

Etapas para que se divida um par de números por um número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo número.

Etapas para que se divida um par de números por um número e um segundo número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo segundo número.

\Um DOCINFO é um conjunto com
\Um número denominado cbSize,
\Um endereço de memória denominado lpszDocName,
\Um endereço de memória denominado lpszoutput,
\Um endereço de memória denominado lpszdatadtype,
\Um número denominado fwtype.

Um dot é um elipse.

Etapas para que se double um número:
  Adicione o número para o número.

Etapas para que se pinte e fill uma caixa com uma cor:
  Pinte a caixa com a cor e a cor.

Etapas para que se pinte algum tipo de visível rows of um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver visível, repita.
    Pinte a row of o text.
  Repita. [o código acima]

Etapas para que se pinte algum tipo de visível rows of um text (editing):
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não for visível, repita.
    Pinte a row of o text (editing).
  Repita. [o código acima]

Etapas para que se pinte uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas para que se pinte uma caixa (focus style):
  Isole a caixa.
  Adicione a quantidade de twips/pixel para o canto inferior direito desta caixa.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e O endereçamento desta caixa e 2.
  Converta a cor branca para um código da cor. \código de pigmento/tonalidade?
  Call "gdi32.dll" "SetBkColor" com 
    O quadro atual 
    e O código da cor.
  Converta a cor preta para um segundo código da cor.
  Call "gdi32.dll" "SetTextColor" com 
    O quadro atual 
    e O segundo código da cor.
  Call "gdi32.dll" "SetMapMode" com 
    O quadro atual 
    e 1 [MM_TEXT]. \ o modo de mapeamento para o contexto de dispositivo do seu aplicativo
  Call "user32.dll" "DrawFocusRect" com 
    O quadro atual 
    e O endereçamento desta caixa.
  Normalize o quadro atual.

Etapas para que se pinte uma caixa em uma cor:
  \Etapas para que se pinte uma caixa com uma cor:
  Pinte a caixa com a cor e a cor preta.

Etapas para que se pinte o caret em um text:
  Se o text for inexistente, cancele.
  Obtenha uma caixa pelo caret no text.
  Se a caixa não estiver touching a caixa deste text, cancele.
  Atribua o canto superior esquerdo desta caixa e o canto inferior direito desta caixa a um linha reta.
  Pinte o linha reta com a cor preta.

Etapas para que se pinte um circle about uns twips wide;
Etapas para que se pinte um circle usando um largura;
Etapas para que se pinte um circle uns twips em largura;
Etapas para que se pinte um circle uns twips wide:
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o caminho.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Repita. [o código acima]

Etapas para que se pinte um circle uns twips wide (backwards);
Etapas para que se pinte um circle uns twips wide (counterclockwise):
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o caminho.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Repita. [o código acima]

Etapas para que se pinte um console:
  Se o console for inexistente, cancele.
  Salve o quadro atual.
  Cubra somente fora de a caixa deste console .
  Pinte a caixa deste console com a cor da borda deste console e a cor de preenchimento deste console.
  Atribua a cor branca ao pincel cor deste text deste console.
  Pinte o text deste console.
  Restaure o quadro atual.

Etapas para que se pinte um dot uns twips wide sobre a localização atual com uma cor:
  Faça o dot os twips wide.
  Centralize o dot sobre a localização deste context.
  Pinte o dot com a cor.

Etapas para que se pinte um dot uns twips wide sobre uma localização com uma cor:
  Faça o dot os twips wide.
  Centralize o dot sobre a localização.
  Pinte o dot com a cor.

Etapas para que se pinte uma elipse:
  Pinte a elipse com a cor preta e a cor branca.

Etapas para que se pinte uma elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor e a cor preta.

Etapas para que se pinte uma elipse com uma cor:
  Pinte a elipse com a cor e a cor.

Etapas para que se pinte uma flecha estilizada uns twips long com uma cor:
  Atribua a cor à cor deste context.
  Salve o context.
  Pinte os twips.
  Dê meia volta.
  Mova os twips dividido por 8.
  Salve o context.
  Vire left 1/8 of o caminho.
  Pinte um spiral starting com os twips dividido por 4.
  Restaure o context.
  Vire right 1/8 of o caminho.
  Pinte uma segunda spiral backwards starting com os twips dividido por 4.
  Restaure o context.

Etapas para que se pinte um figura com uma cor:
  Pinte a figura com a cor e a cor preta.

Etapas para que se pinte um figura com uns sides about uns twips wide:
  Atribua 1 e o side contagem a um fração.
  Atribua os twips times o número pi dividido pelo sides a uma quantidade de caracteres do segmento.
  Se o sides são 4, atribua os twips times 7/8 ao quantidade de caracteres do segmento. \ what é this? ***
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire a fração.
    Adicione 1 para uma contagem. 
    Se a contagem for os sides, pare.
  Repita. [o código acima]

Etapas para que se pinte um figura com uns sides uns twips long;
Etapas para que se pinte um figura com uns sides e uns twips:
  Atribua 1 e o sides a um fração.
  Percorra. [o código abaixo]
    Pinte os twips.
    Vire a fração.
    Adicione 1 para uma contagem. Se a contagem é o sides, pare.
  Repita. [o código acima]

Etapas para que se pinte um figura com uns sides uns twips long using uma cor;
Etapas para que se pinte um figura com uns sides e uns twips using uma cor:
  Atribua a cor à cor deste context.
  Pinte a figura com o sides e os twips.

Etapas para que se pinte um half circle about uns twips wide;
Etapas para que se pinte um half circle usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o caminho.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Repita. [o código acima]

Etapas para que se pinte um half circle usando um size (backwards);
Etapas para que se pinte um half circle usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o caminho.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Repita. [o código acima]

Etapas para que se pinte um hexagon usando um side quantidade de caracteres:
  Pinte o side quantidade de caracteres.
  Vire right 1/6 of o caminho.
  Adicione 1 para uma contagem. Se a contagem for 6, pare.
  Repita. [o código acima]

Etapas para que se pinte um linha reta:
  Pinte o linha reta com a cor deste context.

Etapas para que se pinte um linha reta around uns twips long; \ "around" é significante here
Etapas para que se pinte um linha reta about uns twips long: \ "about" é significante here
  \ "about" é significant here
  Atribua os twips dividido por 2 a uns segunda twips.
  Escolha aleatoriamente uns terceiro twips entre os twips menos a segunda twips e os twips mais a segunda twips.
  Pinte o linha reta o terceiro twips long.

Etapas para que se pinte um linha reta como tall como uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte a altura desta caixa.

Etapas para que se pinte um linha reta como wide como uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte a largura desta caixa.

Etapas para que se pinte um linha reta entre uns twips e uns segunda twips long;
Etapas para que se pinte um linha reta entre uns twips para uns segunda twips long;
Etapas para que se pinte um linha reta uns twips para uns segunda twips long:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte o linha reta o terceiro twips long.

Etapas para que se pinte um linha reta uns twips long:
  \Aguarde pelo delay. ***
  Atribua a localização deste context ao localização inicial desta linha reta.
  Atribua a localização deste context ao localização final desta linha reta.
  Obtenha um deslocamento vertical e um deslocamento horizontal usando a orientação deste context.
  Adicione o deslocamento horizontal times os twips dividido por 10000 para a coordenada X desta localização final desta linha reta.
  Adicione o deslocamento vertical times os twips dividido por 10000 para a coordenada Y desta localização final desta linha reta.
  Atribua a localização final desta linha reta à localização deste context.
  Pinte o linha reta com a cor deste context.
  \Se o delay for positive, atualize o tela.

Etapas para que se pinte um linha reta using uns twips como a quantidade de caracteres;
Etapas para que se pinte um linha reta using uns twips pelo quantidade de caracteres:
  Pinte os twips.

Etapas para que se pinte um linha reta com uma cor around uns twips long; \ "around" é significant here
Etapas para que se pinte um linha reta com uma cor about uns twips long:\ "about" é significant here
  Atribua os twips dividido por 2 a uns segunda twips.
  Escolha aleatoriamente uns terceiro twips entre os twips menos a segunda twips e os twips mais a segunda twips.
  Pinte o linha reta com a cor o terceiro twips long.

Etapas para que se pinte um linha reta com uma cor uns twips long:
  Atribua a cor à cor deste context.
  Atribua a localização deste context ao localização inicial desta linha reta.
  Pinte os twips.
  Atribua a localização deste context ao localização final desta linha reta.

Etapas para que se pinte um linha reta com uma cor uns twips para uns segunda twips long:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte o linha reta com a cor o terceiro twips long.

Etapas para que se pinte um número em uma caixa com uma cor:
  Atribua o número a uma string.
  Pinte a string na caixa com a cor e "center".

Etapas para que se pinte only within uma caixa;
Etapas para que se pinte only inside uma caixa;
Etapas para que se pinte only em uma caixa;
Etapas para que se pinte only within uma caixa desde now on;
Etapas para que se pinte only inside uma caixa desde now on;
Etapas para que se pinte only em uma caixa desde now on;
Etapas para que se only pinte within uma caixa desde now on;
Etapas para que se only pinte inside uma caixa desde now on;
Etapas para que se only pinte em uma caixa desde now on;
Etapas para que se only pinte within uma caixa;
Etapas para que se only pinte inside uma caixa;
Etapas para que se only pinte em uma caixa;
Etapas para que se pinte within uma caixa only;
Etapas para que se pinte inside uma caixa only;
Etapas para que se pinte em uma caixa only;
Etapas para que se atribua masking tape all around uma caixa;
Etapas para que se atribua masking tape around uma caixa:
  \ note that this masks a cor da borda da caixa as well
  Isole a caixa.
  Indent a caixa 1 pixel.
  Cubra externamente a caixa.
  Atribua a original caixa à caixa deste context. \ *** original caixa ? ou indented one?

Etapas para que se pinte uma imagem sobre um gpgraphic sob uma coordenada X e uma coordenada Y:
  Se a imagem for inexistente, cancele.
  Se o grayscale detector desta imagem estiver ativo, crie um GpImageAttributes (escala de cinza).
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com 
    O gpgraphic 
    e O gpBitmap desta imagem 
    e A coordenada X 
    e A coordenada Y 
    e A largura desta caixa intacta desta imagem 
    e A altura desta caixa intacta desta imagem 
    e 0 
    e 0 
    e A largura deste gpBitmap desta imagem 
    e A altura deste gpBitmap desta imagem 
    e 2 [unitpixel] 
    e O GpImageAttributes 
    e nil e 0.
  Se o GpImageAttributes não for inexistente, destrua o GpImageAttributes.

Etapas para que se pinte um polígono:
  Pinte o polígono com a cor preta e a cor branca.

Etapas para que se pinte um polígono com uma cor:
  Pinte o polígono com a cor e a cor.

Etapas para que se pinte um polígono com uma cor (border only):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hpen of o quadro atual usando a cor.
  Obtenha um vértice desde os vértices deste polígono.
  Se o vértice for inexistente, cancele.
  Call "gdi32.dll" "MoveToEx" com 
    O quadro atual 
    e A coordenada X deste vértice 
    e A coordenada Y deste vértice 
    e nil.
  Percorra. [o código abaixo]
    Obtenha o vértice desde os vértices deste polígono.
    Se o vértice for inexistente, pare.
    Call "gdi32.dll" "LineTo" com 
      O quadro atual 
      e A coordenada X deste vértice 
      e A coordenada Y deste vértice.
  Repita. [o código acima]
  Destrua o hpen of o quadro atual.
  Se a localização deste first destes vértices deste polígono for a localização deste last destes vértices deste polígono, cancele.
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com 
    O quadro atual 
    e A coordenada X deste last destes vértices deste polígono 
    e A coordenada Y deste last destes vértices deste polígono 
    e O código da cor.

Etapas para que se pinte um polígono com uma cor (fill only):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hpen of o quadro atual usando a cor preta.
  Crie o HBRUSH of o quadro atual usando a cor.
  Call "gdi32.dll" "SetPolyFillMode" com 
    O quadro atual 
    e 2 [WINDING].
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "Polygon" com 
    O quadro atual 
    e A localização endereço de memória deste vértice array 
    e A contagem deste vértice array.
  Destrua o vértice array.
  Destrua o HBRUSH of o quadro atual.
  Destrua o hpen of o quadro atual.

Etapas para que se pinte um quarter circle about uns twips wide;
Etapas para que se pinte um quarter circle usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o caminho.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Repita. [o código acima]

Etapas para que se pinte um quarter circle entre uns twips e uns segunda twips wide:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte um quarter circle usando o terceiro twips.

Etapas para que se pinte um quarter circle usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o caminho.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Repita. [o código acima]

Etapas para que se pinte um retângulo uns twips por uns segunda twips;
Etapas para que se pinte um retângulo uns twips wide por uns segunda twips high:
  Pinte a segunda twips.
  Vire right.
  Pinte os twips.
  Vire right.
  Pinte a segunda twips.
  Vire right.
  Pinte os twips.
  Vire right.

Etapas para que se pinte uma caixa arredondada:
  Pinte a caixa arredondada com a cor preta e a cor branca.

Etapas para que se pinte uma caixa arredondada com uma cor:
  Pinte a caixa arredondada com a cor e a cor.

Etapas para que se pinte uma row of um text:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas para que se pinte uma row of um text (editing):
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Pinte a caixa de seleção pela row of o text.
  Obtenha uma caixa usando a row e o text.
  Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas para que se pinte a caixa de seleção por uma row of um text:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Se a row of o text não estiver selecionado, cancele.
  Obtenha uma caixa de seleção usando a row e o text.
  Pinte a caixa de seleção com o cor hilite e o cor hilite.

Etapas para que se pinte um spiral backward usando uns twips;
Etapas para que se pinte um spiral backward starting com uns twips;
Etapas para que se pinte um spiral usando um size (backwards):
  Isole o size.
  Percorra. [o código abaixo]
    Pinte um half circle usando o size (backwards).
    Divida o size por 2.
    Adicione 1 para uma contagem.
    Se a contagem for 5, pare.
  Repita. [o código acima]

Etapas para que se pinte um spiral starting com uns twips;
Etapas para que se pinte um spiral usando um size:
  Isole o size.
  Percorra. [o código abaixo]
    Pinte um half circle usando o size.
    Divida o size por 2.
    Adicione 1 para uma contagem. 
    Se a contagem for 5, pare.
  Repita. [o código acima]

Etapas para que se pinte uma localização:
  Pinte a localização com a cor preta.

Etapas para que se pinte uma localização com uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    e O código da cor.

Etapas para que se pinte um star usando uma point contagem e um size:
  Atribua 1 e a point contagem a um fração.
  Percorra. [o código abaixo]
    Vire right 1/48 of o caminho.
    Pinte o size.
    Dê meia volta.
    Vire left 1/24 of o caminho.
    Pinte o size.
    Dê meia volta.
    Vire right 1/48 of o caminho.
    Vire right a fração of o caminho.
    Adicione 1 para uma contagem. 
    Se a contagem for o point contagem, pare.
  Repita. [o código acima]

Etapas para que se pinte uma string sob o left of uma caixa:
  Pinte a string sob o left of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string sob o left of uma caixa com uma cor:
  Pinte a string sob o left of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string sob o left of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e a font e "left".

Etapas para que se pinte uma string sob o left of uma caixa com um font:
  Pinte a string sob o left of a caixa com a cor preta e a font.

Etapas para que se pinte uma string sob o right of uma caixa:
  Pinte a string sob o right of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string sob o right of uma caixa com uma cor:
  Pinte a string sob o right of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string sob o right of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e a font e "right".

Etapas para que se pinte uma string sob o right of uma caixa com um font:
  Pinte a string sob o right of a caixa com a cor preta e a font.

Etapas para que se pinte uma string sob uma localização com uma cor:
  Pinte a string sob a localização com a cor e a fonte padrão.

Etapas para que se pinte uma string em uma caixa:
  Pinte a string na caixa com a cor preta e a fonte padrão e "left".

Etapas para que se pinte uma string em uma caixa over um número com uma cor e uma font e um alinhamento:
  Isole a caixa.
  Se o alinhamento for "left", adicione o número para a coordenada X do canto superior esquerdo desta caixa.
  Se o alinhamento for "zquierda", adicione o número para a coordenada X do canto superior esquerdo desta caixa.
  Se o alinhamento for "derecho", subtraia o número desde a coordenada X do canto inferior direito desta caixa.
  Pinte a string na caixa com a cor e a font e o alinhamento.

Etapas para que se pinte uma string em uma caixa com um alinhamento:
  Pinte a string na caixa com a cor preta e a fonte padrão e o alinhamento.

Etapas para que se pinte uma string em uma caixa com uma cor:
  Pinte a string na caixa com a cor e a fonte padrão e "left".

Etapas para que se pinte uma string em uma caixa com uma cor e um alinhamento:
  Pinte a string na caixa com a cor e a fonte padrão e o alinhamento.

Etapas para que se pinte uma string em uma caixa com uma cor e uma font e um alinhamento:
  Obtenha um offset par de números usando a string e a caixa e a font e o alinhamento.
  Pinte a string sob o canto superior esquerdo desta caixa mais o offset par de números com a cor e a font.

Etapas para que se pinte uma string em uma caixa com uma font e um alinhamento:
  Pinte a string na caixa com a cor preta e a font e o alinhamento.

Etapas para que se pinte uma string no center of uma caixa:
  Pinte a string no center of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string no center of uma caixa com uma cor:
  Pinte a string no center of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string no center of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e a font e "center".

Etapas para que se pinte uma string no center of uma caixa com um font:
  Pinte a string no center of a caixa com a cor preta e a font.

Etapas para que se pinte um terminal:
  Se o terminal for inexistente, cancele.
  Salve o quadro atual.
  Cubra somente fora de a caixa deste terminal.
  Pinte e fill a caixa deste terminal com a cor preta.
  Escreva os quoras deste terminal na caixa deste terminal.
  Restaure o quadro atual.

Etapas para que se pinte um text:
  Se o text for inexistente, cancele.
  Salve o quadro atual.
  Cubra externamente a caixa deste text.
  Pinte algum tipo de visível rows of o text.
  Restaure o quadro atual.

Etapas para que se pinte um text (editing):
  Se o text for inexistente, cancele.
  Salve o quadro atual.
  Cubra externamente a caixa deste text.
  Pinte algum tipo de visível rows of o text (editing).
  Pinte o caret no text.
  Restaure o quadro atual.

Etapas para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos:
  Se o endereço completo é endereço da pasta-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (arquivo).

Etapas para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (pasta)[endereço]:
  Se o endereço completo estiver no segunda endereço completo, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de ". - erro de recursão inválida." ao erro do fluxo de entrada/saída; volte.
  Se o endereço completo não estiver no sistema de arquivos, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; volte.
  Se a segunda endereço completo não estiver no sistema de arquivos, crie a segunda endereço completo no sistema de arquivos.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Atribua o endereço completo a um terceiro endereço completo.
    Posponha o designador deste item para o terceiro endereço completo.
    Atribua a segunda endereço completo a um quarto endereço completo.
    Posponha o designador deste item para o quarto endereço completo.
    Duplicate o terceiro endereço completo para o quarto endereço completo no sistema de arquivos.
  Repita. [o código acima]

Etapas para que se duplicate um endereço completo para um segundo endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Isole o segundo endereço completo.
  Termine com o caractere NULL o segundo endereço completo.
  Call "kernel32.dll" "CopyFileA" com 
    O first deste endereço completo 
    e O first deste segundo endereço completo 
    e 0 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, defina o endereço completo para read-write mode; volte.
  Atribua "Ocorreu um erro na hora de duplicar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.



Uma elipse é um conjunto com uma caixa.

Um email é um conjunto com
  Um smtp server,
  Um sender,
  Um recipient,
  Um subject,
  Uma message.

Etapas para que se encrypt um trecho usando um passphrase string:
  \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie um crypt session usando o passphrase.
  Se o crypt session for inexistente, cancele.
  Atribua o trecho a um temp trecho.
  Atribua a quantidade de caracteres deste temp trecho a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptEncrypt" com 
    A hcryptkey desta crypt session 
    e 0 
    e 1 
    e 0 
    e O first endereço de memória do pedaço deste temp trecho 
    e O endereçamento deste quantidade de caracteres 
    e A quantidade de caracteres 
    devolvendo um número resultante.
  Se o número resultante for 0, atribua "Ocorreu um erro na hora de criptografar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
  Destrua o crypt session.
  Converta o temp trecho para um cifra hexadecimal.
  Atribua a cifra hexadecimal ao trecho.

Etapas para que se enlarge uma caixa por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta caixa.
  Adicione os twips para o canto inferior direito desta caixa.

Etapas para que se enlarge um elipse por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta elipse.
  Adicione os twips para o canto inferior direito desta elipse.

Etapas para que se enfileire um event:
  Posponha o event para a fila de eventos.

Etapas para que se erase o insides of uma caixa;
Etapas para que se erase inside uma caixa;
Etapas para que se limpe inside uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas para que se estime um deslocamento vertical e um deslocamento horizontal usando uma orientação:
  Atribua a orientação a um low orientação.
  Arredonde o low orientação para baixo para o múltiplo imediato of 20.
  Obtenha um low deslocamento vertical e um low deslocamento horizontal usando o low orientação.
  Atribua a orientação a um high orientação.
  Arredonde o high orientação para cima para o múltiplo imediato of 20.
  Obtenha um high deslocamento vertical e um high deslocamento horizontal usando o high orientação.
  Atribua o low deslocamento vertical mais o high deslocamento vertical dividido por 2 ao deslocamento vertical.
  Atribua o low deslocamento horizontal mais o high deslocamento horizontal dividido por 2 ao deslocamento horizontal.

A fila de eventos é uma fila de eventos.

Uma fila de eventos é uns events.

Etapas para que se extend algum tipo de seleção em um text usando uma localização:
  Se o text for inexistente, cancele.
  Obtenha o caret deste text usando a localização e o text.
  Limpe a última operação deste text.

Etapas para que se extend uma caixa para include uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta segunda caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua a coordenada X do canto superior esquerdo desta segunda caixa à coordenada X do canto superior esquerdo desta caixa.
  Se a coordenada Y do canto superior esquerdo desta segunda caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua a coordenada Y do canto superior esquerdo desta segunda caixa à coordenada Y do canto superior esquerdo desta caixa.
  Se a coordenada X do canto inferior direito desta segunda caixa for maior do que a coordenada X do canto inferior direito desta caixa, atribua a coordenada X do canto inferior direito desta segunda caixa à coordenada X do canto inferior direito desta caixa.
  Se a coordenada Y do canto inferior direito desta segunda caixa for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta caixa.

Some  extra points são uns points.

Etapas para que se extraia um designador desde um endereço completo:
  Limpe o designador.
  Extraia um unidade de disco desde o endereço completo.
  Lance um endereço completo subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o first deste endereço completo subtexto.
  Se o endereço completo subtexto estiver em branco, atribua o unidade de disco ao designador; volte.
  Lance um subtexto sobre o last pedaço of o endereço completo subtexto.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o first endereço de memória do pedaço deste subtexto for menor do que o first deste endereço completo subtexto, pare.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Atribua o subtexto ao designador.

Etapas para que se extraia um endereço da pasta desde um endereço completo:
  Limpe o endereço da pasta.
  Extraia um unidade de disco desde o endereço completo.
  Se o unidade de disco estiver em branco, cancele.
  Lance um subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, subtraia 1 desde o last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua a unidade de disco junto com o subtexto ao endereço da pasta.

Etapas para que se extraia um nome do diretório desde um endereço completo:
  Limpe o nome do diretório.
  Se o endereço completo não for endereço da pasta-format, cancele.
  Extraia o nome do diretório como um designador desde o endereço completo.

Etapas para que se extraia um nome da pasta desde um endereço completo:
  Extraia o nome da pasta como um nome do diretório desde o endereço completo.
  Se o nome da pasta estiver em branco, cancele.
  Remove o last pedaço desde o nome da pasta.

Etapas para que se extraia um unidade de disco desde um endereço completo:
  Limpe o unidade de disco.
  Se a quantidade de caracteres deste endereço completo for menor do que 3, cancele.
  Lance um subtexto sobre o first pedaço of o endereço completo.
  Adicione 2 para o last endereço de memória do pedaço deste subtexto.
  Se o subtexto termina com ":\", atribua o subtexto ao unidade de disco; volte.
  Se o subtexto não começa com "\\", cancele.
  Lance o subtexto sobre o first pedaço of o endereço completo.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last deste endereço completo, cancele.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, adicione 1 para uma contagem.
    Se a contagem for 4, pare. \ "\\computer\share\"
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o subtexto ao unidade de disco.

Etapas para que se extraia um extensão desde um endereço completo:
  Limpe o extensão.
  Se o endereço completo estiver em branco, cancele.
  Lance um subtexto sobre o last pedaço of o endereço completo.
  Percorra. [o código abaixo]
    Se o first endereço de memória do pedaço deste subtexto for menor do que o first deste endereço completo, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de dois pontos, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o ponto final, pare.
    Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o subtexto ao extensão.

Etapas para que se extraia um nome do arquivo desde um endereço completo:
  Limpe o nome do arquivo.
  Se o endereço completo não for file-format, cancele.
  Extraia o nome do arquivo como um designador desde o endereço completo.

Etapas para que se extraia um nome do arquivo s/ extensão desde um endereço completo:
  Extraia o nome do arquivo s/ extensão como um nome do arquivo desde o endereço completo.
  Extraia um extensão desde o endereço completo.
  Remove trailing pedaços desde o nome do arquivo s/ extensão usando a quantidade de caracteres desta extensão.

Etapas para que se extraia um imagem usando uma caixa:
  Atribua a largura desta caixa dividido pelo quantidade de twips/pixel a um largura.
  Atribua a altura desta caixa dividido pelo quantidade de twips/pixel a uma altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
    A largura 
    e A altura 
    e 0 
    e 137224 [pixelformat24bpprgb] 
    e 0 
    e O endereçamento desse gpBitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
    O gpBitmap 
    e O endereçamento desse gpgraphic.
  Call "gdiplus.dll" "GdipGetDC" com 
    O gpgraphic 
    e O endereçamento desse bitmap canvas.
  Normalize o bitmap canvas.
  Call "gdi32.dll" "BitBlt" com 
    O bitmap canvas 
    e 0 
    e 0 
    e A largura desta caixa 
    e A altura desta caixa 
  And o quadro atual e a coordenada X do canto superior esquerdo desta caixa e a coordenada Y do canto superior esquerdo desta caixa e 13369376 [srccopy].
  Call "gdiplus.dll" "GdipReleaseDC" com 
    O gpgraphic 
    e O bitmap canvas.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
    O gpgraphic.
  Crie a imagem usando o gpBitmap.
  Atribua a caixa à caixa desta imagem.
  Atribua a caixa à caixa intacta desta imagem.

Etapas para que se extraia uma string desde um text:
  Se o text for inexistente, limpe a string; volte.
  Converta as rows deste text para a string.
  Remove algum tipo de trailing quebra de linha desde a string.
  Remove algum tipo de trailing retorno de carro desde a string.

Etapas para que se extraia uma string desde um text (no linefeed additions):
  Se o text for inexistente, limpe a string; volte.
  Converta as rows deste text para a string (no linefeed additions).
  Remove algum tipo de trailing retorno de carro desde a string.

Etapas para que se extraia uma string desde um text (pedaços selecionados):
  Limpe a string.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
    Se o subtexto estiver em branco, repita.
    Posponha o subtexto para a string.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for o retorno de carro, posponha a quebra de linha para a string.
  Repita. [o código acima]

Etapas para que se face algum tipo de way you want;
Etapas para que se face algum tipo de which way:
  Escolha aleatoriamente uma orientação.

Etapas para que se face east:
  Atribua 960 à orientação deste context.

Etapas para que se face north:
  Atribua 0 à orientação deste context.

Etapas para que se face south:
  Atribua 1920 à orientação deste context.

Etapas para que se face west:
  Atribua 2880 à orientação deste context.

Um flecha estilizada é um figura.

Um figura é um polígono.

As figuras são uns polígonos.

\Um filetime é um conjunto com
\  Um número denominado dwlowdatetime,
\  Um número denominado dwhighdatetime.

Etapas para que se fill uma caixa com uma cor:
  Pinte a caixa com a cor preta e a cor.

Etapas para que se fill um elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor preta e a cor.

Etapas para que se fill uma string com um pedaço usando uma contagem:
  Reassign o first endereço de memória do pedaço desta string usando a contagem.
  Fill pedaços com o pedaço starting sob o first endereço de memória do pedaço desta string pela contagem.
  Atribua o first endereço de memória do pedaço desta string mais a contagem menos 1 ao last endereço de memória do pedaço desta string.

Etapas para que se finalize after run:
  Se a contagem do heap for 0, cancele.
  Atribua a contagem do heap a uma contagem.
  Atribua "Você esqueceu de destruir " junto com a contagem seguido de " elemento(s) no heap." a uma string.
  Produza o relatório de informações usando a string.

Etapas para que se finalize o canvases:
  Finalize o memory canvas.
  Finalize o tela canvas.

Etapas para que se finalize o cgi:
  Call "kernel32.dll" "FreeConsole".

Etapas para que se finalize a cors:

Etapas para que se finalize COM:
  Call "ole32.dll" "CoUninitialize".

Etapas para que se finalize um context:
  Destrua o choices.
  Destrua as figuras.
  Destrua o context stack.
  Destrua o context.

Etapas para que se finalize os cursors:
  \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroycursor
  Call "user32.dll" "DestroyCursor" com 
    O i-beam cursor. 
  Call "user32.dll" "DestroyCursor" com 
    O hand cursor.
  Call "user32.dll" "DestroyCursor" com 
    A seta do mouse.

Etapas para que se finalize as fonts:
  \Call "gdi32.dll" "RemoveFontMemResourceEx" com o osmosian font resource.
  \Call "gdi32.dll" "RemoveFontMemResourceEx" com o Segoe UI resource.
  Call "gdi32.dll" "RemoveFontMemResourceEx" com 
    O recurso de fonte Tahoma. \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-RemoveFontMemResourceEx

Etapas para que se finalize gdi+:
  Call "gdiplus.dll" "GdiplusShutdown" com 
    O gpToken. \https://docs.microsoft.com/en-us/windows/win32/api/gdiplusinit/nf-gdiplusinit-gdiplusshutdown

Etapas para que se finalize o memory canvas:
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O saved memory hbitmap 
    devolvendo um hbitmap. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  Call "gdi32.dll" "DeleteObject" com 
    O hbitmap. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  Call "gdi32.dll" "DeleteDC" com 
    O memory canvas. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deletedc

Etapas para que se finalize o module:

Etapas para que se finalize o mouse:

Etapas para que se finalize a área de impressão:
  Call "kernel32.dll" "GlobalFree" com \https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalfree
    o número identificador do modo de dispositivo da impressora.
    \ Um identificador para o objeto de memória global. 
    \Esse identificador é retornado pela função GlobalAlloc ou GlobalReAlloc. 
    \Não é seguro liberar memória alocada com LocalAlloc.
  Atribua 0 ao área de impressão.

Etapas para que se finalize a tela:

Etapas para que se finalize o tela canvas:

Etapas para que se finalize um talker:
  Se o talker for inexistente, cancele.
  Call a release desta vtable deste talker com o talker.
  Atribua nil ao talker.

Etapas para que se finalize o janela do programa:
  Call "user32.dll" "DestroyWindow" com 
    A janela principal do programa. \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow
  Percorra. [o código abaixo]
  Call "user32.dll" "GetMessageA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea
      o endereçamento dessa msg \Um ponteiro para uma estrutura MSG que recebe informações da mensagem da fila de mensagens do segmento.
      e 0 \Um identificador para a janela cujas mensagens devem ser recuperadas. A janela deve pertencer ao segmento atual.
    \Se hWnd for NULL, GetMessage recuperará mensagens para qualquer janela que pertença ao segmento atual 
    \e quaisquer mensagens na fila de mensagens do segmento atual cujo valor hwnd seja NULL (consulte a estrutura MSG). https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-msg
    \Portanto, se hWnd for NULL, as mensagens da janela e as mensagens do thread serão processadas.
      e 0 \O valor inteiro do menor valor da mensagem a ser recuperado. 
    \Use WM_KEYFIRST (0x0100) para especificar a primeira mensagem do teclado ou WM_MOUSEFIRST (0x0200) para especificar a primeira mensagem do mouse.
      e 0 \O valor inteiro do maior valor da mensagem a ser recuperado. 
    \Use WM_KEYLAST para especificar a última mensagem do teclado ou WM_MOUSELAST para especificar a última mensagem do mouse.
    \Se wMsgFilterMin e wMsgFilterMax forem 0, GetMessage retorna todas as mensagens disponíveis (ou seja, nenhuma filtragem de intervalo é executada).
      devolvendo um número. \Se a função recuperar uma mensagem diferente de WM_QUIT, o valor de retorno será diferente de zero.
    \Se a função recuperar a mensagem WM_QUIT, o valor de retorno será zero.
    \Se houver um erro, o valor de retorno é -1. 
    \Por exemplo, a função falhará se hWnd for um identificador de janela inválido ou lpMsg for um ponteiro inválido. 
    \Para obter informações de erro estendidas, use a função GetLastError. https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror
    \\ Execute a função "GetMessageA" da biblioteca "user32.dll" usando como argumentos os seguintes parâmetros: 
    \\ o endereçamento dessa msg e os valores 0, 0 e 0, esperando um número como resultado.
    Se o número for menor do que 1, pare.
    Call "user32.dll" "TranslateMessage" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage
      o endereçamento desta msg. \Um ponteiro para uma estrutura MSG que contém informações de mensagem recuperadas da fila de mensagens do thread de chamada usando a função GetMessage ou PeekMessage.
    Call "user32.dll" "DispatchMessageA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagea
      o endereçamento desta msg. \Um ponteiro para uma estrutura que contém a mensagem.
  Repita. [o código acima]
  Desmanche a fila de eventos.
  Destrua o evento atual.

Etapas para que se finalize winsock:
  Call "ws2_32.dll" "WSACleanup".\https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsacleanup

A find anchor é uma anchor.

Etapas para que se encontre uma choice usando uma localização:
  Start com nada no choice.
  Percorra. [o código abaixo]
    Obtenha o [first/next] choice desde as choices.
    Se o choice for missing, cancele.
    Se a localização estiver na caixa desta choice, pare.
  Repita. [o código acima]

Etapas para que se encontre um dyad usando uns dyads e um nome:
  Esvazie o dyad.
  Percorra. [o código abaixo]
    Obtenha o dyad desde o dyads.
    Se o dyad for inexistente, cancele.
    Se o nome deste dyad for o nome, cancele.
  Repita. [o código acima]

Etapas para que se encontre next usando uma row e um text e um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Lance um subtexto sobre a string deste row.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres deste find string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Se o número da linha desta row for o número da linha deste find anchor, mova o subtexto usando o número de coluna deste find anchor menos 1.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que ou igual ao last endereço de memória do pedaço desta string desta row, cancele.
    Se o subtexto for o find string (accent-free compare), pare. \ for spanish incremental find
    Mova o subtexto usando 1.
  Repita. [o código acima]
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 1 ao anchor número de coluna deste text.
  Atribua o número da linha desta row ao anchor número da linha deste text .
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 2 ao caret número de coluna deste text.
  Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas para que se encontre next usando um text e um detector:
  Se o wrap detector deste text estiver ativo, encontre next usando o text e o detector (wrapped text); volte.
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a quantidade de caracteres deste find string for 0, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
    Encontre next usando a row e o text e o detector.
    Se o detector estiver ativo, cancele.
  Repita. [o código acima]

Etapas para que se encontre next usando um text e um detector (wrapped text):
  Desative o detector.
  Se o text for inexistente, cancele.
  Converta o find anchor para um posicionamento absoluto denominado offset usando o text.
  Extraia uma string desde o text (no linefeed additions).
  Atribua o first endereço de memória do pedaço desta string mais o offset menos 1 ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres deste find string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta string, cancele.
    Se o subtexto for a find string (accent-free compare), pare. \ para o spanish incremental find
    Mova o subtexto usando 1.
  Repita. [o código acima]
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string mais 1 a um anchor posicionamento absoluto.
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string mais 2 a um caret posicionamento absoluto.
  Converta o anchor posicionamento absoluto para o anchor deste text usando o text.
  Converta o caret posicionamento absoluto para o caret deste text usando o text.

Etapas para que se encontre o next misspelling usando uma row e um text e um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Lance um percorredor sobre a string deste row.
  Se o número da linha desta row for o número da linha deste find anchor, adicione o número de coluna deste find anchor menos 1 para o first endereço de memória do pedaço deste segmento final deste percorredor.
  Se o first endereço de memória do pedaço deste segmento final deste percorredor não for o first endereço de memória do pedaço desta string desta row, skip palavra characters no segmento final deste percorredor.
  Percorra. [o código abaixo]
    Mova o percorredor (spell checking rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor não estiver escrito incorretamente, repita.
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste segmento inicial deste percorredor menos o first endereço de memória do pedaço desta string desta row mais 1 ao anchor número de coluna deste text.
  Atribua o número da linha desta row ao anchor número da linha deste text .
  Atribua o last endereço de memória do pedaço deste segmento inicial deste percorredor menos o first endereço de memória do pedaço desta string desta row mais 2 ao caret número de coluna deste text.
  Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas para que se encontre o next misspelling em um text usando um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
    Encontre o next misspelling usando a row e o text e o detector.
    Se o detector estiver ativo, cancele.
  Repita. [o código acima]



Etapas para que se encontre um endereço de memória usando uma string e um catálogo:
  Encontre um refer usando a string e o catálogo.
  Se o refer não for inexistente, atribua o endereço de memória deste refer ao endereço de memória; volte.
  Esvazie o endereço de memória.

Etapas para que se encontre um refer usando uma string e um catálogo:
  Se o catálogo for inexistente, cancele.
  Se a string estiver em branco, esvazie o refer; volte.
  Obtenha um bucket usando a string e o catálogo.
  Encontre o refer usando a string e os refers deste bucket.

Etapas para que se encontre um refer usando uma string e uns refers:
  Esvazie o refer.
  Percorra. [o código abaixo]
    Obtenha o refer desde o refers.
    Se o refer for inexistente, cancele.
    Se a string for a string deste refer, cancele.
  Repita. [o código acima]

Etapas para que se encontre um sector usando um malha e uma localização:
  Atribua a coordenada X desta localização dividido pelo número X desta malha times o número X desta malha à coordenada X deste sector.
  Atribua a coordenada Y desta localização dividido pelo número Y desta malha times o número Y desta malha à coordenada Y deste sector.

Etapas para que se encontre um square root of um número:
  \ arredonda para baixo
  Isole o número.
  De-sign o número.
  Se o número for 0, atribua 0 ao square root; volte.
  Se o número for 1, atribua 1 ao square root; volte.
  Atribua 1 a um square número.
  Atribua 3 a um delta número.
  Percorra. [o código abaixo]
    Se o square for maior do que o número, pare.
    Adicione o delta para o square.
    Adicione 2 para o delta.
  Repita. [o código acima]
  Atribua o delta dividido por 2 menos 1 ao square root.

Etapas para que se encontre uma string usando uns conjunto de textos e uma string#:
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha um conjunto de texto desde o conjunto de textos.
    Se o conjunto de texto for inexistente, cancele.
    Adicione 1 para uma contagem.
    Se a contagem não for a string#, repita.
  Atribua a string deste conjunto de texto à string.

O find string é uma string.

Etapas para que se encontre um conjunto de texto usando uma string e uns conjunto de textos:
  Esvazie o conjunto de texto.
  Percorra. [o código abaixo]
    Obtenha o conjunto de texto usando o conjunto de textos.
    Se o conjunto de texto for inexistente, pare.
    Se a string deste conjunto de texto é a string, pare.
  Repita. [o código acima]

Etapas para que se encontre um subtexto em uma string usando uma segunda string:
  Lance o subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o subtexto começa com a segunda string, pare.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao last endereço de memória do pedaço deste subtexto.

Etapas para que se encontre um value string usando uns dyads e um nome:
  Encontre um dyad usando o dyads e o nome.
  Se o dyad for inexistente, limpe o value; volte.
  Atribua o value deste dyad ao value.

Etapas para que se encontre um value string usando o environment variáveis e um nome:
  Isole o nome.
  Termine com o caractere NULL o nome.
  Atribua 32767 a uma quantidade de caracteres. \ max size por environment variável
  Reassign o first deste value usando a quantidade de caracteres.
  Call "kernel32.dll" "GetEnvironmentVariableA" com 
    O first deste nome 
    e O first deste value 
    e A quantidade de caracteres 
    devolvendo a quantidade de caracteres.
  Atribua o first deste value mais a quantidade de caracteres menos 1 ao last deste value.

Um finger é um endereço de memória do pedaço .

\Um flag has 4 pedaços.
Um detector é uma coisa com 4 pedaços. \é um conjunto com

Etapas para que se flip um fração:
  Permute o numerador desta fração com o denominador desta fração.

Etapas para que se flip o gpBitmap em um imagem:
  Se a imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Flip o gpBitmap desta imagem.

Etapas para que se flip um GpImage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O GpImage 
    e 6 [RotateNoneFlipY aka Rotate180FlipX].

Etapas para que se flip um imagem:
  Se a imagem for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa desta imagem menos a coordenada Y deste center desta caixa intacta desta imagem ao número Y desse par de números.
  Multiplique o número Y deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Flip o gpBitmap no imagem.

Etapas para que se flip um polígono:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia a coordenada Y do canto superior esquerdo desta caixa desde a coordenada Y deste vértice.
    Atribua a coordenada Y do canto inferior direito desta caixa menos a coordenada Y deste vértice à coordenada Y deste vértice.
  Repita. [o código acima]

Etapas para que se desmanche all input;
Etapas para que se desmanche all inputs;
Etapas para que se desmanche all events:
  Desmanche algum tipo de messages.
  Desmanche a fila de eventos.

Etapas para que se desmanche algum tipo de messages:
  Call "user32.dll" "PeekMessageA" com 
    O endereçamento dessa msg 
    e 0 
    e 0 
    e 0 
    e 1 [PM_REMOVE] devolvendo um número.
  Se o número for 0, cancele.
  Se a message desta msg for 15 [WM_PAINT], Call "user32.dll" "ValidateRect" com a janela principal do programa e 0. \ que tal ter uma rotina específica para isso?
  Repita. [o código acima]

Etapas para que se desmanche um fila de eventos:
  Obtenha um event desde a fila de eventos.
  Se o event for inexistente, cancele.
  Remove o event desde a fila de eventos.
  Destrua o event.
  Repita. [o código acima]

Uma font é um conjunto com 
  Um nome e 
  Uma altura.

Um altura da fonte é uns twips. \ indicates linha reta altura - o letras will fit nicely em uma caixa of this altura

Um font resource é um número identificador.

Um pé são 12 polegadas.

Etapas para que se format um número e um singular string ou um plural string Para uma string: \verificar
  Converta o número para a string.
  Posponha o caractere de espaço para a string.
  Se o número for 1, posponha o singular para a string.
  Se o número não for 1, posponha o plural para a string.

Um fração é um conjunto com 
  Um numerador número e 
  Um denominador número, e 
  Um topo número sob o numerador e 
  Um base número sob o denominador.

Um par de números fracionários é um conjunto com 
  Uma fração e 
  Uma segunda fração.

Um máximo divisor comum é um número.

Um figura geométrica é um figura.

Etapas para que se obtenha um abcA e um abcC usando uma string e um canvas:
  Atribua 0 ao abcA.
  Atribua 0 ao abcC.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O endereçamento desse ABC.
  Atribua o abcA deste ABC ao abcA.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste last endereço de memória do pedaço desta string 
    e O conteúdo deste last endereço de memória do pedaço desta string 
    e O endereçamento desse segunda ABC.
  Atribua o abcC desta segunda ABC ao abcC.

Etapas para que se obtenha um abcA usando uma string e um canvas:
  Atribua 0 ao abcA.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O endereçamento desse ABC.
  Atribua o abcA deste ABC ao abcA.

Etapas para que se obtenha uns addrinfo routines:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "LoadLibraryA" com "ws2_32.dll"'s first endereço de memória do pedaço devolvendo um número identificador.
  Se o número identificador for 0, atribua "Não foi possível obter o valor do endereço de memória da biblioteca ws2_32.dll." ao erro do fluxo de entrada/saída; volte.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador \Um identificador para o módulo DLL que contém a função ou variável. 
    \A função LoadLibrary, LoadLibraryEx, LoadPackagedLibrary ou GetModuleHandle retorna esse identificador.
    e "getaddrinfo"'s first endereço de memória do pedaço [ponteiro para uma string constante]  \ O nome da função ou variável, ou o valor ordinal da função. 
    \Se este parâmetro for um valor ordinal, ele deve estar contido na word de ordem inferior; a word de ordem superior deve ser zero.
    devolvendo um endereço de memória. \ obtendo/recebendo/aguardando como resultado
  Se o endereço de memória for inexistente, atribua "Infelizmente essa rotinas só funciona no Windows XP ou superior." ao erro do fluxo de entrada/saída; volte.
  Atribua o endereço de memória ao getaddrinfo endereço de memória destas addrinfo routines.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador 
    e "freeaddrinfo"'s first endereço de memória do pedaço [ponteiro para uma string constante] 
    devolvendo o endereço de memória.
  Se o endereço de memória for inexistente, atribua "Infelizmente essas rotinas só funcionam no Windows XP ou numa versão superior do Windows." ao erro do fluxo de entrada/saída; volte.
  Atribua o endereço de memória ao freeaddrinfo endereço de memória destas addrinfo routines.

Etapas para que se obtenha uma caixa pelo caret em um text:
  Se o text for inexistente, zero a caixa; volte.
  Obtenha uma localização usando o caret deste text e o text.
  Atribua a localização e a localização ao caixa.
  Adicione a altura da linha deste text para a coordenada Y do canto inferior direito desta caixa.
  Ajuste a caixa usando 0 e a quantidade de twips/pixel e 0 e - a quantidade de twips/pixel .
  Atribua a globalized origem deste text a um origem.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X desta origem, atribua a coordenada X desta origem à coordenada X do canto superior esquerdo desta caixa; atribua a coordenada X desta origem à coordenada X do canto inferior direito desta caixa.
  Se o wrap detector deste text não estiver ativo, cancele.
  Limite a coordenada X do canto superior esquerdo desta caixa para a coordenada X do canto superior esquerdo deste text e a coordenada X do canto inferior direito deste text.
  Limite a coordenada X do canto inferior direito desta caixa para a coordenada X do canto superior esquerdo deste text e a coordenada X do canto inferior direito deste text.

Etapas para que se obtenha uma caixa por um linha reta:
  Atribua a localização inicial desta linha reta ao canto superior esquerdo desta caixa.
  Atribua a localização final desta linha reta ao canto inferior direito desta caixa.
  Normalize a caixa.

Etapas para que se obtenha uma caixa usando uma row e um text:
  Se o text for inexistente, zero a caixa; volte.
  Se a row for inexistente, zero a caixa; volte.
  Atribua a globalized origem deste text ao canto superior esquerdo desta caixa.
  Adicione o número da linha desta row menos 1 times a altura da linha deste text para a coordenada Y do canto superior esquerdo desta caixa.
  Atribua a coordenada X do canto inferior direito deste text à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura da linha deste text à coordenada Y do canto inferior direito desta caixa.

Etapas para que se obtenha um bucket usando um bucket# e um catálogo:
  \ if o catálogo for inexistente, esvazie o bucket; volte. \ para fazer compilador faster
  Atribua o first bucket deste catálogo ao bucket.
  Adicione o bucket# times a magnitude desse conjunto de buckets para o bucket.

Etapas para que se obtenha um bucket usando um catálogo:
  \Se o catálogo for inexistente, esvazie o bucket; volte. \ para fazer o compilador mais rápido
  Se o bucket for inexistente, atribua o first bucket deste catálogo ao bucket; volte.
  Se o bucket for o last bucket deste catálogo, esvazie o bucket; volte.
  Adicione a magnitude desse conjunto de buckets para o bucket.

Etapas para que se obtenha um bucket usando uma string e um catálogo:
  \ if o catálogo for inexistente, esvazie o bucket; volte. \ para fazer compilador faster
  Obtenha um bucket# usando a string e o catálogo.
  Obtenha o bucket usando o bucket# e o catálogo.

Etapas para que se obtenha um bucket# usando uma string e um catálogo:
  \ baseado no algoritmo djb2 
  \ if o catálogo for inexistente, atribua 0 ao bucket#; volte. \ para fazer compilador faster
  Atribua a quantidade de caracteres desta string ao bucket#.
  Se o bucket# for 0, cancele.
  Adicione 5381 para o bucket#.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um pedaço.
    Lowercase o pedaço.
    Atribua o bucket# a um número.
    Desloque o bucket# left 5 bits.
    Adicione o número para o bucket#.
    Adicione o pedaço para o bucket#.
    Adicione 3 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, pare.
  Repita. [o código acima]
  Conjuncione logicamente o bucket# com o maior número.
  Divida o bucket# pela contagem de buckets deste catálogo usando um quociente e o bucket#.

Etapas para que se obtenha um pedaço desde uma string:
  Se a string estiver em branco, atribua o caractere null ao pedaço; volte.
  Atribua o conteúdo deste first endereço de memória do pedaço desta string ao pedaço.
  Remove o first pedaço desde a string.

Etapas para que se obtenha um pedaço desde uma string (backwards):
  Se a string estiver em branco, atribua o caractere null ao pedaço; volte.
  Atribua o conteúdo deste last endereço de memória do pedaço desta string ao pedaço.
  Remove o last pedaço desde a string.

Etapas para que se obtenha um center localização usando uma localização e uma segunda localização:
  Atribua a localização e a segunda localização a um linha reta.
  Atribua o center desta linha reta ao center.

Etapas para que se obtenha uma cor usando uma localização:
  Call "gdi32.dll" "GetPixel" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um código da cor.
  Converta o código da cor para a cor.

Etapas para que se obtenha um número de coluna usando uma row e uma localização e um text:
  Atribua 0 ao número de coluna.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a quantidade de caracteres desta string desta row ao número de coluna; volte. \ only happens sobre last row of text
  Crie o número da fonte of o memory canvas usando a font deste text.
  Obtenha um start largura e um subtexto usando a row e a localização e o text (for "get um número de coluna usando uma row...").
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto é o last endereço de memória do pedaço desta string desta row, pare.
    Obtenha um largura usando o subtexto e o memory canvas.
    Adicione o start largura para a largura.
    Obtenha uma segunda largura usando o conteúdo deste last endereço de memória do pedaço deste subtexto e o memory canvas.
    Divida a segunda largura por 2.
    Subtraia a segunda largura desde a largura.
    Se a coordenada X desta localização for menor do que a largura, pare.
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 1 ao número de coluna.
  Destrua o número da fonte of o memory canvas.

Etapas para que se obtenha uma contagem of items em um endereço completo no sistema de arquivos:
  Atribua 0 à contagem.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se obtenha um description por um endereço completo:
  Limpe o description.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Atribua o categoria da unidade de disco ao description.
  Obtenha um nome da unidade de disco pelo endereço completo.
  Se o nome da unidade de disco não estiver em branco, atribua o nome da unidade de disco ao description.
  Lowercase o description.

Etapas para que se obtenha um difference entre um par de números e um segundo par de números:
  Atribua o par de números à difference.
  Subtraia o segundo par de números desde a difference.

Etapas para que se obtenha um difference entre um par de números e um segundo par de números usando um malha par de números:
  Obtenha a difference entre o par de números e o segundo par de números.
  Arredonde a difference para a malha.

Etapas para que se obtenha um distance entre uma localização e uma segunda localização (approximate):
  Atribua a coordenada X desta localização menos o x desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos o y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número times o número ao distance.
  Adicione o segundo número times o segundo número para o distance.
  Encontre um square root of o distance.
  Atribua o square root ao distance.
  Se a tecla D/d estiver sendo pressionada, produza o relatório de informações usando o distance.

Etapas para que se obtenha um distance entre uma localização e uma segunda localização (chessboard):
  Atribua a coordenada X desta localização menos a coordenada X desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos a coordenada Y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número ao distance.
  Se o segundo número for maior do que o número, atribua o segundo número ao distance.

Etapas para que se obtenha um categoria da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetDriveTypeA" com 
    O first deste endereço completo 
    devolvendo um número.
  Se o número for 2 [DRIVE_REMOVABLE], atribua "Disco removível" à categoria da unidade de disco; volte. \ removable drive
  Se o número for 3 [DRIVE_FIXED], atribua "Disco Rígido / Pendrive" à categoria da unidade de disco; volte.\ hard disk / flash drive
  Se o número for 4 [DRIVE_REMOTE], atribua "Unidade de rede" à categoria da unidade de disco; volte. \ network drive
  Se o número for 5 [DRIVE_CDROM], atribua "Unidade de CD/DVD" à categoria da unidade de disco; volte. \ cd-rom / dvd drive
  Se o número for 6 [DRIVE_RAMDISK], atribua "Unidade de disco RAM" à categoria da unidade de disco; volte. \ unidade virtual de disco criada a partir da RAM
  Atribua "" à categoria da unidade de disco.

Etapas para que se obtenha um nome da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Atribua 512 a uma quantidade de caracteres.
  Reassign o first endereço de memória do pedaço desse trecho usando a quantidade de caracteres.
  Call "kernel32.dll" "GetVolumeInformationA" com 
    O first deste endereço completo 
    e O first endereço de memória do pedaço deste trecho
   e a quantidade de caracteres 
   e 0 
   e 0 
   e 0 
   e 0 
   e 0 devolvendo um número.
  Se o número for 0, limpe o nome da unidade de disco; volte.
  Converta o first deste trecho como um endereçamento de caractere para o nome da unidade de disco.

Etapas para que se obtenha o first-eighth equivalent of uma orientação:
  Obtenha o first-quarter equivalent of a orientação.
  Se a orientação for menor do que 480, cancele.
  Subtraia 960 desde a orientação.
  De-sign a orientação.

Etapas para que se obtenha o first-quarter equivalent of uma orientação:
  Se a orientação for menor do que 960, cancele.
  Subtraia 960 desde a orientação.
  Repita. [o código acima]

Etapas para que se obtenha fresh random números;
Etapas para que se obtenha new random números;
Etapas para que se seed o número aleatório generator:
  Atribua a contagem de intervalos do sistema à seed.

Etapas para que se obtenha um máximo divisor comum usando um número e um segundo número:
  Atribua o número a um dividend número.
  Atribua o segundo número ao máximo divisor comum.
  De-sign o dividend número.
  De-sign o máximo divisor comum.
  Se o dividend for menor do que o máximo divisor comum, permute o dividend com o máximo divisor comum.
  Se o máximo divisor comum for 0, atribua 1 ao máximo divisor comum; volte.
  Percorra. [o código abaixo]
    Divida o dividend pelo máximo divisor comum usando um quociente e um resto.
    Se o resto for 0, cancele.
    Atribua o máximo divisor comum ao dividend.
    Atribua o resto ao máximo divisor comum.
  Repita. [o código acima]

Etapas para que se obtenha um Endereço IP usando um host string:
  Limpe o Endereço IP.
  Obtenha um sockaddr usando o host string.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua o s_addr deste sin_addr deste sockaddr ao número deste Endereço IP.
  Call "ws2_32.dll" "inet_ntoa" com 
    O número deste Endereço IP 
    devolvendo um endereçamento de caractere.
  Converta o endereçamento de caractere para a string deste Endereço IP.

Etapas para que se obtenha um item (novamente):
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "FindNextFileA" com 
    O número identificador deste item 
    e O endereçamento deste WIN32FINDDATA deste item 
    devolvendo um número.
  Se o número não for 0, ajuste o item; volte.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindClose" com 
    O número identificador deste item.

Etapas para que se obtenha um item desde um endereço completo:
  Se o endereço completo não for endereço da pasta-format, cancele.
  Atribua o endereço completo ao endereço da pasta deste item.
  Se a categoria deste item estiver em branco, obtenha o item desde o endereço completo (pela primeira vez); volte.
  Obtenha o item (novamente).

Etapas para que se obtenha um item desde um endereço completo (pela primeira vez):
  Limpe o erro do fluxo de entrada/saída.
  Isole o endereço completo.
  Posponha "*.*" para o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindFirstFileA" com 
    O first deste endereço completo 
    e O endereçamento deste WIN32FINDDATA deste item 
    devolvendo o número identificador deste item.
  Se o número identificador deste item for -1 [INVALID_HANDLE_VALUE], cancele.
  Ajuste o item.

Etapas para que se obtenha um mínimo múltiplo comum usando um número e um segundo número:
  Obtenha um máximo divisor comum usando o número e o segundo número.
  Call "kernel32.dll" "MulDiv" com 
    O número 
    e O segundo número 
    e O máximo divisor comum 
    devolvendo o mínimo múltiplo comum.

Etapas para que se obtenha um letra desde o alphabet:
  Atribua o next letra ao letra.
  Avance o next letra limitando-a para o 'A' maiúsculo e o Z maiúsculo.
  Adicione 1 para o next letra.
  Se o next letra for maior do que o Z maiúsculo, atribua o 'A' maiúsculo à next letra.

Etapas para que se obtenha um número desde a stack:
  Atribua 0 ao número.
  Obtenha um stack entry desde o stack.
  Se a stack entry for inexistente, cancele.
  Converta a string desta stack entry para o número.
  Remove a stack entry desde o stack.
  Destrua a stack entry.

Etapas para que se obtenha um offset par de números usando uma string e uma caixa e uma font e um alinhamento:
  Crie o número da fonte of o memory canvas usando a font.
  Obtenha o offset par de números usando a string e a caixa e a font e o alinhamento (fast).
  Destrua o número da fonte of o memory canvas.

Etapas para que se obtenha um offset par de números usando uma string e uma caixa e uma font e um alinhamento (fast):
  Se o alinhamento for "left", obtenha o número X deste offset par de números usando a string e a caixa (fast - left).
  Se o alinhamento for "right", obtenha o número X deste offset par de números usando a string e a caixa (fast - right).
  Se o alinhamento for "center", obtenha o número X deste offset par de números usando a string e a caixa (fast - center).
  Call "gdi32.dll" "GetTextMetricsA" com 
    O memory canvas 
    e O endereçamento desse textmetric.
  Adicione a altura desta caixa menos a tmheight deste textmetric dividido por 2 para o número Y deste offset par de números.

Etapas para que se obtenha uma position usando uma localização e um text:
  Se o text for inexistente, limpe o position; volte.
  Obtenha uma row usando a localização e o text.
  Atribua o número da linha desta row ao número da linha desta position.
  Obtenha o número de coluna desta position usando a row e a localização e o text.

Etapas para que se obtenha um endereço de memória RGB desde um BitmapData sob um número da linha e um número de coluna:
  \ 1 based
  Atribua o scan0 deste BitmapData ao endereço de memória RGB.
  Adicione o número da linha menos 1 times o stride deste BitmapData para o endereço de memória RGB.
  Adicione o número de coluna menos 1 times a magnitude desse espaço de cor RGB para o endereço de memória RGB.

Etapas para que se obtenha um deslocamento vertical e um deslocamento horizontal usando uma orientação: \deslocamento horizontal e vertical?
  \ veja https://pt.wikipedia.org/wiki/Trigonometria_racional
  \ https://pt.wikipedia.org/wiki/Física_digital
  \ A trigonometria racional evita o uso direto de funções transcendentes, como seno e cosseno, substituindo-as por seus equivalentes quadráticos.
  Isole a orientação.
  Normalize a orientação.
  Normalize o original orientação.
  Se a orientação não for uniformemente divisível por 20, estime o deslocamento vertical e o deslocamento horizontal usando a orientação; volte.
  \ special cases
  Se a orientação for 0, atribua -10000 ao deslocamento vertical; atribua -0 ao deslocamento horizontal; volte. \ 0 graus
  Se a orientação for 960, atribua 10000 ao deslocamento horizontal; atribua -0 ao deslocamento vertical; volte. \ 90 graus
  Se a orientação for 1920, atribua 10000 ao deslocamento vertical; atribua 0 ao deslocamento horizontal; volte. \ 180 graus
  Se a orientação for 2880, atribua -10000 ao deslocamento horizontal; atribua 0 ao deslocamento vertical; volte. \ 270 graus
  Se a orientação for 3840, produza o relatório de informações usando "orientação inválida"; produza o relatório de informações usando a orientação; produza o relatório de informações usando o original orientação.
  \ force it ao first eighth of o circle
  Obtenha o first-eighth equivalent of a orientação.
  \ encontre o first eighth of o circle unsigned values
  Se a orientação for 20, atribua 0327 ao deslocamento horizontal; atribua 9995 ao deslocamento vertical; pare. \ 1.875 degrees
  Se a orientação for 40, atribua 0654 ao deslocamento horizontal; atribua 9979 ao deslocamento vertical; pare. \ 3.75 degrees
  Se a orientação for 60, atribua 0980 ao deslocamento horizontal; atribua 9952 ao deslocamento vertical; pare. \ 5.625 degrees = 1/64 of o caminho
  Se a orientação for 80, atribua 1305 ao deslocamento horizontal; atribua 9914 ao deslocamento vertical; pare. \7.5 degrees
  Se a orientação for 100, atribua 1629 ao deslocamento horizontal; atribua 9866 ao deslocamento vertical; pare. \ 9.375 degrees
  Se a orientação for 120, atribua 1951 ao deslocamento horizontal; atribua 9808 ao deslocamento vertical; pare. \ 11.25 degrees = 2/64 of o caminho
  Se a orientação for 140, atribua 2271 ao deslocamento horizontal; atribua 9739 ao deslocamento vertical; pare. \ 13.125 degrees
  Se a orientação for 160, atribua 2588 ao deslocamento horizontal; atribua 9659 ao deslocamento vertical; pare. \ 15 degrees
  Se a orientação for 180, atribua 2903 ao deslocamento horizontal; atribua 9569 ao deslocamento vertical; pare. \ 16.875 degrees = 3/64 of o caminho
  Se a orientação for 200, atribua 3214 ao deslocamento horizontal; atribua 9469 ao deslocamento vertical; pare. \ 18.75 degrees
  Se a orientação for 220, atribua 3523 ao deslocamento horizontal; atribua 9359 ao deslocamento vertical; pare. \ 20.625 degrees
  Se a orientação for 240, atribua 3827 ao deslocamento horizontal; atribua 9239 ao deslocamento vertical; pare. \ 22.5 degrees = 4/64 of o caminho
  Se a orientação for 260, atribua 4127 ao deslocamento horizontal; atribua 9109 ao deslocamento vertical; pare. \ 24.375 degrees
  Se a orientação for 280, atribua 4423 ao deslocamento horizontal; atribua 8969 ao deslocamento vertical; pare. \ 26.25 degrees
  Se a orientação for 300, atribua 4714 ao deslocamento horizontal; atribua 8819 ao deslocamento vertical; pare. \ 28.125 degrees = 5/64 of o caminho
  Se a orientação for 320, atribua 5000 ao deslocamento horizontal; atribua 8660 ao deslocamento vertical; pare. \ 30 degrees
  Se a orientação for 340, atribua 5281 ao deslocamento horizontal; atribua 8492 ao deslocamento vertical; pare. \ 31.875 degrees
  Se a orientação for 360, atribua 5556 ao deslocamento horizontal; atribua 8315 ao deslocamento vertical; pare. \ 33.75 degrees = 6/64 of o caminho
  Se a orientação for 380, atribua 5825 ao deslocamento horizontal; atribua 8128 ao deslocamento vertical; pare. \ 35.625 degrees
  Se a orientação for 400, atribua 6088 ao deslocamento horizontal; atribua 7934 ao deslocamento vertical; pare. \ 37.5 degrees
  Se a orientação for 420, atribua 6344 ao deslocamento horizontal; atribua 7730 ao deslocamento vertical; pare. \ 39.375 degrees = 7/64 of o caminho
  Se a orientação for 440, atribua 6593 ao deslocamento horizontal; atribua 7518 ao deslocamento vertical; pare. \ 41.25 degrees
  Se a orientação for 460, atribua 6836 ao deslocamento horizontal; atribua 7299 ao deslocamento vertical; pare. \ 43.125 degrees
  Se a orientação for 480, atribua 7071 ao deslocamento horizontal; atribua 7071 ao deslocamento vertical; pare. \ 45 degrees = 8/64 of o caminho
  Repita. [o código acima] \ não é realmente um comando de repetição, é apenas um marcador para as "breaks" aí de cima.
  \ ajuste por segunda eighths of o circle
  Se o original orientação estiver entre 0 e 480, negate o deslocamento vertical; volte. \ 1st eighth (12:00 para 1:30)
  Se o original orientação estiver entre 480 e 960, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento vertical; volte. \ 2nd eighth (1:30 para 3:00)
  Se o original orientação estiver entre 960 e 1440, permute o deslocamento horizontal com o deslocamento vertical; volte. \ 3rd eighth (3:00 para 4:30)
  Se o original orientação estiver entre 1440 e 1920, cancele. \ 4th eighth (4:30 para 6:00)
  Se o original orientação estiver entre 1920 e 2400, negate o deslocamento horizontal; volte. \ 5th eighth (6:00 para 7:30)
  Se o original orientação estiver entre 2400 e 2880, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; volte. \ 6th eighth (7:30 para 9:00)
  Se o original orientação estiver entre 2880 e 3360, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; negate o deslocamento vertical; volte. \ 7th eighth (9:00 para 10:30)
  Se o original orientação estiver entre 3360 e 3840, negate o deslocamento horizontal; negate o deslocamento vertical; volte. \ 8th eighth (10:30 para 12:00)

Etapas para que se obtenha uma row usando um número da linha e um text:
  Esvazie a row.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha a row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for o número da linha, cancele.
  Repita. [o código acima]

Etapas para que se obtenha uma row usando uma localização e um text:
  Se o text for inexistente, esvazie a row; volte.
  Atribua a coordenada Y desta localização a uma coordenada Y.
  Limite a coordenada Y para a coordenada Y do canto superior esquerdo deste text e a coordenada Y do canto inferior direito deste text.
  Atribua a coordenada Y menos a coordenada Y desta globalized origem deste text dividido pela altura da linha deste text mais 1 a um número da linha.
  Limite o número da linha para 1 e a contagem de linhas deste text.
  Obtenha a row usando o número da linha e o text.

Etapas para que se obtenha uma caixa de seleção usando uma row e um text:
  Limpe a caixa de seleção.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Atribua a caixa ao caixa de seleção.
  Obtenha a caixa de seleção usando a row e o text (lado esquerdo).
  Obtenha a caixa de seleção usando a row e o text (lado direito).

Etapas para que se obtenha uma caixa de seleção usando uma row e um text (lado esquerdo):
  Atribua a normalized seleção deste text a uma seleção.
  Atribua a coordenada X desta globalized origem deste text à coordenada X do canto superior esquerdo desta caixa de seleção.
  Se o anchor número da linha desta seleção for o número da linha desta row, obtenha uma localização usando o anchor desta seleção e o text; atribua a coordenada X desta localização à coordenada X do canto superior esquerdo desta caixa de seleção.
  Limite a coordenada X do canto superior esquerdo desta caixa de seleção para a coordenada X do canto superior esquerdo deste text e a coordenada X do canto inferior direito deste text.

Etapas para que se obtenha uma caixa de seleção usando uma row e um text (lado direito):
  Atribua a normalized seleção deste text a uma seleção.
  Atribua a coordenada X do canto inferior direito deste text à coordenada X do canto inferior direito desta caixa de seleção.
  Se o número de linhas do cursor desta seleção for o número da linha desta row, obtenha uma localização usando o caret desta seleção e o text; atribua a coordenada X desta localização à coordenada X do canto inferior direito desta caixa de seleção.
  Limite a coordenada X do canto inferior direito desta caixa de seleção para a coordenada X do canto superior esquerdo deste text e a coordenada X do canto inferior direito deste text.

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, obtenha o size usando o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo for file-format, obtenha o size usando o endereço completo no sistema de arquivos (arquivo).

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos (pasta)[endereço]:
  Atribua 0 ao size.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Se a categoria deste item for "arquivo", adicione o size deste item para o size; repita.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Obtenha uma segunda size usando a segunda endereço completo no sistema de arquivos.
    Adicione a segunda size para o size.
  Repita. [o código acima]

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesExA" com 
    O first deste endereço completo 
    e 0 
    e O endereçamento desse WIN32FINDDATA.
  Atribua o nFileSizeLow deste WIN32FINDDATA ao size.

Etapas para que se obtenha um sockaddr usando um host string:
  Limpe o erro do fluxo de entrada/saída.
  \ prepare strings
  Isole o host string.
  Termine com o caractere NULL o host string.
  \ obtenha o function addresses
  Obtenha uns addrinfo routines.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  \ obtenha o sockaddr
  Atribua 2 [AF_INET] ao ai_family desse addrinfo.
  Atribua 1 [SOCK_STREAM] ao ai_sockettype deste addrinfo.
  Atribua 6 [IPPROTO_TCP] ao ai_protocol deste addrinfo.
  Call o getaddrinfo destas addrinfo routines com 
    O first endereço de memória do pedaço desta host string 
    e 0 e o endereçamento deste addrinfo
   e o endereçamento desse addrinfoptr 
     devolvendo um número resultante.
  Se o número resultante não for 0, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; volte.
  Se o addrinfoptr for inexistente, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; volte.
  Atribua o conteúdo deste ai_addr deste addrinfoptr ao sockaddr.
  Call o freeaddrinfo destas addrinfo routines com o addrinfoptr.

Etapas para que se obtenha uma localização usando uma position e um text:
  Limpe a localização.
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número da linha desta position e o text.
  Obtenha uma caixa usando a row e o text.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização.
  Atribua o first endereço de memória do pedaço desta string desta row ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto mais o número de coluna desta position menos 2 ao last endereço de memória do pedaço deste subtexto.
  Obtenha um largura usando o subtexto e o memory canvas e a font deste text.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais a largura à coordenada X desta localização.
  Obtenha um offset par de números usando o working string desta row e a caixa e a font deste text e o alinhamento deste text.
  Adicione o número X deste offset par de números para a coordenada X desta localização.

Etapas para que se obtenha um start largura e um subtexto usando uma row e uma localização e um text (for "get um número de coluna usando uma row..."):
  Limpe o start largura.
  Limpe o subtexto.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Lance o subtexto sobre o working string desta row.
  Obtenha um offset par de números usando o subtexto e a caixa e a font deste text e o alinhamento deste text (fast).
  Atribua a coordenada X desta globalized origem deste text mais o número X deste offset par de números ao start largura.
  Atribua o first endereço de memória do pedaço deste subtexto mais o text cutoff menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que ou igual ao last endereço de memória do pedaço desta string desta row, pare.
    Obtenha um largura usando o subtexto e o memory canvas.
    Atribua o start largura mais a largura a uma segunda largura.
    Se a coordenada X desta localização for menor do que ou igual ao segunda largura, pare.
    Adicione a largura para o start largura.
    Mova o subtexto usando o text cutoff.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto ao last endereço de memória do pedaço deste subtexto.

Etapas para que se obtenha uma string desde o stack:
  Limpe a string.
  Obtenha um stack entry desde o stack.
  Se o stack entry for inexistente, atribua "ERRO" à string; volte.
  Atribua a string desta stack entry para a string.
  Remove o stack entry desde o stack.
  Destrua o stack entry.

Etapas para que se obtenha uma string desde a área de transferência do Windows:
  Limpe a string.
  Call "user32.dll" "OpenClipboard" com 
    A janela principal do programa.
  Call "user32.dll" "GetClipboardData" com 
  1 [CF_TEXT] 
    devolvendo um número identificador.
  Se o número identificador for 0, Call "user32.dll" "CloseClipboard"; volte.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador 
    devolvendo um endereçamento de caractere.
  Converta o endereçamento de caractere para a string.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "user32.dll" "CloseClipboard".

Etapas para que se obtenha uma coisa desde umas coisas:
  Se  as coisas estiverem vazio, esvazie a coisa; volte.
  Se a coisa for inexistente, atribua o first destas coisas à coisa; volte.
  Atribua o next desta coisa à coisa.

Etapas para que se obtenha uma coisa desde umas coisas (backwards):
  Se  as coisas estiverem vazio, esvazie a coisa; volte.
  Se a coisa for inexistente, atribua o last destas coisas à coisa; volte.
  Atribua o previous desta coisa à coisa.

Etapas para que se obtenha um segmento inicial desde um reply:
  Remove algum tipo de leading noise desde o reply.
  Limpe o segmento inicial.
  Percorra. [o código abaixo]
    Se o reply estiver em branco, cancele.
    Obtenha um pedaço desde o reply.
    Se o pedaço for o caractere de espaço, cancele.
    Posponha o pedaço para o segmento inicial.
  Repita. [o código acima]

Etapas para que se obtenha um largura usando um pedaço e um canvas:
  Call "gdi32.dll" "GetTextExtentPoint32A" com 
    O canvas 
    e O endereçamento deste pedaço 
    e 1 
    e O endereçamento desse par de números.
  Atribua o número X deste par de números à largura.

Etapas para que se obtenha um largura usando um pedaço e uns font larguras:
  Atribua o pedaço a um número.
  Obtenha a largura usando o número e a font larguras.

Etapas para que se obtenha um largura usando um número e uns font larguras:
  \ indexes são 0 based
  Se a font larguras são nil, limpe a largura; volte.
  Atribua o data destes font larguras a um endereço numérico.
  Adicione o número times a magnitude deste número para o endereço numérico.
  Atribua o conteúdo deste endereço numérico ao largura.

Etapas para que se obtenha um largura usando uma string e um canvas:
  \ presume que a font já esteja selecionada no canvas
  Call "gdi32.dll" "GetTextExtentPoint32A" com 
    O canvas 
    e O first endereço de memória do pedaço desta string 
    e A quantidade de caracteres desta string 
    e O endereçamento desse par de números.
  Atribua o número X deste par de números ao largura.

Etapas para que se obtenha um largura usando uma string e um canvas e um font:
  Crie o número da fonte of o canvas usando a font.
  Obtenha a largura usando a string e o canvas.
  Destrua o número da fonte of o canvas.

Etapas para que se obtenha um largura usando uma string e um font:
  \ assumes memory canvas
  Obtenha a largura usando a string e o memory canvas e a font.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - center):
  Obtenha um largura usando a string e o memory canvas.
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Atribua a largura menos o abcA menos o abcC ao largura.
  Atribua a largura desta caixa menos a largura dividido por 2 menos o abcA à coordenada X.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - left):
  Obtenha um abcA usando a string e o memory canvas.
  Atribua - o abcA à coordenada X.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - right):
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Obtenha um largura usando a string e o memory canvas.
  Atribua a largura menos o abcA menos o abcC ao largura.
  Atribua a largura desta caixa menos a largura menos o abcA à coordenada X.

Um gigabyte é 1024 megabytes.

Etapas para que se globalize uma caixa usando um par de números:
  Mova a caixa usando o par de números.

Etapas para que se globalize uma localização usando um par de números:
  Mova a localização usando o par de números.

Etapas para que se go back para where we were:
  Restaure o context.

Um GpBitmap é um GpImage.

Um GpGraphic é um endereço de memória.

Um GpImage é um endereço de memória.



Um GpRect é um conjunto com
  Um número denominado x,
  Um número denominado y,
  Um número denominado largura,
  Um número denominado altura.

O gpToken é um gpToken.

Um gpToken é um número.



Uma malha é um par de números.

Etapas para que se garanta one row em um text:
  Se o text for inexistente, cancele.
  Se as rows deste text não estiverem vazio, cancele.
  Crie uma row usando o retorno de carro.
  Posponha a row para as rows deste text.
  Renumere as rows deste text.

Um guid é um UUID. \ identificador único global

O hand cursor é um cursor.

Etapas para que se mude alinhamento usando um text e um alinhamento:
  Se o text for inexistente, cancele.
  Relembre o text com "alinhamento".
  Alinhe o text usando o alinhamento.

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam:
  Separe o wParam a um word e uma segunda word.
  Atribua a segunda word a um número.
  Se o número for 0, execute algum tipo de WM_ACTIVATE com o wParam (deactivate); volte.
  Execute algum tipo de WM_ACTIVATE com o wParam (activate).

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam (activate):
  Call "user32.dll" "SetFocus" com 
    A janela principal do programa.
  Call "user32.dll" "ClipCursor" com 
  0.
  \ seterrormode(sem_failcriticalerrors) \ keeps certain disk erros desde appearing
  Crie um event.
  Atribua "activate" à categoria deste event. \pode ser traduzido
  Enfileire o event.
  Call "user32.dll" "PostMessageA" com 
    A janela principal do programa 
    e 0 [wm_null] 
    e 0 
    e 0.

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam (deactivate):
  Crie um event.
  Atribua "deactivate" à categoria deste event. \pode ser traduzido
  Enfileire o event.
  Call "user32.dll" "PostMessageA" com 
    A janela principal do programa 
    e 0 [wn_null] 
    e 0 
    e 0.

Etapas para que se execute algum tipo de WM_CHAR com um wParam e um lParam:
  \Se a tecla Alt was para baixo, cancele. \ removed por Spanish teclado AltGr e ctrl+alt characters
  \Se a tecla Ctrl was para baixo, cancele. \ removed por Spanish teclado AltGr e ctrl+alt characters
  Atribua o wParam a um pedaço.
  Se o pedaço não for imprimível, cancele.
  Crie um event.
  Atribua "pressionamento de tecla" à categoria deste event. \traduzido
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Atribua o pedaço ao pedaço deste event.
  Converta o lParam para a tecla deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_CREATE com um janela do programa:
  Atribua a janela do programa à janela principal do programa.

Etapas para que se execute algum tipo de WM_DESTROY:
  Call "user32.dll" "PostQuitMessage" com 
  0.

Etapas para que se execute algum tipo de WM_LBUTTONDBLCLK com um lParam:
  Crie um event.
  Atribua "clique duplo" à categoria deste event. \traduzido
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o lParam para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_LBUTTONDOWN com um lParam:
  Crie um event.
  Atribua "clique" à categoria deste event. \traduzido
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o lParam para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_PAINT com um janela do programa:
  Call "user32.dll" "BeginPaint" com 
    A janela do programa 
    e O endereçamento desse paintstruct.
  Call "user32.dll" "EndPaint" com 
    A janela do programa 
    e O endereçamento desta paintstruct.
  Crie um event.
  Atribua "atualização de tela" à categoria deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_RBUTTONDBLCLK com um lParam:
  Crie um event.
  Atribua "clique direito duplo" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o lParam para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_RBUTTONDOWN com um lParam:
  Crie um event.
  Atribua "clique direito" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o lParam para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_SETCURSOR:
  Atualize o cursor.

Etapas para que se execute algum tipo de WM_SYSKEYDOWN com um wParam e um lParam;
Etapas para que se execute algum tipo de WM_KEYDOWN com um wParam e um lParam:
  Atribua o wParam a um tecla.
  Se a tecla com o lParam é algum comando de repetiçãoed escape ou modifier tecla, cancele.
  Se a tecla for algum tipo de WM_CHAR tecla, cancele.
  Crie um event.
  Atribua "pressionamento de tecla" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Atribua a tecla à tecla deste event.
  Enfileire o event.

Etapas para que se execute capitalize usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "capitalize".
  Capitalize algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se efetue cópias usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Extraia uma string desde o text (pedaços selecionados).
  Atribua a string sobre o área de transferência do Windows.

Etapas para que se execute cut usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text.
  Extraia uma string desde o text (pedaços selecionados).
  Atribua a string sobre o área de transferência do Windows.
  Remove algum tipo de pedaços selecionados no text.
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um console:
  Se o console for inexistente, cancele. \não falta o clique normal aqui?
  Se a categoria deste event for "pressionamento de tecla", execute o event usando o console (pressionamento de tecla); volte.
  Se a categoria deste event for "atualização de tela", execute o event usando o console (atualização de tela); volte.
  Se a categoria deste event for "clique direito", execute o event usando o console (clique direito); volte.
  Se a categoria deste event for "mostrar seta", execute o event usando o console (mostrar seta do mouse); volte.

Etapas para que se execute um event usando um console (tecla backspace):
  Se o reply deste console estiver em branco, cancele.
  Se o event foi alterado, cancele.
  Execute o event usando o text deste console (tecla backspace).
  Remove o last pedaço desde o reply deste console.
  Mostre o console.

Etapas para que se execute um event usando um console (seta pra baixo):
  Role o text deste console para baixo one linha reta.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla End):
  Role o text deste console para o base.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Enter):
  Execute o event usando o text deste console (tecla Enter).
  Relinquish control.

Etapas para que se execute um event usando um console (tecla Home):
  Role o text deste console para o topo.
  Mostre o console.

Etapas para que se execute um event usando um console (pressionamento de tecla):
  Se a tecla deste event for a tecla backspace, execute o event usando o console (tecla backspace); volte.
  Se a tecla deste event for a seta pra baixo, execute o event usando o console (seta pra baixo); volte.
  Se a tecla deste event for a tecla End, execute o event usando o console (tecla End); volte.
  Se a tecla deste event for a tecla Enter, execute o event usando o console (tecla Enter); volte.
  Se a tecla deste event for a tecla Home, execute o event usando o console (tecla Home); volte.
  Se a tecla deste event for a tecla PgDn, execute o event usando o console (tecla Page Down); volte.
  Se a tecla deste event for a tecla PgUp, execute o event usando o console (tecla Page Up); volte.
  Se a tecla deste event for a seta pra cima, execute o event usando o console (seta pra cima); volte.
  Se o pedaço deste event não for imprimível, cancele.
  Posponha o pedaço deste event para o reply deste console.
  Execute o event usando o text deste console (caracteres gráficos).
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Page Down):
  Role o text deste console para baixo one página.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Page Up):
  Role o text deste console para cima one página.
  Mostre o console.

Etapas para que se execute um event usando um console (atualização de tela):
  Mostre o console.

Etapas para que se execute um event usando um console (clique direito):
  Mostre o hand cursor.
  Role o console usando o event.
  Atualize o cursor.

Etapas para que se execute um event usando um console (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas para que se execute um event usando um console (seta pra cima):
  Role o text deste console para cima one linha reta.
  Mostre o console.

Etapas para que se execute um event usando um terminal:
  Se o terminal for inexistente, cancele.
  Se a categoria deste event for "pressionamento de tecla", execute o event usando o terminal (pressionamento de tecla); volte.
  Se a categoria deste event for "atualização de tela", execute o event usando o terminal (atualização de tela); volte.
  Se a categoria deste event for "mostrar seta", execute o event usando o terminal (mostrar seta do mouse); volte.
  Se a categoria deste event for "clique", relinquish control. \ *** added por invisível turtle book questionable

Etapas para que se execute um event usando um terminal (tecla backspace):
  Se o reply deste terminal estiver em branco, cancele.
  Se o event foi alterado, cancele.
  Remove o last pedaço desde o reply deste terminal.
  Remove o last pedaço desde a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (tecla Enter):
  Relinquish control. \Abdique

Etapas para que se execute um event usando um terminal (pressionamento de tecla):
  Se a tecla deste event for a tecla backspace, execute o event usando o terminal (tecla backspace); volte.
  Se a tecla deste event for a tecla Enter, execute o event usando o terminal (tecla Enter); volte.
  Se o pedaço deste event não for imprimível, cancele.
  Posponha o pedaço deste event para o reply deste terminal.
  Posponha o pedaço deste event para a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (atualização de tela):
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas para que se execute um event usando um text (tecla backspace):
  Se o text for inexistente, cancele.
  Se não existir something para backspace no text, cancele.
  Relembre o text com "backspace".
  Se o event foi alterado, remova pedaços de o text (backspace com jump).
  Se o event não foi alterado, remova pedaços de o text (backspace).
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Delete):
  Se o text for inexistente, cancele.
  Se não existir something para remove no text, cancele.
  Relembre o text com "delete".
  Se o event foi alterado, remova pedaços de o text (forward delete com jump).
  Se o event não foi alterado, remova pedaços de o text (forward delete).
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (seta pra baixo):
  Se o text for inexistente, cancele.
  Se o caret of o text é sobre o last linha reta, acione um detector.
  Se o detector estiver ativo, mova o caret para o last pedaço of o text.
  Se o detector não estiver ativo, mova o caret para baixo no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla End):
  Se o text for inexistente, cancele.
  Se o event foi alterado, mova o caret para o last pedaço of o text.
  Se o event não foi alterado, mova o caret para o last pedaço of o current row of o text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Enter):
  Se o text for inexistente, cancele.
  Relembre o text com "insert return".
  Remove algum tipo de pedaços selecionados no text.
  Insira o retorno de carro ao text.
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Esc):
  Se o text for inexistente, cancele.
  Desvencilhe-se de o text.

Etapas para que se execute um event usando um text (tecla Home):
  Se o text for inexistente, cancele.
  Se o event foi alterado, mova o caret para o first pedaço of o text.
  Se o event não foi alterado, mova o caret para o first pedaço of o current row of o text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (clique duplo):
  Se o text for inexistente, cancele.
  Desvencilhe-se de o text.
  Mova o caret right para algum tipo de non-alfanumérico pedaço no text.
  Mova o anchor left para algum tipo de non-alfanumérico pedaço no text.

Etapas para que se execute um event usando um text (seta esquerda):
  Se o text for inexistente, cancele.
  Se o event foi alterado, jump o caret left no text.
  Se o event não foi alterado, mova o caret left no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Page Down):
  Se o text for inexistente, cancele.
  Role o text para baixo one página.
  Mova o caret para baixo one página no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.

Etapas para que se execute um event usando um text (tecla Page Up):
  Se o text for inexistente, cancele.
  Role o text para cima one página.
  Mova o caret para cima one página no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.

Etapas para que se execute um event usando um text (caracteres gráficos):
  Relembre o text com "insert".
  Remove algum tipo de pedaços selecionados no text.
  Insira o pedaço deste event ao text.
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (seta direita):
  Se o text for inexistente, cancele.
  Se o event foi alterado, jump o caret right no text.
  Se o event não foi alterado, mova o caret right no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Tab):
  Se o text for inexistente, cancele.
  Relembre o text com "insert".
  Remove algum tipo de pedaços selecionados no text.
  Insira o caractere de espaço ao text.
  Divida o caret número de coluna deste text por 2 usando um quociente e um resto.
  Se o resto for 0, insira o caractere de espaço ao text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (seta pra cima):
  Se o text for inexistente, cancele.
  Mova o caret para cima no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute events usando um console:
  Se o console for inexistente, cancele.
  Percorra. [o código abaixo]
    Desenfileire um event.
    Se o event for inexistente, cancele.
    Execute o event usando o console.
  Repita. [o código acima]

Etapas para que se execute events usando um terminal:
  Se o terminal for inexistente, cancele.
  Percorra. [o código abaixo]
    Desenfileire um event.
    Se o event for inexistente, cancele.
    Execute o event usando o terminal.
  Repita. [o código acima]

Etapas para que se mude tamanho usando um text e uma caixa e uma altura da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "altura da fonte".
  Mude o text usando a caixa.
  Mude o text usando a altura da fonte.

Etapas para que se mude tamanho usando um text e uma altura da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "altura da fonte".
  Mude o text usando a altura da fonte.

Etapas para que se mude nome da fonte usando um text e uma nome da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "nome da fonte".
  Mude o text usando o nome da fonte.

Etapas para que se execute indent usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "dent".
  Indent algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Um número identificador é um número.

Etapas para que se execute lowercase usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "case".
  Lowercase algum tipo de pedaços selecionados no text.
  Wrap o text.

Etapas para que se execute outdent usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "dent".
  Outdent algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute paste usando um text:
  Se o text for inexistente, cancele.
  Se não existir text sobre o área de transferência do Windows, cancele.
  Relembre o text.
  Remove algum tipo de pedaços selecionados no text.
  Obtenha uma string desde o área de transferência do Windows.
  Insira a string ao text.
  Wrap o text.
  Role o text para o caret.

Etapas para que se efetue alteração de cor usando um text e uma cor:
  Se o text for inexistente, cancele.
  Relembre o text com "pincel".
  Atribua a cor ao pincel deste text.

Etapas para que se execute redo usando um text:
  Se o text for inexistente, cancele.
  Se o last destes redos deste text for inexistente, cancele.
  Copie o text a um segundo text.
  Posponha o segundo text para os undos deste text.
  Atribua o last destes redos deste text a um terceiro text.
  Remove o terceiro text desde os redos deste text.
  Copie o guts of o terceiro text ao text.
  Destrua o terceiro text.
  Ligue o detector de alteração deste text.

Etapas para que se execute reverse usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "reverse".
  Reverse algum tipo de rows selecionadas of o text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute select all usando um text:
  Se o text for inexistente, cancele.
  Selecione cada pedaço no text.

Etapas para que se execute classifique algum tipo de rows selecionadas usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "classifique rows selecionadas".
  Classifique algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute undo usando um text:
  Se o text for inexistente, cancele.
  Se o last destes undos deste text for inexistente, cancele.
  Copie o text a um segundo text.
  Posponha o segundo text para os redos deste text.
  Atribua o last destes undos deste text a um terceiro text.
  Remove o terceiro text desde os undos deste text.
  Copie o guts of o terceiro text ao text.
  Destrua o terceiro text.
  Ligue o detector de alteração deste text.

Etapas para que se execute uppercase usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "case".
  Uppercase algum tipo de pedaços selecionados no text.
  Wrap o text.

Um hbitmap é um número identificador.

Um HBRUSH é um número identificador.

Um hdc é um número identificador.

Um orientação é uns points.

O contagem do heap é um número.

O endereço heap é um endereço de memória.

Um altura é uns twips.

Um texto hexadecimal é uma string.

Um número da fonte é um número identificador.

Um hicon é um número identificador.

Etapas para que se oculte o cursor:
  Call "user32.dll" "ShowCursor" com 
  0 
    devolvendo um número.
  Se o número for menor do que 0, cancele.
  Repita. [o código acima]

Um horizontal linha reta é um linha reta.

Um hour é 60 minutes.

Um hpen é um número identificador.

Um hRgn é um número identificador.

Um matiz é uns precise degrees [0 para 3599].

  

O i-beam cursor é um cursor.

Um iid é um UUID. \ Um interface identifier é um Identificador único universal

Etapas para que se imagine uma caixa uns twips por uns segunda twips;
Etapas para que se faça uma caixa uns twips por uns segunda twips:
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa.
  Atribua os twips à coordenada X do canto inferior direito desta caixa.
  Atribua a segunda twips à coordenada Y do canto inferior direito desta caixa.

Etapas para que se imagine uma caixa uns twips high por uns segunda twips wide;
Etapas para que se faça uma caixa uns twips high por uns segunda twips wide:
  Atribua 0 e 0 e a segunda twips e os twips ao caixa.

Etapas para que se imagine uma caixa uns twips smaller do que uma segunda caixa;
Etapas para que se faça uma caixa uns twips smaller do que uma segunda caixa:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips dividido por 2.

Etapas para que se imagine uma caixa uns twips smaller do que uma segunda caixa sobre cada side:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips.

Etapas para que se imagine uma caixa uns twips wide por uns segunda twips high;
Etapas para que se faça uma caixa uns twips wide por uns segunda twips high:
  Atribua 0 e 0 e os twips e a segunda twips ao caixa.

Etapas para que se imagine uma caixa com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito;
Etapas para que se faça uma caixa com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito ao caixa.

Etapas para que se imagine uma caixa com uma localização e uma segunda localização;
Etapas para que se faça uma caixa com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao caixa.

Etapas para que se imagine uma cor desde um matiz e um saturação e um luminosidade;
Etapas para que se faça uma cor desde um matiz e um saturação e um luminosidade:
  Atribua o matiz e o saturação e o luminosidade à cor.

Etapas para que se imagine um dot about uns twips wide;
Etapas para que se faça um dot about uns twips wide;
Etapas para que se faça um dot uns twips wide:
  Faça o dot os twips pelo twips.

Etapas para que se imagine um dot entre uns twips e uns segunda twips wide;
Etapas para que se faça um dot entre uns twips e uns segunda twips wide:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Faça o dot o terceiro twips wide.

Etapas para que se imagine um elipse usando uma caixa;
Etapas para que se faça um elipse usando uma caixa:
  Atribua a caixa à caixa desta elipse.

Etapas para que se imagine um elipse uns twips por uns segunda twips;
Etapas para que se faça um elipse uns twips por uns segunda twips:
  Atribua 0 à coordenada X do canto superior esquerdo desta elipse.
  Atribua 0 à coordenada Y do canto superior esquerdo desta elipse.
  Atribua os twips à coordenada X do canto inferior direito desta elipse.
  Atribua a segunda twips à coordenada Y do canto inferior direito desta elipse.

Etapas para que se imagine um elipse com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito;
Etapas para que se faça um elipse com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito ao elipse.

Etapas para que se imagine um elipse com uma localização e uma segunda localização;
Etapas para que se faça um elipse com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao elipse.

Etapas para que se imagine uma figura using uma string e uma localização;
Etapas para que se faça uma figura using uma string e uma localização;
Etapas para que se crie uma figura using uma string e um center localização:
  Crie a figura.
  Posponha a figura para as figuras.
  Isole a string.
  Lowercase a string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
  Skip algum tipo de leading noise no subtexto.
  Se a quantidade de caracteres deste subtexto for menor do que 2, cancele.
  Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um pedaço.
  Atribua o pedaço menos o 'a' minúsculo ao y desse localização.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto ao pedaço.
  Atribua o pedaço menos o 'a' minúsculo ao x desta localização.
  Multiplique a localização por 24 px.
  Adicione o x deste center localização menos 299 pixels para a coordenada X desta localização.
  Adicione o y deste center localização menos 299 pixels para a coordenada Y desta localização.
  Posponha a localização para a figura.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se imagine um horizontal linha reta uma fração of o caminho para cima desde o base of uma caixa;
Etapas para que se faça um horizontal linha reta uma fração of o caminho para cima desde o base of uma caixa:
  Imagine o horizontal linha reta across a caixa a fração of o caminho para cima desde o base.

Etapas para que se imagine um linha reta across o base of uma caixa;
Etapas para que se faça um linha reta across o base of uma caixa;
Etapas para que se imagine um linha reta along o base of uma caixa;
Etapas para que se faça um linha reta along o base of uma caixa:
  Atribua a coordenada Y do canto inferior direito desta caixa linha reta ao linha reta.

Etapas para que se imagine um linha reta across uma caixa uma fração of o caminho para cima desde o base;
Etapas para que se faça um linha reta across uma caixa uma fração of o caminho para cima desde o base:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa times a fração a uns twips.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização inicial desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização final desta linha reta.

Etapas para que se imagine um linha reta across o topo of uma caixa;
Etapas para que se faça um linha reta across o topo of uma caixa;
Etapas para que se imagine um linha reta along o topo of uma caixa;
Etapas para que se faça um linha reta along o topo of uma caixa:
  Atribua a coordenada Y do canto superior esquerdo desta caixa linha reta ao linha reta.

Etapas para que se imagine um linha reta no middle of uma caixa;
Etapas para que se faça um linha reta no middle of uma caixa;
Etapas para que se imagine um linha reta across o middle of uma caixa;
Etapas para que se faça um linha reta across o middle of uma caixa;
Etapas para que se imagine um linha reta no center of uma caixa;
Etapas para que se faça um linha reta no center of uma caixa;
Etapas para que se imagine um linha reta across o center of uma caixa;
Etapas para que se faça um linha reta across o center of uma caixa:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua o y deste center desta caixa ao y desta localização inicial desta linha reta.
  Atribua o y deste center desta caixa ao y desta localização final desta linha reta.

Etapas para que se imagine um linha reta uns twips para cima desde o base of uma caixa;
Etapas para que se faça um linha reta uns twips para cima desde o base of uma caixa:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização inicial desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização final desta linha reta.

Etapas para que se imagine um linha reta com uma localização e uma segunda localização;
Etapas para que se faça um linha reta com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao linha reta.

Etapas para que se imagine um linha reta com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y;
Etapas para que se faça um linha reta com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y:
  Atribua a coordenada X e a coordenada Y e a segunda coordenada X e a segunda coordenada Y ao linha reta.

Etapas para que se imagine uma caixa arredondada desde uma caixa e um raio;
Etapas para que se faça uma caixa arredondada desde uma caixa e um raio:
  Atribua a caixa e o raio ao caixa arredondada.

Etapas para que se imagine uma caixa arredondada uns twips por uns segunda twips;
Etapas para que se faça uma caixa arredondada uns twips por uns segunda twips com um raio:
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa arredondada.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa arredondada.
  Atribua os twips à coordenada X do canto inferior direito desta caixa arredondada.
  Atribua a segunda twips à coordenada Y do canto inferior direito desta caixa arredondada.
  Atribua o raio ao raio desta caixa arredondada.

Etapas para que se imagine uma caixa arredondada com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito e um raio;
Etapas para que se faça uma caixa arredondada com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito e um raio:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito e o raio ao caixa arredondada.

Etapas para que se imagine uma caixa arredondada com uma localização e uma segunda localização e um raio;
Etapas para que se faça uma caixa arredondada com uma localização e uma segunda localização e um raio:
  Atribua a localização e a segunda localização e o raio ao caixa arredondada.

Etapas para que se imagine uma localização com uma coordenada X e uma coordenada Y;
Etapas para que se faça uma localização com uma coordenada X e uma coordenada Y:
  Atribua a coordenada X e a coordenada Y à localização.

Etapas para que se indent algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
  Se a row for inexistente, cancele.
  Se a row of o text não estiver selecionado, repita.
  Se a row estiver em branco, repita.
  Anteponha o caractere de espaço para a string deste row.
  Anteponha o caractere de espaço para a string deste row.
  Repita. [o código acima]

Um indent é uma contagem.

Um catálogo é uma coisa com
Um contagem de buckets,
Um first bucket e um last bucket.

Etapas para que se catalogue um endereço de memória usando uma string e um catálogo:
    \ if o catálogo for inexistente, cancele. \ para fazer compilador faster
  Se a quantidade de caracteres desta string for 0, cancele.
  Obtenha um bucket usando a string e o catálogo.
  Crie um refer.
  Posponha o refer para os refers deste bucket.
  Atribua a string à string deste refer.
  Atribua o endereço de memória ao endereço de memória deste refer.

Etapas para que se catalogue uma string em um catálogo:
  \ if o catálogo for inexistente, cancele. \ para fazer compilador faster
  Catalogue nil usando a string e o catálogo.

Etapas para que se initalize o terminal:
  Crie o terminal na caixa desta tela.

Etapas para que se initialize before run:
  Call "user32.dll" "DisableProcessWindowsGhosting".
  Call "kernel32.dll" "GetProcessHeap" 
    devolvendo o endereço heap.
  Call "kernel32.dll" "LoadLibraryA" com 
  "kernel32.dll"'s first endereço de memória do pedaço 
    devolvendo um número identificador.
  Se o número identificador não for 0, Call "kernel32.dll" "GetProcAddress" com 
    O número identificador 
    e "HeapSetInformation"'s first endereço de memória do pedaço 
    devolvendo um endereço de memória.
  Se o endereço de memória não for inexistente, Call o endereço de memória com o endereço heap e 0 e 2's endereçamento e 4.

Etapas para que se inicialize o canvases:
  Inicialize o tela canvas.
  Inicialize o memory canvas.
  Atribua o memory canvas ao quadro atual.

Etapas para que se inicialize o cgi:
  Call "kernel32.dll" "AllocConsole".
  Call "kernel32.dll" "GetStdHandle" com 
  -10 [STD_INPUT_HANDLE] 
    devolvendo o número identificador do fluxo de entrada padrão.
  Call "kernel32.dll" "GetStdHandle" com 
  -11 [STD_OUTPUT_HANDLE] 
    devolvendo o número identificador do fluxo de saída padrão.

\Etapas para que se inicialize o Component Object Model:
\Mande os códigos 0 e 2 para a função "CoInitializeEx" da biblioteca "ole32.dll" [COINIT_APARTMENTTHREADED].

Etapas para que se inicialize o Component Object Model:
  Call "ole32.dll" "CoInitializeEx" com 
  0 
    e 2 [COINIT_APARTMENTTHREADED].

Etapas para que se inicialize um context:
  Aloque memória para o context.
  Atribua o center desta tela à localização deste context.
  Atribua 0 à orientação deste context.
  Atribua a cor verde à cor deste context.
  Atribua o tamanho de letra pequena à tamanho da letra deste context.
  \Atribua 1/60 second ao delay. ***
  Seed o número aleatório generator.

Etapas para que se inicialize os cursors:
  Inicialize os cursors (seta do mouse).
  Inicialize os cursors (hand cursor).
  Inicialize os cursors (i-beam cursor).
  \Atribua a seta do mouse ao cursor flecha.
  \Atribua o hand cursor ao cursor mano.
  \Atribua o i-beam cursor ao cursor rayo-i.
  Oculte o cursor.

Etapas para que se inicialize os cursors (seta do mouse):
  Posponha $00000000000000004000000060000000 para uma máscara de disjunção exclusiva.
  Posponha $70000000780000007C0000007E000000 para a máscara de disjunção exclusiva.
  Posponha $7F0000007F8000007C0000006C000000 para a máscara de disjunção exclusiva.
  Posponha $46000000060000000300000003000000 para a máscara de disjunção exclusiva.
  Posponha $01800000018000000000000000000000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 48.
  Posponha $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF para uma máscara de conjunção lógica.
  Posponha $07FFFFFF03FFFFFF01FFFFFF00FFFFFF para a máscara de conjunção lógica.
  Posponha $007FFFFF003FFFFF001FFFFF01FFFFFF para a máscara de conjunção lógica.
  Posponha $10FFFFFF30FFFFFF787FFFFFF87FFFFF para a máscara de conjunção lógica.
  Posponha $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 48.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 0 
    e 0 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo a seta do mouse.

Etapas para que se inicialize o cursors (hand cursor):
  Posponha $000000000180000019B0000019B00000 para uma máscara de disjunção exclusiva.
  Posponha $0DB200000DB6000007F6000067FE0000 para a máscara de disjunção exclusiva.
  Posponha $7FFC00003FFC00001FFC00001FF80000 para a máscara de disjunção exclusiva.
  Posponha $0FF8000007F0000003F0000003F00000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 64.
  Posponha $FE7FFFFFE40FFFFFC007FFFFC005FFFF para uma máscara de conjunção lógica.
  Posponha $E000FFFFE000FFFF9000FFFF0000FFFF para a máscara de conjunção lógica.
  Posponha $0001FFFF8001FFFFC001FFFFC003FFFF para a máscara de conjunção lógica.
  Posponha $E003FFFFF007FFFFF807FFFFF807FFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 64.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 2 
    e 1 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo o hand cursor.

Etapas para que se inicialize o cursors (i-beam cursor):
  Posponha $EE000000100000001000000010000000 para um máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $100000001000000010000000EE000000 para o máscara de disjunção exclusiva.
  Posponha $00 para o máscara de disjunção exclusiva usando 64.
  Posponha $FF para um máscara de conjunção lógica usando 128.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 3 
    e 7 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo o i-beam cursor.

Etapas para que se inicialize as fonts:
  Call "gdi32.dll" "GetStockObject" com 
  11 [ANSI_FIXED_FONT 0x0000000B] 
    devolvendo o null número da fonte.
  \Call "gdi32.dll" "AddFontMemResourceEx" com o first desta osmosian font source e a quantidade de caracteres desta osmosian font source e 0 e o endereçamento desse número devolvendo o osmosian font resource.
  \Call "gdi32.dll" "AddFontMemResourceEx" com o first desta fonte Segoe UI e a quantidade de caracteres desta fonte Segoe UI e 0 e o endereçamento desse número devolvendo o Segoe UI resource.
  Call "gdi32.dll" "AddFontMemResourceEx" com 
    O first desta fonte Tahoma 
    e A quantidade de caracteres desta fonte Tahoma 
    e 0 
    e O endereçamento desse número 
    devolvendo o recurso de fonte Tahoma.
  \Atribua "Segoe UI" e 1/6 polegada à fonte padrão.
  \Atribua "osmosian" e 24 pixels à fonte padrão.
  Atribua "Tahoma" e 20 pixels à fonte padrão.
  \ stroked fonts below
  Atribua 12 pixels ao tamanho de letra pequena.
  Atribua 24 pixels ao tamanho de letra médio.
  Atribua 48 pixels ao tamanho de letra grande.

Etapas para que se inicialize gdi+:
  Atribua 1 ao GdiplusVersion desse GdiplusStartupInput.
  Call "gdiplus.dll" "GdiplusStartup" com 
    O endereçamento deste gpToken 
    e O endereçamento deste GdiplusStartupInput 
    e 0.
    \Windows GDI+ é uma API baseada em classe para programadores C/C++. 
    \Ela permite que os aplicativos usem elementos gráficos e texto formatado na exibição de vídeo e na impressora. 
    \Aplicativos baseados na API do Microsoft Win32 não acessam diretamente o hardware gráfico. 
    \Em vez disso, GDI+ interage com drivers de dispositivo em nome de aplicativos. 
    \GDI+ também é suportado pelo Microsoft Win64.

Etapas para que se inicialize o memory canvas:
  Call "gdi32.dll" "CreateCompatibleDC" com 
    O tela canvas 
    devolvendo o memory canvas.
  Call "gdi32.dll" "GetCurrentObject" com 
    O memory canvas 
    e 7 [OBJ_BITMAP] 
    devolvendo o saved memory hbitmap.
  Call "gdi32.dll" "CreateCompatibleBitmap" com 
    O tela canvas 
    e A pixel largura desta tela 
    e A pixel altura desta tela devolvendo um hbitmap.
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O hbitmap.
  Normalize o memory canvas.

Etapas para que se inicialize o module:
  \ temp endereço completo
  Atribua 512 a uma quantidade de caracteres.
  Reassign o first deste temp endereço completo usando a quantidade de caracteres.
  Call "kernel32.dll" "GetTempPathA" com 
    A quantidade de caracteres 
    e O first deste temp endereço completo 
    devolvendo a quantidade de caracteres.
  Atribua o first deste temp endereço completo mais a quantidade de caracteres menos 1 ao last deste temp endereço completo.
  Termine com o caractere NULL o temp endereço completo.
  \ module handle
  Call "kernel32.dll" "GetModuleHandleA" com 
  0 
    devolvendo o número identificador deste module.
  \ module nome
  Atribua 512 à quantidade de caracteres.
  Reassign o first deste endereço completo deste module usando a quantidade de caracteres.
  Call "kernel32.dll" "GetModuleFileNameA" com 
    O número identificador deste module 
    e O first deste endereço completo deste module 
    e A quantidade de caracteres 
    devolvendo a quantidade de caracteres.
  Atribua o first deste endereço completo deste module mais a quantidade de caracteres menos 1 ao last deste endereço completo deste module.
  Se o endereço completo deste module começa com "\\?\", remove leading pedaços desde o endereço completo deste module usando 4.
  Lowercase o endereço completo deste module.
  Termine com o caractere NULL o endereço completo deste module. \ segunda endereço completo pieces deste module
  Extraia o nome deste module desde o endereço completo deste module.
  Termine com o caractere NULL o nome deste module.
  Extraia o endereço da pasta deste module desde o endereço completo deste module.
  Termine com o caractere NULL o endereço da pasta deste module.
  Extraia o root endereço da pasta deste module desde o endereço da pasta deste module.
  Termine com o caractere NULL o root endereço da pasta deste module.

Etapas para que se inicialize o mouse:
  Atribua 1 ao botão esquerdo deste mouse.
  Atribua 2 ao botão direito deste mouse.
  Call "user32.dll" "GetSystemMetrics" com 
  23 [SM_SWAPBUTTON] 
    devolvendo um número.
  Se o número for 0, cancele.
  Permute o botão esquerdo deste mouse com o botão direito deste mouse.

Etapas para que se inicialize a área de impressão:
  Atribua a magnitude [quantidade de bytes] desse printdlgex ao lstructsize deste printdlgex.
  Atribua a janela principal do programa ao hwndowner deste printdlgex.
  Atribua 1288 [PD_RETURNDC + PD_RETURNDEFAULT + PD_NOPAGENUMS] ao flags deste printdlgex.
  Atribua -1 [START_PAGE_GENERAL] ao nstartpage deste printdlgex.
  Call "comdlg32.dll" "PrintDlgExA" com 
    O endereçamento deste printdlgex.
  Call "kernel32.dll" "GlobalFree" com 
    O hdevnames deste printdlgex.
  Atribua o hdevmode deste printdlgex ao número identificador do modo de dispositivo da impressora.
  Atribua o hdc deste printdlgex ao área de impressão.

Etapas para que se inicialize o tela:
  Call "user32.dll" "GetSystemMetrics" com 
  0 [sm_cxscreen] 
    devolvendo a pixel largura desta tela.
  Call "user32.dll" "GetSystemMetrics" com 
  1 [sm_cyscreen] 
    devolvendo a pixel altura desta tela.
  Atribua 96 ao ppi.
  Atribua o tpi dividido pelo ppi ao quantidade de twips/pixel .
  Atribua a pixel largura desta tela times a quantidade de twips/pixel a um largura.
  Atribua a pixel altura desta tela times a quantidade de twips/pixel a uma altura.
  Atribua 0 e 0 e a largura e a altura à caixa desta tela.
  Subtraia a quantidade de twips/pixel desde o canto inferior direito desta tela.

Etapas para que se inicialize o tela canvas:
  Call "user32.dll" "GetDC" com 
    A janela principal do programa 
    devolvendo o tela canvas.
  Normalize o tela canvas.

Etapas para que se inicialize um talker:
  Converta "{96749377-3391-11D2-9EE3-00C04F797396}" [CLSID_SpVoice] para um clsid.
  Converta "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [IID_ISpVoice] para um iid.
  Call "ole32.dll" "CoCreateInstance" com 
    O endereçamento deste clsid 
    e 0 
    e 7 [CLSCTX_ALL] 
    e O endereçamento deste iid 
    e O endereçamento deste talker.

Etapas para que se inicialize a janela do programa: \\ para inicializar a janela
  Atribua a magnitude [tamanho em bytes] dessa janela do programa class [estrutura] ao cbSize deste janela do programa class.
  Atribua 40 [CS_OWNDC + CS_DBLCLKS] ao style deste janela do programa class.
    \o valor cs_owndc Aloca um contexto de dispositivo exclusivo para cada janela da classe.
    \ o valor cs_dblclks permite que o windows informe ao programa que aquele é um clique duplo (ao invés de dois cliques)
  Point o lpfnWndProc deste janela do programa class para rotina handle algum tipo de message com um janela do programa um message número um wParam e um lParam.
    \ Isso define o procedimento da classe dessa janela como sendo WndProc
    \LPARAM é um typedef para um LONG_PTR que é um número inteiro (32 bits com sinal) em win32 e __int64 (64 bits com sinal) em x86_64.
    \WPARAM é um typedef para um UINT_PTR que é um número sem sinal (32 bits sem sinal) em win32 e __int64 sem sinal (64 bits sem sinal) em x86_64.
  Atribua o número identificador deste module ao hInstance desta janela do programa class.
  Atribua o first deste nome deste module ao lpszClassName desta janela do programa class.
  Call "user32.dll" "RegisterClassExA" \ Antes de criar uma janela, você deve registrar uma classe pra essa janela chamando a função RegisterClass.
  com o endereçamento deste janela do programa class. \Esta função requer um único parâmetro, que é um ponteiro para uma estrutura do tipo WNDCLASS.
  Call "user32.dll" "CreateWindowExA" com 
  0  \ o estilo opcional da janela, como transparências por exemplo. veja mais detalhes em  https://docs.microsoft.com/en-us/windows/desktop/winmsg/extended-janela do programa-styles
    e O first deste nome deste module  \\ O nome da classe da janela
    e O first deste nome deste module  \\ O texto da janela
    e 2147483648 [13565952  WS_OVERLAPPEDWINDOW 0x00CF0000]   [-2147483648 = WS_POPUP 0x80000000] \\  aqui define o tipo da janela. Use valores em decimal;  
    \para isso Converta os valores hexadecimais da lista  https://www.autoitscript.com/autoit3/docs/appendix/GUIStyles.htm para decimal;
    \outra opção é usar o site https://www.magnumdb.com/
    \ O valor na documentação do windows está em hexadecimal (ou em string), mas esse compilador usa números inteiros (longint). 
    \ Para colocar a barra padrão, use o valor 13565952
    e 0  \\ posição horizontal inicial da janela
    e 0  \\  posição vertical inicial da janela
    e A pixel largura desta tela  \\ A largura da janela em pixels;
    e A pixel altura desta tela  \\ A altura da janela em pixels
    e 0  \ opcional. Informa o número identificador do controle pai da janela (se existir) ou da janela em si
    e 0 \ a mesma coisa, só que identifica o número do menu da janela.
    e O número identificador deste module  \\ descrição auto explicável
    e 0. \ aqui é um ponteiro que passa a informação pra janela. Usamos um valor nulo pq não precisamos dele.
  Call "user32.dll" "ShowWindow" com 
    A janela principal do programa 
    e 1 [SW_SHOWNORMAL].

Etapas para que se inicialize winsock:
  Call "ws2_32.dll" "WSAStartup" com 
  2 
    e O endereçamento desse wsadata.

Um input é um event.

Etapas para que se insira um pedaço Para um text:
  Se o text for inexistente, cancele.
  Atribua o pedaço a uma string.
  Insira a string ao text.

Etapas para que se insira uma localização Para um polígono after um vértice:
  Se o polígono for inexistente, cancele.
  Crie um segundo vértice usando a localização.
  Insira o segundo vértice aos vértices deste polígono after o vértice.

Etapas para que se insira uma string Para uma segunda string antes de um byte#:
  Se a quantidade de caracteres desta string for 0, cancele.
  Isole o byte#.
  Limite o byte# para 1 e a quantidade de caracteres desta segunda string mais 1.
  Lance um subtexto sobre a segunda string. \ left side
  Atribua o first endereço de memória do pedaço deste subtexto mais o byte# menos 2 ao last endereço de memória do pedaço deste subtexto.
  Lance um segundo subtexto sobre a segunda string. \ right side
  Atribua o first endereço de memória do pedaço deste segundo subtexto mais o byte# menos 1 ao first endereço de memória do pedaço deste segundo subtexto.
  Atribua a quantidade de caracteres desta segunda string mais a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Reassign um endereço de memória usando a quantidade de caracteres agrupados.
  Atribua o endereço de memória ao first endereço de memória do pedaço desse terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço deste subtexto para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres deste subtexto.
  Adicione a quantidade de caracteres deste subtexto para o first endereço de memória do pedaço deste terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o first endereço de memória do pedaço deste terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço deste segundo subtexto para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres deste segundo subtexto.
  Unassign o first endereço de memória do pedaço desta segunda string. \ dont use atribua uma string a uma string para prevent extra allocating e copying
  Atribua o endereço de memória ao first endereço de memória do pedaço desta segunda string.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres agrupados menos 1 ao last endereço de memória do pedaço desta segunda string.

Etapas para que se insira uma string Para um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row menos o caret número de coluna deste text a um número.
  Atribua a string deste row a uma segunda string.
  Insira a string ao segunda string antes de o caret número de coluna deste text.
  Converta a segunda string para uns rows.
  Atribua o last destas rows a uma segunda row.
  Insira a rows A as rows deste text antes de a row.
  Remove a row desde as rows deste text.
  Destrua a row.
  Renumere as rows deste text.
  Atribua o número da linha desta segunda row ao número de linhas do cursor deste text.
  Atribua a quantidade de caracteres desta string desta segunda row menos o número ao caret número de coluna deste text.
  Desvencilhe-se de o text.

Etapas para que se insira uma coisa para uns coisas after uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se a segunda coisa for inexistente, anteponha a coisa para as coisas; volte.
  Insira a coisa a as coisas antes de o next desta segunda coisa.

Etapas para que se insira uma coisa para uns coisas antes de uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se as coisas estiverem vazio, posponha a coisa para as coisas; volte.
  Se a segunda coisa for inexistente, posponha a coisa para as coisas; volte.
  Se a segunda coisa for o first destas coisas, anteponha a coisa para as coisas; volte.
  Atribua a coisa a uma new coisa.
  Atribua a segunda coisa a uma previous coisa.
  Atribua a new coisa ao next deste previous desta previous coisa.
  Atribua a previous coisa ao next desta new coisa.
  Atribua o previous desta previous coisa ao previous desta new coisa.
  Atribua o new coisa ao previous desta previous coisa.

Etapas para que se insira uns coisas para uns segunda coisas after um coisa:
  Se a coisa for inexistente, anteponha  as coisas para a segunda coisas; volte.
  Insira  as coisas ao segunda coisas antes de o next desta coisa.

Etapas para que se insira uns coisas para uns segunda coisas antes de um coisa:
  Isole o coisa.
  Percorra. [o código abaixo]
    Atribua o first destas coisas a uma segunda coisa.
    Se a segunda coisa for inexistente, cancele.
    Remove a segunda coisa desde as coisas.
    Insira a segunda coisa ao segunda coisas antes de o coisa.
  Repita. [o código acima]

Etapas para que se insira um vértice para um polígono after um segundo vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono after o segundo vértice.

Etapas para que se insira um vértice para um polígono sob uma localização:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um segundo vértice desde os vértices deste polígono.
    Se o segundo vértice for inexistente, cancele.
    Se o next deste segundo vértice for inexistente, cancele.
    Atribua a localização deste segundo vértice e a localização deste next deste segundo vértice a uma linha reta.
    Se a localização não estiver sobre a linha reta, repita.
  Insira o vértice aos vértices deste polígono after o segundo vértice.

Etapas para que se insira um vértice para um polígono antes de um segundo vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono antes de o segundo vértice.

Etapas para que se intersect uma caixa com uma segunda caixa usando um terceiro caixa:
  \ caixas does not touch
  Limpe o terceiro caixa.
  Se a coordenada X do canto superior esquerdo desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, cancele.
  Se a coordenada Y do canto superior esquerdo desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, cancele.
  Se a coordenada X do canto inferior direito desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, cancele.
  Se a coordenada Y do canto inferior direito desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, cancele.
  \ caixas touch
  Atribua a caixa ao terceiro caixa.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, atribua a coordenada X do canto superior esquerdo desta segunda caixa à coordenada X do canto superior esquerdo desta terceiro caixa.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, atribua a coordenada Y do canto superior esquerdo desta segunda caixa à coordenada Y do canto superior esquerdo desta terceiro caixa.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, atribua a coordenada X do canto inferior direito desta segunda caixa à coordenada X do canto inferior direito desta terceiro caixa.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta terceiro caixa.

 \Etapas para que se invert um detector:
\ see "reverse um detector"
\Se o detector for yes, atribua no ao detector; volte.
 \Atribua yes ao detector.

Um Endereço IP é um conjunto com
  Um número, 
  Uma string. 

Um grupo data/hora de criação é uma string.

Um item é um conjunto com
  Uma categoria [pasta, arquivo, etc], \ 
  Um endereço completo, 
  Um endereço da pasta, 
  Um designador, 
  Uma extensão,
  Um size, 
  Um grupo data/hora de criação,
  Um WIN32FINDDATA e 
  Um número identificador.

Etapas para que se jump o caret left em um text:
  Se o text for inexistente, cancele.
  Mova o caret left para algum tipo de non-noise pedaço no text.
  Se o caret número de coluna deste text for 1, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua o first endereço de memória do pedaço desta string desta row mais o caret número de coluna deste text menos 2 a um endereço de memória do pedaço .
  Se o conteúdo deste endereço de memória do pedaço for alfanumérico, mova o caret left para algum tipo de non-alfanumérico pedaço no text.
  Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, mova o caret left para algum tipo de non-symbolic pedaço no text.
  Mova o caret left para algum tipo de non-noise pedaço no text.

Etapas para que se jump o caret right em um text:
  Se o text for inexistente, cancele.
  Mova o caret right para algum tipo de non-noise pedaço no text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret número de coluna deste text é a quantidade de caracteres desta string desta row, cancele.
  Atribua o first endereço de memória do pedaço desta string desta row mais o caret número de coluna deste text menos 1 a um endereço de memória do pedaço .
  Se o conteúdo deste endereço de memória do pedaço é alfanumérico, mova o caret right para algum tipo de non-alfanumérico pedaço no text.
  Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, mova o caret right para algum tipo de non-symbolic pedaço no text.
  Mova o caret right para algum tipo de non-noise pedaço no text.

Um key é um número.

Um kilobyte é 1024 units.

Um categoria é uma string.

Um lParam é um número.

Um folha modo paisagem é uma folha.

O tamanho de letra grande é um tamanho da letra.

O maior número é 2147483647.

Um mínimo múltiplo comum é um número.

Um clique é um input.

Um left é uns twips.

Uma quantidade de caracteres é uns twips.

Um tamanho da letra é uns twips. \ indicates actual altura of um typical uppercase letra

Uma letra é um pedaço.

O dicionário léxico é uma coisa com um catálogo.

Etapas para que se clareie uma cor por um quantia:
  Adicione o quantia para a luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se clareie uma cor por uns percentual;
Etapas para que se clareie uma cor about uns percentual;
Etapas para que se clareie uma cor por about uns percentual;
Etapas para que se clareie uma cor uns percentual:
  Atribua a luminosidade desta cor mais o percentual à luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se clareie o current cor about uns percentual:
  Clareie a cor deste context pelo percentual.

Etapas para que se clareie um matiz por uns degrees:
  Adicione o degrees para o matiz.

Etapas para que se clareie um matiz por uns points:
  Converta o matiz para uns segunda points.
  Adicione o points para a segunda points.
  Converta a segunda points para o matiz.

Um luminosidade é um número [que vai desde o número 0 até o número 1000].

Etapas para que se limite uma caixa para uma segunda caixa:
  Limite a coordenada X do canto superior esquerdo desta caixa para a coordenada X do canto superior esquerdo desta segunda caixa e a coordenada X do canto inferior direito desta segunda caixa.
  Limite a coordenada Y do canto superior esquerdo desta caixa para a coordenada Y do canto superior esquerdo desta segunda caixa e a coordenada Y do canto inferior direito desta segunda caixa.
  Limite a coordenada X do canto inferior direito desta caixa para a coordenada X do canto superior esquerdo desta segunda caixa e a coordenada X do canto inferior direito desta segunda caixa.
  Limite a coordenada Y do canto inferior direito desta caixa para a coordenada Y do canto superior esquerdo desta segunda caixa e a coordenada Y do canto inferior direito desta segunda caixa.

Etapas para que se limite o caret em um text:
  Se o text for inexistente, cancele.
  Limite o número de linhas do cursor deste text para 1 e a contagem de linhas deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Limite o caret número de coluna deste text para 1 e a quantidade de caracteres desta string desta row.

Etapas para que se limite um número para um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, atribua o segundo número ao número; volte.
  Se o número for maior do que o terceiro número, atribua o terceiro número ao número.

Etapas para que se limite a origem of um text:
  Se o text for inexistente, cancele.
  Limite a coordenada X deste text para o menor número e a margem deste text.
  Atribua a contagem de linhas deste text menos 1 times a altura da linha deste text a um número.
  Limite a coordenada Y deste text para - o número e 0.

Etapas para que se limite uma localização para uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização.
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização.

Etapas para que se limite uns texts para uma contagem:
  Atribua a contagem destes texts a uma segunda contagem.
  Percorra. [o código abaixo]
    Se a segunda contagem for menor do que ou igual à contagem, cancele.
    Atribua o first destes texts a um text.
    Remove o text desde o texts.
    Destrua o text.
    Subtraia 1 desde a segunda contagem.
  Repita. [o código acima]

Uma localização inicial é uma localização.
Uma localização final é uma localização.

Uma linha reta é um conjunto com \ linha, traço, risco, traçado, listra
  Uma localização inicial e 
  Uma localização final.

Etapas para que se liste umas choices em uma caixa;
Etapas para que se pinte umas choices em uma caixa:
  \Pinte really fast. ***
  Obtenha uma [first/next] choice desde as choices.
  Se a choice estiver missing [because we have drawn them all], cancele.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais 24 pixels à coordenada X do canto superior esquerdo desta choice.
  Atribua a coordenada X do canto inferior direito desta caixa menos 24 pixels à coordenada X do canto inferior direito desta choice.
  Se a choice for o first desta choice, atribua a coordenada Y do canto superior esquerdo desta caixa mais 24 pixels à coordenada Y do canto superior esquerdo desta choice.
  Se a choice não for o first desta choice, atribua a coordenada Y do canto inferior direito deste previous desta choice à coordenada Y do canto superior esquerdo desta choice.
  Atribua a coordenada Y do canto superior esquerdo desta choice mais 24 pixels à coordenada Y do canto inferior direito desta choice.
  \Pinte a caixa desta choice com a cor púrpura. \ temp ***
  Pinte o nome desta choice na caixa desta choice com a cor deste context.
  Repita. [o código acima]

Etapas para que se liste umas choices em uma caixa com uma cor;
Etapas para que se pinte umas choices em uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte o choices na caixa.

Etapas para que se carregue o dicionário léxico:
  Se o dicionário léxico não for inexistente, cancele.
  Extraia um endereço da pasta desde o endereço completo deste module.
  Percorra. [o código abaixo]
    Se o endereço da pasta estiver em branco, cancele.
    Atribua o endereço da pasta seguido de "dicionário léxico\" a um endereço completo.
    Se o endereço completo estiver no sistema de arquivos, Carregue o dicionário léxico usando o endereço completo; volte.
    Extraia o endereço da pasta desde o endereço da pasta.
  Repita. [o código acima]

Etapas para que se carregue o dicionário léxico usando um trecho:
  Se o dicionário léxico for inexistente, crie o dicionário léxico.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Mova o percorredor (catálogo dicionário léxico rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Catalogue o segmento inicial deste percorredor no catálogo deste dicionário léxico.
  Repita. [o código acima]

Etapas para que se carregue o dicionário léxico usando um endereço completo:
  Obtenha um item desde o endereço completo.
  Se o item não for found, cancele.
  Se a categoria deste item não for "arquivo", repita.
  Read o endereço completo deste item a um trecho.
  Se o erro do fluxo de entrada/saída não estiver em branco, repita.
  Carregue o dicionário léxico usando o trecho.
  Repita. [o código acima]

Etapas para que se localize uma caixa usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a caixa usando o par de números.

Etapas para que se localize uma localização usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a localização usando o par de números.

Etapas para que se lock um gpBitmap usando um BitmapData (24-bit espaço de cor RGB):
  Atribua o gprect deste gpBitmap a um gprect.
  Call "gdiplus.dll" "GdipBitmapLockBits" com
   o gpBitmap 
   e o endereçamento deste gprect 
   e 3 [ImageLockModeRead ou ImageLockModeWrite] 
   e 137224 [PixelFormat24bppRGB] 
   e o endereçamento deste BitmapData.

\Um logbrush é um conjunto com \ documentar
\Um número denominado lbstyle,
\Um código da cor denominado lbcolor,
\Um número denominado lbhatch.

Etapas para que se lowercase algum tipo de pedaços selecionados em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
    Lowercase o subtexto.
  Repita. [o código acima]

Etapas para que se lowercase um pedaço:
  \Add 32 to each letter in the string entre "A" and "Z".
  Translate o pedaço usando o tabela de caracteres minúsculos ASCII .

Etapas para que se lowercase o character depois de um finger e atribua it para uma string:
  Se o finger for inexistente, cancele.
  Atribua o conteúdo deste finger à string.
  Lowercase a string.

Etapas para que se lowercase uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Lowercase o conteúdo deste first endereço de memória do pedaço deste subtexto.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se lowercase um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, pare.
    Lowercase a string deste row.
  Repita. [o código acima]
  Wrap o text.

A janela principal do programa é um janela do programa.

Etapas para que se faça uma fração com um número e um segundo número:
  Atribua o número ao numerador desta fração.
  Atribua o segundo número ao denominador desta fração.

Etapas para que se faça um par de números racionais usando uma caixa e uma segunda caixa;
Etapas para que se faça uma par de números fracionários usando uma caixa e uma segunda caixa:
  Atribua o x-extent desta caixa à numerador desta fração deste par de números fracionários.
  Atribua o x-extent desta segunda caixa ao denominador desta fração deste par de números fracionários.
  Atribua o y-extent desta caixa ao numerador desta segunda fração deste par de números fracionários.
  Atribua o y-extent desta segunda caixa ao denominador desta segunda fração deste par de números fracionários.

Um margem é um número.

Etapas para que se cubra internamente uma caixa:
  Crie um hRgn usando a caixa.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente um elipse:
  Crie um hRgn usando a elipse.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hRgn e 4 [RGN_DIFF].

Etapas para que se cubra internamente um polígono:
  Crie um hRgn usando o polígono.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Um mask é um texto hexadecimal.

Etapas para que se cubra somente dentro de uma caixa:
  Exponha tudo.
  Cubra internamente a caixa.

Etapas para que se cubra somente dentro de um elipse:
  Exponha tudo.
  Cubra internamente a elipse.

Etapas para que se cubra somente dentro de um polígono:
  Exponha tudo.
  Cubra internamente o polígono.

Etapas para que se cubra somente dentro de uma caixa arredondada:
  Exponha tudo.
  Cubra internamente a caixa arredondada.

Etapas para que se cubra somente fora de uma caixa:
  Exponha tudo.
  Cubra externamente a caixa.

Etapas para que se cubra somente fora de um elipse:
  Exponha tudo.
  Cubra externamente a elipse.

Etapas para que se cubra somente fora de um polígono:
  Exponha tudo.
  Cubra externamente o polígono.

Etapas para que se cubra somente fora de uma caixa arredondada:
  Exponha tudo.
  Cubra externamente a caixa arredondada.

Etapas para que se cubra externamente uma caixa:
  Crie um hRgn usando a caixa.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente um elipse:
  Crie um hRgn usando a elipse.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hRgn e 1 [RGN_AND].

Etapas para que se cubra externamente um polígono:
  Crie um hRgn usando o polígono.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Cubra externamente o hRgn.
  Destrua o hRgn.

O max text undos é uma contagem igual a 32.

O tamanho de letra médio é um tamanho da letra.

O memory canvas é um canvas.

Etapas para que se minimize um janela do programa:
  Call "user32.dll" "ShowWindow" com 
    A janela do programa 
    e 6 [SW_MINIMIZE].

Etapas para que se mirror o gpBitmap em um imagem:
  Se a imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Mirror o gpBitmap desta imagem.

Etapas para que se mirror um GpImage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O GpImage 
    e 4 [RotateNoneFlipX].

Etapas para que se mirror um imagem:
  Se a imagem for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa desta imagem menos a coordenada X deste center desta caixa intacta desta imagem ao número X desse par de números.
  Multiplique o número X deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Mirror o gpBitmap no imagem.

Etapas para que se mova o anchor left para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o anchor número da linha deste text e o text.
  Percorra. [o código abaixo]
    Se o anchor número de coluna deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o anchor número de coluna deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Subtraia 1 desde o anchor número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o caret para baixo em um text:
  Se o text for inexistente, cancele.
  Adicione 1 para o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas para que se mova o caret para baixo one página em um text:
  Se o text for inexistente, cancele.
  Adicione as rows/box deste text para o número de linhas do cursor deste text.
  Subtraia 1 desde o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas para que se mova o caret para o first pedaço of o current row of um text:
  Se o text for inexistente, cancele.
  Atribua 1 ao caret número de coluna deste text.

Etapas para que se mova o caret para o first pedaço of um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao caret deste text.

Etapas para que se mova o caret para o last pedaço of o current row of um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row ao caret número de coluna deste text.

Etapas para que se mova o caret para o last pedaço of um text:
  Se o text for inexistente, cancele.
  Atribua a contagem de linhas deste text ao número de linhas do cursor deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row ao caret número de coluna deste text.

Etapas para que se mova o caret left para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret número de coluna deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret número de coluna deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Subtraia 1 desde o caret número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o caret left para algum tipo de non-noise pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret número de coluna deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret número de coluna deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for irrelevante, cancele.
    Subtraia 1 desde o caret número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o caret left para algum tipo de non-symbolic pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret número de coluna deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret número de coluna deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for symbolic, cancele.
    Subtraia 1 desde o caret número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o caret left em um text:
  Se o text for inexistente, cancele.
  Subtraia 1 desde o caret número de coluna deste text.
  Limite o caret no text.

Etapas para que se mova o caret right para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret número de coluna deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret número de coluna deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Adicione 1 para o caret número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o caret right para algum tipo de non-noise pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret número de coluna deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret número de coluna deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for irrelevante, cancele.
    Adicione 1 para o caret número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o caret right para algum tipo de non-symbolic pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret número de coluna deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret número de coluna deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for symbolic, cancele.
    Adicione 1 para o caret número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o caret right em um text:
  Se o text for inexistente, cancele.
  Adicione 1 para o caret número de coluna deste text.
  Limite o caret no text.

Etapas para que se mova o caret para cima em um text:
  Se o text for inexistente, cancele.
  Subtraia 1 desde o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas para que se mova o caret para cima one página em um text:
  Se o text for inexistente, cancele.
  Subtraia as rows/box deste text desde o número de linhas do cursor deste text.
  Adicione 1 para o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas para que se mova um finger over um número:
  Se o finger for inexistente, cancele.
  Adicione 1 para o finger.

Etapas para que se mova um imagem para baixo uns twips:
  Mova a imagem usando 0 e os twips.

Etapas para que se mova um imagem usando um par de números:
  Mova a imagem usando o número X deste par de números e o número Y deste par de números.

Etapas para que se mova um imagem usando uns x-twips e uns y-twips:
  Se a imagem for inexistente, cancele.
  Mova a caixa desta imagem usando o x-twips e o y-twips.
  Mova a caixa intacta desta imagem usando o x-twips e o y-twips.

Etapas para que se mova um imagem left uns twips:
  Mova a imagem usando - os twips e 0.

Etapas para que se mova um imagem right uns twips:
  Mova a imagem usando os twips e 0.

Etapas para que se mova um imagem para uma localização:
  Se a imagem for inexistente, cancele.
  Obtenha um difference entre a localização e o canto superior esquerdo desta imagem.
  Mova a imagem usando a difference.

Etapas para que se mova um imagem para cima uns twips:
  Mova a imagem usando 0 e - os twips.

Etapas para que se mova uns squares:
  Mova o square size times o squares dividido por 1 square. \ squares são scaled para cima por precision hence o division sob o end

Etapas para que se mova uns squares diagonally;
Etapas para que se mova uns squares slantways:
  Mova o square size times o squares times o raiz de dois dividido por 1 square. \ squares são scaled para cima por precision hence o division sob o end

Etapas para que se mova um subtexto usando um número:
  Adicione o número para o first endereço de memória do pedaço deste subtexto.
  Adicione o número para o last endereço de memória do pedaço deste subtexto.

Etapas para que se mova uma coisa desde uns coisas para uns segunda coisas:
  Se a coisa for inexistente, cancele.
  Isole o coisa.
  Remove a coisa desde as coisas.
  Posponha a coisa para a segunda coisas.

Etapas para que se mova uns coisas para uns segunda coisas:
  Atribua o first destas coisas ao first destas segunda coisas.
  Atribua o last destas coisas ao last destas segunda coisas.
  Limpe as coisas.

Etapas para que se mova uma janela do programa left:
  Call "user32.dll" "GetWindowRect" com 
    A janela principal do programa 
    e O endereçamento dessa caixa.
  Subtraia a pixel largura desta tela desde a coordenada X do canto superior esquerdo desta caixa.
  Call "user32.dll" "MoveWindow" com 
    A janela do programa 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A pixel largura desta tela 
    e A pixel altura desta tela 
    e 1.

Etapas para que se mova uma janela do programa right:
  Call "user32.dll" "GetWindowRect" com 
    A janela principal do programa 
    e O endereçamento dessa caixa.
  Adicione a pixel largura desta tela para a coordenada X do canto superior esquerdo desta caixa.
  Call "user32.dll" "MoveWindow" com 
    A janela do programa 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A pixel largura desta tela 
    e A pixel altura desta tela 
    e 1.

Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números racionais;
Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números fracionários:
  Se a imagem for inexistente, cancele.
  Mova a caixa intacta desta imagem usando o par de números fracionários e o canto superior esquerdo desta caixa desta imagem.
  Redimensione a caixa intacta desta imagem usando o par de números fracionários.
  Redimensione a caixa desta imagem usando o par de números fracionários.
  Se a coordenada X do canto inferior direito desta imagem for menor do que a coordenada X do canto superior esquerdo desta imagem, mirror o gpBitmap no imagem.
  Se a coordenada Y do canto inferior direito desta imagem for menor do que a coordenada Y do canto superior esquerdo desta imagem, flip o gpBitmap no imagem.

Etapas para que se redimensione cuidadosamente [sem perder qualidade] um imagem usando um twip par de números:
  Se a imagem for inexistente, cancele.
  Atribua a caixa desta imagem a uma caixa.
  Redimensione a caixa usando o twip par de números.
  Faça uma par de números fracionários usando a caixa e a caixa desta imagem.
  redimensione cuidadosamente [sem perder qualidade] a imagem usando o par de números fracionários.

Etapas para que se normalize um ângulo:
  Divida o ângulo por 3600 usando um quociente e o ângulo.

Etapas para que se normalize uma caixa:
  Se a coordenada X do canto inferior direito desta caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, permute a coordenada X do canto superior esquerdo desta caixa com a coordenada X do canto inferior direito desta caixa.
  Se a coordenada Y do canto inferior direito desta caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, permute a coordenada Y do canto superior esquerdo desta caixa com a coordenada Y do canto inferior direito desta caixa.

Etapas para que se normalize um canvas:
  Call "gdi32.dll" "SetGraphicsMode" com 
    O canvas 
    e 2 [GM_ADVANCED].
  Call "gdi32.dll" "SetBkMode" com 
    O canvas 
    e 1 [TRANSPARENT].
  Call "gdi32.dll" "SetMapMode" com 
    O canvas 
    e 8 [MM_ANISOTROPIC ].
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O canvas 
    e 0 
    e 0 
    e nil.
  Call "gdi32.dll" "SetViewportExtEx" com 
    O canvas 
    e O ppi 
    e O ppi 
    e nil.
  Call "gdi32.dll" "SetWindowOrgEx" com 
    O canvas 
    e 0 
    e 0 
    e nil.
  Call "gdi32.dll" "SetWindowExtEx" com 
    O canvas 
    e O tpi 
    e O tpi 
    e nil.

Etapas para que se normalize um elipse:
  Normalize a caixa desta elipse.

Etapas para que se normalize uma fração e uma segunda fração:
  Obtenha um mínimo múltiplo comum usando o denominador desta fração e o denominador desta segunda fração.
  Multiplique o numerador desta fração pelo mínimo múltiplo comum dividido pelo denominador desta fração.
  Atribua o mínimo múltiplo comum ao denominador desta fração.
  Multiplique o numerador desta segunda fração pelo mínimo múltiplo comum dividido pelo denominador desta segunda fração.
  Atribua o mínimo múltiplo comum ao denominador desta segunda fração.

Etapas para que se normalize uma orientação:
  Divida a orientação por 3840 usando um quociente e um resto.
  Atribua o resto à orientação.
  Se a orientação for menor do que 0, adicione 3840 para a orientação.

Etapas para que se normalize um horizontal linha reta:
  Se a localização final desta linha reta for menor do que a localização inicial desta linha reta, permute a localização final desta linha reta com a localização inicial desta linha reta.

Etapas para que se normalize um matiz:
  Divida o matiz por 3600 usando um quociente e um resto.
  Atribua o resto ao matiz.
  Se o matiz for menor do que 0, adicione 3600 para o matiz.

Etapas para que se normalize um imagem:
  Se a imagem for inexistente, cancele.
  Normalize a caixa desta imagem.
  Normalize a caixa intacta desta imagem.

Etapas para que se normalize uma seleção:
  Se o anchor número da linha desta seleção for menor do que o número de linhas do cursor desta seleção, cancele.
  Se o anchor número da linha desta seleção for maior do que o número de linhas do cursor desta seleção, permute o anchor desta seleção com o caret desta seleção; volte.
  Se o anchor número de coluna desta seleção for maior do que o caret número de coluna desta seleção, permute o anchor número de coluna desta seleção com o caret número de coluna desta seleção.

Etapas para que se normalize um text:
  Se o text for inexistente, cancele.
  Normalize a caixa deste text.

Etapas para que se normalize um vertical linha reta:
  Se a localização final desta linha reta for menor do que a localização inicial desta linha reta, permute a localização final desta linha reta com a localização inicial desta linha reta.

O null HBRUSH é um HBRUSH.

O null hpen é um hpen.

Etapas para que se termine com o caractere NULL uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres armazenados mais 1.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres armazenados menos 1 ao last endereço de memória do pedaço desta string.
  Atribua o last endereço de memória do pedaço desta string mais 1 a um endereço de memória do pedaço .
  Atribua o caractere null ao conteúdo deste endereço de memória do pedaço.

Etapas para que se termine com o caractere NULL um wide string:
  Atribua a quantidade de caracteres deste wide string a uma quantidade de caracteres armazenados.
  Reassign o first endereço de memória do pedaço desta wide string usando a quantidade de caracteres armazenados mais 2.
  Atribua o first endereço de memória do pedaço desta wide string mais a quantidade de caracteres armazenados menos 1 ao last deste wide string.

Um offset é um número.

Uma operação é uma string.

Uma origem é uma localização.

Etapas para que se outdent algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita. \selecionada
    Se o conteúdo deste first endereço de memória do pedaço desta string desta row for o caractere de espaço, remove o first pedaço desde a string deste row.
    Se o conteúdo deste first endereço de memória do pedaço desta string desta row for o caractere de espaço, remove o first pedaço desde a string deste row.
  Repita. [o código acima]

Um outdent é um número.

Etapas para que se outline uma caixa com uma cor:
  Pinte a caixa com a cor e a cor preta.

  
Um x-offset é um offset.
Um y-offset é um offset.

Etapas para que se output o arco of uma elipse usando uma string: \\ interessante.
  Atribua 2761/10000 a um fração. \ (sqrt(2) -1 ) * (2/3)   = 0,2761423749153967
  Atribua o center desta elipse a um center localização.
  Atribua o x-extent desta elipse dividido por 2 a um half largura.
  Atribua o y-extent desta elipse dividido por 2 a um half altura.
  Atribua o x-extent desta elipse times a fração a um x-offset.
  Atribua o y-extent desta elipse times a fração a um y-offset.
  \ control point 1
  Se a string for "canto superior esquerdo", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y deste center menos o y-offset a um first control localização.
  Se a string for "canto superior direito", atribua a coordenada X deste center mais o x-offset e a coordenada Y do canto superior esquerdo desta elipse ao first control localização.
  Se a string for "canto inferior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y deste center mais o y-offset ao first control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X deste center menos o x-offset e a coordenada Y do canto inferior direito desta elipse ao first control localização.
  \ control point 2
  Se a string for "canto superior esquerdo", atribua a coordenada X deste center menos o x-offset e a coordenada Y do canto superior esquerdo desta elipse a um second control localização.
  Se a string for "canto superior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y deste center menos o y-offset ao second control localização.
  Se a string for "canto inferior direito", atribua a coordenada X deste center mais o x-offset e a coordenada Y do canto inferior direito desta elipse ao second control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y deste center mais o y-offset ao second control localização.
  \ ending point
  Se a string for "canto superior esquerdo", atribua a coordenada X do canto superior esquerdo desta elipse mais o half largura e a coordenada Y do canto superior esquerdo desta elipse a um ending localização.
  Se a string for "canto superior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y do canto superior esquerdo desta elipse mais o half altura ao ending localização.
  Se a string for "canto inferior direito", atribua a coordenada X do canto inferior direito desta elipse menos o half largura e a coordenada Y do canto inferior direito desta elipse ao ending localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y do canto inferior direito desta elipse menos o half altura ao ending localização.
  \ spit it out
  Output o first control localização sem passar pra próxima linha.
  Output o second control localização sem passar pra próxima linha.
  Output o ending localização sem passar pra próxima linha.
  Output "c".

Etapas para que se output uma cor sem passar pra próxima linha:
  Converta a cor para um espaço de cor RGB.
  Atribua o espectro vermelho deste espaço de cor RGB / 255 a um fração.
  Converta a fração para um red string usando 4.
  Atribua o espectro verde deste espaço de cor RGB / 255 à fração.
  Converta a fração para um green string usando 4.
  Atribua o espectro azul deste espaço de cor RGB / 255 à fração.
  Converta a fração para um blue string usando 4.
  Output o red string seguido de " " junto com o green string seguido de " " junto com o blue string sem passar pra próxima linha.

Etapas para que se output lineto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "l".

Etapas para que se output lineto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output lineto usando a localização.

Etapas para que se output moveto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "m".

Etapas para que se output moveto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output moveto usando a localização.

Etapas para que se output um número sem passar pra próxima linha:
  Converta o número para uma string.
  Output a string sem passar pra próxima linha.
  Output " " sem passar pra próxima linha.

Etapas para que se output stroke e fill usando uma cor da borda e uma cor de preenchimento:
  Atribua "B" a uma string. \ stroke e fill
  Se a cor de preenchimento estiver clear, atribua "S" à string. \ stroke
  Se a cor da borda estiver clear, atribua "f" à string. \ fill
  Output a string.

\Um paintstruct é um conjunto com
\Um hdc denominado hdc,
\Um número denominado ferase,
\Um caixa denominado rcpaint,
\Um número denominado frestore,
\Um número denominado fincupdate,
\  32 pedaços.

Um número X é um número.
Um número Y é um número.

Um par de números é um conjunto com 
  Um número X e 
  Um número Y.

Um endereçamento de caractere é um endereço de memória do pedaço.

Um pdevmode é um endereço de memória para um devmode.

Etapas para que se escolha aleatoriamente um número within um quantia of um segundo número:
  Escolha aleatoriamente o número entre o segundo número menos o quantia e o segundo número mais o quantia.
  Atribua o número ao número deste context.

Uma imagem é uma coisa com \FIGURA?
\ as caixas estão em twits
Um caixa [location of cropped imagem sobre a página], 
Um caixa intacta [location of entire imagem sobre a página],
Um grayscale detector,
Um mirror detector,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal denominado data [original pedaços em original format],
Um gpBitmap.

Etapas para que se toque um wave:
  Call "winmm.dll" "PlaySound" com 
    O first desta wave 
    e 0 
    e 5 [SND_MEMORY+SND_ASYNC].

Etapas para que se toque um wave e wait:
  Call "winmm.dll" "PlaySound" com 
    O first desta wave 
    e 0 
    e 4 [SND_MEMORY+SND_SYNC].

Etapas para que se toque um wave file:
  Isole o wave file.
  Termine com o caractere NULL o wave file.
  Call "winmm.dll" "PlaySound" com 
    O first deste wave file 
    e 0 
    e 131073 [snd_filename+snd_async].

Etapas para que se toque um wave file e wait:
  Isole o wave file.
  Termine com o caractere NULL o wave file.
  Call "winmm.dll" "PlaySound" com 
    O first deste wave file 
    e 0 
    e 131072 [snd_filename+snd_sync].

Etapas para que se anteponha uma coisa para uns coisas:
  Se a coisa for inexistente, cancele.
  Atribua o first destas coisas ao next desta coisa.
  Se  as coisas não for vazio, atribua a coisa ao previous deste first destas coisas.
  Se  as coisas estiverem vazio, atribua a coisa ao last destas coisas.
  Atribua a coisa ao first destas coisas.

\Etapas para que se anteponha uns coisas para umas segunda coisas:
\ bug found por Mike Gonta - corrected version below
\Obtenha uma coisa desde  as coisas (backwards).
\Se a coisa for inexistente, cancele.
\Remove a coisa desde as coisas.
\Anteponha a coisa para a segunda coisas.
\Repita. [o código acima]

Etapas para que se anteponha uns coisas para umas segunda coisas:
  Atribua o last destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Anteponha a coisa para a segunda coisas.
  Repita. [o código acima]

Um process é um número identificador.

Um process endereço de memória é um endereço de memória para um process.

Um punch linha reta é uma string.

Etapas para que se atribua o character depois de um finger para um character:
  Se o finger for inexistente, limpe o character; volte.
  Atribua o conteúdo deste finger ao character.

Etapas para que se atribua um date/time para uma segunda date/time:
  Atribua o year deste date/time ao year desta segunda date/time.
  Atribua o month deste date/time ao month desta segunda date/time.
  Atribua o week day deste date/time ao week day segunda date/time.
  Atribua o day deste date/time ao day desta segunda date/time.
  Atribua a hour deste date/time à hour desta segunda date/time.
  Atribua o minute deste date/time ao minute desta segunda date/time.
  Atribua o second deste date/time ao second desta segunda date/time.
  Atribua o millisecond deste date/time ao millisecond desta segunda date/time.

Etapas para que se atribua a string dessa date/time para uma string:
  Limpe a string.
  Posponha o year deste date/time para a string.
  Posponha "/" para a string.
  Zero fill o month deste date/time usando 2 e posponha it para a string.
  Posponha "/" para a string.
  Zero fill o day deste date/time usando 2 e posponha it para a string.
  Posponha " " para a string.
  Zero fill a hour deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o minute deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o second deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o millisecond deste date/time usando 3 e posponha it para a string.

Etapas para que se atribua um finger sobre o first character of uma string:
  Atribua o first endereço de memória do pedaço desta string ao finger.

Etapas para que se atribua a contagem desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha um bucket usando o catálogo.
  Se o bucket for inexistente, cancele.
  Adicione a contagem destes refers deste bucket para a contagem.
  Repita. [o código acima]

Etapas para que se atribua a used contagem de buckets desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, cancele.
    Se os refers deste bucket estiverem vazio, repita.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se atribua um número para um word big-endian unsigned:
  Atribua o número a um word.
  Atribua o word ao word big-endian unsigned.

Etapas para que se atribua um número para uma string;
Etapas para que se converta um número para uma string:
  Limpe a string.
  Isole o número.
  De-sign o número.
  Percorra. [o código abaixo]
    Divida o número por 10 usando um quociente e um resto.
    Adicione 48 para o resto.
    Atribua o resto a um pedaço.
    Anteponha o pedaço para a string.
    Se o quociente for 0, pare.
    Atribua o quociente ao número.
  Repita. [o código acima]
  Se o original número for menor do que 0, anteponha o hífem para a string.

Etapas para que se atribua um número sobre o stack:
  Converta o número para um segmento inicial.
  Atribua o segmento inicial sobre o stack.

Etapas para que se atribua o absolute value desse número para um segundo número:
  Atribua o número ao segundo número.
  De-sign o segundo número.

Etapas para que se atribua um OutlineTextmetric para uma segunda OutlineTextmetric:
  Copie pedaços desde o endereçamento deste OutlineTextmetric para o endereçamento desta segunda OutlineTextmetric pela magnitude deste OutlineTextmetric.

Etapas para que se atribua o absolute value desse par de números para um segundo par de números:
  Atribua o par de números ao segundo par de números.
  De-sign o segundo par de números.

\ unclear why this does not get called properly when I replace hoja apaisada com caja ***

Etapas para que se atribua um imagem no middle of uma caixa;
Etapas para que se centralize um imagem em uma caixa:
  Se a imagem for inexistente, cancele.
  Centralize a imagem na caixa (horizontalmente).
  Centralize a imagem na caixa (verticalmente).

Etapas para que se atribua um imagem sobre uma localização;
Etapas para que se centralize um imagem sobre uma localização:
  Se a imagem for inexistente, cancele.
  Obtenha um difference entre a localização e o center desta caixa desta imagem.
  Arredonde a difference para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando a difference.

Etapas para que se atribua o working string dessa row para um subtexto:
  Se a row for inexistente, limpe o subtexto; volte.
  Lance o subtexto sobre a string deste row.
  Subtraia 1 desde o last endereço de memória do pedaço deste subtexto.

Etapas para que se atribua uma seleção para uma segunda seleção:
  Atribua o anchor desta seleção ao anchor desta segunda seleção.
  Atribua o caret desta seleção ao caret desta segunda seleção.

Etapas para que se atribua um sockaddr para uma segunda sockaddr:
  Copie pedaços desde o endereçamento deste sockaddr para o endereçamento desta segunda sockaddr pela magnitude deste sockaddr.

Etapas para que se atribua uma string para uma letra:
  Atribua o conteúdo deste first endereço de memória do pedaço desta string à letra.

Etapas para que se atribua uma string para um text:
  Se o text for inexistente, cancele.
  Destrua as rows deste text.
  Reset a origem of o text.
  Reset o caret of o text.
  Desvencilhe-se de o text.
  Isole a string.
  Posponha o retorno de carro para a string.
  Converta a string para as rows deste text.
  Wrap o text.

Etapas para que se atribua uma string sobre o área de transferência do Windows:
  Call "user32.dll" "OpenClipboard" com 
    A janela principal do programa.
  Call "user32.dll" "EmptyClipboard".
  Atribua a quantidade de caracteres desta string mais 1 a um número.
  Call "kernel32.dll" "GlobalAlloc" com 
  66 [GHND - 0x0042 - unifica GMEM_MOVEABLE e GMEM_ZEROINIT.] 
    e O número 
    devolvendo um número identificador.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador 
    devolvendo um endereço de memória.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o endereço de memória pelo quantidade de caracteres desta string.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "user32.dll" "SetClipboardData" com 
  1 [CF_TEXT] 
    e O número identificador.
  Call "user32.dll" "CloseClipboard".

Etapas para que se atribua a largura dessa string para uma largura:
  \Consegui traduzir como:
  \Etapas para que se atribua uma largura desse string para uma segunda largura:
  Obtenha a largura usando a string e o memory canvas e a fonte padrão.

\\leave out - causes Spanish string atribuas para resolva here instead of "Atribua uma string a uma segunda string"
Etapas para que se atribua um subtexto para um segundo subtexto:
  Copie pedaços desde o endereçamento deste subtexto para o endereçamento deste segundo subtexto pela magnitude deste subtexto.

Etapas para que se atribua o date/time do system para um date/time:
  Call "kernel32.dll" "GetLocalTime" com o endereçamento desse SYSTEMTIME.
  Atribua o wYear deste SYSTEMTIME ao year deste date/time.
  Atribua o wMonth deste SYSTEMTIME ao month deste date/time.
  Atribua o wDayOfWeek deste SYSTEMTIME ao week day deste date/time.
  Atribua o wDay deste SYSTEMTIME ao day deste date/time.
  Atribua o wHour deste SYSTEMTIME à hour deste date/time.
  Atribua o wMinute deste SYSTEMTIME ao minute deste date/time.
  Atribua o wSecond deste SYSTEMTIME ao second deste date/time.
  Atribua os wMilliseconds deste SYSTEMTIME ao millisecond deste date/time.

Etapas para que se atribua o last erro do system para um número:
  Call "kernel32.dll" "GetLastError" devolvendo o número.

Etapas para que se atribua o last winsock erro do system para um número:
  Call "ws2_32.dll" "WSAGetLastError" devolvendo o número.

Etapas para que se atribua a contagem de intervalos do sistema para uns intervalos:
  \ wraps cada 24.8 days ou so
  Call "kernel32.dll" "GetTickCount" devolvendo os intervalos.
  Conjuncione logicamente os intervalos com o maior número.

Etapas para que se atribua um terminal no middle of uma caixa;
Etapas para que se centralize um terminal em uma caixa:
  Isole a caixa.
  Indent a caixa 24 px.
  Atribua a caixa à caixa deste terminal.

Etapas para que se atribua um text no middle of uma caixa;
Etapas para que se centralize um text em uma caixa:
  Se o text for inexistente, cancele.
  Centralize o text na caixa (horizontalmente).
  Centralize o text na caixa (verticalmente).

Etapas para que se atribua um text sobre uma localização;
Etapas para que se centralize um text sobre uma localização:
  Se o text for inexistente, cancele.
  Obtenha um difference entre a localização e o center desta caixa deste text.
  Arredonde a difference para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o text usando a difference.

Etapas para que se atribua a first linha reta desse text para uma string:
  Se o text for inexistente, limpe a string; volte.
  Atribua a string desta first row deste text à string.
  Remove o last pedaço desde a string.

Etapas para que se atribua a first non-em branco linha reta desse text para uma string:
  \ *** new
  Limpe a string.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Atribua a string deste row à string.
    Remove o last pedaço desde a string. \ cr ou space (see text rules)
    Remove algum tipo de leading noise desde a string.
    Remove algum tipo de trailing noise desde a string.
  Se a string estiver em branco, repita.
  \Se a string não estiver em branco, pare.

Etapas para que se atribua a globalized origem desse text para uma localização:
  Se o text for inexistente, limpe a localização; volte.
  Atribua a origem deste text à localização.
  Globalize a localização usando o canto superior esquerdo deste text.

Etapas para que se atribua a malha desse text para um malha:
  Se o text for inexistente, limpe a malha; volte.
  Atribua a altura desta font deste text times 4 ao número X desta malha.
  Atribua a altura desta font deste text ao número Y desta malha.

Etapas para que se atribua a normalized seleção desse text para uma seleção:
  Se o text for inexistente, cancele.
  Atribua a seleção deste text à seleção.
  Normalize a seleção.

Etapas para que se atribua a contagem de linhas desse text para uma contagem:
  Se o text for inexistente, atribua 0 à contagem; volte.
  Se as rows deste text estiverem vazio, atribua 0 à contagem; volte.
  Atribua o número da linha deste last destas rows deste text à contagem.

Etapas para que se atribua a altura da linha desse text para uma altura:
  Se o text for inexistente, atribua 0 ao altura; volte.
  Atribua a altura desta font deste text ao altura.

Etapas para que se atribua a rows/box desse text para uma contagem:
  Se o text for inexistente, atribua 0 à contagem; volte.
  Atribua a altura desta caixa deste text dividido pela altura da linha deste text à contagem.

Etapas para que se atribua a quantidade de caracteres selecionados desse text para uma contagem:
  Atribua 0 à contagem.
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
  Se a row for inexistente, cancele.
  Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
  Adicione a quantidade de caracteres deste subtexto para a contagem.
  Repita. [o código acima]

Etapas para que se atribua a selecionado contagem de linhas desse text para uma contagem:
  Atribua 0 à contagem.
  Se o text for inexistente, cancele.
  Atribua a normalized seleção deste text a uma seleção.
  Se o anchor número da linha desta seleção é o número de linhas do cursor desta seleção, cancele.
  Atribua o número de linhas do cursor desta seleção à contagem.
  Subtraia o anchor número da linha desta seleção desde a contagem.
  Se o caret número de coluna desta seleção não for 1, adicione 1 para a contagem.

Etapas para que se atribua o painel de informações string desse text para uma string:
  Se o text for inexistente, limpe a string; volte.
  Atribua a selecionado contagem de linhas deste text a uma contagem.
  Se a contagem não for 0, format a contagem e "linha selecionada" ou "linhas selecionadas" à string; volte.
  Atribua a quantidade de caracteres selecionados deste text a uma segunda contagem.
  Se a segunda contagem não for 0, format a segunda contagem e "pedaço" ou "pedaços" à string; volte.
  Converta o número de linhas do cursor deste text para a string.
  Posponha ":" para a string.
  Posponha o caret número de coluna deste text para a string.

Etapas para que se atribua uma coisa sob o end of uns coisas;
Etapas para que se posponha uma coisa para uns coisas:
  Se a coisa for inexistente, cancele.
  Atribua o last destas coisas ao previous desta coisa.
  Se as coisas não estiverem vazio, atribua a coisa ao next deste last destas coisas.
  Se as coisas estiverem vazio, atribua a coisa ao first destas coisas.
  Atribua a coisa ao last destas coisas.

Etapas para que se atribua umas coisas para umas segunda coisas:
  Atribua o first destas coisas ao first destas segunda coisas.
  Atribua o last destas coisas ao last destas segunda coisas.

Etapas para que se atribua a contagem dessas coisas  para uma contagem:
  Atribua 0 à contagem.
  Percorra. [o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a coisa for inexistente, cancele.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se atribua um temporizador para uma string;
Etapas para que se converta um temporizador para uma string:
  Converta os intervalos deste temporizador para a string.

Etapas para que se atribua a string desse temporizador para uma string:
  Converta os intervalos deste temporizador para a string.

Etapas para que se atribua os intervalos desse temporizador para uns intervalos:
  Atribua os intervalos totais deste temporizador aos intervalos.
  Se a contagem deste temporizador for 0, cancele.
  Atribua a contagem de intervalos do sistema a uns intervalos de temporização. 
  Subtraia os intervalos iniciais deste temporizador desde os intervalos de temporização.
  Adicione os intervalos de temporização para os intervalos.

Etapas para que se atribua um segmento inicial sobre o stack:
  Aloque memória para um stack entry.
  Atribua o segmento inicial à string desta stack entry.
  Anteponha o stack entry para o stack.

Etapas para que se quit;
Etapas para que se relinquish control:
  Desmanche a fila de eventos.
  Crie um event.
  Atribua "fechamento do programa" à categoria deste event.
  Enfileire o event.

Um quora é uma coisa com \ quora é abreviação de "question or answer"
  uma string e 
  uma cor. 

Etapas para que se quote uma string:
  \ inserts leading, trailing e nested double-quotes
  Atribua as aspas duplas a uma segunda string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a segunda string.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for as aspas duplas, posponha as aspas duplas para a segunda string.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Posponha as aspas duplas para a segunda string.
  Atribua a segunda string à string.



Etapas para que se atualize a tela usando uma caixa:
  Call "gdi32.dll" "BitBlt" com 
    O tela canvas 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A largura desta caixa 
    e A altura desta caixa 
    e O quadro atual 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e 13369376 [SRCCOPY].

Etapas para que se relembre um text:
  Se o text for inexistente, cancele.
  Destrua os redos deste text.
  Copie o text a um segundo text.
  Redimensione proporcionalmente o segundo text para 1/1.
  Posponha o segundo text para os undos deste text.
  Limite os undos deste text para o max text undos.
  Ligue o detector de alteração deste text.

Etapas para que se relembre um text com um operação:
  Se o text for inexistente, cancele.
  Se o última operação deste text for a operação, acione o detector de alteração deste text; volte.
  Relembre o text.
  Atribua o operação à última operação deste text.

Etapas para que se relembre where we are:
  Salve o context.

Etapas para que se remove algum tipo de pedaços selecionados em um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Atribua a seleção deste text a uma seleção.
  Normalize a seleção.
  Obtenha uma row usando o anchor número da linha desta seleção e o text.
  Lance um subtexto sobre a string deste row.
  Atribua o first endereço de memória do pedaço deste subtexto mais o anchor número de coluna desta seleção menos 2 ao last endereço de memória do pedaço deste subtexto.
  Obtenha uma segunda row usando o número de linhas do cursor desta seleção e o text.
  Lance um segundo subtexto sobre a string desta segunda row.
  Atribua o first endereço de memória do pedaço deste segundo subtexto mais o caret número de coluna desta seleção menos 1 ao first endereço de memória do pedaço deste segundo subtexto.
  Atribua o subtexto junto com o segundo subtexto à string desta row.
  Remove as rows of o text entre o next desta row e a segunda row.
  Atribua o anchor desta seleção ao caret deste text.
  Desvencilhe-se de o text.

Etapas para que se remova pedaços de um text (backspace over um return):
  Se o text for inexistente, cancele.
  Se o número de linhas do cursor deste text for 1, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text menos 1 e o text.
  Atribua a quantidade de caracteres desta string desta row e o número de linhas do cursor deste text menos 1 ao caret deste text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (backspace com jump):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; volte.
  Se o caret número de coluna deste text for 1, remova pedaços de o text (backspace over um return); volte.
  Jump o caret left no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (backspace):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; volte.
  Se o caret número de coluna deste text for 1, remova pedaços de o text (backspace over um return); volte.
  Mova o caret left no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (forward delete um return):
  Se o text for inexistente, cancele.
  Se o número de linhas do cursor deste text for a contagem de linhas deste text, cancele.
  Atribua 1 e o número de linhas do cursor deste text mais 1 ao caret deste text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (forward delete com jump):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; volte.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret número de coluna deste text é a quantidade de caracteres desta string desta row, remova pedaços de o text (forward delete um return); volte.
  Jump o caret right no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (forward delete):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; volte.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret número de coluna deste text é a quantidade de caracteres desta string desta row, remova pedaços de o text (forward delete um return); volte.
  Mova o caret right no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remove cada pedaço em um text:
  Se o text for inexistente, cancele.
  Atribua "" ao text.

Etapas para que se remove o first pedaço desde uma string:
  Lance um subtexto sobre o first pedaço of a string.
  Remova pedaços de a string usando o subtexto.

   
Etapas para que se remove o last pedaço desde uma string:
  Lance um subtexto sobre o last pedaço of a string.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove os last dois pedaços desde uma string:
  Remove trailing pedaços desde a string usando 2.

Etapas para que se remove leading pedaços desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; volte.
  Lance um subtexto sobre o first pedaço of a string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a contagem menos 1 ao last endereço de memória do pedaço deste subtexto.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove leading noise desde uma string;
Etapas para que se remove algum tipo de leading noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço desta string não for irrelevante, cancele.
  Remove o first pedaço desde a string.
  Repita. [o código acima]

Etapas para que se remove a rows of um text entre uma row e uma segunda row:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Se a segunda row for inexistente, cancele.
  Se o número da linha desta row for maior do que o número da linha desta segunda row, cancele.
  Isole a row.
  Atribua o next desta segunda row a uma stop row.
  Percorra. [o código abaixo]
    Se a row for a stop row, pare.
    Atribua o next desta row a uma next row.
    Remove a row desde as rows deste text.
    Destrua a row.
    Atribua o next row à row.
  Repita. [o código acima]
  Renumere as rows deste text.

Etapas para que se remove uma coisa desde uns coisas:
  Se a coisa for inexistente, cancele.
  Se a coisa for o first destas coisas, atribua o next desta coisa ao first destas coisas.
  Se a coisa for o last destas coisas, atribua o previous desta coisa ao last destas coisas.
  Se o next desta coisa não for inexistente, atribua o previous desta coisa ao previous deste next desta coisa.
  Se o previous desta coisa não for inexistente, atribua o next desta coisa ao next deste previous desta coisa.
  Esvazie o next desta coisa.
  Esvazie o previous desta coisa.

Etapas para que se remove trailing pedaços desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; volte.
  Lance um subtexto sobre o last pedaço of a string.
  Atribua o last endereço de memória do pedaço deste subtexto menos a contagem mais 1 ao first endereço de memória do pedaço deste subtexto.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove trailing noise desde uma string;
Etapas para que se remove algum tipo de trailing noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço desta string não for irrelevante, cancele.
  Remove o last pedaço desde a string.
  Repita. [o código acima]

Etapas para que se rename um endereço completo para um segundo endereço completo no sistema de arquivos:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Isole o segundo endereço completo.
  Remove algum tipo de trailing barra invertida desde o segundo endereço completo.
  Termine com o caractere NULL o segundo endereço completo.
  Call "kernel32.dll" "MoveFileA" com 
    O first deste endereço completo 
    e O first deste segundo endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro ao renomear o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se renumere uns rows:
  Obtenha uma row desde a rows.
  Se a row for inexistente, cancele.
  Adicione 1 para um número da linha.
  Atribua o número da linha ao número da linha desta row.
  Repita. [o código acima]

Etapas para que se replace um pedaço com um segundo pedaço em uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o pedaço, adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Atribua o segundo pedaço ao conteúdo deste first endereço de memória do pedaço deste subtexto.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

A reply é uma reply.

Uma reply é uma string.

Etapas para que se reenfileire um event:
  Copie o event a um segundo event.
  Enfileire o segundo event.

Etapas para que se reset o alphabet:
  Atribua o 'A' maiúsculo ao next letra.

Etapas para que se reset o caret of um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao caret deste text.

Etapas para que se reset o context:
  Restaure o context.
  Salve o context.

Etapas para que se reset uma contagem:
  Atribua 0 à contagem.

Etapas para que se reset o drawing origem:
  Defina o drawing origem para o zero localização.

Etapas para que se reset um detector:
  Desative o detector.

Etapas para que se reset a origem of um text:
  Se o text for inexistente, cancele.
  Atribua a margem deste text à coordenada X deste text.
  Atribua 0 à coordenada Y deste text.

Etapas para que se reset um temporizador:
  Atribua 0 à contagem deste temporizador.
  Atribua 0 aos intervalos iniciais deste temporizador.
  Atribua 0 aos intervalos totais deste temporizador.

Etapas para que se redimensione uma caixa usando um par de números racionais;
Etapas para que se redimensione uma caixa usando uma par de números fracionários:
  Atribua o x-extent desta caixa a um largura.
  Atribua o y-extent desta caixa a uma altura.
  Redimensione proporcionalmente a largura usando a fração deste par de números fracionários.
  Redimensione proporcionalmente a altura usando a segunda fração deste par de números fracionários.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais a largura à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura à coordenada Y do canto inferior direito desta caixa.

Etapas para que se redimensione uma caixa usando um twip par de números:
  Adicione o número X deste twip par de números para a coordenada X do canto inferior direito desta caixa.
  Adicione o número Y deste twip par de números para a coordenada Y do canto inferior direito desta caixa.

Etapas para que se redimensione um elipse usando um par de números racionais;
Etapas para que se redimensione um elipse usando uma par de números fracionários:
  Redimensione a caixa desta elipse usando o par de números fracionários.

Etapas para que se redimensione um elipse usando um twip par de números:
  Redimensione a caixa desta elipse usando o twip par de números.

Etapas para que se redimensione um linha reta usando um par de números racionais;
Etapas para que se redimensione um linha reta usando uma par de números fracionários:
  Atribua a caixa desta linha reta a uma caixa.
  Subtraia o canto superior esquerdo desta caixa desde a localização inicial desta linha reta.
  Redimensione proporcionalmente a localização inicial desta linha reta usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para a localização inicial desta linha reta.
  Subtraia o canto superior esquerdo desta caixa desde a localização final desta linha reta.
  Redimensione proporcionalmente a localização final desta linha reta usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para a localização final desta linha reta.

Etapas para que se redimensione um linha reta usando um twip par de números:
  Atribua a caixa desta linha reta a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Faça uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione o linha reta usando o par de números fracionários.

Etapas para que se redimensione um imagem para um largura por uma altura:
  Se a imagem for inexistente, cancele.
  Atribua a largura dividido pelo quantidade de twips/pixel a um pixel largura.
  Atribua a altura dividido pelo quantidade de twips/pixel a um pixel altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
    A pixel largura 
    e A pixel altura 
    e 0 
    e 137224 [pixelformat24bpprgb] 
    e 0 
    e O endereçamento desse gpBitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
    O gpBitmap 
    e O endereçamento desse gpgraphic.
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com
   O gpgraphic 
   e O gpBitmap desta imagem
   e 0 
   e 0 
   e A pixel largura 
   e A pixel altura
   e 0 
   e 0 
   e A largura deste gpBitmap desta imagem menos 1 
   e A altura deste gpBitmap desta imagem menos 1
   e 2 [unitpixel] 
   e nil 
   e nil 
   e 0.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
   O gpgraphic.
  Destrua o gpBitmap desta imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).
  Limpe os data desta imagem.

Etapas para que se redimensione um polígono usando um par de números racionais;
Etapas para que se redimensione um polígono usando uma par de números fracionários:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia o canto superior esquerdo desta caixa desde a localização deste vértice.
    Redimensione proporcionalmente a localização deste vértice usando o par de números fracionários.
    Adicione o canto superior esquerdo desta caixa para a localização deste vértice.
  Repita. [o código acima]

Etapas para que se redimensione um polígono usando um twip par de números:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Faça uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione o polígono usando o par de números fracionários.

Etapas para que se redimensione um text usando um par de números racionais;
Etapas para que se redimensione um text usando uma par de números fracionários:
  Se o text for inexistente, cancele.
  Redimensione a caixa deste text usando o par de números fracionários.
  Wrap o text.

Etapas para que se redimensione um text usando um twip par de números:
  Se o text for inexistente, cancele.
  Redimensione a caixa deste text usando o twip par de números.
  Wrap o text.

Etapas para que se restart um temporizador:
  Adicione 1 para a contagem deste temporizador.
  Se a contagem deste temporizador não for 1, cancele.
  Atribua a contagem de intervalos do sistema aos intervalos iniciais deste temporizador. \ a intervalo contagem deste system

Etapas para que se restaure um canvas:
  Call "gdi32.dll" "RestoreDC" com 
    O canvas [HDC]
    e -1. \ nSavedDC - O estado salvo a ser restaurado. 
    \Se este parâmetro for positivo, ele representa uma instância específica do estado a ser restaurado. 
    \Se este parâmetro for negativo, ele representa uma instância relativa ao estado atual. 
    \Nesse caso, o valor -1 restaura o estado salvo mais recentemente.

Etapas para que se restaure um context:
  Obtenha um saved context desde o context stack.
  Se o saved context for inexistente, cancele.
  Atribua a localização deste saved context à localização deste context.
  Atribua a orientação deste saved context à orientação deste context.
  Atribua a tamanho da letra deste saved context à tamanho da letra deste context.
  Atribua a cor deste saved context à cor deste context.
  Atribua o número deste saved context ao número deste context.
  Remove o saved context desde o context stack.
  Destrua o saved context.

Etapas para que se restaure uma janela do programa:
  Call "user32.dll" "ShowWindow" com 
    A janela do programa 
    e 9 [SW_RESTORE].

Etapas para que se reverse algum tipo de rows selecionadas of um text:
  Se o text for inexistente, cancele.
  Separe a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
  Reverse o rows selecionadas.
  Posponha a rows para as rows deste text.
  Posponha o rows selecionadas para as rows deste text.
  Posponha a segunda rows para as rows deste text.
  Renumere as rows deste text.

Etapas para que se reverse uma cor:
  Se a cor for a cor preta, atribua a cor branca à cor; volte.
  Se a cor for a cor branca, atribua a cor preta à cor; volte.
  Atribua 1000 menos a luminosidade desta cor à luminosidade desta cor.
    \Atribua 1000 menos a saturação desta cor à saturação desta cor.
  Adicione 1800 para a matiz desta cor. Normalize a matiz desta cor.

Etapas para que se invert um detector;
Etapas para que se reverse um detector:
  Se o detector for 1, atribua 0 ao detector; volte.
  Atribua 1 ao detector.

Etapas para que se reverse uma string:
  \ podia ser more efficient
  Isole a string.
  Limpe o original string.
  Percorra. [o código abaixo]
    Se a string estiver em branco, pare.
    Obtenha um character desde a string (backwards).
    Posponha o character para o original string.
  Repita. [o código acima]

Etapas para que se reverse uns coisas:
  Permute  as coisas com uns segunda coisas.
  Percorra. [o código abaixo]
    Atribua o last destas segunda coisas a uma coisa.
    Se a coisa for inexistente, cancele.
    Mova a coisa desde a segunda coisas para as coisas.
  Repita. [o código acima]

Um deslocamento vertical é um número.
Um deslocamento horizontal é um número.

Etapas para que se rotate uma caixa:
  Atribua o center desta caixa a um center localização.
  Atribua a caixa a uma segunda caixa.
  Atribua a coordenada Y deste center menos a coordenada Y do canto superior esquerdo desta segunda caixa mais a coordenada X deste center à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada X do canto superior esquerdo desta segunda caixa menos a coordenada X deste center mais a coordenada Y deste center à coordenada Y do canto superior esquerdo desta caixa.
  Atribua a coordenada Y deste center menos a coordenada Y do canto inferior direito desta segunda caixa mais a coordenada X deste center à coordenada X do canto superior esquerdo desta caixa.
  Atribua a coordenada X do canto inferior direito desta segunda caixa menos a coordenada X deste center mais a coordenada Y deste center à coordenada Y do canto inferior direito desta caixa.

Etapas para que se rotate um elipse:
  Rotate a caixa desta elipse.

Etapas para que se rotate um GpImage:
  Se o GpImage for inexistente, cancele.
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O GpImage 
    e 1 [Rotate90FlipNone].

Etapas para que se rotate um GpImage usando um ângulo:
  \ o ângulo pode ser 0, 900, 1800, 2700
  Se o GpImage for inexistente, cancele.
  Atribua 0 [RotateNoneFlipNone] a um número.
  Se o ângulo for 900, atribua 1 [Rotate90FlipNone] ao número.
  Se o ângulo for 1800, atribua 2 [Rotate180FlipNone ] ao número.
  Se o ângulo for 2700, atribua 3 [Rotate270FlipNone ] ao número.
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O GpImage 
    e O número.

Etapas para que se rotate um linha reta:
  Atribua o center desta linha reta a um center localização.
  Rotate a localização inicial desta linha reta around o center.
  Rotate a localização final desta linha reta around o center.

Etapas para que se rotate um imagem:
  Se a imagem for inexistente, cancele.
  Adicione 900 para o ângulo de rotação desta imagem.
  Se o mirror detector desta imagem estiver ativo, adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Rotate a caixa desta imagem.
  Rotate a caixa intacta desta imagem.
  Atribua o center desta caixa desta imagem a um center localização.
  Atribua o center desta caixa intacta desta imagem a uma segunda center localização.
  Atribua a coordenada Y deste center menos a coordenada Y desta segunda center mais a coordenada X deste center ao número X desse twip par de números.
  Subtraia a coordenada X desta segunda center desde o número X deste twip par de números.
  Atribua a coordenada Y deste center mais a coordenada X desta segunda center menos a coordenada X deste center ao número Y deste twip par de números.
  Subtraia a coordenada Y desta segunda center desde o número Y deste twip par de números.
  Mova a caixa intacta desta imagem usando o twip par de números.
  Rotate o gpBitmap desta imagem.

Etapas para que se rotate um polígono:
  Se o polígono for inexistente, cancele.
  Atribua o center deste polígono a um center localização.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Rotate a localização deste vértice around o center.
  Repita. [o código acima]

Etapas para que se rotate uma localização around um center localização:
  Atribua a localização a uma segunda localização.
  Atribua a coordenada Y deste center menos a coordenada Y desta segunda localização mais a coordenada X deste center à coordenada X desta localização.
  Atribua a coordenada X desta segunda localização menos a coordenada X deste center mais a coordenada Y deste center à coordenada Y desta localização.

Etapas para que se rotate um text:
  Se o text for inexistente, cancele.
  Rotate a caixa deste text.
  Wrap o text.

Etapas para que se arredonde um número para um segundo número:
  Arredonde o número para o múltiplo imediato of o segundo número.

Etapas para que se arredonde um número para baixo para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número.
  Multiplique o número pelo segundo número.

Etapas para que se arredonde um número para o múltiplo imediato of um outro número:
  Se o outro número for 0, cancele.
  Isole o outro número.
  Divida o número pelo outro número usando um quociente e um resto.
  Divida o outro número por 2.
  Se o resto for maior do que ou igual ao outro número, arredonde o número para cima para o múltiplo imediato of o original outro número; volte.
  Arredonde o número para baixo para o múltiplo imediato of o original outro número.

Etapas para que se arredonde um número para cima para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número usando um quociente e um resto.
  Se o resto for 0, cancele.
  Adicione o segundo número menos o resto para o número.

Etapas para que se arredonde um par de números para um segundo par de números:
  Arredonde o par de números para o múltiplo imediato of o segundo par de números.

Etapas para que se arredonde um par de números para o múltiplo imediato of um segundo par de números:
  Arredonde o número X deste par de números para o múltiplo imediato of o número X deste segundo par de números.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número Y deste segundo par de números.

Etapas para que se arredonde um par de números para o múltiplo imediato of um número:
  Arredonde o número X deste par de números para o múltiplo imediato of o número.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número.

Etapas para que se arredonde um par de números para um número:
  Arredonde o par de números para o múltiplo imediato of o número.

Um caixa arredondada é uma caixa com
  Uma coordenada X do canto superior esquerdo, 
  Uma coordenada Y do canto superior esquerdo, 
  Uma coordenada X do canto inferior direito, 
  Uma coordenada Y do canto inferior direito,
  Um canto superior esquerdo localização sob a coordenada X do canto superior esquerdo , 
  Um canto inferior direito localização sob a coordenada X do canto inferior direito, e 
  Um raio.



Um número da linha é um número.

Etapas para que se salve um canvas:
  Call "gdi32.dll" "SaveDC" com o canvas.

Etapas para que se salve um context:
  Aloque memória para um saved context.
  Atribua a localização deste context à localização deste saved context.
  Atribua a orientação deste context à orientação deste saved context.
  Atribua a tamanho da letra deste context à tamanho da letra deste saved context.
  Atribua a cor deste context à cor deste saved context.
  Atribua o número deste context ao número deste saved context.
  Anteponha o saved context para o context stack.

O saved memory hbitmap é um hbitmap.

O saved quantidade de twips/pixel é um número.

Etapas para que se say um número:
  Atribua o número a uma string.
  Say a string.

Etapas para que se say uma string;
Etapas para que se speak uma string:
  Se o silent detector estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para um wide string.
  Termine com o caractere NULL a wide string.
  Call o speak desta vtable deste talker com 
    O talker 
    e O first endereço de memória do pedaço desta wide string 
    e 17 [SVSFDefault+SVSFlagsAsync +SVSFIsNotXML]  \https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms720892(v=vs.85)
    e 0.

Etapas para que se say uma string e wait;
Etapas para que se speak uma string e wait:
  Se o silent detector estiver ativo, cancele.
  Se la bandera silenciosa estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para um wide string.
  Termine com o caractere NULL a wide string.
  Call o speak desta vtable deste talker com 
    O talker 
    e O first endereço de memória do pedaço desta wide string 
    e 16 [SVSFDefault+SVSFIsNotXML] 
    e 0.

Etapas para que se redimensione proporcionalmente uma caixa usando um ratio;
Etapas para que se redimensione proporcionalmente uma caixa usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada X do canto superior esquerdo desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada Y do canto superior esquerdo desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada X do canto inferior direito desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada Y do canto inferior direito desta caixa usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a caixa usando a fração.

Etapas para que se redimensione proporcionalmente um elipse usando um ratio;
Etapas para que se redimensione proporcionalmente um elipse usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta elipse usando a fração.

Etapas para que se redimensione proporcionalmente um elipse para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a elipse usando a fração.

Etapas para que se redimensione proporcionalmente uma font usando um ratio;
Etapas para que se redimensione proporcionalmente uma font usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a altura desta font usando a fração.

Etapas para que se redimensione proporcionalmente uma fração usando uma segunda fração;
Etapas para que se multiplique uma fração por uma segunda fração:
  Multiplique o numerador desta fração pelo numerador desta segunda fração.
  Multiplique o denominador desta fração pelo denominador desta segunda fração.
  Reduza a fração.

Etapas para que se redimensione proporcionalmente um linha reta usando um ratio;
Etapas para que se redimensione proporcionalmente um linha reta usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a localização inicial desta linha reta usando a fração.
  Redimensione proporcionalmente a localização final desta linha reta usando a fração.

Etapas para que se redimensione proporcionalmente um linha reta para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o linha reta usando a fração.

Etapas para que se redimensione proporcionalmente um par de números usando um ratio;
Etapas para que se redimensione proporcionalmente um par de números usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente o número X deste par de números usando a fração.
  Redimensione proporcionalmente o número Y deste par de números usando a fração.

Etapas para que se redimensione proporcionalmente um par de números usando um par de números racionais;
Etapas para que se redimensione proporcionalmente um par de números usando uma par de números fracionários:
  Redimensione proporcionalmente o número X deste par de números usando a fração deste par de números fracionários.
  Redimensione proporcionalmente o número Y deste par de números usando a segunda fração deste par de números fracionários.

Etapas para que se redimensione proporcionalmente um par de números para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o par de números usando a fração.

Etapas para que se redimensione proporcionalmente um imagem usando um ratio;
Etapas para que se redimensione proporcionalmente um imagem usando um fração:
  Se a imagem for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta imagem usando a fração.
  Redimensione proporcionalmente a caixa intacta desta imagem usando a fração.

Etapas para que se redimensione proporcionalmente um imagem para um percentual:
  Se a imagem for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a imagem usando a fração.

Etapas para que se redimensione proporcionalmente um polígono usando um ratio;
Etapas para que se redimensione proporcionalmente um polígono usando um fração:
  Se o polígono for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Redimensione proporcionalmente o vértice usando a fração.
  Repita. [o código acima]

Etapas para que se redimensione proporcionalmente um polígono para um percentual:
  Se o polígono for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o polígono usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa arredondada usando um ratio;
Etapas para que se redimensione proporcionalmente uma caixa arredondada usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa arredondada como uma caixa usando a fração.
  Redimensione proporcionalmente o raio desta caixa arredondada usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa arredondada para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a caixa arredondada usando a fração.

Etapas para que se redimensione proporcionalmente um text para um fração:
  \ absolute
  Se o text for inexistente, cancele.
  Atribua a scale deste text a uma segunda fração.
  Flip a segunda fração.
  Multiplique a segunda fração pela fração.
  Redimensione proporcionalmente o text usando a segunda fração.

Etapas para que se redimensione proporcionalmente um text usando um ratio;
Etapas para que se redimensione proporcionalmente um text usando um fração:
  Se o text for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa deste text usando a fração.
  Redimensione proporcionalmente a origem deste text usando a fração.
  Redimensione proporcionalmente a font deste text usando a fração.
  Redimensione proporcionalmente a scale deste text usando a fração.

Etapas para que se redimensione proporcionalmente um text para um percentual:
  Se o text for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o text usando a fração.

Etapas para que se redimensione proporcionalmente um vértice usando um ratio;
Etapas para que se redimensione proporcionalmente um vértice usando um fração:
  Se o vértice for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada X deste vértice usando a fração.
  Redimensione proporcionalmente a coordenada Y deste vértice usando a fração.

O tela canvas é um canvas.

A tela é um conjunto com 
  Uma caixa, 
  Uma pixel altura e 
  Uma pixel largura.

Etapas para que se role um console usando um event:
  Se o console for inexistente, cancele.
  Encontre um sector usando a malha deste console e a localização deste event.
  Percorra. [o código abaixo]
    Se o botão direito deste mouse não estiver sendo pressionado, cancele.
    Encontre uma segunda sector usando a malha deste console e a localização deste mouse.
    Obtenha um difference entre a segunda sector e o sector.
    Se a difference for 0, repita.
    Role o text deste console usando a difference.
    Mostre o console.
    Adicione a difference para o sector.
  Repita. [o código acima]

Etapas para que se role um text para o base:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua a contagem de linhas deste text menos 1 a um número.
  Atribua - o número times a altura da linha deste text à coordenada Y deste text.
  Limite a origem of o text.

  Multiplique o número por -1.
  Multiplique o número pela altura da linha deste texto.
  Adicione 2 ao número.
  Atribua o número à Coordenada Y deste texto.

Etapas para que se role um text para o caret:
  Se o text for inexistente, cancele.
  Se o número de coluna deste caret deste text for 1, atribua a margem deste text à coordenada X deste text.
  Obtenha uma caixa pelo caret no text.
  Ajuste a caixa usando 0 e - a quantidade de twips/pixel e 0 e a quantidade de twips/pixel . \ caret caixas do not fill entire row
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo deste text, atribua a coordenada Y do canto superior esquerdo deste text menos a coordenada Y do canto superior esquerdo desta caixa ao número Y dessa difference.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito deste text, atribua a coordenada Y do canto inferior direito deste text menos a coordenada Y do canto inferior direito desta caixa ao número Y desta difference.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo deste text , atribua a coordenada X do canto superior esquerdo deste text menos a coordenada X do canto superior esquerdo desta caixa ao número X desta difference.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito deste text, atribua a coordenada X do canto inferior direito deste text menos a coordenada X do canto inferior direito desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role o text usando a difference.

Etapas para que se role um text para o caret e center it:
  Se o text for inexistente, cancele.
  Atribua a margem deste text à coordenada X deste text.
  Obtenha uma caixa pelo caret no text.
  Se a caixa estiver inside a caixa deste text, cancele.
  Ajuste a caixa usando 0 e - a quantidade de twips/pixel e 0 e a quantidade de twips/pixel . \ caret caixas don not fill entire row
  Atribua o y-extent desta caixa deste text dividido por 2 a uma altura.
  Arredonde a altura para baixo para o múltiplo imediato of a altura da linha deste text.
  Atribua a coordenada Y do canto superior esquerdo desta caixa deste text mais a altura a uma coordenada Y do canto superior esquerdo.
  Atribua a coordenada Y do canto superior esquerdo mais a altura da linha deste text a uma coordenada Y do canto inferior direito.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo, atribua a coordenada Y do canto superior esquerdo menos a coordenada Y do canto superior esquerdo desta caixa ao número Y dessa difference.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito, atribua a coordenada Y do canto inferior direito menos a coordenada Y do canto inferior direito desta caixa ao número Y desta difference.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo deste text , atribua a coordenada X do canto superior esquerdo deste text menos a coordenada X do canto superior esquerdo desta caixa ao número X desta difference.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito deste text, atribua a coordenada X do canto inferior direito deste text menos a coordenada X do canto inferior direito desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role o text usando a difference.

Etapas para que se role um text para baixo one linha reta:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua - a altura da linha deste text ao número Y dessa difference. \ reescrever esse comando
  Role o text usando a difference.

Etapas para que se role um text para baixo one página:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Subtraia o y-extent desta caixa deste text desde a coordenada Y deste text.
  Adicione a altura da linha deste text para a coordenada Y deste text.
  Limite a origem of o text.

Etapas para que se role um text usando um difference:
  Se o text for inexistente, cancele.
  Isole a difference.
  Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número X desta difference.
  Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, cancele.
  Mova a origem deste text usando a difference.
  Limite a origem of o text.

Etapas para que se role um text para o topo:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua 0 à coordenada Y deste text.
  Limite a origem of o text.

Etapas para que se role um text para cima one linha reta:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua a altura da linha deste text ao número Y dessa difference.
  Role o text usando a difference.

Etapas para que se role um text para cima one página:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Adicione o y-extent desta caixa deste text para a coordenada Y deste text.
  Subtraia a altura da linha deste text desde a coordenada Y deste text.
  Limite a origem of o text.

Um sector é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y [indicating o canto superior esquerdo of o sector].

A seed é um número.

Etapas para que se selecione cada pedaço em um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao anchor deste text.
  Atribua a quantidade de caracteres desta string deste last destas rows deste text e a contagem de linhas deste text ao caret deste text.

Etapas para que se selecione um número da linha usando um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número da linha e o text.
  Se a row for inexistente, cancele.
  Atribua o número da linha ao anchor número da linha deste text .
  Atribua 1 ao anchor número de coluna deste text.
  Atribua o número da linha ao número de linhas do cursor deste text.
  Atribua a quantidade de caracteres desta string desta row ao caret número de coluna deste text.

Um caixa de seleção é uma caixa.

Uma seleção é um conjunto com 
  Um anchor número de coluna,
  Um anchor número da linha, 
  Um anchor sob o anchor número de coluna,
  Um caret número de coluna, 
  Um número de linhas do cursor, 
  Um caret sob o caret número de coluna.

Etapas para que se send um trecho para um socket:
  Limpe o erro do fluxo de entrada/saída.
  Atribua o first endereço de memória do pedaço deste trecho a um endereço de memória.
  Atribua a quantidade de caracteres deste trecho a uma quantidade de caracteres.
  Percorra. [o código abaixo]
  Se a quantidade de caracteres for 0, pare.
    Call "ws2_32.dll" "send" com 
       O socket 
       e O endereço de memória 
       e A quantidade de caracteres 
       e 0 
       devolvendo um número.
    Se o número for -1 [SOCKET_ERROR ], atribua "Ocorreu um erro na hora de enviar dados." ao erro do fluxo de entrada/saída; volte.
    Subtraia o número desde a quantidade de caracteres.
    Adicione o número para o endereço de memória.
  Repita. [o código acima]

Etapas para que se send um data string para um requisição WinHTTP:
  Se o requisição WinHTTP for inexistente, cancele.
  Call "WinHTTP.dll" "WinHttpSendRequest" com 
    O número identificador de requisição deste requisição WinHTTP 
    e 0 [WINHTTP_NO_ADDITIONAL_HEADERS] 
    e 0 e o first destes data 
    e A quantidade de caracteres destes data 
    e A quantidade de caracteres destes data 
    e 0 
    devolvendo um número resultante.
  Se o result for 0, atribua "Erro. Não foi possível enviar a solicitação." ao erro do fluxo de entrada/saída; volte.

Etapas para que se send um email:
  Limpe o erro do fluxo de entrada/saída.
  \ crie socket
  Crie um socket usando o smtp server deste email e 25.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  \ initial receive here por date/time stuff desde server
  Receive um response string desde o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send HELO
  Send "HELO " junto com o nome deste module junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send MAIL FROM: <xxx>
  Send "MAIL FROM: <" junto com o sender deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send RCPT TO: <xxx>
  Send "RCPT TO: <" junto com o recipient deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send DATA
  Send "DATA" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
  Limpe um temp string.
  Posponha "De: " junto com o sender deste email junto com o texto CRLF para o temp string.
  Posponha "Para: " junto com o recipient deste email junto com o texto CRLF para o temp string.
  Posponha "Assunto: " junto com o subject deste email junto com o texto CRLF ao temp string.
  Posponha "Reply-To: " junto com o sender deste email junto com o texto CRLF ao temp string.
  Posponha o texto CRLF para o temp string.
  Posponha a message deste email para o temp string (handling email transparency).
  Posponha o texto CRLF seguido de "." junto com o texto CRLF para o temp string.
  Send o temp string para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send QUIT
  Send "QUIT" junto com o texto CRLF para o socket.
  \ destrua socket
  Destrua o socket.

Etapas para que se send um message desde um sender para um recipient:
  Send o message para o recipient desde o sender.

Etapas para que se send um message desde um sender para um recipient via um smtp server:
  Send o message para o recipient desde o sender via o smtp server.

Etapas para que se send um message desde um sender para um recipient com um subject:
  Send o message para o recipient desde o sender com o subject.

Etapas para que se send um message desde um sender para um recipient com um subject via um smtp server:
  Send o message para o recipient desde o sender com o subject via o smtp server.

Etapas para que se send um message para um recipient desde um sender:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender com um subject:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender com um subject via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send uma string para um socket e receive um response string:
  Limpe a response string.
  Send a string para o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Receive a response string desde o socket.

Um sender é uma string.

Etapas para que se defina o código da cor of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetTextColor" com 
    O canvas e o código da cor.

Etapas para que se defina o drawing origem para uma localização:
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 112 [PhysicalOffsetYX] 
    devolvendo o número X desse par de números.
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 113 [PhysicalOffsetY ] 
    devolvendo o número Y deste par de números.
  Negate o par de números.
  Se o quadro atual não for a área de impressão, limpe o par de números.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e O número X deste par de números 
    e O número Y deste par de números 
    e nil.
  Isole a localização.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e O endereçamento desta localização 
    e 1.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    e nil.

Etapas para que se acione um detector;
Etapas para que se ative um detector;
Etapas para que se dispare um detector;
Etapas para que se toque um detector;
Etapas para que se ligue um detector:
  Atribua 1 ao detector. \ era "Atribua sim ao detector." O valor binário do termo sim era herdado do CAL-1000 de acordo com o Dan.

Etapas para que se defina um endereço completo para read-write mode:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Conjuncione logicamente o número com -2 [everything except FILE_ATTRIBUTE_READONLY].
  Call "kernel32.dll" "SetFileAttributesA" com 
    O first deste endereço completo 
    e O número.

Um folha é uma caixa.

Etapas para que se mostre um console:
  Se o console for inexistente, cancele.
  Salve o quadro atual.
  Pinte o console.
  Atualize o tela usando a caixa deste console.
  Restaure o quadro atual.

Etapas para que se mostre um cursor:
  Call "user32.dll" "SetCursor" com o cursor.
  Call "user32.dll" "ShowCursor" com 1 
    devolvendo um número.
  Se o número for maior do que 0, cancele.
  Repita. [o código acima]

Etapas para que se mostre um terminal:
  Se o terminal for inexistente, cancele.
  Salve o quadro atual.
  Pinte o terminal.
  Atualize o tela usando a caixa deste terminal.
  Restaure o quadro atual.

Etapas para que se shrink uma caixa por uns twips;
Etapas para que se indent uma caixa uns twips;
Etapas para que se indent uma caixa por uns twips;
Etapas para que se indent uma caixa uns twips sobre cada side;
Etapas para que se indent uma caixa usando uns twips:
  Adicione os twips para a coordenada X do canto superior esquerdo desta caixa.
  Adicione os twips para a coordenada Y do canto superior esquerdo desta caixa.
  Subtraia os twips desde a coordenada X do canto inferior direito desta caixa.
  Subtraia os twips desde a coordenada Y do canto inferior direito desta caixa.

Etapas para que se feche o programa;
Etapas para que se feche o nosso programa;
Etapas para que se feche nosso programa;
Etapas para que se feche tudo;
Etapas para que se shut para baixo:
  Destrua o Bíblia.
  Destrua o stack.
  Destrua o dicionário léxico.
  Destrua o console.
  Destrua o terminal.
  Finalize o context.
  Finalize os canvases.
  Finalize o mouse.
  Finalize os cursors.
  Finalize as fonts.
  Finalize a janela do programa.
  Finalize o tela.
  Finalize as cors.
  Finalize o module.
  Finalize o talker.
  Finalize gdi+.
  Finalize winsock.
  Finalize COM.

Etapas para que se shut para baixo o cgi:
  Finalize o cgi.
  Finalize o module.
  Finalize winsock.

O silent detector é um detector.

Etapas para que se simplify um reply:
  Se o reply estiver em branco, pare.
  Obtenha um pedaço desde o reply.
  Se o pedaço é algum tipo de sinal de pontuação, repita.
  Posponha o pedaço para uma string.
  Repita. [o código acima]
  Atribua a string ao reply.

Um size é uns twips.

Etapas para que se skip algum tipo de leading quebra de linha em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for a quebra de linha, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.

Etapas para que se skip algum tipo de leading noise em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se skip algum tipo de non-alfanumérico pedaços em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for alfanumérico, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se skip um linha reta sobre o terminal:
  Escreva "" sobre o terminal.

Etapas para que se skip palavra characters em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o subtexto está sobre alguma espécie de contração, adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for alfanumérico, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se lance um percorredor sobre um segundo percorredor:
  Lance o segmento final deste percorredor sobre o segmento final deste segundo percorredor.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas para que se lance um percorredor sobre uma string:
  Lance o subtexto original deste percorredor sobre a string.
  Lance o segmento final deste percorredor sobre a string.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas para que se lance um subtexto sobre algum tipo de pedaços selecionados em uma row of um text:
  Limpe o subtexto.
  Se o text for inexistente, cancele.
  Se a row of o text não estiver selecionado, cancele.
  Lance o subtexto sobre a string deste row.
  Atribua a normalized seleção deste text a uma seleção.
  Se o número da linha desta row é o número de linhas do cursor desta seleção, atribua o first endereço de memória do pedaço deste subtexto mais o caret número de coluna desta seleção menos 2 ao last endereço de memória do pedaço deste subtexto.
  Se o número da linha desta row é o anchor número da linha desta seleção, atribua o first endereço de memória do pedaço deste subtexto mais o anchor número de coluna desta seleção menos 1 ao first endereço de memória do pedaço deste subtexto.

Etapas para que se lance um subtexto sobre o first pedaço of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o first endereço de memória do pedaço desta string ao last endereço de memória do pedaço deste subtexto.

Etapas para que se lance um subtexto sobre o last pedaço of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o last endereço de memória do pedaço desta string ao first endereço de memória do pedaço deste subtexto.

Etapas para que se suavize um polígono:
  Se o polígono for inexistente, cancele.
  Se a contagem destes vértices deste polígono for menor do que 3, cancele.
  Se o polígono estiver closed, posponha a localização deste next deste first vértice deste polígono para o polígono; ative um detector.
  Atribua o first vértice deste polígono a um left vértice.
  Percorra. [o código abaixo]
    Se o next deste left vértice for inexistente, pare.
    Atribua o next deste left vértice a um right vértice.
    Obtenha um center localização usando a localização deste left vértice e a localização deste right vértice.
    Insira o center ao polígono after o left vértice.
    Atribua o next deste left vértice a um new vértice.
    Se o previous deste left vértice for inexistente, atribua o right vértice ao left vértice; repita.
    Obtenha uma segunda center localização usando a localização deste previous deste left vértice e a localização deste new vértice.
    Obtenha um difference entre a segunda center e a localização deste left vértice.
    Divida a difference por 2.
    Adicione a difference para a localização deste left vértice.
    Atribua o right vértice ao left vértice.
  Repita. [o código acima]
  Se o detector não estiver ativo, cancele.
  Destrua o first vértice deste polígono usando o polígono.
  Destrua o last vértice deste polígono usando o polígono.

Etapas para que se suavize um polígono uns times; 
Etapas para que se suavize um polígono umas vezes:
  \ this use para "times" é um fluke, I think -- see "some times é um número"
  Isole o times.
  Percorra. [o código abaixo]
    Se o times for 0, cancele.
    Suavize o polígono.
    Subtraia 1 desde o times.
  Repita. [o código acima]

Some vezes é um número.

Um smtp server é uma string.

Um socket é um endereço de memória.

Etapas para que se classifique algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Separe a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
  Classifique o rows selecionadas.
  Posponha a rows para as rows deste text.
  Posponha o rows selecionadas para as rows deste text.
  Posponha a segunda rows para as rows deste text.
  Renumere as rows deste text.

Etapas para que se classifique uns rows:
  Se o first destas rows for o last destas rows, cancele.
  Separe a rows a uns left rows e umas right rows.
  Classifique as left rows.
  Classifique as right rows.
  Percorra. [o código abaixo]
    Atribua o first destas left rows a uma left row.
    Atribua o first destas right rows a uma right row.
    Se a left row for inexistente, posponha as right rows para as rows; volte.
    Se a right row for inexistente, posponha as left rows para as rows; volte.
    Se a string desta left row for maior do que a string desta right row, mova a right row desde as right rows para as rows; repita.
    Mova a left row desde as left rows para as rows.
  Repita. [o código acima]

Etapas para que se separe um trecho para uns dyads:
  Destrua o dyads.
  Se o trecho estiver em branco, cancele.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Mova o percorredor usando o & comercial.
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Crie um dyad.
    Posponha o dyad para o dyads.
    Separe o segmento inicial deste percorredor a um nome subtexto e um query subtexto usando o sinal de igualdade.
    Atribua o nome subtexto ao nome deste dyad.
    Converta o query subtexto como um texto de consulta ao value deste dyad.
  Repita. [o código acima]

Etapas para que se separe um pedaço para uma cifra binária e uma segunda cifra binária:
  Atribua o pedaço à cifra binária.
  Desloque a cifra binária right 4 bits.
  Atribua o pedaço ao segunda cifra binária.
  Conjuncione logicamente a segunda cifra binária com 15.

Etapas para que se separe um linha reta para uma segunda linha reta e um terceiro linha reta:
  Isole o linha reta.
  Atribua o center desta linha reta a um center localização.
  Atribua a localização inicial desta linha reta e o center ao segunda linha reta.
  Atribua o center e a localização final desta linha reta ao terceiro linha reta.

Etapas para que se separe um número para um word e uma segunda word:
  Isole o número.
  Desloque o número right 16 bits.
  Atribua o número ao word.
  Atribua o original número ao segunda word.

Etapas para que se separe a rows of um text para uns rows e uns rows selecionadas e uns segunda rows:
  Se o text for inexistente, limpe as rows; limpe o rows selecionadas; limpe as segunda rows; volte.
  Percorra. [o código abaixo]
    Atribua o first destas rows deste text a uma row.
    Se a row for inexistente, cancele.
    Remove a row desde as rows deste text.
    Se a row of o text estiver selecionado, acione um detector; posponha a row para o rows selecionadas; repita.
    Se o detector estiver ativo, posponha a row para a segunda rows; repita.
    Posponha a row para a rows.
  Repita. [o código acima]

Etapas para que se separe uma string para um left subtexto e um right subtexto usando um separator pedaço:
  Limpe o left .
  Limpe o right subtexto.
  Se a string estiver em branco, cancele.
  Atribua o first endereço de memória do pedaço desta string ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta string, cancele.
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for o separator pedaço, pare.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto ao first endereço de memória do pedaço deste left subtexto.
  Atribua o last endereço de memória do pedaço deste subtexto menos 1 ao last endereço de memória do pedaço deste left subtexto.
  Atribua o last endereço de memória do pedaço deste subtexto mais 1 ao first endereço de memória do pedaço deste right subtexto.
  Atribua o last endereço de memória do pedaço desta string ao last endereço de memória do pedaço deste right subtexto.

Etapas para que se separe uma string para uns conjunto de textos usando um separator pedaço:
  Destrua o conjunto de textos.
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor usando o separator pedaço.
    Adicione o segmento inicial deste percorredor para o conjunto de textos.
    Se o segmento final deste percorredor estiver em branco, pare.
  Repita. [o código acima]
  Se o conteúdo deste last endereço de memória do pedaço desta string não for o separator pedaço, cancele.
  Adicione "" para o conjunto de textos.

Etapas para que se separe uns coisas para uns left coisas e uns right coisas:
  Se  as coisas estiverem vazio, limpe o left coisas; limpe o right coisas; volte.
  Atribua a contagem destas coisas dividido por 2 a uma contagem.
  Percorra. [o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a contagem for 0, pare.
    Subtraia 1 desde a contagem.
    Repita. [o código acima]
    Separe  as coisas ao left coisas e o right coisas sob o coisa.

Etapas para que se separe uns coisas para uns left coisas e uns right coisas sob um coisa:
  Limpe o left coisas.
  Limpe o right coisas.
  Se a coisa for inexistente, permute  as coisas com o left coisas; volte.
  Se o previous desta coisa for inexistente, permute  as coisas com o left coisas; volte.
  \ abra para cima o left chain
  Atribua o first destas coisas ao first destas left coisas.
  Atribua o previous desta coisa ao last destas left coisas.
  Esvazie o next deste previous desta coisa.
  \ abra para cima o right chain
  Atribua a coisa ao first destas right coisas.
  Esvazie o previous desta coisa.
  Atribua o last destas coisas ao last destas right coisas.
  \ fix o original chain
  Limpe as coisas.

Etapas para que se separe um word para um pedaço e um segundo pedaço:
  Isole o word.
  Desloque o word right 8 bits.
  Atribua o word ao pedaço.
  Atribua o original word ao segundo pedaço.

Uma localização é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y e 
  Uma left sob a coordenada X e 
  Um topo sob a coordenada Y.

Uma localização endereço de memória é um endereço de memória para uma localização.

Etapas para que se square para cima algum tipo de seleção em um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Normalize a seleção deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua 1 ao anchor número de coluna deste text.
  Se o caret número de coluna deste text não for 1, adicione 1 para o número de linhas do cursor deste text; atribua 1 ao caret número de coluna deste text.
  Se o número de linhas do cursor deste text for menor do que ou igual à contagem de linhas deste text, cancele.
  Atribua a contagem de linhas deste text ao número da linha deste caret deste text.
  Atribua a quantidade de caracteres desta string desta row ao número de coluna deste caret deste text.



Etapas para que se start anywhere em uma caixa:
  Escolha aleatoriamente a localização deste context na caixa.

Etapas para que se start anywhere sobre um horizontal linha reta:
  Escolha aleatoriamente uma localização sobre o horizontal linha reta.
  Atribua a localização à localização deste context.

Etapas para que se start sob o base left corner of uma caixa facing east:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face east.

Etapas para que se start sob o base left corner of uma caixa facing north:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face north.

Etapas para que se start sob o base left corner of uma caixa facing south:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face south.

Etapas para que se start sob o base left corner of uma caixa facing west:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face west.

Etapas para que se start sob o base of um horizontal linha reta:
  Atribua o end desta vertical linha reta à localização deste context.

Etapas para que se start sob o base right corner of uma caixa facing east:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face east.

Etapas para que se start sob o base right corner of uma caixa facing north:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face north.

Etapas para que se start sob o base right corner of uma caixa facing south:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face south.

Etapas para que se start sob o base right corner of uma caixa facing west:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face west.

Etapas para que se start sob o left of um horizontal linha reta:
  Atribua o start desta horizontal linha reta à localização deste context.

Etapas para que se start sob o middle of o base of uma caixa;
Etapas para que se start no middle of o base of uma caixa;
Etapas para que se start sob o center of o base of uma caixa;
Etapas para que se start no center of o base of uma caixa:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.

Etapas para que se start sob o middle of o base of uma caixa facing east;
Etapas para que se start no middle of o base of uma caixa facing east;
Etapas para que se start sob o center of o base of uma caixa facing east;
Etapas para que se start no center of o base of uma caixa facing east:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.
  Face east.

Etapas para que se start sob o middle of o base of uma caixa facing north;
Etapas para que se start no middle of o base of uma caixa facing north;
Etapas para que se start sob o center of o base of uma caixa facing north;
Etapas para que se start no center of o base of uma caixa facing north:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.
  Face north.

Etapas para que se start sob o middle of o base of uma caixa facing south;
Etapas para que se start no middle of o base of uma caixa facing south;
Etapas para que se start sob o center of o base of uma caixa facing south;
Etapas para que se start no center of o base of uma caixa facing south:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.
  Face south.

Etapas para que se start sob o middle of o base of uma caixa facing west;
Etapas para que se start no middle of o base of uma caixa facing west;
Etapas para que se start sob o center of o base of uma caixa facing west;
Etapas para que se start no center of o base of uma caixa facing west:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.
  Face west.

Etapas para que se start sob o middle of o left of uma caixa facing east;
Etapas para que se start no middle of o left of uma caixa facing east;
Etapas para que se start sob o center of o left of uma caixa facing east;
Etapas para que se start no center of o left of uma caixa facing east:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face east.

Etapas para que se start sob o middle of o left of uma caixa facing north;
Etapas para que se start no middle of o left of uma caixa facing north;
Etapas para que se start sob o center of o left of uma caixa facing north;
Etapas para que se start no center of o left of uma caixa facing north:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face north.

Etapas para que se start sob o middle of o left of uma caixa facing south;
Etapas para que se start no middle of o left of uma caixa facing south;
Etapas para que se start sob o center of o left of uma caixa facing south;
Etapas para que se start no center of o left of uma caixa facing south:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face south.

Etapas para que se start sob o middle of o left of uma caixa facing west;
Etapas para que se start no middle of o left of uma caixa facing west;
Etapas para que se start sob o center of o left of uma caixa facing west;
Etapas para que se start no center of o left of uma caixa facing west:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face west.

Etapas para que se start sob o middle of o right of uma caixa facing east;
Etapas para que se start no middle of o right of uma caixa facing east;
Etapas para que se start sob o center of o right of uma caixa facing east;
Etapas para que se start no center of o right of uma caixa facing east:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face east.

Etapas para que se start sob o middle of o right of uma caixa facing north;
Etapas para que se start no middle of o right of uma caixa facing north;
Etapas para que se start sob o center of o right of uma caixa facing north;
Etapas para que se start no center of o right of uma caixa facing north:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face north.

Etapas para que se start sob o middle of o right of uma caixa facing south;
Etapas para que se start no middle of o right of uma caixa facing south;
Etapas para que se start sob o center of o right of uma caixa facing south;
Etapas para que se start no center of o right of uma caixa facing south:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face south.

Etapas para que se start sob o middle of o right of uma caixa facing west;
Etapas para que se start no middle of o right of uma caixa facing west;
Etapas para que se start sob o center of o right of uma caixa facing west;
Etapas para que se start no center of o right of uma caixa facing west:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face west.

Etapas para que se start sob o middle of o topo of uma caixa;
Etapas para que se start no middle of o topo of uma caixa;
Etapas para que se start sob o center of o topo of uma caixa;
Etapas para que se start no center of o topo of uma caixa:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.

Etapas para que se start sob o middle of o topo of uma caixa facing east;
Etapas para que se start no middle of o topo of uma caixa facing east;
Etapas para que se start sob o center of o topo of uma caixa facing east;
Etapas para que se start no center of o topo of uma caixa facing east:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.
  Face east.

Etapas para que se start sob o middle of o topo of uma caixa facing north;
Etapas para que se start no middle of o topo of uma caixa facing north;
Etapas para que se start sob o center of o topo of uma caixa facing north;
Etapas para que se start no center of o topo of uma caixa facing north:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.
  Face north.

Etapas para que se start sob o middle of o topo of uma caixa facing south;
Etapas para que se start no middle of o topo of uma caixa facing south;
Etapas para que se start sob o center of o topo of uma caixa facing south;
Etapas para que se start no center of o topo of uma caixa facing south:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.
  Face south.

Etapas para que se start sob o middle of o topo of uma caixa facing west;
Etapas para que se start no middle of o topo of uma caixa facing west;
Etapas para que se start sob o center of o topo of uma caixa facing west;
Etapas para que se start no center of o topo of uma caixa facing west:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.
  Face west.

Etapas para que se start sob o right of um horizontal linha reta:
  Atribua o end desta horizontal linha reta à localização deste context.

Etapas para que se start sob uma localização:
  Atribua a localização à localização deste context.

Etapas para que se start sob uma localização facing east:
  Atribua a localização à localização deste context.
  Face east.

Etapas para que se start sob uma localização facing north:
  Atribua a localização à localização deste context.
  Face north.

Etapas para que se start sob uma localização facing south:
  Atribua a localização à localização deste context.
  Face south.

Etapas para que se start sob uma localização facing west:
  Atribua a localização à localização deste context.
  Face west.

Etapas para que se start sob o topo left corner of uma caixa facing east:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face east.

Etapas para que se start sob o topo left corner of uma caixa facing north:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face north.

Etapas para que se start sob o topo left corner of uma caixa facing south:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face south.

Etapas para que se start sob o topo left corner of uma caixa facing west:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face west.

Etapas para que se start sob o topo of um vertical linha reta:
  Atribua o start desta vertical linha reta à localização deste context.

Etapas para que se start sob o topo right corner of uma caixa facing east:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face east.

Etapas para que se start sob o topo right corner of uma caixa facing north:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face north.

Etapas para que se start sob o topo right corner of uma caixa facing south:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face south.

Etapas para que se start sob o topo right corner of uma caixa facing west:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face west.

Etapas para que se start no middle of uma caixa facing east;
Etapas para que se start sob o middle of uma caixa facing east;
Etapas para que se mova para o middle of uma caixa facing east;
Etapas para que se mova para o middle of uma caixa e face east;
Etapas para que se start no center of uma caixa facing east;
Etapas para que se start sob o center of uma caixa facing east;
Etapas para que se mova para o center of uma caixa facing east;
Etapas para que se mova para o center of uma caixa e face east:
  Atribua o center desta caixa à localização deste context.
  Face east.

Etapas para que se start no middle of uma caixa facing north;
Etapas para que se start sob o middle of uma caixa facing north;
Etapas para que se mova para o middle of uma caixa facing north;
Etapas para que se mova para o middle of uma caixa e face north;
Etapas para que se start no center of uma caixa facing north;
Etapas para que se start sob o center of uma caixa facing north;
Etapas para que se mova para o center of uma caixa facing north;
Etapas para que se mova para o center of uma caixa e face north:
  Atribua o center desta caixa à localização deste context.
  Face north.

Etapas para que se start no middle of uma caixa facing north menos uns points;
Etapas para que se start no center of uma caixa facing north menos uns points:
  Atribua o center desta caixa à localização deste context.
  Face north.
  Vire left o points.

Etapas para que se start no middle of uma caixa facing south;
Etapas para que se start sob o middle of uma caixa facing south;
Etapas para que se mova para o middle of uma caixa facing south;
Etapas para que se mova para o middle of uma caixa e face south;
Etapas para que se start no center of uma caixa facing south;
Etapas para que se start sob o center of uma caixa facing south;
Etapas para que se mova para o center of uma caixa facing south;
Etapas para que se mova para o center of uma caixa e face south:
  Atribua o center desta caixa à localização deste context.
  Face south.

Etapas para que se start no middle of uma caixa facing west;
Etapas para que se start sob o middle of uma caixa facing west;
Etapas para que se mova para o middle of uma caixa facing west;
Etapas para que se mova para o middle of uma caixa e face west;
Etapas para que se start no center of uma caixa facing west;
Etapas para que se start sob o center of uma caixa facing west;
Etapas para que se mova para o center of uma caixa facing west;
Etapas para que se mova para o center of uma caixa e face west:
  Atribua o center desta caixa à localização deste context.
  Face west.

Etapas para que se start um process usando um endereço completo:
  \ must ser chamado com um global variável
  Limpe o erro do fluxo de entrada/saída.
  Se o process não for 0, atribua "Erro. Este processo já está sendo executado." ao erro do fluxo de entrada/saída; volte.
  Atribua a magnitude dessa startupinfo ao cb desta startupinfo.
  Extraia um endereço da pasta desde o endereço completo.
  Termine com o caractere NULL o endereço da pasta.
  Isole o endereço completo. termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateProcessA" com 
    O first deste endereço completo 
    e 0 
    e 0 
    e 0 
    e 0 
    e 67108904 [CREATE_DEFAULT_ERROR_MODE + NORMAL_PRIORITY_CLASS + DETACHED_PROCESS] 
    e 0 
    e O first deste endereço da pasta 
    e O endereçamento desta startupinfo 
    e O endereçamento dessa PROCESS_INFORMATION 
    devolvendo um número.
  Se o número for 0, atribua "Erro. Não foi possível executar o programa." ao erro do fluxo de entrada/saída; volte.
  Atribua o hprocess deste PROCESS_INFORMATION ao process.
  Call "kernel32.dll" "CloseHandle" com 
    O hthread deste PROCESS_INFORMATION.
  Point um endereço de memória para rotina aguarde por um process endereço de memória. \redirecione
  Call "kernel32.dll" "CreateThread" com 0 
    e 0 
    e O endereço de memória 
    e O endereçamento deste process 
    e 0 
    e O endereçamento desse segundo número
    devolvendo um número identificador.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador. \ does not end o thread, just dumps o handle

Etapas para que se start um temporizador:
  Reset o temporizador.
  Restart o temporizador.

Etapas para que se start uns twips above o middle of o base of uma caixa:
  \ incomplete abra of these
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips à coordenada Y desta localização deste context.

Etapas para que se start uns twips para baixo desde uma localização;
Etapas para que se start uns twips below uma localização:
  Atribua a coordenada X desta localização ao x deste context.
  Atribua a coordenada Y desta localização mais os twips ao y deste context.

Etapas para que se start uns twips desde o center of uma caixa:
  Atribua o center desta caixa à localização deste context.
  Mova os twips.

Etapas para que se start uns twips para o left e uns segunda twips para baixo desde uma localização;
Etapas para que se start uns twips left e uns segunda twips para baixo desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.
  Atribua a coordenada Y desta localização mais a segunda twips ao y deste context.

Etapas para que se start uns twips left e uns segunda twips para cima desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.
  Atribua a coordenada Y desta localização menos a segunda twips ao y deste context.

Etapas para que se start uns twips para o left e uns segunda twips para cima desde uma localização;
Etapas para que se start uns twips para o left of uma localização;
Etapas para que se start uns twips left of uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.

Etapas para que se start uns twips para o right e uns segunda twips para baixo desde uma localização;
Etapas para que se start uns twips right e uns segunda twips para baixo desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste context.
  Atribua a coordenada Y desta localização mais a segunda twips ao y deste context.

Etapas para que se start uns twips para o right e uns segunda twips para cima desde uma localização;
Etapas para que se start uns twips right e uns segunda twips para cima desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste context.
  Atribua a coordenada Y desta localização menos a segunda twips ao y deste context.

Etapas para que se start uns twips para cima desde uma coordenada:
  Atribua a coordenada menos os twips ao y deste context.

Etapas para que se start uns twips para cima desde uma localização;
Etapas para que se start uns twips above uma localização:
  Atribua a coordenada Y desta localização ao y deste context.
  Subtraia os twips desde a coordenada Y deste context.

Etapas para que se carregue as bibliotecas padrão do sistema;
Etapas para que se start para cima:
  inicialize o Component Object Model.
  Inicialize winsock.
  Inicialize gdi+.
  Inicialize o talker.
  Inicialize o module.
  Inicialize as cors.
  Inicialize o tela.
  Inicialize a janela do programa.
  Inicialize as fonts.
  Inicialize os cursors.
  Inicialize o mouse.
  Inicialize os canvases.
  Inicialize o context.
  Initalize o terminal.
  Crie o console.

Etapas para que se start para cima o cgi:
  Inicialize winsock.
  Inicialize o module.
  Inicialize o cgi.

Etapas para que se start com uma cor:
  Atribua a cor à cor deste context.

Etapas para que se start com nada em um endereço de memória:
  Esvazie o endereço de memória.

O número identificador do fluxo de entrada padrão é um número identificador.

O número identificador do fluxo de saída padrão é um número identificador.

Etapas para que se suspenda um process:
  Se o process for 0, cancele.
  Call "kernel32.dll" "TerminateProcess" com 
    O process 
    e 0.
  Atribua 0 ao process.

Etapas para que se suspenda um temporizador:
  Se a contagem deste temporizador for 0, cancele.
  Subtraia 1 desde a contagem deste temporizador.
  Se a contagem deste temporizador não for 0, cancele.
  Atribua a contagem de intervalos do sistema a uns intervalos.
  Subtraia os intervalos iniciais deste temporizador desde o intervalos.
  Adicione o intervalos para os intervalos totais deste temporizador.

Uma string é um conjunto com 
  Um first endereço de memória do pedaço e 
  Um last endereço de memória do pedaço.



Etapas para que se pinte uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face north.
  Pinte a altura desta caixa.
  Vire right.
  Pinte a largura desta caixa.
  Vire right.
  Pinte a altura desta caixa.
  Vire right.
  Pinte a largura desta caixa.

Um subject é uma string.

Etapas para que se take off all o masking tape:
  Exponha tudo.

Etapas para que se take off algum tipo de masking tape:
  Exponha tudo.

Um talker é um endereço de memória para um talker object.

O talker é um talker.

Um talker object é um conjunto com um talker vtable denominado vtable.

Um talker vtable é um endereço de memória para um talker vtable conjunto.

O temp endereço completo é um endereço completo.

O terminal é um terminal.

Um terminal é uma coisa com 
  Uma caixa, 
  Uns quoras, 
  Uma output cor, 
  Uma input cor, e 
  Uma reply string.

O text cutoff é um número igual a 500.





Um temporizador é um conjunto com 
  Uma contagem, 
  Uns intervalos iniciais e 
  Uns intervalos totais.

Some times é um número. \ this é um fluke, I think -- see "suavize um polígono uns times"

Um topo é uns twips.

Etapas para que se trim uma string:
  Remove algum tipo de leading noise desde a string.
  Remove algum tipo de trailing noise desde a string.

Etapas para que se dê meia volta:
  Vire right 1/2.

Etapas para que se vire uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire a fração.

\Etapas para que se vire uma fração do caminho;
Etapas para que se vire uma fração of o caminho;
Etapas para que se vire uma fração of o caminho around;
Etapas para que se vire uma fração:
  Se a fração for 1/1, cancele.
  Atribua 3840 times a fração mais a orientação deste context à orientação deste context.
  Normalize a orientação deste context.

Etapas para que se vire pra left;
Etapas para que se vire para a left;
\Etapas para que se vire à left;
Etapas para que se vire left:
  Vire -1/4.

\Etapas para que se vire à left uma fração igual para um número over um segundo número;
Etapas para que se vire pra left uma fração igual para um número over um segundo número;
Etapas para que se vire para a left uma fração igual para um número over um segundo número;
Etapas para que se vire left uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire left a fração.

\Etapas para que se vire uma fração à left do caminho;
\Etapas para que se vire uma fração pra left do caminho;
Etapas para que se vire uma fração para a left do caminho;
Etapas para que se vire left uma fração of o caminho;
Etapas para que se vire left uma fração of o caminho around;
Etapas para que se vire left um fração:
  Isole a fração.
  Negate a fração.
  Vire a fração.

\Etapas para que se vire à left uns points;
Etapas para que se vire pra left uns points;
Etapas para que se vire para a left uns points;
Etapas para que se vire left uns points:
  Atribua o points e 3840 a um fração.
  Vire left a fração.

\Etapas para que se vire à right;
Etapas para que se vire pra right;
Etapas para que se vire para a right;
Etapas para que se vire right:
  Vire 1/4.

\Etapas para que se vire uns degrees à right;
\Etapas para que se vire uns degrees pra right;
Etapas para que se vire uns degrees para a right;
Etapas para que se vire right uns degrees:
  Atribua o degrees times 10 e 3600 a um fração.
  Vire right a fração.

Etapas para que se vire uns degrees:
  Atribua o degrees times 10 e 3600 a um fração.
  \Se o degrees forem negative, vire left o fração; volte.
  Vire right a fração.

\Etapas para que se vire à right uma fração igual para um número over um segundo número;
Etapas para que se vire pra right uma fração igual para um número over um segundo número;
Etapas para que se vire para a right uma fração igual para um número over um segundo número;
Etapas para que se vire right uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire right a fração.

\Etapas para que se vire à right uma fração of o caminho;
Etapas para que se vire pra right uma fração of o caminho;
Etapas para que se vire para a right uma fração of o caminho;
Etapas para que se vire right uma fração of o caminho;
Etapas para que se vire right uma fração of o caminho around;
Etapas para que se vire right um fração:
  Vire a fração.

Etapas para que se vire right uma fração of o caminho uns percentual of o time;
Etapas para que se vire right uma fração about uns percentual of o time;
Etapas para que se vire right uma fração of o caminho about uns percentual of o time;
Etapas para que se vire right uma fração uns percentual of o time:
  Escolha aleatoriamente um número entre 1 e 100.
  Se o número for maior do que o percentual, cancele.
  Vire right a fração.

\Etapas para que se vire uns points à right;
\Etapas para que se vire uns points pra right;
Etapas para que se vire uns points para a right;
Etapas para que se vire right uns points:
  Atribua o points e 3840 a um fração.
  Vire right a fração.

Etapas para que se unlock um gpBitmap usando um BitmapData:
  Call "gdiplus.dll" "GdipBitmapUnlockBits" com 
    O gpBitmap e 
  o endereçamento deste BitmapData.

Etapas para que se exponha tudo:
  Call "gdi32.dll" "SelectClipRgn" com 
    O quadro atual 
    e 0.

Etapas para que se exponha conteúdo de uma caixa:
  Crie um hRgn usando a caixa.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de uma elipse:
  Crie um hRgn usando a elipse.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual e 
  o hRgn e 2 [RGN_OR].

Etapas para que se exponha conteúdo de um polígono:
  Crie um hRgn usando o polígono.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma caixa:
  Crie um hRgn usando a caixa.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma elipse:
  Crie um hRgn usando a elipse.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de um hRgn:
  Crie um old hRgn usando o zero caixa.
  Call "gdi32.dll" "GetClipRgn" com 
    O quadro atual e 
  o old hRgn 
    devolvendo um número.
  Se o número não for 1, limpe o old hRgn.
  Call "gdi32.dll" "SelectClipRgn" com 
    O quadro atual 
    e 0.
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hRgn 
    e 4 [RGN_DIFF].
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O old hRgn 
    e 2 [RGN_OR].
  Destrua o old hRgn.

Etapas para que se exponha exterior de um polígono:
  Crie um hRgn usando o polígono.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se renove a tela;
Etapas para que se mostre;
Etapas para que se mostre tudo;
Etapas para que se mostre exponha o canvas;
Etapas para que se atualize a tela:
  Atualize a tela usando a caixa desta tela.

Um número de porta é um número.
Um nome de protocolo é uma string.
Um nome de host é uma string.
Um parâmetro de consulta é uma string.
Um endereço de recurso é uma string.

Uma URL simplificada é um conjunto com
  Um nome do protocolo,\lpszScheme? dwFlags? -> exemplo: http / ftp / https / etc
  Um nome de host, \lpszHostName ?  -> exemplo: www.google.com ou mail.stackoverflow.com
  Um endereço de recurso, \lpszUrlPath? -> exemplo: index.html ou /css/style.css ou questions/SubmitQuestion.aspx
  Um parâmetro de consulta, \lpszExtraInfo? -> exemplo: ?useLiveData=1&internal=0
  Um número de porta. \ nPort? -. números de porta ocupam (geralmente) 16 bits

Um vértice array é um endereço de memória para um vértice array conjunto.

Um vértice array conjunto é um conjunto com 
  Uma contagem e 
  Uma localização endereço de memória.

Um vértice é uma coisa com 
  Uma coordenada X, 
  Uma coordenada Y, 
  Uma localização sob a coordenada X.

Etapas para que se aguarde por um event;
Etapas para que se desenfileire um event:
  Yield para windows.
  Atribua o first desta fila de eventos ao event.
  Se o event for inexistente, repita.
  Remove o event desde a fila de eventos.
  Se a categoria deste event for "fechamento do programa", destrua o event; volte.
  Destrua o evento atual.
  Atribua o event ao evento atual.

Etapas para que se aguarde uns milliseconds;
Etapas para que se espere uns milliseconds;
Etapas para que se aguarde por uns milliseconds:
  Se o milliseconds forem menor do que ou igual para 0, cancele.
  Call "kernel32.dll" "Sleep" com os milliseconds. \ https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep

Etapas para que se aguarde até finalizar a narração;
Etapas para que se aguarde até que a narração esteja finalizada;
Etapas para que se aguarde até finalizarmos narração;
Etapas para que se aguarde até que narração esteja concluída:
  Se o talker for inexistente, cancele.
  Call o WaitUntilDone  desta vtable [SpVoice] deste talker com o talker e -1.

Etapas para que se aguarde até que pressionemos uma tecla;
Etapas para que se aguarde até pressionarmos uma tecla;
Etapas para que se aguarde por uma tecla;
Etapas para que se aguarde o pressionamento de uma tecla;
Etapas para que se aguarde pelo pressionamento de uma tecla;
Etapas para que se aguarde uma tecla ser pressionada;
Etapas para que se aguarde uma tecla:
  Aguarde pela tecla para go para baixo.
  Aguarde pela tecla para come para cima.
  Desmanche all events.

Um wave file é um endereço completo.

Um wave é um texto hexadecimal.

Uma largura é uns twips.

Etapas para que se wrap um text:
  Se o text for inexistente, cancele.
  Se o wrap detector deste text não estiver ativo, cancele.
  Converta o anchor deste text para um posicionamento absoluto usando o text.
  Converta o caret deste text para uma segunda posicionamento absoluto usando o text.
  Atribua a scale deste text a um fração.
  Redimensione proporcionalmente o text para 1/1.
  Extraia uma string desde o text.
  Posponha o retorno de carro para a string.
  Destrua as rows deste text.
  Lance um percorredor sobre a string.
  Crie o número da fonte of o memory canvas usando a font deste text.
  Percorra. [o código abaixo]
    Mova o percorredor usando a caixa deste text (word wrapping rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma row usando o segmento inicial deste percorredor.
    Posponha a row para as rows deste text.
  Repita. [o código acima]
  Destrua o número da fonte of o memory canvas.
  Renumere as rows deste text.
  Redimensione proporcionalmente o text para a fração.
  Converta o posicionamento absoluto para o anchor deste text usando o text.
  Converta a segunda posicionamento absoluto para o caret deste text usando o text.
  Limite a origem of o text.

Etapas para que se salve um trecho em um file;
Etapas para que se armazene um trecho em um file;
Etapas para que se grave um trecho em um file;
Etapas para que se escreva um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" com 
    O file 
    e 0 
    e 0 
    e 0 [FILE_BEGIN] 
    devolvendo um número resultante.
  Se o número resultante for -1, atribua "Ocorreu um erro durante o posicionamento do ponteiro do arquivo." ao erro do fluxo de entrada/saída; volte.
  Call "kernel32.dll" "WriteFile" com 
    O file e 
  o first endereço de memória do pedaço deste trecho 
    e A quantidade de caracteres deste trecho 
    e O endereçamento desse número 
    e 0 
    devolvendo o número resultante.
  Se o número resultante for 0, atribua "Ocorreu um erro durante a gravação do arquivo." ao erro do fluxo de entrada/saída; volte.

Etapas para que se salve um trecho em um endereço completo;
Etapas para que se armazene um trecho em um endereço completo;
Etapas para que se grave um trecho em um endereço completo;
Etapas para que se escreva um trecho para um endereço completo:
  Limpe o erro do fluxo de entrada/saída.
  Extraia um endereço da pasta desde o endereço completo.
  Se o endereço da pasta não estiver no sistema de arquivos, atribua "A pasta: " junto com o endereço da pasta seguido de " não existe." ao erro do fluxo de entrada/saída; volte.
  Defina o endereço completo para read-write mode.
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com 
    O first deste endereço completo 
    e 1073741824 [GENERIC_WRITE] 
  And 0 e 0 e 2 [CREATE_ALWAYS] 
    e -2147483520 [FILE_FLAG_WRITE_THROUGH ou FILE_ATTRIBUTE_NORMAL] 
    e 0 
    devolvendo um número identificador.
  Se o número identificador for -1 [INVALID_HANDLE_VALUE], atribua "Ocorreu um erro ao tentar abrir o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; volte.
  Call "kernel32.dll" "WriteFile" com 
    O número identificador 
    e O first endereço de memória do pedaço deste trecho 
    e A quantidade de caracteres deste trecho 
    e O endereçamento desse número 
    e 0 
    devolvendo o número.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro ao tentar salvar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se escreva um pedaço:
  Atribua o pedaço a uma string.
  Escreva a string.

Etapas para que se escreva um pedaço para StdOut:
  Call "kernel32.dll" "WriteFile" com \https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile
    O stdout handle [hFile] \Um identificador para o arquivo ou dispositivo de E / S
  \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    e O endereçamento deste pedaço [lpBuffer] \Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    e 1 [nNumberOfBytesToWrite] \ representa o nº de bytes a serem gravados no arquivo ou dispositivo.
    e O endereçamento desse número [lpNumberOfBytesWritten]  \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono . 
    e nil. [lpOverlapped] \ serve pra especificar se deseja gravar em outra região, por exemplo o final do arquivo. 

Etapas para que se escreva um pedaço sem passar pra próxima linha:
  Atribua o pedaço a uma string.
  Escreva a string sem passar pra próxima linha.

     \ will translate para English because "Converta um detector" é used para externalize reams pelo caderno
Etapas para que se escreva um detector:
  Converta o detector para uma string.
  Escreva a string.

Etapas para que se escreva um detector sem passar pra próxima linha:
  Converta o detector para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um fração:
  Converta a fração para uma string.
  Escreva a string.

Etapas para que se escreva uma fração sem passar pra próxima linha:
  Converta a fração para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um número:
  Converta o número para uma string.
  Escreva a string.

Etapas para que se escreva um número sem passar pra próxima linha:
  Converta o número para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um número sobre um console:
  Converta o número para uma string.
  Escreva a string sobre o console.

Etapas para que se escreva uns quoras em uma caixa: \descomentar pra ver o que acontece
  \Pinte a caixa com a cor vermelha e a cor preta. \ temp ***
  Atribua a caixa a uma quora caixa.
  Atribua a coordenada Y do canto superior esquerdo desta quora caixa mais 24 pixels à coordenada Y do canto inferior direito desta quora caixa.
  Percorra. [o código abaixo]
    Obtenha um quora desde o quoras.
    Se o quora for inexistente, pare.
  \pinte really fast. ***
    Pinte o quora caixa com a cor amarela. \ temp ***
    Escreva a string deste quora no quora caixa com a cor deste quora.
    Mova o quora caixa para baixo 24 px.
  Repita. [o código acima]

Etapas para que se yield para windows:
  Se a fila de eventos não estiver vazio, cancele.
  Call "user32.dll" "GetMessageA" com 
    O endereçamento dessa msg 
    e 0 
    e 0 
    e 0 
    devolvendo um número.
  Se o número for 0, cancele.
  Call "user32.dll" "TranslateMessage" com 
    O endereçamento desta msg.
  Call "user32.dll" "DispatchMessageA" com 
    O endereçamento desta msg.

Etapas para que se zero uma caixa:
    \ was clear uma caixa, got confounded com "clear uma caixa " (which deveria pinte a caixa all black como does "clear o tela")
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada X do canto inferior direito desta caixa.
  Atribua 0 à coordenada Y do canto inferior direito desta caixa.

O zero caixa é uma caixa.

Etapas para que se zero fill um número usando uma contagem e posponha it para uma string:
  Converta o número para uma segunda string.
  Zero fill a segunda string usando a contagem.
  Posponha a segunda string para a string.

O zero linha reta é um linha reta. \ tracer

O zero localização é uma localização.

O erro do fluxo de entrada/saída é uma string.

