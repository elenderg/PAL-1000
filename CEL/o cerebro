\ O Cérebro - A Sociedade Osmosiana de Programadores de Linguagens Naturais - desde 2006.

\ Regras:
\ No geral, cada linha deve terminar com um ponto final.
\ As exceções são quando você está declarando uma variável do tipo conjunto, 
\ (cujas linhas podem terminar com uma vírgula, exceto no último item do conjunto)
\ Ou quando você estiver declarando um cabeçalho de rotina (que termina com sinal de dois pontos)
\ Quando um campo de texto é convertido para texto puro, 
\ o caractere especial LF é adicionado depois do caractere especial CR
\ Já quando um texto é transformado em um campo de texto, o caractere LF é removido.
\ Existe sempre uma linha, no mínimo.
\ Existe sempre um caractere CR no fim da ultima linha.

Um percorredor é um conjunto com \ conserte "avance um percorredor" e "recue um percorredor" se você alterar isso aqui
  Um subtexto original,
  Um segmento final, 
  Um segmento inicial.

Um segmento inicial é um subtexto.
Um segmento final é um subtexto.

Etapas necessárias para que se avance um percorredor até encontrar o próximo espaço;
Etapas necessárias para que se avance um percorredor até o próximo espaço:
  Avance o percorredor.
  Se o conteúdo deste last endereço de memória do pedaço deste segmento inicial deste percorredor não for o caractere de espaço, repita.
    \Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for o caractere de espaço, repita.

Etapas necessárias para que se recue um percorredor até o próximo espaço;
Etapas necessárias para que se recue um percorredor até encontrar o próximo espaço:
  Recue o percorredor.
  Recue o percorredor.
  Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for o caractere de espaço, repita.
    \Se o conteúdo deste last endereço de memória do pedaço deste segmento inicial deste percorredor não for o caractere de espaço, repita.

Etapas necessárias para que se recue um percorredor por um número:
  Subtraia o número desde o first endereço de memória do pedaço deste segmento inicial deste percorredor.
  Subtraia o número desde o last endereço de memória do pedaço deste segmento final deste percorredor.

A contagem total é um número igual a 0.

O detector de ignição é um detector igual a 1.

O sinal de desligamento é um detector igual a 0.

Um posicionamento absoluto é um número.

Etapas necessárias para que se adicione um pedaço para um segundo pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte 67 8B 45 08
  Intel $0FB600. \ movzx eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo byte 67 8B 5D 0C
  Intel $0003. \ add [ebx],al

Etapas necessárias para que se adicione um pedaço para um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $0FB600. \ movzx eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
  Intel $0103. \ adicione [ebx],eax

Etapas necessárias para que se adicione uma fração para uma segunda fração:
  Isole a fração.
  Normalize a fração e a segunda fração.
  Adicione o numerador desta fração para o numerador desta segunda fração.
  Reduce a segunda fração.

Etapas necessárias para que se adicione uns horizontal twips e uns vertical twips para o current localização:
  Adicione o horizontal twips para a coordenada X desta localização deste context.
  Adicione o vertical twips para a coordenada Y desta localização deste context.

Etapas necessárias para que se adicione uma line para uma figura:
  Se a figura for inexistente, crie a figura; posponha a figura para as figuras.
  Adicione o start desta line para a figura.
  Adicione o end desta line para a figura.

Etapas necessárias para que se adicione um nome para uns choices:
  Aloque memória por uma choice.
  Atribua o nome ao nome desta choice.
  Atribua a choice at o end of as choices.

Etapas necessárias para que se adicione um número e um segundo número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o segundo número para o número Y deste par de números.

Etapas necessárias para que se adicione um número para um segundo número e um terceiro número para um quarto número:
  Adicione o número para o segundo número.
  Adicione o terceiro número para o quarto número.

Etapas necessárias para que se adicione um número para um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
  Intel $0FB60B. \ movzx ecx,[ebx]
  Intel $03C8. \ adicione ecx,eax
  Intel $880B. \ mov [ebx],cl

Etapas necessárias para que se adicione um número para um fração:
  Adicione o número / 1 para a fração.

Etapas necessárias para que se adicione um número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o número para o número Y deste par de números.

Etapas necessárias para que se adicione um número para um endereço de memória;
Etapas necessárias para que se adicione um número para um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo número
  Intel $0103. \ adicione [ebx],eax

Etapas necessárias para que se adicione um par de números para uma segunda par de números:
  Adicione o número X deste par de números para o número X desta segunda par de números.
  Adicione o número Y deste par de números para o número Y desta segunda par de números.

Etapas necessárias para que se adicione um quora para um terminal:
  Crie o quora.
  Posponha o quora para o quora deste terminal.
  Se o terminal não estiver full, cancele.
  Atribua o first destes quoras deste terminal a um doomed quora.
  Remove o doomed quora desde os quoras deste terminal.
  Destrua o doomed quora.

Etapas necessárias para que se adicione uma localização para um figura:
  Posponha a localização para a figura.

Etapas necessárias para que se adicione uma string para uns conjunto de textos:
  Crie um conjunto de texto usando a string.
  Posponha o conjunto de texto para o conjunto de textos.

Etapas necessárias para que se ajuste uma caixa usando um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para a coordenada esquerda desta caixa.
  Adicione o segundo número para a coordenada superior desta caixa.
  Adicione o terceiro número para a coordenada direita desta caixa.
  Adicione o quarto número para a coordenada inferior desta caixa.

Etapas necessárias para que se ajuste um item:
  Atribua os dwFileAttributes deste WIN32FINDDATA deste item a um número.
  Conjuncione logicamente o número com 16 [FILE_ATTRIBUTE_DIRECTORY].
  Se o número for 0, atribua "arquivo" à categoria deste item. \; atribua "arquivo" à classe deste item.
  Se o número não for 0, atribua "endereço de pasta" à categoria deste item.\; atribua "directorio" à classe deste item.
  Converta o ftCreationTime deste WIN32FINDDATA deste item para a creation date/time string deste item . \ adicionado para classificação de e-mails.
  Atribua o endereçamento deste cFileName deste WIN32FINDDATA deste item a um pchar.
  Converta o pchar para o designador deste item.
  Se a categoria deste item for "endereço de pasta", posponha "\" para o designador deste item.
  Atribua o endereço da pasta deste item junto com o designador deste item ao endereço completo deste item.
  Extraia a extensão deste item desde o designador deste item como um endereço completo.
  Atribua o nFileSizeLow deste WIN32FINDDATA deste item ao size deste item.
  Se o conteúdo deste first deste designador deste item não for o ponto final, cancele.
  Obtenha o item (not first time).

Etapas necessárias para que se ajuste um line com um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para o x deste start desta line.
  Adicione o segundo número para o y deste start desta line.
  Adicione o terceiro número para o x deste end desta line.
  Adicione o quarto número para o y deste end desta line.

Etapas necessárias para que se ajuste um imagem (extract caixas desde gpbitmap):
  Se o imagem for inexistente, cancele.
  Atribua 0 à coordenada esquerda desta caixa desta imagem.
  Atribua 0 à coordenada superior desta caixa desta imagem.
  Atribua a largura deste gpbitmap desta imagem menos 1 times o tpp à coordenada direita desta caixa desta imagem.
  Atribua a altura deste gpbitmap desta imagem menos 1 times o tpp à coordenada inferior desta caixa desta imagem.
  Atribua a caixa desta imagem à caixa intacta desta imagem.

Etapas necessárias para que se ajuste spacing usando uma string:
  Se o quadro atual não for o printer canvas, cancele.
  Call "gdi32.dll" "SetTextCharacterExtra" com 
    O printer canvas \ Um identificador para o contexto do dispositivo.
    e 0.    \ A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
    \Se o modo de mapeamento atual não for MM_TEXT, o parâmetro nCharExtra será transformado e arredondado para o pixel mais próximo.
    \quero traduzir esse comando como: Mande o printer canvas e o código 0 para a função "SetTextCharacterExtra" da biblioteca "gdi32.dll".
  Call "gdi32.dll" "GetCurrentObject" com 
    O printer canvas \ Um identificador para o contexto do dispositivo.
    e 6 [obj_font]    \ O tipo de objeto a ser consultado. Este parâmetro pode ser vários valores.
    \ OBJ_FONT -> Retorna a fonte selecionada no momento.
    devolvendo um número identificador. \ Se a função for bem-sucedida, o valor de retorno é um identificador para o objeto especificado. Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas \ Um identificador para o contexto do dispositivo.
    e O número identificador. \ Um identificador para o objeto a ser selecionado. Nesse caso é o número do comando anterior, retornado pelo GetCurrentObject acima
  Obtenha um largura usando a string e o memory canvas.
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O null número da fonte.
  Obtenha uma segunda largura usando a string e o printer canvas.
  Atribua o largura menos a segunda largura dividido pelo quantidade de caracteres desta string a um número.
  Call "gdi32.dll" "SetTextCharacterExtra" com 
    O printer canvas e 
    O número.

Etapas necessárias para que se align um text usando um alinhamento:
  Atribua o alinhamento ao alinhamento deste text.

Um alinhamento é uma string [center, left, ou right].

Um quantia é um número.

Um anchor é um position.

Um máscara de conjunção lógica é uma mask.

Um ângulo é uns precise degrees [0 para 3599].

Etapas necessárias para que se posponha um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" \Esta função armazena o ponteiro do arquivo em dois valores LONG.
  com o file \ Um identificador para o arquivo.
    \O identificador de arquivo deve ser criado com o direito de acesso GENERIC_READ ou GENERIC_WRITE. 
    \Para obter mais informações sobre direitos de acesso, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-security-and-access-rights
    e 0 [lDistanceToMove]
    \Os 32 bits de ordem inferior de um valor com sinal que especifica o número de bytes para mover o ponteiro do arquivo.
    \Se lpDistanceToMoveHigh não for NULL, lpDistanceToMoveHigh e lDistanceToMove formam um único valor de 64 bits com sinal que especifica a distância a ser movida.
    \Se lpDistanceToMoveHigh for NULL, lDistanceToMove será um valor de 32 bits com sinal. 
    \Um valor positivo para lDistanceToMove move o ponteiro do arquivo para frente no arquivo e um valor negativo move o ponteiro para trás no arquivo .
    e 0 [lpDistanceToMoveHigh]
    \ Um ponteiro para os 32 bits de ordem superior da distância de 64 bits com sinal a ser movida.
    \Se você não precisa de 32 bits de alta ordem, este ponteiro deve ser definido como NULL.
    \ Quando não é NULL, esse parâmetro também recebe o DWORD de ordem superior do novo valor do ponteiro do arquivo.
    \ Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer
    e 2 [file_end] [dwMoveMethod]
    \ O ponto de partida para o movimento do ponteiro do arquivo.
    \ Este parâmetro pode ser um dos seguintes valores.
    \0 = FILE_BEGIN ->  O ponto de partida é zero ou o início do arquivo.
    \ 1 = FILE_CURRENT -> O ponto de partida é o valor atual do ponteiro do arquivo.
    \ 2 = FILE_END -> O ponto de partida é a posição atual de fim de arquivo.
    devolvendo um result número.
    \Se a função for bem-sucedida e lpDistanceToMoveHigh for NULL, o valor de retorno será o DWORD de ordem inferior do novo ponteiro de arquivo. 
    \Obs: Se a função retornar um valor diferente de INVALID_SET_FILE_POINTER, a chamada para SetFilePointer foi bem-sucedida.
  Se o result número for -1, atribua "Ocorreu um erro na hora de posicionar o ponteiro do arquivo." ao erro do fluxo de entrada/saída; exit.
    \ Se um novo ponteiro de arquivo for um valor negativo, a função falhará, o ponteiro de arquivo não será movido e o código retornado por GetLastError será ERROR_NEGATIVE_SEEK.
  Call "kernel32.dll" "WriteFile" com \ Grava dados no arquivo ou dispositivo de entrada / saída (E / S) especificado.
    \ Esta função foi projetada para operação síncrona e assíncrona.
    O file [hFile]
    \ Um identificador para o arquivo ou dispositivo de E / S 
    \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    \ O parâmetro hFile deve ter sido criado com o acesso de gravação. 
    \Para obter mais informações, consulte os sites
    \ https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/generic-access-rights
    \ https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-security-and-access-rights
    \ Para operações de gravação assíncrona, hFile pode ser qualquer identificador aberto com a função CreateFile usando o sinalizador FILE_FLAG_OVERLAPPED 
    \ou um identificador de soquete retornado pelo soquete ou função de aceitação.
    e O first deste trecho [lpBuffer]
    \ Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    \ Este buffer deve permanecer válido durante a operação de gravação. 
    \ O chamador não deve usar esse buffer até que a operação de gravação seja concluída.
    e A quantidade de caracteres deste trecho [nNumberOfBytesToWrite]
    \ O número de bytes a serem gravados no arquivo ou dispositivo.
    \ Um valor zero especifica uma operação de gravação nula. 
    \O comportamento de uma operação de gravação nula depende do sistema de arquivos subjacente ou da tecnologia de comunicação.
    e um endereçamento desse número [lpNumberOfBytesWritten]
    \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono. 
    \ WriteFile define esse valor como zero antes de fazer qualquer trabalho ou verificação de erro.
    \ Use NULL para este parâmetro se esta for uma operação assíncrona para evitar resultados potencialmente errôneos.
    \Este parâmetro pode ser NULL somente quando o parâmetro lpOverlapped não for NULL.
    e 0 [lpOverlapped]
    \Um ponteiro para uma estrutura OVERLAPPED é necessário se o parâmetro hFile foi aberto com FILE_FLAG_OVERLAPPED, caso contrário, este parâmetro pode ser NULL.
    \ Para um hFile que oferece suporte a deslocamentos de byte, se você usar este parâmetro, deverá especificar um deslocamento de byte no qual iniciar a gravação no arquivo ou dispositivo. 
    \Esse deslocamento é especificado definindo os membros Offset e OffsetHigh da estrutura OVERLAPPED. 
    \Para um hFile que não oferece suporte a deslocamentos de byte, Offset e OffsetHigh são ignorados.
    \Para gravar no final do arquivo, especifique os membros Offset e OffsetHigh da estrutura OVERLAPPED como 0xFFFFFFFF. 
    \Isso é funcionalmente equivalente a chamar anteriormente a função CreateFile para abrir hFile usando o acesso FILE_APPEND_DATA.
    \ Para obter mais informações sobre diferentes combinações de lpOverlapped e FILE_FLAG_OVERLAPPED, consulte:
    \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
    \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#synchronization-and-file-position
    devolvendo o result número.
    \ Se a função for bem-sucedida, o valor de retorno será diferente de zero (VERDADEIRO).
    \ Se a função falhar ou estiver sendo concluída de forma assíncrona, o valor de retorno será zero (FALSO). 
    \Para obter informações de erro estendidas, chame a função GetLastError.
    \ Nota: O código GetLastError ERROR_IO_PENDING não é uma falha; indica que a operação de gravação está com conclusão pendente de forma assíncrona. 
    \ Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
  Se o result número for 0, atribua "Ocorreu um erro na hora de salvar o arquivo." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se posponha um pedaço para uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres desta string mais 1.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres armazenados ao last endereço de memória do pedaço desta string.
  Atribua o pedaço para o conteúdo deste last endereço de memória do pedaço desta string.

Etapas necessárias para que se posponha um pedaço para uma string usando uma contagem:
  Isole a contagem.
  Percorra. [o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha o pedaço para a string.
    Subtraia 1 desde a contagem.
  Repita. [o código acima]

Etapas necessárias para que se posponha um detector para uma string:
  Converta o detector para uma segunda string.
  Posponha a segunda string para a string.

Etapas necessárias para que se posponha uma fração para uma string:
  Converta a fração para uma segunda string.
  Posponha a segunda string para a string.

Etapas necessárias para que se posponha um número para uma string:
  Converta o número para uma segunda string.
  Posponha a segunda string para a string.

Etapas necessárias para que se posponha um endereço de memória para uma string:
  Converta o endereço de memória para uma segunda string.
  Posponha a segunda string para a string.

Etapas necessárias para que se posponha uma localização para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a localização.
  Posponha o vértice para os vértices deste polígono.

Etapas necessárias para que se posponha uma string para uma segunda string:
  Se a string estiver em branco, cancele.
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Atribua a quantidade de caracteres desta segunda string a uma quantidade de caracteres armazenados.
  Adicione a quantidade de caracteres armazenados para a quantidade de caracteres agrupados.
  Reassign o first endereço de memória do pedaço desta segunda string usando a quantidade de caracteres agrupados.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres armazenados a um endereço de memória.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o endereço de memória pelo quantidade de caracteres desta string.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres agrupados menos 1 ao last endereço de memória do pedaço desta segunda string.

Etapas necessárias para que se posponha uma string para uma segunda string (handling email transparency):
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor (text file rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor começa com ".", posponha "." para a segunda string.
    Posponha o segmento inicial deste percorredor para a segunda string.
  Repita. [o código acima]

Etapas necessárias para que se posponha uma string para uma segunda string usando uma contagem:
  Isole a contagem.
  Percorra. [o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha a string para a segunda string.
    Subtraia 1 desde a contagem.
  Repita. [o código acima]

Etapas necessárias para que se posponha uns coisas para uns segunda coisas:
  Atribua o first destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Posponha a coisa para a segunda coisas.
  Repita. [o código acima]

Etapas necessárias para que se posponha um temporizador para uma string:
  Converta o temporizador para uma segunda string.
  Posponha a segunda string para a string.

Etapas necessárias para que se posponha um vértice para um polígono:
  Se o polígono for inexistente, cancele.
  Posponha o vértice para os vértices deste polígono.

Etapas necessárias para que se posponha uma coordenada X e uma coordenada Y para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a coordenada X e a coordenada Y.
  Posponha o vértice para os vértices deste polígono.

Etapas necessárias para que se posponha zeros para uma string until its quantidade de caracteres é um número:
  Se a quantidade de caracteres desta string for maior do que ou igual ao número, cancele.
  Posponha "0" para a string.
  Repita. [o código acima]

A seta do mouse é um cursor.

Etapas necessárias para que se assign um endereço de memória usando um quantidade de pedaços:
  Se o quantidade de pedaços for 0, esvazie o endereço de memória; exit.
  Isole o quantidade de pedaços.
  Arredonde o quantidade de pedaços para cima para o nearest power of two.
  Call "kernel32.dll" "HeapAlloc" com 
    O endereço heap 
    e 8 [HEAP_ZERO_MEMORY] 
    e A quantidade de pedaços 
    devolvendo o endereço de memória.
  Se o endereço de memória não for inexistente, adicione 1 para a contagem do heap; exit.

Etapas necessárias para que se role automaticamente um text usando uma localização e um detector:
  Se o text for inexistente, desative o detector; exit.
  Atribua a altura desta font deste text a um número.
  Limpe um difference.
  Atribua a caixa deste text a uma caixa.
  Indent a caixa usando o tpp.
  Se a coordenada Y desta localização for menor do que a coordenada superior desta caixa, atribua o número ao número Y desta difference.
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, atribua o número ao número Y desta difference; negate o número Y desta difference.
  Se a coordenada X desta localização for menor do que a coordenada esquerda desta caixa, atribua o número ao número X desta difference.
  Se a coordenada X desta localização for maior do que a coordenada direita desta caixa, atribua o número ao número X desta difference; negate o número X desta difference.
  Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número X desta difference.
  Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, desative o detector; exit.
  Ligue o detector.
  Role o text usando a difference.
  Aguarde por 50 milliseconds.

Um baseline é um número.

Etapas necessárias para que se beep:
  Call "user32.dll" "MessageBeep" com 
  0.

Etapas necessárias para que se begin um landscape sheet:
  Make o landscape sheet 1056 pixels por 816 pixels.
  Begin um sheet com o landscape sheet.

Etapas necessárias para que se begin um portrait sheet:
  Make o portrait sheet 816 pixels por 1056 pixels.
  Begin um sheet com o portrait sheet.

Etapas necessárias para que se begin printing:
  Inicialize o printer canvas.
  Atribua a magnitude desse docinfo ao cbsize deste docinfo.
  Atribua o first deste nome deste module ao lpszdocname deste docinfo.
  Call "gdi32.dll" "StartDocA" com 
    O printer canvas 
    e O endereçamento deste docinfo.

Etapas necessárias para que se begin um sheet:
  Begin o sheet como um portrait sheet.

Etapas necessárias para que se begin um sheet usando um title string:
  Begin um portrait sheet usando o title.

O Bíblia é uma coisa com uns verses.

Um verse é uma coisa com uma string.

Um big-endian unsigned word é um conjunto com 2 pedaços.

    \Um billion é 1000 millions.

Um código binário é uma string.

An bit é uma unidade.

\Um bitmapdata é um conjunto com
\Um largura,
\Um altura,
\Um número denominado stride,
\Um número denominado pixelformat,
\Um endereço de memória denominado scan0,
\Um número denominado Reserved.

Etapas necessárias para que se conjuncione logicamente um pedaço com um segundo pedaço:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $2003. \ e [ebx],al

Etapas necessárias para que se conjuncione logicamente um pedaço com um número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $2003. \ e [ebx],al

Etapas necessárias para que se conjuncione logicamente um número com um segundo número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $2103. \ e [ebx],eax

Etapas necessárias para que se disjuncione logicamente um pedaço com um segundo pedaço:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0803. \ ou [ebx],al

Etapas necessárias para que se disjuncione logicamente um pedaço com um número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0803. \ ou [ebx],al

Etapas necessárias para que se disjuncione logicamente um número com um segundo número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $0903. \ ou [ebx],eax

Etapas necessárias para que se disjuncione seletivamente um pedaço com um segundo pedaço:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ a segunda byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $3003. \ xor [ebx],al

Etapas necessárias para que se disjuncione seletivamente um pedaço com um número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $3003. \ ou [ebx],al

Etapas necessárias para que se disjuncione seletivamente um número com um segundo número:
  Intel $8B850C000000. \ mov eax,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $3103. \ xor [ebx],eax

Uma caixa é um conjunto com
  Uma coordenada esquerda , 
  Uma coordenada superior, 
  Uma coordenada direita, 
  Uma coordenada inferior,
  Um canto superior esquerdo localização at a coordenada esquerda , e 
  Um canto inferior direito localização at a coordenada direita, e
  Uma topo-left localização at a coordenada esquerda , e 
  Uma base-right localização at a coordenada direita. 

Um brilho é uma luminosidade.

Um contagem de buckets é uma contagem.

Um bucket é um endereço de memória para um conjunto de buckets.

Um conjunto de buckets é um conjunto com uns refers.

An bucket# é um número.

Um trecho é uma string.

Etapas necessárias para que se avance um pedaço limiting it para um segundo pedaço e um terceiro pedaço:
  Adicione 1 para o pedaço.
  Se o pedaço for maior do que o terceiro pedaço, atribua o segundo pedaço ao pedaço.

Etapas necessárias para que se avance um número:
  Adicione 1 para o número.

Etapas necessárias para que se avance um número limiting it para um segundo número e um terceiro número:
  Adicione 1 para o número.
  Se o número for maior do que o terceiro número, atribua o segundo número ao número.

Etapas necessárias para que se avance um percorredor:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ comando de movimentação do percorredor?
  Intel $FF8314000000. \ inc [ebx+20] \ aumenta o valor do last endereço de memória do pedaço deste segmento inicial deste percorredor.
  Intel $FF8308000000. \ inc [ebx+8] \ aumenta o valor do first endereço de memória do pedaço deste segmento final deste percorredor.

Etapas necessárias para que se recue um percorredor:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ comando de movimentação do percorredor?
  Intel $FF8B14000000. \ dec [ebx+20] \ reduz o valor do last endereço de memória do pedaço deste segmento inicial deste percorredor.
  Intel $FF8B08000000. \ dec [ebx+8] \ reduz o valor do first endereço de memória do pedaço deste segmento final deste percorredor.

Etapas necessárias para que se avance um percorredor por um número:
  Adicione o número para o last endereço de memória do pedaço deste segmento inicial deste percorredor.
  Adicione o número para o first endereço de memória do pedaço deste segmento final deste percorredor.

Etapas necessárias para que se buzz:
  Call "kernel32.dll" "Beep" com 
  220 
    e 200.

Um quantidade de pedaços é uma contagem.

Um endereço de memória do pedaço é um endereço de memória para um pedaço.

An byte# é um número.

An canvas é um hdc. \ hdc = handle device context

Etapas necessárias para que se capitalize algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Se a row estiver em branco, repita.
    Capitalize a string deste row.
  Repita. [o código acima]

Etapas necessárias para que se capitalize uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, pare.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Uppercase o conteúdo deste first endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se capitalize um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde os rows deste text.
    Se a row for inexistente, pare.
    Capitalize a string deste row.
  Repita. [o código acima]
  Wrap o text.

Um caret é um position.

Etapas necessárias para que se centralize uma caixa at o base of uma segunda caixa:
  Centralize a caixa no segunda caixa (horizontalmente).
  Atribua a altura desta caixa a uma altura.
  Atribua a coordenada inferior desta segunda caixa à coordenada inferior desta caixa.
  Atribua a coordenada inferior desta caixa menos o altura à coordenada superior desta caixa.

Etapas necessárias para que se centralize uma caixa em uma segunda caixa (horizontalmente):
  Atribua a coordenada X deste center desta segunda caixa menos a coordenada X deste center desta caixa a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova a caixa usando o número e 0.

Etapas necessárias para que se centralize uma caixa em uma segunda caixa (verticalmente):
  Atribua a coordenada Y deste center desta segunda caixa menos a coordenada Y deste center desta caixa a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova a caixa usando 0 e o número.

Etapas necessárias para que se centralize um dot sobre o current localização:
    \ need Spanish palavra por "dot"
  Centralize o dot sobre a localização deste context.

Etapas necessárias para que se centralize um elipse em uma caixa (horizontalmente):
  Centralize a caixa desta elipse na caixa (horizontalmente).

Etapas necessárias para que se centralize um elipse em uma caixa (verticalmente):
  Centralize a caixa desta elipse na caixa (verticalmente).

Etapas necessárias para que se centralize um line em uma caixa (horizontalmente):
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta line a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o line usando o número e 0.

Etapas necessárias para que se centralize um line em uma caixa (verticalmente):
  Atribua o y deste center desta caixa menos o y deste center desta line a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o line usando 0 e o número.

Etapas necessárias para que se centralize um imagem em uma caixa (horizontalmente):
  Se o imagem for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o imagem usando o número e 0.

Etapas necessárias para que se centralize um imagem em uma caixa (verticalmente):
  Se o imagem for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa menos a coordenada Y deste center desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o imagem usando 0 e o número.

Etapas necessárias para que se centralize um polígono em uma caixa (horizontalmente):
  Se o polígono for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o polígono usando o número e 0.

Etapas necessárias para que se centralize um polígono em uma caixa (verticalmente):
  Se o polígono for inexistente, cancele.
  Atribua o y deste center desta caixa menos o y deste center desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o polígono usando 0 e o número.

Etapas necessárias para que se centralize uma localização em uma caixa (horizontalmente):
  Atribua a coordenada X deste center desta caixa menos a coordenada X desta localização a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova a localização usando o número e 0.

Etapas necessárias para que se centralize uma localização em uma caixa (verticalmente):
  Atribua o y deste center desta caixa menos a coordenada Y desta localização a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova a localização usando 0 e o número.

Etapas necessárias para que se centralize um text em uma caixa (horizontalmente):
  Se o text for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa deste text a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o text usando o número e 0.

Etapas necessárias para que se centralize um text em uma caixa (verticalmente):
  Se o text for inexistente, cancele.
  Atribua o y deste center desta caixa menos o y deste center desta caixa deste text a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o text usando 0 e o número.

Etapas necessárias para que se modifique o current matiz por uns points;
Etapas necessárias para que se altere o current matiz por uns points;
Etapas necessárias para que se mude o current matiz por uns points:
  Mude a matiz deste context por os points.

Etapas necessárias para que se modifique um matiz por uns points;
Etapas necessárias para que se altere um matiz por uns points;
Etapas necessárias para que se mude um matiz por uns points:
  Adicione o points para o matiz.

Etapas necessárias para que se modifique uma caixa arredondada usando um raio;
Etapas necessárias para que se altere uma caixa arredondada usando um raio;
Etapas necessárias para que se mude uma caixa arredondada usando um raio:
  Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se modifique um text usando uma caixa;
Etapas necessárias para que se altere um text usando uma caixa;
Etapas necessárias para que se mude um text usando uma caixa:
  Se o text for inexistente, cancele.
  Atribua a caixa à caixa deste text.
  Wrap o text.

Etapas necessárias para que se modifique um text usando uma altura da fonte;
Etapas necessárias para que se altere um text usando uma altura da fonte;
Etapas necessárias para que se mude um text usando uma altura da fonte:
  Se o text for inexistente, cancele.
  Subtraia a margin deste text desde a coordenada X deste text.
  Atribua a origin deste text dividido pela malha deste text a um par de números.
  Atribua o altura da fonte à altura desta font deste text.
  Redimensione proporcionalmente a altura desta font deste text usando a scale deste text.
  Atribua o par de números times a malha deste text à origin deste text.
  Adicione a margin deste text para a coordenada X deste text.
  Limite o origin of o text.
  Wrap o text.

Etapas necessárias para que se modifique um text usando uma nome da fonte;
Etapas necessárias para que se altere um text usando uma nome da fonte;
Etapas necessárias para que se mude um text usando uma nome da fonte:
  Se o text for inexistente, cancele.
  Atribua o nome da fonte ao nome desta font deste text.
  Wrap o text.

Um character é um pedaço.

Uma choice é uma coisa com um nome e uma caixa.

As choices são umas choices.

Etapas necessárias para que se limpe uma caixa:
  Atribua 0 e 0 e 0 e 0 ao caixa. \ caderno depends sobre this

Etapas necessárias para que se limpe um pedaço:
  Atribua o null pedaço ao pedaço.

Etapas necessárias para que se limpe uma cor:
  Atribua 0 e 0 e 0 à cor.

Etapas necessárias para que se limpe um elipse:
  Limpe a caixa desta elipse.

Etapas necessárias para que se desative um detector;
Etapas necessárias para que se desligue um detector:
  Atribua 0 ao detector. \ was "Atribua no ao detector." Value of "no" inherited desde o CAL-1000 according para Dan.

Etapas necessárias para que se limpe um font:
  Atribua "" e 0 ao font.

Etapas necessárias para que se limpe um fração:
  Atribua 0 e 1 à fração.

Etapas necessárias para que se limpe um Endereço IP:
  Limpe o número deste Endereço IP.
  Limpe a string deste Endereço IP.

Etapas necessárias para que se limpe umA line:
  Limpe o start desta line.
  Limpe o end desta line.

Etapas necessárias para que se limpe um número:
  Atribua 0 ao número.

Etapas necessárias para que se limpe um par de números:
  Atribua 0 e 0 ao par de números.

Etapas necessárias para que se limpe um percorredor:
  Limpe o subtexto original deste percorredor.
  Limpe o segmento final deste percorredor.
  Limpe o segmento inicial deste percorredor.

Etapas necessárias para que se erase a tela;
    \Etapas necessárias para que se branqueie a tela;
Etapas necessárias para que se apague a tela;
Etapas necessárias para que se limpe a tela:
  Mostre tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se pinte a tela usando uma cor;
Etapas necessárias para que se limpe a tela usando uma cor:
  Mostre tudo.
  Pinte a caixa desta tela com a cor e a cor.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se branqueie a tela;
Etapas necessárias para que se pinte a tela de branco;
Etapas necessárias para que se limpe a tela usando a cor branca:
    \ \ needs special handling
  Mostre tudo.
  Pinte a caixa desta tela com a cor branca e a cor branca.
  Atualize o tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe a tela sem atualizá-la:
  Mostre tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe uma seleção:
  Limpe o anchor desta seleção.
  Limpe o caret desta seleção.

Etapas necessárias para que se limpe o stack:
    \ stack needs work
  Destrua o stack.

Etapas necessárias para que se limpe uma string:
  Unassign o first endereço de memória do pedaço desta string.
  Esvazie o last endereço de memória do pedaço desta string.

Etapas necessárias para que se limpe um subtexto:
  Esvazie o first endereço de memória do pedaço deste subtexto.
  Esvazie o last endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se limpe um terminal:
  Destrua os quoras deste terminal.

Etapas necessárias para que se limpe uns coisas:
  Esvazie o first destas coisas.
  Esvazie o last destas coisas.

Etapas necessárias para que se limpe um word:
  Atribua 0 ao word.

Etapas necessárias para que se close um file:
  Call "kernel32.dll" "CloseHandle" com 
    O file.

Um CLSID é um UUID. \ Class ID

Etapas necessárias para que se avise:
  Toque o som de aviso.

O som de aviso é uma wave igual a $524946463A02000057415645666D74201200000001000100401F0000401F000001000800000066616374040000000702000064617461070200007F7F807F7F807F7F808080807F807F7F80817F81817E7E827E7D847C79877D5F6D99B2A25D608269A5979869667F7D8D738C7D8C5E7E878F767A75868D84797278829A7D7E857A73929271657492907D7E7D787E8B887C758388827E817F7C7B89897C7A7E84838183827E7A8488877D7E8181808484817C7F84838181807E7F8283807E8081808182807F7F81818081807F7F8081818080807F7F808180807F80808080807F8080807F8080808080807F7F7F7F7F8080807F7F7F7C7B8182817C7B7D7E8082807D7D7C7F8281807F7C7D808082807E7E7E7D7E807D7B7C7B7D7D7B7A7979797875727269797A490F4571FFF4FF0C001297FBF492525BB0F5B26A001C69BEE5BA76476F9EBD953C3757BAC9BB705C7F9AA883645D7897AA9B806977959588696976999B83766F828C907F7375828E91877B757D868B837A757C858D8880787B8187847B7A7D8788807B79808486817D7C7F8384817D7C7F8484817B7B7D83847F7C7B7E8182827D7C7C8082817D7C7D7F81807F7D7D7F82817F7B7B7E8081807E7D7D7F80807E7D7D7E80807E7D7D7E7F807F7D7D7E7F807F7E7D7E7E80807F7E7D7E80807F7E7E7E7F7F7E7E7E7F7F7F7F7E7E7F7F807F7F7E7E7E7F8080807E7E7E80807F7E7E7F8081807F7F7E7F7F80807F7E7F8081807F7E7E7E80808080807F807F7F7F7F7F7F7F80808080807F7F7F808080807F80808180807F80808100.

Um column# é um número.

Etapas necessárias para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres e uma tabela de tradução (equal only):
  Intel $8BB508000000. \ mov esi,[ebp+8] \ a string
  Intel $8B36. \ mov esi,[esi] \ o first endereço de memória do pedaço desta string
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda string
  Intel $8B3F. \ mov edi,[edi] \ o first endereço de memória do pedaço desta segunda string
  Intel $8B8510000000. \ mov eax,[ebp+16] \ a quantidade de caracteres desta string
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9514000000. \ mov edx,[ebp+20] \ a quantidade de caracteres desta segunda string
  Intel $8B12. \ mov edx,[edx]
  Intel $3BD0. \ cmp eax,edx \ if o differ do quantidade de caracteres, diga não.
  Intel $0F852B000000. \ jne [Se as condições acima não puderem ser satisfeitas, então:] Diga não. \ ************************************ was 2C
  Intel $8BC8. \ mov ecx,eax \ atribua quantidade de caracteres A ecx 
  Intel $8B9D18000000. \ mov ebx,[ebp+24] \ o tabela de tradução
  Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
    \ loop:
  Intel $85C9. \ test ecx,ecx
  Intel $0F8424000000. \ jz say yes \ ************************************ was 25
     \ fetch e translate o current pedaço no segunda string
  Intel $8A07. \ mov al,[edi]
  Intel $D7. \ xlat al,[ebx]
  Intel $C1E008. \ shl eax,8 C1 E0 08
    \ fetch e translate o current pedaço no string
  Intel $8A06. \ mov al,[esi]
  Intel $D7. \ xlat al,[ebx]
     \ compare o two translated pedaços
  Intel $38E0. \ cmp al,ah
  Intel $0F8508000000. \ jne [Se as condições acima não puderem ser satisfeitas, então:] Diga não. \ ************************************
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $E9DFFFFFFF. \ jmp loop \ ************************************ was DE
    \[Se as condições acima não puderem ser satisfeitas, então:] Diga não.:
  Intel $C7C000000000. \ mov eax,0
  Intel $E906000000. \ jmp end
    \SAY YES:
  Intel $C7C001000000. \ mov eax,1

    \ dahn - spanish strings 2 - which table para use?
Etapas necessárias para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres devolvendo um número:
  Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos ascii devolvendo o número.
    \Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos s/ acento ascii devolvendo o número.

Etapas necessárias para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres e uma tabela de tradução devolvendo um número:
  Intel $8BB508000000. \ mov esi,[ebp+8] \ a string
  Intel $8B36. \ mov esi,[esi] \ o first do string
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda string
  Intel $8B3F. \ mov edi,[edi] \ o first do segunda string
  Intel $8B8510000000. \ mov eax,[ebp+16] \ a quantidade de caracteres do string
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9514000000. \ mov edx,[ebp+20] \ a quantidade de caracteres do segunda string
  Intel $8B12. \ mov edx,[edx]
  Intel $8B9D18000000. \ mov ebx,[ebp+24] \ o tabela de tradução
  Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
    \ obtenha o minimum quantidade de caracteres
  Intel $8BC8. \ mov ecx,eax
  Intel $3BCA. \ cmp ecx,edx
  Intel $0F8602000000. \ jbe L2
  Intel $8BCA. \ mov ecx,edx
    \ if o minimum quantidade de caracteres for 0, jump para L5
  Intel $85C9. \ test ecx,ecx
  Intel $0F8428000000. \ jz L5
    \L2:
    \ loop:
    \ fetch e translate o current pedaço no string
  Intel $8A06. \ mov al,[esi]
  Intel $D7. \ xlat al,[ebx]
  Intel $88C2. \ mov dl,al
    \ fetch e translate o current pedaço no segunda string
  Intel $8A07. \ mov al,[edi]
  Intel $D7. \ xlat al,[ebx]
  Intel $88C6. \ mov dh,al
    \L3:
    \ compare o two translated pedaços
  Intel $38F2. \ cmp dl,dh
  Intel $0F8510000000. \ jne L4
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $85C9. \ test ecx,ecx
  Intel $0F8405000000. \ jz L4
  Intel $E9DEFFFFFF. \ jmp L2
    \L4:
    \ Carregue pedaços para EAX e edx por final compare
  Intel $0FB6C2. \ movzx eax,dl
  Intel $0FB6D6. \ movzx edx,dh
    \L5:
    \ subtraia either o lengths ou os last dois pedaços para abra o eax para <0, =0, >0
  Intel $2BC2. \ sub eax,edx
  Intel $8B9D1C000000. \ mov ebx,[ebp+28] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se compativelmente handle algum tipo de message com um window um message número um w-param e um l-param:
  Se a message for 006, execute algum tipo de WM-ACTIVATE com o w-param; 
    \Enviado para a janela que está sendo ativada e a janela que está sendo desativada. 
    \Se as janelas usarem a mesma fila de entrada, a mensagem será enviada de forma síncrona, 
    \primeiro para o procedimento de janela da janela de nível superior que está sendo desativada e,
    \em seguida, para o procedimento de janela da janela de nível superior que está sendo ativada. 
    \Se as janelas usarem filas de entrada diferentes, a mensagem será enviada de forma assíncrona, portanto, a janela será ativada imediatamente.
     Atribua 0 para EAX; exit.
  Se a message for 258 [hex 102], execute algum tipo de WM-CHAR com o w-param e o l-param; 
    \ Essa menagem é enviada para a janela com o foco do teclado quando uma mensagem WM_KEYDOWN é traduzida pela função TranslateMessage. 
    \A mensagem WM_CHAR contém o código de caractere da tecla que foi pressionada.
  atribua 0 para EAX; exit.
  Se a message for 001, execute algum tipo de wm-create com o window; 
    \Enviado quando um aplicativo solicita que uma janela seja criada chamando a função CreateWindowEx ou CreateWindow. 
    \(A mensagem é enviada antes de a função retornar.) 
    \O procedimento de janela da nova janela recebe essa mensagem depois que a janela é criada, mas antes que a janela se torne visível.
    \Uma janela recebe essa mensagem por meio de sua função WindowProc.
  atribua 0 para EAX; exit.
  Se a message for 002, execute algum tipo de wm-destroy; atribua 0 para EAX; exit.
  Se a message for 256 [Hex 100], execute algum tipo de WM-KEYDOWN 
    \Essa menagem é enviada para a janela com o foco do teclado quando uma tecla não pertencente ao sistema é pressionada. 
    \Uma tecla que não é do sistema é aquela que é pressionada quando a tecla ALT não está pressionada.
  com o w-param \O código de tecla virtual da tecla não pertencente ao sistema. Consulte Códigos de teclas virtualis -> https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
    e O l-param; \Pode ser a contagem de repetição, um código de varredura, sinalizador de chave estendida, código de contexto, sinalizador de estado-chave anterior e sinalizador de estado de transição,
    \ veja detalhes aqui: https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown
   atribua 0 para EAX; exit.
  Se a message for 513 [Hex 201], execute algum tipo de WM-LBUTTONDOWN
    \Postado quando o usuário pressiona o botão esquerdo do mouse enquanto o cursor está na área do cliente de uma janela. 
    \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. 
    \Caso contrário, a mensagem é postada na janela que capturou o mouse.
    \Uma janela recebe essa mensagem por meio de sua função WindowProc.
    \ o w-param Indica se as teclas virtuais estão pressionadas ou não, podendo ser mais de uma
   com o l-param;    \A word de ordem inferior especifica a coordenada X do cursor. A coordenada é relativa ao canto superior esquerdo da área do cliente.
    \A word de ordem superior especifica a coordenada Y do cursor. A coordenada é relativa ao canto superior esquerdo da área do cliente.
   atribua 0 para EAX; exit.
  Se a message for 515 [Hex 203], execute algum tipo de wm-lbuttondblclk com o l-param; atribua 0 para EAX; exit.
  Se a message for 015 [Hex F], execute algum tipo de wm-paint com o window; atribua 0 para EAX; exit.
  Se a message for 516 [Hex 204], execute algum tipo de wm-rbuttondown com o l-param; atribua 0 para EAX; exit.
  Se a message for 518 [Hex 206], execute algum tipo de wm-rbuttondblclk com o l-param; atribua 0 para EAX; exit.
  Se a message for 032 [Hex 20], execute algum tipo de wm-setcursor; atribua 1 para EAX; exit.
  Se a message for 260 [Hex 104], execute algum tipo de wm-syskeydown com o w-param e o l-param; atribua 0 para EAX; exit.
  Call "user32.dll" "DefWindowProcA" com 
    A window 
    e A message 
    e 
  o w-param 
    e O l-param.

Etapas necessárias para que se compativelmente aguarde por um process endereço de memória:
  Call "kernel32.dll" "WaitForSingleObject" com 
    O conteúdo deste process endereço de memória 
    e -1 [tempo em milisegundos.  O valor -1 informa que a função retornará apenas quando o objeto for sinalizado.].
  Call "kernel32.dll" "CloseHandle" com o conteúdo deste process endereço de memória.
  Atribua 0 ao conteúdo deste process endereço de memória. \ conteúdo = conteúdo
  Call "user32.dll" "GetForegroundWindow" 
    devolvendo uma window.
  Se a window for a main window, atribua 0 para EAX; exit.
  Call "user32.dll" "ShowWindow" com 
    A main window 
    e 6 [SW_MINIMIZE].
  Call "user32.dll" "ShowWindow" com 
    A main window 
    e 9 [SW_RESTORE].
  Atribua 0 para EAX. \ abra return value of thread

    \Um console é uma coisa com 
    \a caixa,
    \a cor da borda,
    \a cor de preenchimento,
    \a text,
    \a malha,
    \a reply string.

Um console é uma coisa com 
Um caixa, 
Um cor da borda,
Um cor de preenchimento, 
Um text, 
Um malha, 
Um reply string.

O context é um context.

An context é uma coisa com 
  Uma localização, 
  Uma caixa, 
  Uma orientação, 
  Um tamanho da letra, 
  Uma cor, 
  Um número, 
  Uma grossura do pincel,\ pincel largura? ***
  e um letra size at o tamanho da letra, 
  e um pincel at a cor.
    \REMARK: O "grossura do pincel" não estava no context conjunto, but it deveria be.
    \I will be adding it para o next version of o CAL context, e now might be a good time for you para adicione it para o PAL context conjunto.

O context stack é uns contexts.

Etapas necessárias para que se converta um posicionamento absoluto para uma position usando um text:
  Se o text for inexistente, limpe o position; exit.
  Isole o posicionamento absoluto.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, limpe o position; exit.
    Atribua o número da linha desta row ao número da linha desta position.
    Atribua o posicionamento absoluto ao column# desta position.
    Subtraia a quantidade de caracteres desta string desta row desde o posicionamento absoluto.
    Se o posicionamento absoluto for menor do que 1, cancele.
  Repita. [o código acima]

Etapas necessárias para que se converta um código binário Para um número:
  Atribua 0 ao número.
  Atribua 1 a um value número.
  Percorra. [o código abaixo]
    Se o código binário estiver em branco, cancele.
    Obtenha um character desde o código binário (backwards). \ was backwards
    Se o character for "1", adicione o value para o número.
    Double o value.
  Repita. [o código acima]

Etapas necessárias para que se converta uma caixa para uma string:
  Limpe a string.
  Posponha a coordenada esquerda desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada superior desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada direita desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada inferior desta caixa para a string.

Etapas necessárias para que se converta um pedaço para uma cifra binária:
  Atribua o pedaço à cifra binária como um pedaço.
  Uppercase a cifra binária.
  Se a cifra binária for maior do que o número nove, subtraia 7 desde a cifra binária.
  Subtraia 48 desde a cifra binária.

Etapas necessárias para que se converta um pedaço para um cifra hexadecimal:
  Split o pedaço a uma cifra binária e uma segunda cifra binária.
  Converta a cifra binária para o cifra hexadecimal.
  Converta a segunda cifra binária para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Etapas necessárias para que se converta um pedaço para um query pedaço:
  Se o pedaço estiver entre 48 e 57, atribua o pedaço ao query pedaço; exit. \ 0-9
  Se o pedaço estiver entre 65 e 90, atribua o pedaço ao query pedaço; exit. \ A-Z
  Se o pedaço estiver entre 97 e 122, atribua o pedaço ao query pedaço; exit. \ a-z
  Se o pedaço for 32, atribua "+" ao query pedaço; exit. \ space
  Converta o pedaço para um cifra hexadecimal.
  Atribua "%" junto com a cifra hexadecimal ao query pedaço.

Etapas necessárias para que se converta uma cor para um código da cor:
  Se a cor estiver clear, atribua 16777215 [$00FFFFFF] ao código da cor; exit. \ a cor transparente fica branca 
  Isole a cor.
  Redimensione proporcionalmente a saturação desta cor usando 240/1000.
  Limite a saturação desta cor para 1 e 239.
  Redimensione proporcionalmente a luminosidade desta cor usando 240/1000.
  Limite a luminosidade desta cor para 1 e 239.
  Redimensione proporcionalmente a matiz desta cor usando 240/3600.
  Limite a matiz desta cor para 1 e 239.
  Call "shlwapi.dll" "ColorHLSToRGB" com 
    A matiz desta cor 
    e A luminosidade desta cor 
    e A saturação desta cor 
    devolvendo o código da cor.

Etapas necessárias para que se converta uma cor para um espaço de cor RGB:
  Converta a cor para um código da cor.
  Converta o código da cor para o espaço de cor RGB.

Etapas necessárias para que se converta um código da cor para uma cor:
  Call "shlwapi.dll" "ColorRGBToHLS" com 
    O código da cor e 
    O endereçamento desse word 
    e O endereçamento dessa segunda word 
    e O endereçamento desse terceiro word.
  Atribua o word à matiz desta cor.
  Atribua a segunda word à luminosidade desta cor.
  Atribua o terceiro word à saturação desta cor.
  Redimensione proporcionalmente a matiz desta cor usando 3600/240.
  Limite a matiz desta cor para 0 e 3600.
  Redimensione proporcionalmente a saturação desta cor usando 1000/240.
  Limite a saturação desta cor para 0 e 1000.
  Redimensione proporcionalmente a luminosidade desta cor usando 1000/240.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se converta um código da cor para um espaço de cor RGB:
  Isole o código da cor.
  Desloque o código da cor right 0 bits.
  Atribua o código da cor ao espectro vermelho deste espaço de cor RGB.
  Desloque o código da cor right 8 bits.
  Atribua o código da cor ao espectro verde deste espaço de cor RGB.
  Desloque o código da cor right 8 bits.
  Atribua o código da cor ao espectro azul deste espaço de cor RGB.

Etapas necessárias para que se converta um filetime para uma string:
  Limpe a string.
  Call "kernel32.dll" "FileTimeToSystemTime" com 
    O endereçamento deste filetime 
    e O endereçamento desse systemtime 
    devolvendo um número.
  Se o número for 0, cancele.
  Atribua o wyear deste systemtime ao year desse date/time.
  Atribua o wmonth deste systemtime ao month deste date/time.
  Atribua o wdayofweek deste systemtime ao week day deste date/time.
  Atribua o wday deste systemtime ao day deste date/time.
  Atribua o whour deste systemtime à hour deste date/time.
  Atribua o wminute deste systemtime ao minute deste date/time.
  Atribua o wsecond deste systemtime ao second deste date/time.
  Atribua os wmilliseconds deste systemtime ao millisecond deste date/time.
  Atribua a string deste date/time à string.

Etapas necessárias para que se converta um detector para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude deste detector.
  Copie pedaços desde o endereçamento deste detector para o first deste texto hexadecimal pela magnitude deste detector.
  Atribua o first deste texto hexadecimal mais a magnitude deste detector menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se converta uma font para um número da fonte:
  Isole o font.
  Modifique através do caractere NUL o nome desta font.
  Call "gdi32.dll" "CreateFontA" com
   - a altura desta font times 3 dividido por 4 
    e 0 
    e 0 
    e 0 
    e 0 
    e 0 
    e 0 
    e 0 
    e 1 [DEFAULT_CHARSET] 
    e 0 
    e 0 
    e 5 [CLEARTYPE_QUALITY] 
    e 4 [TRUETYPE_FONTTYPE] 
    e O first deste nome desta font 
    devolvendo o número da fonte.

Etapas necessárias para que se converta uma fração para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude desta fração.
  Copie pedaços desde o endereçamento desta fração para o first deste texto hexadecimal pela magnitude desta fração.
  Atribua o first deste texto hexadecimal mais a magnitude desta fração menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se converta uma fração para um mixed:
  Se o denominador desta fração for 0, atribua 0 ao whole número deste mixed; atribua 0 ao ratio deste mixed; exit.
  Divida o numerador desta fração pelo denominador desta fração usando o whole número deste mixed e um resto.
  Atribua o resto e o denominador desta fração ao fração deste mixed.

Etapas necessárias para que se converta uma fração para uma string usando um número:
    \ converts para um decimal representation com "the número" of places
  Limpe a string.
  Se o número for menor do que 1, cancele.
  Atribua 10 a um value número.
  Raise o value para o número.
  Isole a fração.
  Se a fração for negative, acione um detector; de-sign a fração.
  Multiplique o value pela fração.
  Zero fill o value usando o número e posponha it para a string.
  Atribua a quantidade de caracteres desta string menos o número mais 1 a um byte#.
  Insira "." à string antes de o byte#.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o ponto final, anteponha "0" para a string.
  Se o detector estiver ativo, anteponha "-" para a string.

Etapas necessárias para que se converta um texto hexadecimal para um fração:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude desta fração, atribua 0 e 1 ao ratio; exit.
  Copie pedaços desde o first deste texto hexadecimal para o endereçamento desta fração pela magnitude desta fração.

Etapas necessárias para que se converta um texto hexadecimal para um número:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude deste número, limpe o número; exit.
  Copie pedaços desde o first deste texto hexadecimal para o endereçamento destte número pela magnitude deste número.

Etapas necessárias para que se converta um l-param para um tecla:
    \ assumes l-param desde wm_char message
  Atribua o l-param à tecla.
  Desloque a tecla right 16 bits.
  Conjuncione logicamente a tecla com 255.
  Call "user32.dll" "MapVirtualKeyA" com 
    A tecla 
    e 1 
    devolvendo a tecla.
  Se o numlock tecla was not toggled, cancele.
  Se a tecla for a tecla Insert, atribua o numpad-tecla zero à tecla; exit.
  Se a tecla for a tecla Delete, atribua o numpad-period tecla à tecla; exit.
  Se a tecla for a tecla Home, atribua o numpad-tecla sete à tecla; exit.
  Se a tecla for a tecla End, atribua o numpad-tecla hum à tecla; exit.
  Se a tecla for a tecla PgUp, atribua o numpad-tecla nove à tecla; exit.
  Se a tecla for a tecla PgDn, atribua o numpad-tecla três à tecla; exit.
  Se a tecla for a left-arrow tecla, atribua o numpad-tecla quatro à tecla; exit.
  Se a tecla for a seta pra cima, atribua o numpad-tecla oito à tecla; exit.
  Se a tecla for a right-arrow tecla, atribua o numpad-tecla seis à tecla; exit.
  Se a tecla for a seta pra baixo, atribua o numpad-tecla dois à tecla; exit.
  Se a tecla for a tecla Clear, atribua o numpad-tecla cinco à tecla; exit.

Etapas necessárias para que se converta um l-param para uma localização:
  Split o l-param a um word e uma segunda word.
  Atribua o word à coordenada y desta localização.
  Atribua a segunda word à coordenada x desta localização.
  Multiplique a localização pelo tpp.

Etapas necessárias para que se converta um mixed para um fração:
  Atribua o fração deste mixed à fração.
  Adicione o whole número deste mixed times o denominador desta fração para o numerador desta fração.

Etapas necessárias para que se converta uma cifra binária para um cifra hexadecimal:
  Isole a cifra binária.
  Se a cifra binária for maior do que 9, adicione 7 para a cifra binária.
  Adicione 48 para a cifra binária.
  Atribua a cifra binária ao cifra hexadecimal.

Etapas necessárias para que se converta um cifra hexadecimal para um texto hexadecimal:
  Isole o cifra hexadecimal.
  Limpe o texto hexadecimal.
  Se a quantidade de caracteres deste cifra hexadecimal for ímpar, anteponha o número zero para o cifra hexadecimal.
  Lance um subtexto sobre o cifra hexadecimal.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma cifra binária.
    Desloque a cifra binária left 4 bits.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Posponha a cifra binária para o texto hexadecimal.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se converta um número para um pedaço:
  Atribua o número ao pedaço.

Etapas necessárias para que se converta um pchar para uma string:
  Limpe a string.
  Se o pchar for inexistente, cancele.
  Isole o pchar.
  Percorra. [o código abaixo]
    Se o conteúdo deste pchar for o null pedaço, cancele.
    Posponha o conteúdo deste pchar para a string.
    Adicione 1 para o pchar.
  Repita. [o código acima]

Etapas necessárias para que se converta um endereço de memória e uma quantidade de caracteres para uma string:
  Limpe a string.
  Se o endereço de memória for inexistente, cancele.
  Se a quantidade de caracteres for 0, cancele.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres.
  Copie pedaços desde o endereço de memória para o first endereço de memória do pedaço desta string pelo quantidade de caracteres.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres menos 1 ao last endereço de memória do pedaço desta string.

Etapas necessárias para que se converta um endereço de memória para um texto hexadecimal;
Etapas necessárias para que se converta um número para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude deste número.
  Copie pedaços desde o endereçamento deste número para o first deste texto hexadecimal pela magnitude deste número.
  Atribua o first deste texto hexadecimal mais a magnitude deste número menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se converta um endereço de memória para um cifra hexadecimal;
Etapas necessárias para que se converta um número para um cifra hexadecimal:
  Split o número a um word e uma segunda word.
  Converta o word para o cifra hexadecimal.
  Converta a segunda word para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Etapas necessárias para que se converta um endereço de memória para uma string:
  Converta o endereço de memória para a string como um cifra hexadecimal.

Etapas necessárias para que se converta uns points para uns precise degrees:
  Atribua o points times 3840 dividido por 3600 ao precise degrees.

Etapas necessárias para que se converta uma position para um posicionamento absoluto usando um text:
  Se o text for inexistente, limpe o posicionamento absoluto; exit.
  Atribua 0 ao posicionamento absoluto.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha desta position, adicione a quantidade de caracteres desta string desta row para o posicionamento absoluto; repita.
  Adicione o column# desta position para o posicionamento absoluto.

Etapas necessárias para que se converta uns precise degrees para uns points:
  Atribua os precise degrees times 3600 dividido por 3840 ao points.

Etapas necessárias para que se converta um texto de consulta para uma string:
  Limpe a string.
  Se o texto de consulta estiver em branco, cancele.
  Lance um subtexto sobre o texto de consulta.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de adição, posponha " " para a string; adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o sinal de porcentagem, posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a string; adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Se a quantidade de caracteres deste subtexto for menor do que 3, cancele.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma cifra binária.
    Desloque a cifra binária left 4 bits.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Posponha a cifra binária para a string.
  Repita. [o código acima]

Etapas necessárias para que se converta uns rows para uma string:
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Posponha a string deste row para a string.
    Se o conteúdo deste last endereço de memória do pedaço desta string é o return pedaço, posponha o linefeed pedaço para a string; repita.
  Repita. [o código acima]

Etapas necessárias para que se converta uns rows para uma string (no linefeed additions):
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Posponha a string deste row para a string.
  Repita. [o código acima]

Etapas necessárias para que se converta uma string para um detector:
  Se a string for "s", acione o detector; exit.
  Se a string for "sim", acione o detector; exit.
  Se a string for "y", acione o detector; exit.
  Se a string for "yes", acione o detector; exit.
  [Se o texto informado não for nenhuma dessas opções, então:] 
  Desative o detector.

Etapas necessárias para que se converta uma string para um fração:
  Limpe a fração.
  Se a string estiver em branco, cancele.
  Se a string for algum tipo de integer, converta a string para o numerador desta fração; exit.
  Lance um subtexto sobre a string.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Split o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto estiver em branco, atribua o subtexto à fração subtexto.
  Split a fração subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
  Converta o integer subtexto para um whole número.
  Converta o numerador subtexto para um numerador número.
  Converta o denominador subtexto para um denominador número.
  Se o whole número é negative, cancele.
  Se o numerador número é negative, cancele.
  Se o denominador número é negative, cancele.
  Se o denominador número for 0, cancele.
  Se o whole número não for 0, adicione o denominador número times o whole número para o numerador número.
  Atribua o numerador número ao numerador desta fração.
  Atribua o denominador número ao denominador desta fração.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o hífem, negate a fração.

Etapas necessárias para que se converta uma string para um cifra hexadecimal:
  Limpe o cifra hexadecimal.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra hexadecimal.
    Posponha a segunda cifra hexadecimal para o cifra hexadecimal.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se converta uma string para um número:
  Atribua 0 ao número.
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Multiplique o número por 10.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um segundo número.
    Subtraia 48 desde o segundo número.
    Adicione o segundo número para o número.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Se o conteúdo deste first endereço de memória do pedaço desta string for o hífem, negate o número.

Etapas necessárias para que se converta uma string para um número between um segundo número e um terceiro número:
  Converta a string para o número.
  Limite o número para o segundo número e o terceiro número.

Etapas necessárias para que se converta uma string para um endereço de memória:
    \ presume que o endereço de memória está em cifra binária format
  Converta a string como um cifra hexadecimal para um texto hexadecimal.
  Esvazie o endereço de memória.
  Lance um subtexto sobre o texto hexadecimal.
  Atribua 24 a um contagem de deslocamentos.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se a contagem de deslocamentos for menor do que 0, cancele.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um número.
    Desloque o número left o contagem de deslocamentos.
    Disjuncione logicamente o endereço de memória como um número com o número.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Subtraia 8 desde o contagem de deslocamentos.
  Repita. [o código acima]

Etapas necessárias para que se converta uma string para um texto de consulta:
  Limpe o texto de consulta.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
  Se o subtexto estiver em branco, pare.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para um query pedaço.
    Posponha o query pedaço para o texto de consulta.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se converta uma string para uns rows:
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor (text file rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma row usando o segmento inicial deste percorredor.
    Posponha a row para a rows.
    Se o conteúdo deste last endereço de memória do pedaço desta string desta row for o linefeed pedaço, atribua o return pedaço ao conteúdo deste last endereço de memória do pedaço desta string desta row. 
    \ *dahn new para handle lines terminated por just linefeed
  Repita. [o código acima]
  Renumber a rows.

Etapas necessárias para que se converta uma string para um uuid:
  Converta a string para um wide string e modifique através do caractere NUL.
  Call "ole32.dll" "CLSIDFromString" com 
    O first deste wide string 
    e O endereçamento deste uuid.

Etapas necessárias para que se converta uma string para um wide string:
  Limpe a wide string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a wide string.
    Posponha o null pedaço para a wide string.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se converta uma string para um wide string e modifique através do caractere NUL:
  Converta a string para a wide string.
  Modifique através do caractere NUL a wide string.

Etapas necessárias para que se converta uma URL para uma URL simplificada:
  Isole a URL.
  Modifique através do caractere NUL a URL.
  Atribua a magnitude desses URL_COMPONENTS ao dwStructSize destes URL_COMPONENTS.
  Atribua 1 ao dwSchemeLength destes URL_COMPONENTS.
  Atribua 1 ao dwHostNameLength destes URL_COMPONENTS.
  Atribua 1 ao dwUrlPathLength destes URL_COMPONENTS.
  Atribua 1 ao dwExtraInfoLength destes URL_COMPONENTS.
  Call "wininet.dll" "InternetCrackUrlA" com 
    O first desta URL 
    e 0 
    e 0 
    e O endereçamento destes URL_COMPONENTS 
    devolvendo um número.
  Converta o lpszScheme destes URL_COMPONENTS e o dwSchemeLength destes URL_COMPONENTS para o nome do protocolo desta URL simplificada.
  Converta o lpszHostName destes URL_COMPONENTS e o dwHostNameLength destes URL_COMPONENTS para o nome de host desta URL simplificada.
  Converta o lpszUrlPath destes URL_COMPONENTS e o dwUrlPathLength destes URL_COMPONENTS para o endereço de recurso desta URL simplificada.
  Converta o lpszExtraInfo destes URL_COMPONENTS e o dwExtraInfoLength destes URL_COMPONENTS para a parâmetro de consulta desta URL simplificada.
  Atribua o nPort destes URL_COMPONENTS ao número de porta desta URL simplificada.

Etapas necessárias para que se converta um word para um cifra hexadecimal:
  Split o word a um pedaço e um segundo pedaço.
  Converta o pedaço para o cifra hexadecimal.
  Converta o segundo pedaço para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Uma coordenada é uns twips.

Etapas necessárias para que se copie pedaços desde um endereço de memória para um segundo endereço de memória por um quantidade de pedaços:
    \ copie handling overlap com 1 pedaço moves
  Intel $8BB508000000. \ mov esi,[ebp+8] \ o endereço de memória
  Intel $8B36. \ mov esi,[esi]
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ a segunda endereço de memória
  Intel $8B3F. \ mov edi,[edi]
  Intel $8B8D10000000. \ mov ecx,[ebp+16] \ o número
  Intel $8B09. \ mov ecx,[ecx]
    \ check por something para copiar
  Intel $81F900000000. \ cmp ecx,0
  Intel $0F8E39000000. \ jle end
    \ check por no overlap
  Intel $3BF7. \ cmp esi,edi
  Intel $0F8D24000000. \ jge forward
  Intel $8BC6. \ mov eax,esi
  Intel $03C1. \ adicione eax,ecx
  Intel $3BC7. \ cmp eax,edi
  Intel $0F8E18000000. \ jle forward
    \ copia backward
  Intel $03F1. \ adicione esi,ecx
  Intel $4E. \ dec esi
  Intel $03F9. \ adicione edi,ecx
  Intel $4F. \ dec esi
    \ backward
  Intel $8A16. \ mov dl,[esi]
  Intel $8817. \ mov [edi],dl
  Intel $4E. \ dec esi
  Intel $4F. \ dec edi
  Intel $49. \ dec ecx
  Intel $0F85F3FFFFFF. \ jnz backward
  Intel $E90D000000. \ jmp end
    \ forward: copia forward
  Intel $8A16. \ mov dl,[esi]
  Intel $8817. \ mov [edi],dl
  Intel $46. \ inc esi
  Intel $47. \ inc edi
  Intel $49. \ dec ecx
  Intel $0F85F3FFFFFF. \ jnz forward

Etapas necessárias para que se copie um event para um segundo event: \ mudar o "segunda" aqui
  Se o event for inexistente, esvazie a segundo event; exit.
  Crie a segundo event.
  Atribua a categoria deste event à categoria deste segundo event.
  Atribua o detector de tecla Shift deste event ao detector de tecla Shift deste segundo event.
  Atribua o detector de tecla ctrl deste event ao detector de tecla Ctrl deste segundo event.
  Atribua o detector de tecla alt deste event ao detector de tecla Alt deste segundo event.
  Atribua a localização deste event à localização deste segundo event.
  Atribua a tecla deste event à tecla deste segundo event.
  Atribua o pedaço deste event ao pedaço deste segundo event.

Etapas necessárias para que se copie um gpbitmap Para uma segunda gpbitmap: \verificar
  Se o gpbitmap for inexistente, esvazie a segunda gpbitmap; exit.
  Call "gdiplus.dll" "GdipCloneBitmapAreaI" com 
  0 
    e 0 
    e A largura deste gpbitmap 
    e A altura deste gpbitmap 
    e 0 [PixelFormatDontCare] 
    e O gpbitmap 
    e O endereçamento desta segunda gpbitmap.

Etapas necessárias para que se copie o guts of um text Para uma segunda text:
  Se o text for inexistente, cancele.
  Se a segunda text for inexistente, cancele.
  Atribua a caixa deste text à caixa desta segunda text.
  Atribua a origin deste text à origin desta segunda text.
  Atribua o pincel deste text ao pincel desta segunda text.
  Atribua a font deste text à font desta segunda text.
  Atribua o alinhamento deste text ao alinhamento desta segunda text.
  Copie as rows deste text para as rows desta segunda text.
  Atribua a margin deste text à margin desta segunda text.
  Atribua a scale deste text à scale desta segunda text.
  Atribua o wrap detector deste text ao wrap detector desta segunda text.
  Atribua o horizontal scroll detector deste text ao horizontal scroll detector desta segunda text.
  Atribua o vertical scroll detector deste text ao vertical scroll detector desta segunda text.
  Atribua a seleção deste text à seleção desta segunda text.
  Atribua o detector de alteração deste text ao detector de alteração desta segunda text.
  Atribua o última operação deste text ao última operação desta segunda text.
    \ dont copie undos e redos

O número de cópias é um número.

Etapas necessárias para que se copie uma imagem Para uma segunda imagem:
  Se o imagem for inexistente, esvazie a segunda imagem; exit.
  Aloque memória para a segunda imagem.
  Atribua a caixa desta imagem à caixa desta segunda imagem.
  Atribua a caixa intacta desta imagem à caixa intacta desta segunda imagem.
  Atribua o grayscale detector desta imagem ao grayscale detector desta segunda imagem.
  Atribua o mirror detector desta imagem ao mirror detector desta segunda imagem.
  Atribua o ângulo de rotação desta imagem ao ângulo de rotação desta segunda imagem.
  Atribua os data desta imagem aos data desta segunda imagem.
  Copie o gpbitmap desta imagem ao gpbitmap desta segunda imagem.

Etapas necessárias para que se copie um polígono Para uma segunda polígono:
  Se o polígono for inexistente, esvazie a segunda polígono; exit.
  Aloque memória para o segunda polígono.
  Copie os vértices deste polígono aos vértices desta segunda polígono.

Etapas necessárias para que se copie uma row Para uma segunda row:
  Se a row for inexistente, esvazie a segunda row; exit.
  Aloque memória para o segunda row.
  Atribua a número da linha desta row ao número da linha desta segunda row.
  Atribua a string desta row à string desta segunda row.

Etapas necessárias para que se copie uns rows Para uns segunda rows:
  Destrua a segunda rows.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Copie a row a uma segunda row.
    Posponha a segunda row para a segunda rows.
  Repita. [o código acima]

Etapas necessárias para que se copie um text Para uma segunda text:
  Se o text for inexistente, esvazie a segunda text; exit.
  Aloque memória para o segunda text.
  Copie o guts of o text ao segunda text.

Etapas necessárias para que se copie um vértice Para uma segunda vértice:
  Se o vértice for inexistente, esvazie a segunda vértice; exit.
  Aloque memória para o segunda vértice.
  Atribua a coordenada X deste vértice à coordenada x desta segunda vértice.
  Atribua a coordenada Y deste vértice à coordenada y desta segunda vértice.

Etapas necessárias para que se copie uns vértices Para uns segunda vértices:
  Destrua os segunda vértices.
  Percorra. [o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Copie o vértice a uma segunda vértice.
    Posponha a segunda vértice para a segunda vértices.
  Repita. [o código acima]

Uma contagem é um número.

Um contador é um número.

Etapas necessárias para que se crie o connect handle of um winhttp request using uma URL simplificada:
  Se o winhttp request for inexistente, cancele.
  Converta o nome de host desta URL simplificada a um wide string denominado wide host nome e modifique através do caractere NUL.
  Call "winhttp.dll" "WinHttpConnect" com 
    O session número identificador desta request deste winhttp
   e o first endereço de memória do pedaço deste wide host nome 
   e o número de porta desta URL simplificada 
   e 0 
     devolvendo o connection número identificador deste winhttp request.
  Se o connection número identificador deste winhttp request for 0, atribua "Erro. Não foi possível estabelecer uma conexão." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se crie um console:
  Aloque memória para o console.
  Atribua a cor cinza muito claro à cor da borda deste console.
  Atribua a cor cinza muito claro à cor de preenchimento deste console.
  Atribua a caixa desta tela à caixa deste console.
  Atribua a caixa desta tela a uma caixa.
  Subtraia a altura desta fonte padrão desde a coordenada inferior desta caixa.
  Atribua a altura desta caixa dividido pela altura desta fonte padrão times a altura desta fonte padrão a uma altura.
  Atribua a coordenada superior desta caixa mais o altura à coordenada inferior desta caixa.
  Centralize a caixa na caixa desta tela (verticalmente).
  Atribua a coordenada superior desta caixa à coordenada esquerda desta caixa.
  Subtraia a coordenada superior desta caixa desde a coordenada direita desta caixa.
  Crie o text deste console.
  Atribua a caixa à caixa deste text deste console.
  Ligue o wrap detector deste text deste console.
  Desative o horizontal scroll detector deste text deste console.
  Ligue o vertical scroll detector deste text deste console.
  Atribua a altura desta fonte padrão ao malha deste console.
  Multiplique o número X deste malha deste console por 2.

Etapas necessárias para que se crie um crypt session com um passphrase string:
    \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Aloque memória para o crypt session.
    \ acquire context
  Call "advapi32.dll" "CryptAcquireContextA" com 
    O endereçamento deste HCRYPTPROV deste crypt session 
    e 0 
    e "Microsoft Enhanced Cryptographic Provider v1.0"'s first endereço de memória do pedaço 
    e 1 [PROV_RSA_FULL] 
    e -268435456 [CRYPT_VERIFYCONTEXT] 
    devolvendo um result número.
  Se o result número for 0, atribua "Erro. Não foi possível adquirir o contexto." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
    \ crie hash
  Call "advapi32.dll" "CryptCreateHash" com 
    o HCRYPTPROV deste crypt session 
    e 32771 [CALG_MD5] 
    e 0 
    e 0 
    e o endereçamento deste HCRYPTHASH deste crypt session 
    devolvendo o result número.
  Se o result número for 0, atribua "Erro. Não foi possível criar o hash." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
    \ hash passphrase
  Call "advapi32.dll" "CryptHashData" com 
    O HCRYPTHASH deste crypt session 
    e O first desta passphrase 
    e A quantidade de caracteres desta passphrase 
    e 0 
    devolvendo o result número.
  Se o result número for 0, atribua "Erro. Não foi possível fazer o hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
    \ derive session tecla
  Call "advapi32.dll" "CryptDeriveKey" com 
    O HCRYPTPROV deste crypt session 
    e 26625 [CALG_RC4  Stream Cipher] 
    e O HCRYPTHASH deste crypt session 
    e 8388608 [Key length: 128 bit] 
    e O endereçamento deste hcryptkey desta crypt session 
    devolvendo o result número.
  Se o result número for 0, atribua "Erro. Não foi possível derivar a chave da sessão." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.

Etapas necessárias para que se crie um dyad:
  Aloque memória para o dyad.

Etapas necessárias para que se crie um event:
  Aloque memória para o event.

Etapas necessárias para que se crie uma font info usando um font:
  Crie o font info usando o font (basic data).
  Crie as font larguras desta font info usando o font.

Etapas necessárias para que se crie uma font info usando uma font (basic data):
  Aloque memória para o font info.
  Atribua o font ao font desta font info.
  Obtenha um outlinetextmetric usando o font.
  Atribua 32 ao flags deste font info. \ could ser updated com um more information
  Atribua o tminternalleading destes otmtextmetrics deste outlinetextmetric ao internal leading desta font info.
  Atribua o otmemsquare deste outlinetextmetric ao emsquare desta font info.
  Atribua o tmascent deste otmtextmetrics deste outlinetextmetric ao ascent desta font info.
  Atribua - o tmdescent deste otmtextmetrics deste outlinetextmetric ao descent desta font info.
  Atribua o otmscapemheight deste outlinetextmetric ao capheight desta font info.
  Atribua o otmitalicangle deste outlinetextmetric ao italicangle desta font info.
  Atribua 0 ao stemv desta font info. \ dont know where para obtenha this desde
  Atribua o otmrcfontbox deste outlinetextmetric ao font caixa desta font info.

Etapas necessárias para que se crie uma font info usando uma font e uma string:
    \ creates larguras based sobre characters em string
  Crie o font info usando a font (basic data).
  Crie as font larguras desta font info usando o font e a string.

Etapas necessárias para que se crie uns font larguras usando um font:
  Aloque memória para o font larguras.
  Atribua o font à font destas font larguras.
  Atribua 256 à contagem destas font larguras.
  Assign o data destes font larguras usando a contagem destas font larguras times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando o font.
  Assign um original abc endereço de memória usando 256 times a magnitude desse abc.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O memory canvas \ Um identificador para o contexto do dispositivo.
    e 
  0 \ O primeiro caractere do grupo de caracteres consecutivos da fonte atual.
    e 
  255 \O último caractere no grupo de caracteres consecutivos da fonte atual.
    e 
  o original abc endereço de memória. \ Um ponteiro para uma matriz de estruturas ABC que recebe as larguras dos caracteres, em unidades lógicas. 
    \Esta matriz deve conter, no mínimo, a mesma quantidade estruturas ABC que a quantidade de caracteres no intervalo especificado pelos parâmetros uFirstChar e uLastChar.
    \ Para mais informações, veja os sistes abaixo: 
    \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-abc
    \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsa
  Destrua o número da fonte of o memory canvas.
  Atribua o original abc endereço de memória a um abc endereço de memória.
  Atribua o data destes font larguras a um endereço numérico.
  Percorra. [o código abaixo]
    Se um contador estiver past 256, pare.
    Atribua o abca deste abc endereço de memória ao conteúdo deste endereço numérico .
    Adicione o abcb deste abc endereço de memória para o conteúdo deste endereço numérico .
    Adicione o abcc deste abc endereço de memória para o conteúdo deste endereço numérico .
    Adicione a magnitude deste abc para o abc endereço de memória.
    Adicione a magnitude deste número para o endereço numérico.
  Repita. [o código acima]
  Unassign o original abc endereço de memória.

Etapas necessárias para que se crie uns font larguras usando uma font e uma string:
  Aloque memória para o font larguras.
  Atribua a font à font destas font larguras.
  Atribua a quantidade de caracteres desta string à contagem destas font larguras.
  Se a string estiver em branco, cancele.
  Atribua a magnitude desse gcpresults ao lstructsize destes gcpresults.
  Atribua a quantidade de caracteres desta string ao nglyphs destes gcpresults.
  Assign o lpdx destes gcpresults usando a quantidade de caracteres desta string times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando a font.
  Call "gdi32.dll" "GetCharacterPlacementA" com 
    O memory canvas 
    e O first endereço de memória do pedaço desta string 
    e A quantidade de caracteres desta string 
    e 0 
    e O endereçamento deste gcpresults 
    e 0.
  Destrua o número da fonte of o memory canvas.
  Atribua o lpdx destes gcpresults ao data destes font larguras.

Etapas necessárias para que se crie um gpbitmap usando um trecho:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "GlobalAlloc" com 
  2 [GMEM_MOVEABLE] 
    e A quantidade de caracteres deste trecho 
    devolvendo um número identificador.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador devolvendo um endereço de memória.
  Copie pedaços desde o first endereço de memória do pedaço deste trecho para o endereço de memória pelo quantidade de caracteres deste trecho.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "ole32.dll" "CreateStreamOnHGlobal" com 
    O número identificador 
    e 1 [TRUE] 
    e O endereçamento desse istream.
  Call "gdiplus.dll" "GdipCreateBitmapFromStream" com 
    O istream 
    e O endereçamento deste gpbitmap 
    devolvendo um número.
  Se o número não for 0, atribua "Não sei como processar este tipo de imagem." ao erro do fluxo de entrada/saída; esvazie o gpbitmap.
  Call o release deste vtable deste istream com o istream.

Etapas necessárias para que se crie um gpimageattributes (grayscale):
  Call "gdiplus.dll" "GdipCreateImageAttributes" com 
    O endereçamento destes gpimageattributes.
  Call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" com 
    O gpimageattributes
   e 0 [ColorAdjustTypeDefault ] 
   e 1 
   e o first deste grayscale cor matrix 
   e 0 
   e 0 [ColorMatrixFlagsDefault].

Etapas necessárias para que se crie o hbrush of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor estiver clear, atribua o null hbrush a um hbrush.
  Se a cor não estiver clear, call "gdi32.dll" "CreateSolidBrush" com 
    O código da cor 
    devolvendo o hbrush.
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O hbrush.

Etapas necessárias para que se crie o número da fonte of um canvas usando um font:
  Converta a font para um número da fonte.
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O número da fonte.

Etapas necessárias para que se crie o hpen of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor estiver clear, atribua o null hpen a um hpen.
  Atribua o tpp times o grossura do pincel a um número.
  Se o canvas for o printer canvas, atribua 1 pixel times o grossura do pincel ao número.
  Se a cor não estiver clear, call "gdi32.dll" "CreatePen" com 
  0 [PS_SOLID] 
    e O número 
    e O código da cor 
    devolvendo o hpen.
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O hpen.

Etapas necessárias para que se crie um hrgn usando uma caixa:
  Isole a caixa.
  Adicione o tpp para o canto inferior direito desta caixa.
  Call "gdi32.dll" "BeginPath" com 
    O quadro atual.
  Call "gdi32.dll" "Rectangle" com 
    O quadro atual 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A coordenada direita desta caixa 
    e A coordenada inferior desta caixa.
  Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual devolvendo o hrgn.

Etapas necessárias para que se crie um hrgn usando um elipse:
  Atribua a caixa desta elipse a uma caixa.
  Call "gdi32.dll" "BeginPath" com 
    O quadro atual.
  Call "gdi32.dll" "Ellipse" com 
    O quadro atual 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A coordenada direita desta caixa 
    e A coordenada inferior desta caixa.
  Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual 
    devolvendo o hrgn.

Etapas necessárias para que se crie um hrgn usando um polígono:
  Se o polígono for inexistente, atribua 0 ao hrgn; exit.
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e A localização endereço de memória deste vértice array 
    e A contagem deste vértice array.
  Call "gdi32.dll" "CreatePolygonRgn" com  \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn
    A localização endereço de memória deste vértice array 
    e A contagem deste vértice array 
    e 2 [WINDING]  \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn#parameters
    devolvendo o hrgn.
  Destrua o vértice array.

Etapas necessárias para que se crie um hrgn usando uma caixa arredondada:
  Se o raio desta caixa arredondada for 0, crie o hrgn usando a caixa arredondada como uma caixa; exit.
  Atribua a caixa arredondada a uma caixa.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "BeginPath" com 
    O quadro atual.
  Call "gdi32.dll" "RoundRect" com 
    O quadro atual 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A coordenada direita desta caixa 
    e A coordenada inferior desta caixa 
    e O diameter 
    e O diameter.
  Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual 
    devolvendo o hrgn.

Etapas necessárias para que se crie um catálogo usando uma contagem de buckets:
  Aloque memória para o catálogo.
  Atribua a contagem de buckets à contagem de buckets deste catálogo.
  Atribua o magnitude desse conjunto de buckets a um largura.
  Atribua a contagem de buckets deste catálogo times o largura a um número.
  Assign o first bucket deste catálogo usando o número.
  Atribua o first bucket deste catálogo mais o número menos o largura ao last bucket deste catálogo.

Etapas necessárias para que se crie o dicionário léxico:
  Aloque memória para o dicionário léxico.
  Crie o catálogo deste dicionário léxico usando 4027.

Etapas necessárias para que se crie o abra handle of um winhttp request:
  Se o winhttp request for inexistente, cancele.
  Converta o nome deste module para um wide string denominado wide module nome e modifique através do caractere NUL.
  Call "winhttp.dll" "WinHttpOpen" com 
    O first endereço de memória do pedaço deste wide module nome 
    e 0 [WINHTTP_ACCESS_TYPE_DEFAULT_PROXY] 
    e 0 [WINHTTP_NO_PROXY_NAME] 
    e 0 [WINHTTP_NO_PROXY_BYPASS] 
    e 0 
    devolvendo o session número identificador desta request deste winhttp.
  Se a session desta request deste winhttp for 0, atribua "Erro. Não foi possível iniciar a conexão." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, crie o endereço completo no sistema de arquivos (pasta)[endereço]; exit.
  Se o endereço completo for file-format, crie o endereço completo no sistema de arquivos (arquivo); exit.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos (pasta)[endereço]:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateDirectoryA" com 
    O first deste endereço completo 
    e 0 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível criar a seguinte pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com 
    O first deste endereço completo 
    e 1073741824 [GENERIC_WRITE] 
    e 0 
    e 0 
    e 1 [CREATE_NEW] 
    e 128 [FILE_ATTRIBUTE_NORMAL] 
    e 0 
    devolvendo um número identificador.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador.
  Limpe o erro do fluxo de entrada/saída.
  Se o número identificador não for -1 [INVALID_HANDLE_VALUE], cancele.
  Atribua "Erro. Não foi possível criar o seguinte arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se crie um imagem:
  Aloque memória para o imagem.

Etapas necessárias para que se crie um imagem usando um trecho:
  Crie um gpbitmap usando o trecho.
  Se o gpbitmap for inexistente, esvazie o imagem; exit.
  Aloque memória para o imagem.
  Atribua o trecho ao data desta imagem.
  Atribua o gpbitmap ao gpbitmap desta imagem.
  Ajuste o imagem (extract caixas desde gpbitmap).

Etapas necessárias para que se crie um imagem usando um gpbitmap:
  Se o gpbitmap for inexistente, esvazie o imagem; exit.
  Aloque memória para o imagem.
  Atribua o gpbitmap ao gpbitmap desta imagem.
  Ajuste o imagem (extract caixas desde gpbitmap).

Etapas necessárias para que se crie um imagem usando um URL:
  Read o URL a um trecho.
  Crie o imagem usando o trecho.

Etapas necessárias para que se crie um polígono:
  Aloque memória para o polígono.

Etapas necessárias para que se crie um quora:
  Aloque memória para o quora.

Etapas necessárias para que se crie um refer:
  Aloque memória para o refer.

Etapas necessárias para que se crie o request handle of um winhttp request using uma URL simplificada:
  Se o winhttp request for inexistente, cancele.
  Converta o endereço de recurso desta URL simplificada a um wide string denominado wide endereço completo e modifique através do caractere NUL.
  Converta "POST" para um wide string denominado wide post string e modifique através do caractere NUL.
  Se o nome do protocolo desta URL simplificada for "https", atribua 8388608 [WINHTTP_FLAG_SECURE] a um secure número.
  Call "winhttp.dll" "WinHttpOpenRequest" com 
    O connection número identificador deste winhttp request 
    e O first deste wide post string 
    e O first deste wide endereço completo 
    e 0 [L"HTTP/1.1"] 
    e 0 [WINHTTP_NO_REFERER] 
    e 0 [WINHTTP_DEFAULT_ACCEPT_TYPES] 
    e O secure número 
    devolvendo o request número identificador deste winhttp request.
  Se o request número identificador deste winhttp request for 0, atribua "Erro ao chamar a função 'WinHttpOpenRequest' da biblioteca 'winhttp.dll'. Não foi possível abrir a requisição." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se crie uma row usando um pedaço:
  Aloque memória para a row.
  Atribua o pedaço à string deste row.

Etapas necessárias para que se crie uma row usando uma string:
  Aloque memória para a row.
  Atribua a string à string deste row.

Etapas necessárias para que se crie um socket usando um host string e um número de porta:
    \ this guy creates e connects, sets erro do fluxo de entrada/saída if existe um problem
  Limpe o erro do fluxo de entrada/saída.
    \ obtenha sockaddr
  Obtenha um sockaddr usando o host.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua 2 [AF_INET ] ao sin_family deste sockaddr.
  Atribua o port ao sin_port deste sockaddr.
    \ crie socket 
  Call "ws2_32.dll" "socket" com 
  2 [AF_INET ] 
    e 1 [SOCK_STREAM ] 
    e 0 [IPPROTO_IP] 
    devolvendo o socket.
  Se o socket for -1, atribua "Erro. Não foi possível criar o soquete." ao erro do fluxo de entrada/saída; exit.
    \ connect socket
  Call "ws2_32.dll" "connect" com 
    O socket 
    e O endereçamento deste sockaddr 
    e A magnitude deste sockaddr 
    devolvendo um result número.
  Se o result número não for 0, atribua "Erro. Falha na conexão com o soquete." ao erro do fluxo de entrada/saída; exit.
    \ abra send timeout 30 seconds
  Call "ws2_32.dll" "setsockopt" com 
    O socket 
    e 65535 
    e 4101 [SO_SNDTIMEO]    \O tempo limite, em milissegundos, para bloquear chamadas enviadas.
    e 30 seconds' endereçamento 
    e 4 devolvendo o result número.
  Se o result número não for 0, atribua "Erro na função 'setsockopt' da biblioteca 'Ws2_32.dll'. Valor do parâmetro optname: SO_SNDTIMEO (4101)." ao erro do fluxo de entrada/saída; exit.
    \ abra receive timeout 30 seconds
  Call "ws2_32.dll" "setsockopt" com 
    O socket 
    e 65535 
    e 4102 [SO_RCVTIMEO (optname)]    \Define o tempo limite, em milissegundos, para bloquear chamadas recebidas.
    e 30 seconds' endereçamento e 
  4 
    devolvendo o result número.
  Se o result número não for 0, atribua "Erro na função 'setsockopt' da biblioteca 'Ws2_32.dll'. Não foi possível definir o tempo limite de recepção. Valor do parâmetro optname: SO_RCVTIMEO (4102) ." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se crie um conjunto de texto usando uma string:
  Aloque memória para o conjunto de texto.
  Atribua a string à string deste conjunto de texto.

Etapas necessárias para que se crie um terminal em uma caixa:
  Aloque memória para o terminal.
  Atribua a caixa à caixa deste terminal.
  Atribua a cor verde ao output cor deste terminal.
  Atribua a cor verde claríssimo ao input cor deste terminal.

Etapas necessárias para que se crie um text:
  Aloque memória para o text.
  Atribua a cor preta ao pincel deste text.
  Atribua a fonte padrão ao font deste text.
  Atribua "left" ao alinhamento deste text.
  Atribua 1/1 à scale deste text.
  Garanta one row no text.
  Reset o origin of o text.
  Reset o caret of o text.
  Desvencilhe-se de o text.

Etapas necessárias para que se crie um vértice:
  Aloque memória para o vértice.

Etapas necessárias para que se crie um vértice array usando uma contagem:
  Isole a contagem.
  Aloque memória para o vértice array.
  Atribua a contagem à contagem deste vértice array.
  Multiplique a contagem pela magnitude desse localização.
  Assign a localização endereço de memória deste vértice array usando a contagem.

Etapas necessárias para que se crie um vértice array usando uns vértices:
  Crie o vértice array usando a contagem destes vértices.
  Atribua a localização endereço de memória deste vértice array a uma localização endereço de memória.
  Percorra. [o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Atribua a localização deste vértice ao conteúdo desta localização endereço de memória.
    Adicione a magnitude desta localização deste vértice para a localização endereço de memória.
  Repita. [o código acima]

Etapas necessárias para que se crie um vértice usando uma localização:
  Aloque memória para o vértice.
  Atribua a localização à localização deste vértice.

Etapas necessárias para que se crie um vértice usando uma coordenada X e uma coordenada Y:
  Aloque memória para o vértice.
  Atribua a coordenada X à coordenada x deste vértice.
  Atribua a coordenada Y à coordenada y deste vértice.

Etapas necessárias para que se crie um winhttp request por posting para um URL:
  Aloque memória para o winhttp request.
  Converta o URL para uma URL simplificada.
  Crie o abra handle of o winhttp request.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
  Crie o connect handle of o winhttp request using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
  Crie o request handle of o winhttp request using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.

O console é um console.

O texto CRLF é uma string igual a $0D0A.

O quadro atual é um canvas.

O evento atual é um event.

O número atual da cor do arco-íris é um número [esse número vai de 1 a 6 indicando, respectivamente, vermelho, laranja, amarelo, verde, azul, roxo].

Um cursor é um número identificador.

Etapas necessárias para que se corte um número pela metade:
  Divida o número por 2.

Etapas necessárias para que se darken uma cor por um quantia:
  Subtraia o quantia desde a luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se darken uma cor por uns percent;
Etapas necessárias para que se darken uma cor about uns percent;
Etapas necessárias para que se darken uma cor por about uns percent;
Etapas necessárias para que se darken uma cor uns percent:
  Atribua a luminosidade desta cor menos o percent à luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se darken o current cor about uns percent:
  Darken a cor deste context pelo percent.

Um date/time é um conjunto com
  Um year número,
  Um month número,
  Um week day número,
  Um day número,
  Um hour número,
  Um minute número,
  Um second número,
  Um millisecond número.

Etapas necessárias para que se de-sign um fração:
  De-sign o numerador desta fração.
  De-sign o denominador desta fração.

Etapas necessárias para que se de-sign um número:
  Se o número for o menor número, atribua o maior número ao número; exit.
  Se o número for menor do que 0, negate o número.

Etapas necessárias para que se de-sign um par de números:
  De-sign o número X deste par de números.
  De-sign o número Y deste par de números.

Etapas necessárias para que se de-sign uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço desta string for tipo de sinal aritmético, remove o first pedaço desde a string.

Um relatório de informações é uma string.
Um relatório de bugs é uma string.
Um relatório de erros é uma string.

Etapas necessárias para que se produza o relatório de bugs usando uma caixa;
Etapas necessárias para que se produza o relatório de erros usando uma caixa;
Etapas necessárias para que se produza o relatório de informações usando uma caixa:
  Limpe uma string.
  Posponha "Coordenada esquerda = " para a string.
  Posponha a coordenada esquerda desta caixa para a string.
  Posponha ", Coordenada superior = " para a string.
  Posponha a coordenada superior desta caixa para a string.
  Posponha ", Coordenada direita = " para a string.
  Posponha a coordenada direita desta caixa para a string.
  Posponha ", Coordenada inferior = " para a string.
  Posponha a coordenada inferior desta caixa para a string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de erros usando um pedaço;
Etapas necessárias para que se produza o relatório de bugs usando um pedaço;
Etapas necessárias para que se produza o relatório de informações usando um pedaço:
  Atribua o pedaço a um número.
  Converta o número para uma string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de erros usando uma cor;
Etapas necessárias para que se produza o relatório de bugs usando uma cor;
Etapas necessárias para que se produza o relatório de informações usando uma cor:
  Limpe uma string.
  Posponha "Matiz = " para a string.
  Posponha a matiz desta cor para a string.
  Posponha ", Saturação = " para a string.
  Posponha a saturação desta cor para a string.
  Posponha ", Luminosidade = " para a string.
  Posponha a luminosidade desta cor para a string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de erros usando um detector;
Etapas necessárias para que se produza o relatório de bugs usando um detector;
Etapas necessárias para que se produza o relatório de informações usando um detector:
  Converta o detector para uma string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de bugs usando uma font:
Etapas necessárias para que se produza o relatório de erros usando uma font;
Etapas necessárias para que se produza o relatório de informações usando uma font:
  Limpe uma string.
  Posponha " Nome da fonte = '" para a string seguido de "'".
  Posponha o nome desta font para a string.
  Posponha ", Tamanho da fonte = " para a string.
  Posponha a altura desta font para a string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de erros usando uma fração;
Etapas necessárias para que se produza o relatório de bugs usando uma fração;
Etapas necessárias para que se produza o relatório de informações usando uma fração:
  Limpe uma string.
  Posponha "Numerador = " para a string.
  Posponha o numerador desta fração para a string.
  Posponha ", Denominador = " para a string.
  Posponha o denominador desta fração para a string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de bugs usando uma line;
Etapas necessárias para que se produza o relatório de erros usando uma line;
Etapas necessárias para que se produza o relatório de informações usando uma line:
  Limpe uma string.
  Posponha " Começo da linha = " para a string.
  Posponha a coordenada X deste start desta line para a string.
  Posponha "," para a string.
  Posponha a coordenada Y deste start desta line para a string.
  Posponha " Fim da linha = " para a string.
  Posponha a coordenada X deste end desta line para a string.
  Posponha "," para a string.
  Posponha a coordenada Y deste end desta line para a string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de falhas usando um número;
Etapas necessárias para que se produza o relatório de panes usando um número;
Etapas necessárias para que se produza o relatório de erros usando um número;
Etapas necessárias para que se produza o relatório de bugs usando um número;
Etapas necessárias para que se produza o relatório de informações usando um número:
  Converta o número para uma string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de erros usando um número e um segundo número;
Etapas necessárias para que se produza o relatório de falhas usando um número e um segundo número;
Etapas necessárias para que se produza o relatório de panes usando um número e um segundo número;
Etapas necessárias para que se produza o relatório de bugs usando um número e um segundo número;
Etapas necessárias para que se produza o relatório de informações usando um número e um segundo número:
  Produza o relatório de informações usando o número seguido de ", " junto com o segundo número.

Etapas necessárias para que se produza o relatório de falhas usando um par de números;
Etapas necessárias para que se produza o relatório de panes usando um par de números;
Etapas necessárias para que se produza o relatório de erros usando um par de números;
Etapas necessárias para que se produza o relatório de bugs usando um par de números;
Etapas necessárias para que se produza o relatório de informações usando um par de números:
  Limpe uma string.
  Posponha "Coordenada X = " para a string.
  Posponha o número X deste par de números para a string.
  Posponha ", Coordenada Y = " para a string.
  Posponha o número Y deste par de números para a string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de panes usando um endereço de memória;
Etapas necessárias para que se produza o relatório de falhas usando um endereço de memória;
Etapas necessárias para que se produza o relatório de erros usando um endereço de memória;
Etapas necessárias para que se produza o relatório de bugs usando um endereço de memória;
Etapas necessárias para que se produza o relatório de informações usando um endereço de memória:
  Converta o endereço de memória para um cifra hexadecimal.
  Produza o relatório de informações usando "$" junto com o cifra hexadecimal.
  Produza o relatório de informações usando "0x" junto com o cifra hexadecimal.

Etapas necessárias para que se produza o relatório de panes usando um espaço de cor RGB;
Etapas necessárias para que se produza o relatório de falhas usando um espaço de cor RGB;
Etapas necessárias para que se produza o relatório de erros usando um espaço de cor RGB;
Etapas necessárias para que se produza o relatório de bugs usando um espaço de cor RGB;
Etapas necessárias para que se produza o relatório de informações usando um espaço de cor RGB:
  Limpe uma string.
  Posponha "Vermelho = " para a string. Atribua o espectro vermelho deste espaço de cor RGB a um número.
  Posponha o número para a string.
  Posponha ", Verde = " para a string. Atribua o espectro verde deste espaço de cor RGB ao número.
  Posponha o número para a string.
  Posponha ", Azul = " para a string. Atribua o espectro azul deste espaço de cor RGB ao número.
  Posponha o número para a string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de falhas usando uma string;
Etapas necessárias para que se produza o relatório de panes usando uma string;
Etapas necessárias para que se produza o relatório de erros usando uma string;
Etapas necessárias para que se produza o relatório de bugs usando uma string;
Etapas necessárias para que se produza o relatório de informações usando uma string:
  Isole a string.
  Modifique através do caractere NUL a string.
  Call "user32.dll" "MessageBoxA" com 
  0 
    e O first endereço de memória do pedaço desta string 
    e "debug"'s first endereço de memória do pedaço 
    e 0. 
    \\  Chame função "MessageBoxA" contida na biblioteca "user32.dll" informando os parâmetros a seguir: 0, o primeiro caractere do texto em questão, o primeiro caractere do "debug" e 0.

Etapas necessárias para que se produza o relatório de erros usando uma string (quoted);
Etapas necessárias para que se produza o relatório de bugs usando uma string (quoted);
Etapas necessárias para que se produza o relatório de informações usando uma string (quoted):
  Isole a string.
  Anteponha as aspas duplas para a string.
  Posponha as aspas duplas para a string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se produza o relatório de erros usando um word;
Etapas necessárias para que se produza o relatório de bugs usando um word;
Etapas necessárias para que se produza o relatório de informações usando um word:
  Atribua o word a um número.
  Converta o número para uma string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se determine se uma caixa é uma segunda caixa:
  Se a coordenada esquerda desta caixa não for a coordenada esquerda desta segunda caixa, diga não.
  Se a coordenada superior desta caixa não for a coordenada superior desta segunda caixa, diga não.
  Se a coordenada direita desta caixa não for a coordenada direita desta segunda caixa, diga não.
  Se a coordenada inferior desta caixa não for a coordenada inferior desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma caixa está still em uma segunda caixa;
Etapas necessárias para que se determine se uma caixa está em uma segunda caixa;
Etapas necessárias para que se determine se uma caixa está inside uma segunda caixa:
  Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda desta segunda caixa, diga não.
  Se a coordenada superior desta caixa for menor do que a coordenada superior desta segunda caixa, diga não.
  Se a coordenada direita desta caixa for maior do que a coordenada direita desta segunda caixa, diga não.
  Se a coordenada inferior desta caixa for maior do que a coordenada inferior desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma caixa está touching uma segunda caixa:
  Se a coordenada direita desta segunda caixa for menor do que a coordenada esquerda desta caixa, diga não.
  Se a coordenada inferior desta segunda caixa for menor do que a coordenada superior desta caixa, diga não.
  Se a coordenada esquerda desta segunda caixa for maior do que a coordenada direita desta caixa, diga não.
  Se a coordenada superior desta segunda caixa for maior do que a coordenada inferior desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um pedaço é alfanumérico:
  Se o pedaço for algum tipo de letra, diga sim.
  Se o pedaço for algum tipo de digit, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o outro byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8406000000. \ je over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é um segundo pedaço ou um terceiro pedaço:
  Se o pedaço for o segundo pedaço, diga sim.
  Se o pedaço for o terceiro pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é alguma consoante:
  Se o pedaço estiver em "bcdfghjklmnpqrstvwxyzçñ", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de digit:
  Se o pedaço for menor do que o número zero, diga não.
  Se o pedaço for maior do que o número nove, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um pedaço é algum tipo de letra:
  Se o pedaço estiver entre o 'A' maiúsculo e o Z maiúsculo, diga sim.
  Se o pedaço estiver entre o 'a' minúsculo e o z minúsculo, diga sim.
  Se o pedaço for 131 ou 138, diga sim.
  Se o pedaço for 140 ou 142, diga sim.
  Se o pedaço for 154 ou 156, diga sim.
  Se o pedaço estiver entre 158 e 159, diga sim.
  Se o pedaço estiver entre 192 e 214, diga sim.
  Se o pedaço estiver entre 216 e 246, diga sim.
  Se o pedaço estiver entre 248 e 255, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de indicador numérico:
  Se o pedaço é algum tipo de digit, diga sim.
  Se o pedaço é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de sinal de pontuação:
    \ precisa ser aprimorado
  Se o pedaço for o caractere de espaço, diga não.
  Se o pedaço não for alfanumérico, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é tipo de sinal aritmético:
  Se o pedaço for o sinal de adição, diga sim.
  Se o pedaço for o sinal de subtração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de unidade de disco válida:
  Atribua o pedaço a um endereço completo.
  Posponha ":\" para o endereço completo.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Se a categoria da unidade de disco for "", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um pedaço é algum tipo de vogal:
  Se o pedaço estiver em "aeiouyáéíóúýãõäëïöüÿâêîôûàèìòù", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço está entre um segundo pedaço e um terceiro pedaço:
  Se o pedaço for menor do que o segundo pedaço, diga não.
  Se o pedaço for maior do que o terceiro pedaço, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um pedaço está entre um número e um segundo número:
  Se o pedaço for menor do que o número, diga não.
  Se o pedaço for maior do que o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um pedaço é maior que um segundo pedaço;
Etapas necessárias para que se determine se um pedaço é maior do que um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8706000000. \ ja over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é maior que um número;
Etapas necessárias para que se determine se um pedaço é maior do que um número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8F06000000. \ jg over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é maior do que ou igual para um segundo pedaço;
Etapas necessárias para que se determine se um pedaço é maior que ou igual para um segundo pedaço;
Etapas necessárias para que se determine se um pedaço é maior ou igual para um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8306000000. \ ja over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço estiver em uma string:
  Isole o pedaço.
  Lowercase o pedaço.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga não.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um segundo pedaço.
    Lowercase o segundo pedaço.
    Se o segundo pedaço é o pedaço, diga sim.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se determine se um pedaço é menor que um segundo pedaço;
Etapas necessárias para que se determine se um pedaço é menor do que um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8206000000. \ jb over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é menor que um número;
Etapas necessárias para que se determine se um pedaço é menor do que um número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8C06000000. \ jl over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é menor do que ou igual para um segundo pedaço;
Etapas necessárias para que se determine se um pedaço é menor que ou igual para um segundo pedaço;
Etapas necessárias para que se determine se um pedaço é menor ou igual para um segundo pedaço:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $8A1B. \ mov bl,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ a segunda byte
  Intel $3A19. \ cmp bl,[ecx]
  Intel $0F8606000000. \ jbe over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é like um segundo pedaço:
    \ used internally por palavra wrap
  Se o pedaço é whitespace, acione um detector.
  Se o segundo pedaço é whitespace, acione uma segundo detector.
  Se o detector é a segundo detector, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é irrelevante:
  Se o pedaço for menor do que ou igual ao caractere de espaço, diga sim.
  Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga sim.
  Se o pedaço for o espaço rígido, diga sim.
  Se o pedaço for 129, diga sim.
  Se o pedaço for 141, diga sim.
  Se o pedaço for 143, diga sim.
  Se o pedaço for 144, diga sim.
  Se o pedaço for 157, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é um número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8406000000. \ je over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é um número ou um segundo número:
  Se o pedaço for o número, diga sim.
  Se o pedaço for o segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é printable:
  Se o pedaço for menor do que o caractere de espaço, diga não.
  Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga não.
  Se o pedaço for 129, diga não.
  Se o pedaço for 141, diga não.
  Se o pedaço for 143, diga não.
  Se o pedaço for 144, diga não.
  Se o pedaço for 157, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um pedaço é uma string:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Isole o pedaço.
  Lowercase o pedaço.
  Atribua o conteúdo deste first endereço de memória do pedaço desta string a um segundo pedaço.
  Lowercase o segundo pedaço.
  Se o pedaço for o segundo pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é symbolic:
  Se o pedaço estiver entre o ponto de exclamação e o slash pedaço, diga sim.
  Se o pedaço estiver entre o sinal de dois pontos e o sinal de arroba, diga sim.
  Se o pedaço estiver entre o colchete esquerdo e o acento grave, diga sim.
  Se o pedaço estiver entre o chave esquerda e o acento til, diga sim.
  Se o pedaço for 128, diga sim.
  Se o pedaço for 130, diga sim.
  Se o pedaço estiver entre 132 e 137, diga sim.
  Se o pedaço for 139, diga sim.
  Se o pedaço estiver entre 145 e 153, diga sim.
  Se o pedaço for 155, diga sim.
  Se o pedaço estiver entre 161 e 180, diga sim.
  Se o pedaço estiver entre 183 e 191, diga sim.
  Se o pedaço for 215, diga sim.
  Se o pedaço for 247, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um pedaço é whitespace:
  Se o pedaço for o caractere de espaço, diga sim.
  Se o pedaço for o tabulação horizontal, diga sim.
  Se o pedaço for o return pedaço, diga sim.
  Se o pedaço for o linefeed pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se o caret of um text é at o beginning:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for 1, diga não.
  Se o caret column# deste text não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se o caret of um text é at o end:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for a contagem destas rows deste text, diga não.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text não for a quantidade de caracteres desta string desta row, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se o caret of um text está sobre o first line:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se o caret of um text está sobre o last line:
  Se o text for inexistente, diga não.
  Se as rows deste text estiverem vazio, diga não.
  Se o número de linhas do cursor deste text não for o número da linha desta last row deste text, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma choice é uma string:
  Se a choice for inexistente, diga não.
  Se o nome desta choice for a string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma cor e uma segunda cor estão clear:
  Se a cor não estiver clear, diga não.
  Se a segunda cor não estiver clear, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma cor é uma segunda cor:
  Se a matiz desta cor não for a matiz desta segunda cor, diga não.
  Se a saturação desta cor não for a saturação desta segunda cor, diga não.
  Se a luminosidade desta cor não for a luminosidade desta segunda cor, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma cor está clear:
  Se a matiz desta cor for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma cor é dark:
  Se a luminosidade desta cor estiver entre 250 e 374, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma cor é light:
  Se a luminosidade desta cor estiver entre 625 e 749, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma cor é normal:
  Se a luminosidade desta cor estiver entre 375 e 624, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma cor é very dark:
  Se a luminosidade desta cor estiver entre 125 e 249, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma cor é very light:
  Se a luminosidade desta cor estiver entre 750 e 874, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma cor é very very dark:
  Se a luminosidade desta cor for menor do que ou igual para 124, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma cor é very very light:
  Se a luminosidade desta cor for maior do que ou igual para 875, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um contador é past um número:
  Adicione 1 para o contador.
  Se o contador for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se o current localização está above ou below uma caixa:
  Se a localização deste context é above ou below a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se o current localização está left ou right of uma caixa:
  Se a localização deste context é left ou right of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se o current localização está para o right of uma caixa:
  Se a coordenada X desta localização deste context for maior do que a coordenada direita desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se o current localização está within uns twips of uma caixa:
  Se a localização deste context estiver within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um difference está within um malha:
  Isole a difference.
  De-sign a difference.
  Se o número X desta difference for maior do que ou igual ao número X desta malha, diga não.
  Se o número Y desta difference for maior do que ou igual ao número Y desta malha, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um event é algum tipo de atalho de tecla:
  Se o event for inexistente, diga não.
  Se a categoria deste event não for "pressionamento de tecla", diga não.
  Se o event não foi alterado, diga não.
  Se a tecla deste event estiver entre a tecla A/a e a tecla Z/z, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um event foi alterado:
  Se o detector de tecla ctrl deste event estiver ativo, diga sim.
  Se o detector de tecla alt deste event estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um finger é past o end of uma string:
  Se o finger for inexistente, diga sim.
  Se o finger for maior do que o last endereço de memória do pedaço desta string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um detector é um número;
Etapas necessárias para que se determine se um detector é um segundo detector;
Etapas necessárias para que se determine se um endereço de memória é um número;
Etapas necessárias para que se determine se um endereço de memória é um segunda endereço de memória;
Etapas necessárias para que se determine se um número é um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8406000000. \ je over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

    \Etapas necessárias para que se determine se um detector está on:
    \ switch como uma segunda nome por detector also ? ***
    \Se o detector estiver ativo, diga sim.
    \[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um detector está presente;
Etapas necessárias para que se determine se um detector está em vigor;
Etapas necessárias para que se determine se um detector está levantada;
Etapas necessárias para que se determine se um detector está ligado; \foi ligado também funciona
Etapas necessárias para que se determine se um detector está ativo;
Etapas necessárias para que se determine se um detector está ativado; \foi ativado
    \Etapas necessárias para que se determine se um detector já está ativado;
Etapas necessárias para que se determine se um detector já foi ativado anteriomente;
    \Etapas necessárias para que se determine se um detector foi ativado anteriomente;
Etapas necessárias para que se determine se um detector está tocando;
Etapas necessárias para que se determine se um detector está soando;
Etapas necessárias para que se determine se um detector soou;
    \Etapas necessárias para que se determine se um detector já soou;
Etapas necessárias para que se determine se um detector está disparando;
    \Etapas necessárias para que se determine se um detector disparou;
Etapas necessárias para que se determine se um detector está alarmando;
    \Etapas necessárias para que se determine se um detector disparou;
Etapas necessárias para que se determine se um detector está sendo mostrada;
Etapas necessárias para que se determine se um detector está sendo exibida;
Etapas necessárias para que se determine se um detector está verde:
  Se o detector for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um detector está dormente;
Etapas necessárias para que se determine se um detector está suspenso;
Etapas necessárias para que se determine se um detector está inativo;
Etapas necessárias para que se determine se um detector está desligado;
Etapas necessárias para que se determine se um detector está desativado;
Etapas necessárias para que se determine se um detector está vermelho:
  Se o detector for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma fração é uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração é o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma fração é maior que uma segunda fração;
Etapas necessárias para que se determine se uma fração é maior do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma fração é maior do que ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma fração é menor que uma segunda fração;
Etapas necessárias para que se determine se uma fração é menor do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma fração for menor do que ou igual para uma segunda fração;
Etapas necessárias para que se determine se uma fração for menor que ou igual para uma segunda fração;
Etapas necessárias para que se determine se uma fração for menor ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma fração é negative:
  Se o numerador desta fração for menor do que 0, reverse um detector.
  Se o denominador desta fração for menor do que 0, reverse o detector.
    \ Say o detector. \ does not work em SAL; no detector literals anymore
  Se o detector estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma fração é um número:
  Se a fração é o número / 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um catálogo está vazia;
Etapas necessárias para que se determine se um catálogo estão vazias;
Etapas necessárias para que se determine se um catálogo estão vazios;
Etapas necessárias para que se determine se um catálogo está vazio:
  Se o catálogo for inexistente, diga sim.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, diga sim.
    Se os refers deste bucket não estiverem vazio, diga não.
  Repita. [o código acima]

Etapas necessárias para que se determine se um input é um clique:
  Esvazie o clique.
  Se a categoria deste input não for "clique", diga não.
  Atribua o input ao clique.

Etapas necessárias para que se determine se um item é found:
  Se a categoria deste item não estiver em branco, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de digit tecla:
  Se a tecla estiver entre 48 e 57, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de letra tecla:
  Se a tecla estiver entre 65 e 90, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de modifier tecla:
  Se a tecla for a tecla Alt, diga sim.
  Se a tecla for a tecla Ctrl, diga sim.
  Se a tecla for a tecla Shift ,say yes.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de pad tecla:
  Se a tecla estiver entre 96 e 111, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de printable tecla:
  Se a tecla for o barra de espaço, diga sim.
  Se a tecla for algum tipo de digit tecla, diga sim.
  Se a tecla for algum tipo de letra tecla, diga sim.
  Se a tecla for algum tipo de pad tecla, diga sim.
  Se a tecla for algum tipo de symbol tecla, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de symbol tecla:
  Se a tecla estiver entre 186 e 192, diga sim.
  Se a tecla estiver entre 219 e 222, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla é algum tipo de wm-char tecla:
  Se a tecla não for algum tipo de printable tecla , diga não.
  Se a tecla Alt was para baixo, diga não.
  Se a tecla Ctrl was para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma tecla está sendo pressionada:
  Call "user32.dll" "GetAsyncKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla está sendo pressionado:
  Call "user32.dll" "GetAsyncKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla was para baixo:
  Call "user32.dll" "GetKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla was toggled:
  Call "user32.dll" "GetKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Conjuncione logicamente o número com 1.
  Se o número for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma tecla was para cima:
  Se a tecla was para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma tecla com um l-param é algum tipo de repeated escape ou modifier tecla:
  Atribua o l-param a um número.
  Conjuncione logicamente o número com 1073741824 [$40000000].
  Se o número for 0, diga não.
  Se a tecla for a tecla Esc, diga sim.
  Se a tecla for algum tipo de modifier tecla, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se o left mouse botão está para baixo:
  Se o botão esquerdo deste mouse estiver sendo pressionado, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um line está above uma caixa:
  Se o y deste start desta line for maior do que ou igual à coordenada superior desta caixa, diga não.
  Se o y deste end desta line for maior do que ou igual à coordenada superior desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um line está above uma coordenada:
  Se o y deste start desta line for maior do que ou igual à coordenada, diga não.
  Se o y deste end desta line for maior do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um line está below uma caixa:
  Se o y deste start desta line for menor do que ou igual à coordenada inferior desta caixa, diga não.
  Se o y deste end desta line for menor do que ou igual à coordenada inferior desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um line está below uma coordenada:
  Se o y deste start desta line for menor do que ou igual à coordenada, diga não.
  Se o y deste end desta line for menor do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um line está still em uma caixa;
Etapas necessárias para que se determine se um line estiver em uma caixa:
  Se o start desta line não estiver na caixa, diga não.
  Se o end desta line não estiver na caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um mixed é um número:
  Converta o mixed para um fração.
  Se a fração for o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se o mouse has been dragged desde uma localização usando um malha:
  Se o botão esquerdo deste mouse não estiver sendo pressionado, diga não.
  Atribua a localização deste mouse a uma segunda localização.
  Obtenha um difference between a segunda localização e a localização.
  Se a difference estiver within a malha, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se o mouse estiver em uma caixa:
  Se a localização deste mouse estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um número é um segundo número e uma string é uma segunda string:
  Se o número não for o segundo número, diga não.
  Se a string não for a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um número está entre um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, diga não.
  Se o número for maior do que o terceiro número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um número é par:
  Se o número é ímpar, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um número é uniformemente divisível por um segundo número:
  Isole o número.
  Divida o número pelo segundo número usando um quotient e um resto.
  Se o resto for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um número é um múltiplo of um segundo número:
  Se o número for uniformemente divisível pelo segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um número é negative:
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um número é ímpar:
  Isole o número.
  Conjuncione logicamente o número com 1.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um número é positive:
  Se o número for menor do que 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um número é prime:
  Se o número for menor do que 2, diga não.
  Se o número for 2, diga sim.
  Atribua o número menos 1 a um segundo número.
  Percorra. [o código abaixo]
    Se o número é uniformemente divisível pelo segundo número, diga não.
    Subtraia 1 desde o segundo número.
    Se o segundo número for maior do que 1, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um par de números é uma segunda par de números:
  Se o número X deste par de números não for o número X desta segunda par de números, diga não.
  Se o número Y deste par de números não for o número Y desta segunda par de números, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um par de números é um número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um par de números é um número e um segundo número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um endereço completo é endereço da pasta-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste last deste endereço completo for a barra invertida, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um endereço completo é drive-format:
  Se o endereço completo começa com "\\", diga sim.
  Se a quantidade de caracteres deste endereço completo não for 3, diga não.
  Se o endereço completo termina com ":\", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um endereço completo está vazia no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo estão vazias no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo estão vazios no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo está vazio no sistema de arquivos:
  Se o endereço completo não estiver no sistema de arquivos, diga sim.
  Obtenha uma contagem of items no endereço completo no sistema de arquivos.
  Se a contagem for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um endereço completo é file-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste last deste endereço completo for o sinal de dois pontos, diga não.
  Se o conteúdo deste last deste endereço completo for a barra invertida, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um endereço completo está no sistema de arquivos:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Se o número for menor do que 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um endereço completo é read-only:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Conjuncione logicamente o número com 1 [FILE_ATTRIBUTE_READONLY].
  Se o número não for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um endereço de memória pode ser found;
Etapas necessárias para que se determine se um endereço de memória está coming;
    \Etapas necessárias para que se determine se um endereço de memória é found;
Etapas necessárias para que se determine se um endereço de memória foi found;
Etapas necessárias para que se determine se um endereço de memória existe;
Etapas necessárias para que se determine se um endereço de memória does exist:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um endereço de memória é maior do que um segundo endereço de memória;
Etapas necessárias para que se determine se um número é maior do que um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8F06000000. \ jg over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é maior do que ou igual para um segundo endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é maior que ou igual para um segundo endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é maior ou igual para um segundo endereço de memória;
Etapas necessárias para que se determine se um número é um segundo número ou more;
Etapas necessárias para que se determine se um número é maior do que ou igual para um segundo número;
Etapas necessárias para que se determine se um número é maior que ou igual para um segundo número;
Etapas necessárias para que se determine se um número é maior ou igual para um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8D06000000. \ jge over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é menor do que um segundo endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor que um segundo endereço de memória;
Etapas necessárias para que se determine se um número é menor que um segundo número;
Etapas necessárias para que se determine se um número é menor do que um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8C06000000. \ jl over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é menor do que ou igual para um segundo endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor que ou igual para um segundo endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor ou igual para um segundo endereço de memória;
Etapas necessárias para que se determine se um número é um segundo número ou menos;
Etapas necessárias para que se determine se um número é um segundo número ou menor;
Etapas necessárias para que se determine se um número é menor do que ou igual para um segundo número;
Etapas necessárias para que se determine se um número é menor que ou igual para um segundo número;
Etapas necessárias para que se determine se um número é menor ou igual para um segundo número:
  Intel $C7C001000000. \ mov eax,1 \ assume true
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8B1B. \ mov ebx,[ebx]
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segundo número
  Intel $3B19. \ cmp ebx,[ecx]
  Intel $0F8E06000000. \ jle over o next 1 statement
  Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é missing;
Etapas necessárias para que se determine se um endereço de memória é null e esvazie:
  Se o endereço de memória for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um polígono está closed:
  Se o polígono for inexistente, diga não.
  Se a contagem destes vértices deste polígono for menor do que 3, diga não.
  Se a localização deste first vértice deste polígono for a localização deste last vértice deste polígono, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um reply é something like uma segunda reply:
  Isole o reply.
  Isole a segunda reply.
  Simplify o reply.
  Simplify a segunda reply.
  Se o reply é a segunda reply, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma row está em branco:
  Se a row for inexistente, diga sim.
  Lance um subtexto sobre a string deste row.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se determine se uma row of um text está selecionado:
  Se o text for inexistente, diga não.
  Se a row for inexistente, diga não.
  Se nada estiver selecionado no text, diga não.
  Atribua a normalized seleção deste text a uma seleção.
  Se o número da linha desta row for menor do que o anchor número da linha desta seleção, diga não.
  Se o número da linha desta row for maior do que o número de linhas do cursor desta seleção, diga não.
  Se o número da linha desta row não for o número de linhas do cursor desta seleção, diga sim.
  Se o caret column# desta seleção for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma row of um text é visível:
  Se o text for inexistente, diga não.
  Se a row for inexistente, diga não.
  Obtenha uma caixa usando a row e o text.
  Atribua a caixa deste text a uma segunda caixa.
  Ajuste a segunda caixa usando 0 e o tpp e 0 e - o tpp.
  Se a caixa estiver touching a segunda caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma seleção é uma segunda seleção:
  Se o anchor desta seleção não for o anchor desta segunda seleção, diga não.
  Se o caret desta seleção não for o caret desta segunda seleção, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se something está selecionado em um text:
  Se o anchor deste text for o caret deste text, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização é above uma caixa:
  Se a coordenada Y desta localização for menor do que a coordenada superior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização é above um horizontal line:
  Se a coordenada Y desta localização for menor do que o horizontal y deste start desta line, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização é above ou below uma caixa:
  Se a localização é above a caixa, diga sim.
  Se a localização é below a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização é below uma caixa:
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização é below um horizontal line:
  Se a coordenada Y desta localização for maior do que o horizontal y deste start desta line, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está em um elipse:
  Crie um hrgn usando a elipse.
  Isole a localização.
  Divida a localização pelo tpp.
  Call "gdi32.dll" "PtInRegion" com 
    O hrgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Destrua o hrgn.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização está em um imagem:
  Se o imagem for inexistente, diga não.
  Se a localização estiver na caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está em um polígono:
  Se o polígono for inexistente, diga não.
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "CreatePolygonRgn" com 
    A localização endereço de memória deste vértice array 
    e A contagem deste vértice array 
    e 2 [WINDING] devolvendo um hrgn.
  Call "gdi32.dll" "PtInRegion" com 
    O hrgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Call "gdi32.dll" "DeleteObject" com 
    O hrgn.
  Destrua o vértice array.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização está em uns polígonos:
  Obtenha um polígono desde o polígonos.
  Se o polígono for inexistente, diga não.
  Se a localização estiver no polígono, diga sim.
  Repita. [o código acima]

Etapas necessárias para que se determine se uma localização está em uma caixa arredondada:
  Isole a caixa arredondada.
  Adicione o tpp para a canto inferior direito desta caixa arredondada.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "CreateRoundRectRgn" com 
    A coordenada esquerda desta caixa arredondada 
    e A coordenada superior desta caixa arredondada 
    e A coordenada direita desta caixa arredondada 
    e A coordenada inferior desta caixa arredondada 
    e O diameter 
    e O diameter 
    devolvendo um hrgn.
  Call "gdi32.dll" "PtInRegion" com 
    O hrgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Call "gdi32.dll" "DeleteObject" com 
    O hrgn.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização está em um text:
  Se o text for inexistente, diga não.
  Se a localização estiver na caixa deste text, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está inside uma caixa;
Etapas necessárias para que se determine se uma localização está within uma caixa;
Etapas necessárias para que se determine se uma localização está em uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada esquerda desta caixa, diga não.
  Se a coordenada Y desta localização for menor do que a coordenada superior desta caixa, diga não.
  Se a coordenada X desta localização for maior do que a coordenada direita desta caixa, diga não.
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização está para o left of uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada esquerda desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está left ou right of uma caixa:
  Se a localização é para o left of a caixa, diga sim.
  Se a localização é para o right of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está sobre uma caixa:
  Atribua a caixa a uma segunda caixa.
  Atribua 2 times o tpp a um número.
  Outdent a segunda caixa usando o número.
  Se a localização não estiver no segunda caixa, diga não.
  Atribua a caixa a um terceiro caixa.
  Atribua 3 times o tpp a um segundo número.
  Indent o terceiro caixa usando o segundo número.
  Se a localização estiver no terceiro caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização está sobre uma elipse:
  Atribua a elipse a uma segunda elipse.
  Atribua 2 times o tpp a um número.
  Outdent a caixa desta segunda elipse usando o número.
  Se a localização não estiver na segunda elipse, diga não.
  Atribua a elipse a uma terceiro elipse.
  Atribua 3 times o tpp a um segundo número.
  Indent a caixa desta terceiro elipse usando o segundo número.
  Se a localização estiver na terceiro elipse, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização está sobre uma line:
  Isole a line.
  Atribua 3 times o tpp a um número.
  Percorra. [o código abaixo]
    Obtenha uma distance between a localização e o center desta line (chessboard).
    Se a distance for menor do que ou igual ao número, diga sim.
    Obtenha a distance between a start desta line e o end desta line (chessboard).
    Se a distance for menor do que ou igual ao tpp, diga não.
    Split a line à line e uma segunda line.
    Obtenha a distance between a localização e o center desta line (chessboard).
    Obtenha uma segunda distance between a localização e o center desta segunda line (chessboard).
    Se a distance for maior do que a segunda distance, atribua a segunda line ao line.
  Repita. [o código acima]

Etapas necessárias para que se determine se uma localização está sobre um imagem:
  Se o imagem for inexistente, diga não.
  Se a localização estiver sobre a caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está sobre um polígono:
  Se o polígono for inexistente, diga não.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, diga não.
    Se o next deste vértice for inexistente, diga não.
    Atribua a localização deste vértice e a localização deste next deste vértice a um line.
    Se a localização estiver sobre o line, diga sim.
  Repita. [o código acima]

Etapas necessárias para que se determine se uma localização está sobre uma caixa arredondada:
  Atribua a caixa arredondada a uma segunda caixa arredondada.
  Atribua 2 times o tpp a um número.
  Outdent a segunda caixa arredondada usando o número.
  Se a localização não estiver no segunda caixa arredondada, diga não.
  Atribua a caixa arredondada a um terceiro caixa arredondada.
  Atribua 3 times o tpp a um segundo número.
  Indent o terceiro caixa arredondada usando o segundo número.
  Se a localização estiver no terceiro caixa arredondada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização é outside uma caixa:
  Se a localização é inside a caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma localização é para o right of uma caixa:
  Se a coordenada X desta localização for maior do que a coordenada direita desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização é touching uma caixa:
  Se a localização estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está within um malha of uma segunda localização:
  Obtenha um difference between a segunda localização e a localização.
  Se a difference está within a malha, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está within uns twips of uma segunda localização:
  Atribua os twips e os twips a um malha.
  Se a localização estiver within a malha of a segunda localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma localização está within uns twips of uma caixa:
  Isole a caixa.
  Outdent a caixa usando os twips.
  Se a localização estiver within a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se o stack has just one coisa sobre it:
  Se a contagem deste stack for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

    \Etapas necessárias para que se determine se uma string does end com uma segunda string;
Etapas necessárias para que se determine se uma string termina com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o last endereço de memória do pedaço deste subtexto menos a quantidade de caracteres desta segunda string mais 1 ao first endereço de memória do pedaço deste subtexto.
  Se o subtexto for a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string does start com uma segunda string;
Etapas necessárias para que se determine se uma string começa com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Se o subtexto é a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string does start com um pedaço;
Etapas necessárias para que se determine se uma string começa com um pedaço:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string does end com um pedaço; \ adicionado por Mike Gonta
Etapas necessárias para que se determine se uma string termina com um pedaço:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste last endereço de memória do pedaço desta string for o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string é uma segunda string (accent-free compare):
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos s/ acento ascii (equal only).

Etapas necessárias para que se determine se uma string é uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos ascii (equal only).

Etapas necessárias para que se determine se uma string é uma segunda string ou um terceiro string:
  Se a string é a segunda string, diga sim.
  Se a string é o terceiro string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de fração literal;
Etapas necessárias para que se determine se uma string é algum tipo de ratio literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Split o subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
  Se o numerador subtexto não for algum tipo de integer literal, diga não.
  Se o denominador subtexto não for algum tipo de integer literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

    \Etapas necessárias para que se determine se uma string é algum tipo de inteiro:
    \ parece ser uma duplicata da rotina abaixo
    \Lance um subtexto sobre a string.
    \Se o subtexto estiver em branco, diga não.
    \Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
    \Se o subtexto estiver em branco, diga não.
    \Percorra. [o código abaixo]
      \Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de digit, diga não.
      \Adicione 1 para o first endereço de memória do pedaço deste subtexto.
      \Se o subtexto estiver em branco, diga sim.
    \Repita. [o código acima]

Etapas necessárias para que se determine se uma string é algum tipo de integer;
Etapas necessárias para que se determine se uma string é algum tipo de integer literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Percorra. [o código abaixo]
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de digit, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, diga sim.
  Repita. [o código acima]

Etapas necessárias para que se determine se uma string é algum tipo de mixed literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Split o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto não for algum tipo de integer literal, diga não.
  Se a fração subtexto não for algum tipo de fração literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma string é algum tipo de numeric literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string não for algum tipo de indicador numérico, diga não.
  Se a string é algum tipo de integer literal, diga sim.
  Se a string é algum tipo de fração literal, diga sim.
  Se a string é algum tipo de mixed literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string é tipo de sinal aritmético:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de palavra:
  Se a quantidade de caracteres desta string for menor do que 2, diga não.
  Lance um subtexto sobre a string.
  Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for algum tipo de letra, repita.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o single-quote pedaço, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string está em branco:
    \ assume true
  Intel $B801000000. \ mov eax,1
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ a string
    \ if first for 0, exit
  Intel $833B00. \ cmp [ebx],0
  Intel $0F8410000000. \ je end
    \ if last for menor do que first, exit
  Intel $8B5304. \ mov edx,[ebx+4] \ last endereço de memória
  Intel $3B13. \ cmp edx,[ebx]
  Intel $0F8C05000000. \ jl end
    \ [Se as condições acima não puderem ser satisfeitas, então:] Diga não.:
  Intel $B800000000. \ mov eax,0
    \ END:

Etapas necessárias para que se determine se uma string é um pedaço:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string é dos-compatible:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é o ponto final, diga não.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o slash pedaço, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de dois pontos, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o asterisco, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o ponto de interrogação, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for as aspas duplas, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o símbolo menor do que, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o símbolo maior do que, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o barra vertical, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se determine se uma string é maior que uma segunda string;
Etapas necessárias para que se determine se uma string é maior do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string é maior do que ou igual para uma segunda string;
Etapas necessárias para que se determine se uma string é maior que ou igual para uma segunda string;
Etapas necessárias para que se determine se uma string é maior ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string estiver em uma segunda string:
  Lance um subtexto sobre a segunda string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta segunda string, diga não.
    Se o subtexto é a string, diga sim.
    Mova o subtexto usando 1.
  Repita. [o código acima]

Etapas necessárias para que se determine se uma string estiver em um catálogo:
  Se o catálogo for inexistente, diga não.
  Se a string estiver em branco, diga não.
  Encontre um refer usando a string e o catálogo.
  Se o refer for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma string é menor que uma segunda string;
Etapas necessárias para que se determine se uma string é menor do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se uma string é menor do que ou igual para uma segunda string;
Etapas necessárias para que se determine se uma string é menor que ou igual para uma segunda string;
Etapas necessárias para que se determine se uma string é menor ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

     \ needs work por Spanish
Etapas necessárias para que se determine se uma string está escrito incorretamente:
  Se o dicionário léxico for inexistente, diga não.
  Se a string não for algum tipo de palavra, diga não.
  Isole a string.
  Se a string termina com "'s", remove os last dois pedaços desde a string.
  Se a string estiver no catálogo deste dicionário léxico, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uma string é wider do que uma caixa:
    \ assumes font estiver selecionado sobre memory canvas
  Obtenha um abca e um abcc usando a string e o memory canvas.
  Obtenha um largura usando a string e o memory canvas.
  Subtraia o abca desde o largura.
  Subtraia o abcc desde o largura.
  Se o largura for maior do que a largura desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um subtexto está sobre alguma espécie de contração:
  Atribua o first endereço de memória do pedaço deste subtexto mais 1 a um endereço de memória do pedaço .
  Se o endereço de memória do pedaço for maior do que o last endereço de memória do pedaço deste subtexto, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o single-quote pedaço, diga não.
  Se o conteúdo deste endereço de memória do pedaço não for algum tipo de letra, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um terminal está full:
  Atribua a altura deste terminal dividido por 24 pixels a um número.
  Se a contagem destes quoras deste terminal for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um text pode ser refeito:
  Se o text for inexistente, diga não.
  Se o last destes redos deste text for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um text pode ser desfeito:
  Se o text for inexistente, diga não.
  Se o last destes undos deste text for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se um text foi alterado:
  Se o text for inexistente, diga não.
  Se o detector de alteração deste text estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se existe something para backspace em um text:
  Se o text for inexistente, diga não.
  Se something estiver selecionado no text, diga sim.
  Se o número de linhas do cursor deste text não for 1, diga sim.
  Se o caret column# deste text não for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se existe something para remove em um text:
  Se o text for inexistente, diga não.
  Se something estiver selecionado no text, diga sim.
  Se o número de linhas do cursor deste text não for a contagem de linhas deste text, diga sim.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text não for a quantidade de caracteres desta string desta row, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se existe text sobre o área de transferência do Windows:
  Call "user32.dll" "IsClipboardFormatAvailable" com 
  1 [CF_TEXT] 
    devolvendo um número.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se uns coisas estão vazio:
  Se o first destas coisas for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se um segmento inicial é numeric:
  Isole o segmento inicial.
  Remove algum tipo de leading noise desde o segmento inicial.
  Se o segmento inicial estiver em branco, diga não.
  Percorra. [o código abaixo]
    Obtenha um pedaço desde o segmento inicial.
    Se o pedaço não for algum tipo de digit, diga não.
    Se o segmento inicial estiver em branco, diga sim.
  Repita. [o código acima]

Etapas necessárias para que se determine se o usuário está clicking em umas choices;
Etapas necessárias para que se determine se o usuário has clicked em umas choices;
Etapas necessárias para que se determine se o usuário clicked em umas choices;
Etapas necessárias para que se determine se o usuário clicks em umas choices;
Etapas necessárias para que se determine se o usuário está clicking sobre umas choices;
Etapas necessárias para que se determine se o usuário has clicked sobre umas choices;
Etapas necessárias para que se determine se o usuário clicked sobre umas choices;
Etapas necessárias para que se determine se o usuário clicks sobre umas choices:
Etapas necessárias para que se determine se o usuário clickou sobre umas choices:
Etapas necessárias para que se determine se o usuário clicou sobre umas choices:
Etapas necessárias para que se determine se o usuário clickou em umas choices:
Etapas necessárias para que se determine se o usuário clicou em umas choices:
  Percorra. [o código abaixo]
  Se o botão esquerdo deste mouse não estiver para baixo, diga não.
  Encontre uma choice usando a localização deste mouse.
  Se a choice can't ser found, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

  

Etapas necessárias para que se determine se we pode encontre um endereço de memória:
    \ deveria ser "can" not "ca", compilador bug
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se we could encontre um endereço de memória:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se we did encontre um endereço de memória:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas necessárias para que se determine se we're above uma caixa:
  Se a coordenada Y deste context for menor do que a coordenada superior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're above uma coordenada:
  Se a coordenada Y deste context for menor do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're above um horizontal line:
  Se a localização deste context é above o horizontal line, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're above ou below uma caixa:
  Se a coordenada Y deste context for menor do que a coordenada superior desta caixa, diga sim.
  Se a coordenada Y deste context for maior do que a coordenada inferior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're above uma localização:
  Se a coordenada Y deste context for menor do que o y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're below uma caixa:
  Se a coordenada Y deste context for maior do que a coordenada inferior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're below uma coordenada:
  Se a coordenada Y deste context for maior do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're below um horizontal line:
  Se a localização deste context é below o horizontal line, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're below uma localização:
  Se a coordenada Y deste context for maior do que o y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're facing north:
    \ *** need east, south, west
  Normalize a orientação deste context.
  Se a orientação deste context for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're left of uma caixa:
  Se a coordenada X deste context for menor do que a coordenada esquerda desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're left ou right of uma caixa:
  Se a coordenada X deste context for menor do que a coordenada esquerda desta caixa, diga sim.
  Se a coordenada X deste context for maior do que a coordenada direita desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're outside uma caixa:
  Se a localização deste context é outside a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're right of uma caixa:
  Se a coordenada X deste context for maior do que a coordenada direita desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're still em uma caixa;
Etapas necessárias para que se determine se we're em uma caixa:
  Se a localização deste context estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se we're within uns twips of uma caixa:
  Se a localização deste context está within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se determine se you feel like it:
  Escolha aleatoriamente um número between 1 e 100.
  Se o número for menor do que 51, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas necessárias para que se decrypt um trecho usando um passphrase string:
    \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie um crypt session usando o passphrase.
  Se o crypt session for inexistente, cancele.
  Converta o trecho como um cifra hexadecimal para um texto hexadecimal.
  Atribua a quantidade de caracteres deste texto hexadecimal a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptDecrypt" com 
    A hcryptkey desta crypt session 
    e 0 
    e 1 
    e 0 
    e O first deste texto hexadecimal 
    e O endereçamento deste quantidade de caracteres 
    devolvendo um result número.
  Se o result número for 0, atribua "Ocorreu um erro na hora de tentar decifrar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
  Destrua o crypt session.
  Atribua o texto hexadecimal ao trecho.

O fonte padrão é uma font.

O default smtp server é "localhost".

Um degree é um número [cujos valores variam entre 0 até 359].

Um depth é uns twips.

Um description é uma string.

Etapas necessárias para que se desvencilhe-se de um text:
  Se o text for inexistente, cancele.
  Atribua o caret deste text ao anchor deste text.

Etapas necessárias para que se destrua um crypt session:
  Se o crypt session for inexistente, cancele.
  Call "advapi32.dll" "CryptDestroyKey" com 
    A hcryptkey desta crypt session.
  Call "advapi32.dll" "CryptDestroyHash" com 
    O hcrypthash desta crypt session.
  Call "advapi32.dll" "CryptReleaseContext" com 
    O hcryptprov desta crypt session 
    e 0.
  Desaloque o crypt session.

Etapas necessárias para que se destrua um gpimage:
  Se o gpimage for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImage" com o gpimage.
  Esvazie o gpimage.

Etapas necessárias para que se destrua um gpimageattributes:
  Se o gpimageattributes for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImageAttributes" com o gpimageattributes.
  Esvazie o gpimageattributes.

Etapas necessárias para que se destrua o hbrush of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null hbrush 
    devolvendo um hbrush.
  Call "gdi32.dll" "DeleteObject" com 
    O hbrush.

Etapas necessárias para que se destrua o número da fonte of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null número da fonte 
    devolvendo um número da fonte.
  Call "gdi32.dll" "DeleteObject" com 
    O número da fonte.

Etapas necessárias para que se destrua o hpen of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null hpen 
    devolvendo um hpen.
  Call "gdi32.dll" "DeleteObject" com 
    O hpen.

Etapas necessárias para que se destrua um hrgn:
  Call "gdi32.dll" "DeleteObject" com 
    O hrgn.

Etapas necessárias para que se destrua um catálogo:
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, pare.
    Destrua os refers deste bucket.
  Repita. [o código acima]
  Unassign o first bucket deste catálogo.
  Desaloque o catálogo.

Etapas necessárias para que se destrua um endereço completo no sistema de arquivos:
  Defina o endereço completo para read-write mode.
  Se o endereço completo é endereço da pasta-format, destrua o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, destrua o endereço completo no sistema de arquivos (arquivo).

Etapas necessárias para que se destrua um endereço completo no sistema de arquivos (pasta)[endereço]:
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, pare.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Destrua a segunda endereço completo no sistema de arquivos.
    Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Repita. [o código acima]
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "RemoveDirectoryA" com 
    O first deste endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível apagar a pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se destrua uma endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "DeleteFileA" com 
    O first deste endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível apagar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se destrua uma imagem:
  Se o imagem for inexistente, cancele.
  Destrua o gpbitmap desta imagem.
  Desaloque o imagem.

Etapas necessárias para que se destrua um socket:
  Call "ws2_32.dll" "closesocket" com 
    O socket.

Etapas necessárias para que se destrua um vértice usando um polígono:
  Se o vértice for inexistente, cancele.
  Se o polígono for inexistente, cancele.
  Isole o vértice.
  Remove o vértice desde os vértices deste polígono.
  Destrua o vértice.

Etapas necessárias para que se destrua um winhttp request:
  Se o winhttp request for inexistente, cancele.
  Call "winhttp.dll" "WinHttpCloseHandle" com 
    O request número identificador deste winhttp request.
  Call "winhttp.dll" "WinHttpCloseHandle" com 
    O connection número identificador deste winhttp request.
  Call "winhttp.dll" "WinHttpCloseHandle" com 
    O session número identificador desta request deste winhttp.
  Deallocate o winhttp request.

Um difference é um par de números.

Um file é um número identificador.

Um nome do arquivo é uma string. \ after o last slash para end of endereço completo = file.ext
Um nome do arquivo s/ extensão é uma string. \ after o last slash para last dot ou end of endereço completo = file
Um extensão é uma string. \ last dot para end of endereço completo = .ext
Um endereço da pasta é um endereço completo. \ start of endereço completo para last slash inclusive = c:\folder1\folder2\
Um endereço completo é uma string. \ complete nome = c:\folder1\folder2\file.ext
Um nome do diretório é uma string. \ rightmost endereço da pasta com slash = folder2\
Um designador é uma string. \ rightmost endereço da pasta com slash = folder2\ ou after o last slash para end of endereço completo = file.ext
Um nome da pasta é uma string. \ rightmost endereço da pasta sem slash = folder2
Um unidade de disco é uma string. \ start of endereço completo para first slash = c:\ ou start of endereço completo para quarto slash = \\computer\share\
Um unidade de rede é uma string. \ é basicamente o número de cópias da variável anterior.
Um categoria da unidade de disco é uma string.
Um nome da unidade de disco é uma string.

Um distance é uns twips.

Etapas necessárias para que se divida uma fração por uma segunda fração:
  Isole a segunda fração.
  Flip a segunda fração.
  Multiplique a fração pela segunda fração.

Etapas necessárias para que se divida uma fração por um número:
  Multiplique o denominador desta fração pelo número.
  Reduce a fração.

Etapas necessárias para que se divida um número por um fração:
  Isole a fração.
  Flip a fração.
  Multiplique o número pela fração.

Etapas necessárias para que se divida um par de números por uma segunda par de números:
  Divida o número X deste par de números pelo número X desta segunda par de números.
  Divida o número Y deste par de números pelo número Y desta segunda par de números.

Etapas necessárias para que se divida um par de números por um número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo número.

Etapas necessárias para que se divida um par de números por um número e um segundo número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo segundo número.

Etapas necessárias para que se divida um endereço de memória por um número;
Etapas necessárias para que se divida um número por um segundo número:
  Se o segundo número for 0, atribua o maior número ao número; exit.
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $99. \ cdq
  Intel $F73B. \ div [ebx] \ means div eax,[ebx] but é weird form
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se divida um endereço de memória por um número usando um quotient e um resto;
Etapas necessárias para que se divida um número por um segundo número usando um quotient e um resto:
  Se o segundo número for 0, atribua o maior número ao quotient; atribua 0 ao resto; exit.
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo número
  Intel $8B00. \ mov eax,[eax]
  Intel $99. \ cdq
  Intel $F73B. \ idiv [ebx] \ means idiv eax,[ebx] but é weird form
  Intel $8B9D10000000. \ mov ebx,[ebp+16] \ o quotient
  Intel $8903. \ mov [ebx],eax
  Intel $8B9D14000000. \ mov ebx,[ebp+20] \ o resto
  Intel $8913. \ mov [ebx],edx

\Um docinfo é um conjunto com
\Um número denominado cbsize,
\Um endereço de memória denominado lpszdocname,
\Um endereço de memória denominado lpszoutput,
\Um endereço de memória denominado lpszdatadtype,
\Um número denominado fwtype.

Um dot é um elipse.

Etapas necessárias para que se double um número:
  Adicione o número para o número.

Etapas necessárias para que se pinte e fill uma caixa com uma cor:
  Pinte a caixa com a cor e a cor.

Etapas necessárias para que se pinte algum tipo de visível rows of um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver visível, repita.
    Pinte a row of o text.
  Repita. [o código acima]

Etapas necessárias para que se pinte algum tipo de visível rows of um text (editing):
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não for visível, repita.
    Pinte a row of o text (editing).
  Repita. [o código acima]

Etapas necessárias para que se pinte uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas necessárias para que se pinte uma caixa (focus style):
  Isole a caixa.
  Adicione o tpp para o canto inferior direito desta caixa.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e O endereçamento desta caixa e 2.
  Converta a cor branca para um código da cor. \código de pigmento/tonalidade?
  Call "gdi32.dll" "SetBkColor" com 
    O quadro atual 
    e O código da cor.
  Converta a cor preta para um segundo código da cor.
  Call "gdi32.dll" "SetTextColor" com 
    O quadro atual 
    e O segundo código da cor.
  Call "gdi32.dll" "SetMapMode" com 
    O quadro atual 
    e 1 [MM_TEXT].
  Call "user32.dll" "DrawFocusRect" com 
    O quadro atual 
    e O endereçamento desta caixa.
  Normalize o quadro atual.

Etapas necessárias para que se pinte uma caixa em uma cor:
    \Etapas necessárias para que se pinte uma caixa com uma cor:
  Pinte a caixa com a cor e a cor preta.

Etapas necessárias para que se pinte o caret em um text:
  Se o text for inexistente, cancele.
  Obtenha uma caixa pelo caret no text.
  Se a caixa não for touching a caixa deste text, cancele.
  Atribua o canto superior esquerdo desta caixa e o canto inferior direito desta caixa a um line.
  Pinte o line com a cor preta.

Etapas necessárias para que se pinte um circle about uns twips wide;
Etapas necessárias para que se pinte um circle usando um largura;
Etapas necessárias para que se pinte um circle uns twips em largura;
Etapas necessárias para que se pinte um circle uns twips wide:
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o way.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Repita. [o código acima]

Etapas necessárias para que se pinte um circle uns twips wide (backwards);
Etapas necessárias para que se pinte um circle uns twips wide (counterclockwise):
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o way.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Repita. [o código acima]

Etapas necessárias para que se pinte um console:
  Se o console for inexistente, cancele.
  Save o quadro atual.
  Cubra somente fora de a caixa deste console .
  Pinte a caixa deste console com a cor da borda deste console e a cor de preenchimento deste console.
  Pinte o text deste console.
  Restore o quadro atual.

Etapas necessárias para que se pinte um dot uns twips wide sobre o current localização com uma cor:
  Make o dot os twips wide.
  Centralize o dot sobre a localização deste context.
  Pinte o dot com a cor.

Etapas necessárias para que se pinte um dot uns twips wide sobre uma localização com uma cor:
  Make o dot os twips wide.
  Centralize o dot sobre a localização.
  Pinte o dot com a cor.

Etapas necessárias para que se pinte um elipse:
  Pinte a elipse com a cor preta e a cor branca.

Etapas necessárias para que se pinte um elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor e a cor preta.

Etapas necessárias para que se pinte uma elipse com uma cor:
  Pinte a elipse com a cor e a cor.

Etapas necessárias para que se pinte uma fancy arrow uns twips long com uma cor:
  Atribua a cor à cor deste context.
  Save o context.
  Pinte os twips.
  Vire around.
  Mova os twips dividido por 8.
  Save o context.
  Vire left 1/8 of o way.
  Pinte um spiral starting com os twips dividido por 4.
  Restore o context.
  Vire right 1/8 of o way.
  Pinte uma segunda spiral backwards starting com os twips dividido por 4.
  Restore o context.

Etapas necessárias para que se pinte um figura com uma cor:
  Pinte a figura com a cor e a cor preta.

Etapas necessárias para que se pinte um figura com uns sides about uns twips wide:
  Atribua 1 e o side contagem a um fração.
  Atribua os twips times o número pi dividido pelo sides a uma quantidade de caracteres do segmento.
  Se o sides são 4, atribua os twips times 7/8 ao quantidade de caracteres do segmento. \ what é this? ***
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire a fração.
    Adicione 1 para uma contagem. 
    Se a contagem for os sides, pare.
  Repita. [o código acima]

Etapas necessárias para que se pinte um figura com uns sides uns twips long;
Etapas necessárias para que se pinte um figura com uns sides e uns twips:
  Atribua 1 e o sides a um fração.
  Percorra. [o código abaixo]
    Pinte os twips.
    Vire a fração.
    Adicione 1 para uma contagem. Se a contagem é o sides, pare.
  Repita. [o código acima]

Etapas necessárias para que se pinte um figura com uns sides uns twips long using uma cor;
Etapas necessárias para que se pinte um figura com uns sides e uns twips using uma cor:
  Atribua a cor à cor deste context.
  Pinte a figura com o sides e os twips.

Etapas necessárias para que se pinte um half circle about uns twips wide;
Etapas necessárias para que se pinte um half circle usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o way.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Repita. [o código acima]

Etapas necessárias para que se pinte um half circle usando um size (backwards);
Etapas necessárias para que se pinte um half circle usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o way.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Repita. [o código acima]

Etapas necessárias para que se pinte um hexagon usando um side quantidade de caracteres:
  Pinte o side quantidade de caracteres.
  Vire right 1/6 of o way.
  Adicione 1 para uma contagem. Se a contagem for 6, pare.
  Repita. [o código acima]

Etapas necessárias para que se pinte um line:
  Pinte o line com a cor deste context.

Etapas necessárias para que se pinte um line around uns twips long; \ "around" é significante here
Etapas necessárias para que se pinte um line about uns twips long: \ "about" é significante here
    \ "about" é significant here
  Atribua os twips dividido por 2 a uns segunda twips.
  Escolha aleatoriamente uns terceiro twips between os twips menos a segunda twips e os twips mais a segunda twips.
  Pinte o line o terceiro twips long.

Etapas necessárias para que se pinte um line como tall como uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte a altura desta caixa.

Etapas necessárias para que se pinte um line como wide como uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte a largura desta caixa.

Etapas necessárias para que se pinte um line between uns twips e uns segunda twips long;
Etapas necessárias para que se pinte um line between uns twips para uns segunda twips long;
Etapas necessárias para que se pinte um line uns twips para uns segunda twips long:
  Escolha aleatoriamente uns terceiro twips between os twips e a segunda twips.
  Pinte o line o terceiro twips long.

Etapas necessárias para que se pinte um line uns twips long:
    \Aguarde pelo delay. ***
  Atribua a localização deste context ao start desta line.
  Atribua a localização deste context ao end desta line.
  Obtenha um deslocamento vertical e um deslocamento horizontal usando a orientação deste context.
  Adicione o deslocamento horizontal times os twips dividido por 10000 para a coordenada X deste end desta line.
  Adicione o deslocamento vertical times os twips dividido por 10000 para a coordenada Y deste end desta line.
  Atribua o end desta line à localização deste context.
  Pinte o line com a cor deste context.
    \Se o delay é positive, atualize o tela.

Etapas necessárias para que se pinte um line using uns twips como a quantidade de caracteres;
Etapas necessárias para que se pinte um line using uns twips pelo quantidade de caracteres:
  Pinte os twips.

Etapas necessárias para que se pinte um line com uma cor around uns twips long; \ "around" é significant here
Etapas necessárias para que se pinte um line com uma cor about uns twips long:\ "about" é significant here
    \ "about" é significant here
  Atribua os twips dividido por 2 a uns segunda twips.
  Escolha aleatoriamente uns terceiro twips between os twips menos a segunda twips e os twips mais a segunda twips.
  Pinte o line com a cor o terceiro twips long.

Etapas necessárias para que se pinte um line com uma cor uns twips long:
  Atribua a cor à cor deste context.
  Atribua a localização deste context ao start desta line.
  Pinte os twips.
  Atribua a localização deste context ao end desta line.

Etapas necessárias para que se pinte um line com uma cor uns twips para uns segunda twips long:
  Escolha aleatoriamente uns terceiro twips between os twips e a segunda twips.
  Pinte o line com a cor o terceiro twips long.

Etapas necessárias para que se pinte um número em uma caixa com uma cor:
  Atribua o número a uma string.
  Pinte a string na caixa com a cor e "center".

Etapas necessárias para que se pinte only within uma caixa;
Etapas necessárias para que se pinte only inside uma caixa;
Etapas necessárias para que se pinte only em uma caixa;
Etapas necessárias para que se pinte only within uma caixa desde now on;
Etapas necessárias para que se pinte only inside uma caixa desde now on;
Etapas necessárias para que se pinte only em uma caixa desde now on;
Etapas necessárias para que se only pinte within uma caixa desde now on;
Etapas necessárias para que se only pinte inside uma caixa desde now on;
Etapas necessárias para que se only pinte em uma caixa desde now on;
Etapas necessárias para que se only pinte within uma caixa;
Etapas necessárias para que se only pinte inside uma caixa;
Etapas necessárias para que se only pinte em uma caixa;
Etapas necessárias para que se pinte within uma caixa only;
Etapas necessárias para que se pinte inside uma caixa only;
Etapas necessárias para que se pinte em uma caixa only;
Etapas necessárias para que se atribua masking tape all around uma caixa;
Etapas necessárias para que se atribua masking tape around uma caixa:
    \ note that this masks a cor da borda da caixa as well
  Isole a caixa.
  Indent a caixa 1 pixel.
  Cubra externamente a caixa.
  Atribua a original caixa à caixa deste context. \ *** original caixa ? ou indented one?

Etapas necessárias para que se pinte uma imagem sobre um gpgraphic at uma coordenada X e uma coordenada Y:
  Se o imagem for inexistente, cancele.
  Se o grayscale detector desta imagem estiver ativo, crie um gpimageattributes (grayscale).
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com 
    O gpgraphic 
    e O gpbitmap desta imagem 
    e A coordenada X 
    e A coordenada Y 
    e A largura desta caixa intacta desta imagem 
    e A altura desta caixa intacta desta imagem 
    e 0 
    e 0 
    e A largura deste gpbitmap desta imagem 
    e A altura deste gpbitmap desta imagem 
    e 2 [unitpixel] 
    e O gpimageattributes 
    e nil e 0.
  Se o gpimageattributes não for inexistente, destrua o gpimageattributes.

Etapas necessárias para que se pinte um polígono:
  Pinte o polígono com a cor preta e a cor branca.

Etapas necessárias para que se pinte um polígono com uma cor:
  Pinte o polígono com a cor e a cor.

Etapas necessárias para que se pinte um polígono com uma cor (border only):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hpen of o quadro atual usando a cor.
  Obtenha um vértice desde os vértices deste polígono.
  Se o vértice for inexistente, cancele.
  Call "gdi32.dll" "MoveToEx" com 
    O quadro atual 
    e A coordenada X deste vértice 
    e A coordenada Y deste vértice 
    e nil.
  Percorra. [o código abaixo]
    Obtenha o vértice desde os vértices deste polígono.
    Se o vértice for inexistente, pare.
    Call "gdi32.dll" "LineTo" com 
      O quadro atual 
      e A coordenada X deste vértice 
      e A coordenada Y deste vértice.
  Repita. [o código acima]
  Destrua o hpen of o quadro atual.
  Se a localização deste first destes vértices deste polígono for a localização deste last destes vértices deste polígono, cancele.
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com 
    O quadro atual 
    e A coordenada X deste last destes vértices deste polígono 
    e A coordenada Y deste last destes vértices deste polígono 
    e O código da cor.

Etapas necessárias para que se pinte um polígono com uma cor (fill only):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hpen of o quadro atual usando a cor preta.
  Crie o hbrush of o quadro atual usando a cor.
  Call "gdi32.dll" "SetPolyFillMode" com 
    O quadro atual 
    e 2 [WINDING].
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "Polygon" com 
    O quadro atual 
    e A localização endereço de memória deste vértice array 
    e A contagem deste vértice array.
  Destrua o vértice array.
  Destrua o hbrush of o quadro atual.
  Destrua o hpen of o quadro atual.

Etapas necessárias para que se pinte um quarter circle about uns twips wide;
Etapas necessárias para que se pinte um quarter circle usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o way.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Repita. [o código acima]

Etapas necessárias para que se pinte um quarter circle between uns twips e uns segunda twips wide:
  Escolha aleatoriamente uns terceiro twips between os twips e a segunda twips.
  Pinte um quarter circle usando o terceiro twips.

Etapas necessárias para que se pinte um quarter circle usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o way.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Repita. [o código acima]

Etapas necessárias para que se pinte um retângulo uns twips por uns segunda twips;
Etapas necessárias para que se pinte um retângulo uns twips wide por uns segunda twips high:
  Pinte a segunda twips.
  Vire right.
  Pinte os twips.
  Vire right.
  Pinte a segunda twips.
  Vire right.
  Pinte os twips.
  Vire right.

Etapas necessárias para que se pinte uma caixa arredondada:
  Pinte a caixa arredondada com a cor preta e a cor branca.

Etapas necessárias para que se pinte uma caixa arredondada com uma cor:
  Pinte a caixa arredondada com a cor e a cor.

Etapas necessárias para que se pinte uma row of um text:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas necessárias para que se pinte uma row of um text (editing):
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Pinte a caixa de seleção pela row of o text.
  Obtenha uma caixa usando a row e o text.
  Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas necessárias para que se pinte a caixa de seleção por uma row of um text:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Se a row of o text não estiver selecionado, cancele.
  Obtenha uma caixa de seleção usando a row e o text.
  Pinte a caixa de seleção com o hilite cor e o hilite cor.

Etapas necessárias para que se pinte um spiral backward usando uns twips;
Etapas necessárias para que se pinte um spiral backward starting com uns twips;
Etapas necessárias para que se pinte um spiral usando um size (backwards):
  Isole o size.
  Percorra. [o código abaixo]
    Pinte um half circle usando o size (backwards).
    Divida o size por 2.
    Adicione 1 para uma contagem.
    Se a contagem for 5, pare.
  Repita. [o código acima]

Etapas necessárias para que se pinte um spiral starting com uns twips;
Etapas necessárias para que se pinte um spiral usando um size:
  Isole o size.
  Percorra. [o código abaixo]
    Pinte um half circle usando o size.
    Divida o size por 2.
    Adicione 1 para uma contagem. 
    Se a contagem for 5, pare.
  Repita. [o código acima]

Etapas necessárias para que se pinte uma localização:
  Pinte a localização com a cor preta.

Etapas necessárias para que se pinte uma localização com uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    e O código da cor.

Etapas necessárias para que se pinte um star usando uma point contagem e um size:
  Atribua 1 e a point contagem a um fração.
  Percorra. [o código abaixo]
    Vire right 1/48 of o way.
    Pinte o size.
    Vire around.
    Vire left 1/24 of o way.
    Pinte o size.
    Vire around.
    Vire right 1/48 of o way.
    Vire right a fração of o way.
    Adicione 1 para uma contagem. 
    Se a contagem for o point contagem, pare.
  Repita. [o código acima]

Etapas necessárias para que se pinte uma string at o left of uma caixa:
  Pinte a string at o left of a caixa com a cor preta e a fonte padrão.

Etapas necessárias para que se pinte uma string at o left of uma caixa com uma cor:
  Pinte a string at o left of a caixa com a cor e a fonte padrão.

Etapas necessárias para que se pinte uma string at o left of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e o font e "left".

Etapas necessárias para que se pinte uma string at o left of uma caixa com um font:
  Pinte a string at o left of a caixa com a cor preta e o font.

Etapas necessárias para que se pinte uma string at o right of uma caixa:
  Pinte a string at o right of a caixa com a cor preta e a fonte padrão.

Etapas necessárias para que se pinte uma string at o right of uma caixa com uma cor:
  Pinte a string at o right of a caixa com a cor e a fonte padrão.

Etapas necessárias para que se pinte uma string at o right of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e o font e "right".

Etapas necessárias para que se pinte uma string at o right of uma caixa com um font:
  Pinte a string at o right of a caixa com a cor preta e o font.

Etapas necessárias para que se pinte uma string at uma localização com uma cor:
  Pinte a string at a localização com a cor e a fonte padrão.

Etapas necessárias para que se pinte uma string em uma caixa:
  Pinte a string na caixa com a cor preta e a fonte padrão e "left".

Etapas necessárias para que se pinte uma string em uma caixa over um número com uma cor e uma font e um alinhamento:
  Isole a caixa.
  Se o alinhamento for "left", adicione o número para a coordenada esquerda desta caixa.
  Se o alinhamento for "zquierda", adicione o número para a coordenada esquerda desta caixa.
  Se o alinhamento for "derecho", subtraia o número desde a coordenada direita desta caixa.
  Pinte a string na caixa com a cor e o font e o alinhamento.

Etapas necessárias para que se pinte uma string em uma caixa com um alinhamento:
  Pinte a string na caixa com a cor preta e a fonte padrão e o alinhamento.

Etapas necessárias para que se pinte uma string em uma caixa com uma cor:
  Pinte a string na caixa com a cor e a fonte padrão e "left".

Etapas necessárias para que se pinte uma string em uma caixa com uma cor e um alinhamento:
  Pinte a string na caixa com a cor e a fonte padrão e o alinhamento.

Etapas necessárias para que se pinte uma string em uma caixa com uma cor e uma font e um alinhamento:
  Obtenha um offset par de números usando a string e a caixa e o font e o alinhamento.
  Pinte a string at o canto superior esquerdo desta caixa mais o offset par de números com a cor e o font.

Etapas necessárias para que se pinte uma string em uma caixa com uma font e um alinhamento:
  Pinte a string na caixa com a cor preta e o font e o alinhamento.

Etapas necessárias para que se pinte uma string no center of uma caixa:
  Pinte a string no center of a caixa com a cor preta e a fonte padrão.

Etapas necessárias para que se pinte uma string no center of uma caixa com uma cor:
  Pinte a string no center of a caixa com a cor e a fonte padrão.

Etapas necessárias para que se pinte uma string no center of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e o font e "center".

Etapas necessárias para que se pinte uma string no center of uma caixa com um font:
  Pinte a string no center of a caixa com a cor preta e o font.

Etapas necessárias para que se pinte um terminal:
  Se o terminal for inexistente, cancele.
  Save o quadro atual.
  Cubra somente fora de a caixa deste terminal.
  Pinte e fill a caixa deste terminal com a cor preta.
  Escreva os quoras deste terminal na caixa deste terminal.
  Restore o quadro atual.

Etapas necessárias para que se pinte um text:
  Se o text for inexistente, cancele.
  Save o quadro atual.
  Cubra externamente a caixa deste text.
  Pinte algum tipo de visível rows of o text.
  Restore o quadro atual.

Etapas necessárias para que se pinte um text (editing):
  Se o text for inexistente, cancele.
  Save o quadro atual.
  Cubra externamente a caixa deste text.
  Pinte algum tipo de visível rows of o text (editing).
  Pinte o caret no text.
  Restore o quadro atual.

Etapas necessárias para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos:
  Se o endereço completo é endereço da pasta-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (arquivo).

Etapas necessárias para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (pasta)[endereço]:
  Se o endereço completo estiver no segunda endereço completo, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de ". - erro de recursão inválida." ao erro do fluxo de entrada/saída; exit.
  Se o endereço completo não estiver no sistema de arquivos, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.
  Se a segunda endereço completo não estiver no sistema de arquivos, crie a segunda endereço completo no sistema de arquivos.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Atribua o endereço completo a um terceiro endereço completo.
    Posponha o designador deste item para o terceiro endereço completo.
    Atribua a segunda endereço completo a um quarto endereço completo.
    Posponha o designador deste item para o quarto endereço completo.
    Duplicate o terceiro endereço completo para o quarto endereço completo no sistema de arquivos.
  Repita. [o código acima]

Etapas necessárias para que se duplicate um endereço completo para um segundo endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Isole o segundo endereço completo.
  Modifique através do caractere NUL o segundo endereço completo.
  Call "kernel32.dll" "CopyFileA" com 
    O first deste endereço completo 
    e O first deste segundo endereço completo 
    e 0 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, defina o endereço completo para read-write mode; exit.
  Atribua "Ocorreu um erro na hora de duplicar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

An dyad é uma coisa com
  Um nome,
  Uma value string.

Uma elipse é um conjunto com uma caixa.

Um email é um conjunto com
  Um smtp server,
  Um sender,
  Um recipient,
  Um subject,
  Uma message.

Etapas necessárias para que se encrypt um trecho usando um passphrase string:
    \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie um crypt session usando o passphrase.
  Se o crypt session for inexistente, cancele.
  Atribua o trecho a um temp trecho.
  Atribua a quantidade de caracteres deste temp trecho a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptEncrypt" com 
    A hcryptkey desta crypt session 
    e 0 
    e 1 
    e 0 
    e O first endereço de memória do pedaço deste temp trecho 
    e O endereçamento deste quantidade de caracteres 
    e A quantidade de caracteres 
    devolvendo um result número.
  Se o result número for 0, atribua "Ocorreu um erro na hora de criptografar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
  Destrua o crypt session.
  Converta o temp trecho para um cifra hexadecimal.
  Atribua a cifra hexadecimal ao trecho.

Etapas necessárias para que se enlarge uma caixa por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta caixa.
  Adicione os twips para o canto inferior direito desta caixa.

Etapas necessárias para que se enlarge um elipse por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta elipse.
  Adicione os twips para o canto inferior direito desta elipse.

Etapas necessárias para que se enfileire um event:
  Posponha o event para a fila de eventos.

Etapas necessárias para que se erase o insides of uma caixa;
Etapas necessárias para que se erase inside uma caixa;
Etapas necessárias para que se limpe inside uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas necessárias para que se estimate um deslocamento vertical e um deslocamento horizontal usando uma orientação:
  Atribua a orientação a um low orientação.
  Arredonde o low orientação para baixo para o múltiplo imediato of 20.
  Obtenha um low deslocamento vertical e um low deslocamento horizontal usando o low orientação.
  Atribua a orientação a um high orientação.
  Arredonde o high orientação para cima para o múltiplo imediato of 20.
  Obtenha um high deslocamento vertical e um high deslocamento horizontal usando o high orientação.
  Atribua o low deslocamento vertical mais o high deslocamento vertical dividido por 2 ao deslocamento vertical.
  Atribua o low deslocamento horizontal mais o high deslocamento horizontal dividido por 2 ao deslocamento horizontal.

    \Um event é uma coisa com
    \a categoria,
    \a detector de tecla Shift,
    \a detector de tecla ctrl,
    \um detector de tecla alt,
    \a localização,
    \a tecla, um pedaço.

An event é uma coisa com
Uma categoria [atualização de tela, mostrar seta, pressionamento de tecla, clique, clique duplo, clique direito, clique direito duplo, deactivate, activate, done], \ English
Um detector de tecla Shift, 
Um detector de tecla ctrl, 
Um detector de tecla alt, 
Um localização, 
Uma tecla, 
Um pedaço.

A fila de eventos é uma fila de eventos.

Uma fila de eventos é uns events.

Etapas necessárias para que se extend algum tipo de seleção em um text usando uma localização:
  Se o text for inexistente, cancele.
  Obtenha o caret deste text usando a localização e o text.
  Limpe a última operação deste text.

Etapas necessárias para que se extend uma caixa para include uma segunda caixa:
  Se a coordenada esquerda desta segunda caixa for menor do que a coordenada esquerda desta caixa, atribua a coordenada esquerda desta segunda caixa à coordenada esquerda desta caixa.
  Se a coordenada superior desta segunda caixa for menor do que a coordenada superior desta caixa, atribua a coordenada superior desta segunda caixa à coordenada superior desta caixa.
  Se a coordenada direita desta segunda caixa for maior do que a coordenada direita desta caixa, atribua a coordenada direita desta segunda caixa à coordenada direita desta caixa.
  Se a coordenada inferior desta segunda caixa for maior do que a coordenada inferior desta caixa, atribua a coordenada inferior desta segunda caixa à coordenada inferior desta caixa.

Some  extra points são uns points.

Etapas necessárias para que se extraia um designador desde um endereço completo:
  Limpe o designador.
  Extraia um unidade de disco desde o endereço completo.
  Lance um endereço completo subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o first deste endereço completo subtexto.
  Se o endereço completo subtexto estiver em branco, atribua o unidade de disco ao designador; exit.
  Lance um subtexto sobre o last pedaço of o endereço completo subtexto.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o first endereço de memória do pedaço deste subtexto for menor do que o first deste endereço completo subtexto, pare.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Atribua o subtexto ao designador.

Etapas necessárias para que se extraia um endereço da pasta desde um endereço completo:
  Limpe o endereço da pasta.
  Extraia um unidade de disco desde o endereço completo.
  Se o unidade de disco estiver em branco, cancele.
  Lance um subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, subtraia 1 desde o last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua a unidade de disco junto com o subtexto ao endereço da pasta.

Etapas necessárias para que se extraia um nome do diretório desde um endereço completo:
  Limpe o nome do diretório.
  Se o endereço completo não for endereço da pasta-format, cancele.
  Extraia o nome do diretório como um designador desde o endereço completo.

Etapas necessárias para que se extraia um nome da pasta desde um endereço completo:
  Extraia o nome da pasta como um nome do diretório desde o endereço completo.
  Se o nome da pasta estiver em branco, cancele.
  Remove o last pedaço desde o nome da pasta.

Etapas necessárias para que se extraia um unidade de disco desde um endereço completo:
  Limpe o unidade de disco.
  Se a quantidade de caracteres deste endereço completo for menor do que 3, cancele.
  Lance um subtexto sobre o first pedaço of o endereço completo.
  Adicione 2 para o last endereço de memória do pedaço deste subtexto.
  Se o subtexto termina com ":\", atribua o subtexto ao unidade de disco; exit.
  Se o subtexto não começa com "\\", cancele.
  Lance o subtexto sobre o first pedaço of o endereço completo.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last deste endereço completo, cancele.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, adicione 1 para uma contagem.
    Se a contagem for 4, pare. \ "\\computer\share\"
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o subtexto ao unidade de disco.

Etapas necessárias para que se extraia um extensão desde um endereço completo:
  Limpe o extensão.
  Se o endereço completo estiver em branco, cancele.
  Lance um subtexto sobre o last pedaço of o endereço completo.
  Percorra. [o código abaixo]
    Se o first endereço de memória do pedaço deste subtexto for menor do que o first deste endereço completo, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de dois pontos, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o ponto final, pare.
    Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o subtexto ao extensão.

Etapas necessárias para que se extraia um nome do arquivo desde um endereço completo:
  Limpe o nome do arquivo.
  Se o endereço completo não for file-format, cancele.
  Extraia o nome do arquivo como um designador desde o endereço completo.

Etapas necessárias para que se extraia um nome do arquivo s/ extensão desde um endereço completo:
  Extraia o nome do arquivo s/ extensão como um nome do arquivo desde o endereço completo.
  Extraia um extensão desde o endereço completo.
  Remove trailing pedaços desde o nome do arquivo s/ extensão usando a quantidade de caracteres desta extensão.

Etapas necessárias para que se extraia um imagem usando uma caixa:
  Atribua a largura desta caixa dividido pelo tpp a um largura.
  Atribua a altura desta caixa dividido pelo tpp a uma altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
    A largura 
    e A altura 
    e 0 
    e 137224 [pixelformat24bpprgb] 
    e 0 
    e O endereçamento desse gpbitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
    O gpbitmap 
    e O endereçamento desse gpgraphic.
  Call "gdiplus.dll" "GdipGetDC" com 
    O gpgraphic 
    e O endereçamento desse bitmap canvas.
  Normalize o bitmap canvas.
  Call "gdi32.dll" "BitBlt" com 
    O bitmap canvas 
    e 0 
    e 0 
    e A largura desta caixa 
    e A altura desta caixa 
  And o quadro atual e a coordenada esquerda desta caixa e a coordenada superior desta caixa e 13369376 [srccopy].
  Call "gdiplus.dll" "GdipReleaseDC" com 
    O gpgraphic 
    e O bitmap canvas.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
    O gpgraphic.
  Crie o imagem usando o gpbitmap.
  Atribua a caixa à caixa desta imagem.
  Atribua a caixa à caixa intacta desta imagem.

Etapas necessárias para que se extraia uma string desde um text:
  Se o text for inexistente, limpe a string; exit.
  Converta as rows deste text para a string.
  Remove algum tipo de trailing linefeed pedaço desde a string.
  Remove algum tipo de trailing return pedaço desde a string.

Etapas necessárias para que se extraia uma string desde um text (no linefeed additions):
  Se o text for inexistente, limpe a string; exit.
  Converta as rows deste text para a string (no linefeed additions).
  Remove algum tipo de trailing return pedaço desde a string.

Etapas necessárias para que se extraia uma string desde um text (pedaços selecionados):
  Limpe a string.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
    Se o subtexto estiver em branco, repita.
    Posponha o subtexto para a string.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for o return pedaço, posponha o linefeed pedaço para a string.
  Repita. [o código acima]

Etapas necessárias para que se face algum tipo de way you want;
Etapas necessárias para que se face algum tipo de which way:
  Escolha aleatoriamente uma orientação.

Etapas necessárias para que se face east:
  Atribua 960 à orientação deste context.

Etapas necessárias para que se face north:
  Atribua 0 à orientação deste context.

Etapas necessárias para que se face south:
  Atribua 1920 à orientação deste context.

Etapas necessárias para que se face west:
  Atribua 2880 à orientação deste context.

Um fancy arrow é um figura.

Um figura é um polígono.

As figuras são uns polígonos.

\Um filetime é um conjunto com
\  Um número denominado dwlowdatetime,
\  Um número denominado dwhighdatetime.

Etapas necessárias para que se fill uma caixa com uma cor:
  Pinte a caixa com a cor preta e a cor.

Etapas necessárias para que se fill pedaços com um pedaço starting at um endereço de memória por um quantidade de pedaços:
  Intel $8BBD0C000000. \ mov edi,[ebp+12] \ o endereço de memória
  Intel $8B3F. \ mov edi,[edi]
  Intel $8B8D10000000. \ mov ecx,[ebp+16] \ a contagem
  Intel $8B09. \ mov ecx,[ecx]
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $8A00. \ mov al,[eax]
  Intel $FC. \ cld
  Intel $F3AA. \ rep stosb

Etapas necessárias para que se fill um elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor preta e a cor.

Etapas necessárias para que se fill uma string com um pedaço usando uma contagem:
  Reassign o first endereço de memória do pedaço desta string usando a contagem.
  Fill pedaços com o pedaço starting at o first endereço de memória do pedaço desta string pela contagem.
  Atribua o first endereço de memória do pedaço desta string mais a contagem menos 1 ao last endereço de memória do pedaço desta string.

Etapas necessárias para que se finalize after run:
  Se a contagem do heap for 0, cancele.
  Atribua a contagem do heap a uma contagem.
  Atribua "Você esqueceu de destruir " junto com a contagem seguido de " elemento(s) no heap." a uma string.
  Produza o relatório de informações usando a string.

Etapas necessárias para que se finalize o canvases:
  Finalize o memory canvas.
  Finalize o tela canvas.

Etapas necessárias para que se finalize o cgi:
  Call "kernel32.dll" "FreeConsole".

Etapas necessárias para que se finalize a cors:

Etapas necessárias para que se finalize COM:
  Call "ole32.dll" "CoUninitialize".

Etapas necessárias para que se finalize um context:
  Destrua o choices.
  Destrua as figuras.
  Destrua o context stack.
  Destrua o context.

Etapas necessárias para que se finalize os cursors:
  \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroycursor
  Call "user32.dll" "DestroyCursor" com 
    O i-beam cursor. 
  Call "user32.dll" "DestroyCursor" com 
    O hand cursor.
  Call "user32.dll" "DestroyCursor" com 
    A seta do mouse.

Etapas necessárias para que se finalize as fonts:
    \Call "gdi32.dll" "RemoveFontMemResourceEx" com o osmosian font resource.
    \Call "gdi32.dll" "RemoveFontMemResourceEx" com o Segoe UI resource.
  Call "gdi32.dll" "RemoveFontMemResourceEx" com 
    O recurso de fonte Tahoma. \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-RemoveFontMemResourceEx

Etapas necessárias para que se finalize gdi+:
  Call "gdiplus.dll" "GdiplusShutdown" com 
    O gptoken. \https://docs.microsoft.com/en-us/windows/win32/api/gdiplusinit/nf-gdiplusinit-gdiplusshutdown

Etapas necessárias para que se finalize o memory canvas:
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O saved memory hbitmap 
    devolvendo um hbitmap. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  Call "gdi32.dll" "DeleteObject" com 
    O hbitmap. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  Call "gdi32.dll" "DeleteDC" com 
    O memory canvas. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deletedc

Etapas necessárias para que se finalize o module:

Etapas necessárias para que se finalize o mouse:

Etapas necessárias para que se finalize o printer canvas:
  Call "kernel32.dll" "GlobalFree" com \https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalfree
    o número identificador do modo de dispositivo da impressora.
    \ Um identificador para o objeto de memória global. 
    \Esse identificador é retornado pela função GlobalAlloc ou GlobalReAlloc. 
    \Não é seguro liberar memória alocada com LocalAlloc.
  Atribua 0 ao printer canvas.

Etapas necessárias para que se finalize a tela:

Etapas necessárias para que se finalize o tela canvas:

Etapas necessárias para que se finalize um talker:
  Se o talker for inexistente, cancele.
  Call a release desta vtable deste talker com o talker.
  Atribua nil ao talker.

Etapas necessárias para que se finalize o window:
  Call "user32.dll" "DestroyWindow" com 
    A main window. \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow
  Percorra. [o código abaixo]
  Call "user32.dll" "GetMessageA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea
      o endereçamento dessa msg \Um ponteiro para uma estrutura MSG que recebe informações da mensagem da fila de mensagens do segmento.
      e 0 \Um identificador para a janela cujas mensagens devem ser recuperadas. A janela deve pertencer ao segmento atual.
    \Se hWnd for NULL, GetMessage recuperará mensagens para qualquer janela que pertença ao segmento atual 
    \e quaisquer mensagens na fila de mensagens do segmento atual cujo valor hwnd seja NULL (consulte a estrutura MSG). https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-msg
    \Portanto, se hWnd for NULL, as mensagens da janela e as mensagens do thread serão processadas.
      e 0 \O valor inteiro do menor valor da mensagem a ser recuperado. 
    \Use WM_KEYFIRST (0x0100) para especificar a primeira mensagem do teclado ou WM_MOUSEFIRST (0x0200) para especificar a primeira mensagem do mouse.
      e 0 \O valor inteiro do maior valor da mensagem a ser recuperado. 
    \Use WM_KEYLAST para especificar a última mensagem do teclado ou WM_MOUSELAST para especificar a última mensagem do mouse.
    \Se wMsgFilterMin e wMsgFilterMax forem 0, GetMessage retorna todas as mensagens disponíveis (ou seja, nenhuma filtragem de intervalo é executada).
      devolvendo um número. \Se a função recuperar uma mensagem diferente de WM_QUIT, o valor de retorno será diferente de zero.
    \Se a função recuperar a mensagem WM_QUIT, o valor de retorno será zero.
    \Se houver um erro, o valor de retorno é -1. 
    \Por exemplo, a função falhará se hWnd for um identificador de janela inválido ou lpMsg for um ponteiro inválido. 
    \Para obter informações de erro estendidas, use a função GetLastError. https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror
    \\ Execute a função "GetMessageA" da biblioteca "user32.dll" usando como argumentos os seguintes parâmetros: 
    \\ o endereçamento dessa msg e os valores 0, 0 e 0, esperando um número como resultado.
    Se o número for menor do que 1, pare.
    Call "user32.dll" "TranslateMessage" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage
      o endereçamento desta msg. \Um ponteiro para uma estrutura MSG que contém informações de mensagem recuperadas da fila de mensagens do thread de chamada usando a função GetMessage ou PeekMessage.
    Call "user32.dll" "DispatchMessageA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagea
      o endereçamento desta msg. \Um ponteiro para uma estrutura que contém a mensagem.
  Repita. [o código acima]
  Desmanche a fila de eventos.
  Destrua o evento atual.

Etapas necessárias para que se finalize winsock:
  Call "ws2_32.dll" "WSACleanup".\https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsacleanup

A find anchor é uma anchor.

Etapas necessárias para que se encontre uma choice usando uma localização:
  Start com nada no choice.
  Percorra. [o código abaixo]
    Obtenha o [first/next] choice desde as choices.
    Se o choice for missing, cancele.
    Se a localização estiver na caixa desta choice, pare.
  Repita. [o código acima]

Etapas necessárias para que se encontre um dyad usando uns dyads e um nome:
  Esvazie o dyad.
  Percorra. [o código abaixo]
    Obtenha o dyad desde o dyads.
    Se o dyad for inexistente, cancele.
    Se o nome deste dyad for o nome, cancele.
  Repita. [o código acima]

Etapas necessárias para que se encontre next usando uma row e um text e um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Lance um subtexto sobre a string deste row.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres deste find string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Se o número da linha desta row for o número da linha deste find anchor, mova o subtexto usando o column# deste find anchor menos 1.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que ou igual ao last endereço de memória do pedaço desta string desta row, cancele.
    Se o subtexto for o find string (accent-free compare), pare. \ for spanish incremental find
    Mova o subtexto usando 1.
  Repita. [o código acima]
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 1 ao anchor column# deste text.
  Atribua o número da linha desta row ao anchor número da linha deste text .
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 2 ao caret column# deste text.
  Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas necessárias para que se encontre next usando um text e um detector:
  Se o wrap detector deste text estiver ativo, encontre next usando o text e o detector (wrapped text); exit.
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a quantidade de caracteres deste find string for 0, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
    Encontre next usando a row e o text e o detector.
    Se o detector estiver ativo, cancele.
  Repita. [o código acima]

Etapas necessárias para que se encontre next usando um text e um detector (wrapped text):
  Desative o detector.
  Se o text for inexistente, cancele.
  Converta o find anchor para um posicionamento absoluto denominado offset usando o text.
  Extraia uma string desde o text (no linefeed additions).
  Atribua o first endereço de memória do pedaço desta string mais o offset menos 1 ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres deste find string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta string, cancele.
    Se o subtexto for a find string (accent-free compare), pare. \ para o spanish incremental find
    Mova o subtexto usando 1.
  Repita. [o código acima]
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string mais 1 a um anchor posicionamento absoluto.
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string mais 2 a um caret posicionamento absoluto.
  Converta o anchor posicionamento absoluto para o anchor deste text usando o text.
  Converta o caret posicionamento absoluto para o caret deste text usando o text.

Etapas necessárias para que se encontre o next misspelling usando uma row e um text e um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Lance um percorredor sobre a string deste row.
  Se o número da linha desta row for o número da linha deste find anchor, adicione o column# deste find anchor menos 1 para o first endereço de memória do pedaço deste segmento final deste percorredor.
  Se o first endereço de memória do pedaço deste segmento final deste percorredor não for o first endereço de memória do pedaço desta string desta row, skip palavra characters no segmento final deste percorredor.
  Percorra. [o código abaixo]
    Mova o percorredor (spell checking rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor não estiver escrito incorretamente, repita.
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste segmento inicial deste percorredor menos o first endereço de memória do pedaço desta string desta row mais 1 ao anchor column# deste text.
  Atribua o número da linha desta row ao anchor número da linha deste text .
  Atribua o last endereço de memória do pedaço deste segmento inicial deste percorredor menos o first endereço de memória do pedaço desta string desta row mais 2 ao caret column# deste text.
  Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas necessárias para que se encontre o next misspelling em um text usando um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
    Encontre o next misspelling usando a row e o text e o detector.
    Se o detector estiver ativo, cancele.
  Repita. [o código acima]



Etapas necessárias para que se encontre um endereço de memória usando uma string e um catálogo:
  Encontre um refer usando a string e o catálogo.
  Se o refer não for inexistente, atribua o endereço de memória deste refer ao endereço de memória; exit.
  Esvazie o endereço de memória.

Etapas necessárias para que se encontre um refer usando uma string e um catálogo:
  Se o catálogo for inexistente, cancele.
  Se a string estiver em branco, esvazie o refer; exit.
  Obtenha um bucket usando a string e o catálogo.
  Encontre o refer usando a string e os refers deste bucket.

Etapas necessárias para que se encontre um refer usando uma string e uns refers:
  Esvazie o refer.
  Percorra. [o código abaixo]
    Obtenha o refer desde o refers.
    Se o refer for inexistente, cancele.
    Se a string for a string deste refer, cancele.
  Repita. [o código acima]

Etapas necessárias para que se encontre um sector usando um malha e uma localização:
  Atribua a coordenada X desta localização dividido pelo número X desta malha times o número X desta malha à coordenada x deste sector.
  Atribua a coordenada Y desta localização dividido pelo número Y desta malha times o número Y desta malha à coordenada y deste sector.

Etapas necessárias para que se encontre um square root of um número:
    \ rounds para baixo
  Isole o número.
  De-sign o número.
  Se o número for 0, atribua 0 ao square root; exit.
  Se o número for 1, atribua 1 ao square root; exit.
  Atribua 1 a um square número.
  Atribua 3 a um delta número.
  Percorra. [o código abaixo]
    Se o square for maior do que o número, pare.
    Adicione o delta para o square.
    Adicione 2 para o delta.
  Repita. [o código acima]
  Atribua o delta dividido por 2 menos 1 ao square root.

Etapas necessárias para que se encontre uma string usando uns conjunto de textos e uma string#:
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha um conjunto de texto desde o conjunto de textos.
    Se o conjunto de texto for inexistente, cancele.
    Adicione 1 para uma contagem.
    Se a contagem não for a string#, repita.
  Atribua a string deste conjunto de texto à string.

O find string é uma string.

Etapas necessárias para que se encontre um conjunto de texto usando uma string e uns conjunto de textos:
  Esvazie o conjunto de texto.
  Percorra. [o código abaixo]
    Obtenha o conjunto de texto usando o conjunto de textos.
    Se o conjunto de texto for inexistente, pare.
    Se a string deste conjunto de texto é a string, pare.
  Repita. [o código acima]

Etapas necessárias para que se encontre um subtexto em uma string usando uma segunda string:
  Lance o subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o subtexto começa com a segunda string, pare.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao last endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se encontre um value string usando uns dyads e um nome:
  Encontre um dyad usando o dyads e o nome.
  Se o dyad for inexistente, limpe o value; exit.
  Atribua o value deste dyad ao value.

Etapas necessárias para que se encontre um value string usando o environment variáveis e um nome:
  Isole o nome.
  Modifique através do caractere NUL o nome.
  Atribua 32767 a uma quantidade de caracteres. \ max size por environment variável
  Reassign o first deste value usando a quantidade de caracteres.
  Call "kernel32.dll" "GetEnvironmentVariableA" com 
    O first deste nome 
    e O first deste value 
    e A quantidade de caracteres 
    devolvendo a quantidade de caracteres.
  Atribua o first deste value mais a quantidade de caracteres menos 1 ao last deste value.

Um finger é um endereço de memória do pedaço .

    \Um flag has 4 pedaços.
Um detector é uma coisa com 4 pedaços. \é um conjunto com

Etapas necessárias para que se flip um fração:
  Permute o numerador desta fração com o denominador desta fração.

Etapas necessárias para que se flip o gpbitmap em um imagem:
  Se o imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Flip o gpbitmap desta imagem.

Etapas necessárias para que se flip um gpimage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O gpimage 
    e 6 [RotateNoneFlipY aka Rotate180FlipX].

Etapas necessárias para que se flip um imagem:
  Se o imagem for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa desta imagem menos a coordenada Y deste center desta caixa intacta desta imagem ao número Y desse par de números.
  Multiplique o número Y deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Flip o gpbitmap no imagem.

Etapas necessárias para que se flip um polígono:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia a coordenada superior desta caixa desde a coordenada Y deste vértice.
    Atribua a coordenada inferior desta caixa menos a coordenada Y deste vértice à coordenada y deste vértice.
  Repita. [o código acima]

Etapas necessárias para que se desmanche all input;
Etapas necessárias para que se desmanche all inputs;
Etapas necessárias para que se desmanche all events:
  Desmanche algum tipo de messages.
  Desmanche a fila de eventos.

Etapas necessárias para que se desmanche algum tipo de messages:
  Call "user32.dll" "PeekMessageA" com 
    O endereçamento dessa msg 
    e 0 
    e 0 
    e 0 
    e 1 [PM_REMOVE] devolvendo um número.
  Se o número for 0, cancele.
  Se a message desta msg for 15 [WM_PAINT], call "user32.dll" "ValidateRect" com a main window e 0. \ que tal ter uma rotina específica para isso?
  Repita. [o código acima]

Etapas necessárias para que se desmanche um fila de eventos:
  Obtenha um event desde a fila de eventos.
  Se o event for inexistente, cancele.
  Remove o event desde a fila de eventos.
  Destrua o event.
  Repita. [o código acima]

Uma font é um conjunto com 
  Um nome e 
  Uma altura.

Um altura da fonte é uns twips. \ indicates line altura - o letras will fit nicely em uma caixa of this altura

Um font resource é um número identificador.

Um pé são 12 polegadas.

Etapas necessárias para que se format um número e um singular string ou um plural string Para uma string: \verificar
  Converta o número para a string.
  Posponha o caractere de espaço para a string.
  Se o número for 1, posponha o singular para a string.
  Se o número não for 1, posponha o plural para a string.

Um fração é um conjunto com 
  Um numerador número e 
  Um denominador número, e 
  Um topo número at o numerador e 
  Um base número at o denominador.

Um par de números fracionários é um conjunto com 
  Uma fração e 
  Uma segunda fração.

Um máximo divisor comum é um número.

Um figura geométrica é um figura.

Etapas necessárias para que se obtenha um abca e um abcc usando uma string e um canvas:
  Atribua 0 ao abca.
  Atribua 0 ao abcc.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O endereçamento desse abc.
  Atribua o abca deste abc ao abca.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste last endereço de memória do pedaço desta string 
    e O conteúdo deste last endereço de memória do pedaço desta string 
    e O endereçamento desse segunda abc.
  Atribua o abcc desta segunda abc ao abcc.

Etapas necessárias para que se obtenha um abca usando uma string e um canvas:
  Atribua 0 ao abca.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O endereçamento desse abc.
  Atribua o abca deste abc ao abca.

Etapas necessárias para que se obtenha uns addrinfo routines:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "LoadLibraryA" com "ws2_32.dll"'s first endereço de memória do pedaço devolvendo um número identificador.
  Se o número identificador for 0, atribua "Não foi possível obter o valor do endereço de memória da biblioteca ws2_32.dll." ao erro do fluxo de entrada/saída; exit.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador \Um identificador para o módulo DLL que contém a função ou variável. 
    \A função LoadLibrary, LoadLibraryEx, LoadPackagedLibrary ou GetModuleHandle retorna esse identificador.
    e "getaddrinfo"'s first endereço de memória do pedaço [ponteiro para uma string constante]    \ O nome da função ou variável, ou o valor ordinal da função. 
    \Se este parâmetro for um valor ordinal, ele deve estar contido na word de ordem inferior; a word de ordem superior deve ser zero.
    devolvendo um endereço de memória. \ obtendo/recebendo/aguardando como resultado
  Se o endereço de memória for inexistente, atribua "Infelizmente essa rotinas só funciona no Windows XP ou superior." ao erro do fluxo de entrada/saída; exit.
  Atribua o endereço de memória ao getaddrinfo endereço de memória destas addrinfo routines.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador 
    e "freeaddrinfo"'s first endereço de memória do pedaço [ponteiro para uma string constante] 
    devolvendo o endereço de memória.
  Se o endereço de memória for inexistente, atribua "Infelizmente essas rotinas só funcionam no Windows XP ou numa versão superior do Windows." ao erro do fluxo de entrada/saída; exit.
  Atribua o endereço de memória ao freeaddrinfo endereço de memória destas addrinfo routines.

Etapas necessárias para que se obtenha uma caixa pelo caret em um text:
  Se o text for inexistente, zero a caixa; exit.
  Obtenha uma localização usando o caret deste text e o text.
  Atribua a localização e a localização ao caixa.
  Adicione a altura da linha deste text para a coordenada inferior desta caixa.
  Ajuste a caixa usando 0 e o tpp e 0 e - o tpp.
  Atribua a globalized origin deste text a um origin.
  Se a coordenada esquerda desta caixa for menor do que a coordenada X desta origin, atribua a coordenada X desta origin à coordenada esquerda desta caixa; atribua a coordenada X desta origin à coordenada direita desta caixa.
  Se o wrap detector deste text não estiver ativo, cancele.
  Limite a coordenada esquerda desta caixa para a coordenada esquerda deste text e a coordenada direita deste text.
  Limite a coordenada direita desta caixa para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas necessárias para que se obtenha uma caixa por um line:
  Atribua o start desta line ao canto superior esquerdo desta caixa.
  Atribua o end desta line ao canto inferior direito desta caixa.
  Normalize a caixa.

Etapas necessárias para que se obtenha uma caixa usando uma row e um text:
  Se o text for inexistente, zero a caixa; exit.
  Se a row for inexistente, zero a caixa; exit.
  Atribua a globalized origin deste text ao canto superior esquerdo desta caixa.
  Adicione o número da linha desta row menos 1 times a altura da linha deste text para a coordenada superior desta caixa.
  Atribua a coordenada direita deste text à coordenada direita desta caixa.
  Atribua a coordenada superior desta caixa mais a altura da linha deste text à coordenada inferior desta caixa.

Etapas necessárias para que se obtenha um bucket usando um bucket# e um catálogo:
    \ if o catálogo for inexistente, esvazie o bucket; exit. \ para make compilador faster
  Atribua o first bucket deste catálogo ao bucket.
  Adicione o bucket# times a magnitude desse conjunto de buckets para o bucket.

Etapas necessárias para que se obtenha um bucket usando um catálogo:
    \Se o catálogo for inexistente, esvazie o bucket; exit. \ para fazer o compilador mais rápido
  Se o bucket for inexistente, atribua o first bucket deste catálogo ao bucket; exit.
  Se o bucket for o last bucket deste catálogo, esvazie o bucket; exit.
  Adicione a magnitude desse conjunto de buckets para o bucket.

Etapas necessárias para que se obtenha um bucket usando uma string e um catálogo:
    \ if o catálogo for inexistente, esvazie o bucket; exit. \ para make compilador faster
  Obtenha um bucket# usando a string e o catálogo.
  Obtenha o bucket usando o bucket# e o catálogo.

Etapas necessárias para que se obtenha um bucket# usando uma string e um catálogo:
    \ based sobre o djb2 algorithm
    \ if o catálogo for inexistente, atribua 0 ao bucket#; exit. \ para make compilador faster
  Atribua a quantidade de caracteres desta string ao bucket#.
  Se o bucket# for 0, cancele.
  Adicione 5381 para o bucket#.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um pedaço.
    Lowercase o pedaço.
    Atribua o bucket# a um número.
    Desloque o bucket# left 5 bits.
    Adicione o número para o bucket#.
    Adicione o pedaço para o bucket#.
    Adicione 3 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, pare.
  Repita. [o código acima]
  Conjuncione logicamente o bucket# com o maior número.
  Divida o bucket# pela contagem de buckets deste catálogo usando um quotient e o bucket#.

Etapas necessárias para que se obtenha um pedaço desde uma string:
  Se a string estiver em branco, atribua o null pedaço ao pedaço; exit.
  Atribua o conteúdo deste first endereço de memória do pedaço desta string ao pedaço.
  Remove o first pedaço desde a string.

Etapas necessárias para que se obtenha um pedaço desde uma string (backwards):
  Se a string estiver em branco, atribua o null pedaço ao pedaço; exit.
  Atribua o conteúdo deste last endereço de memória do pedaço desta string ao pedaço.
  Remove o last pedaço desde a string.

Etapas necessárias para que se obtenha um center localização usando uma localização e uma segunda localização:
  Atribua a localização e a segunda localização a um line.
  Atribua o center desta line ao center.

Etapas necessárias para que se obtenha uma cor usando uma localização:
  Call "gdi32.dll" "GetPixel" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um código da cor.
  Converta o código da cor para a cor.

Etapas necessárias para que se obtenha um column# usando uma row e uma localização e um text:
  Atribua 0 ao column#.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, atribua a quantidade de caracteres desta string desta row ao column#; exit. \ only happens sobre last row of text
  Crie o número da fonte of o memory canvas usando o font deste text.
  Obtenha um start largura e um subtexto usando a row e a localização e o text (for "get um column# usando uma row...").
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto é o last endereço de memória do pedaço desta string desta row, pare.
    Obtenha um largura usando o subtexto e o memory canvas.
    Adicione o start largura para o largura.
    Obtenha uma segunda largura usando o conteúdo deste last endereço de memória do pedaço deste subtexto e o memory canvas.
    Divida a segunda largura por 2.
    Subtraia a segunda largura desde o largura.
    Se a coordenada X desta localização for menor do que o largura, pare.
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 1 ao column#.
  Destrua o número da fonte of o memory canvas.

Etapas necessárias para que se obtenha uma contagem of items em um endereço completo no sistema de arquivos:
  Atribua 0 à contagem.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas necessárias para que se obtenha um description por um endereço completo:
  Limpe o description.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Atribua o categoria da unidade de disco ao description.
  Obtenha um nome da unidade de disco pelo endereço completo.
  Se o nome da unidade de disco não estiver em branco, atribua o nome da unidade de disco ao description.
  Lowercase o description.

Etapas necessárias para que se obtenha um difference between um par de números e uma segunda par de números:
  Atribua o par de números à difference.
  Subtraia a segunda par de números desde a difference.

Etapas necessárias para que se obtenha um difference between um par de números e uma segunda par de números usando um malha par de números:
  Obtenha a difference between o par de números e a segunda par de números.
  Arredonde a difference para a malha.

Etapas necessárias para que se obtenha um distance between uma localização e uma segunda localização (approximate):
  Atribua a coordenada X desta localização menos o x desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos o y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número times o número ao distance.
  Adicione o segundo número times o segundo número para o distance.
  Encontre um square root of o distance.
  Atribua o square root ao distance.
  Se a tecla D/d estiver sendo pressionada, produza o relatório de informações usando o distance.

Etapas necessárias para que se obtenha um distance between uma localização e uma segunda localização (chessboard):
  Atribua a coordenada X desta localização menos a coordenada X desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos a coordenada Y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número ao distance.
  Se o segundo número for maior do que o número, atribua o segundo número ao distance.

Etapas necessárias para que se obtenha um categoria da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetDriveTypeA" com 
    O first deste endereço completo 
    devolvendo um número.
  Se o número for 2 [DRIVE_REMOVABLE], atribua "Disco removível" à categoria da unidade de disco; exit. \ removable drive
  Se o número for 3 [DRIVE_FIXED], atribua "Disco Rígido / Pendrive" à categoria da unidade de disco; exit.\ hard disk / flash drive
  Se o número for 4 [DRIVE_REMOTE], atribua "Unidade de rede" à categoria da unidade de disco; exit. \ network drive
  Se o número for 5 [DRIVE_CDROM], atribua "Unidade de CD/DVD" à categoria da unidade de disco; exit. \ cd-rom / dvd drive
  Se o número for 6 [DRIVE_RAMDISK], atribua "Unidade de disco RAM" à categoria da unidade de disco; exit. \ unidade virtual de disco criada a partir da RAM
  Atribua "" à categoria da unidade de disco.

Etapas necessárias para que se obtenha um nome da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Atribua 512 a uma quantidade de caracteres.
  Reassign o first endereço de memória do pedaço desse trecho usando a quantidade de caracteres.
  Call "kernel32.dll" "GetVolumeInformationA" com 
    O first deste endereço completo 
    e O first endereço de memória do pedaço deste trecho
   e a quantidade de caracteres 
   e 0 
   e 0 
   e 0 
   e 0 
   e 0 devolvendo um número.
  Se o número for 0, limpe o nome da unidade de disco; exit.
  Converta o first deste trecho como um pchar para o nome da unidade de disco.

Etapas necessárias para que se obtenha o first-eighth equivalent of uma orientação:
  Obtenha o first-quarter equivalent of a orientação.
  Se a orientação for menor do que 480, cancele.
  Subtraia 960 desde a orientação.
  De-sign a orientação.

Etapas necessárias para que se obtenha o first-quarter equivalent of uma orientação:
  Se a orientação for menor do que 960, cancele.
  Subtraia 960 desde a orientação.
  Repita. [o código acima]

Etapas necessárias para que se obtenha fresh random números;
Etapas necessárias para que se obtenha new random números;
Etapas necessárias para que se seed o random número generator:
  Atribua a contagem de ticks do sistema à seed.

Etapas necessárias para que se obtenha um máximo divisor comum usando um número e um segundo número:
  Atribua o número a um dividend número.
  Atribua o segundo número ao máximo divisor comum.
  De-sign o dividend número.
  De-sign o máximo divisor comum.
  Se o dividend for menor do que o máximo divisor comum, permute o dividend com o máximo divisor comum.
  Se o máximo divisor comum for 0, atribua 1 ao máximo divisor comum; exit.
  Percorra. [o código abaixo]
    Divida o dividend pelo máximo divisor comum usando um quotient e um resto.
    Se o resto for 0, cancele.
    Atribua o máximo divisor comum ao dividend.
    Atribua o resto ao máximo divisor comum.
  Repita. [o código acima]

Etapas necessárias para que se obtenha um Endereço IP usando um host string:
  Limpe o Endereço IP.
  Obtenha um sockaddr usando o host string.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua o s_addr deste sin_addr deste sockaddr ao número deste Endereço IP.
  Call "ws2_32.dll" "inet_ntoa" com 
    O número deste Endereço IP 
    devolvendo um pchar.
  Converta o pchar para a string deste Endereço IP.

Etapas necessárias para que se obtenha um item (not first time):
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "FindNextFileA" com 
    O número identificador deste item 
    e O endereçamento deste WIN32FINDDATA deste item 
    devolvendo um número.
  Se o número não for 0, ajuste o item; exit.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindClose" com 
    O número identificador deste item.

Etapas necessárias para que se obtenha um item desde um endereço completo:
  Se o endereço completo não for endereço da pasta-format, cancele.
  Atribua o endereço completo ao endereço da pasta deste item.
  Se a categoria deste item estiver em branco, obtenha o item desde o endereço completo (first time); exit.
  Obtenha o item (not first time).

Etapas necessárias para que se obtenha um item desde um endereço completo (first time):
  Limpe o erro do fluxo de entrada/saída.
  Isole o endereço completo.
  Posponha "*.*" para o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindFirstFileA" com 
    O first deste endereço completo 
    e O endereçamento deste WIN32FINDDATA deste item 
    devolvendo o número identificador deste item.
  Se o número identificador deste item for -1 [INVALID_HANDLE_VALUE], cancele.
  Ajuste o item.

Etapas necessárias para que se obtenha um mínimo múltiplo comum usando um número e um segundo número:
  Obtenha um máximo divisor comum usando o número e o segundo número.
  Call "kernel32.dll" "MulDiv" com 
    O número 
    e O segundo número 
    e O máximo divisor comum 
    devolvendo o mínimo múltiplo comum.

Etapas necessárias para que se obtenha um letra desde o alphabet:
  Atribua o next letra ao letra.
  Avance o next letra limiting it para o 'A' maiúsculo e o Z maiúsculo.
  Adicione 1 para o next letra.
  Se o next letra for maior do que o Z maiúsculo, atribua o 'A' maiúsculo à next letra.

Etapas necessárias para que se obtenha um número desde a stack:
  Atribua 0 ao número.
  Obtenha um stack entry desde o stack.
  Se a stack entry for inexistente, cancele.
  Converta a string desta stack entry para o número.
  Remove a stack entry desde o stack.
  Destrua a stack entry.

Etapas necessárias para que se obtenha um offset par de números usando uma string e uma caixa e uma font e um alinhamento:
  Crie o número da fonte of o memory canvas usando o font.
  Obtenha o offset par de números usando a string e a caixa e o font e o alinhamento (fast).
  Destrua o número da fonte of o memory canvas.

Etapas necessárias para que se obtenha um offset par de números usando uma string e uma caixa e uma font e um alinhamento (fast):
  Se o alinhamento for "left", obtenha o número X deste offset par de números usando a string e a caixa (fast - left).
  Se o alinhamento for "right", obtenha o número X deste offset par de números usando a string e a caixa (fast - right).
  Se o alinhamento for "center", obtenha o número X deste offset par de números usando a string e a caixa (fast - center).
  Call "gdi32.dll" "GetTextMetricsA" com 
    O memory canvas 
    e O endereçamento desse textmetric.
  Adicione a altura desta caixa menos a tmheight deste textmetric dividido por 2 para o número Y deste offset par de números.

Etapas necessárias para que se obtenha um outlinetextmetric usando um font:
  Crie o número da fonte of o memory canvas usando o font.
  Call "gdi32.dll" "GetOutlineTextMetricsA" com 
    O memory canvas 
    e 0 
    e 0 
    devolvendo um result número.
  Assign um poutlinetextmetric usando o result.
  Call "gdi32.dll" "GetOutlineTextMetricsA" com 
    O memory canvas 
    e O result 
    e O poutlinetextmetric.
  Atribua o conteúdo deste poutlinetextmetric ao outlinetextmetric.
  Destrua o número da fonte of o quadro atual.
  Unassign o poutlinetextmetric.

Etapas necessárias para que se obtenha uma position usando uma localização e um text:
  Se o text for inexistente, limpe o position; exit.
  Obtenha uma row usando a localização e o text.
  Atribua o número da linha desta row ao número da linha desta position.
  Obtenha o column# desta position usando a row e a localização e o text.

Etapas necessárias para que se obtenha um endereço de memória RGB desde um bitmapdata at um número da linha e um column#:
    \ 1 based
  Atribua o scan0 deste bitmapdata ao endereço de memória RGB.
  Adicione o número da linha menos 1 times o stride deste bitmapdata para o endereço de memória RGB.
  Adicione o column# menos 1 times a magnitude desse espaço de cor RGB para o endereço de memória RGB.

Etapas necessárias para que se obtenha um deslocamento vertical e um deslocamento horizontal usando uma orientação: \deslocamento horizontal e vertical?
    \ veja https://pt.wikipedia.org/wiki/Trigonometria_racional
    \ https://pt.wikipedia.org/wiki/Física_digital
    \ A trigonometria racional evita o uso direto de funções transcendentes, como seno e cosseno, substituindo-as por seus equivalentes quadráticos.
  Isole a orientação.
  Normalize a orientação.
  Normalize o original orientação.
  Se a orientação não for uniformemente divisível por 20, estimate o deslocamento vertical e o deslocamento horizontal usando a orientação; exit.
    \ special cases
  Se a orientação for 0, atribua -10000 no deslocamento vertical; atribua -0 no deslocamento horizontal; exit. \ 0 graus
  Se a orientação for 960, atribua 10000 no deslocamento horizontal; atribua -0 no deslocamento vertical; exit. \ 90 graus
  Se a orientação for 1920, atribua 10000 no deslocamento vertical; atribua 0 no deslocamento horizontal; exit. \ 180 graus
  Se a orientação for 2880, atribua -10000 no deslocamento horizontal; atribua 0 no deslocamento vertical; exit. \ 270 graus
  Se a orientação for 3840, produza o relatório de informações usando "orientação inválida"; produza o relatório de informações usando a orientação; produza o relatório de informações usando o original orientação.
    \ force it ao first eighth of o circle
  Obtenha o first-eighth equivalent of a orientação.
    \ encontre o first eighth of o circle unsigned values
  Se a orientação for 20, atribua 0327 no deslocamento horizontal; atribua 9995 no deslocamento vertical; break. \ 1.875 degrees
  Se a orientação for 40, atribua 0654 no deslocamento horizontal; atribua 9979 no deslocamento vertical; break. \ 3.75 degrees
  Se a orientação for 60, atribua 0980 no deslocamento horizontal; atribua 9952 no deslocamento vertical; break. \ 5.625 degrees = 1/64 of o way
  Se a orientação for 80, atribua 1305 no deslocamento horizontal; atribua 9914 no deslocamento vertical; break. \7.5 degrees
  Se a orientação for 100, atribua 1629 no deslocamento horizontal; atribua 9866 no deslocamento vertical; break. \ 9.375 degrees
  Se a orientação for 120, atribua 1951 no deslocamento horizontal; atribua 9808 no deslocamento vertical; break. \ 11.25 degrees = 2/64 of o way
  Se a orientação for 140, atribua 2271 no deslocamento horizontal; atribua 9739 no deslocamento vertical; break. \ 13.125 degrees
  Se a orientação for 160, atribua 2588 no deslocamento horizontal; atribua 9659 no deslocamento vertical; break. \ 15 degrees
  Se a orientação for 180, atribua 2903 no deslocamento horizontal; atribua 9569 no deslocamento vertical; break. \ 16.875 degrees = 3/64 of o way
  Se a orientação for 200, atribua 3214 no deslocamento horizontal; atribua 9469 no deslocamento vertical; break. \ 18.75 degrees
  Se a orientação for 220, atribua 3523 no deslocamento horizontal; atribua 9359 no deslocamento vertical; break. \ 20.625 degrees
  Se a orientação for 240, atribua 3827 no deslocamento horizontal; atribua 9239 no deslocamento vertical; break. \ 22.5 degrees = 4/64 of o way
  Se a orientação for 260, atribua 4127 no deslocamento horizontal; atribua 9109 no deslocamento vertical; break. \ 24.375 degrees
  Se a orientação for 280, atribua 4423 no deslocamento horizontal; atribua 8969 no deslocamento vertical; break. \ 26.25 degrees
  Se a orientação for 300, atribua 4714 no deslocamento horizontal; atribua 8819 no deslocamento vertical; break. \ 28.125 degrees = 5/64 of o way
  Se a orientação for 320, atribua 5000 no deslocamento horizontal; atribua 8660 no deslocamento vertical; break. \ 30 degrees
  Se a orientação for 340, atribua 5281 no deslocamento horizontal; atribua 8492 no deslocamento vertical; break. \ 31.875 degrees
  Se a orientação for 360, atribua 5556 no deslocamento horizontal; atribua 8315 no deslocamento vertical; break. \ 33.75 degrees = 6/64 of o way
  Se a orientação for 380, atribua 5825 no deslocamento horizontal; atribua 8128 no deslocamento vertical; break. \ 35.625 degrees
  Se a orientação for 400, atribua 6088 no deslocamento horizontal; atribua 7934 no deslocamento vertical; break. \ 37.5 degrees
  Se a orientação for 420, atribua 6344 no deslocamento horizontal; atribua 7730 no deslocamento vertical; break. \ 39.375 degrees = 7/64 of o way
  Se a orientação for 440, atribua 6593 no deslocamento horizontal; atribua 7518 no deslocamento vertical; break. \ 41.25 degrees
  Se a orientação for 460, atribua 6836 no deslocamento horizontal; atribua 7299 no deslocamento vertical; break. \ 43.125 degrees
  Se a orientação for 480, atribua 7071 no deslocamento horizontal; atribua 7071 no deslocamento vertical; break. \ 45 degrees = 8/64 of o way
  Repita. [o código acima] \ não é realmente um comando de repetição, é apenas um marcador para as "breaks" aí de cima.
    \ ajuste por segunda eighths of o circle
  Se o original orientação estiver entre 0 e 480, negate o deslocamento vertical; exit. \ 1st eighth (12:00 para 1:30)
  Se o original orientação estiver entre 480 e 960, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento vertical; exit. \ 2nd eighth (1:30 para 3:00)
  Se o original orientação estiver entre 960 e 1440, permute o deslocamento horizontal com o deslocamento vertical; exit. \ 3rd eighth (3:00 para 4:30)
  Se o original orientação estiver entre 1440 e 1920, cancele. \ 4th eighth (4:30 para 6:00)
  Se o original orientação estiver entre 1920 e 2400, negate o deslocamento horizontal; exit. \ 5th eighth (6:00 para 7:30)
  Se o original orientação estiver entre 2400 e 2880, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; exit. \ 6th eighth (7:30 para 9:00)
  Se o original orientação estiver entre 2880 e 3360, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; negate o deslocamento vertical; exit. \ 7th eighth (9:00 para 10:30)
  Se o original orientação estiver entre 3360 e 3840, negate o deslocamento horizontal; negate o deslocamento vertical; exit. \ 8th eighth (10:30 para 12:00)

Etapas necessárias para que se obtenha uma row usando um número da linha e um text:
  Esvazie a row.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha a row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for o número da linha, cancele.
  Repita. [o código acima]

Etapas necessárias para que se obtenha uma row usando uma localização e um text:
  Se o text for inexistente, esvazie a row; exit.
  Atribua a coordenada Y desta localização a uma coordenada Y.
  Limite a coordenada Y para a coordenada superior deste text e a coordenada inferior deste text.
  Atribua a coordenada Y menos a coordenada Y desta globalized origin deste text dividido pela altura da linha deste text mais 1 a um número da linha.
  Limite o número da linha para 1 e a contagem de linhas deste text.
  Obtenha a row usando o número da linha e o text.

Etapas necessárias para que se obtenha uma caixa de seleção usando uma row e um text:
  Limpe a caixa de seleção.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Atribua a caixa ao caixa de seleção.
  Obtenha a caixa de seleção usando a row e o text (lado esquerdo).
  Obtenha a caixa de seleção usando a row e o text (lado direito).

Etapas necessárias para que se obtenha uma caixa de seleção usando uma row e um text (lado esquerdo):
  Atribua a normalized seleção deste text a uma seleção.
  Atribua a coordenada X desta globalized origin deste text à coordenada esquerda desta caixa de seleção.
  Se o anchor número da linha desta seleção for o número da linha desta row, obtenha uma localização usando o anchor desta seleção e o text; atribua a coordenada X desta localização à coordenada esquerda desta caixa de seleção.
  Limite a coordenada esquerda desta caixa de seleção para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas necessárias para que se obtenha uma caixa de seleção usando uma row e um text (lado direito):
  Atribua a normalized seleção deste text a uma seleção.
  Atribua a coordenada direita deste text à coordenada direita desta caixa de seleção.
  Se o número de linhas do cursor desta seleção for o número da linha desta row, obtenha uma localização usando o caret desta seleção e o text; atribua a coordenada X desta localização à coordenada direita desta caixa de seleção.
  Limite a coordenada direita desta caixa de seleção para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, obtenha o size usando o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo for file-format, obtenha o size usando o endereço completo no sistema de arquivos (arquivo).

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos (pasta)[endereço]:
  Atribua 0 ao size.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Se a categoria deste item for "arquivo", adicione o size deste item para o size; repita.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Obtenha uma segunda size usando a segunda endereço completo no sistema de arquivos.
    Adicione a segunda size para o size.
  Repita. [o código acima]

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesExA" com 
    O first deste endereço completo 
    e 0 
    e O endereçamento desse WIN32FINDDATA.
  Atribua o nFileSizeLow deste WIN32FINDDATA ao size.

Etapas necessárias para que se obtenha um sockaddr usando um host string:
  Limpe o erro do fluxo de entrada/saída.
    \ prepare strings
  Isole o host string.
  Modifique através do caractere NUL o host string.
    \ obtenha o function addresses
  Obtenha uns addrinfo routines.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
    \ obtenha o sockaddr
  Atribua 2 [AF_INET] ao ai_family desse addrinfo.
  Atribua 1 [SOCK_STREAM] ao ai_sockettype deste addrinfo.
  Atribua 6 [IPPROTO_TCP] ao ai_protocol deste addrinfo.
  Call o getaddrinfo destas addrinfo routines com 
    O first endereço de memória do pedaço desta host string 
    e 0 e o endereçamento deste addrinfo
   e o endereçamento desse addrinfoptr 
     devolvendo um result número.
  Se o result número não for 0, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; exit.
  Se o addrinfoptr for inexistente, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; exit.
  Atribua o conteúdo deste ai_addr deste addrinfoptr ao sockaddr.
  Call o freeaddrinfo destas addrinfo routines com o addrinfoptr.

Etapas necessárias para que se obtenha uma localização usando uma position e um text:
  Limpe a localização.
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número da linha desta position e o text.
  Obtenha uma caixa usando a row e o text.
  Atribua a coordenada superior desta caixa à coordenada y desta localização.
  Atribua o first endereço de memória do pedaço desta string desta row ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto mais o column# desta position menos 2 ao last endereço de memória do pedaço deste subtexto.
  Obtenha um largura usando o subtexto e o memory canvas e o font deste text.
  Atribua a coordenada esquerda desta caixa mais o largura à coordenada x desta localização.
  Obtenha um offset par de números usando o working string desta row e a caixa e a font deste text e o alinhamento deste text.
  Adicione o número X deste offset par de números para a coordenada X desta localização.

Etapas necessárias para que se obtenha um start largura e um subtexto usando uma row e uma localização e um text (for "get um column# usando uma row..."):
  Limpe o start largura.
  Limpe o subtexto.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Lance o subtexto sobre o working string desta row.
  Obtenha um offset par de números usando o subtexto e a caixa e a font deste text e o alinhamento deste text (fast).
  Atribua a coordenada X desta globalized origin deste text mais o número X deste offset par de números ao start largura.
  Atribua o first endereço de memória do pedaço deste subtexto mais o text cutoff menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que ou igual ao last endereço de memória do pedaço desta string desta row, pare.
    Obtenha um largura usando o subtexto e o memory canvas.
    Atribua o start largura mais o largura a uma segunda largura.
    Se a coordenada X desta localização for menor do que ou igual ao segunda largura, pare.
    Adicione o largura para o start largura.
    Mova o subtexto usando o text cutoff.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto ao last endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se obtenha uma string desde o stack:
  Limpe a string.
  Obtenha um stack entry desde o stack.
  Se o stack entry for inexistente, atribua "ERRO" à string; exit.
  Atribua a string desta stack entry para a string.
  Remove o stack entry desde o stack.
  Destrua o stack entry.

Etapas necessárias para que se obtenha uma string desde a área de transferência do Windows:
  Limpe a string.
  Call "user32.dll" "OpenClipboard" com 
    A main window.
  Call "user32.dll" "GetClipboardData" com 
  1 [CF_TEXT] 
    devolvendo um número identificador.
  Se o número identificador for 0, call "user32.dll" "CloseClipboard"; exit.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador 
    devolvendo um pchar.
  Converta o pchar para a string.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "user32.dll" "CloseClipboard".

Etapas necessárias para que se obtenha uma coisa desde umas coisas:
  Se  as coisas estiverem vazio, esvazie a coisa; exit.
  Se a coisa for inexistente, atribua o first destas coisas à coisa; exit.
  Atribua o next desta coisa à coisa.

Etapas necessárias para que se obtenha uma coisa desde umas coisas (backwards):
  Se  as coisas estiverem vazio, esvazie a coisa; exit.
  Se a coisa for inexistente, atribua o last destas coisas à coisa; exit.
  Atribua o previous desta coisa à coisa.

Etapas necessárias para que se obtenha um segmento inicial desde um reply:
  Remove algum tipo de leading noise desde o reply.
  Limpe o segmento inicial.
  Percorra. [o código abaixo]
    Se o reply estiver em branco, cancele.
    Obtenha um pedaço desde o reply.
    Se o pedaço for o caractere de espaço, cancele.
    Posponha o pedaço para o segmento inicial.
  Repita. [o código acima]

Etapas necessárias para que se obtenha um largura usando um pedaço e um canvas:
  Call "gdi32.dll" "GetTextExtentPoint32A" com 
    O canvas 
    e O endereçamento deste pedaço 
    e 1 
    e O endereçamento desse par de números.
  Atribua o número X deste par de números à largura.

Etapas necessárias para que se obtenha um largura usando um pedaço e uns font larguras:
  Atribua o pedaço a um número.
  Obtenha o largura usando o número e o font larguras.

Etapas necessárias para que se obtenha um largura usando um número e uns font larguras:
    \ indexes são 0 based
  Se o font larguras são nil, limpe o largura; exit.
  Atribua o data destes font larguras a um endereço numérico.
  Adicione o número times a magnitude deste número para o endereço numérico.
  Atribua o conteúdo deste endereço numérico ao largura.

Etapas necessárias para que se obtenha um largura usando uma string e um canvas:
    \ assumes font é already selecionado em canvas
  Call "gdi32.dll" "GetTextExtentPoint32A" com 
    O canvas 
    e O first endereço de memória do pedaço desta string 
    e A quantidade de caracteres desta string 
    e O endereçamento desse par de números.
  Atribua o número X deste par de números ao largura.

Etapas necessárias para que se obtenha um largura usando uma string e um canvas e um font:
  Crie o número da fonte of o canvas usando o font.
  Obtenha o largura usando a string e o canvas.
  Destrua o número da fonte of o canvas.

Etapas necessárias para que se obtenha um largura usando uma string e um font:
    \ assumes memory canvas
  Obtenha o largura usando a string e o memory canvas e o font.

Etapas necessárias para que se obtenha uma coordenada X usando uma string e uma caixa (fast - center):
  Obtenha um largura usando a string e o memory canvas.
  Obtenha um abca e um abcc usando a string e o memory canvas.
  Atribua o largura menos o abca menos o abcc ao largura.
  Atribua a largura desta caixa menos o largura dividido por 2 menos o abca à coordenada x.

Etapas necessárias para que se obtenha uma coordenada X usando uma string e uma caixa (fast - left):
  Obtenha um abca usando a string e o memory canvas.
  Atribua - o abca à coordenada x.

Etapas necessárias para que se obtenha uma coordenada X usando uma string e uma caixa (fast - right):
  Obtenha um abca e um abcc usando a string e o memory canvas.
  Obtenha um largura usando a string e o memory canvas.
  Atribua o largura menos o abca menos o abcc ao largura.
  Atribua a largura desta caixa menos o largura menos o abca à coordenada x.

Um gigabyte é 1024 megabytes.

Etapas necessárias para que se globalize uma caixa usando um par de números:
  Mova a caixa usando o par de números.

Etapas necessárias para que se globalize uma localização usando um par de números:
  Mova a localização usando o par de números.

Etapas necessárias para que se go back para where we were:
  Restore o context.

Um GpBitmap é um GpImage.

Um GpGraphic é um endereço de memória.

Um GpImage é um endereço de memória.

An GpImageAttributes é um endereço de memória.

Um GpRect é um conjunto com
  Um número denominado x,
  Um número denominado y,
  Um número denominado largura,
  Um número denominado altura.

O gptoken é um gptoken.

Um gptoken é um número.

An grain é 10 milliseconds.

O grayscale cor matrix é um texto hexadecimal igual a $8716993E8716993E8716993E0000000000000000A245163FA245163FA245163F0000000000000000D578E93DD578E93DD578E93D00000000000000000000000000000000000000000000803F00000000000000000000000000000000000000000000803F.

Um malha é um par de números.

Etapas necessárias para que se garanta one row em um text:
  Se o text for inexistente, cancele.
  Se as rows deste text não estiverem vazio, cancele.
  Crie uma row usando o return pedaço.
  Posponha a row para as rows deste text.
  Renumber as rows deste text.

Um guid é um UUID. \ identificador único global

O hand cursor é um cursor.

Etapas necessárias para que se mude alinhamento usando um text e um alinhamento:
  Se o text for inexistente, cancele.
  Relembre o text com "alinhamento".
  Align o text usando o alinhamento.

Etapas necessárias para que se execute algum tipo de wm-activate com um w-param:
  Split o w-param a um word e uma segunda word.
  Atribua a segunda word a um número.
  Se o número for 0, execute algum tipo de wm-activate com o w-param (deactivate); exit.
  Execute algum tipo de wm-activate com o w-param (activate).

Etapas necessárias para que se execute algum tipo de wm-activate com um w-param (activate):
  Call "user32.dll" "SetFocus" com 
    A main window.
  Call "user32.dll" "ClipCursor" com 
  0.
    \ seterrormode(sem_failcriticalerrors) \ keeps certain disk erros desde appearing
  Crie um event.
  Atribua "activate" à categoria deste event.
    \Atribua "activar" à categoria deste event.
  Enfileire o event.
  Call "user32.dll" "PostMessageA" com 
    A main window 
    e 0 [wm_null] 
    e 0 
    e 0.

Etapas necessárias para que se execute algum tipo de wm-activate com um w-param (deactivate):
  Crie um event.
  Atribua "deactivate" à categoria deste event.
    \Atribua "desactivar" à categoria deste event.
  Enfileire o event.
  Call "user32.dll" "PostMessageA" com 
    A main window 
    e 0 [wn_null] 
    e 0 
    e 0.

Etapas necessárias para que se execute algum tipo de wm-char com um w-param e um l-param:
    \Se a tecla Alt was para baixo, cancele. \ removed por Spanish teclaboard AltGr e ctrl+alt characters
    \Se a tecla Ctrl was para baixo, cancele. \ removed por Spanish teclaboard AltGr e ctrl+alt characters
  Atribua o w-param a um pedaço.
  Se o pedaço não for printable, cancele.
  Crie um event.
  Atribua "pressionamento de tecla" à categoria deste event.
    \Atribua "tecla abajo" à categoria deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Atribua o pedaço ao pedaço deste event.
  Converta o l-param para a tecla deste event.
  Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-create com um window:
  Atribua a window à main window.

Etapas necessárias para que se execute algum tipo de wm-destroy:
  Call "user32.dll" "PostQuitMessage" com 
  0.

Etapas necessárias para que se execute algum tipo de wm-lbuttondblclk com um l-param:
  Crie um event.
  Atribua "clique duplo" à categoria deste event.
    \Atribua "clic izquierdo doble" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o l-param para a localização deste event.
  Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-lbuttondown com um l-param:
  Crie um event.
  Atribua "clique" à categoria deste event.
    \Atribua "clic izquierdo" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o l-param para a localização deste event.
  Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-paint com um window:
  Call "user32.dll" "BeginPaint" com 
    A window 
    e O endereçamento desse paintstruct.
  Call "user32.dll" "EndPaint" com 
    A window 
    e O endereçamento desta paintstruct.
  Crie um event.
  Atribua "atualização de tela" à categoria deste event.
    \Atribua "refrescar" à categoria deste event.
  Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-rbuttondblclk com um l-param:
  Crie um event.
  Atribua "clique direito duplo" à categoria deste event.
    \Atribua "clic derecho doble" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o l-param para a localização deste event.
  Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-rbuttondown com um l-param:
  Crie um event.
  Atribua "clique direito" à categoria deste event.
    \Atribua "clic derecho" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o l-param para a localização deste event.
  Enfileire o event.

Etapas necessárias para que se execute algum tipo de wm-setcursor:
  Atualize o cursor.

Etapas necessárias para que se execute algum tipo de wm-syskeydown com um w-param e um l-param;
Etapas necessárias para que se execute algum tipo de wm-keydown com um w-param e um l-param:
  Atribua o w-param a um tecla.
  Se a tecla com o l-param é algum tipo de repeated escape ou modifier tecla, cancele.
  Se a tecla for algum tipo de wm-char tecla, cancele.
  Crie um event.
  Atribua "pressionamento de tecla" à categoria deste event.
    \Atribua "tecla abajo" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Atribua a tecla à tecla deste event.
  Enfileire o event.

Etapas necessárias para que se execute capitalize usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "capitalize".
  Capitalize algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas necessárias para que se efetue cópias usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Extraia uma string desde o text (pedaços selecionados).
  Atribua a string sobre o área de transferência do Windows.

Etapas necessárias para que se execute cut usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text.
  Extraia uma string desde o text (pedaços selecionados).
  Atribua a string sobre o área de transferência do Windows.
  Remove algum tipo de pedaços selecionados no text.
  Wrap o text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um console:
  Se o console for inexistente, cancele.
  Se a categoria deste event for "pressionamento de tecla", execute o event usando o console (pressionamento de tecla); exit.
  Se a categoria deste event for "atualização de tela", execute o event usando o console (atualização de tela); exit.
  Se a categoria deste event for "clique direito", execute o event usando o console (clique direito); exit.
  Se a categoria deste event for "mostrar seta", execute o event usando o console (mostrar seta do mouse); exit.

Etapas necessárias para que se execute um event usando um console (tecla backspace):
  Se o reply deste console estiver em branco, cancele.
  Se o event foi alterado, cancele.
  Execute o event usando o text deste console (tecla backspace).
  Remove o last pedaço desde o reply deste console.
  Mostre o console.

Etapas necessárias para que se execute um event usando um console (seta pra baixo):
  Role o text deste console para baixo one line.
  Mostre o console.

Etapas necessárias para que se execute um event usando um console (tecla End):
  Role o text deste console para o base.
  Mostre o console.

Etapas necessárias para que se execute um event usando um console (tecla Enter):
  Execute o event usando o text deste console (tecla Enter).
  Relinquish control.

Etapas necessárias para que se execute um event usando um console (tecla Home):
  Role o text deste console para o topo.
  Mostre o console.

Etapas necessárias para que se execute um event usando um console (pressionamento de tecla):
  Se a tecla deste event for a tecla backspace, execute o event usando o console (tecla backspace); exit.
  Se a tecla deste event for a seta pra baixo, execute o event usando o console (seta pra baixo); exit.
  Se a tecla deste event for a tecla End, execute o event usando o console (tecla End); exit.
  Se a tecla deste event for a tecla Enter, execute o event usando o console (tecla Enter); exit.
  Se a tecla deste event for a tecla Home, execute o event usando o console (tecla Home); exit.
  Se a tecla deste event for a tecla PgDn, execute o event usando o console (tecla Page Down); exit.
  Se a tecla deste event for a tecla PgUp, execute o event usando o console (tecla Page Up); exit.
  Se a tecla deste event for a seta pra cima, execute o event usando o console (seta pra cima); exit.
  Se o pedaço deste event não for printable, cancele.
  Posponha o pedaço deste event para o reply deste console.
  Execute o event usando o text deste console (caracteres gráficos).
  Mostre o console.

Etapas necessárias para que se execute um event usando um console (tecla Page Down):
  Role o text deste console para baixo one página.
  Mostre o console.

Etapas necessárias para que se execute um event usando um console (tecla Page Up):
  Role o text deste console para cima one página.
  Mostre o console.

Etapas necessárias para que se execute um event usando um console (atualização de tela):
  Mostre o console.

Etapas necessárias para que se execute um event usando um console (clique direito):
  Mostre o hand cursor.
  Role o console usando o event.
  Atualize o cursor.

Etapas necessárias para que se execute um event usando um console (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas necessárias para que se execute um event usando um console (seta pra cima):
  Role o text deste console para cima one line.
  Mostre o console.

Etapas necessárias para que se execute um event usando um terminal:
  Se o terminal for inexistente, cancele.
  Se a categoria deste event for "pressionamento de tecla", execute o event usando o terminal (pressionamento de tecla); exit.
  Se a categoria deste event for "atualização de tela", execute o event usando o terminal (atualização de tela); exit.
  Se a categoria deste event for "mostrar seta", execute o event usando o terminal (mostrar seta do mouse); exit.
  Se a categoria deste event for "clique", relinquish control. \ *** added por invisível turtle book questionable

Etapas necessárias para que se execute um event usando um terminal (tecla backspace):
  Se o reply deste terminal estiver em branco, cancele.
  Se o event foi alterado, cancele.
  Remove o last pedaço desde o reply deste terminal.
  Remove o last pedaço desde a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas necessárias para que se execute um event usando um terminal (tecla Enter):
  Relinquish control. \Abdique

Etapas necessárias para que se execute um event usando um terminal (pressionamento de tecla):
  Se a tecla deste event for a tecla backspace, execute o event usando o terminal (tecla backspace); exit.
  Se a tecla deste event for a tecla Enter, execute o event usando o terminal (tecla Enter); exit.
  Se o pedaço deste event não for printable, cancele.
  Posponha o pedaço deste event para o reply deste terminal.
  Posponha o pedaço deste event para a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas necessárias para que se execute um event usando um terminal (atualização de tela):
  Mostre o terminal.

Etapas necessárias para que se execute um event usando um terminal (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas necessárias para que se execute um event usando um text (tecla backspace):
  Se o text for inexistente, cancele.
  Se não existir something para backspace no text, cancele.
  Relembre o text com "backspace".
  Se o event foi alterado, remova pedaços de o text (backspace com jump).
  Se o event não foi alterado, remova pedaços de o text (backspace).
  Wrap o text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Delete):
  Se o text for inexistente, cancele.
  Se não existir something para remove no text, cancele.
  Relembre o text com "delete".
  Se o event foi alterado, remova pedaços de o text (forward delete com jump).
  Se o event não foi alterado, remova pedaços de o text (forward delete).
  Wrap o text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (seta pra baixo):
  Se o text for inexistente, cancele.
  Se o caret of o text é sobre o last line, acione um detector.
  Se o detector estiver ativo, mova o caret para o last pedaço of o text.
  Se o detector não estiver ativo, mova o caret para baixo no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla End):
  Se o text for inexistente, cancele.
  Se o event foi alterado, mova o caret para o last pedaço of o text.
  Se o event não foi alterado, mova o caret para o last pedaço of o current row of o text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Enter):
  Se o text for inexistente, cancele.
  Relembre o text com "insert return".
  Remove algum tipo de pedaços selecionados no text.
  Insira o return pedaço ao text.
  Wrap o text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Esc):
  Se o text for inexistente, cancele.
  Desvencilhe-se de o text.

Etapas necessárias para que se execute um event usando um text (tecla Home):
  Se o text for inexistente, cancele.
  Se o event foi alterado, mova o caret para o first pedaço of o text.
  Se o event não foi alterado, mova o caret para o first pedaço of o current row of o text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (clique duplo):
  Se o text for inexistente, cancele.
  Desvencilhe-se de o text.
  Mova o caret right para algum tipo de non-alfanumérico pedaço no text.
  Mova o anchor left para algum tipo de non-alfanumérico pedaço no text.

Etapas necessárias para que se execute um event usando um text (seta esquerda):
  Se o text for inexistente, cancele.
  Se o event foi alterado, jump o caret left no text.
  Se o event não foi alterado, mova o caret left no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Page Down):
  Se o text for inexistente, cancele.
  Role o text para baixo one página.
  Mova o caret para baixo one página no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.

Etapas necessárias para que se execute um event usando um text (tecla Page Up):
  Se o text for inexistente, cancele.
  Role o text para cima one página.
  Mova o caret para cima one página no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.

Etapas necessárias para que se execute um event usando um text (caracteres gráficos):
  Relembre o text com "insert".
  Remove algum tipo de pedaços selecionados no text.
  Insira o pedaço deste event ao text.
  Wrap o text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (seta direita):
  Se o text for inexistente, cancele.
  Se o event foi alterado, jump o caret right no text.
  Se o event não foi alterado, mova o caret right no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (tecla Tab):
  Se o text for inexistente, cancele.
  Relembre o text com "insert".
  Remove algum tipo de pedaços selecionados no text.
  Insira o caractere de espaço ao text.
  Divida o caret column# deste text por 2 usando um quotient e um resto.
  Se o resto for 0, insira o caractere de espaço ao text.
  Role o text para o caret.

Etapas necessárias para que se execute um event usando um text (seta pra cima):
  Se o text for inexistente, cancele.
  Mova o caret para cima no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas necessárias para que se execute events usando um console:
  Se o console for inexistente, cancele.
  Percorra. [o código abaixo]
    Desenfileire um event.
    Se o event for inexistente, cancele.
    Execute o event usando o console.
  Repita. [o código acima]

Etapas necessárias para que se execute events usando um terminal:
  Se o terminal for inexistente, cancele.
  Percorra. [o código abaixo]
    Desenfileire um event.
    Se o event for inexistente, cancele.
    Execute o event usando o terminal.
  Repita. [o código acima]

Etapas necessárias para que se mude tamanho usando um text e uma caixa e uma altura da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "altura da fonte".
  Mude o text usando a caixa.
  Mude o text usando o altura da fonte.

Etapas necessárias para que se mude tamanho usando um text e uma altura da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "altura da fonte".
  Mude o text usando o altura da fonte.

Etapas necessárias para que se mude nome da fonte usando um text e uma nome da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "nome da fonte".
  Mude o text usando o nome da fonte.

Etapas necessárias para que se execute indent usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "dent".
  Indent algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Um número identificador é um número.

Etapas necessárias para que se execute lowercase usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "case".
  Lowercase algum tipo de pedaços selecionados no text.
  Wrap o text.

Etapas necessárias para que se execute outdent usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "dent".
  Outdent algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas necessárias para que se execute paste usando um text:
  Se o text for inexistente, cancele.
  Se não existir text sobre o área de transferência do Windows, cancele.
  Relembre o text.
  Remove algum tipo de pedaços selecionados no text.
  Obtenha uma string desde o área de transferência do Windows.
  Insira a string ao text.
  Wrap o text.
  Role o text para o caret.

Etapas necessárias para que se efetue alteração de cor usando um text e uma cor:
  Se o text for inexistente, cancele.
  Relembre o text com "pincel".
  Atribua a cor ao pincel deste text.

Etapas necessárias para que se execute redo usando um text:
  Se o text for inexistente, cancele.
  Se o last destes redos deste text for inexistente, cancele.
  Copie o text a uma segunda text.
  Posponha a segunda text para os undos deste text.
  Atribua o last destes redos deste text a um terceiro text.
  Remove o terceiro text desde os redos deste text.
  Copie o guts of o terceiro text ao text.
  Destrua o terceiro text.
  Ligue o detector de alteração deste text.

Etapas necessárias para que se execute reverse usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "reverse".
  Reverse algum tipo de rows selecionadas of o text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas necessárias para que se execute select all usando um text:
  Se o text for inexistente, cancele.
  Selecione cada pedaço no text.

Etapas necessárias para que se execute classifique algum tipo de rows selecionadas usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "classifique rows selecionadas".
  Classifique algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas necessárias para que se execute undo usando um text:
  Se o text for inexistente, cancele.
  Se o last destes undos deste text for inexistente, cancele.
  Copie o text a uma segunda text.
  Posponha a segunda text para os redos deste text.
  Atribua o last destes undos deste text a um terceiro text.
  Remove o terceiro text desde os undos deste text.
  Copie o guts of o terceiro text ao text.
  Destrua o terceiro text.
  Ligue o detector de alteração deste text.

Etapas necessárias para que se execute uppercase usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "case".
  Uppercase algum tipo de pedaços selecionados no text.
  Wrap o text.

Um hbitmap é um número identificador.

Um hbrush é um número identificador.

Um hdc é um número identificador.

Um orientação é uns points.

O contagem do heap é um número.

O endereço heap é um endereço de memória.

Um altura é uns twips.

Um texto hexadecimal é uma string.

Um número da fonte é um número identificador.

Um hicon é um número identificador.

Etapas necessárias para que se hide o cursor:
  Call "user32.dll" "ShowCursor" com 
  0 
    devolvendo um número.
  Se o número for menor do que 0, cancele.
  Repita. [o código acima]

Um horizontal line é um line.

Um hour é 60 minutes.

Um hpen é um número identificador.

Um hrgn é um número identificador.

Um matiz é uns precise degrees [0 para 3599].

  

O i-beam cursor é um cursor.

    \the erro do fluxo de entrada/saída é uma string.

Um iid é um UUID. \ Um interface identifier é um Identificador único universal

Etapas necessárias para que se imagine uma caixa uns twips por uns segunda twips;
Etapas necessárias para que se make uma caixa uns twips por uns segunda twips:
  Atribua 0 à coordenada esquerda desta caixa.
  Atribua 0 à coordenada superior desta caixa.
  Atribua os twips à coordenada direita desta caixa.
  Atribua a segunda twips à coordenada inferior desta caixa.

Etapas necessárias para que se imagine uma caixa uns twips high por uns segunda twips wide;
Etapas necessárias para que se make uma caixa uns twips high por uns segunda twips wide:
  Atribua 0 e 0 e a segunda twips e os twips ao caixa.

Etapas necessárias para que se imagine uma caixa uns twips smaller do que uma segunda caixa;
Etapas necessárias para que se make uma caixa uns twips smaller do que uma segunda caixa:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips dividido por 2.

Etapas necessárias para que se imagine uma caixa uns twips smaller do que uma segunda caixa sobre cada side:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips.

Etapas necessárias para que se imagine uma caixa uns twips wide por uns segunda twips high;
Etapas necessárias para que se make uma caixa uns twips wide por uns segunda twips high:
  Atribua 0 e 0 e os twips e a segunda twips ao caixa.

Etapas necessárias para que se imagine uma caixa com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior;
Etapas necessárias para que se make uma caixa com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior:
  Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior ao caixa.

Etapas necessárias para que se imagine uma caixa com uma localização e uma segunda localização;
Etapas necessárias para que se make uma caixa com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao caixa.

Etapas necessárias para que se imagine uma cor desde um matiz e um saturação e um luminosidade;
Etapas necessárias para que se make uma cor desde um matiz e um saturação e um luminosidade:
  Atribua o matiz e o saturação e o luminosidade à cor.

Etapas necessárias para que se imagine um dot about uns twips wide;
Etapas necessárias para que se make um dot about uns twips wide;
Etapas necessárias para que se make um dot uns twips wide:
  Make o dot os twips pelo twips.

Etapas necessárias para que se imagine um dot between uns twips e uns segunda twips wide;
Etapas necessárias para que se make um dot between uns twips e uns segunda twips wide:
  Escolha aleatoriamente uns terceiro twips between os twips e a segunda twips.
  Make o dot o terceiro twips wide.

Etapas necessárias para que se imagine um elipse usando uma caixa;
Etapas necessárias para que se make um elipse usando uma caixa:
  Atribua a caixa à caixa desta elipse.

Etapas necessárias para que se imagine um elipse uns twips por uns segunda twips;
Etapas necessárias para que se make um elipse uns twips por uns segunda twips:
  Atribua 0 à coordenada esquerda desta elipse.
  Atribua 0 à coordenada superior desta elipse.
  Atribua os twips à coordenada direita desta elipse.
  Atribua a segunda twips à coordenada inferior desta elipse.

Etapas necessárias para que se imagine um elipse com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior;
Etapas necessárias para que se make um elipse com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior:
  Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior ao elipse.

Etapas necessárias para que se imagine um elipse com uma localização e uma segunda localização;
Etapas necessárias para que se make um elipse com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao elipse.

Etapas necessárias para que se imagine uma figura using uma string e uma localização;
Etapas necessárias para que se make uma figura using uma string e uma localização;
Etapas necessárias para que se crie uma figura using uma string e um center localização:
  Crie a figura.
  Posponha a figura para as figuras.
  Isole a string.
  Lowercase a string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
  Skip algum tipo de leading noise no subtexto.
  Se a quantidade de caracteres deste subtexto for menor do que 2, cancele.
  Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um pedaço.
  Atribua o pedaço menos o 'a' minúsculo ao y desse localização.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto ao pedaço.
  Atribua o pedaço menos o 'a' minúsculo ao x desta localização.
  Multiplique a localização por 24 px.
  Adicione o x deste center localização menos 299 pixels para o x desta localização.
  Adicione o y deste center localização menos 299 pixels para o y desta localização.
  Posponha a localização para a figura.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se imagine um horizontal line uma fração of o way para cima desde o base of uma caixa;
Etapas necessárias para que se make um horizontal line uma fração of o way para cima desde o base of uma caixa:
  Imagine o horizontal line across a caixa a fração of o way para cima desde o base.

Etapas necessárias para que se imagine um line across o base of uma caixa;
Etapas necessárias para que se make um line across o base of uma caixa;
Etapas necessárias para que se imagine um line along o base of uma caixa;
Etapas necessárias para que se make um line along o base of uma caixa:
  Atribua a coordenada inferior desta caixa line ao line.

Etapas necessárias para que se imagine um line across uma caixa uma fração of o way para cima desde o base;
Etapas necessárias para que se make um line across uma caixa uma fração of o way para cima desde o base:
  Atribua a coordenada esquerda desta caixa ao x deste start desta line.
  Atribua a coordenada direita desta caixa ao x deste end desta line.
  Atribua a coordenada inferior desta caixa times a fração a uns twips.
  Atribua a coordenada inferior desta caixa menos os twips ao y deste start desta line.
  Atribua a coordenada inferior desta caixa menos os twips ao y deste end desta line.

Etapas necessárias para que se imagine um line across o topo of uma caixa;
Etapas necessárias para que se make um line across o topo of uma caixa;
Etapas necessárias para que se imagine um line along o topo of uma caixa;
Etapas necessárias para que se make um line along o topo of uma caixa:
  Atribua a coordenada superior desta caixa line ao line.

Etapas necessárias para que se imagine um line no middle of uma caixa;
Etapas necessárias para que se make um line no middle of uma caixa;
Etapas necessárias para que se imagine um line across o middle of uma caixa;
Etapas necessárias para que se make um line across o middle of uma caixa;
Etapas necessárias para que se imagine um line no center of uma caixa;
Etapas necessárias para que se make um line no center of uma caixa;
Etapas necessárias para que se imagine um line across o center of uma caixa;
Etapas necessárias para que se make um line across o center of uma caixa:
  Atribua a coordenada esquerda desta caixa ao x deste start desta line.
  Atribua a coordenada direita desta caixa ao x deste end desta line.
  Atribua o y deste center desta caixa ao y deste start desta line.
  Atribua o y deste center desta caixa ao y deste end desta line.

Etapas necessárias para que se imagine um line uns twips para cima desde o base of uma caixa;
Etapas necessárias para que se make um line uns twips para cima desde o base of uma caixa:
  Atribua a coordenada esquerda desta caixa ao x deste start desta line.
  Atribua a coordenada direita desta caixa ao x deste end desta line.
  Atribua a coordenada inferior desta caixa menos os twips ao y deste start desta line.
  Atribua a coordenada inferior desta caixa menos os twips ao y deste end desta line.

Etapas necessárias para que se imagine um line com uma localização e uma segunda localização;
Etapas necessárias para que se make um line com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao line.

Etapas necessárias para que se imagine um line com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y;
Etapas necessárias para que se make um line com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y:
  Atribua a coordenada X e a coordenada Y e a segunda coordenada X e a segunda coordenada Y ao line.

Etapas necessárias para que se imagine uma caixa arredondada desde uma caixa e um raio;
Etapas necessárias para que se make uma caixa arredondada desde uma caixa e um raio:
  Atribua a caixa e o raio ao caixa arredondada.

Etapas necessárias para que se imagine uma caixa arredondada uns twips por uns segunda twips;
Etapas necessárias para que se make uma caixa arredondada uns twips por uns segunda twips com um raio:
  Atribua 0 à coordenada esquerda desta caixa arredondada.
  Atribua 0 à coordenada superior desta caixa arredondada.
  Atribua os twips à coordenada direita desta caixa arredondada.
  Atribua a segunda twips à coordenada inferior desta caixa arredondada.
  Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se imagine uma caixa arredondada com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior e um raio;
Etapas necessárias para que se make uma caixa arredondada com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior e um raio:
  Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior e o raio ao caixa arredondada.

Etapas necessárias para que se imagine uma caixa arredondada com uma localização e uma segunda localização e um raio;
Etapas necessárias para que se make uma caixa arredondada com uma localização e uma segunda localização e um raio:
  Atribua a localização e a segunda localização e o raio ao caixa arredondada.

Etapas necessárias para que se imagine uma localização com uma coordenada X e uma coordenada Y;
Etapas necessárias para que se make uma localização com uma coordenada X e uma coordenada Y:
  Atribua a coordenada X e a coordenada Y à localização.

Etapas necessárias para que se indent algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
  Se a row for inexistente, cancele.
  Se a row of o text não estiver selecionado, repita.
  Se a row estiver em branco, repita.
  Anteponha o caractere de espaço para a string deste row.
  Anteponha o caractere de espaço para a string deste row.
  Repita. [o código acima]

Um indent é uma contagem.

Um catálogo é uma coisa com
Um contagem de buckets,
Um first bucket e um last bucket.

Etapas necessárias para que se catalogue um endereço de memória usando uma string e um catálogo:
    \ if o catálogo for inexistente, cancele. \ para make compilador faster
  Se a quantidade de caracteres desta string for 0, cancele.
  Obtenha um bucket usando a string e o catálogo.
  Crie um refer.
  Posponha o refer para os refers deste bucket.
  Atribua a string à string deste refer.
  Atribua o endereço de memória ao endereço de memória deste refer.

Etapas necessárias para que se catalogue uma string em um catálogo:
    \ if o catálogo for inexistente, cancele. \ para make compilador faster
  Catalogue nil usando a string e o catálogo.

Etapas necessárias para que se initalize o terminal:
  Crie o terminal na caixa desta tela.

Etapas necessárias para que se initialize before run:
  Call "user32.dll" "DisableProcessWindowsGhosting".
  Call "kernel32.dll" "GetProcessHeap" 
    devolvendo o endereço heap.
  Call "kernel32.dll" "LoadLibraryA" com 
  "kernel32.dll"'s first endereço de memória do pedaço 
    devolvendo um número identificador.
  Se o número identificador não for 0, call "kernel32.dll" "GetProcAddress" com 
    O número identificador 
    e "HeapSetInformation"'s first endereço de memória do pedaço 
    devolvendo um endereço de memória.
  Se o endereço de memória não for inexistente, call o endereço de memória com o endereço heap e 0 e 2's endereçamento e 4.

Etapas necessárias para que se inicialize o canvases:
  Inicialize o tela canvas.
  Inicialize o memory canvas.
  Atribua o memory canvas ao quadro atual.

Etapas necessárias para que se inicialize o cgi:
  Call "kernel32.dll" "AllocConsole".
  Call "kernel32.dll" "GetStdHandle" com 
  -10 [STD_INPUT_HANDLE] 
    devolvendo o número identificador do fluxo de entrada padrão.
  Call "kernel32.dll" "GetStdHandle" com 
  -11 [STD_OUTPUT_HANDLE] 
    devolvendo o número identificador do fluxo de saída padrão.

  \Etapas necessárias para que se inicialize o Component Object Model:
  \Mande os códigos 0 e 2 para a função "CoInitializeEx" da biblioteca "ole32.dll" [COINIT_APARTMENTTHREADED].

Etapas necessárias para que se inicialize o Component Object Model:
  Call "ole32.dll" "CoInitializeEx" com 
  0 
    e 2 [COINIT_APARTMENTTHREADED].

Etapas necessárias para que se inicialize um context:
  Aloque memória para o context.
  Atribua o center desta tela à localização deste context.
  Atribua 0 à orientação deste context.
  Atribua a cor verde à cor deste context.
  Atribua o tamanho de letra pequena à tamanho da letra deste context.
    \Atribua 1/60 second ao delay. ***
  Seed o random número generator.

Etapas necessárias para que se inicialize os cursors:
  Inicialize os cursors (seta do mouse).
  Inicialize os cursors (hand cursor).
  Inicialize os cursors (i-beam cursor).
    \Atribua a seta do mouse ao cursor flecha.
    \Atribua o hand cursor ao cursor mano.
    \Atribua o i-beam cursor ao cursor rayo-i.
  Hide o cursor.

Etapas necessárias para que se inicialize os cursors (seta do mouse):
  Posponha $00000000000000004000000060000000 para uma máscara de disjunção exclusiva.
  Posponha $70000000780000007C0000007E000000 para a máscara de disjunção exclusiva.
  Posponha $7F0000007F8000007C0000006C000000 para a máscara de disjunção exclusiva.
  Posponha $46000000060000000300000003000000 para a máscara de disjunção exclusiva.
  Posponha $01800000018000000000000000000000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 48.
  Posponha $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF para uma máscara de conjunção lógica.
  Posponha $07FFFFFF03FFFFFF01FFFFFF00FFFFFF para a máscara de conjunção lógica.
  Posponha $007FFFFF003FFFFF001FFFFF01FFFFFF para a máscara de conjunção lógica.
  Posponha $10FFFFFF30FFFFFF787FFFFFF87FFFFF para a máscara de conjunção lógica.
  Posponha $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 48.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 0 
    e 0 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo a seta do mouse.

Etapas necessárias para que se inicialize o cursors (hand cursor):
  Posponha $000000000180000019B0000019B00000 para uma máscara de disjunção exclusiva.
  Posponha $0DB200000DB6000007F6000067FE0000 para a máscara de disjunção exclusiva.
  Posponha $7FFC00003FFC00001FFC00001FF80000 para a máscara de disjunção exclusiva.
  Posponha $0FF8000007F0000003F0000003F00000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 64.
  Posponha $FE7FFFFFE40FFFFFC007FFFFC005FFFF para uma máscara de conjunção lógica.
  Posponha $E000FFFFE000FFFF9000FFFF0000FFFF para a máscara de conjunção lógica.
  Posponha $0001FFFF8001FFFFC001FFFFC003FFFF para a máscara de conjunção lógica.
  Posponha $E003FFFFF007FFFFF807FFFFF807FFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 64.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 2 
    e 1 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo o hand cursor.

Etapas necessárias para que se inicialize o cursors (i-beam cursor):
  Posponha $EE000000100000001000000010000000 para um máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $100000001000000010000000EE000000 para o máscara de disjunção exclusiva.
  Posponha $00 para o máscara de disjunção exclusiva usando 64.
  Posponha $FF para um máscara de conjunção lógica usando 128.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 3 
    e 7 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo o i-beam cursor.

Etapas necessárias para que se inicialize as fonts:
  Call "gdi32.dll" "GetStockObject" com 
  11 [ANSI_FIXED_FONT] 
    devolvendo o null número da fonte.
    \Call "gdi32.dll" "AddFontMemResourceEx" com o first desta osmosian font source e a quantidade de caracteres desta osmosian font source e 0 e o endereçamento desse número devolvendo o osmosian font resource.
    \Call "gdi32.dll" "AddFontMemResourceEx" com o first desta fonte Segoe UI e a quantidade de caracteres desta fonte Segoe UI e 0 e o endereçamento desse número devolvendo o Segoe UI resource.
  Call "gdi32.dll" "AddFontMemResourceEx" com 
    O first desta fonte Tahoma 
    e A quantidade de caracteres desta fonte Tahoma 
    e 0 
    e O endereçamento desse número 
    devolvendo o recurso de fonte Tahoma.
    \Atribua "Segoe UI" e 1/6 polegada à fonte padrão.
    \Atribua "osmosian" e 24 pixels à fonte padrão.
  Atribua "Tahoma" e 20 pixels à fonte padrão.
    \ stroked fonts below
  Atribua 12 pixels ao tamanho de letra pequena.
  Atribua 24 pixels ao tamanho de letra médio.
  Atribua 48 pixels ao tamanho de letra grande.

Etapas necessárias para que se inicialize gdi+:
  Atribua 1 ao GdiplusVersion desse GdiplusStartupInput.
  Call "gdiplus.dll" "GdiplusStartup" com 
    O endereçamento deste gptoken 
    e O endereçamento deste GdiplusStartupInput 
    e 0.
    \Windows GDI+ é uma API baseada em classe para programadores C/C++. 
    \Ela permite que os aplicativos usem elementos gráficos e texto formatado na exibição de vídeo e na impressora. 
    \Aplicativos baseados na API do Microsoft Win32 não acessam diretamente o hardware gráfico. 
    \Em vez disso, GDI+ interage com drivers de dispositivo em nome de aplicativos. 
    \GDI+ também é suportado pelo Microsoft Win64.

Etapas necessárias para que se inicialize o memory canvas:
  Call "gdi32.dll" "CreateCompatibleDC" com 
    O tela canvas 
    devolvendo o memory canvas.
  Call "gdi32.dll" "GetCurrentObject" com 
    O memory canvas 
    e 7 [OBJ_BITMAP] 
    devolvendo o saved memory hbitmap.
  Call "gdi32.dll" "CreateCompatibleBitmap" com 
    O tela canvas 
    e A pixel largura desta tela 
    e A pixel altura desta tela devolvendo um hbitmap.
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O hbitmap.
  Normalize o memory canvas.

Etapas necessárias para que se inicialize o module:
    \ temp endereço completo
  Atribua 512 a uma quantidade de caracteres.
  Reassign o first deste temp endereço completo usando a quantidade de caracteres.
  Call "kernel32.dll" "GetTempPathA" com 
    A quantidade de caracteres 
    e O first deste temp endereço completo 
    devolvendo a quantidade de caracteres.
  Atribua o first deste temp endereço completo mais a quantidade de caracteres menos 1 ao last deste temp endereço completo.
  Modifique através do caractere NUL o temp endereço completo.
    \ module handle
  Call "kernel32.dll" "GetModuleHandleA" com 
  0 
    devolvendo o número identificador deste module.
    \ module nome
  Atribua 512 à quantidade de caracteres.
  Reassign o first deste endereço completo deste module usando a quantidade de caracteres.
  Call "kernel32.dll" "GetModuleFileNameA" com 
    O número identificador deste module 
    e O first deste endereço completo deste module 
    e A quantidade de caracteres 
    devolvendo a quantidade de caracteres.
  Atribua o first deste endereço completo deste module mais a quantidade de caracteres menos 1 ao last deste endereço completo deste module.
  Se o endereço completo deste module começa com "\\?\", remove leading pedaços desde o endereço completo deste module usando 4.
  Lowercase o endereço completo deste module.
  Modifique através do caractere NUL o endereço completo deste module. \ segunda endereço completo pieces deste module
  Extraia o nome deste module desde o endereço completo deste module.
  Modifique através do caractere NUL o nome deste module.
  Extraia o endereço da pasta deste module desde o endereço completo deste module.
  Modifique através do caractere NUL o endereço da pasta deste module.
  Extraia o root endereço da pasta deste module desde o endereço da pasta deste module.
  Modifique através do caractere NUL o root endereço da pasta deste module.

Etapas necessárias para que se inicialize o mouse:
  Atribua 1 ao botão esquerdo deste mouse.
  Atribua 2 ao botão direito deste mouse.
  Call "user32.dll" "GetSystemMetrics" com 
  23 [SM_SWAPBUTTON] 
    devolvendo um número.
  Se o número for 0, cancele.
  Permute o botão esquerdo deste mouse com o botão direito deste mouse.

Etapas necessárias para que se inicialize o printer canvas:
  Atribua a magnitude [quantidade de bytes] desse printdlgex ao lstructsize deste printdlgex.
  Atribua a main window ao hwndowner deste printdlgex.
  Atribua 1288 [PD_RETURNDC + PD_RETURNDEFAULT + PD_NOPAGENUMS] ao flags deste printdlgex.
  Atribua -1 [START_PAGE_GENERAL] ao nstartpage deste printdlgex.
  Call "comdlg32.dll" "PrintDlgExA" com 
    O endereçamento deste printdlgex.
  Call "kernel32.dll" "GlobalFree" com 
    O hdevnames deste printdlgex.
  Atribua o hdevmode deste printdlgex ao número identificador do modo de dispositivo da impressora.
  Atribua o hdc deste printdlgex ao printer canvas.

Etapas necessárias para que se inicialize o tela:
  Call "user32.dll" "GetSystemMetrics" com 
  0 [sm_cxscreen] 
    devolvendo a pixel largura desta tela.
  Call "user32.dll" "GetSystemMetrics" com 
  1 [sm_cyscreen] 
    devolvendo a pixel altura desta tela.
  Atribua 96 ao ppi.
  Atribua o tpi dividido pelo ppi ao tpp.
  Atribua a pixel largura desta tela times o tpp a um largura.
  Atribua a pixel altura desta tela times o tpp a uma altura.
  Atribua 0 e 0 e o largura e o altura à caixa desta tela.
  Subtraia o tpp desde o canto inferior direito desta tela.

Etapas necessárias para que se inicialize o tela canvas:
  Call "user32.dll" "GetDC" com 
    A main window 
    devolvendo o tela canvas.
  Normalize o tela canvas.

Etapas necessárias para que se inicialize um talker:
  Converta "{96749377-3391-11D2-9EE3-00C04F797396}" [CLSID_SpVoice] para um clsid.
  Converta "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [IID_ISpVoice] para um iid.
  Call "ole32.dll" "CoCreateInstance" com 
    O endereçamento deste clsid 
    e 0 
    e 7 [CLSCTX_ALL] 
    e O endereçamento deste iid 
    e O endereçamento deste talker.

Etapas necessárias para que se inicialize a window: \\ para inicializar a janela
  Atribua a magnitude [tamanho em bytes] dessa window class [estrutura] ao cbsize deste window class.
  Atribua 40 [CS_OWNDC + CS_DBLCLKS] ao style deste window class.
    \o valor cs_owndc Aloca um contexto de dispositivo exclusivo para cada janela da classe.
    \ o valor cs_dblclks permite que o windows informe ao programa que aquele é um clique duplo (ao invés de dois cliques)
  Point o lpfnWndProc deste window class para rotina handle algum tipo de message com um window um message número um W-Param e um L-Param.
    \ Isso define o procedimento da classe dessa janela como sendo WndProc
    \LPARAM é um typedef para um LONG_PTR que é um número inteiro (32 bits com sinal) em win32 e __int64 (64 bits com sinal) em x86_64.
    \WPARAM é um typedef para um UINT_PTR que é um número sem sinal (32 bits sem sinal) em win32 e __int64 sem sinal (64 bits sem sinal) em x86_64.
  Atribua o número identificador deste module ao hInstance desta window class.
  Atribua o first deste nome deste module ao lpszClassName desta window class.
  Call "user32.dll" "RegisterClassExA" \ Antes de criar uma janela, você deve registrar uma classe pra essa janela chamando a função RegisterClass.
  com o endereçamento deste window class. \Esta função requer um único parâmetro, que é um ponteiro para uma estrutura do tipo WNDCLASS.
  Call "user32.dll" "CreateWindowExA" com 
  0    \\  o estilo opcional da janela, como transparências por exemplo. veja mais detalhes em  https://docs.microsoft.com/en-us/windows/desktop/winmsg/extended-window-styles
    e O first deste nome deste module    \\ O nome da classe da janela
    e O first deste nome deste module    \\ O texto da janela
    e 2147483648 [13565952  WS_OVERLAPPEDWINDOW]  [-2147483648 = WS_POPUP]     \\  aqui define o tipo da janela. Use valores em decimal;  
    \\para isso Converta os valores hexadecimais da lista  https://www.autoitscript.com/autoit3/docs/appendix/GUIStyles.htm para decimal;
    \\ O valor na documentação do windows está em hexadecimal (ou em string), mas esse compilador usa números inteiros (longint). 
    \\ Para colocar a barra padrão, use o valor 13565952
    e 0    \\ posição horizontal inicial da janela
    e 0    \\ // posição vertical inicial da janela
    e A pixel largura desta tela    \\ A largura da janela em pixels;
    e A pixel altura desta tela    \\ A altura da janela em pixels
    e 0    \\ opcional. Informa o número identificador do controle pai da janela (se existir) ou da janela em si
    e 0 \\ a mesma coisa, só que identifica o número do menu da janela.
    e O número identificador deste module    \\ descrição auto explicável
    e 0. \\ aqui é um ponteiro que passa a informação pra janela. Usamos um valor nulo pq não precisamos dele.
  Call "user32.dll" "ShowWindow" com 
    A main window 
    e 1 [SW_SHOWNORMAL].

Etapas necessárias para que se inicialize winsock:
  Call "ws2_32.dll" "WSAStartup" com 
  2 
    e O endereçamento desse wsadata.

Um input é um event.

Etapas necessárias para que se insira um pedaço Para um text:
  Se o text for inexistente, cancele.
  Atribua o pedaço a uma string.
  Insira a string ao text.

Etapas necessárias para que se insira uma localização Para um polígono after um vértice:
  Se o polígono for inexistente, cancele.
  Crie uma segunda vértice usando a localização.
  Insira a segunda vértice aos vértices deste polígono after o vértice.

Etapas necessárias para que se insira uma string Para uma segunda string antes de um byte#:
  Se a quantidade de caracteres desta string for 0, cancele.
  Isole o byte#.
  Limite o byte# para 1 e a quantidade de caracteres desta segunda string mais 1.
  Lance um subtexto sobre a segunda string. \ left side
  Atribua o first endereço de memória do pedaço deste subtexto mais o byte# menos 2 ao last endereço de memória do pedaço deste subtexto.
  Lance uma segundo subtexto sobre a segunda string. \ right side
  Atribua o first endereço de memória do pedaço deste segundo subtexto mais o byte# menos 1 ao first endereço de memória do pedaço deste segundo subtexto.
  Atribua a quantidade de caracteres desta segunda string mais a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Reassign um endereço de memória usando a quantidade de caracteres agrupados.
  Atribua o endereço de memória ao first endereço de memória do pedaço desse terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço deste subtexto para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres deste subtexto.
  Adicione a quantidade de caracteres deste subtexto para o first endereço de memória do pedaço deste terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o first endereço de memória do pedaço deste terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço deste segundo subtexto para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres deste segundo subtexto.
  Unassign o first endereço de memória do pedaço desta segunda string. \ dont use atribua uma string a uma string para prevent extra allocating e copying
  Atribua o endereço de memória ao first endereço de memória do pedaço desta segunda string.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres agrupados menos 1 ao last endereço de memória do pedaço desta segunda string.

Etapas necessárias para que se insira uma string Para um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row menos o caret column# deste text a um número.
  Atribua a string deste row a uma segunda string.
  Insira a string ao segunda string antes de o caret column# deste text.
  Converta a segunda string para uns rows.
  Atribua o last destas rows a uma segunda row.
  Insira a rows A as rows deste text antes de a row.
  Remove a row desde as rows deste text.
  Destrua a row.
  Renumber as rows deste text.
  Atribua o número da linha desta segunda row ao número de linhas do cursor deste text.
  Atribua a quantidade de caracteres desta string desta segunda row menos o número ao caret column# deste text.
  Desvencilhe-se de o text.

Etapas necessárias para que se insira uma coisa para uns coisas after uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se a segunda coisa for inexistente, anteponha a coisa para as coisas; exit.
  Insira a coisa a as coisas antes de o next desta segunda coisa.

Etapas necessárias para que se insira uma coisa para uns coisas antes de uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se as coisas estiverem vazio, posponha a coisa para as coisas; exit.
  Se a segunda coisa for inexistente, posponha a coisa para as coisas; exit.
  Se a segunda coisa for o first destas coisas, anteponha a coisa para as coisas; exit.
  Atribua a coisa a uma new coisa.
  Atribua a segunda coisa a uma previous coisa.
  Atribua a new coisa ao next deste previous desta previous coisa.
  Atribua a previous coisa ao next desta new coisa.
  Atribua o previous desta previous coisa ao previous desta new coisa.
  Atribua o new coisa ao previous desta previous coisa.

Etapas necessárias para que se insira uns coisas para uns segunda coisas after um coisa:
  Se a coisa for inexistente, anteponha  as coisas para a segunda coisas; exit.
  Insira  as coisas ao segunda coisas antes de o next desta coisa.

Etapas necessárias para que se insira uns coisas para uns segunda coisas antes de um coisa:
  Isole o coisa.
  Percorra. [o código abaixo]
    Atribua o first destas coisas a uma segunda coisa.
    Se a segunda coisa for inexistente, cancele.
    Remove a segunda coisa desde as coisas.
    Insira a segunda coisa ao segunda coisas antes de o coisa.
  Repita. [o código acima]

Etapas necessárias para que se insira um vértice para um polígono after uma segunda vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono after a segunda vértice.

Etapas necessárias para que se insira um vértice para um polígono at uma localização:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma segunda vértice desde os vértices deste polígono.
    Se a segunda vértice for inexistente, cancele.
    Se o next desta segunda vértice for inexistente, cancele.
    Atribua a localização desta segunda vértice e a localização deste next desta segunda vértice a uma line.
    Se a localização não estiver sobre a line, repita.
  Insira o vértice aos vértices deste polígono after a segunda vértice.

Etapas necessárias para que se insira um vértice para um polígono antes de uma segunda vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono antes de a segunda vértice.

Etapas necessárias para que se intersect uma caixa com uma segunda caixa usando um terceiro caixa:
    \ caixas does not touch
  Limpe o terceiro caixa.
  Se a coordenada esquerda desta caixa for maior do que a coordenada direita desta segunda caixa, cancele.
  Se a coordenada superior desta caixa for maior do que a coordenada inferior desta segunda caixa, cancele.
  Se a coordenada direita desta caixa for menor do que a coordenada esquerda desta segunda caixa, cancele.
  Se a coordenada inferior desta caixa for menor do que a coordenada superior desta segunda caixa, cancele.
    \ caixas touch
  Atribua a caixa ao terceiro caixa.
  Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda desta segunda caixa, atribua a coordenada esquerda desta segunda caixa à coordenada esquerda desta terceiro caixa.
  Se a coordenada superior desta caixa for menor do que a coordenada superior desta segunda caixa, atribua a coordenada superior desta segunda caixa à coordenada superior desta terceiro caixa.
  Se a coordenada direita desta caixa for maior do que a coordenada direita desta segunda caixa, atribua a coordenada direita desta segunda caixa à coordenada direita desta terceiro caixa.
  Se a coordenada inferior desta caixa for maior do que a coordenada inferior desta segunda caixa, atribua a coordenada inferior desta segunda caixa à coordenada inferior desta terceiro caixa.

    \Etapas necessárias para que se invert um detector:
    \ see "reverse um detector"
    \Se o detector for yes, atribua no ao detector; exit.
    \Atribua yes ao detector.

Um Endereço IP é um conjunto com
  Um número, 
  Uma string. 

Um item é um conjunto com
  Uma categoria [directory, file], \ English
  Um endereço completo, 
  Um endereço da pasta, 
  Um designador, 
  Uma extensão,
  Um size, 
  Um creation date/time string,
  Um WIN32FINDDATA e 
  Um número identificador.

Etapas necessárias para que se jump o caret left em um text:
  Se o text for inexistente, cancele.
  Mova o caret left para algum tipo de non-noise pedaço no text.
  Se o caret column# deste text for 1, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
  Se o conteúdo deste endereço de memória do pedaço for alfanumérico, mova o caret left para algum tipo de non-alfanumérico pedaço no text.
  Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, mova o caret left para algum tipo de non-symbolic pedaço no text.
  Mova o caret left para algum tipo de non-noise pedaço no text.

Etapas necessárias para que se jump o caret right em um text:
  Se o text for inexistente, cancele.
  Mova o caret right para algum tipo de non-noise pedaço no text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text é a quantidade de caracteres desta string desta row, cancele.
  Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
  Se o conteúdo deste endereço de memória do pedaço é alfanumérico, mova o caret right para algum tipo de non-alfanumérico pedaço no text.
  Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, mova o caret right para algum tipo de non-symbolic pedaço no text.
  Mova o caret right para algum tipo de non-noise pedaço no text.

Um key é um número.

Um kilobyte é 1024 units.

Um categoria é uma string.

Um l-param é um número.

Um landscape sheet é um sheet.

O tamanho de letra grande é um tamanho da letra.

O maior número é 2147483647.

Um mínimo múltiplo comum é um número.

Um clique é um input.

Um left é uns twips.

Uma quantidade de caracteres é uns twips.

Um tamanho da letra é uns twips. \ indicates actual altura of um typical uppercase letra

Uma letra é um pedaço.

O dicionário léxico é uma coisa com um catálogo.

Etapas necessárias para que se clareie uma cor por um quantia:
  Adicione o quantia para a luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se clareie uma cor por uns percent;
Etapas necessárias para que se clareie uma cor about uns percent;
Etapas necessárias para que se clareie uma cor por about uns percent;
Etapas necessárias para que se clareie uma cor uns percent:
  Atribua a luminosidade desta cor mais o percent à luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se clareie o current cor about uns percent:
  Clareie a cor deste context pelo percent.

Etapas necessárias para que se clareie um matiz por uns degrees:
  Adicione o degrees para o matiz.

Etapas necessárias para que se clareie um matiz por uns points:
  Converta o matiz para uns segunda points.
  Adicione o points para a segunda points.
  Converta a segunda points para o matiz.

Um luminosidade é um número [que vai desde o número 0 até o número 1000].

Etapas necessárias para que se limite uma caixa para uma segunda caixa:
  Limite a coordenada esquerda desta caixa para a coordenada esquerda desta segunda caixa e a coordenada direita desta segunda caixa.
  Limite a coordenada superior desta caixa para a coordenada superior desta segunda caixa e a coordenada inferior desta segunda caixa.
  Limite a coordenada direita desta caixa para a coordenada esquerda desta segunda caixa e a coordenada direita desta segunda caixa.
  Limite a coordenada inferior desta caixa para a coordenada superior desta segunda caixa e a coordenada inferior desta segunda caixa.

Etapas necessárias para que se limite o caret em um text:
  Se o text for inexistente, cancele.
  Limite o número de linhas do cursor deste text para 1 e a contagem de linhas deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Limite o caret column# deste text para 1 e a quantidade de caracteres desta string desta row.

Etapas necessárias para que se limite um número para um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, atribua o segundo número ao número; exit.
  Se o número for maior do que o terceiro número, atribua o terceiro número ao número.

Etapas necessárias para que se limite o origin of um text:
  Se o text for inexistente, cancele.
  Limite a coordenada X deste text para o menor número e a margin deste text.
  Atribua a contagem de linhas deste text menos 1 times a altura da linha deste text a um número.
  Limite a coordenada Y deste text para - o número e 0.

Etapas necessárias para que se limite uma localização para uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada esquerda desta caixa, atribua a coordenada esquerda desta caixa à coordenada x desta localização.
  Se a coordenada Y desta localização for menor do que a coordenada superior desta caixa, atribua a coordenada superior desta caixa à coordenada y desta localização.
  Se a coordenada X desta localização for maior do que a coordenada direita desta caixa, atribua a coordenada direita desta caixa à coordenada x desta localização.
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, atribua a coordenada inferior desta caixa à coordenada y desta localização.

Etapas necessárias para que se limite uns texts para uma contagem:
  Atribua a contagem destes texts a uma segunda contagem.
  Percorra. [o código abaixo]
    Se a segunda contagem for menor do que ou igual à contagem, cancele.
    Atribua o first destes texts a um text.
    Remove o text desde o texts.
    Destrua o text.
    Subtraia 1 desde a segunda contagem.
  Repita. [o código acima]

Uma line é um conjunto com 
  Uma start localização e 
  Uma end localização.

Etapas necessárias para que se liste umas choices em uma caixa;
Etapas necessárias para que se pinte umas choices em uma caixa:
    \Pinte really fast. ***
  Obtenha um [first/next] choice desde as choices.
  Se a choice estiver missing [because we have drawn them all], cancele.
  Atribua a coordenada esquerda desta caixa mais 24 pixels à coordenada esquerda desta choice.
  Atribua a coordenada direita desta caixa menos 24 pixels à coordenada direita desta choice.
  Se a choice for o first desta choice, atribua a coordenada superior desta caixa mais 24 pixels à coordenada superior desta choice.
  Se a choice não for o first desta choice, atribua a coordenada inferior deste previous desta choice à coordenada superior desta choice.
  Atribua a coordenada superior desta choice mais 24 pixels à coordenada inferior desta choice.
    \Pinte a caixa desta choice com a cor púrpura. \ temp ***
  Pinte o nome desta choice na caixa desta choice com a cor deste context.
  Repita. [o código acima]

Etapas necessárias para que se liste uns choices em uma caixa com uma cor;
Etapas necessárias para que se pinte uns choices em uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte o choices na caixa.

Etapas necessárias para que se carregue o dicionário léxico:
  Se o dicionário léxico não for inexistente, cancele.
  Extraia um endereço da pasta desde o endereço completo deste module.
  Percorra. [o código abaixo]
    Se o endereço da pasta estiver em branco, cancele.
    Atribua o endereço da pasta seguido de "dicionário léxico\" a um endereço completo.
    Se o endereço completo estiver no sistema de arquivos, Carregue o dicionário léxico usando o endereço completo; exit.
    Extraia o endereço da pasta desde o endereço da pasta.
  Repita. [o código acima]

Etapas necessárias para que se carregue o dicionário léxico usando um trecho:
  Se o dicionário léxico for inexistente, crie o dicionário léxico.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Mova o percorredor (catálogo dicionário léxico rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Catalogue o segmento inicial deste percorredor no catálogo deste dicionário léxico.
  Repita. [o código acima]

Etapas necessárias para que se carregue o dicionário léxico usando um endereço completo:
  Obtenha um item desde o endereço completo.
  Se o item não for found, cancele.
  Se a categoria deste item não for "arquivo", repita.
  Read o endereço completo deste item a um trecho.
  Se o erro do fluxo de entrada/saída não estiver em branco, repita.
  Carregue o dicionário léxico usando o trecho.
  Repita. [o código acima]

Etapas necessárias para que se localize uma caixa usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a caixa usando o par de números.

Etapas necessárias para que se localize uma localização usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a localização usando o par de números.

Etapas necessárias para que se lock um gpbitmap usando um bitmapdata (24-bit espaço de cor RGB):
  Atribua o gprect deste gpbitmap a um gprect.
  Call "gdiplus.dll" "GdipBitmapLockBits" com
   o gpbitmap 
   e o endereçamento deste gprect 
   e 3 [ImageLockModeRead ou ImageLockModeWrite] 
   e 137224 [PixelFormat24bppRGB] 
   e o endereçamento deste bitmapdata.

\Um logbrush é um conjunto com \ documentar
\Um número denominado lbstyle,
\Um código da cor denominado lbcolor,
\Um número denominado lbhatch.

Etapas necessárias para que se lowercase algum tipo de pedaços selecionados em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
    Lowercase o subtexto.
  Repita. [o código acima]

Etapas necessárias para que se lowercase um pedaço:
    \Add 32 to each letter in the string between "A" and "Z".
  Translate o pedaço usando o tabela de caracteres minúsculos ascii .

Etapas necessárias para que se lowercase o character depois de um finger e atribua it para uma string:
  Se o finger for inexistente, cancele.
  Atribua o conteúdo deste finger à string.
  Lowercase a string.

Etapas necessárias para que se lowercase uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Lowercase o conteúdo deste first endereço de memória do pedaço deste subtexto.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se lowercase um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, pare.
    Lowercase a string deste row.
  Repita. [o código acima]
  Wrap o text.

A main window é um window.

Etapas necessárias para que se make uma fração com um número e um segundo número:
  Atribua o número ao numerador desta fração.
  Atribua o segundo número ao denominador desta fração.

Etapas necessárias para que se make um par de números racionais usando uma caixa e uma segunda caixa;
Etapas necessárias para que se make uma par de números fracionários usando uma caixa e uma segunda caixa:
  Atribua o x-extent desta caixa à numerador desta fração deste par de números fracionários.
  Atribua o x-extent desta segunda caixa ao denominador desta fração deste par de números fracionários.
  Atribua o y-extent desta caixa ao numerador desta segunda fração deste par de números fracionários.
  Atribua o y-extent desta segunda caixa ao denominador desta segunda fração deste par de números fracionários.

Um margin é um número.

Etapas necessárias para que se cubra internamente uma caixa:
  Crie um hrgn usando a caixa.
  Cubra internamente o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se cubra internamente um elipse:
  Crie um hrgn usando a elipse.
  Cubra internamente o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se cubra internamente um hrgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hrgn e 4 [RGN_DIFF].

Etapas necessárias para que se cubra internamente um polígono:
  Crie um hrgn usando o polígono.
  Cubra internamente o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se cubra internamente uma caixa arredondada:
  Crie um hrgn usando a caixa arredondada.
  Cubra internamente o hrgn.
  Destrua o hrgn.

Um mask é um texto hexadecimal.

Etapas necessárias para que se cubra somente dentro de uma caixa:
  Mostre tudo.
  Cubra internamente a caixa.

Etapas necessárias para que se cubra somente dentro de um elipse:
  Mostre tudo.
  Cubra internamente a elipse.

Etapas necessárias para que se cubra somente dentro de um polígono:
  Mostre tudo.
  Cubra internamente o polígono.

Etapas necessárias para que se cubra somente dentro de uma caixa arredondada:
  Mostre tudo.
  Cubra internamente a caixa arredondada.

Etapas necessárias para que se cubra somente fora de uma caixa:
  Mostre tudo.
  Cubra externamente a caixa.

Etapas necessárias para que se cubra somente fora de um elipse:
  Mostre tudo.
  Cubra externamente a elipse.

Etapas necessárias para que se cubra somente fora de um polígono:
  Mostre tudo.
  Cubra externamente o polígono.

Etapas necessárias para que se cubra somente fora de uma caixa arredondada:
  Mostre tudo.
  Cubra externamente a caixa arredondada.

Etapas necessárias para que se cubra externamente uma caixa:
  Crie um hrgn usando a caixa.
  Cubra externamente o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se cubra externamente um elipse:
  Crie um hrgn usando a elipse.
  Cubra externamente o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se cubra externamente um hrgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hrgn e 1 [RGN_AND].

Etapas necessárias para que se cubra externamente um polígono:
  Crie um hrgn usando o polígono.
  Cubra externamente o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se cubra externamente uma caixa arredondada:
  Crie um hrgn usando a caixa arredondada.
  Cubra externamente o hrgn.
  Destrua o hrgn.

O max text undos é uma contagem igual a 32.

O tamanho de letra médio é um tamanho da letra.

Um megabyte é 1024 kilobytes.

O memory canvas é um canvas.

Um message é uma string.

An millisecond é um número.

Etapas necessárias para que se minimize um window:
  Call "user32.dll" "ShowWindow" com 
    A window 
    e 6 [SW_MINIMIZE].

Um minute é 60 seconds.

Etapas necessárias para que se mirror o gpbitmap em um imagem:
  Se o imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Mirror o gpbitmap desta imagem.

Etapas necessárias para que se mirror um gpimage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O gpimage 
    e 4 [RotateNoneFlipX].

Etapas necessárias para que se mirror um imagem:
  Se o imagem for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa desta imagem menos a coordenada X deste center desta caixa intacta desta imagem ao número X desse par de números.
  Multiplique o número X deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Mirror o gpbitmap no imagem.

Etapas necessárias para que se mirror um polígono:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia a coordenada esquerda desta caixa desde a coordenada X deste vértice.
    Atribua a coordenada direita desta caixa menos a coordenada X deste vértice à coordenada x deste vértice.
  Repita. [o código acima]

Um mixed é um conjunto com 
  Um whole número e 
  Um ratio e 
  Uma fração at o ratio.

O module é um conjunto com
  Um número identificador,
  Um endereço completo,
  Um endereço da pasta,
  Um root endereço da pasta, \ uma pasta acima do qual o exe está sendo executado. eexemplo: C:\1\2\a.exe o endereço seria c:\1\
  Um nome do arquivo s/ extensão denominado nome.

O mouse é um conjunto com
  Uma tecla denominado botão esquerdo, 
  Uma tecla denominado botão direito.

Etapas necessárias para que se mova o anchor left para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o anchor número da linha deste text e o text.
  Percorra. [o código abaixo]
    Se o anchor column# deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o anchor column# deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Subtraia 1 desde o anchor column# deste text.
  Repita. [o código acima]

Etapas necessárias para que se mova back uns twips:
  Vire around.
  Mova os twips.
  Vire around.

Etapas necessárias para que se mova uma caixa para o base of uma segunda caixa:
  Mova a caixa para baixo a coordenada inferior desta segunda caixa menos a coordenada inferior desta caixa.

Etapas necessárias para que se mova uma caixa close para o left side of uma segunda caixa;
Etapas necessárias para que se mova uma caixa close para o left of uma segunda caixa:
  Mova a caixa para o left of a segunda caixa.
  Escolha aleatoriamente uma quantidade de caracteres between 0 e a largura desta caixa times 3/4.
  Mova a caixa right a quantidade de caracteres.

Etapas necessárias para que se mova uma caixa para baixo uns twips:
  Mova a caixa usando 0 e os twips.

Etapas necessárias para que se mova uma caixa usando um par de números:
  Mova a caixa usando o número X deste par de números e o número Y deste par de números.

Etapas necessárias para que se mova uma caixa usando um par de números racionais e uma localização;
Etapas necessárias para que se mova uma caixa usando uma par de números fracionários e uma localização:
  Obtenha um difference between o canto superior esquerdo desta caixa e a localização.
  Atribua a difference a uma segunda difference.
  Redimensione proporcionalmente a segunda difference usando o par de números fracionários.
  Subtraia a difference desde a segunda difference.
  Mova a caixa usando a segunda difference.

Some  x-twips são uns twips.
Some  y-twips são uns twips.

Etapas necessárias para que se mova uma caixa usando uns x-twips e uns y-twips:
  Adicione o x-twips para a coordenada esquerda desta caixa.
  Adicione o y-twips para a coordenada superior desta caixa.
  Adicione o x-twips para a coordenada direita desta caixa.
  Adicione o y-twips para a coordenada inferior desta caixa.

Etapas necessárias para que se mova uma caixa left para uma coordenada:
  Mova a caixa left a coordenada esquerda desta caixa menos a coordenada.

Etapas necessárias para que se mova uma caixa para o left side of uma segunda caixa;
Etapas necessárias para que se mova uma caixa para o left of uma segunda caixa:
  Mova a caixa left a coordenada esquerda desta caixa menos a coordenada esquerda desta segunda caixa.

Etapas necessárias para que se mova uma caixa left uns twips:
  Mova a caixa usando - os twips e 0.

Etapas necessárias para que se mova uma caixa para o right side of uma segunda caixa;
Etapas necessárias para que se mova uma caixa para o right of uma segunda caixa:
  Mova a caixa right a coordenada direita desta segunda caixa menos a coordenada direita desta caixa.

Etapas necessárias para que se mova uma caixa right uns twips:
  Mova a caixa usando os twips e 0.

Etapas necessárias para que se mova uma caixa para uma localização:
  Obtenha um difference between a localização e o canto superior esquerdo desta caixa.
  Mova a caixa usando a difference.

Etapas necessárias para que se mova uma caixa para o topo left corner of uma segunda caixa:
  Mova a caixa para a coordenada esquerda desta segunda caixa-top.

Etapas necessárias para que se mova uma caixa para o topo of uma segunda caixa:
  Mova a caixa para cima a coordenada superior desta caixa menos a coordenada superior desta segunda caixa.

Etapas necessárias para que se mova uma caixa para cima uns twips:
  Mova a caixa usando 0 e - os twips.

Etapas necessárias para que se mova o caret para baixo em um text:
  Se o text for inexistente, cancele.
  Adicione 1 para o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas necessárias para que se mova o caret para baixo one página em um text:
  Se o text for inexistente, cancele.
  Adicione as rows/box deste text para o número de linhas do cursor deste text.
  Subtraia 1 desde o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas necessárias para que se mova o caret para o first pedaço of o current row of um text:
  Se o text for inexistente, cancele.
  Atribua 1 ao caret column# deste text.

Etapas necessárias para que se mova o caret para o first pedaço of um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao caret deste text.

Etapas necessárias para que se mova o caret para o last pedaço of o current row of um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row ao caret column# deste text.

Etapas necessárias para que se mova o caret para o last pedaço of um text:
  Se o text for inexistente, cancele.
  Atribua a contagem de linhas deste text ao número de linhas do cursor deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row ao caret column# deste text.

Etapas necessárias para que se mova o caret left para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Subtraia 1 desde o caret column# deste text.
  Repita. [o código acima]

Etapas necessárias para que se mova o caret left para algum tipo de non-noise pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for irrelevante, cancele.
    Subtraia 1 desde o caret column# deste text.
  Repita. [o código acima]

Etapas necessárias para que se mova o caret left para algum tipo de non-symbolic pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for symbolic, cancele.
    Subtraia 1 desde o caret column# deste text.
  Repita. [o código acima]

Etapas necessárias para que se mova o caret left em um text:
  Se o text for inexistente, cancele.
  Subtraia 1 desde o caret column# deste text.
  Limite o caret no text.

Etapas necessárias para que se mova o caret right para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Adicione 1 para o caret column# deste text.
  Repita. [o código acima]

Etapas necessárias para que se mova o caret right para algum tipo de non-noise pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for irrelevante, cancele.
    Adicione 1 para o caret column# deste text.
  Repita. [o código acima]

Etapas necessárias para que se mova o caret right para algum tipo de non-symbolic pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for symbolic, cancele.
    Adicione 1 para o caret column# deste text.
  Repita. [o código acima]

Etapas necessárias para que se mova o caret right em um text:
  Se o text for inexistente, cancele.
  Adicione 1 para o caret column# deste text.
  Limite o caret no text.

Etapas necessárias para que se mova o caret para cima em um text:
  Se o text for inexistente, cancele.
  Subtraia 1 desde o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas necessárias para que se mova o caret para cima one página em um text:
  Se o text for inexistente, cancele.
  Subtraia as rows/box deste text desde o número de linhas do cursor deste text.
  Adicione 1 para o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas necessárias para que se mova um elipse para baixo uns twips:
  Mova a elipse usando 0 e os twips.

Etapas necessárias para que se mova um elipse usando um par de números:
  Mova a elipse usando o x deste par de números e o y deste par de números.

Etapas necessárias para que se mova um elipse usando uns x-twips e uns y-twips:
  Mova a caixa desta elipse usando o x-twips e o y-twips.

Etapas necessárias para que se mova um elipse left uns twips:
  Mova a elipse usando - os twips e 0.

Etapas necessárias para que se mova um elipse right uns twips:
  Mova a elipse usando os twips e 0.

Etapas necessárias para que se mova um elipse para uma localização:
  Obtenha um difference between a localização e o canto superior esquerdo desta elipse.
  Mova a elipse usando a difference.

Etapas necessárias para que se mova um elipse para cima uns twips:
  Mova a elipse usando 0 e - os twips.

Etapas necessárias para que se mova um finger over um número:
  Se o finger for inexistente, cancele.
  Adicione 1 para o finger.

Etapas necessárias para que se mova para o left uns twips e para baixo uns segunda twips;
Etapas necessárias para que se mova left uns twips e para baixo uns segunda twips;
Etapas necessárias para que se mova uns twips para o left e uns segunda twips para baixo;
Etapas necessárias para que se mova uns twips left e uns segunda twips para baixo:
  Mova a localização deste context left os twips.
  Mova a localização deste context para baixo a segunda twips.

Etapas necessárias para que se mova para o left uns twips e para cima uns segunda twips;
Etapas necessárias para que se mova left uns twips e para cima uns segunda twips;
Etapas necessárias para que se mova uns twips para o left e uns segunda twips para cima;
Etapas necessárias para que se mova uns twips left e uns segunda twips para cima:
  Mova a localização deste context left os twips.
  Mova a localização deste context para cima a segunda twips.

Etapas necessárias para que se mova um line para baixo uns twips:
  Mova o line usando 0 e os twips.

Etapas necessárias para que se mova um line usando um par de números:
  Mova o line usando o x deste par de números e o y deste par de números.

Etapas necessárias para que se mova um line usando uns x-twips e uns y-twips:
  Adicione o x-twips para a coordenada X desta start desta line.
  Adicione o y-twips para a coordenada Y desta start desta line.
  Adicione o x-twips para a coordenada X deste end desta line.
  Adicione o y-twips para a coordenada Y deste end desta line.

Etapas necessárias para que se mova um line left uns twips:
  Mova o line usando - os twips e 0.

Etapas necessárias para que se mova um line para uma localização:
  Obtenha um difference between a localização e o start desta line.
  Mova o line usando a difference.

Etapas necessárias para que se mova um line uns twips para o right;
Etapas necessárias para que se mova um line right uns twips:
  Mova o line usando os twips e 0.

Etapas necessárias para que se mova um line para cima uns twips:
  Mova o line usando 0 e - os twips.

Etapas necessárias para que se mova para o middle;
Etapas necessárias para que se start no middle;
Etapas necessárias para que se mova para o center;
Etapas necessárias para que se start no center:
  Atribua o center desta caixa deste context à localização deste context.

Etapas necessárias para que se mova para o middle of uma caixa;
Etapas necessárias para que se start no middle of uma caixa;
Etapas necessárias para que se mova para o center of uma caixa;
Etapas necessárias para que se start no center of uma caixa:
  Atribua o center desta caixa à localização deste context.

Etapas necessárias para que se mova um imagem para baixo uns twips:
  Mova o imagem usando 0 e os twips.

Etapas necessárias para que se mova um imagem usando um par de números:
  Mova o imagem usando o número X deste par de números e o número Y deste par de números.

Etapas necessárias para que se mova um imagem usando uns x-twips e uns y-twips:
  Se o imagem for inexistente, cancele.
  Mova a caixa desta imagem usando o x-twips e o y-twips.
  Mova a caixa intacta desta imagem usando o x-twips e o y-twips.

Etapas necessárias para que se mova um imagem left uns twips:
  Mova o imagem usando - os twips e 0.

Etapas necessárias para que se mova um imagem right uns twips:
  Mova o imagem usando os twips e 0.

Etapas necessárias para que se mova um imagem para uma localização:
  Se o imagem for inexistente, cancele.
  Obtenha um difference between a localização e o canto superior esquerdo desta imagem.
  Mova o imagem usando a difference.

Etapas necessárias para que se mova um imagem para cima uns twips:
  Mova o imagem usando 0 e - os twips.

Etapas necessárias para que se mova um polígono para baixo uns twips:
  Mova o polígono usando 0 e os twips.

Etapas necessárias para que se mova um polígono usando um par de números:
  Mova o polígono usando o número X deste par de números e o número Y deste par de números.

Etapas necessárias para que se mova um polígono usando uns x-twips e uns y-twips:
  Se o polígono for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Mova o vértice usando o x-twips e o y-twips.
  Repita. [o código acima]

Etapas necessárias para que se mova um polígono left uns twips:
  Mova o polígono usando - os twips e 0.

Etapas necessárias para que se mova um polígono left uns twips e para baixo uns segunda twips:
  Mova o polígono left os twips.
  Mova o polígono para baixo a segunda twips.

Etapas necessárias para que se mova um polígono left uns twips e para cima uns segunda twips:
  Mova o polígono left os twips.
  Mova o polígono para cima a segunda twips.

Etapas necessárias para que se mova um polígono right uns twips:
  Mova o polígono usando os twips e 0.

Etapas necessárias para que se mova um polígono right uns twips e para baixo uns segunda twips:
  Mova o polígono right os twips.
  Mova o polígono para baixo a segunda twips.

Etapas necessárias para que se mova um polígono right uns twips e para cima uns segunda twips:
  Mova o polígono right os twips.
  Mova o polígono para cima a segunda twips.

Etapas necessárias para que se mova um polígono para uma localização:
  Se o polígono for inexistente, cancele.
  Obtenha um difference between a localização e o canto superior esquerdo desta caixa deste polígono.
  Mova o polígono usando a difference.

Etapas necessárias para que se mova um polígono para cima uns twips:
  Mova o polígono usando 0 e - os twips.

Etapas necessárias para que se mova um percorredor (catálogo dicionário léxico rules):
  Skip algum tipo de leading noise no segmento final deste percorredor.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Percorra. [o código abaixo]
    Se o segmento final deste percorredor estiver em branco, cancele.
    Avance o percorredor.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor for irrelevante, cancele.
  Repita. [o código acima]

Etapas necessárias para que se mova um percorredor (quoted string rules):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for as aspas duplas, repita.
  Se o first endereço de memória do pedaço deste segmento final deste percorredor for o last endereço de memória do pedaço deste segmento final deste percorredor, avance o percorredor; exit.
  Avance o percorredor.
  Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for as aspas duplas, cancele.
  Repita. [o código acima]

Etapas necessárias para que se mova um percorredor (spell checking rules):
  Skip algum tipo de non-alfanumérico pedaços no segmento final deste percorredor.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Percorra. [o código abaixo]
    Se o segmento final deste percorredor estiver em branco, cancele.
    Avance o percorredor.
    Se o segmento final deste percorredor está sobre alguma espécie de contração, avance o percorredor; repita.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for alfanumérico, cancele.
  Repita. [o código acima]

Etapas necessárias para que se mova um percorredor (text file rules):
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Percorra. [o código abaixo]
    Se o segmento final deste percorredor estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor for o return pedaço, avance o percorredor; break.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor for o linefeed pedaço, avance o percorredor; exit. 
  \ *dahn new to handle lines terminated por just linefeed
    Avance o percorredor.
  Repita. [o código acima]
  Se o segmento final deste percorredor estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor for o linefeed pedaço, adicione 1 para o first endereço de memória do pedaço deste segmento final deste percorredor.

Etapas necessárias para que se mova um percorredor (word wrapping rules):
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor for o return pedaço, avance o percorredor; exit.
  Percorra. [o código abaixo]
    Se o segmento final deste percorredor estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor for o return pedaço, cancele.
    Se o segmento inicial deste percorredor estiver em branco, avance o percorredor; repita.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor for like o conteúdo deste last endereço de memória do pedaço deste segmento inicial deste percorredor, 
      avance o percorredor; repita.

Etapas necessárias para que se mova um percorredor usando uma caixa (word wrapping rules):
  Skip algum tipo de leading linefeed pedaço no segmento final deste percorredor.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, cancele.
  Lance um segundo percorredor sobre o percorredor.
  Percorra. [o código abaixo]
    Se o segmento final deste percorredor estiver em branco, cancele.
    Mova o segundo percorredor (word wrapping rules).
    Se o segmento inicial deste segundo percorredor estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento inicial deste segundo percorredor for o return pedaço, avance o percorredor; exit.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento inicial deste segundo percorredor for whitespace, avance o percorredor pelo quantidade de caracteres deste segmento inicial deste segundo percorredor; repita.
    Se o segmento inicial deste percorredor estiver em branco, avance o percorredor pelo quantidade de caracteres deste segmento inicial deste segundo percorredor; repita.
    Se o segmento inicial deste percorredor junto com o segmento inicial deste segundo percorredor forem wider do que a caixa, cancele.
    Avance o percorredor pelo quantidade de caracteres deste segmento inicial deste segundo percorredor.
  Repita. [o código acima]

Etapas necessárias para que se mova um percorredor usando um separator pedaço:
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Percorra. [o código abaixo]
    Se o segmento final deste percorredor estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor for o separator pedaço, adicione 1 para o first endereço de memória do pedaço deste segmento final deste percorredor; exit.
    Avance o percorredor.
  Repita. [o código acima]

Etapas necessárias para que se mova para o right uns twips e para baixo uns segunda twips;
Etapas necessárias para que se mova right uns twips e para baixo uns segunda twips;
Etapas necessárias para que se mova uns twips para o right e uns segunda twips para baixo;
Etapas necessárias para que se mova uns twips right e uns segunda twips para baixo:
  Mova a localização deste context right os twips.
  Mova a localização deste context para baixo a segunda twips.

Etapas necessárias para que se mova para o right uns twips e para cima uns segunda twips;
Etapas necessárias para que se mova right uns twips e para cima uns segunda twips;
Etapas necessárias para que se mova uns twips para o right e uns segunda twips para cima;
Etapas necessárias para que se mova uns twips right e uns segunda twips para cima:
  Mova a localização deste context right os twips.
  Mova a localização deste context para cima a segunda twips.

Etapas necessárias para que se mova para uma localização:
  Atribua a localização à localização deste context.

Etapas necessárias para que se mova uma localização about uns twips em algum tipo de direction:
  Escolha aleatoriamente uma segunda localização within os twips of a localização.
  Atribua a segunda localização à localização.

Etapas necessárias para que se mova uma localização para uma segunda localização:
  Atribua a segunda localização à localização.

Etapas necessárias para que se mova uma localização usando um par de números:
  Mova a localização usando o número X deste par de números e o número Y deste par de números.

Etapas necessárias para que se mova uma localização usando uns x-twips e uns y-twips:
  Adicione o x-twips para a coordenada X desta localização.
  Adicione o y-twips para a coordenada Y desta localização.

Etapas necessárias para que se mova uma localização uns twips para baixo;
Etapas necessárias para que se mova uma localização para baixo uns twips:
  Mova a localização usando 0 e os twips.

Etapas necessárias para que se mova uma localização uns twips para o left;
Etapas necessárias para que se mova uma localização uns twips left;
Etapas necessárias para que se mova uma localização left uns twips:
  Mova a localização usando - os twips e 0.

Etapas necessárias para que se mova uma localização uns twips right;
Etapas necessárias para que se mova uma localização uns twips para o right;
Etapas necessárias para que se mova uma localização right uns twips:
  Mova a localização usando os twips e 0.

Etapas necessárias para que se mova uma localização uns twips para o right e uns segunda twips para baixo;
Etapas necessárias para que se mova uma localização uns twips right e uns segunda twips para baixo:
  Adicione os twips para o x desta localização.
  Adicione a segunda twips para o y desta localização.

Etapas necessárias para que se mova uma localização uns twips para cima;
Etapas necessárias para que se mova uma localização para cima uns twips:
  Mova a localização usando 0 e - os twips.

Etapas necessárias para que se mova uns squares:
  Mova o square size times o squares dividido por 1 square. \ squares são scaled para cima por precision hence o division at o end

Etapas necessárias para que se mova uns squares diagonally;
Etapas necessárias para que se mova uns squares slantways:
  Mova o square size times o squares times o raiz de dois dividido por 1 square. \ squares são scaled para cima por precision hence o division at o end

Etapas necessárias para que se mova um subtexto usando um número:
  Adicione o número para o first endereço de memória do pedaço deste subtexto.
  Adicione o número para o last endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se mova um text para baixo uns twips:
  Mova o text usando 0 e os twips.

Etapas necessárias para que se mova um text usando um par de números:
  Mova o text usando o número X deste par de números e o número Y deste par de números.

Etapas necessárias para que se mova um text usando uns x-twips e uns y-twips:
  Se o text for inexistente, cancele.
  Mova a caixa deste text usando o x-twips e o y-twips.

Etapas necessárias para que se mova um text left uns twips:
  Mova o text usando - os twips e 0.

Etapas necessárias para que se mova um text right uns twips:
  Mova o text usando os twips e 0.

Etapas necessárias para que se mova um text para uma localização:
  Se o text for inexistente, cancele.
  Obtenha um difference between a localização e o canto superior esquerdo deste text.
  Mova o text usando a difference.

Etapas necessárias para que se mova um text para cima uns twips:
  Mova o text usando 0 e - os twips.

Etapas necessárias para que se mova uma coisa desde uns coisas para uns segunda coisas:
  Se a coisa for inexistente, cancele.
  Isole o coisa.
  Remove a coisa desde as coisas.
  Posponha a coisa para a segunda coisas.

Etapas necessárias para que se mova uns coisas para uns segunda coisas:
  Atribua o first destas coisas ao first destas segunda coisas.
  Atribua o last destas coisas ao last destas segunda coisas.
  Limpe as coisas.

Etapas necessárias para que se mova uns twips:
    \Aguarde pelo delay. ***
  Atribua a localização deste context ao start dessa line.
  Atribua a localização deste context ao end desta line.
  Obtenha um deslocamento vertical e um deslocamento horizontal usando a orientação deste context.
  Adicione o deslocamento horizontal times os twips dividido por 10000 para a coordenada X deste end desta line.
  Adicione o deslocamento vertical times os twips dividido por 10000 para a coordenada Y deste end desta line.
  Atribua o end desta line à localização deste context.

Etapas necessárias para que se mova uns twips para baixo;
Etapas necessárias para que se mova para baixo uns twips:
  Adicione os twips para a coordenada Y deste context.

Etapas necessárias para que se mova uns twips para o left;
Etapas necessárias para que se mova uns twips left;
Etapas necessárias para que se mova left uns twips:
  Subtraia os twips desde a coordenada X deste context.

Etapas necessárias para que se mova uns twips para o right;
Etapas necessárias para que se mova uns twips right;
Etapas necessárias para que se mova right uns twips:
  Adicione os twips para a coordenada X deste context.

Etapas necessárias para que se mova uns twips para cima;
Etapas necessárias para que se mova para cima uns twips:
  Subtraia os twips desde a coordenada Y deste context.

Etapas necessárias para que se mova um vértice para baixo uns twips:
  Mova o vértice usando 0 e os twips.

Etapas necessárias para que se mova um vértice usando um par de números:
  Mova o vértice usando o número X deste par de números e o número Y deste par de números.

Etapas necessárias para que se mova um vértice usando uns x-twips e uns y-twips:
  Se o vértice for inexistente, cancele.
  Adicione o x-twips para a coordenada X deste vértice.
  Adicione o y-twips para a coordenada Y deste vértice.

Etapas necessárias para que se mova um vértice left uns twips:
  Mova o vértice usando - os twips e 0.

Etapas necessárias para que se mova um vértice right uns twips:
  Mova o vértice usando os twips e 0.

Etapas necessárias para que se mova um vértice para uma localização:
  Se o vértice for inexistente, cancele.
  Atribua a localização à localização deste vértice.

Etapas necessárias para que se mova um vértice para cima uns twips:
  Mova o vértice usando 0 e - os twips.

Etapas necessárias para que se mova uma window left:
  Call "user32.dll" "GetWindowRect" com 
    A main window 
    e O endereçamento dessa caixa.
  Subtraia a pixel largura desta tela desde a coordenada esquerda desta caixa.
  Call "user32.dll" "MoveWindow" com 
    A window 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A pixel largura desta tela 
    e A pixel altura desta tela 
    e 1.

Etapas necessárias para que se mova uma window right:
  Call "user32.dll" "GetWindowRect" com 
    A main window 
    e O endereçamento dessa caixa.
  Adicione a pixel largura desta tela para a coordenada esquerda desta caixa.
  Call "user32.dll" "MoveWindow" com 
    A window 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A pixel largura desta tela 
    e A pixel altura desta tela 
    e 1.

Um ms é 1 millisecond.

Uma msg é um conjunto com
  Uma window denominado hwnd,
  Um número denominado message,
  Um w-param denominado wparam,
  Um l-param denominado lparam,
  Um número denominado time,
  Uma localização denominado pt.

Um múltiplo é um número.

Etapas necessárias para que se multiplique uma fração por um número:
  Multiplique o numerador desta fração pelo número.
  Reduce a fração.

Etapas necessárias para que se multiplique um número por um fração;
Etapas necessárias para que se redimensione proporcionalmente um número usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um número usando um fração:
  Se o denominador desta fração for 0, cancele.
  Call "kernel32.dll" "MulDiv" com 
    O número e o numerador desta fração 
    e O denominador desta fração 
    devolvendo o número.

Etapas necessárias para que se multiplique um par de números por um segundo par de números:
  Multiplique o número X deste par de números pelo número X deste segundo par de números.
  Multiplique o número Y deste par de números pelo número Y deste segundo par de números.

Etapas necessárias para que se multiplique um par de números por um número:
  Multiplique o número X deste par de números pelo número.
  Multiplique o número Y deste par de números pelo número.

Etapas necessárias para que se multiplique um par de números por um número e um segundo número:
  Multiplique o número X deste par de números pelo número.
  Multiplique o número Y deste par de números pelo segundo número.

Etapas necessárias para que se multiplique um endereço de memória por um número;
Etapas necessárias para que se multiplique um número por um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segundo número
  Intel $F72B.\ mul [ebx] \ means mul eax,[ebx] but é weird form
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8903. \ mov [ebx],eax

Um nome é uma string.

Etapas necessárias para que se negate um fração:
  Negate o numerador desta fração.

Etapas necessárias para que se negate um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $F718.\ neg [eax]

Etapas necessárias para que se negate um par de números:
  Negate o número X deste par de números.
  Negate o número Y deste par de números.

O next letra é um letra igual a 65 [the big-a byte].

Uma cifra binária é um pedaço. \ somente são válidos os 4 bits de ordem inferior. Exemplo: No byte 0101 1010 somente a parte "1010" é válida. 
    \ é um "low order nibble" ou uma sucessão de bytes de ordem inferior

Um cifra hexadecimal é uma string. \ Exemplo: $0010A0... O cifrão serve para indicar ao compilador que se trata de um valor hexadecimal. 
    \Em outras linguagens costuma-se usar um # (como no css #a1b2e3; ou um 0x, por exemplo 0xA1B2FF...

Etapas necessárias para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números racionais;
Etapas necessárias para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números fracionários:
  Se a imagem for inexistente, cancele.
  Mova a caixa intacta desta imagem usando o par de números fracionários e o canto superior esquerdo desta caixa desta imagem.
  Redimensione a caixa intacta desta imagem usando o par de números fracionários.
  Redimensione a caixa desta imagem usando o par de números fracionários.
  Se a coordenada direita desta imagem for menor do que a coordenada esquerda desta imagem, mirror o gpbitmap no imagem.
  Se a coordenada inferior desta imagem for menor do que a coordenada superior desta imagem, flip o gpbitmap no imagem.

Etapas necessárias para que se redimensione cuidadosamente [sem perder qualidade] um imagem usando um twip par de números:
  Se o imagem for inexistente, cancele.
  Atribua a caixa desta imagem a uma caixa.
  Redimensione a caixa usando o twip par de números.
  Make uma par de números fracionários usando a caixa e a caixa desta imagem.
  redimensione cuidadosamente [sem perder qualidade] o imagem usando o par de números fracionários.

Etapas necessárias para que se normalize um ângulo:
  Divida o ângulo por 3600 usando um quotient e o ângulo.

Etapas necessárias para que se normalize uma caixa:
  Se a coordenada direita desta caixa for menor do que a coordenada esquerda desta caixa, permute a coordenada esquerda desta caixa com a coordenada direita desta caixa.
  Se a coordenada inferior desta caixa for menor do que a coordenada superior desta caixa, permute a coordenada superior desta caixa com a coordenada inferior desta caixa.

Etapas necessárias para que se normalize um canvas:
  Call "gdi32.dll" "SetGraphicsMode" com 
    O canvas 
    e 2 [GM_ADVANCED].
  Call "gdi32.dll" "SetBkMode" com 
    O canvas 
    e 1 [TRANSPARENT].
  Call "gdi32.dll" "SetMapMode" com 
    O canvas 
    e 8 [MM_ANISOTROPIC ].
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O canvas 
    e 0 
    e 0 
    e nil.
  Call "gdi32.dll" "SetViewportExtEx" com 
    O canvas 
    e O ppi 
    e O ppi 
    e nil.
  Call "gdi32.dll" "SetWindowOrgEx" com 
    O canvas 
    e 0 
    e 0 
    e nil.
  Call "gdi32.dll" "SetWindowExtEx" com 
    O canvas 
    e O tpi 
    e O tpi 
    e nil.

Etapas necessárias para que se normalize um elipse:
  Normalize a caixa desta elipse.

Etapas necessárias para que se normalize uma fração e uma segunda fração:
  Obtenha um mínimo múltiplo comum usando o denominador desta fração e o denominador desta segunda fração.
  Multiplique o numerador desta fração pelo mínimo múltiplo comum dividido pelo denominador desta fração.
  Atribua o mínimo múltiplo comum ao denominador desta fração.
  Multiplique o numerador desta segunda fração pelo mínimo múltiplo comum dividido pelo denominador desta segunda fração.
  Atribua o mínimo múltiplo comum ao denominador desta segunda fração.

Etapas necessárias para que se normalize uma orientação:
  Divida a orientação por 3840 usando um quotient e um resto.
  Atribua o resto à orientação.
  Se a orientação for menor do que 0, adicione 3840 para a orientação.

Etapas necessárias para que se normalize um horizontal line:
  Se o end desta line for menor do que o start desta line, permute o end desta line com o start desta line.

Etapas necessárias para que se normalize um matiz:
  Divida o matiz por 3600 usando um quotient e um resto.
  Atribua o resto ao matiz.
  Se o matiz for menor do que 0, adicione 3600 para o matiz.

Etapas necessárias para que se normalize um imagem:
  Se o imagem for inexistente, cancele.
  Normalize a caixa desta imagem.
  Normalize a caixa intacta desta imagem.

Etapas necessárias para que se normalize uma seleção:
  Se o anchor número da linha desta seleção for menor do que o número de linhas do cursor desta seleção, cancele.
  Se o anchor número da linha desta seleção for maior do que o número de linhas do cursor desta seleção, permute o anchor desta seleção com o caret desta seleção; exit.
  Se o anchor column# desta seleção for maior do que o caret column# desta seleção, permute o anchor column# desta seleção com o caret column# desta seleção.

Etapas necessárias para que se normalize um text:
  Se o text for inexistente, cancele.
  Normalize a caixa deste text.

Etapas necessárias para que se normalize um vertical line:
  Se o end desta line for menor do que o start desta line, permute o end desta line com o start desta line.

O null hbrush é um hbrush.

O null número da fonte é um número da fonte.

O null hpen é um hpen.

Etapas necessárias para que se modifique através do caractere NUL uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres armazenados mais 1.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres armazenados menos 1 ao last endereço de memória do pedaço desta string.
  Atribua o last endereço de memória do pedaço desta string mais 1 a um endereço de memória do pedaço .
  Atribua o null pedaço ao conteúdo deste endereço de memória do pedaço.

Etapas necessárias para que se modifique através do caractere NUL um wide string:
  Atribua a quantidade de caracteres deste wide string a uma quantidade de caracteres armazenados.
  Reassign o first desta wide string usando a quantidade de caracteres armazenados mais 2.
  Atribua o first desta wide string mais a quantidade de caracteres armazenados menos 1 ao last deste wide string.

Um número é um conjunto com
  Um first pedaço,
  Um second pedaço,
  Um terceiro pedaço,
  Um quarto pedaço,
  Uma low word at o first pedaço,
  Uma high word at o terceiro pedaço.

Um endereço numérico é um endereço de memória para um número.

Um offset é um número.

Etapas necessárias para que se abra um file usando um endereço completo:
  Limpe o erro do fluxo de entrada/saída.
  Extraia um endereço da pasta desde o endereço completo.
  Se o endereço da pasta não estiver no sistema de arquivos, atribua "A Pasta: " junto com o endereço da pasta seguido de " não existe." ao erro do fluxo de entrada/saída; exit.
  Ligue o endereço completo para read-write mode.
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com 
    O first deste endereço completo 
    e -1073741824 [GENERIC_READ+GENERIC_WRITE] 
    e 0 
    e 0 
    e 4 [OPEN_ALWAYS] 
    e -2147483520 [FILE_FLAG_WRITE_THROUGH ou FILE_ATTRIBUTE_NORMAL] 
    e 0 
    devolvendo o file.
  Se o file for -1 [INVALID_HANDLE_VALUE], atribua "Ocorreu um erro na hora de abrir o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se abra um file usando um endereço completo e uns milliseconds:
  Start um temporizador.
  Percorra. [o código abaixo]
    Abra o file usando o endereço completo.
    Se o erro do fluxo de entrada/saída estiver em branco, cancele.
    Se os ticks deste temporizador forem greater do que os milliseconds, cancele.
  Repita. [o código acima]

Um operação é uma string.

Um origin é uma localização.

    \O osmosian font resource é uma font resource.

A fonte Tahoma é um texto hexadecimal igual a $00. \ quando se usa uma fonte do windows não é necesário inserir o código hexadecimal da mesma no fonte.
O recurso de fonte Tahoma é um font resource.

Etapas necessárias para que se outdent algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita. \selecionada
    Se o conteúdo deste first endereço de memória do pedaço desta string desta row for o caractere de espaço, remove o first pedaço desde a string deste row.
    Se o conteúdo deste first endereço de memória do pedaço desta string desta row for o caractere de espaço, remove o first pedaço desde a string deste row.
  Repita. [o código acima]

Etapas necessárias para que se outdent uma caixa uns twips;
Etapas necessárias para que se outdent uma caixa usando uns twips:
  Subtraia os twips desde a coordenada esquerda desta caixa.
  Subtraia os twips desde a coordenada superior desta caixa.
  Adicione os twips para a coordenada direita desta caixa.
  Adicione os twips para a coordenada inferior desta caixa.

Um outdent é um número.

Etapas necessárias para que se outline uma caixa com uma cor:
  Pinte a caixa com a cor e a cor preta.

  
Um x-offset é um offset.
Um y-offset é um offset.

Etapas necessárias para que se output o arco of uma elipse usando uma string: \\ interessante.
  Atribua 2761/10000 a um fração. \ 2/3*(sqrt(2)-1)
  Atribua o center desta elipse a um center localização.
  Atribua o x-extent desta elipse dividido por 2 a um half largura.
  Atribua o y-extent desta elipse dividido por 2 a um half altura.
  Atribua o x-extent desta elipse times a fração a um x-offset.
  Atribua o y-extent desta elipse times a fração a um y-offset.
    \ control point 1
  Se a string for "canto superior esquerdo", atribua a coordenada esquerda desta elipse e a coordenada Y deste center menos o y-offset a um first control localização.
  Se a string for "canto superior direito", atribua a coordenada X deste center mais o x-offset e a coordenada superior desta elipse ao first control localização.
  Se a string for "canto inferior direito", atribua a coordenada direita desta elipse e a coordenada Y deste center mais o y-offset ao first control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X deste center menos o x-offset e a coordenada inferior desta elipse ao first control localização.
    \ control point 2
  Se a string for "canto superior esquerdo", atribua a coordenada X deste center menos o x-offset e a coordenada superior desta elipse a um second control localização.
  Se a string for "canto superior direito", atribua a coordenada direita desta elipse e a coordenada Y deste center menos o y-offset ao second control localização.
  Se a string for "canto inferior direito", atribua a coordenada X deste center mais o x-offset e a coordenada inferior desta elipse ao second control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada esquerda desta elipse e a coordenada Y deste center mais o y-offset ao second control localização.
    \ ending point
  Se a string for "canto superior esquerdo", atribua a coordenada esquerda desta elipse mais o half largura e a coordenada superior desta elipse a um ending localização.
  Se a string for "canto superior direito", atribua a coordenada direita desta elipse e a coordenada superior desta elipse mais o half altura ao ending localização.
  Se a string for "canto inferior direito", atribua a coordenada direita desta elipse menos o half largura e a coordenada inferior desta elipse ao ending localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada esquerda desta elipse e a coordenada inferior desta elipse menos o half altura ao ending localização.
    \ spit it out
  Output o first control localização sem passar pra próxima linha.
  Output o second control localização sem passar pra próxima linha.
  Output o ending localização sem passar pra próxima linha.
  Output "c".

Etapas necessárias para que se output uma cor sem passar pra próxima linha:
  Converta a cor para um espaço de cor RGB.
  Atribua o espectro vermelho deste espaço de cor RGB / 255 a um fração.
  Converta a fração para um red string usando 4.
  Atribua o espectro verde deste espaço de cor RGB / 255 à fração.
  Converta a fração para um green string usando 4.
  Atribua o espectro azul deste espaço de cor RGB / 255 à fração.
  Converta a fração para um blue string usando 4.
  Output o red string seguido de " " junto com o green string seguido de " " junto com o blue string sem passar pra próxima linha.

Etapas necessárias para que se output lineto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "l".

Etapas necessárias para que se output lineto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output lineto usando a localização.

Etapas necessárias para que se output moveto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "m".

Etapas necessárias para que se output moveto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output moveto usando a localização.

Etapas necessárias para que se output um número sem passar pra próxima linha:
  Converta o número para uma string.
  Output a string sem passar pra próxima linha.
  Output " " sem passar pra próxima linha.

Etapas necessárias para que se output stroke e fill usando uma cor da borda e uma cor de preenchimento:
  Atribua "B" a uma string. \ stroke e fill
  Se a cor de preenchimento estiver clear, atribua "S" à string. \ stroke
  Se a cor da borda estiver clear, atribua "f" à string. \ fill
  Output a string.

Um pabc é um endereço de memória para um abc.

\Um paintstruct é um conjunto com
\Um hdc denominado hdc,
\Um número denominado ferase,
\Um caixa denominado rcpaint,
\Um número denominado frestore,
\Um número denominado fincupdate,
\  32 pedaços.

Um número X é um número.
Um número Y é um número.

Um par de números é um conjunto com 
  Um número X e 
  Um número Y.

Um pchar é um endereço de memória do pedaço.

Um pdevmode é um endereço de memória para um devmode.

A grossura do pincel é um número.

Um percent é um número. \ um scale com 100 no denominador

Etapas necessárias para que se escolha aleatoriamente um brilho between um percent e uma segunda percent;
Etapas necessárias para que se vary uma luminosidade between um percent e uma segunda percent;
Etapas necessárias para que se escolha aleatoriamente uam luminosidade between um percent e uma segunda percent:
  Escolha aleatoriamente um número between o percent e a segunda percent.
  Atribua o número times 10 à luminosidade.
  Atribua a luminosidade à luminosidade deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor amarronzada:
  Escolha aleatoriamente a matiz desta cor amarronzada between 250 e 350.
  Escolha aleatoriamente a saturação desta cor amarronzada between 500 e 1000.
  Escolha aleatoriamente o brilho desta cor amarronzada between 125 e 375.
  Atribua a cor amarronzada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor amarronzada about uns percent of o time:
    \ *** generalize this por all cors
  Escolha aleatoriamente um número between 1 e 100.
  Se o número for maior do que o percent, cancele.
  Escolha aleatoriamente a cor amarronzada.
  Atribua a cor amarronzada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor:
  Escolha aleatoriamente a matiz desta cor between 0 e 3600.
  Escolha aleatoriamente a saturação desta cor between 0 e 1000.
  Escolha aleatoriamente a luminosidade desta cor between 0 e 1000.
  Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor between uma segunda cor e um terceiro cor:
  Escolha aleatoriamente a matiz desta cor between a matiz desta segunda cor e a matiz desta terceiro cor.
  Escolha aleatoriamente a saturação desta cor between a saturação desta segunda cor e a saturação desta terceiro cor.
  Escolha aleatoriamente a luminosidade desta cor between a luminosidade desta segunda cor e a luminosidade desta terceiro cor.
  Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor like uma segunda cor:
  Atribua a segunda cor à cor.
  Escolha aleatoriamente um número between -100 e 100.
  Adicione o número para a matiz desta cor.
  Limite a matiz desta cor para 0 e 3599.
  Defina a saturação desta cor para something between 100 e 1000.
  Defina a luminosidade desta cor para something between 0 e 800.
  Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor escura:
    \Etapas necessárias para que se escolha aleatoriamente uma cor escura:
  Escolha aleatoriamente a matiz desta cor escura between 0 e 3599.
  Atribua 1000 à saturação desta cor escura.
  Atribua 375 à luminosidade desta cor escura.
  Atribua a cor escura à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor esverdeada:
  Escolha aleatoriamente a matiz desta cor esverdeada between 900 e 1200.
  Escolha aleatoriamente a saturação desta cor esverdeada between 500 e 1000.
  Escolha aleatoriamente o brilho desta cor esverdeada between 250 e 875.
  Atribua a cor esverdeada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor esverdeada about uns percent of o time:
    \ *** generalize this por all cors
  Escolha aleatoriamente um número between 1 e 100.
  Se o número for maior do que o percent, cancele.
  Escolha aleatoriamente a cor esverdeada.
  Atribua a cor esverdeada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma orientação:
  Escolha aleatoriamente a orientação between 0 e 3839.
  Atribua a orientação à orientação deste context.

Etapas necessárias para que se escolha aleatoriamente um tamanho da letra between uns twips e uns segunda twips:
  Escolha aleatoriamente um random número between os twips e a segunda twips.
  Atribua o random número ao tamanho da letra.
  Atribua o random número à tamanho da letra deste context.

Etapas necessárias para que se escolha aleatoriamente um letra of o alphabet:
    \ atribua letra A context? ***
  Escolha aleatoriamente um número between 65 e 90.
  Atribua o número ao letra.

Etapas necessárias para que se escolha aleatoriamente um claro cor:
  Escolha aleatoriamente a matiz desta claro cor between 0 e 3599.
  Atribua 1000 à saturação desta claro cor.
  Atribua 625 à luminosidade desta claro cor.
  Atribua o claro cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um número:
  Escolha aleatoriamente o número between 0 e o maior número.
  Atribua o número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente um número within um quantia of um segundo número:
  Escolha aleatoriamente o número between o segundo número menos o quantia e o segundo número mais o quantia.
  Atribua o número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor pastel:
  Escolha aleatoriamente a matiz desta cor pastel between 0 e 3599.
  Atribua 1000 à saturação desta cor pastel.
  Atribua 875 à luminosidade desta cor pastel.
  Atribua a cor pastel à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um rainbow cor:
  Adicione 1 para o número atual da cor do arco-íris.
  Se o número atual da cor do arco-íris for maior do que 6, atribua 1 ao número atual da cor do arco-íris.
  Se o número atual da cor do arco-íris for 1, atribua a cor vermelha ao rainbow cor.
  Se o número atual da cor do arco-íris for 2, atribua a cor laranja ao rainbow cor.
  Se o número atual da cor do arco-íris for 3, atribua a cor amarela ao rainbow cor.
  Se o número atual da cor do arco-íris for 4, atribua a cor verde ao rainbow cor.
  Se o número atual da cor do arco-íris for 5, atribua a cor azul ao rainbow cor.
  Se o número atual da cor do arco-íris for 6, atribua a cor púrpura ao rainbow cor.
  Atribua o rainbow cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um solid cor:
  Escolha aleatoriamente o matiz desta solid cor between 0 e 3599.
  Atribua 1000 à saturação desta solid cor.
  Atribua 500 à luminosidade desta solid cor.
  Atribua o solid cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma localização anywhere no base uma fração of uma caixa;
Etapas necessárias para que se escolha aleatoriamente uma localização no base uma fração of uma caixa:
  Isole a caixa.
  Atribua a altura desta caixa times a fração a uns twips.
  Atribua a coordenada inferior desta caixa menos os twips à coordenada superior desta caixa.
  Escolha aleatoriamente a localização na caixa.

Etapas necessárias para que se escolha aleatoriamente uma localização anywhere em uma caixa:
  Escolha aleatoriamente a coordenada X desta localização between a coordenada esquerda desta caixa e a coordenada direita desta caixa.
  Escolha aleatoriamente a coordenada Y desta localização between a coordenada superior desta caixa e a coordenada inferior desta caixa.
  Atribua a localização à localização deste context.

Etapas necessárias para que se escolha aleatoriamente uma localização anywhere no middle uma fração of uma caixa;
Etapas necessárias para que se escolha aleatoriamente uma localização no middle uma fração of uma caixa:
  Isole a caixa.
  Atribua o y deste center desta caixa a uma coordenada.
  Atribua a altura desta caixa times a fração dividido por 2 a um número.
  Atribua a coordenada menos o número à coordenada superior desta caixa.
  Atribua a coordenada mais o número à coordenada inferior desta caixa.
  Escolha aleatoriamente a localização na caixa.

Etapas necessárias para que se escolha aleatoriamente uma localização anywhere no topo half of uma caixa;
Etapas necessárias para que se escolha aleatoriamente uma localização no topo half of uma caixa:
  Isole a caixa.
  Atribua o y deste center desta caixa à coordenada inferior desta caixa.
  Escolha aleatoriamente a localização na caixa.

Etapas necessárias para que se escolha aleatoriamente uma localização anywhere no topo middle uma fração of uma caixa;
Etapas necessárias para que se escolha aleatoriamente uma localização no topo middle uma fração of uma caixa:
  Isole a caixa.
  Atribua o y deste center desta caixa a uma coordenada.
  Atribua a altura desta caixa times a fração a um número.
  Atribua a coordenada menos o número à coordenada superior desta caixa.
  Atribua a coordenada à coordenada inferior desta caixa.
  Escolha aleatoriamente a localização na caixa.

Etapas necessárias para que se escolha aleatoriamente uma localização anywhere sobre um horizontal line;
Etapas necessárias para que se escolha aleatoriamente uma localização sobre um horizontal line:
  Escolha aleatoriamente a coordenada X desta localização between o horizontal x deste start desta line e o x deste end desta horizontal line.
  Atribua o y desta horizontal line ao y desta localização.

Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa:
  Escolha aleatoriamente a coordenada X desta localização between a coordenada esquerda desta caixa e a coordenada direita desta caixa.
  Escolha aleatoriamente a coordenada Y desta localização between a coordenada superior desta caixa e a coordenada inferior desta caixa.
  Atribua a localização à localização deste context.

Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa about uns twips above o middle;
Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa about uns twips above o center:
  Atribua a caixa a um bounding caixa.
  Atribua os twips dividido por 2 a uns segunda twips.
  Atribua o y deste center desta caixa menos a segunda twips à coordenada inferior desta bounding caixa.
  Atribua a coordenada inferior desta bounding caixa menos os twips à coordenada superior desta bounding caixa.
  Escolha aleatoriamente a localização anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa about uns twips below o middle;
Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa about uns twips below o center:
  Atribua a caixa a um bounding caixa.
  Atribua os twips dividido por 2 a uns segunda twips.
  Atribua o y deste center desta caixa mais a segunda twips à coordenada superior desta bounding caixa.
  Atribua a coordenada superior desta bounding caixa mais os twips à coordenada inferior desta bounding caixa.
  Escolha aleatoriamente a localização anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa uns twips para uns segunda twips above o middle;
Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa uns twips para uns segunda twips above o center:
  Atribua a caixa a um bounding caixa.
  Atribua o y deste center desta caixa menos os twips à coordenada inferior desta bounding caixa.
  Atribua a coordenada inferior desta bounding caixa menos a segunda twips à coordenada superior desta bounding caixa.
  Escolha aleatoriamente a localização anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa uns twips para uns segunda twips below o middle;
Etapas necessárias para que se escolha aleatoriamente uma localização em uma caixa uns twips para uns segunda twips below o center:
  Atribua a caixa a um bounding caixa.
  Atribua o y deste center desta caixa mais os twips à coordenada superior desta bounding caixa.
  Atribua a coordenada superior desta bounding caixa mais a segunda twips à coordenada inferior desta bounding caixa.
  Escolha aleatoriamente a localização anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente uma localização within um distance of uma segunda localização:
  Escolha aleatoriamente a coordenada X desta localização within o distance of a coordenada X desta segunda localização.
  Escolha aleatoriamente a coordenada Y desta localização within o distance of a coordenada Y desta segunda localização.
  Atribua a localização à localização deste context.

Etapas necessárias para que se escolha aleatoriamente uns twips between uns min twips e uns segunda twips; \ são all these necessary? ***
Etapas necessárias para que se escolha aleatoriamente um número between uns min twips e uns segunda twips;
Etapas necessárias para que se escolha aleatoriamente um número between um min número e um max número;
Etapas necessárias para que se escolha aleatoriamente um número desde um min número para um max número;
Etapas necessárias para que se defina um número para something between um segundo número e um terceiro número;
Etapas necessárias para que se escolha aleatoriamente um random número between um min número e um max número:
  Atribua o endereçamento deste seed para EAX.
    \ atribua address of randseed A ecx
  Intel $8BC8. \ mov ecx,eax
    \ calculate zero based max
  Intel $8B8510000000. \ mov eax,[ebp+16] \ o max
  Intel $8B00. \ mov eax,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o min
  Intel $2B03. \ sub eax,[ebx]
  Intel $40. \ inc eax
    \ ajuste randseed
  Intel $691105840808. \ imul edx,[ecx],134775813
  Intel $42. \ inc edx
  Intel $8911. \ mov [ecx],edx
    \ mul adjusted randseed pelo zero based max
  Intel $F7E2. \ mul edx
    \ adicione o min para an-zero base o número
  Intel $0313. \ adicione edx,[ebx] o min
    \ store o result
  Intel $8B9D08000000. \ mov ebx,[ebp+08] \ o random número
  Intel $8913. \ mov [ebx],edx
  Atribua o random número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente um cor muito escura;
Etapas necessárias para que se escolha aleatoriamente um really cor escura:
  Escolha aleatoriamente a matiz desta really cor escura between 0 e 3599.
  Atribua 500 à saturação desta really cor escura.
  Atribua 250 à luminosidade desta really cor escura.
  Atribua o really cor escura à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor muito clara;
Etapas necessárias para que se escolha aleatoriamente um really claro cor:
  Escolha aleatoriamente a matiz desta really claro cor between 0 e 3599.
  Atribua 1000 à saturação desta really claro cor.
  Atribua 750 à luminosidade desta really claro cor.
  Atribua o really claro cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor escuríssima;
Etapas necessárias para que se escolha aleatoriamente um really really cor escura:
  Escolha aleatoriamente a matiz desta really really cor escura between 0 e 3599.
  Atribua 500 à saturação desta really really cor escura.
  Atribua 125 à luminosidade desta really really cor escura.
  Atribua o really really cor escura à cor deste context.

    \Etapas necessárias para que se escolha aleatoriamente uma cor claríssima;
Etapas necessárias para que se escolha aleatoriamente uma cor claríssima:
  Escolha aleatoriamente a matiz desta cor claríssima between 0 e 3599.
  Atribua 1000 à saturação desta cor claríssima.
  Atribua 875 à luminosidade desta cor claríssima.
  Atribua a cor claríssima à cor deste context.

Uma imagem é uma coisa com
    \ as caixas estão em twits
Um caixa [location of cropped imagem sobre a página], 
Um caixa intacta [location of entire imagem sobre a página],
Um grayscale detector,
Um mirror detector,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal denominado data [original pedaços em original format],
Um gpbitmap.

    \Um imagem é uma coisa com
    \ as caixas estão em twits
    \Um caixa [location of cropped imagem sobre a página], 
    \Um caixa intacta [location of entire imagem sobre a página],
    \Um grayscale detector,
    \Um mirror detector,
    \Um ângulo de rotação, \ rotation é clockwise
    \Um texto hexadecimal denominado data [original pedaços em original format],
    \Um gpbitmap.

    \Um figura é uma coisa com
    \ all caixas são em twits
    \Um caixa [location of cropped imagem sobre a página], 
    \Um caixa intacta [location of entire imagem sobre a página],
    \Um grayscale detector,
    \Um mirror detector,
    \Um ângulo de rotação, \ rotation é clockwise
    \Um texto hexadecimal denominado data [original pedaços em original format],
    \Um gpbitmap.

Etapas necessárias para que se toque um wave:
  Call "winmm.dll" "PlaySound" com 
    O first desta wave 
    e 0 
    e 5 [SND_MEMORY+SND_ASYNC].

Etapas necessárias para que se toque um wave e wait:
  Call "winmm.dll" "PlaySound" com 
    O first desta wave 
    e 0 
    e 4 [SND_MEMORY+SND_SYNC].

Etapas necessárias para que se toque um wave file:
  Isole o wave file.
  Modifique através do caractere NUL o wave file.
  Call "winmm.dll" "PlaySound" com 
    O first deste wave file 
    e 0 
    e 131073 [snd_filename+snd_async].

Etapas necessárias para que se toque um wave file e wait:
  Isole o wave file.
  Modifique através do caractere NUL o wave file.
  Call "winmm.dll" "PlaySound" com 
    O first deste wave file 
    e 0 
    e 131072 [snd_filename+snd_sync].

An point é um número. \cujos valores vão desde 0 até 3839;  servem para dividir um ciírculo. 
    \Nesse sistema de pontos de bússola, o número 0 representa o norte, cada quadrante tem 960 pontos
    \ Perfazendo um total de 3840 pontos

Um endereço de memória é um conjunto com 4 pedaços.

Um polígono é uma coisa com uns vértices.

Um position é um par de números com um column# e um número da linha.

Etapas necessárias para que se posicione um subtexto sobre uma string:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a string
    \ atribua o first endereço de memória do pedaço desta string ao first  endereço de memória do pedaço deste subtexto
  Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o first  endereço de memória do pedaço da string
  Intel $898800000000. \ mov [eax+0],ecx \ o first  endereço de memória do pedaço do subtexto
    \ atribua o first endereço de memória do pedaço desta string menos 1 ao last endereço de memória do pedaço deste subtexto
  Intel $49. \ dec ecx
  Intel $898804000000. \ mov [eax+4],ecx \ o last endereço de memória do pedaço deste subtexto

Etapas necessárias para que se post um data string para um URL e receive um response string:
    \ only works com http e https
  Limpe o response.
  Limpe o erro do fluxo de entrada/saída.
  Crie um winhttp request por posting para o URL.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Send o data para o winhttp request.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
  Receive o response desde o winhttp request.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
  Read o response desde o winhttp request.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
  Destrua o winhttp request.

Um poutlinetextmetric é um endereço de memória para um outlinetextmetric.

O ppi é uns twips.

An precise degree é um número [0 para 3599].

Etapas necessárias para que se anteponha um pedaço para uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres desta string mais 1.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o first endereço de memória do pedaço desta string mais 1 pelo quantidade de caracteres armazenados.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres armazenados ao last endereço de memória do pedaço desta string.
  Atribua o pedaço ao conteúdo deste first endereço de memória do pedaço desta string.

Etapas necessárias para que se anteponha uma string para uma segunda string:
  Atribua a quantidade de caracteres desta segunda string mais a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Reassign um endereço de memória usando a quantidade de caracteres agrupados.
  Atribua o endereço de memória ao first endereço de memória do pedaço desse subtexto.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o first endereço de memória do pedaço deste subtexto pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o first endereço de memória do pedaço deste subtexto.
  Copie pedaços desde o first desta segunda string para o first endereço de memória do pedaço deste subtexto pelo quantidade de caracteres desta segunda string.
  Unassign o first endereço de memória do pedaço desta segunda string. \ para que se esvazie extra allocates e copies
  Atribua o endereço de memória ao first endereço de memória do pedaço desta segunda string.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres agrupados menos 1 ao last endereço de memória do pedaço desta segunda string.

Etapas necessárias para que se anteponha uma coisa para uns coisas:
  Se a coisa for inexistente, cancele.
  Atribua o first destas coisas ao next desta coisa.
  Se  as coisas não for vazio, atribua a coisa ao previous deste first destas coisas.
  Se  as coisas estiverem vazio, atribua a coisa ao last destas coisas.
  Atribua a coisa ao first destas coisas.

    \Etapas necessárias para que se anteponha uns coisas para umas segunda coisas:
    \ bug found por Mike Gonta - corrected version below
    \Obtenha uma coisa desde  as coisas (backwards).
    \Se a coisa for inexistente, cancele.
    \Remove a coisa desde as coisas.
    \Anteponha a coisa para a segunda coisas.
    \Repita. [o código acima]

Etapas necessárias para que se anteponha uns coisas para umas segunda coisas:
  Atribua o last destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Anteponha a coisa para a segunda coisas.
  Repita. [o código acima]

O printer canvas é um canvas.

O número identificador do modo de dispositivo da impressora é um número identificador.

Um process é um número identificador.

Um process endereço de memória é um endereço de memória para um process.

Um punch line é uma string.

Etapas necessárias para que se atribua o actual data of uma font para um trecho:
    \ only works com true/abra type fonts
  Crie o número da fonte of o memory canvas usando o font.
  Call "gdi32.dll" "GetFontData" com 
    O memory canvas 
    e 0 
    e 0 
    e nil 
    e 0 
    devolvendo uma contagem.
  Reassign o first endereço de memória do pedaço deste trecho usando a contagem.
  Call "gdi32.dll" "GetFontData" com 
    O memory canvas 
    e 0 
    e 0 
    e O first endereço de memória do pedaço deste trecho 
    e A contagem.
  Atribua o first endereço de memória do pedaço deste trecho mais a contagem menos 1 ao last endereço de memória do pedaço deste trecho.
  Destrua o número da fonte of o memory canvas.

Etapas necessárias para que se atribua o base of uma caixa para um horizontal line;
Etapas necessárias para que se atribua o base edge of uma caixa para um horizontal line;
Etapas necessárias para que se atribua o base side of uma caixa para um horizontal line:
  Atribua o canto inferior esquerdo desta caixa ao start desta horizontal line.
  Atribua o canto inferior direito desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o base of uma caixa para um line:
  Make o line com o canto inferior esquerdo desta caixa e o canto inferior direito desta caixa.

Etapas necessárias para que se atribua uma caixa e um raio para uma caixa arredondada:
  Atribua a coordenada esquerda desta caixa à coordenada esquerda desta caixa arredondada.
  Atribua a coordenada superior desta caixa à coordenada superior desta caixa arredondada.
  Atribua a coordenada direita desta caixa à coordenada direita desta caixa arredondada.
  Atribua a coordenada inferior desta caixa à coordenada inferior desta caixa arredondada.
  Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se atribua uma caixa no center of uma segunda caixa;
Etapas necessárias para que se centralize uma caixa em uma segunda caixa:
  Centralize a caixa no segunda caixa (horizontalmente).
  Centralize a caixa no segunda caixa (verticalmente).

Etapas necessárias para que se atribua uma caixa no center of a tela;
Etapas necessárias para que se centralize uma caixa sobre a tela:
  Centralize a caixa na caixa desta tela.

Etapas necessárias para que se atribua uma caixa para uma segunda caixa:
  Atribua a coordenada esquerda desta caixa à coordenada esquerda desta segunda caixa.
  Atribua a coordenada superior desta caixa à coordenada superior desta segunda caixa.
  Atribua a coordenada direita desta caixa à coordenada direita desta segunda caixa.
  Atribua a coordenada inferior desta caixa à coordenada inferior desta segunda caixa.

Etapas necessárias para que se atribua uma caixa sobre uma localização;
Etapas necessárias para que se centralize uma caixa sobre uma localização:
  Obtenha um difference between a localização e o center desta caixa.
  Arredonde a difference para o múltiplo imediato of o tpp.
  Mova a caixa usando a difference.

Etapas necessárias para que se atribua uma caixa uns twips por uns segunda twips no center of uma segunda caixa;
Etapas necessárias para que se centralize uma caixa uns twips por uns segunda twips em uma segunda caixa:
  Make a caixa os twips pelo segunda twips.
  Centralize a caixa no segunda caixa.

Etapas necessárias para que se atribua a linha de baixo dessa caixa para uma horizontal line:
    \ e "vertical" por left e right
  Atribua a coordenada esquerda desta caixa e a coordenada inferior desta caixa ao start desta horizontal line.
  Atribua a coordenada direita desta caixa e a coordenada inferior desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o base-center dessa caixa para uma localização:
    \ *** need these sem dashs too
  Atribua a coordenada X deste center desta caixa ao x desta localização.
  Atribua a coordenada inferior desta caixa ao y desta localização.

Etapas necessárias para que se atribua o center dessa caixa para uma localização:
  Atribua a coordenada esquerda desta caixa mais a coordenada direita desta caixa à coordenada x desta localização.
  Atribua a coordenada superior desta caixa mais a coordenada inferior desta caixa à coordenada y desta localização.
  Divida a localização por 2.

Etapas necessárias para que se atribua o center-base dessa caixa para uma localização:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização.

Etapas necessárias para que se atribua o center-top dessa caixa para uma localização:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização.
  Atribua a coordenada superior desta caixa à coordenada y desta localização.

Etapas necessárias para que se atribua a altura dessa caixa para uma altura:
  Atribua a coordenada inferior desta caixa ao altura.
  Subtraia a coordenada superior desta caixa desde o altura.
  Adicione o tpp para o altura.

Etapas necessárias para que se atribua a left line dessa caixa para um line:
  Atribua a coordenada esquerda desta caixa e a coordenada superior desta caixa ao start desta line.
  Atribua a coordenada esquerda desta caixa e a coordenada inferior desta caixa ao end desta line.

Etapas necessárias para que se atribua a canto inferior esquerdo dessa caixa para uma localização:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização.

Etapas necessárias para que se atribua o left-center dessa caixa para uma localização:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização.
  Atribua a coordenada Y deste center desta caixa à coordenada y desta localização.

Etapas necessárias para que se atribua o right line dessa caixa para uma line:
  Atribua a coordenada direita desta caixa e a coordenada superior desta caixa ao start desta line.
  Atribua a coordenada direita desta caixa e a coordenada inferior desta caixa ao end desta line.

Etapas necessárias para que se atribua o right-center dessa caixa para uma localização:
  Atribua a coordenada direita desta caixa à coordenada x desta localização.
  Atribua a coordenada Y deste center desta caixa à coordenada y desta localização.

Etapas necessárias para que se atribua o canto superior direito dessa caixa para uma localização:
  Atribua a coordenada direita desta caixa à coordenada x desta localização.
  Atribua a coordenada superior desta caixa à coordenada y desta localização.

Etapas necessárias para que se atribua a linha de cima dessa caixa para uma horizontal line:
  Atribua a coordenada esquerda desta caixa e a coordenada superior desta caixa ao start desta horizontal line.
  Atribua a coordenada direita desta caixa e a coordenada superior desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o topo-center dessa caixa para uma localização:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização.
  Atribua a coordenada superior desta caixa à coordenada y desta localização.

Etapas necessárias para que se atribua a largura dessa caixa para uma largura:
  Atribua a coordenada direita desta caixa ao largura.
  Subtraia a coordenada esquerda desta caixa desde o largura.
  Adicione o tpp para o largura.

Etapas necessárias para que se atribua o x-extent dessa caixa para uma largura:
  Atribua a coordenada direita desta caixa ao largura.
  Subtraia a coordenada esquerda desta caixa desde o largura.

Etapas necessárias para que se atribua o y-extent dessa caixa para uma altura:
  Atribua a coordenada inferior desta caixa ao altura.
  Subtraia a coordenada superior desta caixa desde o altura.

Etapas necessárias para que se atribua um pedaço e um número para um fração:
  Atribua o pedaço ao numerador desta fração.
  Atribua o número ao denominador desta fração.

Etapas necessárias para que se atribua um pedaço para um segundo pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $8A00. \ mov al,[eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a segunda byte
  Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um pedaço para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
  Intel $0FB603. \ movzx eax,byte ptr [ebx]

Etapas necessárias para que se atribua um pedaço para um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $0FB600. \ movzx eax,byte ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se atribua um pedaço para uma string:
  Atribua 1 a uma quantidade de caracteres.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres.
  Atribua o pedaço ao conteúdo deste first endereço de memória do pedaço desta string.
  Atribua o first endereço de memória do pedaço desta string ao last endereço de memória do pedaço desta string.

Etapas necessárias para que se atribua um pedaço para um word:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
  Intel $660FB600. \ movzx eax,byte ptr [eax]
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o word
  Intel $668903. \ mov [ebx],ah

Etapas necessárias para que se atribua o character depois de um finger para um character:
  Se o finger for inexistente, limpe o character; exit.
  Atribua o conteúdo deste finger ao character.

Etapas necessárias para que se atribua uma cor para uma segunda cor:
  Atribua a matiz desta cor à matiz desta segunda cor.
  Atribua a saturação desta cor à saturação desta segunda cor.
  Atribua a luminosidade desta cor à luminosidade desta segunda cor.

Etapas necessárias para que se atribua um date/time para uma segunda date/time:
  Atribua o year deste date/time ao year desta segunda date/time.
  Atribua o month deste date/time ao month desta segunda date/time.
  Atribua o week day deste date/time ao week day segunda date/time.
  Atribua o day deste date/time ao day desta segunda date/time.
  Atribua a hour deste date/time à hour desta segunda date/time.
  Atribua o minute deste date/time ao minute desta segunda date/time.
  Atribua o second deste date/time ao second desta segunda date/time.
  Atribua o millisecond deste date/time ao millisecond desta segunda date/time.

Etapas necessárias para que se atribua a string dessa date/time para uma string:
  Limpe a string.
  Posponha o year deste date/time para a string.
  Posponha "/" para a string.
  Zero fill o month deste date/time usando 2 e posponha it para a string.
  Posponha "/" para a string.
  Zero fill o day deste date/time usando 2 e posponha it para a string.
  Posponha " " para a string.
  Zero fill a hour deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o minute deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o second deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o millisecond deste date/time usando 3 e posponha it para a string.

Etapas necessárias para que se atribua eax para um pedaço:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua eax para um detector;
Etapas necessárias para que se atribua eax para um endereço de memória;
Etapas necessárias para que se atribua eax para um número:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
  Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se atribua eax para um word:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o word
  Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua uma elipse no middle of uma caixa;
Etapas necessárias para que se centralize uma elipse em uma caixa:
  Centralize a elipse na caixa (horizontalmente).
  Centralize a elipse na caixa (verticalmente).

Etapas necessárias para que se atribua um elipse para uma segunda elipse:
  Atribua a caixa desta elipse à caixa desta segunda elipse.

Etapas necessárias para que se atribua um elipse sobre uma localização;
Etapas necessárias para que se centralize um elipse sobre uma localização:
  Centralize a caixa desta elipse sobre a localização.

Etapas necessárias para que se atribua um finger sobre o first character of uma string:
  Atribua o first endereço de memória do pedaço desta string ao finger.

Etapas necessárias para que se atribua um detector para uma segundo detector;
Etapas necessárias para que se atribua um detector para um número;
Etapas necessárias para que se atribua um endereço de memória para um número;
Etapas necessárias para que se atribua um endereço de memória para um segundo endereço de memória;
Etapas necessárias para que se atribua um número para um detector;
Etapas necessárias para que se atribua um número para um endereço de memória;
Etapas necessárias para que se atribua um número para um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o 1º valor (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp=8 representa o 1º parâmetro da função. ebp+12 representa o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva o 2º valor (ebp+12) no registrador ebx
  Intel $8903. \ mov [ebx],eax -> salva eax em ebx

Etapas necessárias para que se atribua um detector para eax;
Etapas necessárias para que se atribua um endereço de memória para eax;
Etapas necessárias para que se atribua um número para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva o número (ebp+8) no registrador ebx
  Intel $8B03. \ mov eax,[ebx] -> salva ebx em eax

Etapas necessárias para que se atribua um detector para uma string;
Etapas necessárias para que se converta um detector para uma string:
  Se o detector estiver ativo, atribua "yes" à string; exit. \ no momento tem que ser inglês por conta das externalized reams
  Atribua "no" à string.

Etapas necessárias para que se atribua uma font para uma segunda font:
  Atribua o nome desta font ao nome desta segunda font.
  Atribua a altura desta font à altura desta segunda font.

Etapas necessárias para que se atribua a adjusted altura dessa font para uma altura:
  Atribua a altura desta font times 3/4 à altura.

Etapas necessárias para que se atribua uma fração para uma segunda fração:
  Atribua o numerador desta fração ao numerador desta segunda fração.
  Atribua o denominador desta fração ao denominador desta segunda fração.

Etapas necessárias para que se atribua uma fração para uma string;
Etapas necessárias para que se converta uma fração para uma string:
  Limpe a string.
  Isole a fração.
  Se a fração é negative, atribua "-" à string; de-sign a fração.
  Reduce a fração.
  Converta a fração para um mixed.
  Se o mixed for 0, posponha "0" para a string; exit.
  Se o whole número deste mixed não for 0, posponha o whole número deste mixed para a string.
  Se o fração deste mixed for 0, cancele.
  Se a string não estiver em branco, posponha o hífem para a string.
  Posponha o numerador deste mixed seguido de "/" junto com o denominador deste mixed para a string.

Etapas necessárias para que se atribua uma par de números fracionários para uma segundo par de números fracionários:
  Atribua a fração deste par de números fracionários à fração deste segundo par de números fracionários.
  Atribua a segunda fração deste par de números fracionários à segunda fração deste segundo par de números fracionários.

Etapas necessárias para que se atribua o absolute value dessa fração para uma segunda fração:
  Atribua a fração à segunda fração.
  De-sign a segunda fração.

Etapas necessárias para que se atribua o gprect desse gpimage para um gprect:
  Atribua 0 ao x deste gprect.
  Atribua 0 ao y deste gprect.
  Atribua a largura desta gpimage ao largura deste gprect.
  Atribua a altura desta gpimage à altura deste gprect.

Etapas necessárias para que se atribua a altura desse gpimage para uma altura:
  Se o gpimage for inexistente, atribua 0 ao altura; exit.
  Call "gdiplus.dll" "GdipGetImageHeight" com 
    O gpimage 
    e O endereçamento desta altura.

Etapas necessárias para que se atribua a largura desse gpimage para uma largura:
  Se o gpimage for inexistente, atribua 0 ao largura; exit.
  Call "gdiplus.dll" "GdipGetImageWidth" com 
    O gpimage 
    e O endereçamento desta largura.

Etapas necessárias para que se atribua um gprect para uma segunda gprect:
  Atribua o x deste gprect ao x desta segunda gprect.
  Atribua o y deste gprect ao y desta segunda gprect.
  Atribua o largura deste gprect ao largura desta segunda gprect.
  Atribua a altura deste gprect à altura desta segunda gprect.

Etapas necessárias para que se atribua um matiz e um saturação e um luminosidade para uma cor:
  Atribua o matiz à matiz desta cor.
  Se a matiz desta cor não for -1, limite a matiz desta cor para 0 e 3599. \ -1 é transparente
  Atribua o saturação à saturação desta cor.
  Limite a saturação desta cor para 0 e 1000.
  Atribua o luminosidade à luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se atribua a contagem desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha um bucket usando o catálogo.
  Se o bucket for inexistente, cancele.
  Adicione a contagem destes refers deste bucket para a contagem.
  Repita. [o código acima]

Etapas necessárias para que se atribua a used contagem de buckets desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, cancele.
    Se os refers deste bucket estiverem vazio, repita.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas necessárias para que se atribua uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior e um raio para uma caixa arredondada:
  Atribua a coordenada esquerda à coordenada esquerda desta caixa arredondada.
  Atribua a coordenada superior à coordenada superior desta caixa arredondada.
  Atribua a coordenada direita à coordenada direita desta caixa arredondada.
  Atribua a coordenada inferior à coordenada inferior desta caixa arredondada.
  Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se atribua uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior para uma caixa:
  Atribua a coordenada esquerda à coordenada esquerda desta caixa.
  Atribua a coordenada superior à coordenada superior desta caixa.
  Atribua a coordenada direita à coordenada direita desta caixa.
  Atribua a coordenada inferior à coordenada inferior desta caixa.

Etapas necessárias para que se atribua uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior para um elipse:
  Atribua a coordenada esquerda à coordenada esquerda desta elipse.
  Atribua a coordenada superior à coordenada superior desta elipse.
  Atribua a coordenada direita à coordenada direita desta elipse.
  Atribua a coordenada inferior à coordenada inferior desta elipse.

Etapas necessárias para que se atribua a coordenada esquerda of uma caixa para um vertical line;
Etapas necessárias para que se atribua a coordenada esquerda edge of uma caixa para um vertical line;
Etapas necessárias para que se atribua a coordenada esquerda side of uma caixa para um vertical line:
  Atribua o canto superior esquerdo desta caixa ao start desta vertical line.
  Atribua o canto inferior esquerdo desta caixa ao end desta vertical line.

Etapas necessárias para que se atribua um line no middle of uma caixa;
Etapas necessárias para que se centralize um line em uma caixa:
  Centralize o line na caixa (horizontalmente).
  Centralize o line na caixa (verticalmente).

Etapas necessárias para que se atribua um line para uma segunda line:
  Atribua o start desta line ao start desta segunda line.
  Atribua o end desta line ao end desta segunda line.

Etapas necessárias para que se atribua a base dessa line para uma coordenada:
  Atribua o y deste start desta line à coordenada.
  Se o y deste end desta line for maior do que o y deste start desta line, atribua o y deste end desta line à coordenada.

Etapas necessárias para que se atribua a caixa dessa line para uma caixa:
  Atribua o start desta line ao canto superior esquerdo desta caixa.
  Atribua o end desta line ao canto inferior direito desta caixa.
  Normalize a caixa.

Etapas necessárias para que se atribua o center dessa line para uma localização:
  Atribua a coordenada X desta start desta line mais a coordenada X deste end desta line à coordenada x desta localização.
  Atribua a coordenada Y desta start desta line mais a coordenada Y deste end desta line à coordenada y desta localização.
  Divida a localização por 2.

Etapas necessárias para que se atribua a coordenada esquerda dessa line para uma coordenada:
  Atribua a coordenada X desta start desta line à coordenada.
  Se a coordenada X deste end desta line for menor do que a coordenada X desta start desta line, atribua a coordenada X deste end desta line à coordenada.

Etapas necessárias para que se atribua o right dessa line para uma coordenada:
  Atribua a coordenada X desta start desta line à coordenada.
  Se a coordenada X deste end desta line for maior do que a coordenada X desta start desta line, atribua a coordenada X deste end desta line à coordenada.

Etapas necessárias para que se atribua o topo dessa line para uma coordenada:
  Atribua a coordenada Y desta start desta line à coordenada.
  Se a coordenada Y deste end desta line for menor do que a coordenada Y desta start desta line, atribua a coordenada Y deste end desta line à coordenada.

Etapas necessárias para que se atribua masking tape below um figura:
  Se a figura for inexistente, cancele.
  Se a contagem destes vértices desta figura for menor do que 2, cancele.
  Copie a figura para uma segunda figura.
  Atribua a coordenada inferior desta tela à  coordenada y desse localização.
  Atribua a coordenada X deste last desta figura à coordenada x desta localização.
  Posponha a localização para a segunda figura.
  Atribua a coordenada X deste first desta figura à coordenada x desta localização.
  Posponha a localização para a segunda figura.
  Posponha a localização deste first desta figura para a segunda figura.
  Cubra internamente a segunda figura.
  Destrua a segunda figura.

Etapas necessárias para que se atribua o middle of uma line sobre uma localização;
Etapas necessárias para que se centralize uma line sobre uma localização:
  Obtenha um difference between a localização e o center desta line.
  Arredonde a difference para o múltiplo imediato of o tpp.
  Mova a line usando a difference.

Etapas necessárias para que se atribua a localização deste mouse para uma localização:
  Call "user32.dll" "GetCursorPos" com 
    O endereçamento desta localização.
  Call "user32.dll" "ScreenToClient" com 
    A main window 
    e O endereçamento desta localização. \ caso a janela principal esteja em um segundo monitor.
  Call "gdi32.dll" "DPtoLP" com 
    O tela canvas 
    e O endereçamento desta localização 
    e 1.

Etapas necessárias para que se atribua um nome e uma altura para um font:
  Atribua o nome ao nome desta font.
  Atribua o altura à altura desta font.

Etapas necessárias para que se atribua um nome para uma font:
  Atribua o nome ao nome desta font.

Etapas necessárias para que se atribua um número e um segundo número para um par de números:
  Atribua o número ao número X deste par de números.
  Atribua o segundo número ao número Y deste par de números.

Etapas necessárias para que se atribua um número para um big-endian unsigned word:
  Atribua o número a um word.
  Atribua o word ao big-endian unsigned word.

Etapas necessárias para que se atribua um número para um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> atribui o número (ebp+8) ao registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp+8 representa o primeiro argumento da função (o número).
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> atribui o byte (ebp+12) ao registrador ebx
  Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um número para um fração:
  Atribua o número ao numerador desta fração.
  Atribua 1 ao denominador desta fração.

Etapas necessárias para que se atribua um número para um par de números:
  Atribua o número ao número X deste par de números.
  Atribua o número ao número Y deste par de números.

Etapas necessárias para que se atribua um número para uma string;
Etapas necessárias para que se converta um número para uma string:
  Limpe a string.
  Isole o número.
  De-sign o número.
  Percorra. [o código abaixo]
    Divida o número por 10 usando um quotient e um resto.
    Adicione 48 para o resto.
    Atribua o resto a um pedaço.
    Anteponha o pedaço para a string.
    Se o quotient for 0, pare.
    Atribua o quotient ao número.
  Repita. [o código acima]
  Se o original número for menor do que 0, anteponha o hífem para a string.

Etapas necessárias para que se atribua um número para um word:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> atribui o número (ebp+8) ao registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp+8 representa o primeiro argumento da função (o número).
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> atribui a word (ebp+12) ao registrador ebx
  Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua um número sobre o stack:
  Converta o número para um segmento inicial.
  Atribua o segmento inicial sobre o stack.

Etapas necessárias para que se atribua um número over um segundo número em uma fração;
Etapas necessárias para que se atribua um número e um segundo número para uma fração:
  Atribua o número ao numerador desta fração.
  Atribua o segundo número ao denominador desta fração.

Etapas necessárias para que se atribua o absolute value desse número para um segundo número:
  Atribua o número ao segundo número.
  De-sign o segundo número.

Etapas necessárias para que se atribua um outlinetextmetric para uma segunda outlinetextmetric:
  Copie pedaços desde o endereçamento deste outlinetextmetric para o endereçamento desta segunda outlinetextmetric pela magnitude deste outlinetextmetric.

Etapas necessárias para que se atribua um par de números para uma segunda par de números:
  Atribua o número X deste par de números ao número X desta segunda par de números.
  Atribua o número Y deste par de números ao número Y desta segunda par de números.

Etapas necessárias para que se atribua o absolute value desse par de números para uma segunda par de números:
  Atribua o par de números ao segunda par de números.
  De-sign a segunda par de números.

\ unclear why this does not get called properly when I replace hoja apaisada com caja ***

Etapas necessárias para que se atribua um imagem no middle of uma caixa;
Etapas necessárias para que se centralize um imagem em uma caixa:
  Se o imagem for inexistente, cancele.
  Centralize o imagem na caixa (horizontalmente).
  Centralize o imagem na caixa (verticalmente).

Etapas necessárias para que se atribua um imagem sobre uma localização;
Etapas necessárias para que se centralize um imagem sobre uma localização:
  Se o imagem for inexistente, cancele.
  Obtenha um difference between a localização e o center desta caixa desta imagem.
  Arredonde a difference para o múltiplo imediato of o tpp.
  Mova o imagem usando a difference.

Etapas necessárias para que se atribua um polígono no middle of uma caixa;
Etapas necessárias para que se centralize um polígono em uma caixa:
  Se o polígono for inexistente, cancele.
  Centralize o polígono na caixa (horizontalmente).
  Centralize o polígono na caixa (verticalmente).

Etapas necessárias para que se atribua um polígono no middle of o tela;
Etapas necessárias para que se centralize um polígono sobre o tela:
  Centralize o polígono na caixa desta tela.

Etapas necessárias para que se atribua um polígono sobre uma localização;
Etapas necessárias para que se centralize um polígono sobre uma localização:
  Se o polígono for inexistente, cancele.
  Obtenha um difference between a localização e o center desta caixa deste polígono.
  Arredonde a difference para o múltiplo imediato of o tpp.
  Mova o polígono usando a difference.

Etapas necessárias para que se atribua a caixa desse polígono para uma caixa:
  Se o polígono for inexistente, zero a caixa; exit.
  Se os vértices deste polígono estiverem vazio, zero a caixa; exit.
  Atribua o maior número e o maior número e o menor número e o menor número ao caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, pare.
    Se a coordenada X deste vértice for menor do que a coordenada esquerda desta caixa, atribua a coordenada X deste vértice à coordenada esquerda desta caixa.
    Se a coordenada Y deste vértice for menor do que a coordenada superior desta caixa, atribua a coordenada Y deste vértice à coordenada superior desta caixa.
    Se a coordenada X deste vértice for maior do que a coordenada direita desta caixa, atribua a coordenada X deste vértice à coordenada direita desta caixa.
    Se a coordenada Y deste vértice for maior do que a coordenada inferior desta caixa, atribua a coordenada Y deste vértice à coordenada inferior desta caixa.
  Repita. [o código acima]

Etapas necessárias para que se atribua o center desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o center desta caixa deste polígono à localização.

Etapas necessárias para que se atribua o center-base desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o center-base  desta caixa deste polígono à localização.

Etapas necessárias para que se atribua o center-top desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o center-top desta caixa deste polígono à localização.

Etapas necessárias para que se atribua a altura desse polígono para uma altura:
  Se o polígono for inexistente, limpe o altura; exit.
  Atribua a altura desta caixa deste polígono à altura.

Etapas necessárias para que se atribua o canto inferior esquerdo desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o canto inferior esquerdo desta caixa deste polígono à localização.

Etapas necessárias para que se atribua o left-center desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o left-center desta caixa deste polígono à localização.

Etapas necessárias para que se atribua o canto superior esquerdo desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o canto superior esquerdo desta caixa deste polígono à localização.

Etapas necessárias para que se atribua o canto inferior direito desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o canto inferior direito desta caixa deste polígono à localização.

Etapas necessárias para que se atribua o right-center desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o right-center desta caixa deste polígono à localização.

Etapas necessárias para que se atribua o canto superior direito desse polígono para uma localização:
  Se o polígono for inexistente, limpe a localização; exit.
  Atribua o canto superior direito desta caixa deste polígono à localização.

Etapas necessárias para que se atribua a largura desse polígono para uma largura:
  Se o polígono for inexistente, limpe o largura; exit.
  Atribua a largura desta caixa deste polígono à largura.

Etapas necessárias para que se atribua o x-extent desse polígono para uma largura:
  Se o polígono for inexistente, limpe o largura; exit.
  Atribua o x-extent desta caixa deste polígono ao largura.

Etapas necessárias para que se atribua o y-extent desse polígono para uma altura:
  Se o polígono for inexistente, limpe o altura; exit.
  Atribua o y-extent desta caixa deste polígono ao altura.

Etapas necessárias para que se atribua um percorredor para uma segundo percorredor:
  Copie pedaços desde o endereçamento deste percorredor para o endereçamento deste segundo percorredor pela magnitude deste percorredor.

Etapas necessárias para que se atribua o right of uma caixa para uma vertical line;
Etapas necessárias para que se atribua o right edge of uma caixa para uma vertical line;
Etapas necessárias para que se atribua o right side of uma caixa para uma vertical line:
  Atribua o canto superior direito desta caixa ao start desta vertical line.
  Atribua o canto inferior direito desta caixa ao end desta vertical line.

Etapas necessárias para que se atribua uma caixa arredondada para uma segunda caixa arredondada:
  Atribua a coordenada esquerda desta caixa arredondada à coordenada esquerda desta segunda caixa arredondada.
  Atribua a coordenada superior desta caixa arredondada à coordenada superior desta segunda caixa arredondada.
  Atribua a coordenada direita desta caixa arredondada à coordenada direita desta segunda caixa arredondada.
  Atribua a coordenada inferior desta caixa arredondada à coordenada inferior desta segunda caixa arredondada.
  Atribua o raio desta caixa arredondada ao raio desta segunda caixa arredondada.

Etapas necessárias para que se atribua o working string dessa row para um subtexto:
  Se a row for inexistente, limpe o subtexto; exit.
  Lance o subtexto sobre a string deste row.
  Subtraia 1 desde o last endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se atribua uma seleção para uma segunda seleção:
  Atribua o anchor desta seleção ao anchor desta segunda seleção.
  Atribua o caret desta seleção ao caret desta segunda seleção.

Etapas necessárias para que se atribua um sockaddr para uma segunda sockaddr:
  Copie pedaços desde o endereçamento deste sockaddr para o endereçamento desta segunda sockaddr pela magnitude deste sockaddr.

Etapas necessárias para que se atribua uma localização e uma segunda localização e um raio para uma caixa arredondada:
  Atribua a localização ao canto superior esquerdo desta caixa arredondada.
  Atribua a segunda localização à canto inferior direito desta caixa arredondada.
  Atribua o raio ao raio desta caixa arredondada.

Etapas necessárias para que se atribua uma localização e uma segunda localização para uma caixa:
  Atribua a localização ao canto superior esquerdo desta caixa.
  Atribua a segunda localização ao canto inferior direito desta caixa.

Etapas necessárias para que se atribua uma localização e uma segunda localização para uma elipse:
  Atribua a localização ao canto superior esquerdo desta elipse.
  Atribua a segunda localização ao canto inferior direito desta elipse.

Etapas necessárias para que se atribua uma localização e uma segunda localização para uma line:
  Atribua a localização ao start desta line.
  Atribua a segunda localização ao end desta line.

Etapas necessárias para que se atribua uma localização no middle of uma caixa;
Etapas necessárias para que se centralize uma localização em uma caixa:
  Centralize a localização na caixa (horizontalmente).
  Centralize a localização na caixa (verticalmente).

Etapas necessárias para que se atribua uma string para uma segunda string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Assign um endereço de memória usando a quantidade de caracteres armazenados.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o endereço de memória pelo quantidade de caracteres armazenados.
  Unassign o first endereço de memória do pedaço desta segunda string.
  Atribua o endereço de memória ao first endereço de memória do pedaço desta segunda string.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres armazenados menos 1 ao last endereço de memória do pedaço desta segunda string.

Etapas necessárias para que se atribua uma string para uma letra:
  Atribua o conteúdo deste first endereço de memória do pedaço desta string à letra.

Etapas necessárias para que se atribua uma string para um text:
  Se o text for inexistente, cancele.
  Destrua as rows deste text.
  Reset o origin of o text.
  Reset o caret of o text.
  Desvencilhe-se de o text.
  Isole a string.
  Posponha o return pedaço para a string.
  Converta a string para as rows deste text.
  Wrap o text.

Etapas necessárias para que se atribua uma string sobre o área de transferência do Windows:
  Call "user32.dll" "OpenClipboard" com 
    A main window.
  Call "user32.dll" "EmptyClipboard".
  Atribua a quantidade de caracteres desta string mais 1 a um número.
  Call "kernel32.dll" "GlobalAlloc" com 
  66 [GHND - 0x0042 - unifica GMEM_MOVEABLE e GMEM_ZEROINIT.] 
    e O número 
    devolvendo um número identificador.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador 
    devolvendo um endereço de memória.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o endereço de memória pelo quantidade de caracteres desta string.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "user32.dll" "SetClipboardData" com 
  1 [CF_TEXT] 
    e O número identificador.
  Call "user32.dll" "CloseClipboard".

Etapas necessárias para que se atribua a quantidade de caracteres dessa string para uma quantidade de caracteres:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva a string (ebp+8) no registrador eax
  \ Carrega default result
  Intel $B900000000. \ mov ecx,0 -> zera o registrador ecx
  \ if first for 0, store 0
  Intel $833B00. \ cmp [ebx],0 -> compara a string com 0. 
  Intel $0F8414000000. \ je store it
  \ if last for menor do que first, store 0
  Intel $8B5304. \ mov edx,[ebx+4] -> atribui o last endereço de memória ao registrador edx
  Intel $3B13. \ cmp edx,[ebx] -> compara edc com ebx
  Intel $0F8C09000000. \ jl store it
  \ calcula a  quantidade de caracteres
  Intel $8B8B04000000. \ mov ecx,[ebx+4] ->atribui o last endereço de memória ao registrador ecx
  Intel $2B0B. \ sub ecx,[ebx] \ subtrai o registrador ebx do ecx
  Intel $41. \ inc ecx \ adiciona 1 ao registrador ecx
  \ STORE IT:
  Intel $8B950C000000. \ mov edx,[ebp+12] \ atribui a quantidade de caracteres (ebp+12) ao registrador edx
  Intel $890A. \ mov [edx],ecx -> atribui o valor de ecx ao registrador edx

Etapas necessárias para que se atribua a largura dessa string para uma largura:
  \Consegui traduzir como:
  \Etapas necessárias para que se atribua uma largura desse string para uma segunda largura:
  Obtenha o largura usando a string e o memory canvas e a fonte padrão.

    \ \ leave out - causes Spanish string atribuas para resolva here instead of "Atribua uma string a uma segunda string"
Etapas necessárias para que se atribua um subtexto para um segundo subtexto:
  Copie pedaços desde o endereçamento deste subtexto para o endereçamento deste segundo subtexto pela magnitude deste subtexto.

Etapas necessárias para que se atribua o date/time do system para um date/time:
  Call "kernel32.dll" "GetLocalTime" com o endereçamento desse systemtime.
  Atribua o wyear deste systemtime ao year deste date/time.
  Atribua o wmonth deste systemtime ao month deste date/time.
  Atribua o wdayofweek deste systemtime ao week day deste date/time.
  Atribua o wday deste systemtime ao day deste date/time.
  Atribua o whour deste systemtime à hour deste date/time.
  Atribua o wminute deste systemtime ao minute deste date/time.
  Atribua o wsecond deste systemtime ao second deste date/time.
  Atribua os wmilliseconds deste systemtime ao millisecond deste date/time.

Etapas necessárias para que se atribua o last erro do system para um número:
  Call "kernel32.dll" "GetLastError" devolvendo o número.

Etapas necessárias para que se atribua o last winsock erro do system para um número:
  Call "ws2_32.dll" "WSAGetLastError" devolvendo o número.

Etapas necessárias para que se atribua a contagem de ticks do sistema para uns ticks:
    \ wraps cada 24.8 days ou so
  Call "kernel32.dll" "GetTickCount" devolvendo os ticks.
  Conjuncione logicamente os ticks com o maior número.

Etapas necessárias para que se atribua um terminal no middle of uma caixa;
Etapas necessárias para que se centralize um terminal em uma caixa:
  Isole a caixa.
  Indent a caixa 24 px.
  Atribua a caixa à caixa deste terminal.

Etapas necessárias para que se atribua um text no middle of uma caixa;
Etapas necessárias para que se centralize um text em uma caixa:
  Se o text for inexistente, cancele.
  Centralize o text na caixa (horizontalmente).
  Centralize o text na caixa (verticalmente).

Etapas necessárias para que se atribua um text sobre uma localização;
Etapas necessárias para que se centralize um text sobre uma localização:
  Se o text for inexistente, cancele.
  Obtenha um difference between a localização e o center desta caixa deste text.
  Arredonde a difference para o múltiplo imediato of o tpp.
  Mova o text usando a difference.

Etapas necessárias para que se atribua a first line desse text para uma string:
  Se o text for inexistente, limpe a string; exit.
  Atribua a string desta first row deste text à string.
  Remove o last pedaço desde a string.

Etapas necessárias para que se atribua a first non-em branco line desse text para uma string:
    \ *** new
  Limpe a string.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Atribua a string deste row à string.
    Remove o last pedaço desde a string. \ cr ou space (see text rules)
    Remove algum tipo de leading noise desde a string.
    Remove algum tipo de trailing noise desde a string.
  Se a string estiver em branco, repita.
  \Se a string não estiver em branco, pare.

Etapas necessárias para que se atribua a globalized origin desse text para uma localização:
  Se o text for inexistente, limpe a localização; exit.
  Atribua a origin deste text à localização.
  Globalize a localização usando o canto superior esquerdo deste text.

Etapas necessárias para que se atribua a malha desse text para um malha:
  Se o text for inexistente, limpe a malha; exit.
  Atribua a altura desta font deste text times 4 ao número X desta malha.
  Atribua a altura desta font deste text ao número Y desta malha.

Etapas necessárias para que se atribua a normalized seleção desse text para uma seleção:
  Se o text for inexistente, cancele.
  Atribua a seleção deste text à seleção.
  Normalize a seleção.

Etapas necessárias para que se atribua a contagem de linhas desse text para uma contagem:
  Se o text for inexistente, atribua 0 à contagem; exit.
  Se as rows deste text estiverem vazio, atribua 0 à contagem; exit.
  Atribua o número da linha deste last destas rows deste text à contagem.

Etapas necessárias para que se atribua a altura da linha desse text para uma altura:
  Se o text for inexistente, atribua 0 ao altura; exit.
  Atribua a altura desta font deste text ao altura.

Etapas necessárias para que se atribua a rows/box desse text para uma contagem:
  Se o text for inexistente, atribua 0 à contagem; exit.
  Atribua a altura desta caixa deste text dividido pela altura da linha deste text à contagem.

Etapas necessárias para que se atribua a quantidade de caracteres selecionados desse text para uma contagem:
  Atribua 0 à contagem.
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
  Se a row for inexistente, cancele.
  Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
  Adicione a quantidade de caracteres deste subtexto para a contagem.
  Repita. [o código acima]

Etapas necessárias para que se atribua a selecionado contagem de linhas desse text para uma contagem:
  Atribua 0 à contagem.
  Se o text for inexistente, cancele.
  Atribua a normalized seleção deste text a uma seleção.
  Se o anchor número da linha desta seleção é o número de linhas do cursor desta seleção, cancele.
  Atribua o número de linhas do cursor desta seleção à contagem.
  Subtraia o anchor número da linha desta seleção desde a contagem.
  Se o caret column# desta seleção não for 1, adicione 1 para a contagem.

Etapas necessárias para que se atribua o painel de informações string desse text para uma string:
  Se o text for inexistente, limpe a string; exit.
  Atribua a selecionado contagem de linhas deste text a uma contagem.
  Se a contagem não for 0, format a contagem e "linha selecionada" ou "linhas selecionadas" à string; exit.
  Atribua a quantidade de caracteres selecionados deste text a uma segunda contagem.
  Se a segunda contagem não for 0, format a segunda contagem e "pedaço" ou "pedaços" à string; exit.
  Converta o número de linhas do cursor deste text para a string.
  Posponha ":" para a string.
  Posponha o caret column# deste text para a string.

Etapas necessárias para que se atribua uma coisa at o end of uns coisas;
Etapas necessárias para que se posponha uma coisa para uns coisas:
  Se a coisa for inexistente, cancele.
  Atribua o last destas coisas ao previous desta coisa.
  Se as coisas não estiverem vazio, atribua a coisa ao next deste last destas coisas.
  Se as coisas estiverem vazio, atribua a coisa ao first destas coisas.
  Atribua a coisa ao last destas coisas.

Etapas necessárias para que se atribua umas coisas para umas segunda coisas:
  Atribua o first destas coisas ao first destas segunda coisas.
  Atribua o last destas coisas ao last destas segunda coisas.

Etapas necessárias para que se atribua a contagem dessas coisas  para uma contagem:
  Atribua 0 à contagem.
  Percorra. [o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a coisa for inexistente, cancele.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas necessárias para que se atribua um temporizador para uma string;
Etapas necessárias para que se converta um temporizador para uma string:
  Converta os ticks deste temporizador para a string.

Etapas necessárias para que se atribua a string desse temporizador para uma string:
  Converta os ticks deste temporizador para a string.

Etapas necessárias para que se atribua os ticks desse temporizador para uns ticks:
  Atribua os total ticks deste temporizador aos ticks.
  Se a contagem deste temporizador for 0, cancele.
  Atribua a contagem de ticks do sistema a uns segunda ticks. 
  Subtraia os start ticks deste temporizador desde os segunda ticks.
  Adicione os segunda ticks para os ticks.

Etapas necessárias para que se atribua um segmento inicial sobre o stack:
  Aloque memória por um stack entry.
  Atribua o segmento inicial à string desta stack entry.
  Anteponha o stack entry para o stack.

Etapas necessárias para que se atribua o topo of uma caixa para um horizontal line;
Etapas necessárias para que se atribua o topo edge of uma caixa para um horizontal line;
Etapas necessárias para que se atribua o topo side of uma caixa para um horizontal line:
  Atribua o canto superior esquerdo desta caixa ao start desta horizontal line.
  Atribua o canto superior direito desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o topo of uma caixa para um line:
  Make a line com o canto superior esquerdo desta caixa e o canto superior direito desta caixa.

Etapas necessárias para que se atribua um word para uma segunda word:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva a 1ª word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,[eax] -> salva o endereço da 1ª word no registrador ax
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva a 2ª word (ebp+12) no registrador ebx
  Intel $668903. \ mov [ebx],ax -> Atribui o endereço da 1ª word para a 2ª word

Etapas necessárias para que se atribua um word para um big-endian unsigned word:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva a word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,word ptr [eax]  -> ebp+8 é o 1º parâmetro da função. 
  Intel $86E0. \ xchg al,ah -> ebp+12 é o 2º parâmetro da função
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva a o big-endian unsigned word  (ebp+12) no registrador ebx
  Intel $668903. \ mov word ptr [ebx],ax

Etapas necessárias para que se atribua um word para um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva a word (ebp+8) no registrador eax
  Intel $668B00. \ mov ax,[eax] -> ebp+8 é o 1º parâmetro da função. ebp+12 é o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva o byte (ebp+12) no registrador ebx
  Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um word para eax:
  Intel $8B9D08000000. \ mov ebx,[ebp+8] -> salva a word (ebp+8) no registrador ebx
  Intel $0FBF03. \ movsx eax,word ptr [ebx]

Etapas necessárias para que se atribua um word para um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva a word (ebp+8) no registrador eax
  Intel $0FBF00. \ movsx eax,word ptr [eax] -> ebp+8 é o 1º parâmetro da função. ebp+12 é o 2º parâmetro
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> salva o número (ebp+12) no registrador ebx
  Intel $8903. \ mov [ebx],eax -> atribui a word ao número

Uma coordenada X é uma coordenada.
Uma coordenada Y é uma coordenada.

Etapas necessárias para que se atribua uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y para uma line:
  Atribua a coordenada X à coordenada x desta start desta line.
  Atribua a coordenada Y à coordenada y desta start desta line.
  Atribua a segunda coordenada X à coordenada x deste end desta line.
  Atribua a segunda coordenada Y à coordenada y deste end desta line.

Um query pedaço é um texto de consulta.

Um texto de consulta é uma string.

Etapas necessárias para que se quit;
Etapas necessárias para que se relinquish control:
  Desmanche a fila de eventos.
  Crie um event.
  Atribua "fechamento do programa" à categoria deste event.
  Enfileire o event.

Um quora é uma coisa com \ quora é abreviação de "question or answer"
  uma string e 
  uma cor. 

Etapas necessárias para que se quote uma string:
    \ inserts leading, trailing e nested double-quotes
  Atribua as aspas duplas a uma segunda string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a segunda string.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for as aspas duplas, posponha as aspas duplas para a segunda string.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Posponha as aspas duplas para a segunda string.
  Atribua a segunda string à string.

Um quotient é um número.

Um raio é uns twips.

Etapas necessárias para que se raise um número para um segundo número:
  Se o segundo número for 0, atribua 1 ao número; exit.
  Se o segundo número for menor do que 0, atribua 0 ao número; exit. \ deveria ser 1/the raised result, but always comes out 0 com números
  Atribua 1 a um result número.
  Percorra. [o código abaixo]
    Se um contador é past o segundo número, pare.
    Multiplique o result pelo número.
  Repita. [o código acima]
  Atribua o result ao número.

Um random número é um número.

Um ratio é um fração.

Um par de números racionais é uma par de números fracionários.

Etapas necessárias para que se read o Bíblia:
  Se o Bíblia não for inexistente, cancele.
  Extraia um endereço da pasta desde o endereço completo deste module.
  Percorra. [o código abaixo]
    Se o endereço da pasta estiver em branco, cancele.
    Atribua o endereço da pasta seguido de "Bíblia.txt" a um endereço completo.
    Se o endereço completo estiver no sistema de arquivos, read o Bíblia usando o endereço completo; exit.
    Extraia o endereço da pasta desde o endereço da pasta.
  Repita. [o código acima]

Etapas necessárias para que se read a Bíblia usando um endereço completo:
  Se o Bíblia não for inexistente, cancele.
  Read o endereço completo a um trecho.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Aloque memória para o Bíblia.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Se o segmento final deste percorredor estiver em branco, cancele.
    Aloque memória por um verse. Posponha o verse para os verses desta Bíblia.
    Mova o percorredor (text file rules).
    Atribua o segmento inicial deste percorredor à string deste verse.
    Remove algum tipo de leading noise desde a string deste verse.
    Remove algum tipo de trailing noise desde a string deste verse.
  Repita. [o código acima]

Etapas necessárias para que se read um pedaço desde um console:
  Read uma string desde o console.
  Se a string estiver em branco, atribua o null pedaço ao pedaço; exit.
  Atribua o conteúdo deste first endereço de memória do pedaço desta string ao pedaço.

Etapas necessárias para que se read um console para uma string:
  Se o console for inexistente, limpe a string; exit.
  Desmanche all events.
  Limpe o reply deste console.
  Mostre o console.
  Execute events usando o console.
  Atribua o reply deste console à string.
  Desmanche all events.
  Atualize o cursor.

Etapas necessárias para que se read um file para um trecho:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "GetFileSize" com 
    O file 
    e nil 
    devolvendo um size. \o valor de retorno é uma double word de ordem inferior do tamanho do arquivo
  Reassign o first endereço de memória do pedaço deste trecho usando o size.
  Atribua o first endereço de memória do pedaço deste trecho mais o size menos 1 ao last endereço de memória do pedaço deste trecho.
  Call "kernel32.dll" "ReadFile" com 
    O file 
    e O first endereço de memória do pedaço deste trecho 
    e O size 
    e O endereçamento desse número 
    e 0 
    devolvendo um result número.
  Se o result número for 0, atribua "Ocorreu um erro na hora de tentar ler o arquivo." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se read um detector desde um console:
  Read uma string desde o console.
  Converta a string para o detector.

Etapas necessárias para que se read uma fração desde um console:
  Read uma string desde o console.
  Converta a string para a fração.

Etapas necessárias para que se read um número desde um console:
  Read uma string desde o console.
  Converta a string para o número.

Etapas necessárias para que se carregue um endereço completo para um trecho;
Etapas necessárias para que se read um endereço completo para um trecho:
  Limpe o erro do fluxo de entrada/saída.
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Se o endereço completo não estiver no sistema de arquivos, atribua "O Arquivo: '" junto com o endereço completo seguido de "' não existe." ao erro do fluxo de entrada/saída; exit.
  \ abra o endereço completo para read-write mode.
  Call "kernel32.dll" "CreateFileA" com 
    O first deste endereço completo 
    e -2147483648 [GENERIC_READ] 
    e 3 [FILE_SHARE_READ+FILE_SHARE_WRITE] 
    e 0 
    e 3 [OPEN_EXISTING] 
    e 0 
    e 0 
    devolvendo um número identificador.
  Se o número identificador for -1 [INVALID_HANDLE_VALUE], atribua "Ocorreu um erro ao tentar abrir o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.
  Call "kernel32.dll" "GetFileSize" com 
    O número identificador 
    e nil 
    devolvendo um size.
  Reassign o first endereço de memória do pedaço deste trecho usando o size.
  Atribua o first endereço de memória do pedaço deste trecho mais o size menos 1 ao last endereço de memória do pedaço deste trecho.
  Call "kernel32.dll" "ReadFile" com 
    O número identificador 
    e O first endereço de memória do pedaço deste trecho 
    e O size 
    e O endereçamento desse número 
    e 0 
    devolvendo o número.
  Call "kernel32.dll" "CloseHandle" com o número identificador.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro na hora de tentar ler o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se carregue um endereço completo para um imagem:

Etapas necessárias para que se read um endereço completo para um imagem:
  Read o endereço completo a um trecho.
  Se o erro do fluxo de entrada/saída não estiver em branco, esvazie o imagem; exit.
  Crie a imagem usando o trecho.

Etapas necessárias para que se read uma reply desde um terminal:
  Se o terminal for inexistente, limpe o reply; exit.
  Desmanche all events.
  Limpe o reply deste terminal.
  Adicione um quora para o terminal.
  Atribua "> " à string deste quora.
  Atribua a input cor deste terminal à cor deste quora.
  Mostre o terminal.
  Execute events usando o terminal.
    \ mostre o terminal.
  Atribua o reply deste terminal ao reply.
  Remove algum tipo de leading noise desde o reply.
  Remove algum tipo de trailing noise desde o reply.
  Desmanche all events.
    \ questionable below
  Crie um event.
  Atribua "clique" à categoria deste event.
    \Atribua "clic izquierdo" à categoria deste event.
  Atribua a localização deste mouse à localização deste event.
  Enfileire o event.
  Atualize o cursor.

Etapas necessárias para que se read uma response string desde um winhttp request:
  Se o winhttp request for inexistente, cancele.
  Limpe a response string.
  Atribua 8 kilobytes a um trecho size.
  Percorra. [o código abaixo]
    Atribua 0 a um size.
    Call "winhttp.dll" "WinHttpqueryDataAvailable" com 
      O request número identificador deste winhttp request 
      e O endereçamento deste size 
      devolvendo um result número.
    Se o result número for 0, atribua "Erro. Não foi possível consultar os dados disponíveis." ao erro do fluxo de entrada/saída; limpe a response; break.
    Atribua a quantidade de caracteres desta response a uma quantidade de caracteres armazenados.
    Reassign o first desta response string usando a quantidade de caracteres armazenados mais o trecho size.
    Atribua o first desta response string mais a quantidade de caracteres armazenados a um endereço de memória.
    Call "winhttp.dll" "WinHttpReadData" com 
      O request número identificador deste winhttp request 
      e O endereço de memória 
      e O trecho size 
      e O endereçamento dessa contagem 
      devolvendo o result número.
    Se o result número for 0, atribua "Ocorreu um erro na hora de ler os dados." ao erro do fluxo de entrada/saída; limpe o response; break.
    Atribua o endereço de memória mais a contagem menos 1 ao last desta response string.
    Se a contagem for 0, pare.
  Repita. [o código acima]

Etapas necessárias para que se read stdin para um trecho:
  Limpe o erro do fluxo de entrada/saída.
  Limpe o trecho.
  Encontre uma string usando o environment variáveis e "CONTENT_LENGTH".
  Se a string estiver em branco, atribua "Ocorreu um erro na hora de obter o conteúdo de comprimento CONTENT_LENGTH." ao erro do fluxo de entrada/saída; exit.
  Converta a string a uma quantidade de caracteres.
  Se a quantidade de caracteres for 0, cancele.
  Reassign o first endereço de memória do pedaço deste trecho usando a quantidade de caracteres.
  Call "kernel32.dll" "ReadFile" com 
    O stdin handle 
    e O first endereço de memória do pedaço deste trecho 
    e A quantidade de caracteres 
    e O endereçamento desse número 
    e nil.
  Se o número não for a quantidade de caracteres, atribua "Erro ao ler dados do fluxo de entrada padrão stdin." ao erro do fluxo de entrada/saída; limpe o trecho; exit.
  Atribua o first endereço de memória do pedaço deste trecho mais a quantidade de caracteres menos 1 ao last endereço de memória do pedaço deste trecho.

Etapas necessárias para que se read uma string desde um console:
  Read o console à string.

Etapas necessárias para que se read um URL para um trecho:
    \ prepare
  Limpe o trecho.
  Limpe o erro do fluxo de entrada/saída.
    \ internet abra
  Call "wininet.dll" "InternetOpenA" com 
    O first deste nome deste module 
    e 0 [INTERNET_OPEN_TYPE_PRECONFIG] 
    e nil 
    e nil 
    devolvendo um internet número identificador.
  Se o internet número identificador for 0, atribua "Erro. Não foi possível se conectar à internet. Verifique sua conexão" ao erro do fluxo de entrada/saída; exit.
    \ internet abra URL
  Isole a URL.
  Modifique através do caractere NUL a URL.
  Call "wininet.dll" "InternetOpenUrlA" com 
    O internet número identificador 
    e O first desta URL 
    e nil 
    e 0 
    e 0 
    e 0 
    devolvendo um URL número identificador.
  Se o URL número identificador for 0, atribua "Erro. Não foi possível acessar a URL: " junto com o URL seguido de "." ao erro do fluxo de entrada/saída; call "wininet.dll" "InternetCloseHandle" com o internet número identificador; exit.
    \ read o file
  Atribua 64 kilobytes a um trecho size.
  Percorra. [o código abaixo]
    Atribua a quantidade de caracteres deste trecho a uma quantidade de caracteres armazenados.
    Reassign o first endereço de memória do pedaço deste trecho usando a quantidade de caracteres armazenados mais o trecho size.
    Atribua o first endereço de memória do pedaço deste trecho mais a quantidade de caracteres armazenados a um endereço de memória.
    Call "wininet.dll" "InternetReadFile" com 
      O URL número identificador 
      e O endereço de memória 
      e O trecho size 
      e O endereçamento dessa contagem 
      devolvendo um result número.
    Se o result número for 0, atribua "Ocorreu um erro na hora de ler a URL: " junto com o URL seguido de "." ao erro do fluxo de entrada/saída; break.
    Atribua o endereço de memória mais a contagem menos 1 ao last endereço de memória do pedaço deste trecho.
    Se a contagem for 0, pare.
  Repita. [o código acima]
    \ clean para cima
  Call "wininet.dll" "InternetCloseHandle" com 
    O URL número identificador.
  Call "wininet.dll" "InternetCloseHandle" com 
    O internet número identificador.

Etapas necessárias para que se reassign um endereço de memória usando um quantidade de pedaços:
  Se o endereço de memória for inexistente, assign o endereço de memória usando o quantidade de pedaços; exit.
  Se o quantidade de pedaços for 0, unassign o endereço de memória; exit.
  Isole o quantidade de pedaços.
  Arredonde o quantidade de pedaços para cima para o nearest power of two.
  Call "kernel32.dll" "HeapReAlloc" com 
    O endereço heap 
    e 8 [HEAP_ZERO_MEMORY] 
    e O endereço de memória 
    e A quantidade de pedaços 
    devolvendo o endereço de memória.

Etapas necessárias para que se receive um trecho desde um socket:
  Limpe o erro do fluxo de entrada/saída.
  Limpe o trecho.
  Atribua 8 kilobytes a um trecho size.
  Percorra. [o código abaixo]
    Atribua 0 a um size.
    Atribua a quantidade de caracteres deste trecho a uma quantidade de caracteres armazenados.
    Reassign o first endereço de memória do pedaço deste trecho usando a quantidade de caracteres armazenados mais o trecho size.
    Atribua o first endereço de memória do pedaço deste trecho mais a quantidade de caracteres armazenados a um endereço de memória.
    Call "ws2_32.dll" "recv" com
      O socket 
      e O endereço de memória 
      e O trecho size 
      e 0 
      devolvendo uma contagem.
    Se a contagem não for -1 [SOCKET_ERROR], atribua o endereço de memória mais a contagem menos 1 ao last endereço de memória do pedaço deste trecho; exit.
    Se o last winsock erro do system não for 10040 [WSAMSGSIZE], atribua "Ocorreu um erro no recebimento dos dados." ao erro do fluxo de entrada/saída; limpe o trecho; exit.
    \Se o last winsock erro desse system não for 10040 [WSAMSGSIZE], atribua "Ocorreu um erro no recebimento dos dados." ao erro do fluxo de entrada/saída; limpe o trecho; exit.
    Atribua o endereço de memória mais a contagem menos 1 ao last endereço de memória do pedaço deste trecho.
  Repita. [o código acima]

Etapas necessárias para que se receive o response desde um winhttp request:
  Se o winhttp request for inexistente, cancele.
  Call "winhttp.dll" "WinHttpReceiveResponse" com
    A request número identificador deste winhttp request
    e 0
    devolvendo um result número.
  Se o result número for 0, atribua "A solicitação não pode ser enviada." ao erro do fluxo de entrada/saída; exit.

Um recipient é uma string.

\formas geométricas
Um retângulo é um figura.
Um skinny retângulo é um retângulo.
Um diamond é um figura.
Uma desert landscape é uma coisa.
Um octagon é um figura.
Um arco é um figura.
Um circle é um figura.
Uma fractal forest é uma coisa.
Uma joke é uma coisa.
Um triangle é um figura.
Um heptagon é um figura. \ 7 lados
Um nonagon é um figura. \ 9 lados
Um decagon é um figura. \ 10 lados
Um hexagon é um figura.
Um koch curve é um figura.
Uma twelve-sided figura é um figura.
Um half circle é um figura.
Uma half circle flower é um figura.
Um quarter circle é um figura.
Uma spiral é um figura.
Uma leaf é um figura.
Uma half leaf é um figura.
Uma five pointed star é um figura.
Um six pointed star é um figura.
Um left crescent é um figura.
Um right crescent é um figura.
Um pinceltagon é um figura.
Um solid é um figura.
Uma star é uma coisa.
Um cube é um figura.
Uma yew tree é um figura.
Uma tree é um figura.

Etapas necessárias para que se reduce um fração:
  Obtenha um máximo divisor comum usando o numerador desta fração e o denominador desta fração.
  Divida o numerador desta fração pelo máximo divisor comum.
  Divida o denominador desta fração pelo máximo divisor comum.

An refer é uma coisa com 
  Uma string e 
  Um endereço de memória (reference).

Etapas necessárias para que se atualize o cursor:
  Crie um event.
  Atribua "mostrar seta" à categoria deste event.
  \Atribua "cursor" à categoria deste event.
  Se a tecla Alt estiver sendo pressionada, acione o detector de tecla alt deste event.
  Se a tecla Ctrl estiver sendo pressionada, acione o detector de tecla ctrl deste event.
  Se a tecla Shift estiver sendo pressionada, acione o detector de tecla Shift deste event.
  Atribua a localização deste mouse à localização deste event.
  Enfileire o event.

Etapas necessárias para que se atualize o tela usando uma caixa:
  Call "gdi32.dll" "BitBlt" com 
    O tela canvas 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A largura desta caixa 
    e A altura desta caixa 
    e O quadro atual 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e 13369376 [SRCCOPY].

Um resto é um número.

Etapas necessárias para que se relembre um text:
  Se o text for inexistente, cancele.
  Destrua os redos deste text.
  Copie o text a uma segunda text.
  Redimensione proporcionalmente a segunda text para 1/1.
  Posponha a segunda text para os undos deste text.
  Limite os undos deste text para o max text undos.
  Ligue o detector de alteração deste text.

Etapas necessárias para que se relembre um text com um operação:
  Se o text for inexistente, cancele.
  Se o última operação deste text for a operação, acione o detector de alteração deste text; exit.
  Relembre o text.
  Atribua o operação à última operação deste text.

Etapas necessárias para que se relembre where we are:
  Save o context.

Etapas necessárias para que se remove algum tipo de pedaços selecionados em um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Atribua a seleção deste text a uma seleção.
  Normalize a seleção.
  Obtenha uma row usando o anchor número da linha desta seleção e o text.
  Lance um subtexto sobre a string deste row.
  Atribua o first endereço de memória do pedaço deste subtexto mais o anchor column# desta seleção menos 2 ao last endereço de memória do pedaço deste subtexto.
  Obtenha uma segunda row usando o número de linhas do cursor desta seleção e o text.
  Lance um segundo subtexto sobre a string desta segunda row.
  Atribua o first endereço de memória do pedaço deste segundo subtexto mais o caret column# desta seleção menos 1 ao first endereço de memória do pedaço deste segundo subtexto.
  Atribua o subtexto junto com o segundo subtexto à string desta row.
  Remove as rows of o text between o next desta row e a segunda row.
  Atribua o anchor desta seleção ao caret deste text.
  Desvencilhe-se de o text.

Etapas necessárias para que se remove algum tipo de trailing barra invertida desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço desta string não for a barra invertida, cancele.
  Remove o last pedaço desde a string.

Etapas necessárias para que se remove algum tipo de trailing linefeed pedaço desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço desta string não for o linefeed pedaço, cancele.
  Remove o last pedaço desde a string.

Etapas necessárias para que se remove algum tipo de trailing return pedaço desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço desta string não for o return pedaço, cancele.
  Remove o last pedaço desde a string.

Etapas necessárias para que se remova pedaços de uma string usando um subtexto:
  Se a string estiver em branco, cancele.
  Se o subtexto estiver em branco, cancele.
  Atribua o last endereço de memória do pedaço desta string menos o last endereço de memória do pedaço deste subtexto a uma quantidade de caracteres.
  Atribua o last endereço de memória do pedaço deste subtexto mais 1 a um endereço de memória.
  Copie pedaços desde o endereço de memória para o first endereço de memória do pedaço deste subtexto pelo quantidade de caracteres.
  Atribua a quantidade de caracteres desta string menos a quantidade de caracteres deste subtexto a um new quantidade de caracteres.
  Reassign o first endereço de memória do pedaço desta string usando o new quantidade de caracteres.
  Atribua o first endereço de memória do pedaço desta string mais o new quantidade de caracteres menos 1 ao last endereço de memória do pedaço desta string.

Etapas necessárias para que se remova pedaços de um text (backspace over um return):
  Se o text for inexistente, cancele.
  Se o número de linhas do cursor deste text for 1, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text menos 1 e o text.
  Atribua a quantidade de caracteres desta string desta row e o número de linhas do cursor deste text menos 1 ao caret deste text.
  Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (backspace com jump):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
  Se o caret column# deste text for 1, remova pedaços de o text (backspace over um return); exit.
  Jump o caret left no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (backspace):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
  Se o caret column# deste text for 1, remova pedaços de o text (backspace over um return); exit.
  Mova o caret left no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (forward delete um return):
  Se o text for inexistente, cancele.
  Se o número de linhas do cursor deste text for a contagem de linhas deste text, cancele.
  Atribua 1 e o número de linhas do cursor deste text mais 1 ao caret deste text.
  Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (forward delete com jump):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text é a quantidade de caracteres desta string desta row, remova pedaços de o text (forward delete um return); exit.
  Jump o caret right no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remova pedaços de um text (forward delete):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text é a quantidade de caracteres desta string desta row, remova pedaços de o text (forward delete um return); exit.
  Mova o caret right no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas necessárias para que se remove cada pedaço em um text:
  Se o text for inexistente, cancele.
  Atribua "" ao text.

Etapas necessárias para que se remove o first pedaço desde uma string:
  Lance um subtexto sobre o first pedaço of a string.
  Remova pedaços de a string usando o subtexto.

   
Etapas necessárias para que se remove o last pedaço desde uma string:
  Lance um subtexto sobre o last pedaço of a string.
  Remova pedaços de a string usando o subtexto.

Etapas necessárias para que se remove os last dois pedaços desde uma string:
  Remove trailing pedaços desde a string usando 2.

Etapas necessárias para que se remove leading pedaços desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; exit.
  Lance um subtexto sobre o first pedaço of a string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a contagem menos 1 ao last endereço de memória do pedaço deste subtexto.
  Remova pedaços de a string usando o subtexto.

Etapas necessárias para que se remove leading noise desde uma string;
Etapas necessárias para que se remove algum tipo de leading noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço desta string não for irrelevante, cancele.
  Remove o first pedaço desde a string.
  Repita. [o código acima]

Etapas necessárias para que se remove a rows of um text between uma row e uma segunda row:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Se a segunda row for inexistente, cancele.
  Se o número da linha desta row for maior do que o número da linha desta segunda row, cancele.
  Isole a row.
  Atribua o next desta segunda row a uma stop row.
  Percorra. [o código abaixo]
    Se a row for a stop row, pare.
    Atribua o next desta row a uma next row.
    Remove a row desde as rows deste text.
    Destrua a row.
    Atribua o next row à row.
  Repita. [o código acima]
  Renumber as rows deste text.

Etapas necessárias para que se remove uma coisa desde uns coisas:
  Se a coisa for inexistente, cancele.
  Se a coisa for o first destas coisas, atribua o next desta coisa ao first destas coisas.
  Se a coisa for o last destas coisas, atribua o previous desta coisa ao last destas coisas.
  Se o next desta coisa não for inexistente, atribua o previous desta coisa ao previous deste next desta coisa.
  Se o previous desta coisa não for inexistente, atribua o next desta coisa ao next deste previous desta coisa.
  Esvazie o next desta coisa.
  Esvazie o previous desta coisa.

Etapas necessárias para que se remove trailing pedaços desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; exit.
  Lance um subtexto sobre o last pedaço of a string.
  Atribua o last endereço de memória do pedaço deste subtexto menos a contagem mais 1 ao first endereço de memória do pedaço deste subtexto.
  Remova pedaços de a string usando o subtexto.

Etapas necessárias para que se remove trailing noise desde uma string;
Etapas necessárias para que se remove algum tipo de trailing noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço desta string não for irrelevante, cancele.
  Remove o last pedaço desde a string.
  Repita. [o código acima]

Etapas necessárias para que se rename um endereço completo para um segundo endereço completo no sistema de arquivos:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Isole o segundo endereço completo.
  Remove algum tipo de trailing barra invertida desde o segundo endereço completo.
  Modifique através do caractere NUL o segundo endereço completo.
  Call "kernel32.dll" "MoveFileA" com 
    O first deste endereço completo 
    e O first deste segundo endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro ao renomear o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se renumber uns rows:
  Obtenha uma row desde a rows.
  Se a row for inexistente, cancele.
  Adicione 1 para um número da linha.
  Atribua o número da linha ao número da linha desta row.
  Repita. [o código acima]

Etapas necessárias para que se replace um pedaço com um segundo pedaço em uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o pedaço, adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Atribua o segundo pedaço ao conteúdo deste first endereço de memória do pedaço deste subtexto.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

A reply é uma reply.

Uma reply é uma string.

Etapas necessárias para que se reenfileire um event:
  Copie o event a uma segundo event.
  Enfileire a segundo event.

Etapas necessárias para que se reset o alphabet:
  Atribua o 'A' maiúsculo ao next letra.

Etapas necessárias para que se reset o caret of um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao caret deste text.

Etapas necessárias para que se reset o context:
  Restore o context.
  Save o context.

Etapas necessárias para que se reset uma contagem:
  Atribua 0 à contagem.

Etapas necessárias para que se reset o drawing origin:
  Defina o drawing origin para o zero localização.

Etapas necessárias para que se reset um detector:
  Desative o detector.

Etapas necessárias para que se reset o origin of um text:
  Se o text for inexistente, cancele.
  Atribua a margin deste text à coordenada x deste text.
  Atribua 0 à coordenada y deste text.

Etapas necessárias para que se reset um endereço de memória;
Etapas necessárias para que se reset um endereço de memória pelo next time around;
Etapas necessárias para que se esvazie um endereço de memória:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o endereço de memória (ebp+8) no registrador eax
  Intel $C70000000000. \ mov [eax],0 -> zera o registrador eax

Etapas necessárias para que se reset o rainbow cors:
  Atribua 0 ao número atual da cor do arco-íris.

Etapas necessárias para que se reset um temporizador:
  Atribua 0 à contagem deste temporizador.
  Atribua 0 aos start ticks deste temporizador.
  Atribua 0 aos total ticks deste temporizador.

Etapas necessárias para que se redimensione uma caixa usando um par de números racionais;
Etapas necessárias para que se redimensione uma caixa usando uma par de números fracionários:
  Atribua o x-extent desta caixa a um largura.
  Atribua o y-extent desta caixa a uma altura.
  Redimensione proporcionalmente o largura usando a fração deste par de números fracionários.
  Redimensione proporcionalmente o altura usando a segunda fração deste par de números fracionários.
  Atribua a coordenada esquerda desta caixa mais o largura à coordenada direita desta caixa.
  Atribua a coordenada superior desta caixa mais o altura à coordenada inferior desta caixa.

Etapas necessárias para que se redimensione uma caixa usando um twip par de números:
  Adicione o número X deste twip par de números para a coordenada direita desta caixa.
  Adicione o número Y deste twip par de números para a coordenada inferior desta caixa.

Etapas necessárias para que se redimensione um elipse usando um par de números racionais;
Etapas necessárias para que se redimensione um elipse usando uma par de números fracionários:
  Redimensione a caixa desta elipse usando o par de números fracionários.

Etapas necessárias para que se redimensione um elipse usando um twip par de números:
  Redimensione a caixa desta elipse usando o twip par de números.

Etapas necessárias para que se redimensione um line usando um par de números racionais;
Etapas necessárias para que se redimensione um line usando uma par de números fracionários:
  Atribua a caixa desta line a uma caixa.
  Subtraia o canto superior esquerdo desta caixa desde o start desta line.
  Redimensione proporcionalmente o start desta line usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para o start desta line.
  Subtraia o canto superior esquerdo desta caixa desde o end desta line.
  Redimensione proporcionalmente o end desta line usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para o end desta line.

Etapas necessárias para que se redimensione um line usando um twip par de números:
  Atribua a caixa desta line a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Make uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione o line usando o par de números fracionários.

Etapas necessárias para que se redimensione um imagem para um largura por uma altura:
  Se o imagem for inexistente, cancele.
  Atribua o largura dividido pelo tpp a um pixel largura.
  Atribua o altura dividido pelo tpp a um pixel altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
    A pixel largura 
    e A pixel altura 
    e 0 
    e 137224 [pixelformat24bpprgb] 
    e 0 
    e O endereçamento desse gpbitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
    O gpbitmap 
    e O endereçamento desse gpgraphic.
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com
   O gpgraphic 
   e O gpbitmap desta imagem
   e 0 
   e 0 
   e A pixel largura 
   e A pixel altura
   e 0 
   e 0 
   e A largura deste gpbitmap desta imagem menos 1 
   e A altura deste gpbitmap desta imagem menos 1
   e 2 [unitpixel] 
   e nil 
   e nil 
   e 0.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
   O gpgraphic.
  Destrua o gpbitmap desta imagem.
  Atribua o gpbitmap ao gpbitmap desta imagem.
  Ajuste o imagem (extract caixas desde gpbitmap).
  Limpe os data desta imagem.

Etapas necessárias para que se redimensione um polígono usando um par de números racionais;
Etapas necessárias para que se redimensione um polígono usando uma par de números fracionários:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia o canto superior esquerdo desta caixa desde a localização deste vértice.
    Redimensione proporcionalmente a localização deste vértice usando o par de números fracionários.
    Adicione o canto superior esquerdo desta caixa para a localização deste vértice.
  Repita. [o código acima]

Etapas necessárias para que se redimensione um polígono usando um twip par de números:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Make uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione o polígono usando o par de números fracionários.

Etapas necessárias para que se redimensione um text usando um par de números racionais;
Etapas necessárias para que se redimensione um text usando uma par de números fracionários:
  Se o text for inexistente, cancele.
  Redimensione a caixa deste text usando o par de números fracionários.
  Wrap o text.

Etapas necessárias para que se redimensione um text usando um twip par de números:
  Se o text for inexistente, cancele.
  Redimensione a caixa deste text usando o twip par de números.
  Wrap o text.

Etapas necessárias para que se restart um temporizador:
  Adicione 1 para a contagem deste temporizador.
  Se a contagem deste temporizador não for 1, cancele.
  Atribua a contagem de ticks do sistema aos start ticks deste temporizador. \ a tick contagem deste system

Etapas necessárias para que se restore um canvas:
  Call "gdi32.dll" "RestoreDC" com 
    O canvas [HDC]
    e -1. \ nSavedDC - O estado salvo a ser restaurado. 
    \Se este parâmetro for positivo, ele representa uma instância específica do estado a ser restaurado. 
    \Se este parâmetro for negativo, ele representa uma instância relativa ao estado atual. 
    \Nesse caso, o valor -1 restaura o estado salvo mais recentemente.

Etapas necessárias para que se restore um context:
  Obtenha um saved context desde o context stack.
  Se o saved context for inexistente, cancele.
  Atribua a localização deste saved context à localização deste context.
  Atribua a orientação deste saved context à orientação deste context.
  Atribua a tamanho da letra deste saved context à tamanho da letra deste context.
  Atribua a cor deste saved context à cor deste context.
  Atribua o número deste saved context ao número deste context.
  Remove o saved context desde o context stack.
  Destrua o saved context.

Etapas necessárias para que se restore uma window:
  Call "user32.dll" "ShowWindow" com 
    A window 
    e 9 [SW_RESTORE].

Etapas necessárias para que se reverse algum tipo de rows selecionadas of um text:
  Se o text for inexistente, cancele.
  Split a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
  Reverse o rows selecionadas.
  Posponha a rows para as rows deste text.
  Posponha o rows selecionadas para as rows deste text.
  Posponha a segunda rows para as rows deste text.
  Renumber as rows deste text.

Etapas necessárias para que se reverse uma cor:
  Se a cor for a cor preta, atribua a cor branca à cor; exit.
  Se a cor for a cor branca, atribua a cor preta à cor; exit.
  Atribua 1000 menos a luminosidade desta cor à luminosidade desta cor.
    \Atribua 1000 menos a saturação desta cor à saturação desta cor.
  Adicione 1800 para a matiz desta cor. Normalize a matiz desta cor.

Etapas necessárias para que se invert um detector;
Etapas necessárias para que se reverse um detector:
  Se o detector for 1, atribua 0 ao detector; exit.
  Atribua 1 ao detector.

Etapas necessárias para que se reverse um número;
Etapas necessárias para que se invert um número:
  Multiplique o número por -1.

Etapas necessárias para que se reverse uma string:
    \ could ser more efficient
  Isole a string.
  Limpe o original string.
  Percorra. [o código abaixo]
    Se a string estiver em branco, pare.
    Obtenha um character desde a string (backwards).
    Posponha o character para o original string.
  Repita. [o código acima]

Etapas necessárias para que se reverse uns coisas:
  Permute  as coisas com uns segunda coisas.
  Percorra. [o código abaixo]
    Atribua o last destas segunda coisas a uma coisa.
    Se a coisa for inexistente, cancele.
    Mova a coisa desde a segunda coisas para as coisas.
  Repita. [o código acima]

Um espaço de cor RGB é um conjunto com
  Um pedaço denominado espectro azul,
  Um pedaço denominado espectro verde,
  Um pedaço denominado espectro vermelho.

Um endereço de memória RGB é um endereço de memória para um espaço de cor RGB.

Um deslocamento vertical é um número.
Um deslocamento horizontal é um número.

Etapas necessárias para que se rotate uma caixa:
  Atribua o center desta caixa a um center localização.
  Atribua a caixa a uma segunda caixa.
  Atribua a coordenada Y deste center menos a coordenada superior desta segunda caixa mais a coordenada X deste center à coordenada direita desta caixa.
  Atribua a coordenada esquerda desta segunda caixa menos a coordenada X deste center mais a coordenada Y deste center à coordenada superior desta caixa.
  Atribua a coordenada Y deste center menos a coordenada inferior desta segunda caixa mais a coordenada X deste center à coordenada esquerda desta caixa.
  Atribua a coordenada direita desta segunda caixa menos a coordenada X deste center mais a coordenada Y deste center à coordenada inferior desta caixa.

Etapas necessárias para que se rotate um elipse:
  Rotate a caixa desta elipse.

Etapas necessárias para que se rotate um gpimage:
  Se o gpimage for inexistente, cancele.
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O gpimage 
    e 1 [Rotate90FlipNone].

Etapas necessárias para que se rotate um gpimage usando um ângulo:
    \ ângulo pode ser 0, 900, 1800, 2700
  Se o gpimage for inexistente, cancele.
  Atribua 0 [RotateNoneFlipNone] a um número.
  Se o ângulo for 900, atribua 1 [Rotate90FlipNone] ao número.
  Se o ângulo for 1800, atribua 2 [Rotate180FlipNone ] ao número.
  Se o ângulo for 2700, atribua 3 [Rotate270FlipNone ] ao número.
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O gpimage 
    e O número.

Etapas necessárias para que se rotate um line:
  Atribua o center desta line a um center localização.
  Rotate o start desta line around o center.
  Rotate o end desta line around o center.

Etapas necessárias para que se rotate um imagem:
  Se o imagem for inexistente, cancele.
  Adicione 900 para o ângulo de rotação desta imagem.
  Se o mirror detector desta imagem estiver ativo, adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Rotate a caixa desta imagem.
  Rotate a caixa intacta desta imagem.
  Atribua o center desta caixa desta imagem a um center localização.
  Atribua o center desta caixa intacta desta imagem a uma segunda center localização.
  Atribua a coordenada Y deste center menos a coordenada Y desta segunda center mais a coordenada X deste center ao número X desse twip par de números.
  Subtraia a coordenada X desta segunda center desde o número X deste twip par de números.
  Atribua a coordenada Y deste center mais a coordenada X desta segunda center menos a coordenada X deste center ao número Y deste twip par de números.
  Subtraia a coordenada Y desta segunda center desde o número Y deste twip par de números.
  Mova a caixa intacta desta imagem usando o twip par de números.
  Rotate o gpbitmap desta imagem.

Etapas necessárias para que se rotate um polígono:
  Se o polígono for inexistente, cancele.
  Atribua o center deste polígono a um center localização.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Rotate a localização deste vértice around o center.
  Repita. [o código acima]

Etapas necessárias para que se rotate uma localização around um center localização:
  Atribua a localização a uma segunda localização.
  Atribua a coordenada Y deste center menos a coordenada Y desta segunda localização mais a coordenada X deste center à coordenada x desta localização.
  Atribua a coordenada X desta segunda localização menos a coordenada X deste center mais a coordenada Y deste center à coordenada y desta localização.

Etapas necessárias para que se rotate um text:
  Se o text for inexistente, cancele.
  Rotate a caixa deste text.
  Wrap o text.

Etapas necessárias para que se arredonde um número para um segundo número:
  Arredonde o número para o múltiplo imediato of o segundo número.

Etapas necessárias para que se arredonde um número para baixo para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número.
  Multiplique o número pelo segundo número.

Etapas necessárias para que se arredonde um número para o múltiplo imediato of um outro número:
  Se o outro número for 0, cancele.
  Isole o outro número.
  Divida o número pelo outro número usando um quotient e um resto.
  Divida o outro número por 2.
  Se o resto for maior do que ou igual ao outro número, arredonde o número para cima para o múltiplo imediato of o original outro número; exit.
  Arredonde o número para baixo para o múltiplo imediato of o original outro número.

Etapas necessárias para que se arredonde um número para cima para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número usando um quotient e um resto.
  Se o resto for 0, cancele.
  Adicione o segundo número menos o resto para o número.

Etapas necessárias para que se arredonde um número para cima para o nearest power of two:
  Intel $8B8D08000000. \ mov ecx,[ebp+8] \ o número
  Intel $8B09. \ mov ecx,[ecx]
  Intel $49. \ dec ecx
  Intel $0FBDC9. \ bsr ecx,ecx
  Intel $41. \ inc ecx
  Intel $81F904000000. \ cmp ecx,4
  Intel $0F8F05000000. \ jg over o next 1 statement
  Intel $B904000000. \ mov ecx,4
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
  Intel $C70001000000. \ mov [eax],1
  Intel $D320. \ shl [eax],ecx 

Etapas necessárias para que se arredonde um par de números para uma segunda par de números:
  Arredonde o par de números para o múltiplo imediato of a segunda par de números.

Etapas necessárias para que se arredonde um par de números para o múltiplo imediato of uma segunda par de números:
  Arredonde o número X deste par de números para o múltiplo imediato of o número X desta segunda par de números.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número Y desta segunda par de números.

Etapas necessárias para que se arredonde um par de números para o múltiplo imediato of um número:
  Arredonde o número X deste par de números para o múltiplo imediato of o número.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número.

Etapas necessárias para que se arredonde um par de números para um número:
  Arredonde o par de números para o múltiplo imediato of o número.

Um caixa arredondada é uma caixa com
  Uma coordenada esquerda, 
  Uma coordenada superior, 
  Uma coordenada direita, 
  Uma coordenada inferior,
  Um canto superior esquerdo localização at a coordenada esquerda , 
  Um canto inferior direito localização at a coordenada direita, e 
  Um raio.

An row é uma coisa com 
  Um número da linha e 
  Uma string.

Um número da linha é um número.

Um saturação é um número [0 para 1000].

Etapas necessárias para que se save um canvas:
  Call "gdi32.dll" "SaveDC" com o canvas.

Etapas necessárias para que se save um context:
  Aloque memória por um saved context.
  Atribua a localização deste context à localização deste saved context.
  Atribua a orientação deste context à orientação deste saved context.
  Atribua a tamanho da letra deste context à tamanho da letra deste saved context.
  Atribua a cor deste context à cor deste saved context.
  Atribua o número deste context ao número deste saved context.
  Anteponha o saved context para o context stack.

O saved memory hbitmap é um hbitmap.

O saved tpp é um número.

Etapas necessárias para que se say um número:
  Atribua o número a uma string.
  Say a string.

Etapas necessárias para que se say uma string;
Etapas necessárias para que se speak uma string:
  Se o silent detector estiver ativo, cancele.
    \Se la bandera silenciosa estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para um wide string.
  Modifique através do caractere NUL a wide string.
  Call o speak desta vtable deste talker com 
    O talker 
    e O first deste wide string 
    e 17 [SVSFDefault+SVSFlagsAsync +SVSFIsNotXML] 
    e 0.

Etapas necessárias para que se say uma string e wait;
Etapas necessárias para que se speak uma string e wait:
  Se o silent detector estiver ativo, cancele.
  Se la bandera silenciosa estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para um wide string.
  Modifique através do caractere NUL a wide string.
  Call o speak desta vtable deste talker com 
    O talker 
    e O first deste wide string 
    e 16 [SVSFDefault+SVSFIsNotXML] 
    e 0.

Etapas necessárias para que se redimensione proporcionalmente uma caixa usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente uma caixa usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada esquerda desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada superior desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada direita desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada inferior desta caixa usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma caixa para um percent:
  Atribua o percent / 100 a um fração.
  Redimensione proporcionalmente a caixa usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um elipse usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um elipse usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta elipse usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um elipse para um percent:
  Atribua o percent / 100 a um fração.
  Redimensione proporcionalmente a elipse usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma font usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente uma font usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a altura desta font usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma fração usando uma segunda fração;
Etapas necessárias para que se multiplique uma fração por uma segunda fração:
  Multiplique o numerador desta fração pelo numerador desta segunda fração.
  Multiplique o denominador desta fração pelo denominador desta segunda fração.
  Reduce a fração.

Etapas necessárias para que se redimensione proporcionalmente um line usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um line usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente o start desta line usando a fração.
  Redimensione proporcionalmente o end desta line usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um line para um percent:
  Atribua o percent / 100 a um fração.
  Redimensione proporcionalmente o line usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um par de números usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um par de números usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente o número X deste par de números usando a fração.
  Redimensione proporcionalmente o número Y deste par de números usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um par de números usando um par de números racionais;
Etapas necessárias para que se redimensione proporcionalmente um par de números usando uma par de números fracionários:
  Redimensione proporcionalmente o número X deste par de números usando a fração deste par de números fracionários.
  Redimensione proporcionalmente o número Y deste par de números usando a segunda fração deste par de números fracionários.

Etapas necessárias para que se redimensione proporcionalmente um par de números para um percent:
  Atribua o percent / 100 a um fração.
  Redimensione proporcionalmente o par de números usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um imagem usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um imagem usando um fração:
  Se a imagem for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta imagem usando a fração.
  Redimensione proporcionalmente a caixa intacta desta imagem usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um imagem para um percent:
  Se a imagem for inexistente, cancele.
  Atribua o percent / 100 a um fração.
  Redimensione proporcionalmente o imagem usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um polígono usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um polígono usando um fração:
  Se o polígono for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Redimensione proporcionalmente o vértice usando a fração.
  Repita. [o código acima]

Etapas necessárias para que se redimensione proporcionalmente um polígono para um percent:
  Se o polígono for inexistente, cancele.
  Atribua o percent / 100 a um fração.
  Redimensione proporcionalmente o polígono usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma caixa arredondada usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente uma caixa arredondada usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa arredondada como uma caixa usando a fração.
  Redimensione proporcionalmente o raio desta caixa arredondada usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma caixa arredondada para um percent:
  Atribua o percent / 100 a um fração.
  Redimensione proporcionalmente a caixa arredondada usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um text para um fração:
  \ absolute
  Se o text for inexistente, cancele.
  Atribua a scale deste text a uma segunda fração.
  Flip a segunda fração.
  Multiplique a segunda fração pela fração.
  Redimensione proporcionalmente o text usando a segunda fração.

Etapas necessárias para que se redimensione proporcionalmente um text usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um text usando um fração:
  Se o text for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa deste text usando a fração.
  Redimensione proporcionalmente a origin deste text usando a fração.
  Redimensione proporcionalmente a font deste text usando a fração.
  Redimensione proporcionalmente a scale deste text usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um text para um percent:
  Se o text for inexistente, cancele.
  Atribua o percent / 100 a um fração.
  Redimensione proporcionalmente o text usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um vértice usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um vértice usando um fração:
  Se o vértice for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada X deste vértice usando a fração.
  Redimensione proporcionalmente a coordenada Y deste vértice usando a fração.

O tela canvas é um canvas.

A tela é um conjunto com 
  Uma caixa, 
  Uma pixel altura e 
  Uma pixel largura.

Etapas necessárias para que se role um console usando um event:
  Se o console for inexistente, cancele.
  Encontre um sector usando a malha deste console e a localização deste event.
  Percorra. [o código abaixo]
    Se o botão direito deste mouse não estiver sendo pressionado, cancele.
    Encontre uma segunda sector usando a malha deste console e a localização deste mouse.
    Obtenha um difference between a segunda sector e o sector.
    Se a difference for 0, repita.
    Role o text deste console usando a difference.
    Mostre o console.
    Adicione a difference para o sector.
  Repita. [o código acima]

Etapas necessárias para que se role um text para o base:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua a contagem de linhas deste text menos 1 a um número.
  Atribua - o número times a altura da linha deste text à coordenada y deste text.
  Limite o origin of o text.

  Multiplique o número por -1.
  Multiplique o número pela altura da linha deste texto.
  Adicione 2 ao número.
  Atribua o número à Coordenada Y deste texto.

Etapas necessárias para que se role um text para o caret:
  Se o text for inexistente, cancele.
  Se o column# deste caret deste text for 1, atribua a margin deste text à coordenada x deste text.
  Obtenha uma caixa pelo caret no text.
  Ajuste a caixa usando 0 e - o tpp e 0 e o tpp. \ caret caixas do not fill entire row
  Se a coordenada superior desta caixa for menor do que a coordenada superior deste text, atribua a coordenada superior deste text menos a coordenada superior desta caixa ao número Y dessa difference.
  Se a coordenada inferior desta caixa for maior do que a coordenada inferior deste text, atribua a coordenada inferior deste text menos a coordenada inferior desta caixa ao número Y desta difference.
  Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda deste text , atribua a coordenada esquerda deste text menos a coordenada esquerda desta caixa ao número X desta difference.
  Se a coordenada direita desta caixa for maior do que a coordenada direita deste text, atribua a coordenada direita deste text menos a coordenada direita desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role o text usando a difference.

Etapas necessárias para que se role um text para o caret e center it:
  Se o text for inexistente, cancele.
  Atribua a margin deste text à coordenada x deste text.
  Obtenha uma caixa pelo caret no text.
  Se a caixa estiver inside a caixa deste text, cancele.
  Ajuste a caixa usando 0 e - o tpp e 0 e o tpp. \ caret caixas don not fill entire row
  Atribua o y-extent desta caixa deste text dividido por 2 a uma altura.
  Arredonde o altura para baixo para o múltiplo imediato of a altura da linha deste text.
  Atribua a coordenada superior desta caixa deste text mais o altura a uma coordenada superior.
  Atribua a coordenada superior mais a altura da linha deste text a uma coordenada inferior.
  Se a coordenada superior desta caixa for menor do que a coordenada superior, atribua a coordenada superior menos a coordenada superior desta caixa ao número Y dessa difference.
  Se a coordenada inferior desta caixa for maior do que a coordenada inferior, atribua a coordenada inferior menos a coordenada inferior desta caixa ao número Y desta difference.
  Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda deste text , atribua a coordenada esquerda deste text menos a coordenada esquerda desta caixa ao número X desta difference.
  Se a coordenada direita desta caixa for maior do que a coordenada direita deste text, atribua a coordenada direita deste text menos a coordenada direita desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role o text usando a difference.

Etapas necessárias para que se role um text para baixo one line:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua - a altura da linha deste text ao número Y dessa difference. \ reescrever esse comando
  Role o text usando a difference.

Etapas necessárias para que se role um text para baixo one página:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Subtraia o y-extent desta caixa deste text desde a coordenada Y deste text.
  Adicione a altura da linha deste text para a coordenada Y deste text.
  Limite o origin of o text.

Etapas necessárias para que se role um text usando um difference:
  Se o text for inexistente, cancele.
  Isole a difference.
  Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número X desta difference.
  Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, cancele.
  Mova a origin deste text usando a difference.
  Limite a origin of o text.

Etapas necessárias para que se role um text para o topo:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua 0 à coordenada y deste text.
  Limite o origin of o text.

Etapas necessárias para que se role um text para cima one line:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua a altura da linha deste text ao número Y dessa difference.
  Role o text usando a difference.

Etapas necessárias para que se role um text para cima one página:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Adicione o y-extent desta caixa deste text para a coordenada Y deste text.
  Subtraia a altura da linha deste text desde a coordenada Y deste text.
  Limite o origin of o text.

An second é 1000 milliseconds.

Um sector é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y [indicating o canto superior esquerdo of o sector].

A seed é um número.

Etapas necessárias para que se selecione cada pedaço em um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao anchor deste text.
  Atribua a quantidade de caracteres desta string deste last destas rows deste text e a contagem de linhas deste text ao caret deste text.

Etapas necessárias para que se selecione um número da linha usando um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número da linha e o text.
  Se a row for inexistente, cancele.
  Atribua o número da linha ao anchor número da linha deste text .
  Atribua 1 ao anchor column# deste text.
  Atribua o número da linha ao número de linhas do cursor deste text.
  Atribua a quantidade de caracteres desta string desta row ao caret column# deste text.

Um caixa de seleção é uma caixa.

Uma seleção é um conjunto com 
  Um anchor column#,
  Um anchor número da linha, 
  Um anchor at o anchor column#,
  Um caret column#, 
  Um número de linhas do cursor, 
  Um caret at o caret column#.

Etapas necessárias para que se send um trecho para um socket:
  Limpe o erro do fluxo de entrada/saída.
  Atribua o first endereço de memória do pedaço deste trecho a um endereço de memória.
  Atribua a quantidade de caracteres deste trecho a uma quantidade de caracteres.
  Percorra. [o código abaixo]
  Se a quantidade de caracteres for 0, pare.
    Call "ws2_32.dll" "send" com 
       O socket 
       e O endereço de memória 
       e A quantidade de caracteres 
       e 0 
       devolvendo um número.
    Se o número for -1 [SOCKET_ERROR ], atribua "Ocorreu um erro na hora de enviar dados." ao erro do fluxo de entrada/saída; exit.
    Subtraia o número desde a quantidade de caracteres.
    Adicione o número para o endereço de memória.
  Repita. [o código acima]

Etapas necessárias para que se send um data string para um winhttp request:
  Se o winhttp request for inexistente, cancele.
  Call "winhttp.dll" "WinHttpSendRequest" com 
    O request número identificador deste winhttp request 
    e 0 [WINHTTP_NO_ADDITIONAL_HEADERS] 
    e 0 e o first destes data 
    e A quantidade de caracteres destes data 
    e A quantidade de caracteres destes data 
    e 0 
    devolvendo um result número.
  Se o result for 0, atribua "Erro. Não foi possível enviar a solicitação." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se send um email:
  Limpe o erro do fluxo de entrada/saída.
  \ crie socket
  Crie um socket usando o smtp server deste email e 25.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
    \ initial receive here por date/time stuff desde server
  Receive um response string desde o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send HELO
  Send "HELO " junto com o nome deste module junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send MAIL FROM: <xxx>
  Send "MAIL FROM: <" junto com o sender deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send RCPT TO: <xxx>
  Send "RCPT TO: <" junto com o recipient deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send DATA
  Send "DATA" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
  Limpe um temp string.
  Posponha "De: " junto com o sender deste email junto com o texto CRLF para o temp string.
  Posponha "Para: " junto com o recipient deste email junto com o texto CRLF para o temp string.
  Posponha "Assunto: " junto com o subject deste email junto com o texto CRLF ao temp string.
  Posponha "Reply-To: " junto com o sender deste email junto com o texto CRLF ao temp string.
  Posponha o texto CRLF para o temp string.
  Posponha a message deste email para o temp string (handling email transparency).
  Posponha o texto CRLF seguido de "." junto com o texto CRLF para o temp string.
  Send o temp string para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send QUIT
  Send "QUIT" junto com o texto CRLF para o socket.
  \ destrua socket
  Destrua o socket.

Etapas necessárias para que se send um message desde um sender para um recipient:
  Send o message para o recipient desde o sender.

Etapas necessárias para que se send um message desde um sender para um recipient via um smtp server:
  Send o message para o recipient desde o sender via o smtp server.

Etapas necessárias para que se send um message desde um sender para um recipient com um subject:
  Send o message para o recipient desde o sender com o subject.

Etapas necessárias para que se send um message desde um sender para um recipient com um subject via um smtp server:
  Send o message para o recipient desde o sender com o subject via o smtp server.

Etapas necessárias para que se send um message para um recipient desde um sender:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas necessárias para que se send um message para um recipient desde um sender via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas necessárias para que se send um message para um recipient desde um sender com um subject:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas necessárias para que se send um message para um recipient desde um sender com um subject via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas necessárias para que se send uma string para um socket e receive um response string:
  Limpe a response string.
  Send a string para o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Receive a response string desde o socket.

Um sender é uma string.

Etapas necessárias para que se defina o código da cor of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetTextColor" com 
    O canvas e o código da cor.

Etapas necessárias para que se defina o drawing origin para uma localização:
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 112 [PhysicalOffsetYX] 
    devolvendo o número X desse par de números.
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 113 [PhysicalOffsetY ] 
    devolvendo o número Y deste par de números.
  Negate o par de números.
  Se o quadro atual não for o printer canvas, limpe o par de números.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e O número X deste par de números 
    e O número Y deste par de números 
    e nil.
  Isole a localização.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e O endereçamento desta localização 
    e 1.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    e nil.

Etapas necessárias para que se acione um detector;
Etapas necessárias para que se ative um detector;
Etapas necessárias para que se dispare um detector;
Etapas necessárias para que se toque um detector;
Etapas necessárias para que se ligue um detector:
  Atribua 1 ao detector. \ era "Atribua sim ao detector." O valor binário do termo sim era herdado do CAL-1000 de acordo com o Dan.

Etapas necessárias para que se defina um endereço completo para read-write mode:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Conjuncione logicamente o número com -2 [everything except FILE_ATTRIBUTE_READONLY].
  Call "kernel32.dll" "SetFileAttributesA" com 
    O first deste endereço completo 
    e O número.

Um sheet é uma caixa.

Etapas necessárias para que se desloque um pedaço left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o byte (ebp+8) no registrador eax
  Intel $D220. \ shl ptr [eax],ecx -> efetua o deslocamento dos bits para a esquerda (shl)

Etapas necessárias para que se desloque um pedaço right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o byte (ebp+8) no registrador eax
  Intel $D228. \ shr ptr [eax],ecx -> efetua o deslocamento dos bits para a direita (shr)

Etapas necessárias para que se desloque um número left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o número (ebp+8) no registrador eax
  Intel $D320. \ shl [eax],ecx -> efetua o deslocamento do número para a esquerda (shl)

Etapas necessárias para que se desloque um número right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] -> salva o número (ebp+8) no registrador eax
  Intel $D328. \ shr [eax],ecx -> efetua o deslocamento do número para a direita (shr)

Etapas necessárias para que se desloque um word left uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] \ salva a word (ebp+8) no registrador eax
  Intel $66D320. \ shl word ptr [eax],ecx \ shr word ptr [eax],ecx -> efetua o deslocamento dos bits para a esquerda (shl)

Etapas necessárias para que se desloque um word right uns bits:
  Intel $8B8D0C000000. \ mov ecx,[ebp+12] -> salva a quantidade de bits informada (ebp+12) no registrador ecx
  Intel $8B09. \ mov ecx,[ecx] -> ebp-12 é o 2º parâmetro de uma função. ebp+8 é o 1º parâmetro
  Intel $8B8508000000. \ mov eax,[ebp+8] \ salva a word (ebp+8) no registrador eax
  Intel $66D328. \ shr word ptr [eax],ecx -> efetua o deslocamento dos bits  para a direita (shr)

Etapas necessárias para que se mostre um console:
  Se o console for inexistente, cancele.
  Save o quadro atual.
  Pinte o console.
  Atualize o tela usando a caixa deste console.
  Restore o quadro atual.

Etapas necessárias para que se mostre um cursor:
  Call "user32.dll" "SetCursor" com o cursor.
  Call "user32.dll" "ShowCursor" com 1 
    devolvendo um número.
  Se o número for maior do que 0, cancele.
  Repita. [o código acima]

Etapas necessárias para que se mostre um terminal:
  Se o terminal for inexistente, cancele.
  Save o quadro atual.
  Pinte o terminal.
  Atualize o tela usando a caixa deste terminal.
  Restore o quadro atual.

Etapas necessárias para que se shrink uma caixa por uns twips;
Etapas necessárias para que se indent uma caixa uns twips;
Etapas necessárias para que se indent uma caixa por uns twips;
Etapas necessárias para que se indent uma caixa uns twips sobre cada side;
Etapas necessárias para que se indent uma caixa usando uns twips:
  Adicione os twips para a coordenada esquerda desta caixa.
  Adicione os twips para a coordenada superior desta caixa.
  Subtraia os twips desde a coordenada direita desta caixa.
  Subtraia os twips desde a coordenada inferior desta caixa.

Etapas necessárias para que se feche o programa;
Etapas necessárias para que se feche o nosso programa;
Etapas necessárias para que se feche nosso programa;
Etapas necessárias para que se feche tudo;
Etapas necessárias para que se shut para baixo:
  Destrua o Bíblia.
  Destrua o stack.
  Destrua o dicionário léxico.
  Destrua o console.
  Destrua o terminal.
  Finalize o context.
  Finalize os canvases.
  Finalize o mouse.
  Finalize os cursors.
  Finalize as fonts.
  Finalize a window.
  Finalize o tela.
  Finalize as cors.
  Finalize o module.
  Finalize o talker.
  Finalize gdi+.
  Finalize winsock.
  Finalize COM.

Etapas necessárias para que se shut para baixo o cgi:
  Finalize o cgi.
  Finalize o module.
  Finalize winsock.

Um side é 1 unit.

O silent detector é um detector.

Etapas necessárias para que se simplify um reply:
  Se o reply estiver em branco, pare.
  Obtenha um pedaço desde o reply.
  Se o pedaço é algum tipo de sinal de pontuação, repita.
  Posponha o pedaço para uma string.
  Repita. [o código acima]
  Atribua a string ao reply.

Um size é uns twips.

Etapas necessárias para que se skip algum tipo de leading linefeed pedaço em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o linefeed pedaço, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se skip algum tipo de leading noise em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se skip algum tipo de non-alfanumérico pedaços em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for alfanumérico, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se skip um line sobre o terminal:
  Escreva "" sobre o terminal.

Etapas necessárias para que se skip palavra characters em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o subtexto está sobre alguma espécie de contração, adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for alfanumérico, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se lance um percorredor sobre um segundo percorredor:
  Lance o segmento final deste percorredor sobre o segmento final deste segundo percorredor.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas necessárias para que se lance um percorredor sobre uma string:
  Lance o subtexto original deste percorredor sobre a string.
  Lance o segmento final deste percorredor sobre a string.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas necessárias para que se lance um subtexto sobre algum tipo de pedaços selecionados em uma row of um text:
  Limpe o subtexto.
  Se o text for inexistente, cancele.
  Se a row of o text não estiver selecionado, cancele.
  Lance o subtexto sobre a string deste row.
  Atribua a normalized seleção deste text a uma seleção.
  Se o número da linha desta row é o número de linhas do cursor desta seleção, atribua o first endereço de memória do pedaço deste subtexto mais o caret column# desta seleção menos 2 ao last endereço de memória do pedaço deste subtexto.
  Se o número da linha desta row é o anchor número da linha desta seleção, atribua o first endereço de memória do pedaço deste subtexto mais o anchor column# desta seleção menos 1 ao first endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se lance um subtexto sobre o first pedaço of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o first endereço de memória do pedaço desta string ao last endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se lance um subtexto sobre o last pedaço of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o last endereço de memória do pedaço desta string ao first endereço de memória do pedaço deste subtexto.

Etapas necessárias para que se lance um subtexto sobre uma string:
  Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ a string
    \ atribua o first endereço de memória do pedaço desta string ao first do subtexto
  Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o first endereço de memória do pedaço desta string
  Intel $898800000000. \ mov [eax+0],ecx \ o first do subtexto
    \ atribua o last endereço de memória do pedaço desta string ao last endereço de memória do pedaço deste subtexto
  Intel $8B8B04000000. \ mov ecx,[ebx+4] \ o last do string
  Intel $898804000000. \ mov [eax+4],ecx \ o last endereço de memória do pedaço deste subtexto

O tamanho de letra pequena é um tamanho da letra.

O menor número é -2147483648.

Etapas necessárias para que se suavize um polígono:
  Se o polígono for inexistente, cancele.
  Se a contagem destes vértices deste polígono for menor do que 3, cancele.
  Se o polígono estiver closed, posponha a localização deste next deste first vértice deste polígono para o polígono; ative um detector.
  Atribua o first vértice deste polígono a um left vértice.
  Percorra. [o código abaixo]
    Se o next deste left vértice for inexistente, pare.
    Atribua o next deste left vértice a um right vértice.
    Obtenha um center localização usando a localização deste left vértice e a localização deste right vértice.
    Insira o center ao polígono after o left vértice.
    Atribua o next deste left vértice a um new vértice.
    Se o previous deste left vértice for inexistente, atribua o right vértice ao left vértice; repita.
    Obtenha uma segunda center localização usando a localização deste previous deste left vértice e a localização deste new vértice.
    Obtenha um difference between a segunda center e a localização deste left vértice.
    Divida a difference por 2.
    Adicione a difference para a localização deste left vértice.
    Atribua o right vértice ao left vértice.
  Repita. [o código acima]
  Se o detector não estiver ativo, cancele.
  Destrua o first vértice deste polígono usando o polígono.
  Destrua o last vértice deste polígono usando o polígono.

Etapas necessárias para que se suavize um polígono uns times; 
Etapas necessárias para que se suavize um polígono uns vezes:
    \ this use para "times" é um fluke, I think -- see "some times é um número"
  Isole o times.
  Percorra. [o código abaixo]
    Se o times for 0, cancele.
    Suavize o polígono.
    Subtraia 1 desde o times.
  Repita. [o código acima]

Some vezes é um número.

Um smtp server é uma string.

Um socket é um endereço de memória.

Etapas necessárias para que se classifique algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Split a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
  Classifique o rows selecionadas.
  Posponha a rows para as rows deste text.
  Posponha o rows selecionadas para as rows deste text.
  Posponha a segunda rows para as rows deste text.
  Renumber as rows deste text.

Etapas necessárias para que se classifique uns rows:
  Se o first destas rows for o last destas rows, cancele.
  Split a rows a uns left rows e umas right rows.
  Classifique as left rows.
  Classifique as right rows.
  Percorra. [o código abaixo]
    Atribua o first destas left rows a uma left row.
    Atribua o first destas right rows a uma right row.
    Se a left row for inexistente, posponha as right rows para as rows; exit.
    Se a right row for inexistente, posponha as left rows para as rows; exit.
    Se a string desta left row for maior do que a string desta right row, mova a right row desde as right rows para as rows; repita.
    Mova a left row desde as left rows para as rows.
  Repita. [o código acima]

Etapas necessárias para que se providencie espaçamento adequado entre caracteres:
  Vire right.
  Mova 3 squares.
  Vire left.

O texto de espaço é uma string igual a " ".

Etapas necessárias para que se split um trecho para uns dyads:
  Destrua o dyads.
  Se o trecho estiver em branco, cancele.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Mova o percorredor usando o & comercial.
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Crie um dyad.
    Posponha o dyad para o dyads.
    Split o segmento inicial deste percorredor a um nome subtexto e um query subtexto usando o sinal de igualdade.
    Atribua o nome subtexto ao nome deste dyad.
    Converta o query subtexto como um texto de consulta ao value deste dyad.
  Repita. [o código acima]

Etapas necessárias para que se split um pedaço para uma cifra binária e uma segunda cifra binária:
  Atribua o pedaço à cifra binária.
  Desloque a cifra binária right 4 bits.
  Atribua o pedaço ao segunda cifra binária.
  Conjuncione logicamente a segunda cifra binária com 15.

Etapas necessárias para que se split um line para uma segunda line e um terceiro line:
  Isole o line.
  Atribua o center desta line a um center localização.
  Atribua o start desta line e o center ao segunda line.
  Atribua o center e o end desta line ao terceiro line.

Etapas necessárias para que se split um número para um word e uma segunda word:
  Isole o número.
  Desloque o número right 16 bits.
  Atribua o número ao word.
  Atribua o original número ao segunda word.

Etapas necessárias para que se split a rows of um text para uns rows e uns rows selecionadas e uns segunda rows:
  Se o text for inexistente, limpe as rows; limpe o rows selecionadas; limpe as segunda rows; exit.
  Percorra. [o código abaixo]
    Atribua o first destas rows deste text a uma row.
    Se a row for inexistente, cancele.
    Remove a row desde as rows deste text.
    Se a row of o text estiver selecionado, acione um detector; posponha a row para o rows selecionadas; repita.
    Se o detector estiver ativo, posponha a row para a segunda rows; repita.
    Posponha a row para a rows.
  Repita. [o código acima]

Etapas necessárias para que se split uma string para um left subtexto e um right subtexto usando um separator pedaço:
  Limpe o left .
  Limpe o right subtexto.
  Se a string estiver em branco, cancele.
  Atribua o first endereço de memória do pedaço desta string ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta string, cancele.
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for o separator pedaço, pare.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto ao first endereço de memória do pedaço deste left subtexto.
  Atribua o last endereço de memória do pedaço deste subtexto menos 1 ao last endereço de memória do pedaço deste left subtexto.
  Atribua o last endereço de memória do pedaço deste subtexto mais 1 ao first endereço de memória do pedaço deste right subtexto.
  Atribua o last endereço de memória do pedaço desta string ao last endereço de memória do pedaço deste right subtexto.

Etapas necessárias para que se split uma string para uns conjunto de textos usando um separator pedaço:
  Destrua o conjunto de textos.
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor usando o separator pedaço.
    Adicione o segmento inicial deste percorredor para o conjunto de textos.
    Se o segmento final deste percorredor estiver em branco, pare.
  Repita. [o código acima]
  Se o conteúdo deste last endereço de memória do pedaço desta string não for o separator pedaço, cancele.
  Adicione "" para o conjunto de textos.

Etapas necessárias para que se split uns coisas para uns left coisas e uns right coisas:
  Se  as coisas estiverem vazio, limpe o left coisas; limpe o right coisas; exit.
  Atribua a contagem destas coisas dividido por 2 a uma contagem.
  Percorra. [o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a contagem for 0, pare.
    Subtraia 1 desde a contagem.
    Repita. [o código acima]
    Split  as coisas ao left coisas e o right coisas at o coisa.

Etapas necessárias para que se split uns coisas para uns left coisas e uns right coisas at um coisa:
  Limpe o left coisas.
  Limpe o right coisas.
  Se a coisa for inexistente, permute  as coisas com o left coisas; exit.
  Se o previous desta coisa for inexistente, permute  as coisas com o left coisas; exit.
    \ abra para cima o left chain
  Atribua o first destas coisas ao first destas left coisas.
  Atribua o previous desta coisa ao last destas left coisas.
  Esvazie o next deste previous desta coisa.
    \ abra para cima o right chain
  Atribua a coisa ao first destas right coisas.
  Esvazie o previous desta coisa.
  Atribua o last destas coisas ao last destas right coisas.
    \ fix o original chain
  Limpe as coisas.

Etapas necessárias para que se split um word para um pedaço e um segundo pedaço:
  Isole o word.
  Desloque o word right 8 bits.
  Atribua o word ao pedaço.
  Atribua o original word ao segundo pedaço.

Um localização é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y e 
  Uma left at a coordenada X e 
  Um topo at a coordenada Y.

Um localização endereço de memória é um endereço de memória para uma localização.

Um square é 1440 units. \ número alto para facilitar as divisões. Podia ser qualquer número

Um square root é um número.

O square size é uns twips.

Etapas necessárias para que se square para cima algum tipo de seleção em um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Normalize a seleção deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua 1 ao anchor column# deste text.
  Se o caret column# deste text não for 1, adicione 1 para o número de linhas do cursor deste text; atribua 1 ao caret column# deste text.
  Se o número de linhas do cursor deste text for menor do que ou igual à contagem de linhas deste text, cancele.
  Atribua a contagem de linhas deste text ao número da linha deste caret deste text.
  Atribua a quantidade de caracteres desta string desta row ao column# deste caret deste text.

\A raiz de dois é uma fração igual a 99/70.
A raiz de dois é uma fração igual a 1414213562/1000000000.
A raiz de três é uma fração igual a 1732050807/1000000000.
\A raiz de cinco é uma fração igual a 161/72.
A raiz de cinco é uma fração igual a 2236067977/1000000000.
A raiz de seis é uma fração igual a 2449489742/1000000000.
A raiz de sete é uma fração igual a 2645751311/1000000000.
A raiz de oito é uma fração igual a 2828427124/1000000000.
A raiz de dez é uma fração igual a 3162277660/1000000000.
A raiz de onze é uma fração igual a 3316624790/1000000000.
\2147483647 é o número máximo positivo em um processador de 32 bits / 4 bytes
\O número pi é uma fração igual a 355/113. \número pi
O número pi é uma fração igual a 3141592653/1000000000.
O número de Euler é uma fração igual a 271828182846/1000000000.
O número neperiano é uma fração igual a 271828182846/1000000000.
A proporção dourada é uma fração igual a 1618033988/1000000000.

An stack entry é uma coisa com uma string.

O stack é uns stack entries.

Etapas necessárias para que se start anywhere em uma caixa:
  Escolha aleatoriamente a localização deste context na caixa.

Etapas necessárias para que se start anywhere sobre um horizontal line:
  Escolha aleatoriamente uma localização sobre o horizontal line.
  Atribua a localização à localização deste context.

Etapas necessárias para que se start at o base left corner of uma caixa facing east:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face east.

Etapas necessárias para que se start at o base left corner of uma caixa facing north:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face north.

Etapas necessárias para que se start at o base left corner of uma caixa facing south:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face south.

Etapas necessárias para que se start at o base left corner of uma caixa facing west:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face west.

Etapas necessárias para que se start at o base of um horizontal line:
  Atribua o end desta vertical line à localização deste context.

Etapas necessárias para que se start at o base right corner of uma caixa facing east:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face east.

Etapas necessárias para que se start at o base right corner of uma caixa facing north:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face north.

Etapas necessárias para que se start at o base right corner of uma caixa facing south:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face south.

Etapas necessárias para que se start at o base right corner of uma caixa facing west:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face west.

Etapas necessárias para que se start at o left of um horizontal line:
  Atribua o start desta horizontal line à localização deste context.

Etapas necessárias para que se start at o middle of o base of uma caixa;
Etapas necessárias para que se start no middle of o base of uma caixa;
Etapas necessárias para que se start at o center of o base of uma caixa;
Etapas necessárias para que se start no center of o base of uma caixa:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.

Etapas necessárias para que se start at o middle of o base of uma caixa facing east;
Etapas necessárias para que se start no middle of o base of uma caixa facing east;
Etapas necessárias para que se start at o center of o base of uma caixa facing east;
Etapas necessárias para que se start no center of o base of uma caixa facing east:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.
  Face east.

Etapas necessárias para que se start at o middle of o base of uma caixa facing north;
Etapas necessárias para que se start no middle of o base of uma caixa facing north;
Etapas necessárias para que se start at o center of o base of uma caixa facing north;
Etapas necessárias para que se start no center of o base of uma caixa facing north:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.
  Face north.

Etapas necessárias para que se start at o middle of o base of uma caixa facing south;
Etapas necessárias para que se start no middle of o base of uma caixa facing south;
Etapas necessárias para que se start at o center of o base of uma caixa facing south;
Etapas necessárias para que se start no center of o base of uma caixa facing south:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.
  Face south.

Etapas necessárias para que se start at o middle of o base of uma caixa facing west;
Etapas necessárias para que se start no middle of o base of uma caixa facing west;
Etapas necessárias para que se start at o center of o base of uma caixa facing west;
Etapas necessárias para que se start no center of o base of uma caixa facing west:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.
  Face west.

Etapas necessárias para que se start at o middle of o left of uma caixa facing east;
Etapas necessárias para que se start no middle of o left of uma caixa facing east;
Etapas necessárias para que se start at o center of o left of uma caixa facing east;
Etapas necessárias para que se start no center of o left of uma caixa facing east:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face east.

Etapas necessárias para que se start at o middle of o left of uma caixa facing north;
Etapas necessárias para que se start no middle of o left of uma caixa facing north;
Etapas necessárias para que se start at o center of o left of uma caixa facing north;
Etapas necessárias para que se start no center of o left of uma caixa facing north:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face north.

Etapas necessárias para que se start at o middle of o left of uma caixa facing south;
Etapas necessárias para que se start no middle of o left of uma caixa facing south;
Etapas necessárias para que se start at o center of o left of uma caixa facing south;
Etapas necessárias para que se start no center of o left of uma caixa facing south:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face south.

Etapas necessárias para que se start at o middle of o left of uma caixa facing west;
Etapas necessárias para que se start no middle of o left of uma caixa facing west;
Etapas necessárias para que se start at o center of o left of uma caixa facing west;
Etapas necessárias para que se start no center of o left of uma caixa facing west:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face west.

Etapas necessárias para que se start at o middle of o right of uma caixa facing east;
Etapas necessárias para que se start no middle of o right of uma caixa facing east;
Etapas necessárias para que se start at o center of o right of uma caixa facing east;
Etapas necessárias para que se start no center of o right of uma caixa facing east:
  Atribua a coordenada direita desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face east.

Etapas necessárias para que se start at o middle of o right of uma caixa facing north;
Etapas necessárias para que se start no middle of o right of uma caixa facing north;
Etapas necessárias para que se start at o center of o right of uma caixa facing north;
Etapas necessárias para que se start no center of o right of uma caixa facing north:
  Atribua a coordenada direita desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face north.

Etapas necessárias para que se start at o middle of o right of uma caixa facing south;
Etapas necessárias para que se start no middle of o right of uma caixa facing south;
Etapas necessárias para que se start at o center of o right of uma caixa facing south;
Etapas necessárias para que se start no center of o right of uma caixa facing south:
  Atribua a coordenada direita desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face south.

Etapas necessárias para que se start at o middle of o right of uma caixa facing west;
Etapas necessárias para que se start no middle of o right of uma caixa facing west;
Etapas necessárias para que se start at o center of o right of uma caixa facing west;
Etapas necessárias para que se start no center of o right of uma caixa facing west:
  Atribua a coordenada direita desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face west.

Etapas necessárias para que se start at o middle of o topo of uma caixa;
Etapas necessárias para que se start no middle of o topo of uma caixa;
Etapas necessárias para que se start at o center of o topo of uma caixa;
Etapas necessárias para que se start no center of o topo of uma caixa:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.

Etapas necessárias para que se start at o middle of o topo of uma caixa facing east;
Etapas necessárias para que se start no middle of o topo of uma caixa facing east;
Etapas necessárias para que se start at o center of o topo of uma caixa facing east;
Etapas necessárias para que se start no center of o topo of uma caixa facing east:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.
  Face east.

Etapas necessárias para que se start at o middle of o topo of uma caixa facing north;
Etapas necessárias para que se start no middle of o topo of uma caixa facing north;
Etapas necessárias para que se start at o center of o topo of uma caixa facing north;
Etapas necessárias para que se start no center of o topo of uma caixa facing north:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.
  Face north.

Etapas necessárias para que se start at o middle of o topo of uma caixa facing south;
Etapas necessárias para que se start no middle of o topo of uma caixa facing south;
Etapas necessárias para que se start at o center of o topo of uma caixa facing south;
Etapas necessárias para que se start no center of o topo of uma caixa facing south:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.
  Face south.

Etapas necessárias para que se start at o middle of o topo of uma caixa facing west;
Etapas necessárias para que se start no middle of o topo of uma caixa facing west;
Etapas necessárias para que se start at o center of o topo of uma caixa facing west;
Etapas necessárias para que se start no center of o topo of uma caixa facing west:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.
  Face west.

Etapas necessárias para que se start at o right of um horizontal line:
  Atribua o end desta horizontal line à localização deste context.

Etapas necessárias para que se start at uma localização:
  Atribua a localização à localização deste context.

Etapas necessárias para que se start at uma localização facing east:
  Atribua a localização à localização deste context.
  Face east.

Etapas necessárias para que se start at uma localização facing north:
  Atribua a localização à localização deste context.
  Face north.

Etapas necessárias para que se start at uma localização facing south:
  Atribua a localização à localização deste context.
  Face south.

Etapas necessárias para que se start at uma localização facing west:
  Atribua a localização à localização deste context.
  Face west.

Etapas necessárias para que se start at o topo left corner of uma caixa facing east:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face east.

Etapas necessárias para que se start at o topo left corner of uma caixa facing north:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face north.

Etapas necessárias para que se start at o topo left corner of uma caixa facing south:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face south.

Etapas necessárias para que se start at o topo left corner of uma caixa facing west:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face west.

Etapas necessárias para que se start at o topo of um vertical line:
  Atribua o start desta vertical line à localização deste context.

Etapas necessárias para que se start at o topo right corner of uma caixa facing east:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face east.

Etapas necessárias para que se start at o topo right corner of uma caixa facing north:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face north.

Etapas necessárias para que se start at o topo right corner of uma caixa facing south:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face south.

Etapas necessárias para que se start at o topo right corner of uma caixa facing west:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face west.

Etapas necessárias para que se start no middle of uma caixa facing east;
Etapas necessárias para que se start at o middle of uma caixa facing east;
Etapas necessárias para que se mova para o middle of uma caixa facing east;
Etapas necessárias para que se mova para o middle of uma caixa e face east;
Etapas necessárias para que se start no center of uma caixa facing east;
Etapas necessárias para que se start at o center of uma caixa facing east;
Etapas necessárias para que se mova para o center of uma caixa facing east;
Etapas necessárias para que se mova para o center of uma caixa e face east:
  Atribua o center desta caixa à localização deste context.
  Face east.

Etapas necessárias para que se start no middle of uma caixa facing north;
Etapas necessárias para que se start at o middle of uma caixa facing north;
Etapas necessárias para que se mova para o middle of uma caixa facing north;
Etapas necessárias para que se mova para o middle of uma caixa e face north;
Etapas necessárias para que se start no center of uma caixa facing north;
Etapas necessárias para que se start at o center of uma caixa facing north;
Etapas necessárias para que se mova para o center of uma caixa facing north;
Etapas necessárias para que se mova para o center of uma caixa e face north:
  Atribua o center desta caixa à localização deste context.
  Face north.

Etapas necessárias para que se start no middle of uma caixa facing north menos uns points;
Etapas necessárias para que se start no center of uma caixa facing north menos uns points:
  Atribua o center desta caixa à localização deste context.
  Face north.
  Vire left o points.

Etapas necessárias para que se start no middle of uma caixa facing south;
Etapas necessárias para que se start at o middle of uma caixa facing south;
Etapas necessárias para que se mova para o middle of uma caixa facing south;
Etapas necessárias para que se mova para o middle of uma caixa e face south;
Etapas necessárias para que se start no center of uma caixa facing south;
Etapas necessárias para que se start at o center of uma caixa facing south;
Etapas necessárias para que se mova para o center of uma caixa facing south;
Etapas necessárias para que se mova para o center of uma caixa e face south:
  Atribua o center desta caixa à localização deste context.
  Face south.

Etapas necessárias para que se start no middle of uma caixa facing west;
Etapas necessárias para que se start at o middle of uma caixa facing west;
Etapas necessárias para que se mova para o middle of uma caixa facing west;
Etapas necessárias para que se mova para o middle of uma caixa e face west;
Etapas necessárias para que se start no center of uma caixa facing west;
Etapas necessárias para que se start at o center of uma caixa facing west;
Etapas necessárias para que se mova para o center of uma caixa facing west;
Etapas necessárias para que se mova para o center of uma caixa e face west:
  Atribua o center desta caixa à localização deste context.
  Face west.

Etapas necessárias para que se start um process usando um endereço completo:
  \ must ser chamado com um global variável
  Limpe o erro do fluxo de entrada/saída.
  Se o process não for 0, atribua "Erro. Este processo já está sendo executado." ao erro do fluxo de entrada/saída; exit.
  Atribua a magnitude dessa startupinfo ao cb desta startupinfo.
  Extraia um endereço da pasta desde o endereço completo.
  Modifique através do caractere NUL o endereço da pasta.
  Isole o endereço completo. modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateProcessA" com 
    O first deste endereço completo 
    e 0 
    e 0 
    e 0 
    e 0 
    e 67108904 [CREATE_DEFAULT_ERROR_MODE + NORMAL_PRIORITY_CLASS + DETACHED_PROCESS] 
    e 0 
    e O first deste endereço da pasta 
    e O endereçamento desta startupinfo 
    e O endereçamento dessa PROCESS_INFORMATION 
    devolvendo um número.
  Se o número for 0, atribua "Erro. Não foi possível executar o programa." ao erro do fluxo de entrada/saída; exit.
  Atribua o hprocess deste PROCESS_INFORMATION ao process.
  Call "kernel32.dll" "CloseHandle" com 
    O hthread deste PROCESS_INFORMATION.
  Point um endereço de memória para rotina aguarde por um process endereço de memória. \redirecione
  Call "kernel32.dll" "CreateThread" com 0 
    e 0 
    e O endereço de memória 
    e O endereçamento deste process 
    e 0 
    e O endereçamento desse segundo número
    devolvendo um número identificador.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador. \ does not end o thread, just dumps o handle

Etapas necessárias para que se start um temporizador:
  Reset o temporizador.
  Restart o temporizador.

Etapas necessárias para que se start uns twips above o middle of o base of uma caixa:
    \ incomplete abra of these
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa menos os twips à coordenada y desta localização deste context.

Etapas necessárias para que se start uns twips para baixo desde uma localização;
Etapas necessárias para que se start uns twips below uma localização:
  Atribua a coordenada X desta localização ao x deste context.
  Atribua a coordenada Y desta localização mais os twips ao y deste context.

Etapas necessárias para que se start uns twips desde o center of uma caixa:
  Atribua o center desta caixa à localização deste context.
  Mova os twips.

Etapas necessárias para que se start uns twips para o left e uns segunda twips para baixo desde uma localização;
Etapas necessárias para que se start uns twips left e uns segunda twips para baixo desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.
  Atribua a coordenada Y desta localização mais a segunda twips ao y deste context.

Etapas necessárias para que se start uns twips left e uns segunda twips para cima desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.
  Atribua a coordenada Y desta localização menos a segunda twips ao y deste context.

Etapas necessárias para que se start uns twips para o left e uns segunda twips para cima desde uma localização;
Etapas necessárias para que se start uns twips para o left of uma localização;
Etapas necessárias para que se start uns twips left of uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.

Etapas necessárias para que se start uns twips para o right e uns segunda twips para baixo desde uma localização;
Etapas necessárias para que se start uns twips right e uns segunda twips para baixo desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste context.
  Atribua a coordenada Y desta localização mais a segunda twips ao y deste context.

Etapas necessárias para que se start uns twips para o right e uns segunda twips para cima desde uma localização;
Etapas necessárias para que se start uns twips right e uns segunda twips para cima desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste context.
  Atribua a coordenada Y desta localização menos a segunda twips ao y deste context.

Etapas necessárias para que se start uns twips para cima desde uma coordenada:
  Atribua a coordenada menos os twips ao y deste context.

Etapas necessárias para que se start uns twips para cima desde uma localização;
Etapas necessárias para que se start uns twips above uma localização:
  Atribua a coordenada Y desta localização ao y deste context.
  Subtraia os twips desde a coordenada Y deste context.

Etapas necessárias para que se carregue as bibliotecas padrão do sistema;
Etapas necessárias para que se start para cima:
  inicialize o Component Object Model.
  Inicialize winsock.
  Inicialize gdi+.
  Inicialize o talker.
  Inicialize o module.
  Inicialize as cors.
  Inicialize o tela.
  Inicialize a window.
  Inicialize as fonts.
  Inicialize os cursors.
  Inicialize o mouse.
  Inicialize os canvases.
  Inicialize o context.
  Initalize o terminal.
  Crie o console.

Etapas necessárias para que se start para cima o cgi:
  Inicialize winsock.
  Inicialize o module.
  Inicialize o cgi.

Etapas necessárias para que se start com uma cor:
  Atribua a cor à cor deste context.

Etapas necessárias para que se start com nada em um endereço de memória:
  Esvazie o endereço de memória.

O número identificador do fluxo de entrada padrão é um número identificador.

O número identificador do fluxo de saída padrão é um número identificador.

Etapas necessárias para que se suspenda um process:
  Se o process for 0, cancele.
  Call "kernel32.dll" "TerminateProcess" com 
    O process 
    e 0.
  Atribua 0 ao process.

Etapas necessárias para que se suspenda um temporizador:
  Se a contagem deste temporizador for 0, cancele.
  Subtraia 1 desde a contagem deste temporizador.
  Se a contagem deste temporizador não for 0, cancele.
  Atribua a contagem de ticks do sistema a uns ticks.
  Subtraia os start ticks deste temporizador desde o ticks.
  Adicione o ticks para os total ticks deste temporizador.

Uma string é um conjunto com 
  Um first endereço de memória do pedaço e 
  Um last endereço de memória do pedaço.

An conjunto de texto é uma coisa com uma string.

An string# é um número.

Etapas necessárias para que se pinte uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face north.
  Pinte a altura desta caixa.
  Vire right.
  Pinte a largura desta caixa.
  Vire right.
  Pinte a altura desta caixa.
  Vire right.
  Pinte a largura desta caixa.

Um subject é uma string.

    \Um substring é uma string.
Um subtexto é uma string.

Etapas necessárias para que se subtraia um pedaço desde um segundo pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8]  -> Salva o 1º byte (ebp+8) no registrador eax
  Intel $0FB600. \ movzx eax,[eax] -> ebp+8 é onde fica o valor do 1º argumento da função. ebp+12 é o 2º argumento
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> Salva o 2º byte (ebp+12) no registrador ebx
  Intel $2803. \ sub [ebx],al -> subtrai o 1º byte do 2º byte

Etapas necessárias para que se subtraia um pedaço desde um número:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> Salva o byte (ebp+8) no registrador eax
  Intel $0FB600. \ movzx eax,[eax] -> ebp+8 é onde fica o valor do 1º argumento da função. ebp+12 é o 2º argumento
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> Salva o número (ebp+12) no registrador ebx
  Intel $2903. \ sub [ebx],eax -> subtrai o byte do número

Etapas necessárias para que se subtraia uma fração desde uma segunda fração:
  Isole a fração.
  Normalize a fração e a segunda fração.
  Subtraia o numerador desta fração desde o numerador desta segunda fração.
  Reduce a segunda fração.

Etapas necessárias para que se subtraia um número e um segundo número desde um par de números:
  Subtraia o número desde o x deste par de números.
  Subtraia o segundo número desde o y deste par de números.

Etapas necessárias para que se subtraia um número desde um pedaço:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> Salva o número (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp+8 é onde fica o valor do 1º argumento da função. ebp+12 é o 2º argumento
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> Salva o byte (ebp+12) no registrador ebx
  Intel $0FB60B. \ movzx ecx,[ebx] -> Salva o endereço de ebx em ecx. E "zero extende", ou seja
  \se houver disparidade entre o valor do byte e do número e for preciso expandir a quantidade de bits,  o espaço restante é preenchido com zeros
  Intel $2BC8. \ sub ecx,eax -> subtrai o número do byte
  Intel $880B. \ mov [ebx],cl -> salva o valor no endereço de memória salvo no registrador ebx

Etapas necessárias para que se subtraia um número desde um fração:
  Subtraia o número / 1 desde a fração.

Etapas necessárias para que se subtraia um número desde um par de números:
  Subtraia o número desde o número X deste par de números.
  Subtraia o número desde o número Y deste par de números.

Etapas necessárias para que se subtraia um par de números desde uma segunda par de números:
  Subtraia o número X deste par de números desde o número X desta segunda par de números.
  Subtraia o número Y deste par de números desde o número Y desta segunda par de números.

Etapas necessárias para que se subtraia um endereço de memória desde um segundo endereço de memória;
Etapas necessárias para que se subtraia um número desde um endereço de memória;
Etapas necessárias para que se subtraia um número desde um segundo número:
  Intel $8B8508000000. \ mov eax,[ebp+8] -> Salva o 1º número/endereço (ebp+8) no registrador eax
  Intel $8B00. \ mov eax,[eax] -> ebp+8 é onde fica o valor do 1º argumento da função. ebp+12 é o 2º argumento
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] -> Salva o 2º número/endereço (ebp+12) no registrador ebx
  Intel $2903. \ sub [ebx],eax -> subtrai o 1º valor do 2º

Etapas necessárias para que se permute uma cor com uma segunda cor:
  Permute a matiz desta cor com a matiz desta segunda cor.
  Permute a saturação desta cor com a saturação desta segunda cor.
  Permute a luminosidade desta cor com a luminosidade desta segunda cor.

Etapas necessárias para que se permute um par de números com uma segunda par de números:
  Permute o número X deste par de números com o número X desta segunda par de números.
  Permute o número Y deste par de números com o número Y desta segunda par de números.

Etapas necessárias para que se permute um endereço de memória com um segundo endereço de memória;
Etapas necessárias para que se permute um número com um segundo número:
  Atribua o número a um terceiro número.
  Atribua o segundo número ao número.
  Atribua o terceiro número ao segundo número.

Etapas necessárias para que se permute uns coisas com uns segunda coisas:
  Permute o first destas coisas com o first destas segunda coisas.
  Permute o last destas coisas com o last destas segunda coisas.

Etapas necessárias para que se take off all o masking tape:
  Mostre tudo.

Etapas necessárias para que se take off algum tipo de masking tape:
  Mostre tudo.

Um talker é um endereço de memória para um talker object.

O talker é um talker.

Um talker object é um conjunto com um talker vtable denominado vtable.

Um talker vtable é um endereço de memória para um talker vtable conjunto.

O temp endereço completo é um endereço completo.

O terminal é um terminal.

Um terminal é uma coisa com 
  Uma caixa, 
  Uns quoras, 
  Uma output cor, 
  Uma input cor, e 
  Uma reply string.

O text cutoff é um número igual a 500.

An text é uma coisa com 
  Uma caixa,
  Uma origin,
  Um pincel cor,
  Uma font,
  Um alinhamento,
  Some  rows,
  Uma margin,
  Uma scale fração,
  Um wrap detector,
  Um horizontal scroll detector,
  Um vertical scroll detector,
  Uma seleção,
  Um detector de alteração,
  Uma última operação,
  Some texts denominado undos,
  Some texts denominado redos.

Uma coisa é um endereço de memória para uma coisa conjunto.

Uma coisa conjunto é um conjunto com 
  Uma next coisa e 
  Uma previous coisa.

Some coisas é um conjunto com 
  Uma first coisa e 
  Uma last coisa.

\An thousand é 10 hundreds.

An tick é um número.

Um temporizador é um conjunto com 
  Uma contagem, 
  Uns start ticks e 
  Uns total ticks.

Some times é um número. \ this é um fluke, I think -- see "suavize um polígono uns times"

  

Um topo é uns twips.

O tpi é uns twips igual a 1440.

O tpp é uns twips.

Etapas necessárias para que se trim uma string:
  Remove algum tipo de leading noise desde a string.
  Remove algum tipo de trailing noise desde a string.

Etapas necessárias para que se dê meia volta:
Etapas necessárias para que se vire around:
  Vire right 1/2.

Etapas necessárias para que se vire uma fração igual para um número over um segundo número:
  Atribua o número à coordenada superior desta fração.
  Atribua o segundo número à coordenada inferior desta fração.
  Vire a fração.

    \Etapas necessárias para que se vire uma fração do caminho;
Etapas necessárias para que se vire uma fração of o way;
Etapas necessárias para que se vire uma fração of o way around;
Etapas necessárias para que se vire uma fração:
  Se a fração for 1/1, cancele.
  Atribua 3840 times a fração mais a orientação deste context à orientação deste context.
  Normalize a orientação deste context.

Etapas necessárias para que se vire pra left;
Etapas necessárias para que se vire para a left;
    \Etapas necessárias para que se vire à left;
Etapas necessárias para que se vire left:
  Vire -1/4.

    \Etapas necessárias para que se vire à left uma fração igual para um número over um segundo número;
Etapas necessárias para que se vire pra left uma fração igual para um número over um segundo número;
Etapas necessárias para que se vire para a left uma fração igual para um número over um segundo número;
Etapas necessárias para que se vire left uma fração igual para um número over um segundo número:
  Atribua o número à coordenada superior desta fração.
  Atribua o segundo número à coordenada inferior desta fração.
  Vire left a fração.

    \Etapas necessárias para que se vire uma fração à left do caminho;
    \Etapas necessárias para que se vire uma fração pra left do caminho;
Etapas necessárias para que se vire uma fração para a left do caminho;
Etapas necessárias para que se vire left uma fração of o way;
Etapas necessárias para que se vire left uma fração of o way around;
Etapas necessárias para que se vire left um fração:
  Isole a fração.
  Negate a fração.
  Vire a fração.

    \Etapas necessárias para que se vire à left uns points;
Etapas necessárias para que se vire pra left uns points;
Etapas necessárias para que se vire para a left uns points;
Etapas necessárias para que se vire left uns points:
  Atribua o points e 3840 a um fração.
  Vire left a fração.

    \Etapas necessárias para que se vire à right;
Etapas necessárias para que se vire pra right;
Etapas necessárias para que se vire para a right;
Etapas necessárias para que se vire right:
  Vire 1/4.

    \Etapas necessárias para que se vire uns degrees à right;
    \Etapas necessárias para que se vire uns degrees pra right;
Etapas necessárias para que se vire uns degrees para a right;
Etapas necessárias para que se vire right uns degrees:
  Atribua o degrees times 10 e 3600 a um fração.
  Vire right a fração.

Etapas necessárias para que se vire uns degrees:
  Atribua o degrees times 10 e 3600 a um fração.
    \Se o degrees forem negative, vire left o fração; exit.
  Vire right a fração.

    \Etapas necessárias para que se vire à right uma fração igual para um número over um segundo número;
Etapas necessárias para que se vire pra right uma fração igual para um número over um segundo número;
Etapas necessárias para que se vire para a right uma fração igual para um número over um segundo número;
Etapas necessárias para que se vire right uma fração igual para um número over um segundo número:
  Atribua o número à coordenada superior desta fração.
  Atribua o segundo número à coordenada inferior desta fração.
  Vire right a fração.

    \Etapas necessárias para que se vire à right uma fração of o way;
Etapas necessárias para que se vire pra right uma fração of o way;
Etapas necessárias para que se vire para a right uma fração of o way;
Etapas necessárias para que se vire right uma fração of o way;
Etapas necessárias para que se vire right uma fração of o way around;
Etapas necessárias para que se vire right um fração:
  Vire a fração.

Etapas necessárias para que se vire right uma fração of o way uns percent of o time;
Etapas necessárias para que se vire right uma fração about uns percent of o time;
Etapas necessárias para que se vire right uma fração of o way about uns percent of o time;
Etapas necessárias para que se vire right uma fração uns percent of o time:
  Escolha aleatoriamente um número between 1 e 100.
  Se o número for maior do que o percent, cancele.
  Vire right a fração.

    \Etapas necessárias para que se vire uns points à right;
    \Etapas necessárias para que se vire uns points pra right;
Etapas necessárias para que se vire uns points para a right;
Etapas necessárias para que se vire right uns points:
  Atribua o points e 3840 a um fração.
  Vire right a fração.

Etapas necessárias para que se unassign um endereço de memória:
  Se o endereço de memória for inexistente, cancele.
  Call "kernel32.dll" "HeapFree" com 
    O endereço heap 
    e 0 [no options] e 
  o endereço de memória 
    devolvendo um número.
  Se o número for 0, cancele.
  Esvazie o endereço de memória.
  Subtraia 1 desde a contagem do heap.

An unit é um número.

Etapas necessárias para que se unlock um gpbitmap usando um bitmapdata:
  Call "gdiplus.dll" "GdipBitmapUnlockBits" com 
    O gpbitmap e 
  o endereçamento deste bitmapdata.

Etapas necessárias para que se mostre tudo:
  Call "gdi32.dll" "SelectClipRgn" com 
    O quadro atual 
    e 0.

Etapas necessárias para que se mostre dentro de uma caixa:
  Crie um hrgn usando a caixa.
  Mostre dentro de o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se mostre dentro de um elipse:
  Crie um hrgn usando a elipse.
  Mostre dentro de o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se mostre dentro de um hrgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual e 
  o hrgn e 2 [RGN_OR].

Etapas necessárias para que se mostre dentro de um polígono:
  Crie um hrgn usando o polígono.
  Mostre dentro de o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se mostre dentro de uma caixa arredondada:
  Crie um hrgn usando a caixa arredondada.
  Mostre dentro de o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se mostre fora de uma caixa:
  Crie um hrgn usando a caixa.
  Mostre fora de o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se mostre fora de um elipse:
  Crie um hrgn usando a elipse.
  Mostre fora de o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se mostre fora de um hrgn:
  Crie um old hrgn usando o zero caixa.
  Call "gdi32.dll" "GetClipRgn" com 
    O quadro atual e 
  o old hrgn 
    devolvendo um número.
  Se o número não for 1, limpe o old hrgn.
  Call "gdi32.dll" "SelectClipRgn" com 
    O quadro atual 
    e 0.
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hrgn 
    e 4 [RGN_DIFF].
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O old hrgn 
    e 2 [RGN_OR].
  Destrua o old hrgn.

Etapas necessárias para que se mostre fora de um polígono:
  Crie um hrgn usando o polígono.
  Mostre fora de o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se mostre fora de uma caixa arredondada:
  Crie um hrgn usando a caixa arredondada.
  Mostre fora de o hrgn.
  Destrua o hrgn.

Etapas necessárias para que se remova aspas de uma string:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, pare.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for as aspas duplas, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Se o first endereço de memória do pedaço deste subtexto é o last endereço de memória do pedaço deste subtexto, pare.
    Posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda string.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for as aspas duplas, adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua a segunda string à string.

Etapas necessárias para que se update o tela;
Etapas necessárias para que se mostre it;
Etapas necessárias para que se mostre it all;
Etapas necessárias para que se mostre reveal o canvas;
Etapas necessárias para que se atualize o tela:
  Atualize o tela usando a caixa desta tela.

Etapas necessárias para que se uppercase algum tipo de pedaços selecionados em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
    Uppercase o subtexto.
  Repita. [o código acima]

Etapas necessárias para que se uppercase um pedaço:
  Translate o pedaço using o tabela de caracteres maiúsculos ascii .

Etapas necessárias para que se translate um pedaço using um translation texto hexadecimal:
  Intel $8B8D08000000. \ mov ecx,[ebp+8] \ o endereço de memória do pedaço 
  Intel $8B01. \ mov eax,[ecx] \ o byte
  Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o tabela de tradução
  Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
  Intel $D7. \ xlat al,[ebx]
  Intel $8901. \ mov [ecx],eax

Etapas necessárias para que se uppercase o character depois de um finger e atribua it para uma string:
  Se o finger for inexistente, cancele.
  Atribua o conteúdo deste finger à string.
  Uppercase a string.

Etapas necessárias para que se uppercase uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Uppercase o conteúdo deste first endereço de memória do pedaço deste subtexto.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas necessárias para que se uppercase um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, pare.
    Uppercase a string deste row.
  Repita. [o código acima]
  Wrap o text.

An URL é uma string.

Um número de porta é um número.
Um nome de protocolo é uma string.
Um nome de host é uma string.
Um parâmetro de consulta é uma string.
Um endereço de recurso é uma string.

Um URL simplificada é um conjunto com
  Um nome do protocolo,\lpszScheme? dwFlags? 
  \exemplo: http / ftp / https / etc
  Um nome de host, \lpszHostName ?  
  \exemplo: www.google.com ou mail.stackoverflow.com
  Um endereço de recurso, \lpszUrlPath?
  \ exemplo: index.html ou /css/style.css ou questions/SubmitQuestion.aspx
  Um parâmetro de consulta, \lpszExtraInfo?
  \ exemplo: ?useLiveData=1&internal=0
  Um número de porta. \ nPort?
  \números de porca ocupam (geralmente) 16 bits

Etapas necessárias para que se use uma cor:
  Atribua a cor à cor deste context.

Etapas necessárias para que se use o pincel grosso:
  Atribua 3 ao grossura do pincel.

Etapas necessárias para que se use um tamanho da letra:
  Atribua o tamanho da letra à tamanho da letra deste context.

Etapas necessárias para que se use um tamanho da letra of uns twips:
  Atribua os twips ao tamanho da letra.
  Atribua os twips à tamanho da letra deste context.

Etapas necessárias para que se use um pincel:
  Atribua o pincel ao pincel deste context.

Etapas necessárias para que se use o skinny pincel:
  Atribua 1 ao grossura do pincel.

Etapas necessárias para que se use small pointy letras:
    \ como opposed para "roundy letras" not yet implemented
  Use small letras.

Um vértice array é um endereço de memória para um vértice array conjunto.

Um vértice array conjunto é um conjunto com 
  Uma contagem e 
  Uma localização endereço de memória.

Um vértice é uma coisa com 
  Uma coordenada X, 
  Uma coordenada Y, 
  Uma localização at a coordenada X.

Um w-param é um número.

Etapas necessárias para que se aguarde por um event;
Etapas necessárias para que se desenfileire um event:
  Yield para windows.
  Atribua o first desta fila de eventos ao event.
  Se o event for inexistente, repita.
  Remove o event desde a fila de eventos.
  Se a categoria deste event for "fechamento do programa", destrua o event; exit.
  Destrua o evento atual.
  Atribua o event ao evento atual.

Etapas necessárias para que se aguarde uns milliseconds;
Etapas necessárias para que se espere uns milliseconds;
Etapas necessárias para que se aguarde por uns milliseconds:
  Se o milliseconds forem menor do que ou igual para 0, cancele.
  Call "kernel32.dll" "Sleep" com os milliseconds. \ https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep

Etapas necessárias para que se aguarde por uma tecla para come back para cima:
  Se a tecla estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde por uma tecla para come para cima:
  Se a tecla estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde por uma tecla para go para baixo:
  Se a tecla não estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde sobre that there tecla com o ESC sobre it:
  Aguarde pela tecla Esc.

Etapas necessárias para que se aguarde until speaking é done:
  Se o talker for inexistente, cancele.
  Call o WaitUntilDone  desta vtable [SpVoice] deste talker com o talker e -1.

Etapas necessárias para que se aguarde until we hit um tecla;
Etapas necessárias para que se aguarde por uma tecla;
Etapas necessárias para que se aguarde uma tecla ser pressionada;
Etapas necessárias para que se aguarde uma tecla:
  Aguarde pela tecla para go para baixo.
  Aguarde pela tecla para come para cima.
  Desmanche all events.

Um wave file é um endereço completo.

Um wave é um texto hexadecimal.

Uma wide string é uma string.

Uma largura é uns twips.

Um palavra é um subtexto.

Etapas necessárias para que se wrap um text:
  Se o text for inexistente, cancele.
  Se o wrap detector deste text não estiver ativo, cancele.
  Converta o anchor deste text para um posicionamento absoluto usando o text.
  Converta o caret deste text para uma segunda posicionamento absoluto usando o text.
  Atribua a scale deste text a um fração.
  Redimensione proporcionalmente o text para 1/1.
  Extraia uma string desde o text.
  Posponha o return pedaço para a string.
  Destrua as rows deste text.
  Lance um percorredor sobre a string.
  Crie o número da fonte of o memory canvas usando o font deste text.
  Percorra. [o código abaixo]
    Mova o percorredor usando a caixa deste text (word wrapping rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma row usando o segmento inicial deste percorredor.
    Posponha a row para as rows deste text.
  Repita. [o código acima]
  Destrua o número da fonte of o memory canvas.
  Renumber as rows deste text.
  Redimensione proporcionalmente o text para a fração.
  Converta o posicionamento absoluto para o anchor deste text usando o text.
  Converta a segunda posicionamento absoluto para o caret deste text usando o text.
  Limite o origin of o text.

Etapas necessárias para que se store um trecho em um file;
Etapas necessárias para que se escreva um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" com 
    O file 
    e 0 
    e 0 
    e 0 [FILE_BEGIN] 
    devolvendo um result número.
  Se o result número for -1, atribua "Ocorreu um erro durante o posicionamento do ponteiro do arquivo." ao erro do fluxo de entrada/saída; exit.
  Call "kernel32.dll" "WriteFile" com 
    O file e 
  o first endereço de memória do pedaço deste trecho 
    e A quantidade de caracteres deste trecho 
    e O endereçamento desse número 
    e 0 
    devolvendo o result número.
  Se o result número for 0, atribua "Ocorreu um erro durante a gravação do arquivo." ao erro do fluxo de entrada/saída; exit.

Etapas necessárias para que se store um trecho em um endereço completo;
Etapas necessárias para que se escreva um trecho para um endereço completo:
  Limpe o erro do fluxo de entrada/saída.
  Extraia um endereço da pasta desde o endereço completo.
  Se o endereço da pasta não estiver no sistema de arquivos, atribua "A pasta: " junto com o endereço da pasta seguido de " não existe." ao erro do fluxo de entrada/saída; exit.
  Defina o endereço completo para read-write mode.
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com 
    O first deste endereço completo 
    e 1073741824 [GENERIC_WRITE] 
  And 0 e 0 e 2 [CREATE_ALWAYS] 
    e -2147483520 [FILE_FLAG_WRITE_THROUGH ou FILE_ATTRIBUTE_NORMAL] 
    e 0 
    devolvendo um número identificador.
  Se o número identificador for -1 [INVALID_HANDLE_VALUE], atribua "Ocorreu um erro ao tentar abrir o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.
  Call "kernel32.dll" "WriteFile" com 
    O número identificador 
    e O first endereço de memória do pedaço deste trecho 
    e A quantidade de caracteres deste trecho 
    e O endereçamento desse número 
    e 0 
    devolvendo o número.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro ao tentar salvar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas necessárias para que se escreva um pedaço:
  Atribua o pedaço a uma string.
  Escreva a string.

Etapas necessárias para que se escreva um pedaço para stdout:
  Call "kernel32.dll" "WriteFile" com 
    O stdout handle 
    e O endereçamento deste pedaço 
    e 1 
    e O endereçamento desse número 
    e nil.

Etapas necessárias para que se escreva um pedaço sem passar pra próxima linha:
  Atribua o pedaço a uma string.
  Escreva a string sem passar pra próxima linha.

     \ will translate para English because "Converta um detector" é used para externalize reams pelo caderno
Etapas necessárias para que se escreva um detector:
  Converta o detector para uma string.
  Escreva a string.

Etapas necessárias para que se escreva um detector sem passar pra próxima linha:
  Converta o detector para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas necessárias para que se escreva um fração:
  Converta a fração para uma string.
  Escreva a string.

Etapas necessárias para que se escreva uma fração sem passar pra próxima linha:
  Converta a fração para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas necessárias para que se escreva um número:
  Converta o número para uma string.
  Escreva a string.

Etapas necessárias para que se escreva um número sem passar pra próxima linha:
  Converta o número para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas necessárias para que se escreva um número sobre um console:
  Converta o número para uma string.
  Escreva a string sobre o console.

Etapas necessárias para que se escreva uns quoras em uma caixa: \descomentar pra ver o que acontece
    \Pinte a caixa com a cor vermelha e a cor preta. \ temp ***
  Atribua a caixa a um quora caixa.
  Atribua a coordenada superior desta quora caixa mais 24 pixels à coordenada inferior desta quora caixa.
  Percorra. [o código abaixo]
    Obtenha um quora desde o quoras.
    Se o quora for inexistente, pare.
    \pinte really fast. ***
    \ Pinte o quora caixa com a cor amarela. \ temp ***
    Escreva a string deste quora no quora caixa com a cor deste quora.
    Mova o quora caixa para baixo 24 px.
  Repita. [o código acima]

Etapas necessárias para que se escreva uma string;
Etapas necessárias para que se pinte uma string:
  Isole a string.
  Percorra. [o código abaixo]
  Se a string estiver em branco, cancele.
    Obtenha um pedaço desde a string.
    Pinte o pedaço.
    Se a string não estiver em branco, providencie espaçamento adequado entre caracteres.
  Repita. [o código acima]

Etapas necessárias para que se escreva uma string around um center localização at um raio;
Etapas necessárias para que se escreva uma string usando um center localização e um raio;
Etapas necessárias para que se pinte uma string around um center localização at um raio;
Etapas necessárias para que se pinte uma string usando um center localização e um raio:
  Isole a string.
  Atribua 1 e a quantidade de caracteres desta string a uma fração.
  Percorra. [o código abaixo]
    Se a string estiver em branco, cancele.
    Obtenha um pedaço desde a string.
    Start at o center localização.
    Mova o raio.
    Pinte o pedaço.
    Vire a fração.
  Repita. [o código acima]

Etapas necessárias para que se escreva uma string at uma localização com uma cor:
    \Etapas necessárias para que se pinte uma string at uma localização com uma cor:
  Start at a localização.
  Atribua a cor à cor deste context.
  Pinte a string.

Etapas necessárias para que se escreva uma string sobre um console:
  Se o console for inexistente, cancele.
  Insira a string ao text deste console.
  Insira o return pedaço ao text deste console.
  Wrap o text deste console.
  Role o text deste console para o caret.
  Mostre o console.

Etapas necessárias para que se escreva uma string para um console sem passar pra próxima linha;
Etapas necessárias para que se escreva uma string sobre um console sem passar pra próxima linha:
  Se o console for inexistente, cancele.
  Insira a string ao text deste console.
  Wrap o text deste console.
  Role o text deste console para o caret.
  Mostre o console.

Etapas necessárias para que se escreva uma string em uma caixa:
    \Etapas necessárias para que se pinte uma string em uma caixa:
  Pinte a string na caixa com a cor deste context.

Etapas necessárias para que se escreva uma string em uma caixa com uma cor:
    \Etapas necessárias para que se pinte uma string em uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Atribua a altura desta caixa dividido por 2 à tamanho da letra deste context.
    \Atribua a altura desta caixa à tamanho da letra deste context.
  Face north.
  Mova a altura desta caixa dividido por 4. \ was 4 e still é now! ***
  Pinte a string.

Etapas necessárias para que se escreva uma string no middle of uma caixa;
Etapas necessárias para que se pinte uma string no middle of uma caixa:
  Atribua a tamanho da letra deste context dividido por 4 a um square size. \ was 4 ***
    \ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
  Atribua a quantidade de caracteres desta string times o square size times 3 menos o square size a um largura.
  Divida o largura por 2.
  Start no middle of a caixa.
  Mova para baixo a tamanho da letra deste context dividido por 2. \ was 2 ***
  Mova left o largura.
  Face north.
  Pinte a string.

Etapas necessárias para que se escreva uma string no middle of o tela:
  Pinte a string no middle of a caixa desta tela.
  Atualize o tela.

Etapas necessárias para que se escreva uma string sobre um terminal:
  Se o terminal for inexistente, cancele.
  Adicione um quora para o terminal.
  Atribua a string à string deste quora.
  Atribua a output cor deste terminal à cor deste quora.
  Mostre o terminal.

Etapas necessárias para que se escreva uma string um raio away desde um center localização;
Etapas necessárias para que se escreva uma string um raio around um center localização;
Etapas necessárias para que se escreva uma string about um raio desde um center localização;
Etapas necessárias para que se escreva uma string um raio desde um center localização;
Etapas necessárias para que se pinte uma string um raio away desde um center localização;
Etapas necessárias para que se pinte uma string um raio around um center localização;
Etapas necessárias para que se pinte uma string about um raio desde um center localização;
Etapas necessárias para que se pinte uma string um raio desde um center localização:
  Pinte a string usando o center localização e o raio.

Etapas necessárias para que se escreva uma string um raio away desde o middle of uma caixa;
Etapas necessárias para que se escreva uma string um raio around o middle of uma caixa;
Etapas necessárias para que se escreva uma string about um raio desde o middle of uma caixa;
Etapas necessárias para que se escreva uma string um raio desde o middle of uma caixa;
Etapas necessárias para que se pinte uma string um raio away desde o middle of uma caixa;
Etapas necessárias para que se pinte uma string um raio around o middle of uma caixa;
Etapas necessárias para que se pinte uma string about um raio desde o middle of uma caixa;
Etapas necessárias para que se pinte uma string um raio desde o middle of uma caixa:
  Pinte a string usando o center desta caixa e o raio.

Etapas necessárias para que se escreva uma string para stdout:
  Call "kernel32.dll" "WriteFile" com 
    O stdout handle 
    e O first endereço de memória do pedaço desta string 
    e A quantidade de caracteres desta string 
    e O endereçamento desse número 
    e nil.

Etapas necessárias para que se escreva uma string while turning uma fração of o way;
Etapas necessárias para que se escreva uma string while turning uma fração of o way around;
Etapas necessárias para que se escreva uma string while turning um fração;
Etapas necessárias para que se pinte uma string while turning uma fração of o way;
Etapas necessárias para que se pinte uma string while turning uma fração of o way around;
Etapas necessárias para que se pinte uma string while turning um fração:
  Isole a string.
  Percorra. [o código abaixo]
    Se a string estiver em branco, cancele.
    Obtenha um pedaço desde a string.
    Pinte o pedaço.
    Vire a fração.
    Se a string não estiver em branco, providencie espaçamento adequado entre caracteres.
  Repita. [o código acima]

Etapas necessárias para que se escreva uma string com uma cor;
Etapas necessárias para que se pinte uma string com uma cor:
  Atribua a cor à cor deste context.
  Pinte a string.

Etapas necessárias para que se escreva uma string com uma cor at o base of uma caixa;
Etapas necessárias para que se pinte uma string com uma cor at o base of uma caixa:
  Atribua a tamanho da letra deste context dividido por 4 a um square size. \ ***
    \ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
  Atribua a quantidade de caracteres desta string times o square size times 3 menos o square size a um largura.
  Divida o largura por 2.
  Start no middle of o base of a caixa.
  Mova para cima a tamanho da letra deste context times 2. \ was sem o times 2 ***
  Mova left o largura.
  Face north.
  Pinte a string com a cor.

Etapas necessárias para que se escreva uma string com uma cor at o topo of uma caixa;
Etapas necessárias para que se pinte uma string com uma cor at o topo of uma caixa:
  Atribua a tamanho da letra deste context dividido por 4 a um square size. \ ***
    \ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
  Atribua a quantidade de caracteres desta string times o square size times 3 menos o square size a um largura.
  Divida o largura por 2.
  Start no middle of o topo of a caixa.
  Mova para baixo a tamanho da letra deste context times 4. \ was times 2 ***
  Mova left o largura.
  Face north.
  Pinte a string com a cor.

Etapas necessárias para que se escreva uma string com uma cor no middle of uma caixa;
Etapas necessárias para que se pinte uma string com uma cor no middle of uma caixa:
  Atribua a tamanho da letra deste context dividido por 4 a um square size. \ was 4 ***
    \ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
  Atribua a quantidade de caracteres desta string times o square size times 3 menos o square size a um largura.
  Divida o largura por 2.
  Start no middle of a caixa.
  Mova para baixo a tamanho da letra deste context dividido por 2. \ was 2 ***
  Mova left o largura.
  Face north.
  Pinte a string com a cor.

Etapas necessárias para que se escreva uma string com uma cor um raio away desde um center localização;
Etapas necessárias para que se escreva uma string com uma cor um raio around um center localização;
Etapas necessárias para que se escreva uma string com uma cor about um raio desde um center localização;
Etapas necessárias para que se escreva uma string com uma cor um raio desde um center localização;
Etapas necessárias para que se pinte uma string com uma cor um raio away desde um center localização;
Etapas necessárias para que se pinte uma string com uma cor um raio around um center localização;
Etapas necessárias para que se pinte uma string com uma cor about um raio desde um center localização;
Etapas necessárias para que se pinte uma string com uma cor um raio desde um center localização:
  Atribua a cor à cor deste context.
  Pinte a string usando o center localização e o raio.

Etapas necessárias para que se escreva uma string com uma cor uns twips para baixo desde o topo of uma caixa;
Etapas necessárias para que se escreva uma string com uma cor uns twips para baixo desde o topo center of uma caixa;
Etapas necessárias para que se pinte uma string com uma cor uns twips para baixo desde o topo of uma caixa;
Etapas necessárias para que se pinte uma string com uma cor uns twips para baixo desde o topo center of uma caixa:
  Atribua a tamanho da letra deste context dividido por 4 a um square size. \ was 4 ***
    \ caracteres são two squares wide mais one square of intercharacter spacing. no spacing at o end.
  Atribua a quantidade de caracteres desta string times o square size times 3 menos o square size a um largura.
  Divida o largura por 2.
  Start no middle of o topo of a caixa.
  Mova para baixo os twips.
  Mova left o largura.
  Face north.
  Pinte a string com a cor.

Etapas necessárias para que se escreva uma string com uma font e um size e uma cor e uma localização:
  Atribua o size à altura desta font.
  Atribua o largura desta string a um largura.
  Atribua a localização e a localização a uma caixa.
  Subtraia o largura dividido por 2 desde a coordenada esquerda desta caixa.
  Adicione o largura dividido por 2 para a coordenada direita desta caixa.
  Subtraia o size dividido por 2 desde a coordenada superior desta caixa.
  Adicione o size dividido por 2 para a coordenada inferior desta caixa.
  Pinte a string na caixa com a cor e o font e "center".
  Atualize o tela.

Etapas necessárias para que se use letras de tamanho grande;
Etapas necessárias para que se escreva com letras grandes;
Etapas necessárias para que se escreva com letras de tamanho grande;
Etapas necessárias para que se use letras grandes:
  Atribua o tamanho de letra grande ao tamanho da letra deste context.

Etapas necessárias para que se use letras de tamanho médio;
Etapas necessárias para que se use letras de tamanho regular;
Etapas necessárias para que se escreva com letras de tamanho médio;
Etapas necessárias para que se escreva com letras de tamanho normal;
Etapas necessárias para que se escreva com letras de tamanho regular;
Etapas necessárias para que se use letras de tamanho normal:
  Atribua o tamanho de letra médio à tamanho da letra deste context.

Etapas necessárias para que se use letras de tamanho pequeno;
Etapas necessárias para que se escreva com letras pequenas;
Etapas necessárias para que se escreva com letras de tamanho pequeno;
Etapas necessárias para que se use letras pequenas:
  Atribua o tamanho de letra pequena ao tamanho da letra deste context.

Uma word é um conjunto com 
  Um pedaço inicial [high byte] e 
  Um pedaço final [low byte].

Um máscara de disjunção exclusiva é um mask.

Etapas necessárias para que se yield para windows:
  Se a fila de eventos não for vazio, cancele.
  Call "user32.dll" "GetMessageA" com 
    O endereçamento dessa msg 
    e 0 
    e 0 
    e 0 
    devolvendo um número.
  Se o número for 0, cancele.
  Call "user32.dll" "TranslateMessage" com 
    O endereçamento desta msg.
  Call "user32.dll" "DispatchMessageA" com 
    O endereçamento desta msg.

Etapas necessárias para que se zero uma caixa:
    \ was clear uma caixa, got confounded com "clear uma caixa " (which deveria pinte a caixa all black como does "clear o tela")
  Atribua 0 à coordenada esquerda desta caixa.
  Atribua 0 à coordenada superior desta caixa.
  Atribua 0 à coordenada direita desta caixa.
  Atribua 0 à coordenada inferior desta caixa.

O zero caixa é uma caixa.

Etapas necessárias para que se zero fill um número usando uma contagem e posponha it para uma string:
  Converta o número para uma segunda string.
  Zero fill a segunda string usando a contagem.
  Posponha a segunda string para a string.

Etapas necessárias para que se zero fill uma string usando uma contagem:
  Se a quantidade de caracteres desta string for maior do que ou igual à contagem, cancele.
  Anteponha o número zero para a string.
  Repita. [o código acima]

O zero line é um line. \ tracer

O zero localização é uma localização.

Um tabela de tradução é um texto hexadecimal.

O tabela ascii é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF.

O tabela de caracteres minúsculos s/ acento ascii é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F406162636465666768696A6B6C6D6E6F707172737475767778797A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788899A8B9C8D9E8F909192939495969798999A9B9C9D9E79A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF616161616161E6636565656569696969F06E6F6F6F6F6FD7F87575757579FEDF616161616161E6636565656569696969F06E6F6F6F6F6FF7F87575757579FE79.

O tabela de caracteres minúsculos ascii é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F406162636465666768696A6B6C6D6E6F707172737475767778797A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788899A8B9C8D9E8F909192939495969798999A9B9C9D9EFFA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6D7F8F9FAFBFCFDFEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF.

O tabela de caracteres maiúsculos ascii é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F604142434445464748494A4B4C4D4E4F505152535455565758595A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798998A9B8C9D8E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6F7D8D9DADBDCDDDE9F.

An twip é um número.
    \ Twip (em inglês "Twentieth of a Point" ou "um vinte avos de um ponto") é uma medida tipográfica. 
    \Também usada como medida padrão no Visual Basic 6 e outras versões anteriores 
    \quando no modo "Fontes pequenas" do Windows, 15 twips são iguais a um pixel, e 567 twips equivale a 1 cm ou 17.64 µm
    \ Twips são unidades independentes de tela para garantir que a proporção dos elementos da tela seja a mesma em todos os sistemas de exibição. 
    \Um TWIP é definida como sendo 1 / 1440 de uma polegada (cerca de 0,0176 milímetros).
Um pixel são 15 twips.
  Uns pixels são 15 twips.
Um px são 15 twips.
  Uns pxs são 15 twips.
Um píxel são 15 twips.
An inch são 1440 twips.
Uma polegada são 1440 twips.
    \ Um twip seriam 1,76389 milímetros
    \900.000 twips dá 625 polegadas
    \Um cm é 56693/100 twips. \ O certo seira 567 / 566,93 cm 
    \Um centímetro é 56693/100 twips.
Um cm são 254/100 polegadas.
Um centímetro são 254/100 polegadas.
Um mm é 1/10 centímetros. \ creio que pela lógica seriam 56,7
Um milímetro é 1/10 centímetros. \
Um micrômetro é 1/1000 milímetros. 
Um metro são 100 centímetros.
    \Um m são 100 centímetros.
    \Um km são 1000 metros.
    \Um quilômetro são 1000 metros.
    \Um kilômetro são 1000 metros.

O erro do fluxo de entrada/saída é uma string.

Uma unidade é um número.
Uma dezena são 10 unidades.
Uma centena são 10 dezenas.
Um milhar são 10 centenas.
Um milhão são 1000 milhares.
Um bilhão são 1000 milhões.

Um milisegundo é um número.
Um segundo são 1000 milisegundos.
Um minuto são 60 segundos.
Uma hora são 60 minutos.
Um dia são 24 horas.