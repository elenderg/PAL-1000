\ O Cérebro - A Sociedade Osmosiana de Programadores de Linguagens Naturais - desde 2006.

\ Regras de campos de texto:
\ No geral, cada linha deve terminar com um ponto final.
\ As exceções são quando você está declarando uma variável do tipo conjunto, 
\ (que costumam terminar com uma vírgula, exceto no final)
\ Ou quando você estiver declarando um cabeçalho de rotina (que termina com sinal de dois pontos)
\ Quando um campo de texto é convertido para texto puro, 
\ o caractere especial LF é adicionado depois do caractere especial CR
\ Já quando um texto é transformado em um campo de texto, o caractere LF é removido.
\ Existe sempre uma linha, no mínimo.
\ Existe sempre um caractere CR no fim da ultima linha.

\Etapas necessárias para que se inicialize o Component Object Model:
\Mande os códigos 0 e 2 para a função "CoInitializeEx" da biblioteca "ole32.dll" [coinit_aparthreaded].

O alarme de ignição é um alarme igual a 1.

O sinal de desligamento é um alarme igual a 0.

O tecla A/a é uma tecla igual a 65.

Um abc é um conjunto with um número called abca, um número called abcb, um número called abcc.

Um abc endereço de memória é um endereço de memória para um abc.

Um abca é um número.

Um abcc é um número.

Um posicionamento absoluto é um número.

O acento grave é um pedaço igual a 96.
O acento crase é um pedaço igual a 96.

O tecla VK_OEM_3 é uma tecla igual a 192. \\ Essa tecla depende do teclado do fabricante, e do idioma do teclado. Nos estados unidos é a tecla que fica em cima da tecla Tab

O pedaço de confirmação [ACK] é um pedaço igual a 6.

O acento agudo é um pedaço igual a 180.

Etapas necessárias para que se adicione um pedaço para uma segunda pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda byte
Intel $0003. \ adicione [ebx],al

Etapas necessárias para que se adicione um pedaço para um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
Intel $0103. \ adicione [ebx],eax


Etapas necessárias para que se adicione uma fração para uma segunda fração:
Isole a fração.
Normalize a fração e a segunda fração.
Adicione o numerador desta fração para o numerador desta segunda fração.
Reduce a segunda fração.

Etapas necessárias para que se adicione alguns horizontal twips e alguns vertical twips para o current spot:
Adicione o horizontal twips para o x deste spot deste context.
Adicione o vertical twips para o y deste spot deste context.

Etapas necessárias para que se adicione uma line para uma figura:
Se o figura for inexistente, crie a figura; posponha a figura para a figuras.
Adicione o start desta line para a figura.
Adicione o end desta line para a figura.

Etapas necessárias para que se adicione um name para alguns choices:
Allocate memory por uma choice.
Atribua o name ao name desta choice.
Atribua a choice at o end of as choices.

Etapas necessárias para que se adicione um número e uma segunda número para um pair:
Adicione o número para o número x deste pair.
Adicione o segunda número para o número y deste pair.

Etapas necessárias para que se adicione um número para uma segunda número e um terceiro número para um quarto número:
Adicione o número para o segunda número.
Adicione o terceiro número para o quarto número.

Etapas necessárias para que se adicione um número para um pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
Intel $0FB60B. \ movzx ecx,[ebx]
Intel $03C8. \ adicione ecx,eax
Intel $880B. \ mov [ebx],cl

Etapas necessárias para que se adicione um número para um fração:
Adicione o número / 1 para a fração.

Etapas necessárias para que se adicione um número para um pair:
Adicione o número para o número x deste pair.
Adicione o número para o número y deste pair.


Etapas necessárias para que se adicione um número para um endereço de memória;
Etapas necessárias para que se adicione um número para uma segunda número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda número
Intel $0103. \ adicione [ebx],eax

Etapas necessárias para que se adicione um pair para uma segunda pair:
Adicione o número x deste pair para o número x deste segunda pair.
Adicione o número y deste pair para o número y deste segunda pair.

Etapas necessárias para que se adicione um pdf object usando um categoria:
Crie o pdf object usando o categoria.
Posponha o pdf object para os objects deste pdf state.
Adicione 1 para o object número deste pdf state.
Atribua o object número deste pdf state ao número deste pdf object.

Etapas necessárias para que se adicione um quora para um terminal:
Crie o quora.
Posponha o quora para o quora deste terminal.
Se o terminal não estiver full, cancele.
Atribua o first destes quoras deste terminal A um doomed quora.
Remove o doomed quora from os quoras deste terminal.
Destroy o doomed quora.

Etapas necessárias para que se adicione um spot para um figura:
Append o spot para a figura.

Etapas necessárias para que se adicione um string para alguns conjunto de textos:
Crie um conjunto de texto usando o string.
Posponha o conjunto de texto para o conjunto de textos.

Um addrinfo é um conjunto with
Um número called ai_flags,
Um número called ai_family,
Um número called ai_sockettype,
Um número called ai_protocol,
Um número called ai_addrlen,
Um pchar called ai_canonname,
Um sockaddrptr called ai_addr,
Um addrinfoptr called ai_next.

Some addrinfo routines é um conjunto with
Um getaddrinfo endereço de memória,
Um freeaddrinfo endereço de memória.

Um addrinfoptr é um endereço de memória para um addrinfo.

Etapas necessárias para que se ajuste um caixa usando um número e uma segunda número e um terceiro número e um quarto número:
Adicione o número para o left desta caixa.
Adicione o segunda número para o topo desta caixa.
Adicione o terceiro número para o right desta caixa.
Adicione o quarto número para a base desta caixa.

Etapas necessárias para que se ajuste um item:
Atribua os dwfileattributes deste win32finddata deste item A um número.
Conjuncione logicamente o número with 16 [file_attribute_directory].
Se o número for 0, atribua "file" à categoria deste item. \; atribua "arquivo" à classe deste item.
Se o número não for 0, atribua "endereço de pasta" à categoria deste item.\; atribua "directorio" à classe deste item.
Convert o ftcreationtime deste win32finddata deste item para a creation date/time string deste item . \ adicionado para classificação de e-mails.
Atribua o whereabouts deste cfilename deste win32finddata deste item A um pchar.
Convert o pchar para o designador deste item.
Se a categoria deste item for "endereço de pasta", posponha "\" para o designador deste item.
Atribua o endereço da pasta deste item then o designador deste item ao endereço completo deste item.
Extract a extensão deste item from o designador deste item como um endereço completo.
Atribua o nfilesizelow deste win32finddata deste item ao size deste item.
Se o target deste first deste designador deste item não for o ponto final, cancele.
Obtenha o item (not first time).

Etapas necessárias para que se ajuste um line with um número e uma segunda número e um terceiro número e um quarto número:
Adicione o número para o x deste start desta line.
Adicione o segunda número para o y deste start desta line.
Adicione o terceiro número para o x deste end desta line.
Adicione o quarto número para o y deste end desta line.

Etapas necessárias para que se ajuste um picture (extract caixas from gpbitmap):
Se o picture for inexistente, cancele.
Atribua 0 ao left desta caixa desta picture.
Atribua 0 ao topo desta caixa desta picture.
Atribua a width deste gpbitmap desta picture menos 1 times o tpp ao right desta caixa desta picture.
Atribua a altura deste gpbitmap desta picture menos 1 times o tpp à base desta caixa desta picture.
Atribua a caixa desta picture à uncropped caixa desta picture.

Etapas necessárias para que se ajuste spacing usando um string:
Se o quadro atual não for o printer canvas, cancele.
Call "gdi32.dll" "SetTextCharacterExtra" with o printer canvas e 0. \quero traduzir esse comando como: Mande o printer canvas e o código 0 para a função "SetTextCharacterExtra" da biblioteca "gdi32.dll".
Call "gdi32.dll" "GetCurrentObject" with o printer canvas e 6 [obj_font] returning um handle.
Call "gdi32.dll" "SelectObject" with o memory canvas e o handle.
Obtenha um width usando o string e o memory canvas.
Call "gdi32.dll" "SelectObject" with o memory canvas e o null hfont.
Obtenha uma segunda width usando o string e o printer canvas.
Atribua o width menos o segunda width dividido pelo length deste string A um número.
Call "gdi32.dll" "SetTextCharacterExtra" with o printer canvas e o número.

Etapas necessárias para que se align um text usando um alinhamento:
Atribua o alinhamento ao alinhamento deste text.

Um alinhamento é um string [center, left, ou right].

O tecla Alt é uma tecla igual a 18.

Um quantia é um número.

O & comercial é um pedaço igual a 38.
O símbolo & é um pedaço igual a 38.
O sinal & é um pedaço igual a 38.
O & é um pedaço igual a 38.
O sinal tironiano é um pedaço igual a 38.

Um anchor é um position.

Um máscara de conjunção lógica é uma mask.

Um ângulo é alguns precise degrees [0 para 3599].

Etapas necessárias para que se posponha um trecho para um file:
Limpe o i/o erro.
Call "kernel32.dll" "SetFilePointer" with o file e 0 e 0 e 2 [file_end] returning um result número.
Se o result número é -1, atribua "Ocorreu um erro na hora de posicionar o ponteiro do arquivo." ao i/o erro; exit.
Call "kernel32.dll" "WriteFile" with o file e o first deste trecho e o length deste trecho e um whereabouts desse número e 0 returning o result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de salvar o arquivo." ao i/o erro; exit.

Etapas necessárias para que se posponha um pedaço para um string:
Atribua o length deste string A um saved length.
Reassign o first deste string usando o length deste string mais 1.
Atribua o first deste string mais o saved length ao last deste string.
Atribua o pedaço Into o target deste last deste string.

Etapas necessárias para que se posponha um pedaço para um string usando um contagem:
Isole a contagem.
Percorra.
Se o contagem for menor do que 1, cancele.
Posponha o pedaço para o string.
Subtraia 1 from a contagem.
Repita.

Etapas necessárias para que se posponha um alarme para um string:
Convert o alarme para uma segunda string.
Posponha o segunda string para o string.

Etapas necessárias para que se posponha uma fração para um string:
Convert a fração para uma segunda string.
Posponha o segunda string para o string.

Etapas necessárias para que se posponha um número para um string:
Convert o número para uma segunda string.
Posponha o segunda string para o string.

Etapas necessárias para que se posponha um endereço de memória para um string:
Convert o endereço de memória para uma segunda string.
Posponha o segunda string para o string.

Etapas necessárias para que se posponha um spot para um polygon:
Se o polygon for inexistente, cancele.
Crie um vértice usando o spot.
Posponha o vértice para os vértices deste polygon.

Etapas necessárias para que se posponha um string para uma segunda string:
Se o string estiver em branco, cancele.
Atribua o length deste string A um combined length.
Atribua o length deste segunda string A um saved length.
Adicione o saved length para o combined length.
Reassign o first deste segunda string usando o combined length.
Atribua o first deste segunda string mais o saved length A um endereço de memória.
Copy pedaços from o first deste string para o endereço de memória pelo length deste string.
Atribua o first deste segunda string mais o combined length menos 1 ao last deste segunda string.

Etapas necessárias para que se posponha um string para uma segunda string (handling email transparency):
Se o string estiver em branco, cancele.
Lance um percorredor sobre o string.
Percorra.
Mova o percorredor (text file rules).
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor starts with ".", posponha "." para o segunda string.
Posponha o token deste percorredor para o segunda string.
Repita.

Etapas necessárias para que se posponha um string para uma segunda string usando um contagem:
Isole a contagem.
Percorra.
Se o contagem for menor do que 1, cancele.
Posponha o string para o segunda string.
Subtraia 1 from a contagem.
Repita.

Etapas necessárias para que se posponha um string para um pdf object:
\ this guys adds CRLF
Posponha o string para o data deste pdf object.
Posponha o texto CRLF para o data deste pdf object.

Etapas necessárias para que se posponha um string para um pdf object sem advancing:
Posponha o string para o data deste pdf object.

Etapas necessárias para que se posponha alguns coisas para alguns segunda coisas:
Atribua o first destas coisas A uma coisa.
Se a coisa for inexistente, cancele.
Remove a coisa from as coisas.
Posponha a coisa para o segunda coisas.
Repita.

Etapas necessárias para que se posponha um cronômetro para um string:
Convert o cronômetro para uma segunda string.
Posponha o segunda string para o string.

Etapas necessárias para que se posponha um vértice para um polygon:
Se o polygon for inexistente, cancele.
Posponha o vértice para os vértices deste polygon.


Etapas necessárias para que se posponha um coordenada x e um coordenada y para um polygon:
Se o polygon for inexistente, cancele.
Crie um vértice usando o coordenada x e o coordenada y.
Posponha o vértice para os vértices deste polygon.

Etapas necessárias para que se posponha zeros para um string until its length é um número:
Se o length deste string for maior do que ou igual ao número, cancele.
Posponha "0" para o string.
Repita.

O seta do mouse é um cursor.

Etapas necessárias para que se assign um endereço de memória usando um quantidade de pedaços:
Se o quantidade de pedaços for 0, esvazie o endereço de memória; exit.
Isole o quantidade de pedaços.
Round o quantidade de pedaços up para o nearest power of two.
Call "kernel32.dll" "HeapAlloc" with o heap endereço de memória e 8 [heap_zero_memory] e o quantidade de pedaços returning o endereço de memória.
Se o endereço de memória não for inexistente, adicione 1 para o heap contagem; exit.

O asterisco é um pedaço igual a 42.
O sinal de asterisco é um pedaço igual a 42.
O símbolo de asterisco é um pedaço igual a 42.
O sinal asterisco é um pedaço igual a 42.
O símbolo asterisco é um pedaço igual a 42.

O sinal de arroba é um pedaço igual a 64.
O símbolo de arroba é um pedaço igual a 64.
O sinal arroba é um pedaço igual a 64.
O símbolo arroba é um pedaço igual a 64.
O @ é um pedaço igual a 64.

Etapas necessárias para que se role automaticamente um text usando um spot e um alarme:
Se o text for inexistente, desative o alarme; exit.
Atribua a altura desta font deste text A um número.
Limpe um difference.
Atribua a caixa deste text A uma caixa.
Indent a caixa usando o tpp.
Se a coordenada y deste spot for menor do que o topo desta caixa, atribua o número ao número y desta difference.
Se a coordenada y deste spot for maior do que a base desta caixa, atribua o número ao número y desta difference; negate o número y desta difference.
Se a coordenada x deste spot for menor do que o left desta caixa, atribua o número ao número x desta difference.
Se a coordenada x deste spot for maior do que o right desta caixa, atribua o número ao número x desta difference; negate o número x desta difference.
Se o horizontal scroll alarme deste text não estiver ativo, atribua 0 ao número x desta difference.
Se o vertical scroll alarme deste text não estiver ativo, atribua 0 ao número y desta difference.
Se a difference for 0, desative o alarme; exit.
Ligue o alarme.
Role o text usando a difference.
Aguarde por 50 milliseconds.

O tecla B/b é uma tecla igual a 66.

O barra invertida é um pedaço igual a 92.
O barra inversa é um pedaço igual a 92.
O contrabarra é um pedaço igual a 92.

O tecla backspace é uma tecla igual a 8.
O tecla de retrocesso é uma tecla igual a 8.
O tecla de apagar caracteres é uma tecla igual a 8.
O tecla de retorno é uma tecla igual a 8.

O barra vertical é um pedaço igual a 124.
O símbolo de módulo é um pedaço igual a 124.

Um baseline é um número.

Etapas necessárias para que se beep:
Call "user32.dll" "MessageBeep" with 0.


Etapas necessárias para que se begin um landscape sheet:
Make o landscape sheet 11 inches por 8-1/2 inches.
Begin um sheet with o landscape sheet.

Etapas necessárias para que se begin um landscape sheet usando um title string:
Se o pdf documento alarme não estiver ativo, limpe o landscape sheet; exit.
Make o landscape sheet 11 inches por 8-1/2 inches.
Begin o sheet usando o caixa e o title (pdf style).

Etapas necessárias para que se begin um portrait sheet:
Make o portrait sheet 8-1/2 inches por 11 inches.
Begin um sheet with o portrait sheet.

Etapas necessárias para que se begin um portrait sheet usando um title string:
Se o pdf documento alarme não estiver ativo, limpe o portrait sheet; exit.
Make o portrait sheet 8-1/2 inches por 11 inches.
Begin o sheet usando o caixa e o title (pdf style).

Etapas necessárias para que se begin printing:
Initialize o printer canvas.
Atribua um docinfo's magnitude ao cbsize deste docinfo.
Atribua o first deste name deste module ao lpszdocname deste docinfo.
Call "gdi32.dll" "StartDocA" with o printer canvas e o whereabouts deste docinfo.

Etapas necessárias para que se begin printing um pdf:
Ligue o documento alarme deste pdf state.
Atribua 0 ao object número deste pdf state.
Crie o font index deste pdf state usando 113.
Begin printing o pdf (start o root).
Begin printing o pdf (start o parent).

Etapas necessárias para que se begin printing um pdf (start o parent):
Adicione um parent pdf object usando "parent".
Atribua o parent ao parent deste pdf state.
Posponha o número deste parent then " 0 obj" para o parent.
Posponha "<<" para o parent.
Posponha "/Type /Pages" para o parent.

Etapas necessárias para que se begin printing um pdf (start o root):
Adicione um root pdf object usando "root".
Atribua o root ao root deste pdf state.
Posponha o número deste root then " 0 obj" para o root.
Posponha "<<" para o root.
Posponha "/Type /Catalog" para o root.

Etapas necessárias para que se begin um sheet:
Begin o sheet como um portrait sheet.

Etapas necessárias para que se begin um sheet usando um caixa:
Se o documento alarme deste pdf state estiver ativo, begin o sheet usando o caixa (pdf style); exit.
Call "kernel32.dll" "GlobalLock" with o printer device mode handle returning um pdevmode.
Se o pdevmode for inexistente, cancele.
Disjuncione logicamente o dmfields deste pdevmode with 1 [dm_orientation].
Atribua 1 [dmorient_portrait] ao dmorientation deste pdevmode .
Se a width desta caixa for maior do que a altura desta caixa, atribua 2 [dmorient_landscape] ao dmorientation deste pdevmode .
Call "gdi32.dll" "ResetDCA" with o printer canvas e o pdevmode.
Call "kernel32.dll" "GlobalUnlock" with o printer device mode handle.
Call "gdi32.dll" "SetGraphicsMode" with o printer canvas e 2 [gm_advanced].
Call "gdi32.dll" "SetBkMode" with o printer canvas e 1 [transparent].
Call "gdi32.dll" "SetMapMode" with o printer canvas e 8 [mm_anisotropic].
Call "gdi32.dll" "GetDeviceCaps" with o printer canvas e 112 [physicaloffsetx] returning um pair's número x.
Call "gdi32.dll" "GetDeviceCaps" with o printer canvas e 113 [physicaloffsety] returning o número y deste pair.
Negate o pair.
Call "gdi32.dll" "SetViewportOrgEx" with o printer canvas e o número x deste pair e o número y deste pair e nil.
Call "gdi32.dll" "GetDeviceCaps" with o printer canvas e 88 [logpixelsx] returning o número x deste pair.
Call "gdi32.dll" "GetDeviceCaps" with o printer canvas e 90 [logpixelsy] returning o número y deste pair.
Call "gdi32.dll" "SetViewportExtEx" with o printer canvas e o número x deste pair e o número y deste pair e nil.
Call "gdi32.dll" "SetWindowOrgEx" with o printer canvas e 0 e 0 e nil.
Call "gdi32.dll" "SetWindowExtEx" with o printer canvas e o tpi e o tpi e nil.
Call "gdi32.dll" "StartPage" with o printer canvas.
Atribua o printer canvas ao quadro atual.
Call "gdi32.dll" "GetDeviceCaps" with o printer canvas e 88 [logpixelsx] returning um número.
Atribua o tpp ao saved tpp.
Atribua o tpi dividido pelo número ao tpp.

Etapas necessárias para que se begin um sheet usando um caixa (pdf style):
Begin o sheet usando o caixa e "" (pdf style).

Etapas necessárias para que se begin um sheet usando um caixa e um title string:
Begin o sheet usando o caixa e o title (pdf style).

Etapas necessárias para que se begin um sheet usando um caixa e um title string (pdf style - start o current página):
Adicione o current página deste pdf state usando "page".
Posponha o número desta current página deste pdf state then " 0 obj" para o current página deste pdf state.
Posponha "<<" para o current página deste pdf state.
Posponha "/Type /Page" para o current página deste pdf state.
Posponha "/Parent " then o número deste parent deste pdf state then " 0 R" para o current página deste pdf state.
Atribua a width desta caixa menos o tpp times 72 / o tpi A um width.
Atribua a altura desta caixa menos o tpp times 72 / o tpi A um altura.
Posponha "/MediaBox [0 0 " then o width then " " then o altura then "]" para o current página deste pdf state.
Atribua a altura desta caixa menos o tpp ao current altura deste pdf state.
Adicione os current contents deste pdf state usando "contents".
Posponha "/Contents " then o número destes current contents deste pdf state then " 0 R" para o current página deste pdf state.
Posponha "0.05 0 0 0.05 1 1 cm" para os current contents deste pdf state. \ abra matrix para scale 72/1440
Posponha "13 w 0 J 0 j 0 i" para os current contents deste pdf state. \ pincelwidth, linecap, linejoin, flatness \ 15 w sobre pincelwidth comes out para wide

Etapas necessárias para que se begin um sheet usando um caixa e um title string (pdf style):
Ligue o página alarme deste pdf state.
Atribua o clear cor ao current border deste pdf state.
Atribua o clear cor ao current fill deste pdf state.
Begin o sheet usando o caixa e o title (pdf style - start o current página).
Se o title estiver em branco, cancele.
Crie um pdf outline entry usando o title e o current altura deste pdf state e o número desta current página deste pdf state.
Posponha o pdf outline entry para o outline entries deste pdf state.

Etapas necessárias para que se begin um sheet usando um title string:
Begin um portrait sheet usando o title.

O sinal sonoro é um pedaço igual a 7.

O Bíblia é uma coisa with alguns verses.

Um verse é uma coisa with um string.

O letra 'A' maiúscula é um pedaço igual a 65.
O 'A' maiúsculo é um pedaço igual a 65.

O letra Á maiúscula é um pedaço igual a 193.
O Á maiúsculo é um pedaço igual a 193.

O letra Â maiúscula é um pedaço igual a 194.
O Â maiúsculo é um pedaço igual a 194.

O letra Ä maiúscula é um pedaço igual a 196.
O Ä maiúsculo é um pedaço igual a 196.

O letra 'À' maiúscula é um pedaço igual a 192.
O 'À' maiúsculo é um pedaço igual a 192.

O letra Å maiúscula é um pedaço igual a 197.
O Å maiúsculo é um pedaço igual a 197.

O letra Ã maiúscula é um pedaço igual a 195.
O Ã maiúsculo é um pedaço igual a 195.

O letra Æ maiúscula é um pedaço igual a 198.
O Æ maiúsculo é um pedaço igual a 198.

O letra B maiúscula é um pedaço igual a 66.
O B maiúsculo é um pedaço igual a 66.

O letra C maiúscula é um pedaço igual a 67.
O C maiúsculo é um pedaço igual a 67.

O letra Ç maiúscula é um pedaço igual a 199.
O Ç maiúsculo é um pedaço igual a 199.

O letra D maiúscula é um pedaço igual a 68.
O D maiúsculo é um pedaço igual a 68.

O letra 'E' maiúscula é um pedaço igual a 69.
O 'E' maiúsculo é um pedaço igual a 69.

O letra 'É' maiúscula é um pedaço igual a 201.
O 'É' maiúsculo é um pedaço igual a 201.

O letra Ê maiúscula é um pedaço igual a 202.
O Ê maiúsculo é um pedaço igual a 202.

O letra Ë maiúscula é um pedaço igual a 203.
O Ë maiúsculo é um pedaço igual a 203.

O letra È maiúscula é um pedaço igual a 200.
O È maiúsculo é um pedaço igual a 200.

Um big-endian unsigned wyrd é um conjunto with 2 pedaços.

O letra Ð maiúscula é um pedaço igual a 208.
O Ð maiúsculo é um pedaço igual a 208.

O letra F maiúscula é um pedaço igual a 70.
O F maiúsculo é um pedaço igual a 70.

O letra G maiúscula é um pedaço igual a 71.
O G maiúsculo é um pedaço igual a 71.

O letra H maiúscula é um pedaço igual a 72.
O H maiúsculo é um pedaço igual a 72.

O letra I maiúscula é um pedaço igual a 73.
O I maiúsculo é um pedaço igual a 73.

O letra Í maiúscula é um pedaço igual a 205.
O Í maiúsculo é um pedaço igual a 205.

O letra Î maiúscula é um pedaço igual a 206.
O Î maiúsculo é um pedaço igual a 206.

O letra Ï maiúsculo é um pedaço igual a 207.
O Ï maiúsculo é um pedaço igual a 207.

O letra Ì maiúscula é um pedaço igual a 204.
O Ì maiúsculo é um pedaço igual a 204.

O letra J maiúscula é um pedaço igual a 74.
O J maiúsculo é um pedaço igual a 74.

O letra K maiúscula é um pedaço igual a 75.
O K maiúsculo é um pedaço igual a 75.

O letra L maiúscula é um pedaço igual a 76.
O L maiúsculo é um pedaço igual a 76.

O letra M maiúscula é um pedaço igual a 77.
O M maiúsculo é um pedaço igual a 77.

O letra N maiúscula é um pedaço igual a 78.
O N maiúsculo é um pedaço igual a 78.

O letra Ñ maiúscula é um pedaço igual a 209.
O Ñ maiúsculo é um pedaço igual a 209.

O letra 'O' maiúscula é um pedaço igual a 79.
O 'O' maiúsculo é um pedaço igual a 79.

O letra Ó maiúscula é um pedaço igual a 211.
O Ó maiúsculo é um pedaço igual a 211.

O letra Ô maiúscula é um pedaço igual a 212.
O Ô maiúsculo é um pedaço igual a 212.

O letra Ö maiúscula é um pedaço igual a 214.
O Ö maiúsculo é um pedaço igual a 214.

O letra Ò maiúscula é um pedaço igual a 210.
O Ò maiúsculo é um pedaço igual a 210.

O letra Ø maiúscula é um pedaço igual a 216.
O Ø maiúsculo é um pedaço igual a 216.

O letra Õ maiúscula é um pedaço igual a 213.
O Õ maiúsculo é um pedaço igual a 213.

O letra  maiúscula é um pedaço igual a 140.
O  maiúsculo é um pedaço igual a 140.

O letra P maiúscula é um pedaço igual a 80.
O P maiúsculo é um pedaço igual a 80.

O letra Q maiúscula é um pedaço igual a 81.
O Q maiúsculo é um pedaço igual a 81.

O letra R maiúscula é um pedaço igual a 82.
O R maiúsculo é um pedaço igual a 82.

O letra S maiúscula é um pedaço igual a 83.
O S maiúsculo é um pedaço igual a 83.

O letra  maiúscula é um pedaço igual a 138.
O  maiúsculo é um pedaço igual a 138.

O letra T maiúscula é um pedaço igual a 84.
O T maiúsculo é um pedaço igual a 84.

O letra Þ maiúscula é um pedaço igual a 222. \Þ,þ, não confundir com a consoante P/p
O Þ maiúsculo é um pedaço igual a 222.\ Þ,þ, não confundir com a consoante P/p

O letra U maiúscula é um pedaço igual a 85.
O U maiúsculo é um pedaço igual a 85.

O letra Ú maiúscula é um pedaço igual a 218.
O Ú maiúsculo é um pedaço igual a 218.

O letra Û maiúscula é um pedaço igual a 219.
O Û maiúsculo é um pedaço igual a 219.

O letra Ü maiúscula é um pedaço igual a 220.
O Ü maiúsculo é um pedaço igual a 220.

O Ù maiúsculo é um pedaço igual a 217.

O letra V maiúscula é um pedaço igual a 86.
O V maiúsculo é um pedaço igual a 86.

O letra W maiúscula é um pedaço igual a 87.
O W maiúsculo é um pedaço igual a 87.

O letra X maiúscula é um pedaço igual a 88.
O X maiúsculo é um pedaço igual a 88.

O letra Y maiúscula é um pedaço igual a 89.
O Y maiúsculo é um pedaço igual a 89.

O letra Ý maiúscula é um pedaço igual a 221.
O Ý maiúsculo é um pedaço igual a 221.

O letra  maiúscula é um pedaço igual a 159.
O  maiúsculo é um pedaço igual a 159.

O letra Z maiúscula é um pedaço igual a 90.
O Z maiúsculo é um pedaço igual a 90.

O letra  maiúscula é um pedaço igual a 142.
O  maiúsculo é um pedaço igual a 142.

Um billion é 1000 millions.

Um código binário é um string.

An bit é uma unit.

Um bitmapdata é um conjunto with
Um width,
Um altura,
Um número called stride,
Um número called pixelformat,
Um endereço de memória called scan0,
Um número called reserved.

Etapas necessárias para que se conjuncione logicamente um pedaço with uma segunda pedaço:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segunda byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $2003. \ e [ebx],al

Etapas necessárias para que se conjuncione logicamente um pedaço with um número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $2003. \ e [ebx],al

Etapas necessárias para que se conjuncione logicamente um número with uma segunda número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segunda número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $2103. \ e [ebx],eax

Etapas necessárias para que se disjuncione logicamente um pedaço with uma segunda pedaço:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segunda byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0803. \ ou [ebx],al

Etapas necessárias para que se disjuncione logicamente um pedaço with um número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0803. \ ou [ebx],al

Etapas necessárias para que se disjuncione logicamente um número with uma segunda número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segunda número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $0903. \ ou [ebx],eax

Etapas necessárias para que se disjuncione seletivamente um pedaço with uma segunda pedaço:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segunda byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $3003. \ xor [ebx],al

Etapas necessárias para que se disjuncione seletivamente um pedaço with um número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $3003. \ ou [ebx],al

Etapas necessárias para que se disjuncione seletivamente um número with uma segunda número:
Intel $8B850C000000. \ mov eax,[ebp+12] \ o segunda número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $3103. \ xor [ebx],eax

O cor preta é uma cor.

O black pincel é um pincel.

O blue cor é uma cor.

O blue pincel é um pincel.

Um caixa has
Um left coord, 
Um topo coord, 
Um right coord, 
Um base coord,
Um left-top spot at o left, e um right-base spot at o right,
Um topo-left spot at o left, e um base-right spot at o right.

Um brilho é um luminosidade.

O barra vertical quebrada é um pedaço igual a 166.
O barra vertical interrompida é um pedaço igual a 166.

O brown cor é uma cor.

O brown pincel é um pincel.

Um cor amarronzada é uma cor.

Um bucket contagem é um contagem.

Um bucket é um endereço de memória para um bucket conjunto.

Um bucket conjunto has alguns refers.

An bucket# é um número.

Um trecho é um string.

O ponto lista é um pedaço igual a 149.
O ponto-lista é um pedaço igual a 149.

Etapas necessárias para que se avance um pedaço limiting it para uma segunda pedaço e um terceiro pedaço:
Adicione 1 para o pedaço.
Se o pedaço for maior do que o terceiro pedaço, atribua o segunda pedaço ao pedaço.

Etapas necessárias para que se avance um número:
Adicione 1 para o número.

Etapas necessárias para que se avance um número limiting it para uma segunda número e um terceiro número:
Adicione 1 para o número.
Se o número for maior do que o terceiro número, atribua o segunda número ao número.

Etapas necessárias para que se avance um percorredor:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ comando de movimentação do percorredor?
Intel $FF8314000000. \ inc [ebx+20] \ aumenta o valor do last deste token deste percorredor.
Intel $FF8308000000. \ inc [ebx+8] \ aumenta o valor do first deste source deste percorredor.

Etapas necessárias para que se recue um percorredor:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ comando de movimentação do percorredor?
Intel $FF8B14000000. \ dec [ebx+20] \ reduz o valor do last deste token deste percorredor.
Intel $FF8B08000000. \ dec [ebx+8] \ reduz o valor do first deste source deste percorredor.

Etapas necessárias para que se avance um percorredor por um número:
Adicione o número para o last deste token deste percorredor.
Adicione o número para o first deste source deste percorredor.

Etapas necessárias para que se buzz:
Call "kernel32.dll" "Beep" with 220 e 200.

Um quantidade de pedaços é uma contagem.

Um endereço de memória do pedaço é um endereço de memória para um pedaço.

An byte# é um número.

O tecla C/c é uma tecla igual a 67.

O caractere de cancelamento [CAN] é um pedaço igual a 24.
\O caractere CAN é um pedaço igual a 24.

An canvas é um hdc. \ hdc = handle device context

Etapas necessárias para que se capitalize any selecionado rows em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Se a row estiver em branco, repita.
Capitalize o string deste row.
Repita.

Etapas necessárias para que se capitalize um string:
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto não for noise, pare.
Adicione 1 para o first deste subtexto.
Repita.
Uppercase o target deste first deste subtexto.

Etapas necessárias para que se capitalize um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from os rows deste text.
Se a row for inexistente, pare.
Capitalize o string deste row.
Repita.
Wrap o text.

O tecla Caps Lock é uma tecla igual a 20.

O caret pedaço é um pedaço igual a 94.

Um caret é um position.

O sinal de cedilha é um pedaço igual a 184.
O símbolo de cedilha é um pedaço igual a 184.

O sinal de centavos é um pedaço igual a 162.
O símbolo de centavos é um pedaço igual a 162.
O sinal de cêntimos é um pedaço igual a 162.
O símbolo de cêntimos é um pedaço igual a 162.

Etapas necessárias para que se centralize um caixa at o base of uma segunda caixa:
Centralize o caixa no segunda caixa (horizontally).
Atribua a altura desta caixa A um altura.
Atribua a base desta segunda caixa à base desta caixa.
Atribua a base desta caixa menos o altura ao topo desta caixa.

Etapas necessárias para que se centralize um caixa em uma segunda caixa (horizontally):
Atribua a coordenada x deste center desta segunda caixa menos a coordenada x deste center desta caixa A um número.
Round o número para o nearest multiple of o tpp.
Mova o caixa usando o número e 0.

Etapas necessárias para que se centralize um caixa em uma segunda caixa (vertically):
Atribua a coordenada y deste center desta segunda caixa menos a coordenada y deste center desta caixa A um número.
Round o número para o nearest multiple of o tpp.
Mova o caixa usando 0 e o número.

Etapas necessárias para que se centralize um dot sobre o current spot:
\ need Spanish palavra por "dot"
Centralize o dot sobre o spot deste context.

Etapas necessárias para que se centralize um elipse em um caixa (horizontally):
Centralize a caixa desta elipse no caixa (horizontally).

Etapas necessárias para que se centralize um elipse em um caixa (vertically):
Centralize a caixa desta elipse no caixa (vertically).

Etapas necessárias para que se centralize um line em um caixa (horizontally):
Atribua o x deste center desta caixa menos o x deste center desta line A um número.
Round o número para o nearest multiple of o tpp.
Mova o line usando o número e 0.

Etapas necessárias para que se centralize um line em um caixa (vertically):
Atribua o y deste center desta caixa menos o y deste center desta line A um número.
Round o número para o nearest multiple of o tpp.
Mova o line usando 0 e o número.

Etapas necessárias para que se centralize um picture em um caixa (horizontally):
Se o picture for inexistente, cancele.
Atribua o coordenada x deste center desta caixa menos o coordenada x deste center desta caixa desta picture A um número.
Round o número para o nearest multiple of o tpp.
Mova o picture usando o número e 0.

Etapas necessárias para que se centralize um picture em um caixa (vertically):
Se o picture for inexistente, cancele.
Atribua a coordenada y deste center desta caixa menos o coordenada y deste center desta caixa desta picture A um número.
Round o número para o nearest multiple of o tpp.
Mova o picture usando 0 e o número.

Etapas necessárias para que se centralize um polygon em um caixa (horizontally):
Se o polygon for inexistente, cancele.
Atribua o x deste center desta caixa menos o x deste center desta caixa deste polygon A um número.
Round o número para o nearest multiple of o tpp.
Mova o polygon usando o número e 0.

Etapas necessárias para que se centralize um polygon em um caixa (vertically):
Se o polygon for inexistente, cancele.
Atribua o y deste center desta caixa menos o y deste center desta caixa deste polygon A um número.
Round o número para o nearest multiple of o tpp.
Mova o polygon usando 0 e o número.

Etapas necessárias para que se centralize um spot em um caixa (horizontally):
Atribua o x deste center desta caixa menos o x deste spot A um número.
Round o número para o nearest multiple of o tpp.
Mova o spot usando o número e 0.

Etapas necessárias para que se centralize um spot em um caixa (vertically):
Atribua o y deste center desta caixa menos o y deste spot A um número.
Round o número para o nearest multiple of o tpp.
Mova o spot usando 0 e o número.

Etapas necessárias para que se centralize um text em um caixa (horizontally):
Se o text for inexistente, cancele.
Atribua o x deste center desta caixa menos o x deste center desta caixa deste text A um número.
Round o número para o nearest multiple of o tpp.
Mova o text usando o número e 0.

Etapas necessárias para que se centralize um text em um caixa (vertically):
Se o text for inexistente, cancele.
Atribua o y deste center desta caixa menos o y deste center desta caixa deste text A um número.
Round o número para o nearest multiple of o tpp.
Mova o text usando 0 e o número.

Etapas necessárias para que se modifique o current matiz por alguns points;
Etapas necessárias para que se altere o current matiz por alguns points;
Etapas necessárias para que se mude o current matiz por alguns points:
Mude a matiz deste context por os points.

Etapas necessárias para que se modifique um matiz por alguns points;
Etapas necessárias para que se altere um matiz por alguns points;
Etapas necessárias para que se mude um matiz por alguns points:
Adicione o points para o matiz.

Etapas necessárias para que se modifique um caixa arredondada usando um radius;
Etapas necessárias para que se altere um caixa arredondada usando um radius;
Etapas necessárias para que se mude um caixa arredondada usando um radius:
Atribua o radius ao radius desta caixa arredondada.

Etapas necessárias para que se modifique um text usando um caixa;
Etapas necessárias para que se altere um text usando um caixa;
Etapas necessárias para que se mude um text usando um caixa:
Se o text for inexistente, cancele.
Atribua o caixa à caixa deste text.
Wrap o text.

Etapas necessárias para que se modifique um text usando uma font altura;
Etapas necessárias para que se altere um text usando uma font altura;
Etapas necessárias para que se mude um text usando uma font altura:
Se o text for inexistente, cancele.
Subtraia a margin deste text from a coordenada x deste text.
Atribua a origin deste text dividido pela grid deste text A um pair.
Atribua o font altura à altura desta font deste text.
Redimensione proporcionalmente a altura desta font deste text usando a scale deste text.
Atribua o pair times a grid deste text à origin deste text.
Adicione a margin deste text para a coordenada x deste text.
Limite o origin of o text.
Wrap o text.

Etapas necessárias para que se modifique um text usando uma font name;
Etapas necessárias para que se altere um text usando uma font name;
Etapas necessárias para que se mude um text usando uma font name:
Se o text for inexistente, cancele.
Atribua o font name ao name desta font deste text.
Wrap o text.

Um character é um pedaço.

Um choice é uma coisa with um name e uma caixa.

O choices são algumas choices.

O circumflex pedaço é um pedaço igual a 136.

Etapas necessárias para que se limpe um caixa:
Atribua 0 e 0 e 0 e 0 ao caixa. \ caderno depends sobre this

Etapas necessárias para que se limpe um pedaço:
Atribua o null pedaço ao pedaço.

Etapas necessárias para que se limpe um cor:
Atribua 0 e 0 e 0 à cor.

O clear cor é uma cor.

Etapas necessárias para que se limpe um elipse:
Limpe a caixa desta elipse.

Etapas necessárias para que se desative um alarme;
Etapas necessárias para que se desligue um alarme:
Atribua 0 ao alarme. \ was "Atribua no ao alarme." Value of "no" inherited from o CAL-1000 according para Dan.

Etapas necessárias para que se limpe um font:
Atribua "" e 0 ao font.

Etapas necessárias para que se limpe um fração:
Atribua 0 e 1 à fração.

Etapas necessárias para que se limpe um ip address:
Limpe o número deste ip address.
Limpe o string deste ip address.

O tecla Clear é uma tecla igual a 12.

Etapas necessárias para que se limpe um line:
Limpe o start desta line.
Limpe o end desta line.

Etapas necessárias para que se limpe um número:
Atribua 0 ao número.

Etapas necessárias para que se limpe um pair:
Atribua 0 e 0 ao pair.

O clear pincel é um pincel.

Etapas necessárias para que se limpe um percorredor:
Limpe o original deste percorredor.
Limpe o source deste percorredor.
Limpe o token deste percorredor.

Etapas necessárias para que se erase o tela;
Etapas necessárias para que se branqueie o tela;
Etapas necessárias para que se apague o tela;
Etapas necessárias para que se limpe o tela:
Unmask everything.
Draw a caixa desta tela with a cor preta e a cor preta.
Atualize o tela.
Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe o tela para um cor:
Unmask everything.
Draw a caixa desta tela with a cor e a cor.
Atualize o tela.
Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe o tela para white:
\ \ needs special handling
Unmask everything.
Draw a caixa desta tela with o cor branca e o cor branca.
Atualize o tela.
Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe o tela sem atualizá-la:
Unmask everything.
Draw a caixa desta tela with a cor preta e a cor preta.
Atribua a caixa desta tela à caixa deste context.

Etapas necessárias para que se limpe um selection:
Limpe o anchor desta selection.
Limpe o caret desta selection.

Etapas necessárias para que se limpe o stack:
\ stack needs work
Destroy o stack.

Etapas necessárias para que se limpe um string:
Unassign o first desta string.
Esvazie o last deste string.

Etapas necessárias para que se limpe um subtexto:
Esvazie o first deste subtexto.
Esvazie o last deste subtexto.

Etapas necessárias para que se limpe um terminal:
Destroy os quoras deste terminal.

Etapas necessárias para que se limpe alguns coisas:
Esvazie o first destas coisas.
Esvazie o last destas coisas.

Etapas necessárias para que se limpe um wyrd:
Atribua 0 ao wyrd.

Etapas necessárias para que se close um file:
Call "kernel32.dll" "CloseHandle" with o file.

Um clsid é um uuid.

Etapas necessárias para que se cluck:
Play o cluck sound.

O cluck sound é um wave igual a $524946463A02000057415645666D74201200000001000100401F0000401F000001000800000066616374040000000702000064617461070200007F7F807F7F807F7F808080807F807F7F80817F81817E7E827E7D847C79877D5F6D99B2A25D608269A5979869667F7D8D738C7D8C5E7E878F767A75868D84797278829A7D7E857A73929271657492907D7E7D787E8B887C758388827E817F7C7B89897C7A7E84838183827E7A8488877D7E8181808484817C7F84838181807E7F8283807E8081808182807F7F81818081807F7F8081818080807F7F808180807F80808080807F8080807F8080808080807F7F7F7F7F8080807F7F7F7C7B8182817C7B7D7E8082807D7D7C7F8281807F7C7D808082807E7E7E7D7E807D7B7C7B7D7D7B7A7979797875727269797A490F4571FFF4FF0C001297FBF492525BB0F5B26A001C69BEE5BA76476F9EBD953C3757BAC9BB705C7F9AA883645D7897AA9B806977959588696976999B83766F828C907F7375828E91877B757D868B837A757C858D8880787B8187847B7A7D8788807B79808486817D7C7F8384817D7C7F8484817B7B7D83847F7C7B7E8182827D7C7C8082817D7C7D7F81807F7D7D7F82817F7B7B7E8081807E7D7D7F80807E7D7D7E80807E7D7D7E7F807F7D7D7E7F807F7E7D7E7E80807F7E7D7E80807F7E7E7E7F7F7E7E7E7F7F7F7F7E7E7F7F807F7F7E7E7E7F8080807E7E7E80807F7E7E7F8081807F7F7E7F7F80807F7E7F8081807F7E7E7E80808080807F807F7F7F7F7F7F7F80808080807F7F7F808080807F80808180807F80808100.

O sinal de dois pontos é um pedaço igual a 58.
O símbolo de dois pontos é um pedaço igual a 58.

\um cor has um matiz, um saturação, um luminosidade, e um brilho at o luminosidade.

Um cor has uma matiz, uma saturação, uma luminosidade, um brilho at a luminosidade.

Um código da cor é um número [like $00BBGGRR].

Um column# é um número.

O vírgula é um pedaço igual a 44.

Etapas necessárias para que se compare um string para uma segunda string usando um length e uma segunda length e uma tabela de tradução (equal only):
Intel $8BB508000000. \ mov esi,[ebp+8] \ o string
Intel $8B36. \ mov esi,[esi] \ o first deste string
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ o segunda string
Intel $8B3F. \ mov edi,[edi] \ o first deste segunda string
Intel $8B8510000000. \ mov eax,[ebp+16] \ o length deste string
Intel $8B00. \ mov eax,[eax]
Intel $8B9514000000. \ mov edx,[ebp+20] \ o length deste segunda string
Intel $8B12. \ mov edx,[edx]
Intel $3BD0. \ cmp eax,edx \ if o differ do length, diga não.
Intel $0F852B000000. \ jne Diga não. \ ************************************ was 2C
Intel $8BC8. \ mov ecx,eax \ atribua length A ecx 
Intel $8B9D18000000. \ mov ebx,[ebp+24] \ o tabela de tradução
Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
\ loop:
Intel $85C9. \ test ecx,ecx
Intel $0F8424000000. \ jz say yes \ ************************************ was 25
 \ fetch e translate o current pedaço no segunda string
Intel $8A07. \ mov al,[edi]
Intel $D7. \ xlat al,[ebx]
Intel $C1E008. \ shl eax,8
\ fetch e translate o current pedaço no string
Intel $8A06. \ mov al,[esi]
Intel $D7. \ xlat al,[ebx]
 \ compare o two translated pedaços
Intel $38E0. \ cmp al,ah
Intel $0F8508000000. \ jne Diga não. \ ************************************
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $E9DFFFFFFF. \ jmp loop \ ************************************ was DE
\Diga não.:
Intel $C7C000000000. \ mov eax,0
Intel $E906000000. \ jmp end
\SAY YES:
Intel $C7C001000000. \ mov eax,1

\ dahn - spanish strings 2 - which table para use?
Etapas necessárias para que se compare um string para uma segunda string usando um length e uma segunda length returning um número:
Compare o string para o segunda string usando o length e o segunda length e o lowercase ascii table returning o número.
\Compare o string para o segunda string usando o length e o segunda length e o lowercase accent-free ascii table returning o número.

Etapas necessárias para que se compare um string para uma segunda string usando um length e uma segunda length e uma tabela de tradução returning um número:
Intel $8BB508000000. \ mov esi,[ebp+8] \ o string
Intel $8B36. \ mov esi,[esi] \ o first do string
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ o segunda string
Intel $8B3F. \ mov edi,[edi] \ o first do segunda string
Intel $8B8510000000. \ mov eax,[ebp+16] \ o length do string
Intel $8B00. \ mov eax,[eax]
Intel $8B9514000000. \ mov edx,[ebp+20] \ o length do segunda string
Intel $8B12. \ mov edx,[edx]
Intel $8B9D18000000. \ mov ebx,[ebp+24] \ o tabela de tradução
Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
\ obtenha o minimum length
Intel $8BC8. \ mov ecx,eax
Intel $3BCA. \ cmp ecx,edx
Intel $0F8602000000. \ jbe L2
Intel $8BCA. \ mov ecx,edx
\ if o minimum length for 0, jump para L5
Intel $85C9. \ test ecx,ecx
Intel $0F8428000000. \ jz L5
\L2:
\ loop:
\ fetch e translate o current pedaço no string
Intel $8A06. \ mov al,[esi]
Intel $D7. \ xlat al,[ebx]
Intel $88C2. \ mov dl,al
\ fetch e translate o current pedaço no segunda string
Intel $8A07. \ mov al,[edi]
Intel $D7. \ xlat al,[ebx]
Intel $88C6. \ mov dh,al
\L3:
\ compare o two translated pedaços
Intel $38F2. \ cmp dl,dh
Intel $0F8510000000. \ jne L4
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $85C9. \ test ecx,ecx
Intel $0F8405000000. \ jz L4
Intel $E9DEFFFFFF. \ jmp L2
\L4:
\ load pedaços Into EAX e edx por final compare
Intel $0FB6C2. \ movzx eax,dl
Intel $0FB6D6. \ movzx edx,dh
\L5:
\ subtraia either o lengths ou os last dois pedaços para abra o eax para <0, =0, >0
Intel $2BC2. \ sub eax,edx
Intel $8B9D1C000000. \ mov ebx,[ebp+28] \ o número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se compativelmente handle any message with um window um message número um w-param e um l-param:
Se o message for 006, gerencie any wm-activate with o w-param; atribua 0 Into EAX; exit.
Se o message for 258, gerencie any wm-char with o w-param e o l-param; atribua 0 Into EAX; exit.
Se o message for 001, gerencie any wm-create with o window; atribua 0 Into EAX; exit.
Se o message for 002, gerencie any wm-destroy; atribua 0 Into EAX; exit.
Se o message for 256, gerencie any wtecla M/mdown with o w-param e o l-param; atribua 0 Into EAX; exit.
Se o message for 513, gerencie any wm-lbuttondown with o l-param; atribua 0 Into EAX; exit.
Se o message for 515, gerencie any wm-lbuttondblclk with o l-param; atribua 0 Into EAX; exit.
Se o message for 015, gerencie any wm-paint with o window; atribua 0 Into EAX; exit.
Se o message for 516, gerencie any wm-rbuttondown with o l-param; atribua 0 Into EAX; exit.
Se o message for 518, gerencie any wm-rbuttondblclk with o l-param; atribua 0 Into EAX; exit.
Se o message for 032, gerencie any wm-setcursor; atribua 1 Into EAX; exit.
Se o message for 260, gerencie any wm-syskeydown with o w-param e o l-param; atribua 0 Into EAX; exit.
Call "user32.dll" "DefWindowProcA" with o window e o message e o w-param e o l-param.

Etapas necessárias para que se compativelmente aguarde por um process endereço de memória:
Call "kernel32.dll" "WaitForSingleObject" with o target deste process endereço de memória e -1 [infinite].
Call "kernel32.dll" "CloseHandle" with o target deste process endereço de memória.
Atribua 0 ao target deste process endereço de memória.
Call "user32.dll" "GetForegroundWindow" returning um window.
Se o window é o main window, atribua 0 Into EAX; exit.
Call "user32.dll" "ShowWindow" with o main window e 6 [sw_minimize].
Call "user32.dll" "ShowWindow" with o main window e 9 [sw_restore].
Atribua 0 Into EAX. \ abra return value of thread

\Um console é uma coisa with 
\a caixa,
\a border cor,
\a fill cor,
\a text,
\a grid,
\a reply string.

Um console é uma coisa with 
Um caixa, 
Um border cor,
Um fill cor, 
Um text, 
Um grid, 
Um reply string.

O context é um context.

An context é uma coisa with um spot, um caixa, um heading, um tamanho da letra, um cor, um número, um pincel size,\ pincel width? ***
and um letra size at o tamanho da letra, e um pincel at a cor.
\REMARK: O "pincel size" não estava no context conjunto, but it deveria be.
\I will be adding it para o next version of o CAL context, e now might be a good time for you para adicione it para o PAL context conjunto.

O context stack é alguns contexts.

Etapas necessárias para que se convert um posicionamento absoluto para uma position usando um text:
Se o text for inexistente, limpe o position; exit.
Isole o posicionamento absoluto.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, limpe o position; exit.
Atribua o número da linha desta row ao número da linha desta position.
Atribua o posicionamento absoluto ao column# desta position.
Subtraia o length deste string desta row from o posicionamento absoluto.
Se o posicionamento absoluto for menor do que 1, cancele.
Repita.

Etapas necessárias para que se convert um código binário Para um número:
Atribua 0 ao número.
Atribua 1 A um value número.
Percorra.
Se o código binário estiver em branco, cancele.
Obtenha um character from o código binário (backwards). \ was backwards
Se o character for "1", adicione o value para o número.
Double o value.
Repita.

Etapas necessárias para que se convert um caixa para um string:
Limpe o string.
Posponha o left desta caixa para o string.
Posponha " " para o string.
Posponha o topo desta caixa para o string.
Posponha " " para o string.
Posponha o right desta caixa para o string.
Posponha " " para o string.
Posponha a base desta caixa para o string.

Etapas necessárias para que se convert um pedaço para uma cifra binária:
Atribua o pedaço à cifra binária como um pedaço.
Uppercase a cifra binária.
Se a cifra binária for maior do que o número nove, subtraia 7 from a cifra binária.
Subtraia 48 from a cifra binária.

Etapas necessárias para que se convert um pedaço para um texto da cifra binária:
Split o pedaço A uma cifra binária e uma segunda cifra binária.
Convert a cifra binária para o texto da cifra binária.
Convert o segunda cifra binária para uma segunda texto da cifra binária.
Posponha o segunda texto da cifra binária para o texto da cifra binária.

Etapas necessárias para que se convert um pedaço para um query pedaço:
Se o pedaço estiver entre 48 e 57, atribua o pedaço ao query pedaço; exit. \ 0-9
Se o pedaço estiver entre 65 e 90, atribua o pedaço ao query pedaço; exit. \ A-Z
Se o pedaço estiver entre 97 e 122, atribua o pedaço ao query pedaço; exit. \ a-z
Se o pedaço for 32, atribua "+" ao query pedaço; exit. \ space
Convert o pedaço para um texto da cifra binária.
Atribua "%" then o texto da cifra binária ao query pedaço.

Etapas necessárias para que se convert uma cor para um código da cor:
Se a cor estiver clear, atribua 16777215 [$00FFFFFF] ao código da cor; exit. \ clear pincel becomes white
Isole a cor.
Redimensione proporcionalmente a saturação desta cor usando 240/1000.
Limite a saturação desta cor para 1 e 239.
Redimensione proporcionalmente a luminosidade desta cor usando 240/1000.
Limite a luminosidade desta cor para 1 e 239.
Redimensione proporcionalmente a matiz desta cor usando 240/3600.
Limite a matiz desta cor para 1 e 239.
Call "shlwapi.dll" "ColorHLSToRGB" with a matiz desta cor e a luminosidade desta cor e a saturação desta cor returning o código da cor.

Etapas necessárias para que se convert uma cor para um rgb:
Convert a cor para um código da cor.
Convert o código da cor para o rgb.

Etapas necessárias para que se convert um código da cor para um cor:
Call "shlwapi.dll" "ColorRGBToHLS" with o código da cor e um whereabouts desse wyrd e uma segunda whereabouts desse wyrd e um terceiro whereabouts deste wyrd.
Atribua o wyrd à matiz desta cor.
Atribua o segunda wyrd à luminosidade desta cor.
Atribua o terceiro wyrd à saturação desta cor.
Redimensione proporcionalmente a matiz desta cor usando 3600/240.
Limite a matiz desta cor para 0 e 3600.
Redimensione proporcionalmente a saturação desta cor usando 1000/240.
Limite a saturação desta cor para 0 e 1000.
Redimensione proporcionalmente a luminosidade desta cor usando 1000/240.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se convert um código da cor para um rgb:
Isole o código da cor.
Shift o código da cor right 0 bits.
Atribua o código da cor ao espectro vermelho deste rgb.
Shift o código da cor right 8 bits.
Atribua o código da cor ao espectro verde deste rgb.
Shift o código da cor right 8 bits.
Atribua o código da cor ao espectro azul deste rgb.

Etapas necessárias para que se convert um filetime para um string:
Limpe o string.
Call "kernel32.dll" "FileTimeToSystemTime" with o whereabouts deste filetime e um systemtime's whereabouts returning um número.
Se o número for 0, cancele.
Atribua o wyear deste systemtime A um date/time's year.
Atribua o wmonth deste systemtime ao month deste date/time.
Atribua o wdayofweek deste systemtime ao week day deste date/time.
Atribua o wday deste systemtime ao day deste date/time.
Atribua o whour deste systemtime à hour deste date/time.
Atribua o wminute deste systemtime ao minute deste date/time.
Atribua o wsecond deste systemtime ao second deste date/time.
Atribua os wmilliseconds deste systemtime ao millisecond deste date/time.
Atribua o string deste date/time ao string.

Etapas necessárias para que se convert um alarme para um texto hexadecimal:
Reassign o first deste texto hexadecimal usando a magnitude deste alarme.
Copy pedaços from o whereabouts deste alarme para o first deste texto hexadecimal pela magnitude deste alarme.
Atribua o first deste texto hexadecimal mais a magnitude deste alarme menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se convert uma font para um hfont:
Isole o font.
Null terminate o name desta font.
Call "gdi32.dll" "CreateFontA" with - a altura desta font times 3 dividido por 4 e 0 e 0 e 0 e 0 e 0 e 0 e 0 
And 1 [default_charset] e 0 e 0 e 5 [cleartype_quality] e 4 [truetype_fonttype] e o first deste name desta font returning o hfont.

Etapas necessárias para que se convert uma font info para pdf em units:
Se o font info for inexistente, cancele.
Convert o internal leading desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Convert o ascent desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Convert o descent desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Convert o capheight desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
\ convert o italicangle desta font info para pdf em units usando o emsquare desta font info e o font desta font info. \não sei porque está comentado
Convert o stemv desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Convert o left desta font caixa desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Convert o topo desta font caixa desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Convert o right desta font caixa desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Convert a base desta font caixa desta font info para pdf em units usando o emsquare desta font info e o font desta font info.
Swap o topo desta font caixa desta font info with a base desta font caixa desta font info.
Convert as font widths desta font info para pdf em units.

Etapas necessárias para que se convert algumas font widths para pdf em units:
Obtenha um outlinetextmetric usando a font destas font widths.
Atribua os data desta font widths A um número endereço de memória.
Percorra.
Se um contador é past a contagem destas font widths, pare.
Convert o target deste número endereço de memória para pdf em units usando o otmemsquare deste outlinetextmetric e a font destas font widths.
Adicione um número's magnitude para o número endereço de memória.
Repita.

Etapas necessárias para que se convert uma fração para um texto hexadecimal:
Reassign o first deste texto hexadecimal usando a magnitude desta fração.
Copy pedaços from o whereabouts desta fração para o first deste texto hexadecimal pela magnitude desta fração.
Atribua o first deste texto hexadecimal mais a magnitude desta fração menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se convert uma fração para um mixed:
Se o denominador desta fração for 0, atribua 0 ao whole número deste mixed; atribua 0 ao ratio deste mixed; exit.
Divida o numerador desta fração pelo denominador desta fração giving o whole número deste mixed e um resto.
Atribua o resto e o denominador desta fração ao fração deste mixed.

Etapas necessárias para que se convert uma fração para um string usando um número:
\ converts para um decimal representation with "the número" of places
Limpe o string.
Se o número for menor do que 1, cancele.
Atribua 10 A um value número.
Raise o value para o número.
Isole a fração.
Se a fração for negative, acione um alarme; de-sign a fração.
Multiplique o value pela fração.
Zero fill o value usando o número e posponha it para o string.
Atribua o length deste string menos o número mais 1 A um byte#.
Insira "." ao string antes de o byte#.
Se o target deste first deste string é o ponto final, anteponha "0" para o string.
Se o alarme estiver ativo, anteponha "-" para o string.

Etapas necessárias para que se convert um gpbitmap para um trecho (pdf style):
Limpe o trecho.
Se o gpbitmap for inexistente, cancele.
Lock o gpbitmap usando um bitmapdata (24-bit rgb).
Atribua 1 A um número da linha.
Atribua 1 A um column#.
Percorra.
Se o column# for maior do que o width deste bitmapdata, atribua 1 ao column#; adicione 1 para o número da linha.
Se o número da linha for maior do que a altura deste bitmapdata, pare.
Obtenha um rgb endereço de memória from o bitmapdata at o número da linha e o column#.
Posponha o espectro vermelho deste rgb endereço de memória para o trecho.
Posponha o espectro verde deste rgb endereço de memória para o trecho.
Posponha o espectro azul deste rgb endereço de memória para o trecho.
Adicione 1 para o column#.
Repita.
Unlock o gpbitmap usando o bitmapdata.

Etapas necessárias para que se convert um texto hexadecimal para um fração:
Se o length deste texto hexadecimal não for a magnitude desta fração, atribua 0 e 1 ao ratio; exit.
Copy pedaços from o first deste texto hexadecimal para o whereabouts desta fração pela magnitude desta fração.

Etapas necessárias para que se convert um texto hexadecimal para um número:
Se o length deste texto hexadecimal não for a magnitude deste número, limpe o número; exit.
Copy pedaços from o first deste texto hexadecimal para o whereabouts destte número pela magnitude deste número.

Etapas necessárias para que se convert um l-param para um tecla:
\ assumes l-param from wm_char message
Atribua o l-param à tecla.
Shift a tecla right 16 bits.
Conjuncione logicamente a tecla with 255.
Call "user32.dll" "MapVirtualKeyA" with a tecla e 1 returning a tecla.
Se o numlock tecla was not toggled, cancele.
Se a tecla for a tecla Insert, atribua o numpad-tecla zero à tecla; exit.
Se a tecla for a tecla Delete, atribua o numpad-period tecla à tecla; exit.
Se a tecla for a tecla Home, atribua o numpad-tecla sete à tecla; exit.
Se a tecla for a tecla End, atribua o numpad-one tecla à tecla; exit.
Se a tecla for a tecla PgUp, atribua o numpad-tecla nove à tecla; exit.
Se a tecla for a tecla PgDn, atribua o numpad-tecla três à tecla; exit.
Se a tecla for a left-arrow tecla, atribua o numpad-tecla quatro à tecla; exit.
Se a tecla for a seta pra cima, atribua o numpad-tecla oito à tecla; exit.
Se a tecla for a right-arrow tecla, atribua o numpad-tecla seis à tecla; exit.
Se a tecla for a seta pra baixo, atribua o numpad-tecla dois à tecla; exit.
Se a tecla for a tecla Clear, atribua o numpad-tecla cinco à tecla; exit.

Etapas necessárias para que se convert um l-param para um spot:
Split o l-param A um wyrd e uma segunda wyrd.
Atribua o wyrd à coordenada y deste spot.
Atribua o segunda wyrd à coordenada x deste spot.
Multiplique o spot pelo tpp.

Etapas necessárias para que se convert um mixed para um fração:
Atribua o fração deste mixed à fração.
Adicione o whole número deste mixed times o denominador desta fração para o numerador desta fração.

Etapas necessárias para que se convert uma cifra binária para um texto da cifra binária:
Isole a cifra binária.
Se a cifra binária for maior do que 9, adicione 7 para a cifra binária.
Adicione 48 para a cifra binária.
Atribua a cifra binária ao texto da cifra binária.

Etapas necessárias para que se convert um texto da cifra binária para um texto hexadecimal:
Isole o texto da cifra binária.
Limpe o texto hexadecimal.
Se o length deste texto da cifra binária for ímpar, anteponha o número zero para o texto da cifra binária.
Lance um subtexto sobre o texto da cifra binária.
Percorra.
Se o subtexto estiver em branco, cancele.
Convert o target deste first deste subtexto para uma cifra binária.
Shift a cifra binária left 4 bits.
Adicione 1 para o first deste subtexto.
Convert o target deste first deste subtexto para uma segunda cifra binária.
Disjuncione logicamente a cifra binária with o segunda cifra binária.
Posponha a cifra binária para o texto hexadecimal.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se convert um número para um pedaço:
Atribua o número ao pedaço.

Etapas necessárias para que se convert um número para pdf em units usando um emsquare número e um font:
Multiplique o número pelo emsquare / a adjusted altura desta font.
Multiplique o número por 1000 / o emsquare.

Etapas necessárias para que se convert um pchar para um string:
Limpe o string.
Se o pchar for inexistente, cancele.
Isole o pchar.
Percorra.
Se o target deste pchar for o null pedaço, cancele.
Posponha o target deste pchar para o string.
Adicione 1 para o pchar.
Repita.

Etapas necessárias para que se convert um endereço de memória e um length para um string:
Limpe o string.
Se o endereço de memória for inexistente, cancele.
Se o length for 0, cancele.
Reassign o first deste string usando o length.
Copy pedaços from o endereço de memória para o first deste string pelo length.
Atribua o first deste string mais o length menos 1 ao last deste string.

Etapas necessárias para que se convert um endereço de memória para um texto hexadecimal;
Etapas necessárias para que se convert um número para um texto hexadecimal:
Reassign o first deste texto hexadecimal usando a magnitude deste número.
Copy pedaços from o whereabouts deste número para o first deste texto hexadecimal pela magnitude deste número.
Atribua o first deste texto hexadecimal mais a magnitude deste número menos 1 ao last deste texto hexadecimal.

Etapas necessárias para que se convert um endereço de memória para um texto da cifra binária;
Etapas necessárias para que se convert um número para um texto da cifra binária:
Split o número A um wyrd e uma segunda wyrd.
Convert o wyrd para o texto da cifra binária.
Convert o segunda wyrd para uma segunda texto da cifra binária.
Posponha o segunda texto da cifra binária para o texto da cifra binária.

Etapas necessárias para que se convert um endereço de memória para um string:
Convert o endereço de memória para o string como um texto da cifra binária.

Etapas necessárias para que se convert alguns points para alguns precise degrees:
Atribua o points times 3840 dividido por 3600 ao precise degrees.

Etapas necessárias para que se convert uma position para um posicionamento absoluto usando um text:
Se o text for inexistente, limpe o posicionamento absoluto; exit.
Atribua 0 ao posicionamento absoluto.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se o número da linha desta row for menor do que o número da linha desta position, adicione o length deste string desta row para o posicionamento absoluto; repita.
Adicione o column# desta position para o posicionamento absoluto.

Etapas necessárias para que se convert alguns precise degrees para alguns points:
Atribua os precise degrees times 3600 dividido por 3840 ao points.

Etapas necessárias para que se convert um query string para um string:
Limpe o string.
Se o query string estiver em branco, cancele.
Lance um subtexto sobre o query string.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for o sinal de adição, posponha " " para o string; adicione 1 para o first deste subtexto; repita.
Se o target deste first deste subtexto não for o sinal de porcentagem, posponha o target deste first deste subtexto para o string; adicione 1 para o first deste subtexto; repita.
Se o length deste subtexto for menor do que 3, cancele.
Adicione 1 para o first deste subtexto.
Convert o target deste first deste subtexto para uma cifra binária.
Shift a cifra binária left 4 bits.
Adicione 1 para o first deste subtexto.
Convert o target deste first deste subtexto para uma segunda cifra binária.
Disjuncione logicamente a cifra binária with o segunda cifra binária.
Adicione 1 para o first deste subtexto.
Posponha a cifra binária para o string.
Repita.

Etapas necessárias para que se convert alguns rows para um string:
Limpe o string.
Percorra.
Obtenha um row from a rows.
Se a row for inexistente, cancele.
Posponha o string deste row para o string.
Se o target deste last deste string é o return pedaço, posponha o linefeed pedaço para o string; repita.
Repita.

Etapas necessárias para que se convert alguns rows para um string (no linefeed additions):
Limpe o string.
Percorra.
Obtenha um row from a rows.
Se a row for inexistente, cancele.
Posponha o string deste row para o string.
Repita.

Etapas necessárias para que se convert um string e um actual font info e um original font info Para um trecho por pdf output:
Limpe o trecho.
Atribua 0 A um current byte#.
Lance um subtexto sobre o first pedaço of o string.
Percorra.
Se o first deste subtexto for maior do que o last deste string, pare.
Se o last deste subtexto é o last deste string, pare.
Obtenha um current width usando o current byte# e as font widths desta actual font info.
Obtenha um original width usando o target deste last deste subtexto e o font widths desta original font info.
Atribua o original width menos o current width A um offset.
Se o offset for 0, adicione 1 para o last deste subtexto; adicione 1 para o current byte#; repita.
Convert o subtexto para um pdf string.
Posponha o pdf string then " " then o offset then " " para o trecho.
Atribua o last deste subtexto mais 1 ao last deste subtexto.
Atribua o last deste subtexto ao first deste subtexto.
Adicione 1 para o current byte#.
Repita.
Se o first deste subtexto for maior do que o last deste string, cancele.
Convert o subtexto para uma segunda pdf string.
Posponha o segunda pdf string para o trecho.

Etapas necessárias para que se convert um string para um alarme:
Se o string for "sí", acione o alarme; exit.
Se o string for "s", acione o alarme; exit.
Se o string for "sim", acione o alarme; exit.
Se o string for "y", acione o alarme; exit.
Se o string for "yes", acione o alarme; exit.
[Se o texto não informado não for nenhuma dessas opções, então:] Desative o alarme.

Etapas necessárias para que se convert um string para um fração:
Limpe a fração.
Se o string estiver em branco, cancele.
Se o string for any integer, convert o string para o numerador desta fração; exit.
Lance um subtexto sobre o string.
Se o target deste first deste subtexto for any sign, adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, cancele.
Split o subtexto A um integer subtexto e uma fração subtexto usando o hífem.
Se o integer subtexto estiver em branco, atribua o subtexto à fração subtexto.
Split a fração subtexto A um numerador subtexto e um denominador subtexto usando o slash pedaço.
Convert o integer subtexto para um whole número.
Convert o numerador subtexto para um numerador número.
Convert o denominador subtexto para um denominador número.
Se o whole número é negative, cancele.
Se o numerador número é negative, cancele.
Se o denominador número é negative, cancele.
Se o denominador número for 0, cancele.
Se o whole número não for 0, adicione o denominador número times o whole número para o numerador número.
Atribua o numerador número ao numerador desta fração.
Atribua o denominador número ao denominador desta fração.
Se o target deste first deste string é o hífem, negate a fração.

Etapas necessárias para que se convert um string para um texto da cifra binária:
Limpe o texto da cifra binária.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Convert o target deste first deste subtexto para uma segunda texto da cifra binária.
Posponha o segunda texto da cifra binária para o texto da cifra binária.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se convert um string para um número:
Atribua 0 ao número.
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for any sign, adicione 1 para o first deste subtexto.
Percorra.
Se o subtexto estiver em branco, pare.
Multiplique o número por 10.
Atribua o target deste first deste subtexto A uma segunda número.
Subtraia 48 from o segunda número.
Adicione o segunda número para o número.
Adicione 1 para o first deste subtexto.
Repita.
Se o target deste first deste string é o hífem, negate o número.

Etapas necessárias para que se convert um string para um número between uma segunda número e um terceiro número:
Convert o string para o número.
Limite o número para o segunda número e o terceiro número.

Etapas necessárias para que se convert um string para um pdf string:
Atribua "(" ao pdf string.
Lance um subtexto sobre o string.
Subtraia 1 from o first deste subtexto.
Percorra.
Adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, pare.
Se o target deste first deste subtexto for o left-paren pedaço, posponha "\(" para o pdf string; repita.
Se o target deste first deste subtexto for o right-paren pedaço, posponha "\)" para o pdf string; repita.
Se o target deste first deste subtexto for a barra invertida, posponha "\\" para o pdf string; repita.
Posponha o target deste first deste subtexto para o pdf string.
Repita.
Posponha ")" para o pdf string.

Etapas necessárias para que se convert um string para um endereço de memória:
\ assumes endereço de memória estiver em cifra binária format
Convert o string como um texto da cifra binária para um texto hexadecimal.
Esvazie o endereço de memória.
Lance um subtexto sobre o texto hexadecimal.
Atribua 24 A um shift contagem.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o shift contagem for menor do que 0, cancele.
Atribua o target deste first deste subtexto A um número.
Shift o número left o shift contagem.
Disjuncione logicamente o endereço de memória como um número with o número.
Adicione 1 para o first deste subtexto.
Subtraia 8 from o shift contagem.
Repita.

Etapas necessárias para que se convert um string para um query string:
Limpe o query string.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, pare.
Convert o target deste first deste subtexto para um query pedaço.
Posponha o query pedaço para o query string.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se convert um string para alguns rows:
Lance um percorredor sobre o string.
Percorra.
Mova o percorredor (text file rules).
Se o token deste percorredor estiver em branco, pare.
Crie um row usando o token deste percorredor.
Posponha a row para a rows.
Se o target deste last deste string desta row é o linefeed pedaço, atribua o return pedaço ao target deste last deste string desta row. 
\ *dahn new para handle lines terminated por just linefeed
Repita.
Renumber a rows.

Etapas necessárias para que se convert um string para um uuid:
Convert o string para um wide string e null terminate.
Call "ole32.dll" "CLSIDFromString" with o first deste wide string e o whereabouts deste uuid.

Etapas necessárias para que se convert um string para um wide string:
Limpe o wide string.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Posponha o target deste first deste subtexto para o wide string.
Posponha o null pedaço para o wide string.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se convert um string para um wide string e null terminate:
Convert o string para o wide string.
Null terminate o wide string.

Etapas necessárias para que se convert um url para um url conjunto:
Isole o url.
Null terminate o url.
Atribua um urlcomponents' magnitude ao dwstructsize destes urlcomponents.
Atribua 1 ao dwschemelength destes urlcomponents.
Atribua 1 ao dwhostnamelength destes urlcomponents.
Atribua 1 ao dwurlpathlength destes urlcomponents.
Atribua 1 ao dwextrainfolength destes urlcomponents.
Call "wininet.dll" "InternetCrackUrlA" with o url's first e 0 e 0 e o whereabouts destes urlcomponents returning um número.
Convert o lpszscheme destes urlcomponents e o dwschemelength destes urlcomponents para o scheme deste url conjunto.
Convert o lpszhostname destes urlcomponents e o dwhostnamelength destes urlcomponents para o host name deste url conjunto.
Convert o lpszurlpath destes urlcomponents e o dwurlpathlength destes urlcomponents para o endereço completo deste url conjunto.
Convert o lpszextrainfo destes urlcomponents e o dwextrainfolength destes urlcomponents para o extra deste url conjunto.
Atribua o nport destes urlcomponents ao port número deste url conjunto.

Etapas necessárias para que se convert um wyrd para um texto da cifra binária:
Split o wyrd A um pedaço e uma segunda pedaço.
Convert o pedaço para o texto da cifra binária.
Convert o segunda pedaço para uma segunda texto da cifra binária.
Posponha o segunda texto da cifra binária para o texto da cifra binária.

Um coord é alguns twips.

Etapas necessárias para que se copy pedaços from um endereço de memória para uma segunda endereço de memória por um quantidade de pedaços:
\ copy handling overlap with 1 pedaço moves
Intel $8BB508000000. \ mov esi,[ebp+8] \ o endereço de memória
Intel $8B36. \ mov esi,[esi]
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ o segunda endereço de memória
Intel $8B3F. \ mov edi,[edi]
Intel $8B8D10000000. \ mov ecx,[ebp+16] \ o número
Intel $8B09. \ mov ecx,[ecx]
\ check por something para copy
Intel $81F900000000. \ cmp ecx,0
Intel $0F8E39000000. \ jle end
\ check por no overlap
Intel $3BF7. \ cmp esi,edi
Intel $0F8D24000000. \ jge forward
Intel $8BC6. \ mov eax,esi
Intel $03C1. \ adicione eax,ecx
Intel $3BC7. \ cmp eax,edi
Intel $0F8E18000000. \ jle forward
\ copy backward
Intel $03F1. \ adicione esi,ecx
Intel $4E. \ dec esi
Intel $03F9. \ adicione edi,ecx
Intel $4F. \ dec esi
\ backward
Intel $8A16. \ mov dl,[esi]
Intel $8817. \ mov [edi],dl
Intel $4E. \ dec esi
Intel $4F. \ dec edi
Intel $49. \ dec ecx
Intel $0F85F3FFFFFF. \ jnz backward
Intel $E90D000000. \ jmp end
\ forward: copy forward
Intel $8A16. \ mov dl,[esi]
Intel $8817. \ mov [edi],dl
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $0F85F3FFFFFF. \ jnz forward

Etapas necessárias para que se copy um event Para uma segunda event:
Se o event for inexistente, esvazie o segunda event; exit.
Crie o segunda event.
Atribua a categoria deste event à categoria deste segunda event.
Atribua o shift alarme deste event ao shift alarme deste segunda event.
Atribua o ctrl alarme deste event ao ctrl alarme deste segunda event.
Atribua o alt alarme deste event ao alt alarme deste segunda event.
Atribua o spot deste event ao spot deste segunda event.
Atribua a tecla deste event à tecla deste segunda event.
Atribua o pedaço deste event ao pedaço deste segunda event.

Etapas necessárias para que se copy um gpbitmap Para uma segunda gpbitmap:
Se o gpbitmap for inexistente, esvazie o segunda gpbitmap; exit.
Call "gdiplus.dll" "GdipCloneBitmapAreaI" with 0 e 0 e o width deste gpbitmap e a altura deste gpbitmap e 0 [pixelformatdontcare] and the gpbitmap e o whereabouts deste segunda gpbitmap.

Etapas necessárias para que se copy o guts of um text Para uma segunda text:
Se o text for inexistente, cancele.
Se o segunda text for inexistente, cancele.
Atribua a caixa deste text à caixa deste segunda text.
Atribua a origin deste text à origin deste segunda text.
Atribua o pincel deste text ao pincel deste segunda text.
Atribua a font deste text à font deste segunda text.
Atribua o alinhamento deste text ao alinhamento deste segunda text.
Copy as rows deste text Into as rows deste segunda text.
Atribua a margin deste text à margin deste segunda text.
Atribua a scale deste text à scale deste segunda text.
Atribua o wrap alarme deste text ao wrap alarme deste segunda text.
Atribua o horizontal scroll alarme deste text ao horizontal scroll alarme deste segunda text.
Atribua o vertical scroll alarme deste text ao vertical scroll alarme deste segunda text.
Atribua a selection deste text à selection deste segunda text.
Atribua o alarme de alteração deste text ao alarme de alteração deste segunda text.
Atribua o last operation deste text ao last operation deste segunda text.
\ dont copy undos e redos

Um copy é um número.

Etapas necessárias para que se copy uma picture Para uma segunda picture:
Se o picture for inexistente, esvazie a segunda picture; exit.
Allocate memory pela segunda picture.
Atribua a caixa desta picture à caixa desta segunda picture.
Atribua a uncropped caixa desta picture à uncropped caixa desta segunda picture.
Atribua o grayscale alarme desta picture ao grayscale alarme desta segunda picture.
Atribua o mirror alarme desta picture ao mirror alarme desta segunda picture.
Atribua o ângulo de rotação desta picture ao ângulo de rotação desta segunda picture.
Atribua os data desta picture aos data desta segunda picture.
Copy o gpbitmap desta picture ao gpbitmap desta segunda picture.

Etapas necessárias para que se copy um polygon Para uma segunda polygon:
Se o polygon for inexistente, esvazie o segunda polygon; exit.
Allocate memory pelo segunda polygon.
Copy os vértices deste polygon a os vértices deste segunda polygon.

Etapas necessárias para que se copy um row Para uma segunda row:
Se a row for inexistente, esvazie a segunda row; exit.
Allocate memory pelo segunda row.
Atribua a número da linha desta row ao número da linha desta segunda row.
Atribua o string desta row ao string desta segunda row.

Etapas necessárias para que se copy alguns rows Para alguns segunda rows:
Destroy o segunda rows.
Percorra.
Obtenha um row from a rows.
Se a row for inexistente, cancele.
Copy a row A uma segunda row.
Posponha a segunda row para o segunda rows.
Repita.

Etapas necessárias para que se copy um text Para uma segunda text:
Se o text for inexistente, esvazie o segunda text; exit.
Allocate memory pelo segunda text.
Copy o guts of o text ao segunda text.

Etapas necessárias para que se copy um vértice Para uma segunda vértice:
Se o vértice for inexistente, esvazie o segunda vértice; exit.
Allocate memory pelo segunda vértice.
Atribua a coordenada x deste vértice à coordenada x deste segunda vértice.
Atribua a coordenada y deste vértice à coordenada y deste segunda vértice.

Etapas necessárias para que se copy alguns vértices Para alguns segunda vértices:
Destroy os segunda vértices.
Percorra.
Obtenha um vértice from o vértices.
Se o vértice for inexistente, cancele.
Copy o vértice A uma segunda vértice.
Posponha o segunda vértice para o segunda vértices.
Repita.

O símbolo de direitos autorais é um pedaço igual a 169.

Um contagem é um número.

Um contador é um número.

Etapas necessárias para que se crie o connect handle of um winhttp request using um url conjunto:
Se o winhttp request for inexistente, cancele.
Convert o host name deste url conjunto A um wide string called wide host name e null terminate.
Call "winhttp.dll" "WinHttpConnect" With a session desta request deste winhttp And o first deste wide host name And a port deste url conjunto And 0 Returning a connection deste winhttp request.
Se a connection deste winhttp request for 0, atribua "Erro. Não foi possível estabelecer uma conexão." ao i/o erro; exit.

Etapas necessárias para que se crie um console:
Allocate memory pelo console.
Atribua o cor cinza muito claro à border deste console.
Atribua o cor cinza muito claro ao fill deste console.
Atribua a caixa desta tela à caixa deste console.
Atribua a caixa desta tela A uma caixa.
Subtraia a altura desta default font from a base desta caixa.
Atribua a altura desta caixa dividido pela altura desta default font times a altura desta default font A um altura.
Atribua o topo desta caixa mais o altura à base desta caixa.
Centralize o caixa na caixa desta tela (vertically).
Atribua o topo desta caixa ao left desta caixa.
Subtraia o topo desta caixa from o right desta caixa.
Crie o text deste console.
Atribua o caixa à caixa deste text deste console.
Ligue o wrap alarme deste text deste console.
Desative o horizontal scroll alarme deste text deste console.
Ligue o vertical scroll alarme deste text deste console.
Atribua a altura desta default font ao grid deste console.
Multiplique o número x deste grid deste console por 2.

Etapas necessárias para que se crie um crypt session with um passphrase string:
\ sets i/o erro if failure
Limpe o i/o erro.
Allocate memory pelo crypt session.
\ acquire context
Call "advapi32.dll" "CryptAcquireContextA" with o whereabouts deste hcryptprov deste crypt session e 0 e "Microsoft Enhanced Cryptographic Provider v1.0"'s first And 1 [prov_rsa_full] e -268435456 [crypt_verifycontext] returning um result número.
Se o result for 0, atribua "Erro. Não foi possível adquirir o contexto." ao i/o erro; destroy o crypt session; exit.
\ crie hash
Call "advapi32.dll" "CryptCreateHash" with o hcryptprov deste crypt session e 32771 [calg_md5] e 0 e 0 And o whereabouts deste hcrypthash deste crypt session returning o result número.
Se o result for 0, atribua "Erro. Não foi possível criar o hash." ao i/o erro; destroy o crypt session; exit.
\ hash passphrase
Call "advapi32.dll" "CryptHashData" with o hcrypthash deste crypt session e o first desta passphrase e o length desta passphrase e 0 returning o result número.
Se o result for 0, atribua "Erro. Não foi possível fazer o hash da senha." ao i/o erro; destroy o crypt session; exit.
\ derive session tecla
Call "advapi32.dll" "CryptDeriveKey" with o hcryptprov deste crypt session e 26625 [calg_rc4 stream cipher] e o hcrypthash deste crypt session And 8388608 [128 bit] e o whereabouts deste hcryptkey desta crypt session returning o result número.
Se o result for 0, atribua "Erro. Não foi possível derivar a chave da sessão." ao i/o erro; destroy o crypt session; exit.

Etapas necessárias para que se crie um dyad:
Allocate memory pelo dyad.

Etapas necessárias para que se crie um event:
Allocate memory pelo event.

Etapas necessárias para que se crie uma font info usando um font:
Crie o font info usando o font (basic data).
Crie as font widths desta font info usando o font.

Etapas necessárias para que se crie uma font info usando uma font (basic data):
Allocate memory pelo font info.
Atribua o font ao font desta font info.
Obtenha um outlinetextmetric usando o font.
Atribua 32 ao flags deste font info. \ could ser updated with um more information
Atribua o tminternalleading destes otmtextmetrics deste outlinetextmetric ao internal leading desta font info.
Atribua o otmemsquare deste outlinetextmetric ao emsquare desta font info.
Atribua o tmascent deste otmtextmetrics deste outlinetextmetric ao ascent desta font info.
Atribua - o tmdescent deste otmtextmetrics deste outlinetextmetric ao descent desta font info.
Atribua o otmscapemheight deste outlinetextmetric ao capheight desta font info.
Atribua o otmitalicangle deste outlinetextmetric ao italicangle desta font info.
Atribua 0 ao stemv desta font info. \ dont know where para obtenha this from
Atribua o otmrcfontbox deste outlinetextmetric ao font caixa desta font info.

Etapas necessárias para que se crie uma font info usando uma font e um string:
\ creates widths based sobre characters em string
Crie o font info usando a font (basic data).
Crie as font widths desta font info usando o font e o string.

Etapas necessárias para que se crie alguns font widths usando um font:
Allocate memory pelo font widths.
Atribua o font à font destas font widths.
Atribua 256 à contagem destas font widths.
Assign o data destes font widths usando a contagem destas font widths times um número's magnitude.
Crie o hfont of o memory canvas usando o font.
Assign um original abc endereço de memória usando 256 times um abc's magnitude.
Call "gdi32.dll" "GetCharABCWidthsA" with o memory canvas e 0 e 255 e o original abc endereço de memória.
Destroy o hfont of o memory canvas.
Atribua o original abc endereço de memória A um abc endereço de memória.
Atribua o data destes font widths A um número endereço de memória.
Percorra.
Se um contador é past 256, pare.
Atribua o abca deste abc endereço de memória ao target deste número endereço de memória .
Adicione o abcb deste abc endereço de memória para o target deste número endereço de memória .
Adicione o abcc deste abc endereço de memória para o target deste número endereço de memória .
Adicione a magnitude deste abc para o abc endereço de memória.
Adicione a magnitude deste número para o número endereço de memória.
Repita.
Unassign o original abc endereço de memória.

Etapas necessárias para que se crie alguns font widths usando uma font e um string:
Allocate memory pelo font widths.
Atribua o font à font destas font widths.
Atribua o length deste string à contagem destas font widths.
Se o string estiver em branco, cancele.
Atribua um gcpresults' magnitude ao lstructsize destes gcpresults.
Atribua o length deste string ao nglyphs destes gcpresults.
Assign o lpdx destes gcpresults usando o length deste string times um número's magnitude.
Crie o hfont of o memory canvas usando o font.
Call "gdi32.dll" "GetCharacterPlacementA" with o memory canvas e o first deste string And o length deste string e 0 e o whereabouts deste gcpresults e 0.
Destroy o hfont of o memory canvas.
Atribua o lpdx destes gcpresults ao data destes font widths.

Etapas necessárias para que se crie um gpbitmap usando um trecho:
Limpe o i/o erro.
Call "kernel32.dll" "GlobalAlloc" with 2 [gmem_moveable] e o length deste trecho returning um handle.
Call "kernel32.dll" "GlobalLock" with o handle returning um endereço de memória.
Copy pedaços from o first deste trecho para o endereço de memória pelo length deste trecho.
Call "kernel32.dll" "GlobalUnlock" with o handle.
Call "ole32.dll" "CreateStreamOnHGlobal" with o handle e 1 [true] e um istream's whereabouts.
Call "gdiplus.dll" "GdipCreateBitmapFromStream" with o istream e o whereabouts deste gpbitmap returning um número.
Se o número não for 0, atribua "Não sei como processar este tipo de imagem." ao i/o erro; esvazie o gpbitmap.
Call o release deste vtable deste istream with o istream.

Etapas necessárias para que se crie um gpimageattributes (grayscale):
Call "gdiplus.dll" "GdipCreateImageAttributes" with o whereabouts destes gpimageattributes.
Call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" with o gpimageattributes e 0 [coloradjusttypedefault] e 1 And o first deste grayscale cor matrix e 0 e 0 [colormatrixflagsdefault].

Etapas necessárias para que se crie o hbrush of um canvas usando um cor:
Convert a cor para um código da cor.
Se a cor estiver clear, atribua o null hbrush A um hbrush.
Se a cor não estiver clear, call "gdi32.dll" "CreateSolidBrush" with o código da cor returning o hbrush.
Call "gdi32.dll" "SelectObject" with o canvas e o hbrush.

Etapas necessárias para que se crie o hfont of um canvas usando um font:
Convert o font para um hfont.
Call "gdi32.dll" "SelectObject" with o canvas e o hfont.

Etapas necessárias para que se crie o hpen of um canvas usando um cor:
Convert a cor para um código da cor.
Se a cor estiver clear, atribua o null hpen A um hpen.
Atribua o tpp times o pincel size A um número.
Se o canvas é o printer canvas, atribua 1/96 inch times o pincel size ao número.
Se a cor não estiver clear, call "gdi32.dll" "CreatePen" with 0 [ps_solid] e o número e o código da cor returning o hpen.
Call "gdi32.dll" "SelectObject" with o canvas e o hpen.

Etapas necessárias para que se crie um hrgn usando um caixa:
Isole o caixa.
Adicione o tpp para o right-base desta caixa.
Call "gdi32.dll" "BeginPath" with o quadro atual.
Call "gdi32.dll" "Rectangle" with o quadro atual e o left desta caixa e o topo desta caixa e o right desta caixa e a base desta caixa.
Call "gdi32.dll" "EndPath" with o quadro atual.
Call "gdi32.dll" "PathToRegion" with o quadro atual returning o hrgn.

Etapas necessárias para que se crie um hrgn usando um elipse:
Atribua a caixa desta elipse A uma caixa.
Call "gdi32.dll" "BeginPath" with o quadro atual.
Call "gdi32.dll" "Ellipse" with o quadro atual e o left desta caixa e o topo desta caixa e o right desta caixa e a base desta caixa.
Call "gdi32.dll" "EndPath" with o quadro atual.
Call "gdi32.dll" "PathToRegion" with o quadro atual returning o hrgn.

Etapas necessárias para que se crie um hrgn usando um polygon:
Se o polygon for inexistente, atribua 0 ao hrgn; exit.
Crie um vértice array usando os vértices deste polygon.
Call "gdi32.dll" "LPtoDP" with o quadro atual e o spot endereço de memória deste vértice array e a contagem deste vértice array.
Call "gdi32.dll" "CreatePolygonRgn" with o spot endereço de memória deste vértice array e a contagem deste vértice array e 2 [winding] returning o hrgn.
Destroy o vértice array.

Etapas necessárias para que se crie um hrgn usando um caixa arredondada:
Se o radius desta caixa arredondada for 0, crie o hrgn usando o caixa arredondada como um caixa; exit.
Atribua o caixa arredondada A uma caixa.
Atribua o radius desta caixa arredondada times 2 A um diameter número.
Call "gdi32.dll" "BeginPath" with o quadro atual.
Call "gdi32.dll" "RoundRect" with o quadro atual e o left desta caixa e o topo desta caixa e o right desta caixa e a base desta caixa e o diameter e o diameter.
Call "gdi32.dll" "EndPath" with o quadro atual.
Call "gdi32.dll" "PathToRegion" with o quadro atual returning o hrgn.

Etapas necessárias para que se crie um index usando uma bucket contagem:
Allocate memory pelo index.
Atribua o bucket contagem à bucket contagem deste index.
Atribua um bucket conjunto's magnitude A um width.
Atribua a bucket contagem deste index times o width A um número.
Assign o first bucket deste index usando o número.
Atribua o first bucket deste index mais o número menos o width ao last bucket deste index.

Etapas necessárias para que se crie o lexicon:
Allocate memory pelo lexicon.
Crie o index deste lexicon usando 4027.

Etapas necessárias para que se crie o open handle of um winhttp request:
Se o winhttp request for inexistente, cancele.
Convert o name deste module para um wide string called wide module name e null terminate.
Call "winhttp.dll" "WinHttpOpen"
With o first deste wide module name And 0 [winhttp_access_type_default_proxy] And 0 [winhttp_no_proxy_name] And 0 [winhttp_no_proxy_bypass] And 0 Returning a session desta request deste winhttp.
Se a session desta request deste winhttp for 0, atribua "Erro. Não foi possível iniciar a conexão." ao i/o erro; exit.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos:
Se o endereço completo for endereço da pasta-format, crie o endereço completo no sistema de arquivos (pasta)[endereço]; exit.
Se o endereço completo for file-format, crie o endereço completo no sistema de arquivos (file); exit.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos (pasta)[endereço]:
Isole o endereço completo.
Remove any trailing barra invertida from o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "CreateDirectoryA" with o first deste endereço completo e 0 returning um número.
Limpe o i/o erro.
Se o número não for 0, cancele.
Atribua "Erro. Não foi possível criar a seguinte pasta: " then o endereço completo then "." ao i/o erro.

Etapas necessárias para que se crie um endereço completo no sistema de arquivos (file):
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "CreateFileA" with o first deste endereço completo e 1073741824 [generic_write] e 0 e 0 e 1 [create_new] e 128 [file_attribute_normal] e 0 returning um handle.
Call "kernel32.dll" "CloseHandle" with o handle.
Limpe o i/o erro.
Se o handle não for -1 [invalid_handle_value], cancele.
Atribua "Erro. Não foi possível criar o seguinte arquivo: " then o endereço completo then "." ao i/o erro.

Etapas necessárias para que se crie um pdf object usando um categoria:
Allocate memory pelo pdf object.
Atribua o categoria à categoria deste pdf object.

Etapas necessárias para que se crie um pdf outline entry usando um title string e uma página altura e um destination número:
Allocate memory pelo pdf outline entry.
Atribua o title string ao title deste pdf outline entry.
Atribua o página altura ao página altura deste pdf outline entry.
Atribua o destination ao destination deste pdf outline entry.

Etapas necessárias para que se crie um picture:
Allocate memory pelo picture.

Etapas necessárias para que se crie um picture usando um trecho:
Crie um gpbitmap usando o trecho.
Se o gpbitmap for inexistente, esvazie o picture; exit.
Allocate memory pelo picture.
Atribua o trecho ao data desta picture.
Atribua o gpbitmap ao gpbitmap desta picture.
Ajuste o picture (extract caixas from gpbitmap).

Etapas necessárias para que se crie um picture usando um gpbitmap:
Se o gpbitmap for inexistente, esvazie o picture; exit.
Allocate memory pelo picture.
Atribua o gpbitmap ao gpbitmap desta picture.
Ajuste o picture (extract caixas from gpbitmap).

Etapas necessárias para que se crie um picture usando um url:
Read o url A um trecho.
Crie o picture usando o trecho.

Etapas necessárias para que se crie um polygon:
Allocate memory pelo polygon.

Etapas necessárias para que se crie um quora:
Allocate memory pelo quora.

Etapas necessárias para que se crie um refer:
Allocate memory pelo refer.

Etapas necessárias para que se crie o request handle of um winhttp request using um url conjunto:
Se o winhttp request for inexistente, cancele.
Convert o endereço completo deste url conjunto A um wide string called wide endereço completo e null terminate.
Convert "POST" para um wide string called wide post string e null terminate.
Se o scheme deste url conjunto for "https", atribua 8388608 [winhttp_flag_secure] A um secure número.
Call "winhttp.dll" "WinHttpOpenRequest"
With a connection deste winhttp request
And o first deste wide post string And o first deste wide endereço completo And 0 [L"HTTP/1.1"] And 0 [winhttp_no_referer] And 0 [winhttp_default_accept_types] And o secure número Returning a request deste winhttp request.
Se a request deste winhttp request for 0, atribua "Erro na requisição winhttp. Não foi possível abrir a requisição." ao i/o erro; exit.

Etapas necessárias para que se crie um row usando um pedaço:
Allocate memory pela row.
Atribua o pedaço ao string deste row.

Etapas necessárias para que se crie um row usando um string:
Allocate memory pela row.
Atribua o string ao string deste row.

Etapas necessárias para que se crie um socket usando um host string e um port número:
\ this guy creates e connects, sets i/o erro if existe um problem
Limpe o i/o erro.
\ obtenha sockaddr
Obtenha um sockaddr usando o host.
Se o i/o erro não estiver em branco, cancele.
Atribua 2 [af_inet] ao sin_family deste sockaddr.
Atribua o port ao sin_port deste sockaddr.
\ crie socket 
Call "ws2_32.dll" "socket" with 2 [af_inet] e 1 [sock_stream] e 0 [ipproto_ip] returning o socket.
Se o socket é -1, atribua "Erro. Não foi possível criar o soquete." ao i/o erro; exit.
\ connect socket
Call "ws2_32.dll" "connect" with o socket e o whereabouts deste sockaddr e a magnitude deste sockaddr returning um result número.
Se o result não for 0, atribua "Erro. Falha na conexão com o soquete." ao i/o erro; exit.
\ abra send timeout 30 seconds
Call "ws2_32.dll" "setsockopt" with o socket e 65535 e 4101 [so_sndtimo] e 30 seconds' whereabouts e 4 returning o result número.
Se o result não for 0, atribua "Erro. Não foi possível definir o tempo limite de recepção 4101 so_sndtimo." ao i/o erro; exit.
\ abra receive timeout 30 seconds
Call "ws2_32.dll" "setsockopt" with o socket e 65535 e 4102 [so_rcvtimeo] e 30 seconds' whereabouts e 4 returning o result número.
Se o result não for 0, atribua "Erro. Não foi possível definir o tempo limite de recepção 4102 so_rcvtimeo." ao i/o erro; exit.

Etapas necessárias para que se crie um conjunto de texto usando um string:
Allocate memory pelo conjunto de texto.
Atribua o string ao string deste conjunto de texto.

Etapas necessárias para que se crie um terminal em um caixa:
Allocate memory pelo terminal.
Atribua o caixa à caixa deste terminal.
Atribua o green cor ao output cor deste terminal.
Atribua o cor verde claríssimo ao input cor deste terminal.

Etapas necessárias para que se crie um text:
Allocate memory pelo text.
Atribua a cor preta ao pincel deste text.
Atribua a default font ao font deste text.
Atribua "left" ao alinhamento deste text.
Atribua 1/1 à scale deste text.
Garanta one row no text.
Reset o origin of o text.
Reset o caret of o text.
Deselect o text.

Etapas necessárias para que se crie um vértice:
Allocate memory pelo vértice.

Etapas necessárias para que se crie um vértice array usando um contagem:
Isole a contagem.
Allocate memory pelo vértice array.
Atribua o contagem à contagem deste vértice array.
Multiplique o contagem por um spot's magnitude.
Assign o spot endereço de memória deste vértice array usando a contagem.

Etapas necessárias para que se crie um vértice array usando alguns vértices:
Crie o vértice array usando a contagem destes vértices.
Atribua o spot endereço de memória deste vértice array A um spot endereço de memória.
Percorra.
Obtenha um vértice from o vértices.
Se o vértice for inexistente, cancele.
Atribua o spot deste vértice ao target deste spot endereço de memória.
Adicione a magnitude deste spot deste vértice para o spot endereço de memória.
Repita.

Etapas necessárias para que se crie um vértice usando um spot:
Allocate memory pelo vértice.
Atribua o spot ao spot deste vértice.

Etapas necessárias para que se crie um vértice usando um coordenada x e um coordenada y:
Allocate memory pelo vértice.
Atribua o coordenada x à coordenada x deste vértice.
Atribua o coordenada y à coordenada y deste vértice.

Etapas necessárias para que se crie um winhttp request por posting para um url:
Allocate memory pelo winhttp request.
Convert o url para um url conjunto.
Crie o open handle of o winhttp request.
Se o i/o erro não estiver em branco, destroy o winhttp request; exit.
Crie o connect handle of o winhttp request using o url conjunto.
Se o i/o erro não estiver em branco, destroy o winhttp request; exit.
Crie o request handle of o winhttp request using o url conjunto.
Se o i/o erro não estiver em branco, destroy o winhttp request; exit.

O console é um console.

O texto CRLF é um string igual a $0D0A.

O sinal de adição é um pedaço igual a 43.

Um crypt session é uma coisa with
Um hcryptprov endereço de memória,
Um hcrypthash endereço de memória,
Um hcryptkey endereço de memória.

O tecla Ctrl é uma tecla igual a 17.

O símbolo genérico de moedas é um pedaço igual a 164.

O quadro atual é um canvas.

O evento atual é um event.

O número atual da cor do arco-íris é um número [1 para 6 indicating, respectively, red, orange, yellow, green, blue, purple].

Um cursor é um handle.

Etapas necessárias para que se cut um número em half:
Divida o número por 2.

O ciano cor é uma cor.

O ciano pincel é um pincel.

O tecla D/d é uma tecla igual a 68.

O obelisco é um pedaço igual a 134.
O adaga é um pedaço igual a 134.
O cruz é um pedaço igual a 134.
O óbelo é um pedaço igual a 134.
O punhal é um pedaço igual a 134.

O dark blue cor é uma cor.

O dark blue pincel é um pincel.

O dark brown cor é uma cor.

O dark brown pincel é um pincel.

\Um cor escura é uma cor.
Uma cor escura é uma cor.

O dark ciano cor é uma cor.

O dark ciano pincel é um pincel.

O cor cinza escuro é uma cor.

O dark gray pincel é um pincel.

O cor verde escuro é uma cor.

O dark green pincel é um pincel.

O dark lime cor é uma cor.

O dark lime pincel é um pincel.

O dark magenta cor é uma cor.

O dark magenta pincel é um pincel.

O cor laranja escuro é uma cor.

O dark orange pincel é um pincel.

O dark pink cor é uma cor.

O dark pink pincel é um pincel.

O dark purple cor é uma cor.

O dark purple pincel é um pincel.

O cor vermelho escuro é uma cor.

O dark red pincel é um pincel.

O dark sky blue cor é uma cor.

O dark sky blue pincel é um pincel.

O dark sky cor é uma cor.

O dark sky pincel é um pincel.

O dark teal cor é uma cor.

O dark teal pincel é um pincel.

O dark violet cor é uma cor.

O dark violet pincel é um pincel.

O cor amarelo escuro é uma cor.

O dark yellow pincel é um pincel.

Etapas necessárias para que se darken uma cor por um quantia:
Subtraia o quantia from a luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se darken uma cor por alguns percent;
Etapas necessárias para que se darken uma cor about alguns percent;
Etapas necessárias para que se darken uma cor por about alguns percent;
Etapas necessárias para que se darken uma cor alguns percent:
Atribua a luminosidade desta cor menos o percent à luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se darken o current cor about alguns percent:
Darken a cor deste context pelo percent.

O darker blue cor é uma cor.

O darker blue pincel é um pincel.

O darker brown cor é uma cor.

O darker brown pincel é um pincel.

O darker ciano cor é uma cor.

O darker ciano pincel é um pincel.

O cor cinza muito escuro é uma cor.

O darker gray pincel é um pincel.

O cor verde muito escuro é uma cor.

O darker green pincel é um pincel.

O darker lime cor é uma cor.

O darker lime pincel é um pincel.

O darker magenta cor é uma cor.

O darker magenta pincel é um pincel.

O cor laranja muito escuro é uma cor.

O darker orange pincel é um pincel.

O darker purple cor é uma cor.

O darker purple pincel é um pincel.

O cor vermelho muito escuro é uma cor.

O darker red pincel é um pincel.

O darker sky blue cor é uma cor.

O darker sky blue pincel é um pincel.

O darker sky cor é uma cor.

O darker sky pincel é um pincel.

O darker teal cor é uma cor.

O darker teal pincel é um pincel.

O darker violet cor é uma cor.

O darker violet pincel é um pincel.

O cor amarelo muito escuro é uma cor.

O darker yellow pincel é um pincel.

O darkest blue cor é uma cor.

O darkest blue pincel é um pincel.

O darkest brown cor é uma cor.

O darkest brown pincel é um pincel.

O darkest ciano cor é uma cor.

O darkest ciano pincel é um pincel.

O cor cinza escuríssimo é uma cor.

O darkest gray pincel é um pincel.

O cor verde escuríssimo é uma cor.

O darkest green pincel é um pincel.

O darkest lime cor é uma cor.

O darkest lime pincel é um pincel.

O darkest magenta cor é uma cor.

O darkest magenta pincel é um pincel.

O cor laranja escuríssimo é uma cor.

O darkest orange pincel é um pincel.

O darkest purple cor é uma cor.

O darkest purple pincel é um pincel.

O cor vermelho escuríssimo é uma cor.

O darkest red pincel é um pincel.

O darkest sky blue cor é uma cor.

O darkest sky blue pincel é um pincel.

O darkest sky cor é uma cor.

O darkest sky pincel é um pincel.

O darkest teal cor é uma cor.

O darkest teal pincel é um pincel.

O darkest violet cor é uma cor.

O darkest violet pincel é um pincel.

O cor amarelo escuríssimo é uma cor.

O darkest yellow pincel é um pincel.

O hífem é um pedaço igual a 45.
O sinal de hífem é um pedaço igual a 45.
O símbolo hífem é um pedaço igual a 45.
O traço é um pedaço igual a 45.

O tecla hífem é uma tecla igual a 189.
O tecla traço é uma tecla igual a 189.

O Data Link Escape é um pedaço igual a 16.
O DLE é um pedaço igual a 16.

Um date/time has
Um year número,
Um month número,
Um week day número,
Um day número,
Um hour número,
Um minute número,
Um second número,
Um millisecond número.

Etapas necessárias para que se de-sign um fração:
De-sign o numerador desta fração.
De-sign o denominador desta fração.

Etapas necessárias para que se de-sign um número:
Se o número for o menor número, atribua o maior número ao número; exit.
Se o número for menor do que 0, negate o número.

Etapas necessárias para que se de-sign um pair:
De-sign o número x deste pair.
De-sign o número y deste pair.

Etapas necessárias para que se de-sign um string:
Se o string estiver em branco, cancele.
Se o target deste first deste string for any sign, remove o first pedaço from o string.

Etapas necessárias para que se debug um caixa:
Limpe um string.
Posponha "izquierda=" para o string.
Posponha o left desta caixa para o string.
Posponha ", superior=" para o string.
Posponha o topo desta caixa para o string.
Posponha ", derecho=" para o string.
Posponha o right desta caixa para o string.
Posponha ", inferior=" para o string.
Posponha a base desta caixa para o string.
Debug o string.

Etapas necessárias para que se debug um pedaço:
Atribua o pedaço A um número.
Convert o número para um string.
Debug o string.

Etapas necessárias para que se debug um cor:
Limpe um string.
Posponha "matiz=" para o string.
Posponha a matiz desta cor para o string.
Posponha ", saturación=" para o string.
Posponha a saturação desta cor para o string.
Posponha ", luminosidad=" para o string.
Posponha a luminosidade desta cor para o string.
Debug o string.

Etapas necessárias para que se debug um alarme:
Convert o alarme para um string.
Debug o string.

Etapas necessárias para que se debug uma font:
Limpe um string.
Posponha "nome='" para o string then "'".
Posponha o name desta font para o string.
Posponha ", altura=" para o string.
Posponha a altura desta font para o string.
Debug o string.

Etapas necessárias para que se debug uma fração:
Limpe um string.
Posponha "numerador=" para o string.
Posponha o numerador desta fração para o string.
Posponha ", denominador=" para o string.
Posponha o denominador desta fração para o string.
Debug o string.

Etapas necessárias para que se debug um line:
Limpe um string.
Posponha "comienzo=" para o string.
Posponha o x deste start desta line para o string.
Posponha "," para o string.
Posponha o y deste start desta line para o string.
Posponha " fin=" para o string.
Posponha o x deste end desta line para o string.
Posponha "," para o string.
Posponha o y deste end desta line para o string.
Debug o string.

Etapas necessárias para que se debug um número:
Convert o número para um string.
Debug o string.

Etapas necessárias para que se debug um número e uma segunda número:
Debug o número then ", " then o segunda número.

Etapas necessárias para que se debug um pair:
Limpe um string.
Posponha "x=" para o string.
Posponha o número x deste pair para o string.
Posponha ", y=" para o string.
Posponha o número y deste pair para o string.
Debug o string.

Etapas necessárias para que se debug um endereço de memória:
Convert o endereço de memória para um texto da cifra binária.
Debug "$" then o texto da cifra binária.

Etapas necessárias para que se debug um rgb:
Limpe um string.
Posponha "red=" para o string.
Atribua o espectro vermelho deste rgb A um número.
Posponha o número para o string.
Posponha ", green=" para o string.
Atribua o espectro verde deste rgb ao número.
Posponha o número para o string.
Posponha ", blue=" para o string.
Atribua o espectro azul deste rgb ao número.
Posponha o número para o string.
Debug o string.

Etapas necessárias para que se debug um string:
Isole o string.
Null terminate o string.
Call "user32.dll" "MessageBoxA" with 0 e o first deste string e "debug"'s first e 0.

Etapas necessárias para que se debug um string (quoted):
Isole o string.
Anteponha as aspas duplas para o string.
Posponha as aspas duplas para o string.
Debug o string.

Etapas necessárias para que se debug um wyrd:
Atribua o wyrd A um número.
Convert o número para um string.
Debug o string.

Etapas necessárias para que se determine se um caixa é uma segunda caixa:
Se o left desta caixa não for o left desta segunda caixa, diga não.
Se o topo desta caixa não for o topo desta segunda caixa, diga não.
Se o right desta caixa não for o right desta segunda caixa, diga não.
Se a base desta caixa não for a base desta segunda caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um caixa está still em uma segunda caixa;
Etapas necessárias para que se determine se um caixa está em uma segunda caixa;
Etapas necessárias para que se determine se um caixa está inside uma segunda caixa:
Se o left desta caixa for menor do que o left desta segunda caixa, diga não.
Se o topo desta caixa for menor do que o topo desta segunda caixa, diga não.
Se o right desta caixa for maior do que o right desta segunda caixa, diga não.
Se a base desta caixa for maior do que a base desta segunda caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um caixa está touching uma segunda caixa:
Se o right desta segunda caixa for menor do que o left desta caixa, diga não.
Se a base desta segunda caixa for menor do que o topo desta caixa, diga não.
Se o left desta segunda caixa for maior do que o right desta caixa, diga não.
Se o topo desta segunda caixa for maior do que a base desta caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é alphanumeric:
Se o pedaço for any letra, diga sim.
Se o pedaço for any digit, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o outro byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8406000000. \ je over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é uma segunda pedaço ou um terceiro pedaço:
Se o pedaço for o segunda pedaço, diga sim.
Se o pedaço for o terceiro pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any consonant:
Se o pedaço estiver em "bcdfghjklmnpqrstvwxyzçñ", diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any digit:
Se o pedaço for menor do que o número zero, diga não.
Se o pedaço for maior do que o número nove, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é any letra:
Se o pedaço estiver entre o 'A' maiúsculo e o Z maiúsculo, diga sim.
Se o pedaço estiver entre o little-a pedaço e o z minúsculo, diga sim.
Se o pedaço for 131 ou 138, diga sim.
Se o pedaço for 140 ou 142, diga sim.
Se o pedaço for 154 ou 156, diga sim.
Se o pedaço estiver entre 158 e 159, diga sim.
Se o pedaço estiver entre 192 e 214, diga sim.
Se o pedaço estiver entre 216 e 246, diga sim.
Se o pedaço estiver entre 248 e 255, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any numeric starter:
Se o pedaço é any digit, diga sim.
Se o pedaço é any sign, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any punctuation mark:
\ *** questionable?
Se o pedaço for o caractere de espaço, diga não.
Se o pedaço não for alphanumeric, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any sign:
Se o pedaço for o hífem, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any valid unidade de disco:
Atribua o pedaço A um endereço completo.
Posponha ":\" para o endereço completo.
Obtenha um categoria da unidade de disco pelo endereço completo.
Se o categoria da unidade de disco for "", diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é any vowel:
Se o pedaço estiver em "aeiou", diga sim.
\ if o pedaço for "y", say sometimes. \ ha ha ha
Diga não.

Etapas necessárias para que se determine se um pedaço está entre uma segunda pedaço e um terceiro pedaço:
Se o pedaço for menor do que o segunda pedaço, diga não.
Se o pedaço for maior do que o terceiro pedaço, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço está entre um número e uma segunda número:
Se o pedaço for menor do que o número, diga não.
Se o pedaço for maior do que o segunda número, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é maior que uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é maior do que uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8706000000. \ ja over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é maior que um número;
Etapas necessárias para que se determine se um pedaço é maior do que um número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8F06000000. \ jg over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false


Etapas necessárias para que se determine se um pedaço é maior do que ou igual para uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é maior que ou igual para uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é maior ou igual para uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8306000000. \ ja over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço estiver em um string:
Isole o pedaço.
Lowercase o pedaço.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, diga não.
Atribua o target deste first deste subtexto A uma segunda pedaço.
Lowercase o segunda pedaço.
Se o segunda pedaço é o pedaço, diga sim.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se determine se um pedaço é menor que uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é menor do que uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8206000000. \ jb over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é menor que um número;
Etapas necessárias para que se determine se um pedaço é menor do que um número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8C06000000. \ jl over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é menor do que ou igual para uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é menor que ou igual para uma segunda pedaço;
Etapas necessárias para que se determine se um pedaço é menor ou igual para uma segunda pedaço:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8606000000. \ jbe over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é like uma segunda pedaço:
\ used internally por palavra wrap
Se o pedaço é whitespace, acione um alarme.
Se o segunda pedaço é whitespace, acione uma segunda alarme.
Se o alarme é o segunda alarme, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é noise:
Se o pedaço for menor do que ou igual ao caractere de espaço, diga sim.
Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga sim.
Se o pedaço for o non-breaking-caractere de espaço, diga sim.
Se o pedaço for 129, diga sim.
Se o pedaço for 141, diga sim.
Se o pedaço for 143, diga sim.
Se o pedaço for 144, diga sim.
Se o pedaço for 157, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é um número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8406000000. \ je over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um pedaço é um número ou uma segunda número:
Se o pedaço for o número, diga sim.
Se o pedaço for o segunda número, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é printable:
Se o pedaço for menor do que o caractere de espaço, diga não.
Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga não.
Se o pedaço for 129, diga não.
Se o pedaço for 141, diga não.
Se o pedaço for 143, diga não.
Se o pedaço for 144, diga não.
Se o pedaço for 157, diga não.
Diga sim.

Etapas necessárias para que se determine se um pedaço é um string:
Se o length deste string não for 1, diga não.
Isole o pedaço.
Lowercase o pedaço.
Atribua o target deste first deste string A uma segunda pedaço.
Lowercase o segunda pedaço.
Se o pedaço for o segunda pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é symbolic:
Se o pedaço estiver entre o exclamation pedaço e o slash pedaço, diga sim.
Se o pedaço estiver entre o sinal de dois pontos e o sinal de arroba, diga sim.
Se o pedaço estiver entre o left-bracket pedaço e o acento grave, diga sim.
Se o pedaço estiver entre o left-brace pedaço e o acento til, diga sim.
Se o pedaço for 128, diga sim.
Se o pedaço for 130, diga sim.
Se o pedaço estiver entre 132 e 137, diga sim.
Se o pedaço for 139, diga sim.
Se o pedaço estiver entre 145 e 153, diga sim.
Se o pedaço for 155, diga sim.
Se o pedaço estiver entre 161 e 180, diga sim.
Se o pedaço estiver entre 183 e 191, diga sim.
Se o pedaço for 215, diga sim.
Se o pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é whitespace:
Se o pedaço for o caractere de espaço, diga sim.
Se o pedaço for o tabulação horizontal, diga sim.
Se o pedaço for o return pedaço, diga sim.
Se o pedaço for o linefeed pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se o caret of um text é at o beginning:
Se o text for inexistente, diga não.
Se o caret número da linha deste text não for 1, diga não.
Se o caret column# deste text não for 1, diga não.
Diga sim.

Etapas necessárias para que se determine se o caret of um text é at o end:
Se o text for inexistente, diga não.
Se o caret número da linha deste text não for a contagem destas rows deste text, diga não.
Obtenha um row usando o caret número da linha deste text e o text.
Se o caret column# deste text não for o length deste string desta row, diga não.
Diga sim.

Etapas necessárias para que se determine se o caret of um text é sobre o first line:
Se o text for inexistente, diga não.
Se o caret número da linha deste text não for 1, diga não.
Diga sim.

Etapas necessárias para que se determine se o caret of um text está sobre o last line:
Se o text for inexistente, diga não.
Se as rows deste text estiverem vazio, diga não.
Se o caret número da linha deste text não for o número da linha desta last row deste text, diga não.
Diga sim.

Etapas necessárias para que se determine se uma choice é um string:
Se a choice for inexistente, diga não.
Se o name desta choice for o string, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor e uma segunda cor estão clear:
Se a cor não estiver clear, diga não.
Se o segunda cor não estiver clear, diga não.
Diga sim.

Etapas necessárias para que se determine se uma cor é uma segunda cor:
Se a matiz desta cor não for a matiz desta segunda cor, diga não.
Se a saturação desta cor não for a saturação desta segunda cor, diga não.
Se a luminosidade desta cor não for a luminosidade desta segunda cor, diga não.
Diga sim.

Etapas necessárias para que se determine se uma cor está clear:
Se a matiz desta cor for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é dark:
Se a luminosidade desta cor estiver entre 250 e 374, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é light:
Se a luminosidade desta cor estiver entre 625 e 749, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é normal:
Se a luminosidade desta cor estiver entre 375 e 624, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é very dark:
Se a luminosidade desta cor estiver entre 125 e 249, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é very light:
Se a luminosidade desta cor estiver entre 750 e 874, diga sim.
Diga não.

Etapas necessárias para que se determine se uma cor é very very dark:
Se a luminosidade desta cor for menor do que ou igual a 124, diga sim.
Diga não.


Etapas necessárias para que se determine se uma cor é very very light:
Se a luminosidade desta cor for maior do que ou igual a 875, diga sim.
Diga não.

Etapas necessárias para que se determine se um contador é past um número:
Adicione 1 para o contador.
Se o contador for maior do que o número, diga sim.
Diga não.

Etapas necessárias para que se determine se o current spot é above ou below um caixa:
Se o spot deste context é above ou below o caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se o current spot está left ou right of um caixa:
Se o spot deste context é left ou right of o caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se o current spot está para o right of um caixa:
Se o x deste spot deste context for maior do que o right desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se o current spot está within alguns twips of um caixa:
Se o spot deste context estiver within o twips of o caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um difference está within um grid:
Isole a difference.
De-sign a difference.
Se o número x desta difference for maior do que ou igual ao número x desta grid, diga não.
Se o número y desta difference for maior do que ou igual ao número y desta grid, diga não.
Diga sim.

Etapas necessárias para que se determine se um event é any shortcut:
Se o event for inexistente, diga não.
Se a categoria deste event não for "pressionamento de tecla", diga não.
Se o event não for modified, diga não.
Se a tecla deste event estiver entre a tecla A/a e a tecla Z/z, diga sim.
Diga não.

Etapas necessárias para que se determine se um event foi modified:
Se o ctrl alarme deste event estiver ativo, diga sim.
Se o alt alarme deste event estiver ativo, diga sim.
Diga não.

Etapas necessárias para que se determine se um finger é past o end of um string:
Se o finger for inexistente, diga sim.
Se o finger for maior do que o last deste string, diga sim.
Diga não.

Etapas necessárias para que se determine se um alarme é um número;
Etapas necessárias para que se determine se um alarme é uma segunda alarme;
Etapas necessárias para que se determine se um endereço de memória é um número;
Etapas necessárias para que se determine se um endereço de memória é uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8406000000. \ je over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

\Etapas necessárias para que se determine se um alarme está on:
\ switch como uma segunda name por alarme also ? ***
\Se o alarme estiver ativo, diga sim.
\Diga não.

Etapas necessárias para que se determine se um alarme está presente;
Etapas necessárias para que se determine se um alarme está em vigor;
Etapas necessárias para que se determine se um alarme está levantada;
Etapas necessárias para que se determine se um alarme está ligado; \foi ligado também funciona
Etapas necessárias para que se determine se um alarme está ativo;
Etapas necessárias para que se determine se um alarme está ativado; \foi ativado
\Etapas necessárias para que se determine se um alarme já está ativado;
Etapas necessárias para que se determine se um alarme já foi ativado anteriomente;
\Etapas necessárias para que se determine se um alarme foi ativado anteriomente;
Etapas necessárias para que se determine se um alarme está tocando;
Etapas necessárias para que se determine se um alarme está soando;
Etapas necessárias para que se determine se um alarme soou;
\Etapas necessárias para que se determine se um alarme já soou;
Etapas necessárias para que se determine se um alarme está disparando;
\Etapas necessárias para que se determine se um alarme disparou;
Etapas necessárias para que se determine se um alarme está alarmando;
\Etapas necessárias para que se determine se um alarme disparou;
Etapas necessárias para que se determine se um alarme está sendo mostrada;
Etapas necessárias para que se determine se um alarme está sendo exibida;
Etapas necessárias para que se determine se um alarme está verde:
Se o alarme for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um alarme está dormente;
Etapas necessárias para que se determine se um alarme está suspenso;
Etapas necessárias para que se determine se um alarme está inativo;
Etapas necessárias para que se determine se um alarme está desligado;
Etapas necessárias para que se determine se um alarme está desativado;
Etapas necessárias para que se determine se um alarme está vermelho:
Se o alarme for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração é o numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é maior que uma segunda fração;
Etapas necessárias para que se determine se uma fração é maior do que uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração for maior do que o numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é maior do que ou igual para uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração for maior do que ou igual ao numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é menor que uma segunda fração;
Etapas necessárias para que se determine se uma fração é menor do que uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração for menor do que o numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração for menor do que ou igual para uma segunda fração;
Etapas necessárias para que se determine se uma fração for menor que ou igual para uma segunda fração;
Etapas necessárias para que se determine se uma fração for menor ou igual para uma segunda fração:
Isole a fração.
Isole a segunda fração.
Normalize a fração e a segunda fração.
Se o numerador desta fração for menor do que ou igual ao numerador desta segunda fração, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é negative:
Se o numerador desta fração for menor do que 0, reverse um alarme.
Se o denominador desta fração for menor do que 0, reverse o alarme.
\ Say o alarme. \ does not work em SAL; no alarme literals anymore
Se o alarme estiver ativo, diga sim.
Diga não.

Etapas necessárias para que se determine se uma fração é um número:
Se a fração é o número / 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um index está vazia;
Etapas necessárias para que se determine se um index estão vazias;
Etapas necessárias para que se determine se um index estão vazios;
Etapas necessárias para que se determine se um index está vazio:
Se o index for inexistente, diga sim.
Percorra.
Obtenha um bucket usando o index.
Se o bucket for inexistente, diga sim.
Se os refers deste bucket não estiverem vazio, diga não.
Repita.

Etapas necessárias para que se determine se um input é from windows telling us para atualize o cursor;
Etapas necessárias para que se determine se um input é from windows telling us para abra o cursor:
Se o input for inexistente, diga não.
Se a categoria deste input for "mostrar seta", diga sim.
Diga não.

Etapas necessárias para que se determine se um input é from windows telling us para mostre all our stuff;
Etapas necessárias para que se determine se um input é from windows telling us para mostre all of our stuff;
Etapas necessárias para que se determine se um input é from windows telling us para redraw all our stuff;
Etapas necessárias para que se determine se um input é from windows telling us para redraw all of our stuff:
Se o input for inexistente, diga não.
Se a categoria deste input for "atualização de tela", diga sim.
Diga não.

Etapas necessárias para que se determine se um input é from windows telling us we're done;
Etapas necessárias para que se determine se um input é from windows telling us that we're done;
Etapas necessárias para que se determine se um input é from windows telling us o usuário has quit:
Se o input for inexistente, diga sim.
Diga não.

Etapas necessárias para que se determine se um input é um clique:
Esvazie o clique.
Se a categoria deste input não for "clique", diga não.
Atribua o input ao clique.

Etapas necessárias para que se determine se um item é found:
Se a categoria deste item não estiver em branco, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é any digit tecla:
Se a tecla estiver entre 48 e 57, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é any letra tecla:
Se a tecla estiver entre 65 e 90, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é any modifier tecla:
Se a tecla for a tecla Alt, diga sim.
Se a tecla for a tecla Ctrl, diga sim.
Se a tecla for a tecla shift ,say yes.
Diga não.

Etapas necessárias para que se determine se uma tecla é any pad tecla:
Se a tecla estiver entre 96 e 111, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é any printable tecla:
Se a tecla for o space tecla, diga sim.
Se a tecla for any digit tecla, diga sim.
Se a tecla for any letra tecla, diga sim.
Se a tecla for any pad tecla, diga sim.
Se a tecla for any symbol tecla, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é any symbol tecla:
Se a tecla estiver entre 186 e 192, diga sim.
Se a tecla estiver entre 219 e 222, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla é any wm-char tecla:
Se a tecla não for any printable tecla , diga não.
Se a tecla Alt was down, diga não.
Se a tecla Ctrl was down, diga não.
Diga sim.

Etapas necessárias para que se determine se uma tecla está sendo pressionada:
Call "user32.dll" "GetAsyncKeyState" with a tecla returning um wyrd.
Atribua o wyrd A um número.
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla está sendo pressionado:
Call "user32.dll" "GetAsyncKeyState" with a tecla returning um wyrd.
Atribua o wyrd A um número.
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla was down:
Call "user32.dll" "GetKeyState" with a tecla returning um wyrd.
Atribua o wyrd A um número.
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla was toggled:
Call "user32.dll" "GetKeyState" with a tecla returning um wyrd.
Atribua o wyrd A um número.
Conjuncione logicamente o número with 1.
Se o número for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se uma tecla was up:
Se a tecla was down, diga não.
Diga sim.

Etapas necessárias para que se determine se uma tecla with um l-param é any repeated escape ou modifier tecla:
Atribua o l-param A um número.
Conjuncione logicamente o número with 1073741824 [$40000000].
Se o número for 0, diga não.
Se a tecla for a tecla Esc, diga sim.
Se a tecla for any modifier tecla, diga sim.
Diga não.

Etapas necessárias para que se determine se o left mouse botão está down:
Se o botão esquerdo deste mouse estiver sendo pressionado, diga sim.
Diga não.

Etapas necessárias para que se determine se um line está above um caixa:
Se o y deste start desta line for maior do que ou igual ao topo desta caixa, diga não.
Se o y deste end desta line for maior do que ou igual ao topo desta caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um line é above um coord:
Se o y deste start desta line for maior do que ou igual ao coord, diga não.
Se o y deste end desta line for maior do que ou igual ao coord, diga não.
Diga sim.

Etapas necessárias para que se determine se um line é below um caixa:
Se o y deste start desta line for menor do que ou igual a a base desta caixa, diga não.
Se o y deste end desta line for menor do que ou igual a a base desta caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um line é below um coord:
Se o y deste start desta line for menor do que ou igual ao coord, diga não.
Se o y deste end desta line for menor do que ou igual ao coord, diga não.
Diga sim.

Etapas necessárias para que se determine se um line é still em um caixa;
Etapas necessárias para que se determine se um line estiver em um caixa:
Se o start desta line não estiver no caixa, diga não.
Se o end desta line não estiver no caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um mixed é um número:
Convert o mixed para um fração.
Se a fração for o número, diga sim.
Diga não.

Etapas necessárias para que se determine se o mouse has been dragged from um spot usando um grid:
Se o botão esquerdo deste mouse não estiver sendo pressionado, diga não.
Atribua o spot deste mouse A uma segunda spot.
Obtenha um difference between o segunda spot e o spot.
Se a difference estiver within o grid, repita.
Diga sim.

Etapas necessárias para que se determine se o mouse estiver em um caixa:
Se o spot deste mouse estiver no caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um número é uma segunda número e um string é uma segunda string:
Se o número não for o segunda número, diga não.
Se o string não for o segunda string, diga não.
Diga sim.

Etapas necessárias para que se determine se um número está entre uma segunda número e um terceiro número:
Se o número for menor do que o segunda número, diga não.
Se o número for maior do que o terceiro número, diga não.
Diga sim.

Etapas necessárias para que se determine se um número é par:
Se o número é ímpar, diga não.
Diga sim.

Etapas necessárias para que se determine se um número é evenly divisible por uma segunda número:
Isole o número.
Divida o número pelo segunda número giving um quotient e um resto.
Se o resto for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um número é um multiple of uma segunda número:
Se o número é evenly divisible pelo segunda número, diga sim.
Diga não.

Etapas necessárias para que se determine se um número é negative:
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um número é ímpar:
Isole o número.
Conjuncione logicamente o número with 1.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um número é positive:
Se o número for menor do que 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um número é prime:
Se o número for menor do que 2, diga não.
Se o número for 2, diga sim.
Atribua o número menos 1 A uma segunda número.
Percorra.
Se o número é evenly divisible pelo segunda número, diga não.
Subtraia 1 from o segunda número.
Se o segunda número for maior do que 1, repita.
Diga sim.

Etapas necessárias para que se determine se um pair é uma segunda pair:
Se o número x deste pair não for o número x deste segunda pair, diga não.
Se o número y deste pair não for o número y deste segunda pair, diga não.
Diga sim.

Etapas necessárias para que se determine se um pair é um número:
Se o número x deste pair não for o número, diga não.
Se o número y deste pair não for o número, diga não.
Diga sim.

Etapas necessárias para que se determine se um pair é um número e uma segunda número:
Se o número x deste pair não for o número, diga não.
Se o número y deste pair não for o segunda número, diga não.
Diga sim.

Etapas necessárias para que se determine se um endereço completo é endereço da pasta-format:
Se o endereço completo estiver em branco, diga não.
Se o target deste last deste endereço completo for a barra invertida, diga sim.
Diga não.

Etapas necessárias para que se determine se um endereço completo é drive-format:
Se o endereço completo starts with "\\", diga sim.
Se o length deste endereço completo não for 3, diga não.
Se o endereço completo ends with ":\", diga sim.
Diga não.

Etapas necessárias para que se determine se um endereço completo está vazia no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo estão vazias no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo estão vazios no sistema de arquivos;
Etapas necessárias para que se determine se um endereço completo está vazio no sistema de arquivos:
Se o endereço completo não estiver no sistema de arquivos, diga sim.
Obtenha um contagem of items no endereço completo no sistema de arquivos.
Se o contagem for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um endereço completo é file-format:
Se o endereço completo estiver em branco, diga não.
Se o target deste last deste endereço completo for o sinal de dois pontos, diga não.
Se o target deste last deste endereço completo for a barra invertida, diga não.
Diga sim.

Etapas necessárias para que se determine se um endereço completo está no sistema de arquivos:
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "GetFileAttributesA" with o first deste endereço completo returning um número.
Se o número for menor do que 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um endereço completo é read-only:
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "GetFileAttributesA" with o first deste endereço completo returning um número.
Conjuncione logicamente o número with 1 [file_attribute_readonly].
Se o número não for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um endereço de memória pode ser found;
Etapas necessárias para que se determine se um endereço de memória está coming;
\Etapas necessárias para que se determine se um endereço de memória é found;
Etapas necessárias para que se determine se um endereço de memória foi found;
Etapas necessárias para que se determine se um endereço de memória existe;
Etapas necessárias para que se determine se um endereço de memória does exist:
Se o endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um endereço de memória é maior do que uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é maior do que uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8F06000000. \ jg over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é maior do que ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é maior que ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é maior ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é uma segunda número ou more;
Etapas necessárias para que se determine se um número é maior do que ou igual para uma segunda número;
Etapas necessárias para que se determine se um número é maior que ou igual para uma segunda número;
Etapas necessárias para que se determine se um número é maior ou igual para uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8D06000000. \ jge over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é menor do que uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor que uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é menor que uma segunda número;
Etapas necessárias para que se determine se um número é menor do que uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8C06000000. \ jl over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é menor do que ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor que ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um endereço de memória é menor ou igual para uma segunda endereço de memória;
Etapas necessárias para que se determine se um número é uma segunda número ou menos;
Etapas necessárias para que se determine se um número é uma segunda número ou menor;
Etapas necessárias para que se determine se um número é menor do que ou igual para uma segunda número;
Etapas necessárias para que se determine se um número é menor que ou igual para uma segunda número;
Etapas necessárias para que se determine se um número é menor ou igual para uma segunda número:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o segunda número
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8E06000000. \ jle over o next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it is false

Etapas necessárias para que se determine se um endereço de memória é missing;
Etapas necessárias para que se determine se um endereço de memória é null e esvazie:
Se o endereço de memória for inexistente, diga sim.
Diga não.

Etapas necessárias para que se determine se um polygon está closed:
Se o polygon for inexistente, diga não.
Se a contagem destes vértices deste polygon for menor do que 3, diga não.
Se o spot deste first vértice deste polygon for o spot deste last vértice deste polygon, diga sim.
Diga não.

Etapas necessárias para que se determine se um reply é something like uma segunda reply:
Isole o reply.
Isole o segunda reply.
Simplify o reply.
Simplify o segunda reply.
Se o reply é o segunda reply, diga sim.
Diga não.

Etapas necessárias para que se determine se uma row está em branco:
Se a row for inexistente, diga sim.
Lance um subtexto sobre o string deste row.
Percorra.
Se o subtexto estiver em branco, diga sim.
Se o target deste first deste subtexto não for noise, diga não.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se determine se uma row of um text está selecionado:
Se o text for inexistente, diga não.
Se a row for inexistente, diga não.
Se nothing estiver selecionado no text, diga não.
Atribua a normalized selection deste text A uma selection.
Se o número da linha desta row for menor do que o anchor número da linha desta selection, diga não.
Se o número da linha desta row for maior do que o caret número da linha desta selection, diga não.
Se o número da linha desta row não for o caret número da linha desta selection, diga sim.
Se o caret column# desta selection for 1, diga não.
Diga sim.

Etapas necessárias para que se determine se um row of um text é visible:
Se o text for inexistente, diga não.
Se a row for inexistente, diga não.
Obtenha um caixa usando a row e o text.
Atribua a caixa deste text A uma segunda caixa.
Ajuste o segunda caixa usando 0 e o tpp e 0 e - o tpp.
Se a caixa estiver touching o segunda caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um selection é uma segunda selection:
Se o anchor desta selection não for o anchor desta segunda selection, diga não.
Se o caret desta selection não for o caret desta segunda selection, diga não.
Diga sim.

Etapas necessárias para que se determine se something está selecionado em um text:
Se o anchor deste text for o caret deste text, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot é above um caixa:
Se o y deste spot for menor do que o topo desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é above um horizontal line:
Se o y deste spot for menor do que o horizontal y deste start desta line, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é above ou below um caixa:
Se o spot é above o caixa, diga sim.
Se o spot é below o caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é below um caixa:
Se o y deste spot for maior do que a base desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é below um horizontal line:
Se o y deste spot for maior do que o horizontal y deste start desta line, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está em um elipse:
Crie um hrgn usando o elipse.
Isole o spot.
Divida o spot pelo tpp.
Call "gdi32.dll" "PtInRegion" with o hrgn e a coordenada x deste spot e a coordenada y deste spot returning um número.
Destroy o hrgn.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está em um picture:
Se o picture for inexistente, diga não.
Se o spot estiver na caixa desta picture, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está em um polygon:
Se o polygon for inexistente, diga não.
Crie um vértice array usando os vértices deste polygon.
Call "gdi32.dll" "CreatePolygonRgn" with o spot endereço de memória deste vértice array e a contagem deste vértice array e 2 [winding] returning um hrgn.
Call "gdi32.dll" "PtInRegion" with o hrgn e a coordenada x deste spot e a coordenada y deste spot returning um número.
Call "gdi32.dll" "DeleteObject" with o hrgn.
Destroy o vértice array.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está em alguns polygons:
Obtenha um polygon from o polygons.
Se o polygon for inexistente, diga não.
Se o spot estiver no polygon, diga sim.
Repita.

Etapas necessárias para que se determine se um spot está em um caixa arredondada:
Isole o caixa arredondada.
Adicione o tpp para a right-base desta caixa arredondada.
Atribua o radius desta caixa arredondada times 2 A um diameter número.
Call "gdi32.dll" "CreateRoundRectRgn" with o left desta caixa arredondada e o topo desta caixa arredondada e o right desta caixa arredondada e a base desta caixa arredondada And o diameter e o diameter returning um hrgn.
Call "gdi32.dll" "PtInRegion" with o hrgn e a coordenada x deste spot e a coordenada y deste spot returning um número.
Call "gdi32.dll" "DeleteObject" with o hrgn.
Se o número for 0, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está em um text:
Se o text for inexistente, diga não.
Se o spot estiver na caixa deste text, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é inside um caixa;
Etapas necessárias para que se determine se um spot está within um caixa;
Etapas necessárias para que se determine se um spot está em um caixa:
Se a coordenada x deste spot for menor do que o left desta caixa, diga não.
Se a coordenada y deste spot for menor do que o topo desta caixa, diga não.
Se a coordenada x deste spot for maior do que o right desta caixa, diga não.
Se a coordenada y deste spot for maior do que a base desta caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot é para o left of um caixa:
Se a coordenada x deste spot for menor do que o left desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é left ou right of um caixa:
Se o spot é para o left of o caixa, diga sim.
Se o spot é para o right of o caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está sobre um caixa:
Atribua o caixa A uma segunda caixa.
Atribua 2 times o tpp A um número.
Outdent o segunda caixa usando o número.
Se o spot não estiver no segunda caixa, diga não.
Atribua o caixa A um terceiro caixa.
Atribua 3 times o tpp A uma segunda número.
Indent o terceiro caixa usando o segunda número.
Se o spot estiver no terceiro caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está sobre uma elipse:
Atribua o elipse A uma segunda elipse.
Atribua 2 times o tpp A um número.
Outdent a caixa desta segunda elipse usando o número.
Se o spot não estiver na segunda elipse, diga não.
Atribua o elipse A uma terceiro elipse.
Atribua 3 times o tpp A uma segunda número.
Indent a caixa desta terceiro elipse usando o segunda número.
Se o spot estiver na terceiro elipse, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot está sobre um line:
Isole a line.
Atribua 3 times o tpp A um número.
Percorra.
Obtenha uma distance between o spot e o center desta line (chessboard).
Se a distance for menor do que ou igual ao número, diga sim.
Obtenha a distance between a start desta line e o end desta line (chessboard).
Se a distance for menor do que ou igual ao tpp, diga não.
Split a line à line e uma segunda line.
Obtenha a distance between o spot e o center desta line (chessboard).
Obtenha uma segunda distance between o spot e o center desta segunda line (chessboard).
Se o distance for maior do que o segunda distance, atribua o segunda line ao line.
Repita.

Etapas necessárias para que se determine se um spot está sobre um picture:
Se o picture for inexistente, diga não.
Se o spot estiver sobre a caixa desta picture, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está sobre um polygon:
Se o polygon for inexistente, diga não.
Percorra.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, diga não.
Se o next deste vértice for inexistente, diga não.
Atribua o spot deste vértice e o spot deste next deste vértice A um line.
Se o spot estiver sobre o line, diga sim.
Repita.

Etapas necessárias para que se determine se um spot está sobre um caixa arredondada:
Atribua o caixa arredondada A uma segunda caixa arredondada.
Atribua 2 times o tpp A um número.
Outdent o segunda caixa arredondada usando o número.
Se o spot não estiver no segunda caixa arredondada, diga não.
Atribua o caixa arredondada A um terceiro caixa arredondada.
Atribua 3 times o tpp A uma segunda número.
Indent o terceiro caixa arredondada usando o segunda número.
Se o spot estiver no terceiro caixa arredondada, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot é outside um caixa:
Se o spot é inside o caixa, diga não.
Diga sim.

Etapas necessárias para que se determine se um spot é para o right of um caixa:
Se o x deste spot for maior do que o right desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot é touching um caixa:
Se o spot estiver no caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está within um grid of uma segunda spot:
Obtenha um difference between o segunda spot e o spot.
Se a difference está within o grid, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está within alguns twips of uma segunda spot:
Atribua o twips e o twips A um grid.
Se o spot estiver within o grid of o segunda spot, diga sim.
Diga não.

Etapas necessárias para que se determine se um spot está within alguns twips of um caixa:
Isole o caixa.
Outdent o caixa usando o twips.
Se o spot estiver within o caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se o stack has just one coisa sobre it:
Se a contagem deste stack for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um string does end with uma segunda string;
Etapas necessárias para que se determine se um string ends with uma segunda string:
Se o length deste segunda string for maior do que o length deste string, diga não.
Lance um subtexto sobre o string.
Atribua o last deste subtexto menos o length deste segunda string mais 1 ao first deste subtexto.
Se o subtexto for o segunda string, diga sim.
Diga não.

Etapas necessárias para que se determine se um string does start with uma segunda string;
Etapas necessárias para que se determine se um string starts with uma segunda string:
Se o length deste segunda string for maior do que o length deste string, diga não.
Lance um subtexto sobre o string.
Atribua o first deste subtexto mais o length deste segunda string menos 1 ao last deste subtexto.
Se o subtexto é o segunda string, diga sim.
Diga não.

Etapas necessárias para que se determine se um string does start with um pedaço;
Etapas necessárias para que se determine se um string starts with um pedaço:
Se o string estiver em branco, diga não.
Se o target deste first deste string é o pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string does end with um pedaço; \ added por Mike Gonta

Etapas necessárias para que se determine se um string ends with um pedaço:
Se o string estiver em branco, diga não.
Se o target deste last deste string é o pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é uma segunda string (accent-free compare):
Compare o string para o segunda string usando o length deste string e o length deste segunda string e o lowercase accent-free ascii table (equal only).

Etapas necessárias para que se determine se um string é uma segunda string:
Compare o string para o segunda string usando o length deste string e o length deste segunda string e o lowercase ascii table (equal only).

Etapas necessárias para que se determine se um string é uma segunda string ou um terceiro string:
Se o string é o segunda string, diga sim.
Se o string é o terceiro string, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any fração literal;
Etapas necessárias para que se determine se um string é any ratio literal:
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, diga não.
Se o target deste first deste subtexto não for any numeric starter, diga não.
Se o target deste first deste subtexto for any sign, adicione 1 para o first deste subtexto.
Split o subtexto A um numerador subtexto e um denominador subtexto usando o slash pedaço.
Se o numerador subtexto não for any integer literal, diga não.
Se o denominador subtexto não for any integer literal, diga não.
Diga sim.

\Etapas necessárias para que se determine se um string é any integer:
\ seemed para ser um duplicate of a routine below
\Lance um subtexto sobre o string.
\Se o subtexto estiver em branco, diga não.
\Se o target deste first deste subtexto for any sign, adicione 1 para o first deste subtexto.
\Se o subtexto estiver em branco, diga não.
\Percorra.
\Se o target deste first deste subtexto não for any digit, diga não.
\Adicione 1 para o first deste subtexto.
\Se o subtexto estiver em branco, diga sim.
\Repita.

Etapas necessárias para que se determine se um string é any integer;
Etapas necessárias para que se determine se um string é any integer literal:
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, diga não.
Se o target deste first deste subtexto for any sign, adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, diga não.
Percorra.
Se o target deste first deste subtexto não for any digit, diga não.
Adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, diga sim.
Repita.

Etapas necessárias para que se determine se um string é any mixed literal:
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, diga não.
Se o target deste first deste subtexto não for any numeric starter, diga não.
Se o target deste first deste subtexto for any sign, adicione 1 para o first deste subtexto.
Split o subtexto A um integer subtexto e uma fração subtexto usando o hífem.
Se o integer subtexto não for any integer literal, diga não.
Se a fração subtexto não for any fração literal, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any numeric literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string não for any numeric starter, diga não.
Se o string é any integer literal, diga sim.
Se o string é any fração literal, diga sim.
Se o string é any mixed literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any sign:
Se o length deste string não for 1, diga não.
Se o target deste first deste string é any sign, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any palavra:
Se o length deste string for menor do que 2, diga não.
Lance um subtexto sobre o string.
Subtraia 1 from o first deste subtexto.
Percorra.
Adicione 1 para o first deste subtexto.
Se o subtexto estiver em branco, diga sim.
Se o target deste first deste subtexto for any letra, repita.
Se o target deste first deste subtexto for o single-quote pedaço, repita.
Diga não.

Etapas necessárias para que se determine se um string está em branco:
\ assume true
Intel $B801000000. \ mov eax,1
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o string
\ if first for 0, exit
Intel $833B00. \ cmp [ebx],0
Intel $0F8410000000. \ je end
\ if last for menor do que first, exit
Intel $8B5304. \ mov edx,[ebx+4] \ last endereço de memória
Intel $3B13. \ cmp edx,[ebx]
Intel $0F8C05000000. \ jl end
\ Diga não.:
Intel $B800000000. \ mov eax,0
\ END:

Etapas necessárias para que se determine se um string é um pedaço:
Se o length deste string não for 1, diga não.
Se o target deste first deste string é o pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é dos-compatible:
Se o string estiver em branco, diga não.
Se o target deste first deste string é o ponto final, diga não.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, diga sim.
Se o target deste first deste subtexto for o slash pedaço, diga não.
Se o target deste first deste subtexto for a barra invertida, diga não.
Se o target deste first deste subtexto for o sinal de dois pontos, diga não.
Se o target deste first deste subtexto for o asterisco, diga não.
Se o target deste first deste subtexto for o question-mark pedaço, diga não.
Se o target deste first deste subtexto for as aspas duplas, diga não.
Se o target deste first deste subtexto for o left-alligator pedaço, diga não.
Se o target deste first deste subtexto for o right-alligator pedaço, diga não.
Se o target deste first deste subtexto for o barra vertical, diga não.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se determine se um string é maior que uma segunda string;
Etapas necessárias para que se determine se um string é maior do que uma segunda string:
Compare o string para o segunda string usando o length deste string e o length deste segunda string returning um número.
Se o número for maior do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é maior do que]ou igual para uma segunda string;
Etapas necessárias para que se determine se um string é maior que ou igual para uma segunda string;
Etapas necessárias para que se determine se um string é maior ou igual para uma segunda string:
Compare o string para o segunda string usando o length deste string e o length deste segunda string returning um número.
Se o número for maior do que ou igual a 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um string estiver em uma segunda string:
Lance um subtexto sobre o segunda string.
Atribua o first deste subtexto mais o length deste string menos 1 ao last deste subtexto.
Percorra.
Se o last deste subtexto for maior do que o last deste segunda string, diga não.
Se o subtexto é o string, diga sim.
Mova o subtexto usando 1.
Repita.

Etapas necessárias para que se determine se um string estiver em um index:
Se o index for inexistente, diga não.
Se o string estiver em branco, diga não.
Encontre um refer usando o string e o index.
Se o refer for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é menor que uma segunda string;
Etapas necessárias para que se determine se um string é menor do que uma segunda string:
Compare o string para o segunda string usando o length deste string e o length deste segunda string returning um número.
Se o número for menor do que 0, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é menor do que ou igual para uma segunda string;
Etapas necessárias para que se determine se um string é menor que ou igual para uma segunda string;
Etapas necessárias para que se determine se um string é menor ou igual para uma segunda string:
Compare o string para o segunda string usando o length deste string e o length deste segunda string returning um número.
Se o número for menor do que ou igual a 0, diga sim.
Diga não.

 \ needs work por Spanish
Etapas necessárias para que se determine se um string está misspelled:
Se o lexicon for inexistente, diga não.
Se o string não for any palavra, diga não.
Isole o string.
Se o string ends with "'s", remove os last dois pedaços from o string.
Se o string estiver no index deste lexicon, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é wider do que um caixa:
\ assumes font estiver selecionado sobre memory canvas
Obtenha um abca e um abcc usando o string e o memory canvas.
Obtenha um width usando o string e o memory canvas.
Subtraia o abca from o width.
Subtraia o abcc from o width.
Se o width for maior do que a width desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se um subtexto está sobre any contraction:
Atribua o first deste subtexto mais 1 A um endereço de memória do pedaço .
Se o endereço de memória do pedaço for maior do que o last deste subtexto, diga não.
Se o target deste first deste subtexto não for o single-quote pedaço, diga não.
Se o target deste endereço de memória do pedaço não for any letra, diga não.
Diga sim.

Etapas necessárias para que se determine se um terminal está full:
Atribua a altura deste terminal dividido por 1/4 inch A um número.
Se a contagem destes quoras deste terminal for maior do que o número, diga sim.
Diga não.

Etapas necessárias para que se determine se um text pode ser refeito:
Se o text for inexistente, diga não.
Se o last destes redos deste text for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um text pode ser desfeito:
Se o text for inexistente, diga não.
Se o last destes undos deste text for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um text foi modified:
Se o text for inexistente, diga não.
Se o alarme de alteração deste text estiver ativo, diga sim.
Diga não.

Etapas necessárias para que se determine se existe something para backspace em um text:
Se o text for inexistente, diga não.
Se something estiver selecionado no text, diga sim.
Se o caret número da linha deste text não for 1, diga sim.
Se o caret column# deste text não for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se existe something para remove em um text:
Se o text for inexistente, diga não.
Se something estiver selecionado no text, diga sim.
Se o caret número da linha deste text não for a row contagem deste text, diga sim.
Obtenha um row usando o caret número da linha deste text e o text.
Se o caret column# deste text não for o length deste string desta row, diga sim.
Diga não.

Etapas necessárias para que se determine se existe text sobre o windows clipboard:
Call "user32.dll" "IsClipboardFormatAvailable" with 1 [cf_text] returning um número.
Se o número for 0, diga não.
Diga sim.


Etapas necessárias para que se determine se alguns coisas estão vazio:
Se o first destas coisas for inexistente, diga sim.
Diga não.

Etapas necessárias para que se determine se um token é numeric:
Isole o token.
Remove any leading noise from o token.
Se o token estiver em branco, diga não.
Percorra.
Obtenha um pedaço from o token.
Se o pedaço não for any digit, diga não.
Se o token estiver em branco, diga sim.
Repita.

Etapas necessárias para que se determine se o usuário é clicking em alguns choices;
Etapas necessárias para que se determine se o usuário has clicked em alguns choices;
Etapas necessárias para que se determine se o usuário clicked em alguns choices;
Etapas necessárias para que se determine se o usuário clicks em alguns choices;
Etapas necessárias para que se determine se o usuário é clicking sobre alguns choices;
Etapas necessárias para que se determine se o usuário has clicked sobre alguns choices;
Etapas necessárias para que se determine se o usuário clicked sobre alguns choices;
Etapas necessárias para que se determine se o usuário clicks sobre alguns choices:
Percorra.
Se o botão esquerdo deste mouse não for down, diga não.
Encontre um choice usando o spot deste mouse.
Se a choice can't ser found, diga não.
Diga sim.

Etapas necessárias para que se determine se we pode encontre um endereço de memória:
\ deveria ser "can" not "ca", compilador bug
Se o endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se we could encontre um endereço de memória:
Se o endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se we did encontre um endereço de memória:
Se o endereço de memória for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se we're above um caixa:
Se o y deste context for menor do que o topo desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're above um coord:
Se o y deste context for menor do que o coord, diga sim.
Diga não.

Etapas necessárias para que se determine se we're above um horizontal line:
Se o spot deste context é above o horizontal line, diga sim.
Diga não.

Etapas necessárias para que se determine se we're above ou below um caixa:
Se o y deste context for menor do que o topo desta caixa, diga sim.
Se o y deste context for maior do que a base desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're above um spot:
Se o y deste context for menor do que o y deste spot, diga sim.
Diga não.

Etapas necessárias para que se determine se we're below um caixa:
Se o y deste context for maior do que a base desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're below um coord:
Se o y deste context for maior do que o coord, diga sim.
Diga não.

Etapas necessárias para que se determine se we're below um horizontal line:
Se o spot deste context é below o horizontal line, diga sim.
Diga não.

Etapas necessárias para que se determine se we're below um spot:
Se o y deste context for maior do que o y deste spot, diga sim.
Diga não.

Etapas necessárias para que se determine se we're facing north:
\ *** need east, south, west
Normalize o heading deste context.
Se o heading deste context for 0, diga sim.
Diga não.

Etapas necessárias para que se determine se we're left of um caixa:
Se o x deste context for menor do que o left desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're left ou right of um caixa:
Se o x deste context for menor do que o left desta caixa, diga sim.
Se o x deste context for maior do que o right desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're outside um caixa:
Se o spot deste context é outside o caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're right of um caixa:
Se o x deste context for maior do que o right desta caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're still em um caixa;
Etapas necessárias para que se determine se we're em um caixa:
Se o spot deste context estiver no caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se we're within alguns twips of um caixa:
Se o spot deste context está within o twips of o caixa, diga sim.
Diga não.

Etapas necessárias para que se determine se you feel like it:
Escolha aleatoriamente um número between 1 e 100.
Se o número for menor do que 51, diga sim.
Diga não.

Etapas necessárias para que se decrypt um trecho usando um passphrase string:
\ sets i/o erro if failure
Limpe o i/o erro.
Crie um crypt session usando o passphrase.
Se o crypt session for inexistente, cancele.
Convert o trecho como um texto da cifra binária para um texto hexadecimal.
Atribua o length deste texto hexadecimal A um length.
Call "advapi32.dll" "CryptDecrypt" with a hcryptkey desta crypt session e 0 e 1 e 0 e o first deste texto hexadecimal And o whereabouts deste length returning um result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de tentar decifrar os dados." ao i/o erro; destroy o crypt session; exit.
Destroy o crypt session.
Atribua o texto hexadecimal ao trecho.

O default font é uma font.

O default smtp server é "localhost".

Um degree é um número [cujos valores variam entre 0 até 359].

O símbolo de grau é um pedaço igual a 176.

O antigo símbolo de delete [que agora está descontinuado] é um pedaço igual a 127.

O tecla Delete é uma tecla igual a 46.
O tecla Del é uma tecla igual a 46.

Um depth é alguns twips.

Um description é um string.

Etapas necessárias para que se deselect um text:
Se o text for inexistente, cancele.
Atribua o caret deste text ao anchor deste text.



Etapas necessárias para que se destroy um crypt session:
Se o crypt session for inexistente, cancele.
Call "advapi32.dll" "CryptDestroyKey" with a hcryptkey desta crypt session.
Call "advapi32.dll" "CryptDestroyHash" with o hcrypthash desta crypt session.
Call "advapi32.dll" "CryptReleaseContext" with o crypt session's hcryptprov e 0.
Deallocate o crypt session.

Etapas necessárias para que se destroy um gpimage:
Se o gpimage for inexistente, cancele.
Call "gdiplus.dll" "GdipDisposeImage" with o gpimage.
Esvazie o gpimage.

Etapas necessárias para que se destroy um gpimageattributes:
Se o gpimageattributes for inexistente, cancele.
Call "gdiplus.dll" "GdipDisposeImageAttributes" with o gpimageattributes.
Esvazie o gpimageattributes.

Etapas necessárias para que se destroy o hbrush of um canvas:
Call "gdi32.dll" "SelectObject" with o canvas e o null hbrush returning um hbrush.
Call "gdi32.dll" "DeleteObject" with o hbrush.

Etapas necessárias para que se destroy o hfont of um canvas:
Call "gdi32.dll" "SelectObject" with o canvas e o null hfont returning um hfont.
Call "gdi32.dll" "DeleteObject" with o hfont.

Etapas necessárias para que se destroy o hpen of um canvas:
Call "gdi32.dll" "SelectObject" with o canvas e o null hpen returning um hpen.
Call "gdi32.dll" "DeleteObject" with o hpen.

Etapas necessárias para que se destroy um hrgn:
Call "gdi32.dll" "DeleteObject" with o hrgn.

Etapas necessárias para que se destroy um index:
Se o index for inexistente, cancele.
Percorra.
Obtenha um bucket usando o index.
Se o bucket for inexistente, pare.
Destroy os refers deste bucket.
Repita.
Unassign o first bucket deste index.
Deallocate o index.

Etapas necessárias para que se destroy um endereço completo no sistema de arquivos:
Defina o endereço completo para read-write mode.
Se o endereço completo é endereço da pasta-format, destroy o endereço completo no sistema de arquivos (pasta)[endereço].
Se o endereço completo é file-format, destroy o endereço completo no sistema de arquivos (file).

Etapas necessárias para que se destroy um endereço completo no sistema de arquivos (pasta)[endereço]:
Percorra.
Obtenha um item from o endereço completo.
Se o item não for found, pare.
Atribua o endereço completo A uma segunda endereço completo.
Posponha o designador deste item para o segunda endereço completo.
Destroy o segunda endereço completo no sistema de arquivos.
Se o i/o erro não estiver em branco, cancele.
Repita.
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "RemoveDirectoryA" with o first deste endereço completo returning um número.
Limpe o i/o erro.
Se o número não for 0, cancele.
Atribua "Erro. Não foi possível apagar a pasta: " then o endereço completo then "." ao i/o erro.

Etapas necessárias para que se destroy uma endereço completo no sistema de arquivos (file):
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "DeleteFileA" with o first deste endereço completo returning um número.
Limpe o i/o erro.
Se o número não for 0, cancele.
Atribua "Erro. Não foi possível apagar o arquivo: " then o endereço completo then "." ao i/o erro.

Etapas necessárias para que se destroy uma picture:
Se o picture for inexistente, cancele.
Destroy o gpbitmap desta picture.
Deallocate o picture.

Etapas necessárias para que se destroy um socket:
Call "ws2_32.dll" "closesocket" with o socket.

Etapas necessárias para que se destroy um vértice usando um polygon:
Se o vértice for inexistente, cancele.
Se o polygon for inexistente, cancele.
Isole o vértice.
Remove o vértice from os vértices deste polygon.
Destroy o vértice.

Etapas necessárias para que se destroy um winhttp request:
Se o winhttp request for inexistente, cancele.
Call "winhttp.dll" "WinHttpCloseHandle" with a request deste winhttp request.
Call "winhttp.dll" "WinHttpCloseHandle" with a connection deste winhttp request.
Call "winhttp.dll" "WinHttpCloseHandle" with a session desta request deste winhttp.
Deallocate o winhttp request.

O DC4 é um pedaço igual a 20.

O DC1 é um pedaço igual a 17.

O DC3 é um pedaço igual a 19.

O DC2 é um pedaço igual a 18.

Um devmode é um conjunto with
32 pedaços called dmdevicename,
Um wyrd called dmspecversion,
Um wyrd called dmdriverversion,
Um wyrd called dmsize,
Um wyrd called dmdriverextra,
Um número called dmfields,
Um wyrd called dmorientation,
Um wyrd called dmpapersize,
Um wyrd called paperlength,
Um wyrd called paperwidth,
Um wyrd called dmscale,
Um wyrd called dmcopies,
Um wyrd called dmdefaultsource,
Um wyrd called dmprintquality,
Um wyrd called dmcolor,
Um wyrd called dmduplex,
Um wyrd called ydmresolution,
Um wyrd called dmttoption,
Um wyrd called dmcollate,
32 pedaços called dmformname,
Um wyrd called dmlogpixels,
Um número called dmbitsperpel,
Um número called dmpelswidth,
Um número called dmpelsheight,
Um número called dmdisplayflags,
Um número called dmdisplayfrequency,
Um número called dmicmmethod,
Um número called dmicmintent,
Um número called dmmediatype,
Um número called dmdithertype,
Um número called dmreserved1,
Um número called dmreserved2.

O trema é um pedaço igual a 168.

Um difference é um pair.

Um file é um handle.

Um nome do arquivo é um string. \ after o last slash para end of endereço completo = file.ext
Um nome do arquivo s/ extensão é um string. \ after o last slash para last dot ou end of endereço completo = file
Um extensão é um string. \ last dot para end of endereço completo = .ext
Um endereço da pasta é um endereço completo. \ start of endereço completo para last slash inclusive = c:\folder1\folder2\
Um endereço completo é um string. \ complete name = c:\folder1\folder2\file.ext
Um nome do diretório é um string. \ rightmost endereço da pasta with slash = folder2\
Um designador é um string. \ rightmost endereço da pasta with slash = folder2\ ou after o last slash para end of endereço completo = file.ext
Um nome da pasta é um string. \ rightmost endereço da pasta sem slash = folder2
Um unidade de disco é um string. \ start of endereço completo para first slash = c:\ ou start of endereço completo para quarto slash = \\computer\share\
Um unidade de rede é um string. \ é basicamente uma cópia da variável anterior.
Um categoria da unidade de disco é um string.

Um nome da unidade de disco é um string.

Um distance é alguns twips.

Etapas necessárias para que se divida uma fração por uma segunda fração:
Isole a segunda fração.
Flip a segunda fração.
Multiplique a fração pela segunda fração.

Etapas necessárias para que se divida uma fração por um número:
Multiplique o denominador desta fração pelo número.
Reduce a fração.

Etapas necessárias para que se divida um número por um fração:
Isole a fração.
Flip a fração.
Multiplique o número pela fração.

Etapas necessárias para que se divida um pair por uma segunda pair:
Divida o número x deste pair pelo número x deste segunda pair.
Divida o número y deste pair pelo número y deste segunda pair.

Etapas necessárias para que se divida um pair por um número:
Divida o número x deste pair pelo número.
Divida o número y deste pair pelo número.

Etapas necessárias para que se divida um pair por um número e uma segunda número:
Divida o número x deste pair pelo número.
Divida o número y deste pair pelo segunda número.

Etapas necessárias para que se divida um endereço de memória por um número;
Etapas necessárias para que se divida um número por uma segunda número:
Se o segunda número for 0, atribua o maior número ao número; exit.
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda número
Intel $8B00. \ mov eax,[eax]
Intel $99. \ cdq
Intel $F73B. \ div [ebx] \ means div eax,[ebx] but é weird form
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se divida um endereço de memória por um número giving um quotient e um resto;
Etapas necessárias para que se divida um número por uma segunda número giving um quotient e um resto:
Se o segunda número for 0, atribua o maior número ao quotient; atribua 0 ao resto; exit.
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda número
Intel $8B00. \ mov eax,[eax]
Intel $99. \ cdq
Intel $F73B. \ idiv [ebx] \ means idiv eax,[ebx] but é weird form
Intel $8B9D10000000. \ mov ebx,[ebp+16] \ o quotient
Intel $8903. \ mov [ebx],eax
Intel $8B9D14000000. \ mov ebx,[ebp+20] \ o resto
Intel $8913. \ mov [ebx],edx

O sinal de divisão é um pedaço igual a 247.
O símbolo de divisão é um pedaço igual a 247.

Um docinfo é um conjunto with
Um número called cbsize,
Um endereço de memória called lpszdocname,
Um endereço de memória called lpszoutput,
Um endereço de memória called lpszdatadtype,
Um número called fwtype.

O cifrão é um pedaço igual a 36.

Um dot é um elipse.

Etapas necessárias para que se double um número:
Adicione o número para o número.

O diesis é um pedaço igual a 135.
O obelisco duplo é um pedaço igual a 135.

O aspas duplas são um pedaço igual a 34.

O seta pra baixo é uma tecla igual a 40.

Etapas necessárias para que se draw e fill um caixa with um cor:
Draw o caixa with a cor e a cor.

Etapas necessárias para que se draw any visible rows of um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver visible, repita.
Draw a row of o text.
Repita.

Etapas necessárias para que se draw any visible rows of um text (editing):
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não for visible, repita.
Draw a row of o text (editing).
Repita.

Etapas necessárias para que se draw um caixa:
Draw o caixa with a cor preta e o clear cor.

Etapas necessárias para que se draw um caixa (focus style):
Isole o caixa.
Adicione o tpp para o right-base desta caixa.
Call "gdi32.dll" "LPtoDP" with o quadro atual e o whereabouts desta caixa e 2.
Convert o cor branca para um código da cor.
Call "gdi32.dll" "SetBkColor" with o quadro atual e o código da cor.
Convert a cor preta para uma segunda código da cor.
Call "gdi32.dll" "SetTextColor" with o quadro atual e o segunda código da cor.
Call "gdi32.dll" "SetMapMode" with o quadro atual e 1 [mm_text].
Call "user32.dll" "DrawFocusRect" with o quadro atual e o whereabouts desta caixa.
Normalize o quadro atual.

Etapas necessárias para que se draw uma caixa em uma cor;
Etapas necessárias para que se draw uma caixa with uma cor:
Draw o caixa with a cor e o clear cor.

Etapas necessárias para que se draw um caixa with uma border cor e uma fill cor:
Se o página alarme deste pdf state estiver ativo, draw a caixa with o border e o fill (pdf style); exit.
Isole a caixa.
Crie o hpen of o quadro atual usando a border.
Crie o hbrush of o quadro atual usando o fill.
Se a border estiver clear, adicione o tpp para o left-top desta caixa.
Call "gdi32.dll" "Rectangle" with o quadro atual e o left desta caixa e o topo desta caixa e o right desta caixa e a base desta caixa.
Destroy o hbrush of o quadro atual.
Destroy o hpen of o quadro atual.

Etapas necessárias para que se draw um caixa with um border cor e um fill cor (pdf style):
Se o border e o fill são clear, cancele.
Output setcolor usando o border e o fill.
Output o left-base desta caixa sem advancing.
Output o x-extent desta caixa sem advancing.
Output o y-extent desta caixa sem advancing.
Output "re".
Output stroke e fill usando o border e o fill.

Etapas necessárias para que se draw o caret em um text:
Se o text for inexistente, cancele.
Obtenha um caixa pelo caret no text.
Se o caixa não for touching a caixa deste text, cancele.
Atribua o left-top desta caixa e o right-base desta caixa A um line.
Draw o line with a cor preta.

Etapas necessárias para que se draw um circle about alguns twips wide;
Etapas necessárias para que se draw um circle usando um width;
Etapas necessárias para que se draw um circle alguns twips em width;
Etapas necessárias para que se draw um circle alguns twips wide:
Atribua o twips times o número pi dividido por 48 A um segment length.
Adicione 1 para o segment length.
Percorra.
Stroke o segment length.
Vire right 1/48 of o way.
Adicione 1 para um contagem. Se o contagem for 48, pare.
Repita.

Etapas necessárias para que se draw um circle alguns twips wide (backwards);
Etapas necessárias para que se draw um circle alguns twips wide (counterclockwise):
Atribua o twips times o número pi dividido por 48 A um segment length.
Adicione 1 para o segment length.
Percorra.
Stroke o segment length.
Vire left 1/48 of o way.
Adicione 1 para um contagem. Se o contagem for 48, pare.
Repita.

Etapas necessárias para que se draw um console:
Se o console for inexistente, cancele.
Save o quadro atual.
Mask only outside a caixa deste console .
Draw a caixa deste console with o border deste console e o fill deste console.
Draw o text deste console.
Restore o quadro atual.

Etapas necessárias para que se draw um dot alguns twips wide sobre o current spot with um cor:
Make o dot o twips wide.
Centralize o dot sobre o spot deste context.
Draw o dot with a cor.

Etapas necessárias para que se draw um dot alguns twips wide sobre um spot with um cor:
Make o dot o twips wide.
Centralize o dot sobre o spot.
Draw o dot with a cor.

Etapas necessárias para que se draw um elipse:
Draw o elipse with a cor preta e o clear cor.

Etapas necessárias para que se draw um elipse sobre um spot with um cor:
Centralize o elipse sobre o spot.
Draw o elipse with a cor e o clear cor.

Etapas necessárias para que se draw um elipse with uma border cor e uma fill cor:
Se o página alarme deste pdf state estiver ativo, draw a elipse with a border e o fill (pdf style); exit.
Isole a elipse.
Crie o hpen of o quadro atual usando a border.
Crie o hbrush of o quadro atual usando o fill.
Se a border estiver clear, adicione o tpp para o left-top desta elipse.
Call "gdi32.dll" "Ellipse" with o quadro atual e o left desta elipse e o topo desta elipse e o right desta elipse e a base desta elipse.
Destroy o hbrush of o quadro atual.
Destroy o hpen of o quadro atual.

Etapas necessárias para que se draw um elipse with um border cor e um fill cor (pdf style):
Se o border e o fill são clear, cancele.
Output setcolor usando o border e o fill.
Atribua o left desta elipse e o topo desta elipse A um spot.
Adicione o y-extent desta elipse dividido por 2 para a coordenada y deste spot.
Output moveto usando o spot.
Output o arc of o elipse usando "left-top".
Output o arc of o elipse usando "right-top".
Output o arc of o elipse usando "right-base".
Output o arc of o elipse usando "left-base".
Output stroke e fill usando o border e o fill.

Etapas necessárias para que se draw um elipse with um cor:
Draw o elipse with a cor e a cor.

Etapas necessárias para que se draw um fancy arrow alguns twips long with um cor;
Etapas necessárias para que se stroke um fancy arrow alguns twips long with um cor:
Atribua a cor à cor deste context.
Save o context.
Stroke o twips.
Vire around.
Mova o twips dividido por 8.
Save o context.
Vire left 1/8 of o way.
Draw um spiral starting with o twips dividido por 4.
Restore o context.
Vire right 1/8 of o way.
Draw uma segunda spiral backwards starting with o twips dividido por 4.
Restore o context.

Etapas necessárias para que se draw um figura with um cor:
Draw o figura with a cor e o clear cor.

Etapas necessárias para que se draw um figura with alguns sides about alguns twips wide:
Atribua 1 e o side contagem A um fração.
Atribua o twips times o número pi dividido pelo sides A um segment length.
Se o sides são 4, atribua o twips times 7/8 ao segment length. \ what é this? ***
Percorra.
Stroke o segment length.
Vire a fração.
Adicione 1 para um contagem. if o contagem é o sides, pare.
Repita.

Etapas necessárias para que se draw um figura with alguns sides alguns twips long;
Etapas necessárias para que se draw um figura with alguns sides e alguns twips:
Atribua 1 e o sides A um fração.
Percorra.
Stroke o twips.
Vire a fração.
Adicione 1 para um contagem. Se o contagem é o sides, pare.
Repita.

Etapas necessárias para que se draw um figura with alguns sides alguns twips long using um cor;
Etapas necessárias para que se draw um figura with alguns sides e alguns twips using um cor:
Atribua a cor à cor deste context.
Draw o figura with o sides e o twips.

Etapas necessárias para que se draw um gpbitmap at um spot (pdf style):
Se o gpbitmap for inexistente, cancele.
\ adicione xobject
Adicione um xobject pdf object usando "image object".
Atribua "I" then o número deste xobject A um name.
\ adicione para image resources em current página
Atribua "/" then o name then " " then o número deste xobject then " 0 R" A um string.
Crie um new conjunto de texto usando o string.
Posponha o new conjunto de texto para os image strings desta current página deste pdf state.
\ finish setting up xobject
Posponha o número deste xobject then " 0 obj" para o xobject.
Posponha "<<" para o xobject.
Posponha "/Type /XObject" para o xobject.
Posponha "/Subtype /Image" para o xobject.
Posponha "/ColorSpace /DeviceRGB" para o xobject.
Posponha "/Width " then o width deste gpbitmap para o xobject.
Posponha "/Height " then a altura deste gpbitmap para o xobject.
Posponha "/BitsPerComponent 8" para o xobject.
Convert o gpbitmap para um trecho (pdf style).
Convert o trecho para um texto da cifra binária.
Posponha "/Filter /ASCIIHexDecode" para o xobject.
Posponha "/Length " then o length deste texto da cifra binária para o xobject.
Posponha ">>" para o xobject.
Posponha "stream" para o xobject.
Posponha o texto da cifra binária para o xobject.
Posponha "endstream" para o xobject.
Posponha "endobj" para o xobject.
\ draw o image no current contents
Atribua o width deste gpbitmap times o tpp A um width.
Atribua a altura deste gpbitmap times o tpp A um altura.
Atribua a coordenada x deste spot A um número x.
Atribua a current altura deste pdf state menos a coordenada y deste spot menos o altura A um número y.
Output "q".
Output o width then " 0 0 " then o altura then " " then o número x then " " then o número y then " cm".
Output "/" then o name then " Do".
Output "Q".

Etapas necessárias para que se draw um half circle about alguns twips wide;
Etapas necessárias para que se draw um half circle usando um size:
Atribua o size times o número pi dividido por 48 A um segment length.
Adicione 1 para o segment length.
Percorra.
Stroke o segment length.
Vire right 1/48 of o way.
Adicione 1 para um contagem.
Se o contagem for 24, cancele.
Repita.

Etapas necessárias para que se draw um half circle usando um size (backwards);
Etapas necessárias para que se draw um half circle usando um size (counterclockwise):
Atribua o size times o número pi dividido por 48 A um segment length.
Adicione 1 para o segment length.
Percorra.
Stroke o segment length.
Vire left 1/48 of o way.
Adicione 1 para um contagem.
Se o contagem for 24, cancele.
Repita.

Etapas necessárias para que se draw um hexagon usando um side length:
Stroke o side length.
Vire right 1/6 of o way.
Adicione 1 para um contagem. Se o contagem for 6, pare.
Repita.

Etapas necessárias para que se draw um line:
Draw o line with a cor deste context.

Etapas necessárias para que se draw um line around alguns twips long; \ "around" é significant here
Etapas necessárias para que se draw um line about alguns twips long; \ "about" é significant here
Etapas necessárias para que se stroke um line around alguns twips long; \ "around" é significant here
Etapas necessárias para que se stroke um line about alguns twips long:
\ "about" é significant here
Atribua o twips dividido por 2 A alguns segunda twips.
Escolha aleatoriamente alguns terceiro twips between o twips menos o segunda twips e o twips mais o segunda twips.
Stroke o line o terceiro twips long.

Etapas necessárias para que se draw um line como high como um caixa with um cor;
Etapas necessárias para que se draw um line como tall como um caixa with um cor:
Atribua a cor à cor deste context.
Stroke a altura desta caixa.

Etapas necessárias para que se draw um line como wide como um caixa with um cor:
Atribua a cor à cor deste context.
Stroke a width desta caixa.

Etapas necessárias para que se draw um line between alguns twips e alguns segunda twips long;
Etapas necessárias para que se draw um line between alguns twips para alguns segunda twips long;
Etapas necessárias para que se draw um line alguns twips para alguns segunda twips long;
Etapas necessárias para que se stroke um line alguns twips para alguns segunda twips long:
Escolha aleatoriamente alguns terceiro twips between o twips e o segunda twips.
Stroke o line o terceiro twips long.

Etapas necessárias para que se draw um line alguns twips long;
Etapas necessárias para que se stroke um line alguns twips long:
\Aguarde pelo delay. ***
Atribua o spot deste context ao start desta line.
Atribua o spot deste context ao end desta line.
Obtenha um rise e um run usando o heading deste context.
Adicione o run times o twips dividido por 10000 para a coordenada x deste end desta line.
Adicione o rise times o twips dividido por 10000 para a coordenada y deste end desta line.
Atribua o end desta line ao spot deste context.
Draw o line with a cor deste context.
\Se o delay é positive, atualize o tela.

Etapas necessárias para que se draw um line using alguns twips como o length;
Etapas necessárias para que se draw um line using alguns twips pelo length:
Stroke o twips.

Etapas necessárias para que se draw um line with um cor:
Se o página alarme deste pdf state estiver ativo, draw o line with a cor (pdf style); exit.
Crie o hpen of o quadro atual usando a cor.
Call "gdi32.dll" "MoveToEx" with o quadro atual e o coordenada x desta start desta line e o coordenada y desta start desta line e nil.
Call "gdi32.dll" "LineTo" with o quadro atual e a coordenada x deste end desta line e a coordenada y deste end desta line.
Convert a cor para um código da cor.
Call "gdi32.dll" "SetPixelV" with o quadro atual e a coordenada x deste end desta line e a coordenada y deste end desta line e o código da cor.
Destroy o hpen of o quadro atual.

Etapas necessárias para que se draw um line with uma cor (pdf style):
Se a cor estiver clear, cancele.
Output setcolor usando a cor e o clear cor.
Output moveto usando o start desta line.
Output lineto usando o end desta line.
Output stroke e fill usando a cor e o clear cor.

Etapas necessárias para que se draw um line with uma cor around alguns twips long; \ "around" é significant here
Etapas necessárias para que se draw um line with uma cor about alguns twips long; \ "about" é significant here
Etapas necessárias para que se stroke um line with uma cor around alguns twips long; \ "around" é significant here
Etapas necessárias para que se stroke um line with uma cor about alguns twips long:
\ "about" é significant here
Atribua o twips dividido por 2 A alguns segunda twips.
Escolha aleatoriamente alguns terceiro twips between o twips menos o segunda twips e o twips mais o segunda twips.
Stroke o line with a cor o terceiro twips long.

Etapas necessárias para que se draw um line with uma cor alguns twips long;
Etapas necessárias para que se stroke um line with uma cor alguns twips long:
Atribua a cor à cor deste context.
Atribua o spot deste context ao start desta line.
Stroke o twips.
Atribua o spot deste context ao end desta line.

Etapas necessárias para que se draw um line with uma cor alguns twips para alguns segunda twips long;
Etapas necessárias para que se stroke um line with uma cor alguns twips para alguns segunda twips long:
Escolha aleatoriamente alguns terceiro twips between o twips e o segunda twips.
Stroke o line with a cor o terceiro twips long.

Etapas necessárias para que se draw um número em um caixa with um cor:
Atribua o número A um string.
Draw o string no caixa with a cor e "center".

Etapas necessárias para que se draw only within um caixa;
Etapas necessárias para que se draw only inside um caixa;
Etapas necessárias para que se draw only em um caixa;
Etapas necessárias para que se draw only within um caixa from now on;
Etapas necessárias para que se draw only inside um caixa from now on;
Etapas necessárias para que se draw only em um caixa from now on;
Etapas necessárias para que se only draw within um caixa from now on;
Etapas necessárias para que se only draw inside um caixa from now on;
Etapas necessárias para que se only draw em um caixa from now on;
Etapas necessárias para que se only draw within um caixa;
Etapas necessárias para que se only draw inside um caixa;
Etapas necessárias para que se only draw em um caixa;
Etapas necessárias para que se draw within um caixa only;
Etapas necessárias para que se draw inside um caixa only;
Etapas necessárias para que se draw em um caixa only;
Etapas necessárias para que se atribua masking tape all around um caixa;
Etapas necessárias para que se atribua masking tape around um caixa:
\ note that this masks a border da caixa as well
Isole o caixa.
Indent o caixa 1 pixel.
Mask outside o caixa.
Atribua o original caixa à caixa deste context. \ *** original caixa ? ou indented one?

Etapas necessárias para que se draw um picture:
Se o página alarme deste pdf state estiver ativo, draw o picture (pdf style); exit.
Se o picture for inexistente, cancele.
Save o quadro atual.
Mask outside a caixa desta picture.
Call "gdiplus.dll" "GdipCreateFromHDC" with o quadro atual e um gpgraphic's whereabouts.
Call "gdiplus.dll" "GdipSetPageUnit" with o gpgraphic e 2 [pixels].
Draw o picture sobre o gpgraphic at o left desta uncropped caixa desta picture e o topo desta uncropped caixa desta picture.
Call "gdiplus.dll" "GdipDeleteGraphics" with o gpgraphic.
Restore o quadro atual.

Etapas necessárias para que se draw um picture (pdf style):
Se o picture for inexistente, cancele.
Atribua o left desta caixa desta picture menos o left desta uncropped caixa desta picture dividido pelo tpp A um número x.
Atribua o topo desta caixa desta picture menos o topo desta uncropped caixa desta picture dividido pelo tpp A um número y.
Atribua a width desta caixa desta picture dividido pelo tpp A um width.
Atribua a altura desta caixa desta picture dividido pelo tpp A um altura.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" with o width e o altura e 0 e 137224 [pixelformat24bpprgb] e 0 e um gpbitmap's whereabouts.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" with o gpbitmap e um gpgraphic's whereabouts.
Se o grayscale alarme desta picture estiver ativo, crie um gpimageattributes (grayscale).
Call "gdiplus.dll" "GdipDrawImageRectRectI" with o gpgraphic e o gpbitmap desta picture and 0 e 0 e o width e o altura and o número x e o número y e o width e o altura and 2 [unitpixel] e o gpimageattributes e nil e 0.
Se o gpimageattributes não for inexistente, destroy o gpimageattributes.
Call "gdiplus.dll" "GdipDeleteGraphics" with o gpgraphic.
Draw o gpbitmap at o left-top desta caixa desta picture (pdf style).
Call "gdiplus.dll" "GdipDisposeImage" with o gpbitmap.

Etapas necessárias para que se draw um picture sobre um gpgraphic at um coordenada x e um coordenada y:
Se o picture for inexistente, cancele.
Se o grayscale alarme desta picture estiver ativo, crie um gpimageattributes (grayscale).
Call "gdiplus.dll" "GdipDrawImageRectRectI" with o gpgraphic e o gpbitmap desta picture And o coordenada x e o coordenada y e a width desta uncropped caixa desta picture e a altura desta uncropped caixa desta picture And 0 e 0 e a width deste gpbitmap desta picture e a altura deste gpbitmap desta picture And 2 [unitpixel] e o gpimageattributes e nil e 0.
Se o gpimageattributes não for inexistente, destroy o gpimageattributes.

Etapas necessárias para que se draw um polygon:
Draw o polygon with a cor preta e o clear cor.

Etapas necessárias para que se draw um polygon with um border cor e um fill cor:
Se o página alarme deste pdf state estiver ativo, draw o polygon with o border e o fill (pdf style); exit.
Se o polygon for inexistente, cancele.
Draw o polygon with o fill (fill only).
Draw o polygon with o border (border only).

Etapas necessárias para que se draw um polygon with um border cor e um fill cor (pdf style):
Se o polygon for inexistente, cancele.
Se o border e o fill são clear, cancele.
Output setcolor usando o border e o fill.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, cancele.
Output moveto usando o spot deste vértice.
Percorra.
Obtenha o vértice from os vértices deste polygon.
Se o vértice for inexistente, pare.
Output lineto usando o spot deste vértice.
Repita.
Output stroke e fill usando o border e o fill.

Etapas necessárias para que se draw um polygon with um cor:
Draw o polygon with a cor e a cor.

Etapas necessárias para que se draw um polygon with uma cor (border only):
Se o polygon for inexistente, cancele.
Se a cor estiver clear, cancele.
Crie o hpen of o quadro atual usando a cor.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, cancele.
Call "gdi32.dll" "MoveToEx" with o quadro atual e a coordenada x deste vértice e a coordenada y deste vértice e nil.
Percorra.
Obtenha o vértice from os vértices deste polygon.
Se o vértice for inexistente, pare.
Call "gdi32.dll" "LineTo" with o quadro atual e a coordenada x deste vértice e a coordenada y deste vértice.
Repita.
Destroy o hpen of o quadro atual.
Se o spot deste first destes vértices deste polygon for o spot deste last destes vértices deste polygon, cancele.
Convert a cor para um código da cor.
Call "gdi32.dll" "SetPixelV" with o quadro atual e a coordenada x deste last destes vértices deste polygon e a coordenada y deste last destes vértices deste polygon e o código da cor.

Etapas necessárias para que se draw um polygon with uma cor (fill only):
Se o polygon for inexistente, cancele.
Se a cor estiver clear, cancele.
Crie o hpen of o quadro atual usando o clear cor.
Crie o hbrush of o quadro atual usando a cor.
Call "gdi32.dll" "SetPolyFillMode" with o quadro atual e 2 [winding].
Crie um vértice array usando os vértices deste polygon.
Call "gdi32.dll" "Polygon" with o quadro atual e o spot endereço de memória deste vértice array e a contagem deste vértice array.
Destroy o vértice array.
Destroy o hbrush of o quadro atual.
Destroy o hpen of o quadro atual.

Etapas necessárias para que se draw um quarter circle about alguns twips wide;
Etapas necessárias para que se draw um quarter circle usando um size:
Atribua o size times o número pi dividido por 48 A um segment length.
Adicione 1 para o segment length.
Percorra.
Stroke o segment length.
Vire right 1/48 of o way.
Adicione 1 para um contagem.
Se o contagem for 12, cancele.
Repita.

Etapas necessárias para que se draw um quarter circle between alguns twips e alguns segunda twips wide:
Escolha aleatoriamente alguns terceiro twips between o twips e o segunda twips.
Draw um quarter circle usando o terceiro twips.

Etapas necessárias para que se draw um quarter circle usando um size (counterclockwise):
Atribua o size times o número pi dividido por 48 A um segment length.
Adicione 1 para o segment length.
Percorra.
Stroke o segment length.
Vire left 1/48 of o way.
Adicione 1 para um contagem.
Se o contagem for 12, cancele.
Repita.

Etapas necessárias para que se draw um retângulo alguns twips por alguns segunda twips;
Etapas necessárias para que se draw um retângulo alguns twips wide por alguns segunda twips high:
Stroke o segunda twips.
Vire right.
Stroke o twips.
Vire right.
Stroke o segunda twips.
Vire right.
Stroke o twips.
Vire right.

Etapas necessárias para que se draw um caixa arredondada:
Draw o caixa arredondada with a cor preta e o clear cor.

Etapas necessárias para que se draw um caixa arredondada with um border cor e um fill cor:
Se o página alarme deste pdf state estiver ativo, draw o caixa arredondada with o border e o fill (pdf style); exit.
Isole o caixa arredondada.
Crie o hpen of o quadro atual usando o border.
Crie o hbrush of o quadro atual usando o fill.
Se o border estiver clear, adicione o tpp para o left-top desta caixa arredondada.
Atribua o radius desta caixa arredondada times 2 A um diameter número.
Call "gdi32.dll" "RoundRect" with o quadro atual e o left desta caixa arredondada e o topo desta caixa arredondada e o right desta caixa arredondada e a base desta caixa arredondada 
And o diameter e o diameter.
Destroy o hbrush of o quadro atual.
Destroy o hpen of o quadro atual.

Etapas necessárias para que se draw um caixa arredondada with um border cor e um fill cor (pdf style):
Se o border e o fill são clear, cancele.
Se o radius desta caixa arredondada for 0, draw o caixa arredondada como um caixa with o border e o fill (pdf style); exit.
Atribua o radius desta caixa arredondada A um radius.
Atribua o radius times 2 A um offset.
Atribua o caixa arredondada A uma caixa.
Output setcolor usando o border e o fill.
\ initial moveto
Output moveto usando o left desta caixa e o topo desta caixa mais o radius.
\ left-top
Atribua o left desta caixa e o topo desta caixa e o left desta caixa mais o offset e o topo desta caixa mais o offset A um elipse.
Output o arc of o elipse usando "left-top".
Output lineto usando o right desta caixa menos o radius e o topo desta caixa.
\ right-top
Atribua o right desta caixa menos o offset e o topo desta caixa e o right desta caixa e o topo desta caixa mais o offset ao elipse.
Output o arc of o elipse usando "right-top".
Output lineto usando o right desta caixa e a base desta caixa menos o radius.
\ right-base
Atribua o right desta caixa menos o offset e a base desta caixa menos o offset e o right desta caixa e a base desta caixa ao elipse.
Output o arc of o elipse usando "right-base".
Output lineto usando o left desta caixa mais o radius e a base desta caixa.
\ left-base
Atribua o left desta caixa e a base desta caixa menos o offset e o left desta caixa mais o offset e a base desta caixa ao elipse.
Output o arc of o elipse usando "left-base".
\ finish up
Output "h".
Output stroke e fill usando o border e o fill.

Etapas necessárias para que se draw um caixa arredondada with um cor:
Draw o caixa arredondada with a cor e a cor.

Etapas necessárias para que se draw um row of um text:
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Obtenha um caixa usando a row e o text.
Draw o working string desta row no caixa with o pincel deste text e a font deste text e o alinhamento deste text.

Etapas necessárias para que se draw um row of um text (editing):
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Draw o selection caixa pela row of o text.
Obtenha um caixa usando a row e o text.
Draw o working string desta row no caixa with o pincel deste text e a font deste text e o alinhamento deste text.

Etapas necessárias para que se draw o selection caixa por um row of um text:
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, cancele.
Obtenha um selection caixa usando a row e o text.
Draw o selection caixa with o hilite cor e o hilite cor.

Etapas necessárias para que se draw um spiral backward usando alguns twips;
Etapas necessárias para que se draw um spiral backward starting with alguns twips;
Etapas necessárias para que se draw um spiral usando um size (backwards):
Isole o size.
Percorra.
Draw um half circle usando o size (backwards).
Divida o size por 2.
Adicione 1 para um contagem.
Se o contagem for 5, pare.
Repita.

Etapas necessárias para que se draw um spiral starting with alguns twips;
Etapas necessárias para que se draw um spiral usando um size:
Isole o size.
Percorra.
Draw um half circle usando o size.
Divida o size por 2.
Adicione 1 para um contagem. Se o contagem for 5, pare.
Repita.

Etapas necessárias para que se draw um spot:
Draw o spot with a cor preta.

Etapas necessárias para que se draw um spot with um cor:
Convert a cor para um código da cor.
Call "gdi32.dll" "SetPixelV" with o quadro atual e a coordenada x deste spot e a coordenada y deste spot e o código da cor.

Etapas necessárias para que se draw um star usando um point contagem e um size:
Atribua 1 e o point contagem A um fração.
Percorra.
Vire right 1/48 of o way.
Stroke o size.
Vire around.
Vire left 1/24 of o way.
Stroke o size.
Vire around.
Vire right 1/48 of o way.
Vire right a fração of o way.
Adicione 1 para um contagem. Se o contagem é o point contagem, pare.
Repita.

Etapas necessárias para que se draw um string at o left of um caixa:
Draw o string at o left of o caixa with a cor preta e a default font.

Etapas necessárias para que se draw um string at o left of um caixa with um cor:
Draw o string at o left of o caixa with a cor e a default font.

Etapas necessárias para que se draw um string at o left of um caixa with uma cor e um font:
Draw o string no caixa with a cor e o font e "left".

Etapas necessárias para que se draw um string at o left of um caixa with um font:
Draw o string at o left of o caixa with a cor preta e o font.

Etapas necessárias para que se draw um string at o right of um caixa:
Draw o string at o right of o caixa with a cor preta e a default font.

Etapas necessárias para que se draw um string at o right of um caixa with um cor:
Draw o string at o right of o caixa with a cor e a default font.

Etapas necessárias para que se draw um string at o right of um caixa with uma cor e um font:
Draw o string no caixa with a cor e o font e "right".

Etapas necessárias para que se draw um string at o right of um caixa with um font:
Draw o string at o right of o caixa with a cor preta e o font.

Etapas necessárias para que se draw um string at um spot with um cor:
Draw o string at o spot with a cor e a default font.

Etapas necessárias para que se draw um string at um spot with uma cor e um font:
Se o página alarme deste pdf state estiver ativo, draw o string at o spot with a cor e o font (pdf style); exit.
Defina o código da cor of o quadro atual usando a cor.
Crie o hfont of o quadro atual usando o font.
Ajuste spacing usando o string.
Atribua o first deste string A um subtexto's first.
Atribua o first deste subtexto mais o text cutoff menos 1 ao last deste subtexto.
Isole o spot.
Percorra.
Se o subtexto estiver em branco, pare.
Se o last deste subtexto for maior do que o last deste string, atribua o last deste string ao last deste subtexto.
Call "gdi32.dll" "TextOutA" with o quadro atual e a coordenada x deste spot e a coordenada y deste spot e o first deste subtexto e o length deste subtexto.
Obtenha um width usando o subtexto e o quadro atual.
Adicione o width para a coordenada x deste spot.
Mova o subtexto usando o text cutoff.
Repita.
Destroy o hfont of o quadro atual.

Etapas necessárias para que se draw um string at um spot with uma cor e uma font (pdf style):
Se o string estiver em branco, cancele.
Isole o spot.
Include o font no current pdf.
Include o font na current página deste pdf state.
Encontre um definition pdf object usando o name desta font e o font index deste pdf state.
Se o definition for inexistente, cancele. \ erro
Crie uma font info usando o font e o string.
Output o pdf border usando a cor.
Output o pdf fill usando a cor.
Output "BT".
Output "/" then o font name desta definition then " " then a adjusted altura desta font then " Tf".
\ adicione a adjusted altura desta font menos o internal leading desta font info para o y do spot. \ just plain wrong
Adicione o ascent desta font info para a coordenada y deste spot. \ fix por line above
Output o spot sem advancing.
Output "Td".
Output "[" sem advancing.
Convert o font info para pdf em units.
Convert o string e o font info e a font info desta definition A um trecho por pdf output.
Output o trecho sem advancing.
Output "]" sem advancing.
Output " TJ".
Output "ET".
Destroy o font info.

Etapas necessárias para que se draw um string em um caixa:
Draw o string no caixa with a cor preta e a default font e "left".

Etapas necessárias para que se draw um string em um caixa over um número with uma cor e uma font e um alinhamento:
Isole o caixa.
Se o alinhamento for "left", adicione o número para o left desta caixa.
Se o alinhamento for "zquierda", adicione o número para o left desta caixa.
Se o alinhamento for "derecho", subtraia o número from o right desta caixa.
Draw o string no caixa with a cor e o font e o alinhamento.

Etapas necessárias para que se draw um string em um caixa with um alinhamento:
Draw o string no caixa with a cor preta e a default font e o alinhamento.

Etapas necessárias para que se draw um string em um caixa with um cor:
Draw o string no caixa with a cor e a default font e "left".

Etapas necessárias para que se draw um string em um caixa with uma cor e um alinhamento:
Draw o string no caixa with a cor e a default font e o alinhamento.

Etapas necessárias para que se draw um string em um caixa with uma cor e uma font e um alinhamento:
Obtenha um offset pair usando o string e o caixa e o font e o alinhamento.
Draw o string at o left-top desta caixa mais o offset pair with a cor e o font.

Etapas necessárias para que se draw um string em um caixa with uma font e um alinhamento:
Draw o string no caixa with a cor preta e o font e o alinhamento.

Etapas necessárias para que se draw um string no center of um caixa:
Draw o string no center of o caixa with a cor preta e a default font.

Etapas necessárias para que se draw um string no center of um caixa with um cor:
Draw o string no center of o caixa with a cor e a default font.

Etapas necessárias para que se draw um string no center of um caixa with uma cor e um font:
Draw o string no caixa with a cor e o font e "center".

Etapas necessárias para que se draw um string no center of um caixa with um font:
Draw o string no center of o caixa with a cor preta e o font.

Etapas necessárias para que se draw um terminal:
Se o terminal for inexistente, cancele.
Save o quadro atual.
Mask only outside a caixa deste terminal.
Draw e fill a caixa deste terminal with a cor preta.
Escreva os quoras deste terminal na caixa deste terminal.
Restore o quadro atual.

Etapas necessárias para que se draw um text:
Se o text for inexistente, cancele.
Save o quadro atual.
Mask outside a caixa deste text.
Draw any visible rows of o text.
Restore o quadro atual.

Etapas necessárias para que se draw um text (editing):
Se o text for inexistente, cancele.
Save o quadro atual.
Mask outside a caixa deste text.
Draw any visible rows of o text (editing).
Draw o caret no text.
Restore o quadro atual.

Etapas necessárias para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos:
Se o endereço completo é endereço da pasta-format, duplicate o endereço completo para o segunda endereço completo no sistema de arquivos (pasta)[endereço].
Se o endereço completo é file-format, duplicate o endereço completo para o segunda endereço completo no sistema de arquivos (file).

Etapas necessárias para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (pasta)[endereço]:
Se o endereço completo estiver no segunda endereço completo, atribua "Ocorreu um erro na hora de duplicar a pasta: " then o endereço completo then ". - erro de recursão inválida." ao i/o erro; exit.
Se o endereço completo não estiver no sistema de arquivos, atribua "Ocorreu um erro na hora de duplicar a pasta: " then o endereço completo then "." ao i/o erro; exit.
Se o segunda endereço completo não estiver no sistema de arquivos, crie o segunda endereço completo no sistema de arquivos.
Percorra.
Obtenha um item from o endereço completo.
Se o item não for found, cancele.
Atribua o endereço completo A um terceiro endereço completo.
Posponha o designador deste item para o terceiro endereço completo.
Atribua o segunda endereço completo A um quarto endereço completo.
Posponha o designador deste item para o quarto endereço completo.
Duplicate o terceiro endereço completo para o quarto endereço completo no sistema de arquivos.
Repita.

Etapas necessárias para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (file):
Isole o endereço completo.
Null terminate o endereço completo.
Isole o segunda endereço completo.
Null terminate o segunda endereço completo.
Call "kernel32.dll" "CopyFileA" with o first deste endereço completo e o first deste segunda endereço completo e 0 returning um número.
Limpe o i/o erro.
Se o número não for 0, defina o endereço completo para read-write mode; exit.
Atribua "Ocorreu um erro na hora de duplicar o arquivo: " then o endereço completo then "." ao i/o erro.

An dyad é uma coisa with
Um name,
Um value string.

O tecla E/e é uma tecla igual a 69.

O número oito é um pedaço igual a 56.

O tecla oito é uma tecla igual a 56.

Um elipse has uma caixa.

O ellipsis pedaço é um pedaço igual a 133.

O travessão é um pedaço igual a 151.

Um email has
Um smtp server,
Um sender,
Um recipient,
Um subject,
Um message.

O traço médio é um pedaço igual a 150.

Etapas necessárias para que se encrypt um trecho usando um passphrase string:
\ sets i/o erro if failure
Limpe o i/o erro.
Crie um crypt session usando o passphrase.
Se o crypt session for inexistente, cancele.
Atribua o trecho A um temp trecho.
Atribua o length deste temp trecho A um length.
Call "advapi32.dll" "CryptEncrypt" with a hcryptkey desta crypt session e 0 e 1 e 0 e o first deste temp trecho And o whereabouts deste length e o length returning um result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de criptografar os dados." ao i/o erro; destroy o crypt session; exit.
Destroy o crypt session.
Convert o temp trecho para um texto da cifra binária.
Atribua o texto da cifra binária ao trecho.

O tecla End é uma tecla igual a 35.

Etapas necessárias para que se end printing:
Se o documento alarme deste pdf state estiver ativo, end printing (pdf style); exit.
Call "gdi32.dll" "EndDoc" with o printer canvas.
Finalize o printer canvas.

Etapas necessárias para que se end printing (pdf style):
Se o documento alarme deste pdf state não estiver ativo, cancele.
End printing o target deste pdf endereço de memória deste pdf state.

Etapas necessárias para que se end printing um pdf:
End printing o pdf (finish o parent).
End printing o pdf (append o outline).
End printing o pdf (finish o root).
Limpe o pdf.
End printing o pdf (append header).
End printing o pdf (offset e posponha objects).
End printing o pdf (append xref table).
End printing o pdf (append trailer).
End printing o pdf (append footer).
Destroy o font index deste pdf state.
Destroy as outline entries deste pdf state.
Destroy os objects deste pdf state.
Desative o documento alarme deste pdf state.

Etapas necessárias para que se end printing um pdf (append footer):
Posponha "startxref" then o texto CRLF para o pdf.
Posponha o xref offset deste pdf state then o texto CRLF para o pdf.
Posponha "%%EOF" para o pdf.

Etapas necessárias para que se end printing um pdf (append header):
Posponha "%PDF-1.3" then o texto CRLF para o pdf.
Posponha "%âãÏÓ" then o texto CRLF para o pdf.
Posponha o texto CRLF para o pdf.

Etapas necessárias para que se end printing um pdf (append o outline entries - crie o objects):
Obtenha um pdf outline entry from as outline entries deste pdf state.
Se o pdf outline entry for inexistente, cancele.
Adicione um entry pdf object usando "outline entry".
Atribua o entry ao pdf object desta pdf outline entry.
Repita.

Etapas necessárias para que se end printing um pdf (append o outline entries):
Se as outline entries deste pdf state estiverem vazio, cancele.
End printing o pdf (append o outline entries - crie o objects).
Percorra.
Obtenha um pdf outline entry from as outline entries deste pdf state.
Se o pdf outline entry for inexistente, cancele.
Atribua o pdf object desta pdf outline entry A um object pdf object.
Posponha o número deste object then " 0 obj" para o object.
Posponha "<<" para o object.
Convert o title deste pdf outline entry para um pdf string.
Posponha "/Title " then o pdf string para o object.
Posponha "/Parent " then o número deste outline deste pdf state then " 0 R" para o object.
Se o next desta pdf outline entry não for inexistente, posponha "/Next " then o número deste pdf object deste next desta pdf outline entry then " 0 R" para o object.
Se o previous desta pdf outline entry não for inexistente, posponha "/Prev " then o número deste pdf object deste previous desta pdf outline entry then " 0 R" para o object.
Posponha "/Dest [" then o destination deste pdf outline entry then " 0 R /XYZ null " then o página altura deste pdf outline entry then " null]" para o object.
Posponha ">>" para o object.
Posponha "endobj" para o object.
Repita.

Etapas necessárias para que se end printing um pdf (append o outline):
Esvazie o outline deste pdf state.
Se as outline entries deste pdf state estiverem vazio, cancele.
Adicione um outline pdf object usando "outline".
Atribua o outline ao outline deste pdf state.
End printing o pdf (append o outline entries).
Posponha o número deste outline then " 0 obj" para o outline.
Posponha "<<" para o outline.
Posponha "/Type /Outlines" para o outline.
Posponha "/First " then o número deste pdf object deste first destas outline entries deste pdf state then " 0 R" para o outline.
Posponha "/Last " then o número deste pdf object deste last destas outline entries deste pdf state then " 0 R" para o outline.
Posponha "/Count " then a contagem destas outline entries deste pdf state para o outline.
Posponha ">>" para o outline.
Posponha "endobj" para o outline.

Etapas necessárias para que se end printing um pdf (append trailer):
Posponha "trailer" then o texto CRLF para o pdf.
Posponha "<<" then o texto CRLF para o pdf.
Atribua a contagem destes objects deste pdf state mais 1 A uma contagem.
Posponha "/Size " then o contagem then o texto CRLF para o pdf.
Posponha "/Root " then o número deste root deste pdf state then " 0 R" then o texto CRLF para o pdf.
Posponha ">>" then o texto CRLF para o pdf.
Posponha o texto CRLF para o pdf.

Etapas necessárias para que se end printing um pdf (append xref table):
Atribua o length deste pdf ao xref offset deste pdf state.
Posponha "xref" then o texto CRLF para o pdf.
Atribua a contagem destes objects deste pdf state mais 1 A um contagem.
Posponha "0 " then o contagem then o texto CRLF para o pdf.
Posponha "0000000000 65535 f" then o texto CRLF para o pdf.
Percorra.
Obtenha um pdf object from os objects deste pdf state.
Se o pdf object for inexistente, pare.
Zero fill o offset deste pdf object usando 10 e posponha it para o pdf.
Posponha " 00000 n" then o texto CRLF para o pdf.
Repita.
Posponha o texto CRLF para o pdf.

Etapas necessárias para que se end printing um pdf (finish o parent):
Atribua o parent deste pdf state A um parent pdf object.
Posponha "/Kids [" para o parent sem advancing.
Percorra.
Obtenha um pdf object from os objects deste pdf state.
Se o pdf object for inexistente, pare.
Se a categoria deste pdf object não for "page", repita.
Se um alarme estiver ativo, posponha " " para o parent sem advancing.
Posponha o número deste pdf object then " 0 R" para o parent sem advancing.
Ligue o alarme.
Adicione 1 para um contagem.
Se o contagem é evenly divisible por 20, posponha o texto CRLF then " " para o parent sem advancing.
Repita.
Posponha "]" para o parent.
Posponha "/Count " then o contagem para o parent.
Posponha ">>" para o parent.
Posponha "endobj" para o parent.

Etapas necessárias para que se end printing um pdf (finish o root):
Atribua o root deste pdf state A um root pdf object.
Posponha "/Pages " then o número deste parent deste pdf state then " 0 R" para o root.
Encontre um pdf object usando "page".
Posponha "/OpenAction [" then o número deste pdf object then " 0 R /XYZ null null 1]" para o root.
Posponha "/PageMode /UseNone" para o root.
Se o outline deste pdf state não for inexistente, posponha "/Outlines " then o número deste outline deste pdf state then " 0 R" para o root.
Posponha ">>" para o root.
Posponha "endobj" para o root.

Etapas necessárias para que se end printing um pdf (offset e posponha objects):
Obtenha um pdf object from os objects deste pdf state.
Se o pdf object for inexistente, pare.
Atribua o length deste pdf ao offset deste pdf object.
Posponha o data deste pdf object para o pdf.
Posponha o texto CRLF para o pdf.
Repita.

Etapas necessárias para que se end um sheet:
Se o documento alarme deste pdf state estiver ativo, end o sheet (pdf style); exit.
Call "gdi32.dll" "EndPage" with o printer canvas.
Atribua o memory canvas ao quadro atual.
Atribua o saved tpp ao tpp.

Etapas necessárias para que se end um sheet (pdf style - finish o current contents):
Atribua os current contents deste pdf state A um content pdf object.
Atribua os data deste content A um trecho.
Limpe os data deste content.
Posponha o número deste content then " 0 obj" para o content.
Posponha "<</Length " then o length deste trecho then " >>" para o content.
Posponha "stream" para o content.
Posponha o trecho para os data deste content.
Posponha "endstream" para o content.
Posponha "endobj" para o content.
Desative o página alarme deste pdf state.

Etapas necessárias para que se end um sheet (pdf style - finish o current página - font resources):
Atribua a current página deste pdf state A uma página pdf object.
Se as font strings desta página estiverem vazio, cancele.
Posponha "/Font <<" para o página sem advancing.
Percorra.
Obtenha um conjunto de texto from as font strings desta página.
Se o conjunto de texto for inexistente, pare.
Se um alarme estiver ativo, posponha " " para o página sem advancing.
Posponha o string deste conjunto de texto para o página sem advancing.
Ligue o alarme.
Repita.
Posponha ">>" para o página.

Etapas necessárias para que se end um sheet (pdf style - finish o current página - image resources):
Atribua a current página deste pdf state A uma página pdf object.
Se as image strings desta página estiverem vazio, cancele.
Posponha "/XObject <<" para o página sem advancing.
Percorra.
Obtenha um conjunto de texto from as image strings desta página.
Se o conjunto de texto for inexistente, pare.
Se um alarme estiver ativo, posponha " " para o página sem advancing.
Posponha o string deste conjunto de texto para o página sem advancing.
Ligue o alarme.
Repita.
Posponha ">>" para o página.

Etapas necessárias para que se end um sheet (pdf style - finish o current página):
Atribua a current página deste pdf state A uma página pdf object.
Posponha "/Resources" para o página.
Posponha "<<" para o página.
Posponha "/ProcSet [/PDF /Text /ImageC]" para o página.
End o sheet (pdf style - finish o current página - font resources).
End o sheet (pdf style - finish o current página - image resources).
Posponha ">>" para o página. \ end resources
Posponha ">>" para o página. \ end página
Posponha "endobj" para o página.

Etapas necessárias para que se end um sheet (pdf style):
End o sheet (pdf style - finish o current página).
End o sheet (pdf style - finish o current contents).

O end-of-medium pedaço é um pedaço igual a 25.

O end-of-text pedaço é um pedaço igual a 3.

O end-of-transmission pedaço é um pedaço igual a 4.

O end-of-transmission-block pedaço é um pedaço igual a 23.


Etapas necessárias para que se enlarge um caixa por alguns twips:
Subtraia o twips from o left-top desta caixa.
Adicione o twips para o right-base desta caixa.


Etapas necessárias para que se enlarge um elipse por alguns twips:
Subtraia o twips from o left-top desta elipse.
Adicione o twips para o right-base desta elipse.

Etapas necessárias para que se enque um event:
Posponha o event para o event queue.

O enquiry pedaço é um pedaço igual a 5.

O tecla Enter é uma tecla igual a 13.

O sinal de igualdade é um pedaço igual a 61.
O símbolo de igualdade é um pedaço igual a 61.

O tecla contendo sinal de igualdade é uma tecla igual a 187.
O tecla contendo símbolo de igualdade é uma tecla igual a 187.
O tecla de igualdade é uma tecla igual a 187.

Etapas necessárias para que se erase o insides of um caixa;
Etapas necessárias para que se erase inside um caixa;
Etapas necessárias para que se limpe inside um caixa:
Draw o caixa with o clear cor e a cor preta.

O Esc é um pedaço igual a 27.

O tecla de cancelameno é uma tecla igual a 27.

O tecla Esc é uma tecla igual a 27.

Etapas necessárias para que se estimate um rise e um run usando um heading:
Atribua o heading A um low heading.
Round o low heading down para o nearest multiple of 20.
Obtenha um low rise e um low run usando o low heading.
Atribua o heading A um high heading.
Round o high heading up para o nearest multiple of 20.
Obtenha um high rise e um high run usando o high heading.
Atribua o low rise mais o high rise dividido por 2 ao rise.
Atribua o low run mais o high run dividido por 2 ao run.

O euro-sign pedaço é um pedaço igual a 128.

\Um event é uma coisa with
\a categoria,
\a shift alarme,
\a ctrl alarme,
\um alt alarme,
\a spot,
\a tecla, um pedaço.

An event é uma coisa with
Um categoria [atualização de tela, mostrar seta, pressionamento de tecla, clique, clique duplo, clique direito, right double click, deactivate, activate, done], \ English
\Um clase [refrescar, cursor, tecla abajo, clic izquierdo, clic izquierdo doble, clic derecho, clic derecho doble, desactivar, activar, hecho], \ categoria em Spanish
Um shift alarme, 
Um ctrl alarme, 
Um alt alarme, 
Um spot, 
Um tecla, 
Um pedaço.

O event queue é um event queue.

Um event queue é alguns events.

O exclamation pedaço é um pedaço igual a 33.

O exclamation-mark pedaço é um pedaço igual a 33.

Etapas necessárias para que se extend any selection em um text usando um spot:
Se o text for inexistente, cancele.
Obtenha o caret deste text usando o spot e o text.
Limpe a last operation deste text.

Etapas necessárias para que se extend um caixa para include uma segunda caixa:
Se o left desta segunda caixa for menor do que o left desta caixa, atribua o left desta segunda caixa ao left desta caixa.
Se o topo desta segunda caixa for menor do que o topo desta caixa, atribua o topo desta segunda caixa ao topo desta caixa.
Se o right desta segunda caixa for maior do que o right desta caixa, atribua o right desta segunda caixa ao right desta caixa.
Se a base desta segunda caixa for maior do que a base desta caixa, atribua a base desta segunda caixa à base desta caixa.

Some extra points são alguns points.

Etapas necessárias para que se extract um designador from um endereço completo:
Limpe o designador.
Extract um unidade de disco from o endereço completo.
Lance um endereço completo subtexto sobre o endereço completo.
Adicione o length desta unidade de disco para o first deste endereço completo subtexto.
Se o endereço completo subtexto estiver em branco, atribua o unidade de disco ao designador; exit.
Lance um subtexto sobre o last pedaço of o endereço completo subtexto.
Se o target deste first deste subtexto for a barra invertida, subtraia 1 from o first deste subtexto.
Percorra.
Se o first deste subtexto for menor do que o first deste endereço completo subtexto, pare.
Se o target deste first deste subtexto for a barra invertida, pare.
Subtraia 1 from o first deste subtexto.
Repita.
Adicione 1 para o first deste subtexto.
Atribua o subtexto ao designador.

Etapas necessárias para que se extract um endereço da pasta from um endereço completo:
Limpe o endereço da pasta.
Extract um unidade de disco from o endereço completo.
Se o unidade de disco estiver em branco, cancele.
Lance um subtexto sobre o endereço completo.
Adicione o length desta unidade de disco para o first deste subtexto.
Se o subtexto estiver em branco, cancele.
Se o target deste last deste subtexto for a barra invertida, subtraia 1 from o last deste subtexto.
Percorra.
Se o subtexto estiver em branco, pare.
Se o target deste last deste subtexto for a barra invertida, pare.
Subtraia 1 from o last deste subtexto.
Repita.
Atribua o unidade de disco then o subtexto ao endereço da pasta.

Etapas necessárias para que se extract um nome do diretório from um endereço completo:
Limpe o nome do diretório.
Se o endereço completo não for endereço da pasta-format, cancele.
Extract o nome do diretório como um designador from o endereço completo.

Etapas necessárias para que se extract um nome da pasta from um endereço completo:
Extract o nome da pasta como um nome do diretório from o endereço completo.
Se o nome da pasta estiver em branco, cancele.
Remove o last pedaço from o nome da pasta.

Etapas necessárias para que se extract um unidade de disco from um endereço completo:
Limpe o unidade de disco.
Se o length deste endereço completo for menor do que 3, cancele.
Lance um subtexto sobre o first pedaço of o endereço completo.
Adicione 2 para o last deste subtexto.
Se o subtexto ends with ":\", atribua o subtexto ao unidade de disco; exit.
Se o subtexto does not start with "\\", cancele.
Lance o subtexto sobre o first pedaço of o endereço completo.
Percorra.
Se o last deste subtexto for maior do que o last deste endereço completo, cancele.
Se o target deste last deste subtexto for a barra invertida, adicione 1 para um contagem.
Se o contagem for 4, pare. \ "\\computer\share\"
Adicione 1 para o last deste subtexto.
Repita.
Atribua o subtexto ao unidade de disco.

Etapas necessárias para que se extract um extensão from um endereço completo:
Limpe o extensão.
Se o endereço completo estiver em branco, cancele.
Lance um subtexto sobre o last pedaço of o endereço completo.
Percorra.
Se o first deste subtexto for menor do que o first deste endereço completo, cancele.
Se o target deste first deste subtexto for o sinal de dois pontos, cancele.
Se o target deste first deste subtexto for a barra invertida, cancele.
Se o target deste first deste subtexto for o ponto final, pare.
Subtraia 1 from o first deste subtexto.
Repita.
Atribua o subtexto ao extensão.

Etapas necessárias para que se extract um nome do arquivo from um endereço completo:
Limpe o nome do arquivo.
Se o endereço completo não for file-format, cancele.
Extract o nome do arquivo como um designador from o endereço completo.

Etapas necessárias para que se extract um nome do arquivo s/ extensão from um endereço completo:
Extract o nome do arquivo s/ extensão como um nome do arquivo from o endereço completo.
Extract um extensão from o endereço completo.
Remove trailing pedaços from o nome do arquivo s/ extensão usando o length desta extensão.

Etapas necessárias para que se extract um picture usando um caixa:
Atribua a width desta caixa dividido pelo tpp A um width.
Atribua a altura desta caixa dividido pelo tpp A um altura.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" with o width e o altura e 0 e 137224 [pixelformat24bpprgb] e 0 e um gpbitmap's whereabouts.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" with o gpbitmap e um gpgraphic's whereabouts.
Call "gdiplus.dll" "GdipGetDC" with o gpgraphic e um bitmap canvas' whereabouts.
Normalize o bitmap canvas.
Call "gdi32.dll" "BitBlt" with o bitmap canvas e 0 e 0 e a width desta caixa e a altura desta caixa 
And o quadro atual e o left desta caixa e o topo desta caixa e 13369376 [srccopy].
Call "gdiplus.dll" "GdipReleaseDC" with o gpgraphic e o bitmap canvas.
Call "gdiplus.dll" "GdipDeleteGraphics" with o gpgraphic.
Crie o picture usando o gpbitmap.
Atribua o caixa à caixa desta picture.
Atribua o caixa à uncropped caixa desta picture.

Etapas necessárias para que se extract um string from um text:
Se o text for inexistente, limpe o string; exit.
Convert as rows deste text para o string.
Remove any trailing linefeed pedaço from o string.
Remove any trailing return pedaço from o string.

Etapas necessárias para que se extract um string from um text (no linefeed additions):
Se o text for inexistente, limpe o string; exit.
Convert as rows deste text para o string (no linefeed additions).
Remove any trailing return pedaço from o string.

Etapas necessárias para que se extract um string from um text (selecionado pedaços):
Limpe o string.
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Lance um subtexto sobre any selecionado pedaços na row of o text.
Se o subtexto estiver em branco, repita.
Posponha o subtexto para o string.
Se o target deste last deste subtexto for o return pedaço, posponha o linefeed pedaço para o string.
Repita.

O tecla F/f é uma tecla igual a 70.

O tecla F1 é uma tecla igual a 112.

O tecla F10 é uma tecla igual a 121.

O tecla F11 é uma tecla igual a 122.

O tecla F12 é uma tecla igual a 123.

O tecla F2 é uma tecla igual a 113.

O tecla F3 é uma tecla igual a 114.

O tecla F4 é uma tecla igual a 115.

O tecla F5 é uma tecla igual a 116.

O tecla F6 é uma tecla igual a 117.

O tecla F7 é uma tecla igual a 118.

O tecla F8 é uma tecla igual a 119.

O tecla F9 é uma tecla igual a 120.

Etapas necessárias para que se face any way you want;
Etapas necessárias para que se face any which way:
Escolha aleatoriamente um heading.

Etapas necessárias para que se face east:
Atribua 960 ao heading deste context.

Etapas necessárias para que se face north:
Atribua 0 ao heading deste context.

Etapas necessárias para que se face south:
Atribua 1920 ao heading deste context.

Etapas necessárias para que se face west:
Atribua 2880 ao heading deste context.

Um fancy arrow é um figura.

O feminúmero nove é um pedaço igual a 170.

Um figura é um polygon.

O figuras são alguns polygons.

O file-separator pedaço é um pedaço igual a 28.

Um filetime é um conjunto with
Um número called dwlowdatetime,
Um número called dwhighdatetime.

Etapas necessárias para que se fill um caixa with um cor:
Draw o caixa with o clear cor e a cor.

Etapas necessárias para que se fill pedaços with um pedaço starting at um endereço de memória por um quantidade de pedaços:
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ o endereço de memória
Intel $8B3F. \ mov edi,[edi]
Intel $8B8D10000000. \ mov ecx,[ebp+16] \ o contagem
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $8A00. \ mov al,[eax]
Intel $FC. \ cld
Intel $F3AA. \ rep stosb

Etapas necessárias para que se fill um elipse sobre um spot with um cor:
Centralize o elipse sobre o spot.
Draw o elipse with o clear cor e a cor.

Etapas necessárias para que se fill um string with um pedaço usando um contagem:
Reassign o first deste string usando a contagem.
Fill pedaços with o pedaço starting at o first deste string pela contagem.
Atribua o first deste string mais o contagem menos 1 ao last deste string.

Etapas necessárias para que se finalize after run:
Se o heap contagem for 0, cancele.
Atribua o heap contagem A um contagem.
Atribua o contagem then " drip(s)." A um string.
Debug o string.

Etapas necessárias para que se finalize o canvases:
Finalize o memory canvas.
Finalize o tela canvas.

Etapas necessárias para que se finalize o cgi:
Call "kernel32.dll" "FreeConsole".

Etapas necessárias para que se finalize o cors:

Etapas necessárias para que se finalize with:
Call "ole32.dll" "CoUninitialize".

Etapas necessárias para que se finalize um context:
Destroy o choices.
Destroy o figuras.
Destroy o context stack.
Destroy o context.

Etapas necessárias para que se finalize o cursors:
Call "user32.dll" "DestroyCursor" with o i-beam cursor.
Call "user32.dll" "DestroyCursor" with o hand cursor.
Call "user32.dll" "DestroyCursor" with a seta do mouse.

Etapas necessárias para que se finalize o fonts:
Call "gdi32.dll" "RemoveFontMemResourceEx" with o osmosian font resource.

Etapas necessárias para que se finalize gdi+:
Call "gdiplus.dll" "GdiplusShutdown" with o gptoken.

Etapas necessárias para que se finalize o memory canvas:
Call "gdi32.dll" "SelectObject" with o memory canvas e o saved memory hbitmap returning um hbitmap.
Call "gdi32.dll" "DeleteObject" with o hbitmap.
Call "gdi32.dll" "DeleteDC" with o memory canvas.

Etapas necessárias para que se finalize o module:

Etapas necessárias para que se finalize o mouse:

Etapas necessárias para que se finalize o printer canvas:
Call "kernel32.dll" "GlobalFree" with o printer device mode handle.
Atribua 0 ao printer canvas.

Etapas necessárias para que se finalize o tela:

Etapas necessárias para que se finalize o tela canvas:

Etapas necessárias para que se finalize um talker:
Se o talker for inexistente, cancele.
Call a release desta vtable deste talker with o talker.
Atribua nil ao talker.

Etapas necessárias para que se finalize o window:
Call "user32.dll" "DestroyWindow" with o main window.
Percorra.
Call "user32.dll" "GetMessageA" with um msg's whereabouts e 0 e 0 e 0 returning um número.
Se o número for menor do que 1, pare.
Call "user32.dll" "TranslateMessage" with o whereabouts desta msg.
Call "user32.dll" "DispatchMessageA" with o whereabouts desta msg.
Repita.
Desmanche o event queue.
Destroy o evento atual.

Etapas necessárias para que se finalize winsock:
Call "ws2_32.dll" "WSACleanup".

O find anchor é um anchor.

Etapas necessárias para que se encontre um choice usando um spot:
Start with nothing no choice.
Percorra.
Obtenha o [first/next] choice from o choices.
Se o choice é missing, cancele.
Se o spot estiver na caixa desta choice, pare.
Repita.

Etapas necessárias para que se encontre um dyad usando alguns dyads e um name:
Esvazie o dyad.
Percorra.
Obtenha o dyad from o dyads.
Se o dyad for inexistente, cancele.
Se o name deste dyad for o name, cancele.
Repita.

Etapas necessárias para que se encontre next usando um row e um text e um alarme:
Desative o alarme.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Lance um subtexto sobre o string deste row.
Atribua o first deste subtexto mais o length deste find string menos 1 ao last deste subtexto.
Se o número da linha desta row for o número da linha deste find anchor, mova o subtexto usando o column# deste find anchor menos 1.
Percorra.
Se o last deste subtexto for maior do que ou igual ao last deste string desta row, cancele.
Se o subtexto for o find string (accent-free compare), pare. \ for spanish incremental find
Mova o subtexto usando 1.
Repita.
Ligue o alarme.
Atribua o first deste subtexto menos o first deste string desta row mais 1 ao anchor column# deste text.
Atribua o número da linha desta row ao anchor número da linha deste text .
Atribua o last deste subtexto menos o first deste string desta row mais 2 ao caret column# deste text.
Atribua o número da linha desta row ao caret número da linha deste text.

Etapas necessárias para que se encontre next usando um text e um alarme:
Se o wrap alarme deste text estiver ativo, encontre next usando o text e o alarme (wrapped text); exit.
Desative o alarme.
Se o text for inexistente, cancele.
Se o length deste find string for 0, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
Encontre next usando a row e o text e o alarme.
Se o alarme estiver ativo, cancele.
Repita.

Etapas necessárias para que se encontre next usando um text e um alarme (wrapped text):
Desative o alarme.
Se o text for inexistente, cancele.
Convert o find anchor para um posicionamento absoluto called offset usando o text.
Extract um string from o text (no linefeed additions).
Atribua o first deste string mais o offset menos 1 A um subtexto's first.
Atribua o first deste subtexto mais o length deste find string menos 1 ao last deste subtexto.
Percorra.
Se o last deste subtexto for maior do que o last deste string, cancele.
Se o subtexto é o find string (accent-free compare), pare. \ por spanish incremental find
Mova o subtexto usando 1.
Repita.
Ligue o alarme.
Atribua o first deste subtexto menos o first deste string mais 1 A um anchor posicionamento absoluto.
Atribua o last deste subtexto menos o first deste string mais 2 A um caret posicionamento absoluto.
Convert o anchor posicionamento absoluto para o anchor deste text usando o text.
Convert o caret posicionamento absoluto para o caret deste text usando o text.

Etapas necessárias para que se encontre o next misspelling usando um row e um text e um alarme:
Desative o alarme.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Lance um percorredor sobre o string deste row.
Se o número da linha desta row é o número da linha deste find anchor, adicione o column# deste find anchor menos 1 para o first deste source deste percorredor.
Se o first deste source deste percorredor não for o first deste string desta row, skip palavra characters no source deste percorredor.
Percorra.
Mova o percorredor (spell checking rules).
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor não for misspelled, repita.
Ligue o alarme.
Atribua o first deste token deste percorredor menos o first deste string desta row mais 1 ao anchor column# deste text.
Atribua o número da linha desta row ao anchor número da linha deste text .
Atribua o last deste token deste percorredor menos o first deste string desta row mais 2 ao caret column# deste text.
Atribua o número da linha desta row ao caret número da linha deste text.

Etapas necessárias para que se encontre o next misspelling em um text usando um alarme:
Desative o alarme.
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
Encontre o next misspelling usando a row e o text e o alarme.
Se o alarme estiver ativo, cancele.
Repita.

Etapas necessárias para que se encontre um pdf object usando um categoria:
Esvazie o pdf object.
Percorra.
Obtenha o pdf object usando os objects deste pdf state.
Se o pdf object for inexistente, pare.
Se a categoria deste pdf object é o categoria, pare.
Repita.

Etapas necessárias para que se encontre um endereço de memória usando um string e um index:
Encontre um refer usando o string e o index.
Se o refer não for inexistente, atribua o endereço de memória deste refer ao endereço de memória; exit.
Esvazie o endereço de memória.

Etapas necessárias para que se encontre um refer usando um string e um index:
Se o index for inexistente, cancele.
Se o string estiver em branco, esvazie o refer; exit.
Obtenha um bucket usando o string e o index.
Encontre o refer usando o string e os refers deste bucket.

Etapas necessárias para que se encontre um refer usando um string e alguns refers:
Esvazie o refer.
Percorra.
Obtenha o refer from o refers.
Se o refer for inexistente, cancele.
Se o string for o string deste refer, cancele.
Repita.

Etapas necessárias para que se encontre um sector usando um grid e um spot:
Atribua a coordenada x deste spot dividido pelo número x desta grid times o número x desta grid à coordenada x deste sector.
Atribua a coordenada y deste spot dividido pelo número y desta grid times o número y desta grid à coordenada y deste sector.

Etapas necessárias para que se encontre um square root of um número:
\ rounds down
Isole o número.
De-sign o número.
Se o número for 0, atribua 0 ao square root; exit.
Se o número for 1, atribua 1 ao square root; exit.
Atribua 1 A um square número.
Atribua 3 A um delta número.
Percorra.
Se o square for maior do que o número, pare.
Adicione o delta para o square.
Adicione 2 para o delta.
Repita.
Atribua o delta dividido por 2 menos 1 ao square root.

Etapas necessárias para que se encontre um string usando alguns conjunto de textos e um string#:
Limpe o string.
Percorra.
Obtenha um conjunto de texto from o conjunto de textos.
Se o conjunto de texto for inexistente, cancele.
Adicione 1 para um contagem.
Se o contagem não for o string#, repita.
Atribua o string deste conjunto de texto ao string.

O find string é um string.

Etapas necessárias para que se encontre um conjunto de texto usando um string e alguns conjunto de textos:
Esvazie o conjunto de texto.
Percorra.
Obtenha o conjunto de texto usando o conjunto de textos.
Se o conjunto de texto for inexistente, pare.
Se o string deste conjunto de texto é o string, pare.
Repita.

Etapas necessárias para que se encontre um subtexto em um string usando uma segunda string:
Lance o subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o subtexto starts with o segunda string, pare.
Adicione 1 para o first deste subtexto.
Repita.
Atribua o first deste subtexto mais o length deste segunda string menos 1 ao last deste subtexto.

Etapas necessárias para que se encontre um value string usando alguns dyads e um name:
Encontre um dyad usando o dyads e o name.
Se o dyad for inexistente, limpe o value; exit.
Atribua o value deste dyad ao value.

Etapas necessárias para que se encontre um value string usando o environment variables e um name:
Isole o name.
Null terminate o name.
Atribua 32767 A um length. \ max size por environment variable
Reassign o first deste value usando o length.
Call "kernel32.dll" "GetEnvironmentVariableA" with o first deste name e o first deste value e o length returning o length.
Atribua o first deste value mais o length menos 1 ao last deste value.

Um finger é um endereço de memória do pedaço .

O número cinco é um pedaço igual a 53.

O tecla cinco é uma tecla igual a 53.

\Um flag has 4 pedaços.
Um alarme has 4 pedaços. \é um conjunto com

Etapas necessárias para que se flip um fração:
Swap o numerador desta fração with o denominador desta fração.

Etapas necessárias para que se flip o gpbitmap em um picture:
Se o picture for inexistente, cancele.
Reverse o mirror alarme desta picture.
Adicione 1800 para o ângulo de rotação desta picture.
Normalize o ângulo de rotação desta picture.
Flip o gpbitmap desta picture.

Etapas necessárias para que se flip um gpimage:
Call "gdiplus.dll" "GdipImageRotateFlip" with o gpimage e 6 [rotatenoneflipy aka rotate180flipx].

Etapas necessárias para que se flip um picture:
Se o picture for inexistente, cancele.
Atribua o coordenada y deste center desta caixa desta picture menos a coordenada y deste center desta uncropped caixa desta picture A um pair's número y.
Multiplique o número y deste pair por 2.
Mova a uncropped caixa desta picture usando o pair.
Flip o gpbitmap no picture.

Etapas necessárias para que se flip um polygon:
Se o polygon for inexistente, cancele.
Atribua a caixa deste polygon A uma caixa.
Percorra.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, cancele.
Subtraia o topo desta caixa from a coordenada y deste vértice.
Atribua a base desta caixa menos a coordenada y deste vértice à coordenada y deste vértice.
Repita.

Etapas necessárias para que se desmanche all input;
Etapas necessárias para que se desmanche all inputs;
Etapas necessárias para que se desmanche all events:
Desmanche any messages.
Desmanche o event queue.

Etapas necessárias para que se desmanche any messages:
Call "user32.dll" "PeekMessageA" with um msg's whereabouts e 0 e 0 e 0 e 1 [pm_remove] returning um número.
Se o número for 0, cancele.
Se a message desta msg for 15 [wm_paint], call "user32.dll" "ValidateRect" with o main window e 0.
Repita.

Etapas necessárias para que se desmanche um event queue:
Obtenha um event from o event queue.
Se o event for inexistente, cancele.
Remove o event from o event queue.
Destroy o event.
Repita.

Um font has um name e um altura.

Um font altura é alguns twips. \ indicates line altura - o letras will fit nicely em um caixa of this altura

Um font info é uma coisa with \ used por pdf conversion
Um font,
Um emsquare número,
Um internal leading número,
Um flags número,
Um ascent número,
Um descent número,
Um capheight número,
Um italicangle número,
Um stemv número,
Um font caixa,
Some font widths.

Um font resource é um handle.

Some font widths é uma coisa with \ used por pdf conversion
Um font,
Um contagem,
Um número endereço de memória called data.

Um foot é 12 inches.

O form-feed pedaço é um pedaço igual a 12.

Etapas necessárias para que se format um número e um singular string ou um plural string Para um string:
Convert o número para o string.
Posponha o caractere de espaço para o string.
Se o número for 1, posponha o singular para o string.
Se o número não for 1, posponha o plural para o string.

O número quatro é um pedaço igual a 52.

O tecla quatro é uma tecla igual a 52.

Um fração has um numerador número e um denominador número, e um topo número at o numerador e um base número at o denominador.

Um fração pair has uma fração e uma segunda fração.

O tecla G/g é uma tecla igual a 71.

Um máximo divisor comum é um número.

Um gcpresults é um conjunto with
Um número called lstructsize,
Um pchar called lpoutstring,
Um número endereço de memória called lporder,
Um número endereço de memória called lpdx,
Um número endereço de memória called lpcaretpos,
Um endereço de memória called lpclass,
Um endereço de memória called lpglyphs,
Um número called nglyphs,
Um número called maxfit.

Um gdiplusstartupinput é um conjunto with
Um número called gdiplusversion,
Um endereço de memória called debugeventcallback,
Um número called suppressbackgroundthread,
Um número called suppressexternalcodecs.

Um figura geométrica é um figura.

Etapas necessárias para que se obtenha um abca e um abcc usando um string e um canvas:
Atribua 0 ao abca.
Atribua 0 ao abcc.
Se o length deste string for menor do que 1, cancele.
Call "gdi32.dll" "GetCharABCWidthsA" with o canvas e o target deste first deste string e o target deste first deste string e um abc's whereabouts.
Atribua o abca deste abc ao abca.
Call "gdi32.dll" "GetCharABCWidthsA" with o canvas e o target deste last deste string e o target deste last deste string e uma segunda abc's whereabouts.
Atribua o abcc deste segunda abc ao abcc.

Etapas necessárias para que se obtenha um abca usando um string e um canvas:
Atribua 0 ao abca.
Se o length deste string for menor do que 1, cancele.
Call "gdi32.dll" "GetCharABCWidthsA" with o canvas e o target deste first deste string e o target deste first deste string e um abc's whereabouts.
Atribua o abca deste abc ao abca.

Etapas necessárias para que se obtenha alguns addrinfo routines:
Limpe o i/o erro.
Call "kernel32.dll" "LoadLibraryA" with "ws2_32.dll"'s first returning um handle.
Se o handle for 0, atribua "No se pudo leer ws2_32.dll." ao i/o erro; exit.
Call "kernel32.dll" "GetProcAddress" with o handle e "getaddrinfo"'s first returning um endereço de memória.
Se o endereço de memória for inexistente, atribua "Lamento que estas rutinas solo funcionan en Windows XP o superior." ao i/o erro; exit.
Atribua o endereço de memória ao getaddrinfo endereço de memória destas addrinfo routines.
Call "kernel32.dll" "GetProcAddress" with o handle e "freeaddrinfo"'s first returning o endereço de memória.
Se o endereço de memória for inexistente, atribua "Infelizmente essas rotinas só funcionam no Windows XP ou numa versão superior do Windows." ao i/o erro; exit.
Atribua o endereço de memória ao freeaddrinfo endereço de memória destas addrinfo routines.

Etapas necessárias para que se obtenha um caixa pelo caret em um text:
Se o text for inexistente, zero o caixa; exit.
Obtenha um spot usando o caret deste text e o text.
Atribua o spot e o spot ao caixa.
Adicione a row altura deste text para a base desta caixa.
Ajuste o caixa usando 0 e o tpp e 0 e - o tpp.
Atribua a globalized origin deste text A um origin.
Se o left desta caixa for menor do que a coordenada x desta origin, atribua a coordenada x desta origin ao left desta caixa; atribua a coordenada x desta origin ao right desta caixa.
Se o wrap alarme deste text não estiver ativo, cancele.
Limite o left desta caixa para o left deste text e o right deste text.
Limite o right desta caixa para o left deste text e o right deste text.

Etapas necessárias para que se obtenha um caixa por um line:
Atribua o start desta line ao left-top desta caixa.
Atribua o end desta line ao right-base desta caixa.
Normalize a caixa.

Etapas necessárias para que se obtenha um caixa usando um row e um text:
Se o text for inexistente, zero o caixa; exit.
Se a row for inexistente, zero o caixa; exit.
Atribua a globalized origin deste text ao left-top desta caixa.
Adicione o número da linha desta row menos 1 times a row altura deste text para o topo desta caixa.
Atribua o right deste text ao right desta caixa.
Atribua o topo desta caixa mais a row altura deste text à base desta caixa.

Etapas necessárias para que se obtenha um bucket usando um bucket# e um index:
\ if o index for inexistente, esvazie o bucket; exit. \ para make compilador faster
Atribua o first bucket deste index ao bucket.
Adicione o bucket# times um bucket conjunto's magnitude para o bucket.

Etapas necessárias para que se obtenha um bucket usando um index:
\ if o index for inexistente, esvazie o bucket; exit. \ para make compilador faster
Se o bucket for inexistente, atribua o first bucket deste index ao bucket; exit.
Se o bucket for o last bucket deste index, esvazie o bucket; exit.
Adicione um bucket conjunto's magnitude para o bucket.

Etapas necessárias para que se obtenha um bucket usando um string e um index:
\ if o index for inexistente, esvazie o bucket; exit. \ para make compilador faster
Obtenha um bucket# usando o string e o index.
Obtenha o bucket usando o bucket# e o index.

Etapas necessárias para que se obtenha um bucket# usando um string e um index:
\ based sobre o djb2 algorithm
\ if o index for inexistente, atribua 0 ao bucket#; exit. \ para make compilador faster
Atribua o length deste string ao bucket#.
Se o bucket# for 0, cancele.
Adicione 5381 para o bucket#.
Lance um subtexto sobre o string.
Percorra.
Atribua o target deste first deste subtexto A um pedaço.
Lowercase o pedaço.
Atribua o bucket# A um número.
Shift o bucket# left 5 bits.
Adicione o número para o bucket#.
Adicione o pedaço para o bucket#.
Adicione 3 para o first deste subtexto.
Se o subtexto estiver em branco, pare.
Repita.
Conjuncione logicamente o bucket# with o maior número.
Divida o bucket# pela bucket contagem deste index giving um quotient e o bucket#.

Etapas necessárias para que se obtenha um pedaço from um string:
Se o string estiver em branco, atribua o null pedaço ao pedaço; exit.
Atribua o target deste first deste string ao pedaço.
Remove o first pedaço from o string.

Etapas necessárias para que se obtenha um pedaço from um string (backwards):
Se o string estiver em branco, atribua o null pedaço ao pedaço; exit.
Atribua o target deste last deste string ao pedaço.
Remove o last pedaço from o string.

Etapas necessárias para que se obtenha um center spot usando um spot e uma segunda spot:
Atribua o spot e o segunda spot A um line.
Atribua o center desta line ao center.

Etapas necessárias para que se obtenha uma cor usando um spot:
Call "gdi32.dll" "GetPixel" with o quadro atual e a coordenada x deste spot e a coordenada y deste spot returning um código da cor.
Convert o código da cor para a cor.

Etapas necessárias para que se obtenha um column# usando um row e um spot e um text:
Atribua 0 ao column#.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Obtenha um caixa usando a row e o text.
Se a coordenada y deste spot for maior do que a base desta caixa, atribua o length deste string desta row ao column#; exit. \ only happens sobre last row of text
Crie o hfont of o memory canvas usando o font deste text.
Obtenha um start width e um subtexto usando a row e o spot e o text (for "get um column# usando um row...").
Percorra.
Se o last deste subtexto é o last deste string desta row, pare.
Obtenha um width usando o subtexto e o memory canvas.
Adicione o start width para o width.
Obtenha uma segunda width usando o target deste last deste subtexto e o memory canvas.
Divida o segunda width por 2.
Subtraia o segunda width from o width.
Se a coordenada x deste spot for menor do que o width, pare.
Adicione 1 para o last deste subtexto.
Repita.
Atribua o last deste subtexto menos o first deste string desta row mais 1 ao column#.
Destroy o hfont of o memory canvas.

Etapas necessárias para que se obtenha um contagem of items em um endereço completo no sistema de arquivos:
Atribua 0 à contagem.
Percorra.
Obtenha um item from o endereço completo.
Se o item não for found, cancele.
Adicione 1 para a contagem.
Repita.

Etapas necessárias para que se obtenha um description por um endereço completo:
Limpe o description.
Obtenha um categoria da unidade de disco pelo endereço completo.
Atribua o categoria da unidade de disco ao description.
Obtenha um nome da unidade de disco pelo endereço completo.
Se o nome da unidade de disco não estiver em branco, atribua o nome da unidade de disco ao description.
Lowercase o description.

Etapas necessárias para que se obtenha um difference between um pair e uma segunda pair:
Atribua o pair à difference.
Subtraia o segunda pair from a difference.

Etapas necessárias para que se obtenha um difference between um pair e uma segunda pair usando um grid pair:
Obtenha a difference between o pair e o segunda pair.
Round a difference para o grid.

Etapas necessárias para que se obtenha um distance between um spot e uma segunda spot (approximate):
Atribua o x deste spot menos o x deste segunda spot A um número.
De-sign o número.
Atribua o y deste spot menos o y deste segunda spot A uma segunda número.
De-sign o segunda número.
Atribua o número times o número ao distance.
Adicione o segunda número times o segunda número para o distance.
Encontre um square root of o distance.
Atribua o square root ao distance.
Se a tecla D/d estiver sendo pressionada, debug o distance.

Etapas necessárias para que se obtenha um distance between um spot e uma segunda spot (chessboard):
Atribua a coordenada x deste spot menos a coordenada x deste segunda spot A um número.
De-sign o número.
Atribua a coordenada y deste spot menos a coordenada y deste segunda spot A uma segunda número.
De-sign o segunda número.
Atribua o número ao distance.
Se o segunda número for maior do que o número, atribua o segunda número ao distance.

Etapas necessárias para que se obtenha um categoria da unidade de disco por um endereço completo:
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "GetDriveTypeA" with o first deste endereço completo returning um número.
Se o número for 2 [drive_removable], atribua "Disco removível" ao categoria da unidade de disco; exit. \ removable drive
Se o número for 3 [drive_fixed], atribua "Disco Rígido / Pendrive" ao categoria da unidade de disco; exit.\ hard disk / flash drive
Se o número for 4 [drive_remote], atribua "Unidade de rede" ao categoria da unidade de disco; exit. \ network drive
Se o número for 5 [drive_cdrom], atribua "Unidade de CD/DVD" ao categoria da unidade de disco; exit. \ cd-rom / dvd drive
Se o número for 6 [drive_ramdisk], atribua "Unidade virtual na memória" ao categoria da unidade de disco; exit. \ virtual unidade de disco em memory
Atribua "" ao categoria da unidade de disco.

Etapas necessárias para que se obtenha um nome da unidade de disco por um endereço completo:
Isole o endereço completo.
Null terminate o endereço completo.
Atribua 512 A um length.
Reassign um trecho's first usando o length.
Call "kernel32.dll" "GetVolumeInformationA" with o first deste endereço completo e o first deste trecho e o length e 0 e 0 e 0 e 0 e 0 returning um número.
Se o número for 0, limpe o nome da unidade de disco; exit.
Convert o first deste trecho como um pchar para o nome da unidade de disco.

Etapas necessárias para que se obtenha o first-eighth equivalent of um heading:
Obtenha o first-quarter equivalent of o heading.
Se o heading for menor do que 480, cancele.
Subtraia 960 from o heading.
De-sign o heading.

Etapas necessárias para que se obtenha o first-quarter equivalent of um heading:
Se o heading for menor do que 960, cancele.
Subtraia 960 from o heading.
Repita.

Etapas necessárias para que se obtenha fresh random números;
Etapas necessárias para que se obtenha new random números;
Etapas necessárias para que se seed o random número generator:
Atribua o system's tick contagem à seed.

Etapas necessárias para que se obtenha um máximo divisor comum usando um número e uma segunda número:
Atribua o número A um dividend número.
Atribua o segunda número ao máximo divisor comum.
De-sign o dividend número.
De-sign o máximo divisor comum.
Se o dividend for menor do que o máximo divisor comum, swap o dividend with o máximo divisor comum.
Se o máximo divisor comum for 0, atribua 1 ao máximo divisor comum; exit.
Percorra.
Divida o dividend pelo máximo divisor comum giving um quotient e um resto.
Se o resto for 0, cancele.
Atribua o máximo divisor comum ao dividend.
Atribua o resto ao máximo divisor comum.
Repita.

Etapas necessárias para que se obtenha um ip address usando um host string:
Limpe o ip address.
Obtenha um sockaddr usando o host string.
Se o i/o erro não estiver em branco, cancele.
Atribua o s_addr deste sin_addr deste sockaddr ao número deste ip address.
Call "ws2_32.dll" "inet_ntoa" with o número deste ip address returning um pchar.
Convert o pchar para o string deste ip address.

Etapas necessárias para que se obtenha um item (not first time):
Limpe o i/o erro.
Call "kernel32.dll" "FindNextFileA" with o handle deste item e o whereabouts deste win32finddata deste item returning um número.
Se o número não for 0, ajuste o item; exit.
Limpe a categoria deste item.
Call "kernel32.dll" "FindClose" with o handle deste item.

Etapas necessárias para que se obtenha um item from um endereço completo:
Se o endereço completo não for endereço da pasta-format, cancele.
Atribua o endereço completo ao endereço da pasta deste item.
Se a categoria deste item estiver em branco, obtenha o item from o endereço completo (first time); exit.
Obtenha o item (not first time).

Etapas necessárias para que se obtenha um item from um endereço completo (first time):
Limpe o i/o erro.
Isole o endereço completo.
Posponha "*.*" para o endereço completo.
Null terminate o endereço completo.
Limpe a categoria deste item.
Call "kernel32.dll" "FindFirstFileA" with o first deste endereço completo e o whereabouts deste win32finddata deste item returning o handle deste item.
Se o handle deste item for -1 [invalid_handle_value], cancele.
Ajuste o item.

Etapas necessárias para que se obtenha um mínimo múltiplo comum usando um número e uma segunda número:
Obtenha um máximo divisor comum usando o número e o segunda número.
Call "kernel32.dll" "MulDiv" with o número e o segunda número e o máximo divisor comum returning o mínimo múltiplo comum.

Etapas necessárias para que se obtenha um letra from o alphabet:
Atribua o next letra ao letra.
Avance o next letra limiting it para o 'A' maiúsculo e o Z maiúsculo.
Adicione 1 para o next letra.
Se o next letra for maior do que o Z maiúsculo, atribua o 'A' maiúsculo à next letra.

Etapas necessárias para que se obtenha um número from a stack:
Atribua 0 ao número.
Obtenha um stack entry from o stack.
Se a stack entry for inexistente, cancele.
Convert o string desta stack entry para o número.
Remove a stack entry from o stack.
Destroy a stack entry.

Etapas necessárias para que se obtenha um offset pair usando um string e um caixa e uma font e um alinhamento:
Crie o hfont of o memory canvas usando o font.
Obtenha o offset pair usando o string e o caixa e o font e o alinhamento (fast).
Destroy o hfont of o memory canvas.

Etapas necessárias para que se obtenha um offset pair usando um string e um caixa e uma font e um alinhamento (fast):
Se o alinhamento for "left", obtenha o número x deste offset pair usando o string e o caixa (fast - left).
Se o alinhamento for "right", obtenha o número x deste offset pair usando o string e o caixa (fast - right).
Se o alinhamento for "center", obtenha o número x deste offset pair usando o string e o caixa (fast - center).
Call "gdi32.dll" "GetTextMetricsA" with o memory canvas e um textmetric's whereabouts.
Adicione a altura desta caixa menos a tmheight deste textmetric dividido por 2 para o número y deste offset pair.

Etapas necessárias para que se obtenha um outlinetextmetric usando um font:
Crie o hfont of o memory canvas usando o font.
Call "gdi32.dll" "GetOutlineTextMetricsA" with o memory canvas e 0 e 0 returning um result número.
Assign um poutlinetextmetric usando o result.
Call "gdi32.dll" "GetOutlineTextMetricsA" with o memory canvas e o result e o poutlinetextmetric.
Atribua o target deste poutlinetextmetric ao outlinetextmetric.
Destroy o hfont of o quadro atual.
Unassign o poutlinetextmetric.

Etapas necessárias para que se obtenha uma position usando um spot e um text:
Se o text for inexistente, limpe o position; exit.
Obtenha um row usando o spot e o text.
Atribua o número da linha desta row ao número da linha desta position.
Obtenha o column# desta position usando a row e o spot e o text.

Etapas necessárias para que se obtenha um rgb endereço de memória from um bitmapdata at um número da linha e um column#:
\ 1 based
Atribua o scan0 deste bitmapdata ao rgb endereço de memória.
Adicione o número da linha menos 1 times o stride deste bitmapdata para o rgb endereço de memória.
Adicione o column# menos 1 times um rgb's magnitude para o rgb endereço de memória.

Etapas necessárias para que se obtenha um rise e um run usando um heading: \deslocamento horizontal e vertical?
\ see Madhava Numbers https://en.wikipedia.org/wiki/Madhava%27s_sine_table 
Isole o heading.
Normalize o heading.
Normalize o original heading.
Se o heading não for evenly divisible por 20, estimate o rise e o run usando o heading; exit.
\ special cases
Se o heading for 0, atribua -10000 no rise; atribua -0 no run; exit. \ 0 degrees
Se o heading for 960, atribua 10000 no run; atribua -0 no rise; exit. \ 90 degrees
Se o heading for 1920, atribua 10000 no rise; atribua 0 no run; exit. \ 180 degrees
Se o heading for 2880, atribua -10000 no run; atribua 0 no rise; exit. \ 270 degrees
Se o heading for 3840, debug "invalid heading"; debug o heading; debug o original heading.
\ force it ao first eighth of o circle
Obtenha o first-eighth equivalent of o heading.
\ encontre o first eighth of o circle unsigned values
Se o heading for 20, atribua 0327 no run; atribua 9995 no rise; break. \ 1.875 degrees
Se o heading for 40, atribua 0654 no run; atribua 9979 no rise; break. \ 3.75 degrees
Se o heading for 60, atribua 0980 no run; atribua 9952 no rise; break. \ 5.625 degrees = 1/64 of o way
Se o heading for 80, atribua 1305 no run; atribua 9914 no rise; break. \7.5 degrees
Se o heading for 100, atribua 1629 no run; atribua 9866 no rise; break. \ 9.375 degrees
Se o heading for 120, atribua 1951 no run; atribua 9808 no rise; break. \ 11.25 degrees = 2/64 of o way
Se o heading for 140, atribua 2271 no run; atribua 9739 no rise; break. \ 13.125 degrees
Se o heading for 160, atribua 2588 no run; atribua 9659 no rise; break. \ 15 degrees
Se o heading for 180, atribua 2903 no run; atribua 9569 no rise; break. \ 16.875 degrees = 3/64 of o way
Se o heading for 200, atribua 3214 no run; atribua 9469 no rise; break. \ 18.75 degrees
Se o heading for 220, atribua 3523 no run; atribua 9359 no rise; break. \ 20.625 degrees
Se o heading for 240, atribua 3827 no run; atribua 9239 no rise; break. \ 22.5 degrees = 4/64 of o way
Se o heading for 260, atribua 4127 no run; atribua 9109 no rise; break. \ 24.375 degrees
Se o heading for 280, atribua 4423 no run; atribua 8969 no rise; break. \ 26.25 degrees
Se o heading for 300, atribua 4714 no run; atribua 8819 no rise; break. \ 28.125 degrees = 5/64 of o way
Se o heading for 320, atribua 5000 no run; atribua 8660 no rise; break. \ 30 degrees
Se o heading for 340, atribua 5281 no run; atribua 8492 no rise; break. \ 31.875 degrees
Se o heading for 360, atribua 5556 no run; atribua 8315 no rise; break. \ 33.75 degrees = 6/64 of o way
Se o heading for 380, atribua 5825 no run; atribua 8128 no rise; break. \ 35.625 degrees
Se o heading for 400, atribua 6088 no run; atribua 7934 no rise; break. \ 37.5 degrees
Se o heading for 420, atribua 6344 no run; atribua 7730 no rise; break. \ 39.375 degrees = 7/64 of o way
Se o heading for 440, atribua 6593 no run; atribua 7518 no rise; break. \ 41.25 degrees
Se o heading for 460, atribua 6836 no run; atribua 7299 no rise; break. \ 43.125 degrees
Se o heading for 480, atribua 7071 no run; atribua 7071 no rise; break. \ 45 degrees = 8/64 of o way
Repita. \ not really um repeat, just um label pelo above breaks.
\ ajuste por segunda eighths of o circle
Se o original heading estiver entre 0 e 480, negate o rise; exit. \ 1st eighth (12:00 para 1:30)
Se o original heading estiver entre 480 e 960, swap o run with o rise; negate o rise; exit. \ 2nd eighth (1:30 para 3:00)
Se o original heading estiver entre 960 e 1440, swap o run with o rise; exit. \ 3rd eighth (3:00 para 4:30)
Se o original heading estiver entre 1440 e 1920, cancele. \ 4th eighth (4:30 para 6:00)
Se o original heading estiver entre 1920 e 2400, negate o run; exit. \ 5th eighth (6:00 para 7:30)
Se o original heading estiver entre 2400 e 2880, swap o run with o rise; negate o run; exit. \ 6th eighth (7:30 para 9:00)
Se o original heading estiver entre 2880 e 3360, swap o run with o rise; negate o run; negate o rise; exit. \ 7th eighth (9:00 para 10:30)
Se o original heading estiver entre 3360 e 3840, negate o run; negate o rise; exit. \ 8th eighth (10:30 para 12:00)

Etapas necessárias para que se obtenha um row usando um número da linha e um text:
Esvazie a row.
Se o text for inexistente, cancele.
Percorra.
Obtenha a row from as rows deste text.
Se a row for inexistente, cancele.
Se o número da linha desta row for o número da linha, cancele.
Repita.

Etapas necessárias para que se obtenha um row usando um spot e um text:
Se o text for inexistente, esvazie a row; exit.
Atribua a coordenada y deste spot A um coordenada y.
Limite o coordenada y para o topo deste text e a base deste text.
Atribua o coordenada y menos a coordenada y desta globalized origin deste text dividido pela row altura deste text mais 1 A um número da linha.
Limite o número da linha para 1 e a row contagem deste text.
Obtenha a row usando o número da linha e o text.

Etapas necessárias para que se obtenha um selection caixa usando um row e um text:
Limpe o selection caixa.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Obtenha um caixa usando a row e o text.
Atribua o caixa ao selection caixa.
Obtenha o selection caixa usando a row e o text (left side).
Obtenha o selection caixa usando a row e o text (right side).

Etapas necessárias para que se obtenha um selection caixa usando um row e um text (left side):
Atribua a normalized selection deste text A um selection.
Atribua a coordenada x desta globalized origin deste text ao left desta selection caixa.
Se o anchor número da linha desta selection for o número da linha desta row, obtenha um spot usando o anchor desta selection e o text; atribua a coordenada x deste spot ao left desta selection caixa.
Limite o left desta selection caixa para o left deste text e o right deste text.

Etapas necessárias para que se obtenha um selection caixa usando um row e um text (right side):
Atribua a normalized selection deste text A um selection.
Atribua o right deste text ao right desta selection caixa.
Se o caret número da linha desta selection for o número da linha desta row, obtenha um spot usando o caret desta selection e o text; atribua a coordenada x deste spot ao right desta selection caixa.
Limite o right desta selection caixa para o left deste text e o right deste text.

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos:
Se o endereço completo for endereço da pasta-format, obtenha o size usando o endereço completo no sistema de arquivos (pasta)[endereço].
Se o endereço completo for file-format, obtenha o size usando o endereço completo no sistema de arquivos (file).

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos (pasta)[endereço]:
Atribua 0 ao size.
Percorra.
Obtenha um item from o endereço completo.
Se o item não for found, cancele.
Se a categoria deste item for "file", adicione o size deste item para o size; repita.
Atribua o endereço completo A uma segunda endereço completo.
Posponha o designador deste item para o segunda endereço completo.
Obtenha uma segunda size usando o segunda endereço completo no sistema de arquivos.
Adicione o segunda size para o size.
Repita.

Etapas necessárias para que se obtenha um size usando um endereço completo no sistema de arquivos (file):
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "GetFileAttributesExA" with o first deste endereço completo e 0 e um win32finddata's whereabouts.
Atribua o nfilesizelow deste win32finddata ao size.

Etapas necessárias para que se obtenha um sockaddr usando um host string:
Limpe o i/o erro.
\ prepare strings
Isole o host string.
Null terminate o host string.
\ obtenha o function addresses
Obtenha alguns addrinfo routines.
Se o i/o erro não estiver em branco, cancele.
\ obtenha o sockaddr
Atribua 2 [af_inet] A um addrinfo's ai_family.
Atribua 1 [sock_stream] ao ai_sockettype deste addrinfo.
Atribua 6 [ipproto_tcp] ao ai_protocol deste addrinfo.
Call o getaddrinfo destas addrinfo routines with o first deste host string e 0 e o whereabouts deste addrinfo e um addrinfoptr's whereabouts returning um result número.
Se o result número não for 0, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host):: " then o host then "." ao i/o erro; exit.
Se o addrinfoptr for inexistente, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host):: " then o host then "." ao i/o erro; exit.
Atribua o target deste ai_addr deste addrinfoptr ao sockaddr.
Call o freeaddrinfo destas addrinfo routines with o addrinfoptr.

Etapas necessárias para que se obtenha um spot usando uma position e um text:
Limpe o spot.
Se o text for inexistente, cancele.
Obtenha um row usando o número da linha desta position e o text.
Obtenha um caixa usando a row e o text.
Atribua o topo desta caixa à coordenada y deste spot.
Atribua o first deste string desta row A um subtexto's first.
Atribua o first deste subtexto mais o column# desta position menos 2 ao last deste subtexto.
Obtenha um width usando o subtexto e o memory canvas e o font deste text.
Atribua o left desta caixa mais o width à coordenada x deste spot.
Obtenha um offset pair usando o working string desta row e o caixa e a font deste text e o alinhamento deste text.
Adicione o número x deste offset pair para a coordenada x deste spot.

Etapas necessárias para que se obtenha um start width e um subtexto usando um row e um spot e um text (for "get um column# usando um row..."):
Limpe o start width.
Limpe o subtexto.
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Obtenha um caixa usando a row e o text.
Lance o subtexto sobre o working string desta row.
Obtenha um offset pair usando o subtexto e o caixa e a font deste text e o alinhamento deste text (fast).
Atribua a coordenada x desta globalized origin deste text mais o número x deste offset pair ao start width.
Atribua o first deste subtexto mais o text cutoff menos 1 ao last deste subtexto.
Percorra.
Se o last deste subtexto for maior do que ou igual ao last deste string desta row, pare.
Obtenha um width usando o subtexto e o memory canvas.
Atribua o start width mais o width A uma segunda width.
Se a coordenada x deste spot for menor do que ou igual ao segunda width, pare.
Adicione o width para o start width.
Mova o subtexto usando o text cutoff.
Repita.
Atribua o first deste subtexto ao last deste subtexto.

Etapas necessárias para que se obtenha um string from o stack:
Limpe o string.
Obtenha um stack entry from o stack.
Se o stack entry for inexistente, atribua "ERROR" ao string; exit.
Atribua o string desta stack entry para o string.
Remove o stack entry from o stack.
Destroy o stack entry.

Etapas necessárias para que se obtenha um string from o windows clipboard:
Limpe o string.
Call "user32.dll" "OpenClipboard" with o main window.
Call "user32.dll" "GetClipboardData" with 1 [cf_text] returning um handle.
Se o handle for 0, call "user32.dll" "CloseClipboard"; exit.
Call "kernel32.dll" "GlobalLock" with o handle returning um pchar.
Convert o pchar para o string.
Call "kernel32.dll" "GlobalUnlock" with o handle.
Call "user32.dll" "CloseClipboard".

Etapas necessárias para que se obtenha uma coisa from algumas coisas:
Se o coisas estiverem vazio, esvazie a coisa; exit.
Se a coisa for inexistente, atribua o first destas coisas à coisa; exit.
Atribua o next desta coisa à coisa.

Etapas necessárias para que se obtenha uma coisa from algumas coisas (backwards):
Se o coisas estiverem vazio, esvazie a coisa; exit.
Se a coisa for inexistente, atribua o last destas coisas à coisa; exit.
Atribua o previous desta coisa à coisa.

Etapas necessárias para que se obtenha um token from um reply:
Remove any leading noise from o reply.
Limpe o token.
Percorra.
Se o reply estiver em branco, cancele.
Obtenha um pedaço from o reply.
Se o pedaço for o caractere de espaço, cancele.
Posponha o pedaço para o token.
Repita.

Etapas necessárias para que se obtenha um width usando um pedaço e um canvas:
Call "gdi32.dll" "GetTextExtentPoint32A" with o canvas e o whereabouts deste pedaço e 1 e um pair's whereabouts.
Atribua o número x deste pair ao width.

Etapas necessárias para que se obtenha um width usando um pedaço e alguns font widths:
Atribua o pedaço A um número.
Obtenha o width usando o número e o font widths.

Etapas necessárias para que se obtenha um width usando um número e alguns font widths:
\ indexes são 0 based
Se o font widths são nil, limpe o width; exit.
Atribua o data destes font widths A um número endereço de memória.
Adicione o número times a magnitude deste número para o número endereço de memória.
Atribua o target deste número endereço de memória ao width.

Etapas necessárias para que se obtenha um width usando um string e um canvas:
\ assumes font é already selecionado em canvas
Call "gdi32.dll" "GetTextExtentPoint32A" with o canvas e o first deste string e o length deste string e um pair's whereabouts.
Atribua o número x deste pair ao width.

Etapas necessárias para que se obtenha um width usando um string e um canvas e um font:
Crie o hfont of o canvas usando o font.
Obtenha o width usando o string e o canvas.
Destroy o hfont of o canvas.

Etapas necessárias para que se obtenha um width usando um string e um font:
\ assumes memory canvas
Obtenha o width usando o string e o memory canvas e o font.

Etapas necessárias para que se obtenha um coordenada x usando um string e um caixa (fast - center):
Obtenha um width usando o string e o memory canvas.
Obtenha um abca e um abcc usando o string e o memory canvas.
Atribua o width menos o abca menos o abcc ao width.
Atribua a width desta caixa menos o width dividido por 2 menos o abca ao coordenada x.

Etapas necessárias para que se obtenha um coordenada x usando um string e um caixa (fast - left):
Obtenha um abca usando o string e o memory canvas.
Atribua - o abca ao coordenada x.

Etapas necessárias para que se obtenha um coordenada x usando um string e um caixa (fast - right):
Obtenha um abca e um abcc usando o string e o memory canvas.
Obtenha um width usando o string e o memory canvas.
Atribua o width menos o abca menos o abcc ao width.
Atribua a width desta caixa menos o width menos o abca ao coordenada x.

Um gigabyte é 1024 megabytes.

Etapas necessárias para que se globalize um caixa usando um pair:
Mova o caixa usando o pair.

Etapas necessárias para que se globalize um spot usando um pair:
Mova o spot usando o pair.

Etapas necessárias para que se go back para where we were:
Restore o context.

O gold cor é uma cor.

O gold pincel é um pincel.

Um gpbitmap é um gpimage.

Um gpgraphic é um endereço de memória.

Um gpimage é um endereço de memória.

An gpimageattributes é um endereço de memória.

Um gprect é um conjunto with
Um número called x,
Um número called y,
Um número called width,
Um número called altura.

O gptoken é um gptoken.

Um gptoken é um número.

An grain é 10 milliseconds.

O cor cinza é uma cor.

O gray pincel é um pincel.

O grayscale cor matrix é um texto hexadecimal igual a $8716993E8716993E8716993E0000000000000000A245163FA245163FA245163F0000000000000000D578E93DD578E93DD578E93D00000000000000000000000000000000000000000000803F00000000000000000000000000000000000000000000803F.

O símbolo maior do que é um pedaço igual a 62.

O green cor é uma cor.

O green pincel é um pincel.

Um cor esverdeada é uma cor.

Um grid é um pair.

O group-separator pedaço é um pedaço igual a 29.

Etapas necessárias para que se garanta one row em um text:
Se o text for inexistente, cancele.
Se as rows deste text não estiverem vazio, cancele.
Crie um row usando o return pedaço.
Posponha a row para as rows deste text.
Renumber as rows deste text.

Um guid é um uuid.

O tecla H/h é uma tecla igual a 72.

O hand cursor é um cursor.

Etapas necessárias para que se gerencie align usando um text e um alinhamento:
Se o text for inexistente, cancele.
Relembre o text with "alinhamento".
Align o text usando o alinhamento.

Etapas necessárias para que se gerencie any wm-activate with um w-param:
Split o w-param A um wyrd e uma segunda wyrd.
Atribua o segunda wyrd A um número.
Se o número for 0, gerencie any wm-activate with o w-param (deactivate); exit.
Gerencie any wm-activate with o w-param (activate).

Etapas necessárias para que se gerencie any wm-activate with um w-param (activate):
Call "user32.dll" "SetFocus" with o main window.
Call "user32.dll" "ClipCursor" with 0.
\ seterrormode(sem_failcriticalerrors) \ keeps certain disk erros from appearing
Crie um event.
Atribua "activate" à categoria deste event.
\Atribua "activar" à categoria deste event.
Enque o event.
Call "user32.dll" "PostMessageA" with o main window e 0 [wm_null] e 0 e 0.

Etapas necessárias para que se gerencie any wm-activate with um w-param (deactivate):
Crie um event.
Atribua "deactivate" à categoria deste event.
\Atribua "desactivar" ao categoria deste event.
Enque o event.
Call "user32.dll" "PostMessageA" with o main window e 0 [wn_null] e 0 e 0.

Etapas necessárias para que se gerencie any wm-char with um w-param e um l-param:
\Se a tecla Alt was down, cancele. \ removed por Spanish teclaboard AltGr e ctrl+alt characters
\Se a tecla Ctrl was down, cancele. \ removed por Spanish teclaboard AltGr e ctrl+alt characters
Atribua o w-param A um pedaço.
Se o pedaço não for printable, cancele.
Crie um event.
Atribua "pressionamento de tecla" à categoria deste event.
\Atribua "tecla abajo" ao categoria deste event.
Se a tecla shift was down, acione o shift alarme deste event.
Atribua o pedaço ao pedaço deste event.
Convert o l-param para a tecla deste event.
Enque o event.

Etapas necessárias para que se gerencie any wm-create with um window:
Atribua o window ao main window.

Etapas necessárias para que se gerencie any wm-destroy:
Call "user32.dll" "PostQuitMessage" with 0.

Etapas necessárias para que se gerencie any wm-lbuttondblclk with um l-param:
Crie um event.
Atribua "clique duplo" à categoria deste event.
\Atribua "clic izquierdo doble" ao categoria deste event.
Se a tecla Alt was down, acione o alt alarme deste event.
Se a tecla Ctrl was down, acione o ctrl alarme deste event.
Se a tecla shift was down, acione o shift alarme deste event.
Convert o l-param para o spot deste event.
Enque o event.

Etapas necessárias para que se gerencie any wm-lbuttondown with um l-param:
Crie um event.
Atribua "clique" à categoria deste event.
\Atribua "clic izquierdo" ao categoria deste event.
Se a tecla Alt was down, acione o alt alarme deste event.
Se a tecla Ctrl was down, acione o ctrl alarme deste event.
Se a tecla shift was down, acione o shift alarme deste event.
Convert o l-param para o spot deste event.
Enque o event.

Etapas necessárias para que se gerencie any wm-paint with um window:
Call "user32.dll" "BeginPaint" with o window e um paintstruct's whereabouts.
Call "user32.dll" "EndPaint" with o window e o whereabouts desta paintstruct.
Crie um event.
Atribua "atualização de tela" à categoria deste event.
\Atribua "refrescar" ao categoria deste event.
Enque o event.

Etapas necessárias para que se gerencie any wm-rbuttondblclk with um l-param:
Crie um event.
Atribua "right double click" à categoria deste event.
\Atribua "clic derecho doble" ao categoria deste event.
Se a tecla Alt was down, acione o alt alarme deste event.
Se a tecla Ctrl was down, acione o ctrl alarme deste event.
Se a tecla shift was down, acione o shift alarme deste event.
Convert o l-param para o spot deste event.
Enque o event.

Etapas necessárias para que se gerencie any wm-rbuttondown with um l-param:
Crie um event.
Atribua "clique direito" à categoria deste event.
\Atribua "clic derecho" ao categoria deste event.
Se a tecla Alt was down, acione o alt alarme deste event.
Se a tecla Ctrl was down, acione o ctrl alarme deste event.
Se a tecla shift was down, acione o shift alarme deste event.
Convert o l-param para o spot deste event.
Enque o event.

Etapas necessárias para que se gerencie any wm-setcursor:
Atualize o cursor.

Etapas necessárias para que se gerencie any wm-syskeydown with um w-param e um l-param;
Etapas necessárias para que se gerencie any wtecla M/mdown with um w-param e um l-param:
Atribua o w-param A um tecla.
Se a tecla with o l-param é any repeated escape ou modifier tecla, cancele.
Se a tecla for any wm-char tecla, cancele.
Crie um event.
Atribua "pressionamento de tecla" à categoria deste event.
\Atribua "tecla abajo" ao categoria deste event.
Se a tecla Alt was down, acione o alt alarme deste event.
Se a tecla Ctrl was down, acione o ctrl alarme deste event.
Se a tecla shift was down, acione o shift alarme deste event.
Atribua a tecla à tecla deste event.
Enque o event.

Etapas necessárias para que se gerencie capitalize usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Relembre o text with "capitalize".
Capitalize any selecionado rows no text.
Square up any selection no text.
Wrap o text.

Etapas necessárias para que se gerencie copy usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Extract um string from o text (selecionado pedaços).
Atribua o string sobre o windows clipboard.

Etapas necessárias para que se gerencie cut usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Relembre o text.
Extract um string from o text (selecionado pedaços).
Atribua o string sobre o windows clipboard.
Remove any selecionado pedaços no text.
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um console:
Se o console for inexistente, cancele.
Se a categoria deste event for "pressionamento de tecla", gerencie o event usando o console (pressionamento de tecla); exit.
Se a categoria deste event for "atualização de tela", gerencie o event usando o console (atualização de tela); exit.
Se a categoria deste event for "clique direito", gerencie o event usando o console (clique direito); exit.
Se a categoria deste event for "mostrar seta", gerencie o event usando o console (mostrar seta); exit.

Etapas necessárias para que se gerencie um event usando um console (tecla backspace):
Se o reply deste console estiver em branco, cancele.
Se o event foi modified, cancele.
Gerencie o event usando o text deste console (tecla backspace).
Remove o last pedaço from o reply deste console.
Mostre o console.

Etapas necessárias para que se gerencie um event usando um console (seta pra baixo):
Role o text deste console down one line.
Mostre o console.

Etapas necessárias para que se gerencie um event usando um console (tecla End):
Role o text deste console para o base.
Mostre o console.

Etapas necessárias para que se gerencie um event usando um console (tecla Enter):
Gerencie o event usando o text deste console (tecla Enter).
Relinquish control.

Etapas necessárias para que se gerencie um event usando um console (tecla Home):
Role o text deste console para o topo.
Mostre o console.

Etapas necessárias para que se gerencie um event usando um console (pressionamento de tecla):
Se a tecla deste event for a tecla backspace, gerencie o event usando o console (tecla backspace); exit.
Se a tecla deste event for a seta pra baixo, gerencie o event usando o console (seta pra baixo); exit.
Se a tecla deste event for a tecla End, gerencie o event usando o console (tecla End); exit.
Se a tecla deste event for a tecla Enter, gerencie o event usando o console (tecla Enter); exit.
Se a tecla deste event for a tecla Home, gerencie o event usando o console (tecla Home); exit.
Se a tecla deste event for a tecla PgDn, gerencie o event usando o console (page-down tecla); exit.
Se a tecla deste event for a tecla PgUp, gerencie o event usando o console (page-up tecla); exit.
Se a tecla deste event for a seta pra cima, gerencie o event usando o console (seta pra cima); exit.
Se o pedaço deste event não for printable, cancele.
Posponha o pedaço deste event para o reply deste console.
Gerencie o event usando o text deste console (printable tecla).
Mostre o console.

Etapas necessárias para que se gerencie um event usando um console (page-down tecla):
Role o text deste console down one página.
Mostre o console.

Etapas necessárias para que se gerencie um event usando um console (page-up tecla):
Role o text deste console up one página.
Mostre o console.

Etapas necessárias para que se gerencie um event usando um console (atualização de tela):
Mostre o console.

Etapas necessárias para que se gerencie um event usando um console (clique direito):
Mostre o hand cursor.
Role o console usando o event.
Atualize o cursor.

Etapas necessárias para que se gerencie um event usando um console (mostrar seta):
Mostre a seta do mouse.

Etapas necessárias para que se gerencie um event usando um console (seta pra cima):
Role o text deste console up one line.
Mostre o console.

Etapas necessárias para que se gerencie um event usando um terminal:
Se o terminal for inexistente, cancele.
Se a categoria deste event for "pressionamento de tecla", gerencie o event usando o terminal (pressionamento de tecla); exit.
Se a categoria deste event for "atualização de tela", gerencie o event usando o terminal (atualização de tela); exit.
Se a categoria deste event for "mostrar seta", gerencie o event usando o terminal (mostrar seta); exit.
Se a categoria deste event for "clique", relinquish control. \ *** added por invisible turtle book questionable

Etapas necessárias para que se gerencie um event usando um terminal (tecla backspace):
Se o reply deste terminal estiver em branco, cancele.
Se o event foi modified, cancele.
Remove o last pedaço from o reply deste terminal.
Remove o last pedaço from o string deste last deste quora deste terminal.
Mostre o terminal.

Etapas necessárias para que se gerencie um event usando um terminal (tecla Enter):
Relinquish control. \Abdique

Etapas necessárias para que se gerencie um event usando um terminal (pressionamento de tecla):
Se a tecla deste event for a tecla backspace, gerencie o event usando o terminal (tecla backspace); exit.
Se a tecla deste event for a tecla Enter, gerencie o event usando o terminal (tecla Enter); exit.
Se o pedaço deste event não for printable, cancele.
Posponha o pedaço deste event para o reply deste terminal.
Posponha o pedaço deste event para o string deste last deste quora deste terminal.
Mostre o terminal.

Etapas necessárias para que se gerencie um event usando um terminal (atualização de tela):
Mostre o terminal.

Etapas necessárias para que se gerencie um event usando um terminal (mostrar seta):
Mostre a seta do mouse.

Etapas necessárias para que se gerencie um event usando um text (tecla backspace):
Se o text for inexistente, cancele.
Se não existir something para backspace no text, cancele.
Relembre o text with "backspace".
Se o event é modified, remove pedaços from o text (backspace with jump).
Se o event não for modified, remove pedaços from o text (backspace).
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (tecla Delete):
Se o text for inexistente, cancele.
Se não existir something para remove no text, cancele.
Relembre o text with "delete".
Se o event é modified, remove pedaços from o text (forward delete with jump).
Se o event não for modified, remove pedaços from o text (forward delete).
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (seta pra baixo):
Se o text for inexistente, cancele.
Se o caret of o text é sobre o last line, acione um alarme.
Se o alarme estiver ativo, mova o caret para o last pedaço of o text.
Se o alarme não estiver ativo, mova o caret down no text.
Se o shift alarme deste event não estiver ativo, deselect o text.
Limpe a last operation deste text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (tecla End):
Se o text for inexistente, cancele.
Se o event é modified, mova o caret para o last pedaço of o text.
Se o event não for modified, mova o caret para o last pedaço of o current row of o text.
Se o shift alarme deste event não estiver ativo, deselect o text.
Limpe a last operation deste text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (tecla Enter):
Se o text for inexistente, cancele.
Relembre o text with "insert return".
Remove any selecionado pedaços no text.
Insira o return pedaço ao text.
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (tecla Esc):
Se o text for inexistente, cancele.
Deselect o text.

Etapas necessárias para que se gerencie um event usando um text (tecla Home):
Se o text for inexistente, cancele.
Se o event é modified, mova o caret para o first pedaço of o text.
Se o event não for modified, mova o caret para o first pedaço of o current row of o text.
Se o shift alarme deste event não estiver ativo, deselect o text.
Limpe a last operation deste text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (clique duplo):
Se o text for inexistente, cancele.
Deselect o text.
Mova o caret right para any non-alphanumeric pedaço no text.
Mova o anchor left para any non-alphanumeric pedaço no text.

Etapas necessárias para que se gerencie um event usando um text (left-arrow tecla):
Se o text for inexistente, cancele.
Se o event é modified, jump o caret left no text.
Se o event não for modified, mova o caret left no text.
Se o shift alarme deste event não estiver ativo, deselect o text.
Limpe a last operation deste text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (page-down tecla):
Se o text for inexistente, cancele.
Role o text down one página.
Mova o caret down one página no text.
Se o shift alarme deste event não estiver ativo, deselect o text.
Limpe a last operation deste text.

Etapas necessárias para que se gerencie um event usando um text (page-up tecla):
Se o text for inexistente, cancele.
Role o text up one página.
Mova o caret up one página no text.
Se o shift alarme deste event não estiver ativo, deselect o text.
Limpe a last operation deste text.

Etapas necessárias para que se gerencie um event usando um text (printable tecla):
Relembre o text with "insert".
Remove any selecionado pedaços no text.
Insira o pedaço deste event ao text.
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (right-arrow tecla):
Se o text for inexistente, cancele.
Se o event é modified, jump o caret right no text.
Se o event não for modified, mova o caret right no text.
Se o shift alarme deste event não estiver ativo, deselect o text.
Limpe a last operation deste text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (tecla tab):
Se o text for inexistente, cancele.
Relembre o text with "insert".
Remove any selecionado pedaços no text.
Insira o caractere de espaço ao text.
Divida o caret column# deste text por 2 giving um quotient e um resto.
Se o resto for 0, insira o caractere de espaço ao text.
Role o text para o caret.

Etapas necessárias para que se gerencie um event usando um text (seta pra cima):
Se o text for inexistente, cancele.
Mova o caret up no text.
Se o shift alarme deste event não estiver ativo, deselect o text.
Limpe a last operation deste text.
Role o text para o caret.

Etapas necessárias para que se gerencie events usando um console:
Se o console for inexistente, cancele.
Percorra.
Deque um event.
Se o event for inexistente, cancele.
Gerencie o event usando o console.
Repita.

Etapas necessárias para que se gerencie events usando um terminal:
Se o terminal for inexistente, cancele.
Percorra.
Deque um event.
Se o event for inexistente, cancele.
Gerencie o event usando o terminal.
Repita.

Etapas necessárias para que se gerencie font altura usando um text e um caixa e uma font altura:
Se o text for inexistente, cancele.
Relembre o text with "font altura".
Mude o text usando o caixa.
Mude o text usando o font altura.

Etapas necessárias para que se gerencie font altura usando um text e uma font altura:
Se o text for inexistente, cancele.
Relembre o text with "font altura".
Mude o text usando o font altura.

Etapas necessárias para que se gerencie font name usando um text e uma font name:
Se o text for inexistente, cancele.
Relembre o text with "font name".
Mude o text usando o font name.

Etapas necessárias para que se gerencie indent usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Relembre o text with "dent".
Indent any selecionado rows no text.
Square up any selection no text.
Wrap o text.

Um handle é um número.

Etapas necessárias para que se gerencie lowercase usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Relembre o text with "case".
Lowercase any selecionado pedaços no text.
Wrap o text.

Etapas necessárias para que se gerencie outdent usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Relembre o text with "dent".
Outdent any selecionado rows no text.
Square up any selection no text.
Wrap o text.

Etapas necessárias para que se gerencie paste usando um text:
Se o text for inexistente, cancele.
Se não existir text sobre o windows clipboard, cancele.
Relembre o text.
Remove any selecionado pedaços no text.
Obtenha um string from o windows clipboard.
Insira o string ao text.
Wrap o text.
Role o text para o caret.

Etapas necessárias para que se gerencie pincel usando um text e um cor:
Se o text for inexistente, cancele.
Relembre o text with "pincel".
Atribua a cor ao pincel deste text.

Etapas necessárias para que se gerencie redo usando um text:
Se o text for inexistente, cancele.
Se o last destes redos deste text for inexistente, cancele.
Copy o text A uma segunda text.
Posponha o segunda text para os undos deste text.
Atribua o last destes redos deste text A um terceiro text.
Remove o terceiro text from os redos deste text.
Copy o guts of o terceiro text ao text.
Destroy o terceiro text.
Ligue o alarme de alteração deste text.

Etapas necessárias para que se gerencie reverse usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Relembre o text with "reverse".
Reverse any selecionado rows of o text.
Square up any selection no text.
Wrap o text.

Etapas necessárias para que se gerencie select all usando um text:
Se o text for inexistente, cancele.
Selecione cada pedaço no text.

Etapas necessárias para que se gerencie classifique any selecionado rows usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Relembre o text with "classifique selecionado rows".
Classifique any selecionado rows no text.
Square up any selection no text.
Wrap o text.

Etapas necessárias para que se gerencie undo usando um text:
Se o text for inexistente, cancele.
Se o last destes undos deste text for inexistente, cancele.
Copy o text A uma segunda text.
Posponha o segunda text para os redos deste text.
Atribua o last destes undos deste text A um terceiro text.
Remove o terceiro text from os undos deste text.
Copy o guts of o terceiro text ao text.
Destroy o terceiro text.
Ligue o alarme de alteração deste text.

Etapas necessárias para que se gerencie uppercase usando um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Relembre o text with "case".
Uppercase any selecionado pedaços no text.
Wrap o text.

O hash-tag pedaço é um pedaço igual a 163.

O hashtag pedaço é um pedaço igual a 163.

Um hbitmap é um handle.

Um hbrush é um handle.

Um hdc é um handle.

Um heading é alguns points.

O heap contagem é um número.

O heap endereço de memória é um endereço de memória.

Um altura é alguns twips.

Um texto hexadecimal é um string.

Um hfont é um handle.

Um hicon é um handle.

Etapas necessárias para que se hide o cursor:
Call "user32.dll" "ShowCursor" with 0 returning um número.
Se o número for menor do que 0, cancele.
Repita.

O hilite cor é uma cor.

O tecla Home é uma tecla igual a 36.

Um horizontal line é um line.

Um hour é 60 minutes.

Um hpen é um handle.

Um hrgn é um handle.

Um matiz é alguns precise degrees [0 para 3599].

An hundred é 100 units.

O i-beam cursor é um cursor.

O tecla I/i é uma tecla igual a 73.

\the i/o erro é um string.

Um iid é um uuid.

Etapas necessárias para que se imagine um caixa alguns twips por alguns segunda twips;
Etapas necessárias para que se make um caixa alguns twips por alguns segunda twips:
Atribua 0 ao left desta caixa.
Atribua 0 ao topo desta caixa.
Atribua o twips ao right desta caixa.
Atribua o segunda twips à base desta caixa.

Etapas necessárias para que se imagine um caixa alguns twips high por alguns segunda twips wide;
Etapas necessárias para que se make um caixa alguns twips high por alguns segunda twips wide:
Atribua 0 e 0 e o segunda twips e o twips ao caixa.

Etapas necessárias para que se imagine um caixa alguns twips smaller do que uma segunda caixa;
Etapas necessárias para que se make um caixa alguns twips smaller do que uma segunda caixa:
Atribua o segunda caixa ao caixa.
Indent o caixa pelo twips dividido por 2.

Etapas necessárias para que se imagine um caixa alguns twips smaller do que uma segunda caixa sobre cada side:
Atribua o segunda caixa ao caixa.
Indent o caixa pelo twips.

Etapas necessárias para que se imagine um caixa alguns twips wide por alguns segunda twips high;
Etapas necessárias para que se make um caixa alguns twips wide por alguns segunda twips high:
Atribua 0 e 0 e o twips e o segunda twips ao caixa.

Etapas necessárias para que se imagine um caixa with um left coord e um topo coord e um right coord e um base coord;
Etapas necessárias para que se make um caixa with um left coord e um topo coord e um right coord e um base coord:
Atribua o left coord e o topo coord e o right coord e o base coord ao caixa.

Etapas necessárias para que se imagine um caixa with um spot e uma segunda spot;
Etapas necessárias para que se make um caixa with um spot e uma segunda spot:
Atribua o spot e o segunda spot ao caixa.

Etapas necessárias para que se imagine uma cor from um matiz e um saturação e um luminosidade;
Etapas necessárias para que se make uma cor from um matiz e um saturação e um luminosidade:
Atribua o matiz e o saturação e o luminosidade à cor.

Etapas necessárias para que se imagine um dot about alguns twips wide;
Etapas necessárias para que se make um dot about alguns twips wide;
Etapas necessárias para que se make um dot alguns twips wide:
Make o dot o twips pelo twips.

Etapas necessárias para que se imagine um dot between alguns twips e alguns segunda twips wide;
Etapas necessárias para que se make um dot between alguns twips e alguns segunda twips wide:
Escolha aleatoriamente alguns terceiro twips between o twips e o segunda twips.
Make o dot o terceiro twips wide.

Etapas necessárias para que se imagine um elipse usando um caixa;
Etapas necessárias para que se make um elipse usando um caixa:
Atribua o caixa à caixa desta elipse.

Etapas necessárias para que se imagine um elipse alguns twips por alguns segunda twips;
Etapas necessárias para que se make um elipse alguns twips por alguns segunda twips:
Atribua 0 ao left desta elipse.
Atribua 0 ao topo desta elipse.
Atribua o twips intoo right desta elipse.
Atribua o segunda twips à base desta elipse.

Etapas necessárias para que se imagine um elipse with um left coord e um topo coord e um right coord e um base coord;
Etapas necessárias para que se make um elipse with um left coord e um topo coord e um right coord e um base coord:
Atribua o left coord e o topo coord e o right coord e o base coord ao elipse.

Etapas necessárias para que se imagine um elipse with um spot e uma segunda spot;
Etapas necessárias para que se make um elipse with um spot e uma segunda spot:
Atribua o spot e o segunda spot ao elipse.

Etapas necessárias para que se imagine um figura using um string e um spot;
Etapas necessárias para que se make um figura using um string e um spot;
Etapas necessárias para que se crie um figura using um string e um center spot:
Crie o figura.
Posponha o figura para o figuras.
Isole o string.
Lowercase o string.
Lance um subtexto sobre o string.
Percorra.
Skip any leading noise no subtexto.
Se o length deste subtexto for menor do que 2, cancele.
Atribua o target deste first deste subtexto A um pedaço.
Atribua o pedaço menos o little-a pedaço A um spot's y.
Adicione 1 para o first deste subtexto.
Atribua o target deste first deste subtexto ao pedaço.
Atribua o pedaço menos o little-a pedaço ao x deste spot.
Multiplique o spot por 1/4 inch.
Adicione o x deste center spot menos 3-1/8 inches mais 1 pixel para o x deste spot.
Adicione o y deste center spot menos 3-1/8 inches mais 1 pixel para o y deste spot.
Posponha o spot para o figura.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se imagine um horizontal line uma fração of o way up from o base of um caixa;
Etapas necessárias para que se make um horizontal line uma fração of o way up from o base of um caixa:
Imagine o horizontal line across o caixa a fração of o way up from o base.

Etapas necessárias para que se imagine um line across o base of um caixa;
Etapas necessárias para que se make um line across o base of um caixa;
Etapas necessárias para que se imagine um line along o base of um caixa;
Etapas necessárias para que se make um line along o base of um caixa:
Atribua a base desta caixa line ao line.

Etapas necessárias para que se imagine um line across um caixa uma fração of o way up from o base;
Etapas necessárias para que se make um line across um caixa uma fração of o way up from o base:
Atribua o left desta caixa ao x deste start desta line.
Atribua o right desta caixa ao x deste end desta line.
Atribua a base desta caixa times a fração A alguns twips.
Atribua a base desta caixa menos o twips ao y deste start desta line.
Atribua a base desta caixa menos o twips ao y deste end desta line.

Etapas necessárias para que se imagine um line across o topo of um caixa;
Etapas necessárias para que se make um line across o topo of um caixa;
Etapas necessárias para que se imagine um line along o topo of um caixa;
Etapas necessárias para que se make um line along o topo of um caixa:
Atribua o topo desta caixa line ao line.

Etapas necessárias para que se imagine um line no middle of um caixa;
Etapas necessárias para que se make um line no middle of um caixa;
Etapas necessárias para que se imagine um line across o middle of um caixa;
Etapas necessárias para que se make um line across o middle of um caixa;
Etapas necessárias para que se imagine um line no center of um caixa;
Etapas necessárias para que se make um line no center of um caixa;
Etapas necessárias para que se imagine um line across o center of um caixa;
Etapas necessárias para que se make um line across o center of um caixa:
Atribua o left desta caixa ao x deste start desta line.
Atribua o right desta caixa ao x deste end desta line.
Atribua o y deste center desta caixa ao y deste start desta line.
Atribua o y deste center desta caixa ao y deste end desta line.

Etapas necessárias para que se imagine um line alguns twips up from o base of um caixa;
Etapas necessárias para que se make um line alguns twips up from o base of um caixa:
Atribua o left desta caixa ao x deste start desta line.
Atribua o right desta caixa ao x deste end desta line.
Atribua a base desta caixa menos o twips ao y deste start desta line.
Atribua a base desta caixa menos o twips ao y deste end desta line.

Etapas necessárias para que se imagine um line with um spot e uma segunda spot;
Etapas necessárias para que se make um line with um spot e uma segunda spot:
Atribua o spot e o segunda spot ao line.

Etapas necessárias para que se imagine um line with um coordenada x e um coordenada y e uma segunda coordenada x e uma segunda coordenada y;
Etapas necessárias para que se make um line with um coordenada x e um coordenada y e uma segunda coordenada x e uma segunda coordenada y:
Atribua o coordenada x e o coordenada y e o segunda coordenada x e o segunda coordenada y ao line.

Etapas necessárias para que se imagine um caixa arredondada from um caixa e um radius;
Etapas necessárias para que se make um caixa arredondada from um caixa e um radius:
Atribua o caixa e o radius ao caixa arredondada.

Etapas necessárias para que se imagine um caixa arredondada alguns twips por alguns segunda twips;
Etapas necessárias para que se make um caixa arredondada alguns twips por alguns segunda twips with um radius:
Atribua 0 ao left desta caixa arredondada.
Atribua 0 ao topo desta caixa arredondada.
Atribua o twips ao right desta caixa arredondada.
Atribua o segunda twips à base desta caixa arredondada.
Atribua o radius ao radius desta caixa arredondada.

Etapas necessárias para que se imagine um caixa arredondada with um left coord e um topo coord e um right coord e um base coord e um radius;
Etapas necessárias para que se make um caixa arredondada with um left coord e um topo coord e um right coord e um base coord e um radius:
Atribua o left coord e o topo coord e o right coord e o base coord e o radius ao caixa arredondada.

Etapas necessárias para que se imagine um caixa arredondada with um spot e uma segunda spot e um radius;
Etapas necessárias para que se make um caixa arredondada with um spot e uma segunda spot e um radius:
Atribua o spot e o segunda spot e o radius ao caixa arredondada.

Etapas necessárias para que se imagine um spot with um coordenada x e um coordenada y;
Etapas necessárias para que se make um spot with um coordenada x e um coordenada y:
Atribua o coordenada x e o coordenada y ao spot.



Etapas necessárias para que se include uma font no current pdf:
Encontre um pdf object usando o name desta font e o font index deste pdf state.
Se o pdf object não for inexistente, cancele.
Crie uma font info usando o font.
Convert o font info para pdf em units.
\ stream
Atribua o actual data of o font A um trecho.
Convert o trecho para um texto da cifra binária.
Adicione um stream pdf object usando "font stream".
Posponha o número deste stream then " 0 obj" para o stream.
Posponha "<<" para o stream sem advancing.
Posponha "/Filter /ASCIIHexDecode" para o stream sem advancing.
Posponha " /Length " then o length deste texto da cifra binária para o stream sem advancing.
Posponha " /Length1 " then o length deste trecho para o stream sem advancing.
Posponha ">>" para o stream.
Posponha "stream" para o stream.
Posponha o texto da cifra binária para o stream.
Posponha "endstream" para o stream.
Posponha "endobj" para o stream.
\ descriptor
Adicione um descriptor pdf object usando "font descriptor".
Atribua "F" then o número deste descriptor A uma font name.
Atribua o name desta font A uma font base name.
Replace o caractere de espaço with o underscore pedaço no font base name.
Posponha o número deste descriptor then " 0 obj" para o descriptor.
Posponha "<<" para o descriptor.
Posponha "/Type /FontDescriptor" para o descriptor.
Posponha "/FontName /" then o font base name para o descriptor.
Posponha "/FontFile2 " then o número deste stream then " 0 R" para o descriptor.
Posponha "/alarmes " then o flags deste font info para o descriptor.
Posponha "/FontBBox [" then a font caixa desta font info then "]" para o descriptor.
Posponha "/Ascent " then o ascent desta font info para o descriptor.
Posponha "/Descent " then o descent desta font info para o descriptor.
Posponha "/CapHeight " then o capheight desta font info para o descriptor.
Posponha "/ItalicAngle " then o italicangle desta font info para o descriptor.
Posponha "/StemV " then o stemv desta font info para o descriptor.
Posponha ">>" para o descriptor.
Posponha "endobj" para o descriptor.
\ definition
Adicione um definition pdf object usando "font definition".
Atribua o font name ao font name desta definition.
Posponha o número desta definition then " 0 obj" para o definition.
Posponha "<<" para o definition.
Posponha "/Type /Font" para o definition.
Posponha "/Subtype /TrueType" para o definition.
Posponha "/Name /" then o font name para o definition.
Posponha "/BaseFont /" then o font base name para o definition.
Posponha "/Encoding /WinAnsiEncoding" para o definition.
Posponha "/FontDescriptor " then o número deste descriptor then " 0 R" para o definition.
Posponha "/FirstChar 0" para o definition.
Posponha "/LastChar 255" para o definition.
Atribua as font widths desta font info A uma segunda trecho.
Posponha "/Widths [" para o definition.
Posponha o segunda trecho then "]" para o definition.
Posponha ">>" para o definition.
Posponha "endobj" para o definition.
Atribua o font info à font info desta definition.
Catalogue o definition usando o name desta font e o font index deste pdf state.

Etapas necessárias para que se include uma font em um pdf object:
Se o pdf object for inexistente, cancele.
Encontre uma font pdf object usando o name desta font e o font index deste pdf state.
Se o font pdf object for inexistente, cancele.
Atribua "/" then o font name deste font pdf object then " " then o número deste font pdf object then " 0 R" A um string.
Encontre um conjunto de texto usando o string e os font strings deste pdf object.
Se o conjunto de texto não for inexistente, cancele.
Crie um new conjunto de texto usando o string.
Posponha o new conjunto de texto para os font strings deste pdf object.

Etapas necessárias para que se indent any selecionado rows em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Se a row estiver em branco, repita.
Anteponha o caractere de espaço para o string deste row.
Anteponha o caractere de espaço para o string deste row.
Repita.

Um indent é um contagem.

An index é uma coisa with
Um bucket contagem,
Um first bucket e um last bucket.

Etapas necessárias para que se catalogue um endereço de memória usando um string e um index:
\ if o index for inexistente, cancele. \ para make compilador faster
Se o length deste string for 0, cancele.
Obtenha um bucket usando o string e o index.
Crie um refer.
Posponha o refer para os refers deste bucket.
Atribua o string ao string deste refer.
Atribua o endereço de memória ao endereço de memória deste refer.

Etapas necessárias para que se catalogue um string em um index:
\ if o index for inexistente, cancele. \ para make compilador faster
Catalogue nil usando o string e o index.

Etapas necessárias para que se initalize o terminal:
Crie o terminal na caixa desta tela.

Etapas necessárias para que se initialize before run:
Call "user32.dll" "DisableProcessWindowsGhosting".
Call "kernel32.dll" "GetProcessHeap" returning o heap endereço de memória.
Call "kernel32.dll" "LoadLibraryA" with "kernel32.dll"'s first returning um handle.
Se o handle não for 0, call "kernel32.dll" "GetProcAddress" with o handle e "HeapSetInformation"'s first returning um endereço de memória.
Se o endereço de memória não for inexistente, call o endereço de memória with o heap endereço de memória e 0 e 2's whereabouts e 4.

Etapas necessárias para que se initialize o canvases:
Initialize o tela canvas.
Initialize o memory canvas.
Atribua o memory canvas ao quadro atual.

Etapas necessárias para que se initialize o cgi:
Call "kernel32.dll" "AllocConsole".
Call "kernel32.dll" "GetStdHandle" with -10 [std_input_handle] returning o stdin handle.
Call "kernel32.dll" "GetStdHandle" with -11 [std_output_handle] returning o stdout handle.

Etapas necessárias para que se initialize as cors:
\\ Aqui você muda não só o nome, mas as tonalidades das cores
Atribua 1 ao pincel size.
Call "gdi32.dll" "GetStockObject" with 8 [null_pen] returning o null hpen.
Call "gdi32.dll" "GetStockObject" with 5 [null_brush] returning o null hbrush.
Atribua -1 e 0 e 0 ao clear cor.
Atribua 0 e 0 e 1000 ao cor branca.
Atribua 0 e 0 e 875 ao cor cinza claríssimo.
Atribua 0 e 0 e 750 ao cor cinza muito claro.
Atribua 0 e 0 e 625 ao cor cinza claro.
Atribua 0 e 0 e 500 ao cor cinza.
Atribua 0 e 0 e 375 ao cor cinza escuro.
Atribua 0 e 0 e 250 ao cor cinza muito escuro.
Atribua 0 e 0 e 125 ao cor cinza escuríssimo.
Atribua 0 e 0 e 0 à cor preta.
Atribua 0 e 1000 e 875 ao cor vermelho claríssimo.
Atribua 0 e 1000 e 750 ao cor vermelho muito claro.
Atribua 0 e 1000 e 625 ao cor vermelho claro.
Atribua 0 e 1000 e 500 ao cor vermelha.
Atribua 0 e 1000 e 375 ao cor vermelho escuro.
Atribua 0 e 1000 e 250 ao cor vermelho muito escuro.
Atribua 0 e 1000 e 125 ao cor vermelho escuríssimo.
Atribua 300 e 1000 e 875 ao cor laranja claríssimo.
Atribua 300 e 1000 e 750 ao cor laranja muito claro.
Atribua 300 e 1000 e 625 ao cor laranja claro.
Atribua 300 e 1000 e 500 ao cor laranja.
Atribua 300 e 1000 e 375 ao cor laranja escuro.
Atribua 300 e 1000 e 250 ao cor laranja muito escuro.
Atribua 300 e 1000 e 125 ao cor laranja escuríssimo.
Atribua 600 e 1000 e 875 ao cor amarelo claríssimo.
Atribua 600 e 1000 e 750 ao cor amarelo muito claro.
Atribua 600 e 1000 e 625 ao cor amarelo claro.
Atribua 600 e 1000 e 500 ao cor amarela.
Atribua 600 e 1000 e 375 ao cor amarelo escuro.
Atribua 600 e 1000 e 250 ao cor amarelo muito escuro.
Atribua 600 e 1000 e 125 ao cor amarelo escuríssimo.
Atribua 900 e 1000 e 875 ao lightest lime cor.
Atribua 900 e 1000 e 750 ao lighter lime cor.
Atribua 900 e 1000 e 625 ao light lime cor.
Atribua 900 e 1000 e 500 ao lime cor.
Atribua 900 e 1000 e 375 ao dark lime cor.
Atribua 900 e 1000 e 250 ao darker lime cor.
Atribua 900 e 1000 e 125 ao darkest lime cor.
Atribua 1200 e 1000 e 875 ao cor verde claríssimo.
Atribua 1200 e 1000 e 750 ao cor verde muito claro.
Atribua 1200 e 1000 e 625 ao cor verde claro.
Atribua 1200 e 1000 e 500 ao green cor.
Atribua 1200 e 1000 e 375 ao cor verde escuro.
Atribua 1200 e 1000 e 250 ao cor verde muito escuro.
Atribua 1200 e 1000 e 125 ao cor verde escuríssimo.
Atribua 1500 e 1000 e 875 ao lightest teal cor.
Atribua 1500 e 1000 e 750 ao lighter teal cor.
Atribua 1500 e 1000 e 625 ao light teal cor.
Atribua 1500 e 1000 e 500 ao teal cor.
Atribua 1500 e 1000 e 375 ao dark teal cor.
Atribua 1500 e 1000 e 250 ao darker teal cor.
Atribua 1500 e 1000 e 125 ao darkest teal cor.
Atribua 1800 e 1000 e 875 ao lightest ciano cor.
Atribua 1800 e 1000 e 750 ao lighter ciano cor.
Atribua 1800 e 1000 e 625 ao light ciano cor.
Atribua 1800 e 1000 e 500 ao ciano cor.
Atribua 1800 e 1000 e 375 ao dark ciano cor.
Atribua 1800 e 1000 e 250 ao darker ciano cor.
Atribua 1800 e 1000 e 125 ao darkest ciano cor.
Atribua 2100 e 1000 e 875 ao lightest sky cor.
Atribua 2100 e 1000 e 750 ao lighter sky cor.
Atribua 2100 e 1000 e 625 ao light sky cor.
Atribua 2100 e 1000 e 500 ao sky cor.
Atribua 2100 e 1000 e 375 ao dark sky cor.
Atribua 2100 e 1000 e 250 ao darker sky cor.
Atribua 2100 e 1000 e 125 ao darkest sky cor.
Atribua 2400 e 1000 e 875 ao lightest blue cor.
Atribua 2400 e 1000 e 750 ao lighter blue cor.
Atribua 2400 e 1000 e 625 ao light blue cor.
Atribua 2400 e 1000 e 500 ao blue cor.
Atribua 2400 e 1000 e 375 ao dark blue cor.
Atribua 2400 e 1000 e 250 ao darker blue cor.
Atribua 2400 e 1000 e 125 ao darkest blue cor.
Atribua 2700 e 1000 e 875 ao lightest purple cor.
Atribua 2700 e 1000 e 750 ao lighter purple cor.
Atribua 2700 e 1000 e 625 ao light purple cor.
Atribua 2700 e 1000 e 500 ao purple cor.
Atribua 2700 e 1000 e 375 ao dark purple cor.
Atribua 2700 e 1000 e 250 ao darker purple cor.
Atribua 2700 e 1000 e 125 ao darkest purple cor.
Atribua 3000 e 1000 e 875 ao lightest magenta cor.
Atribua 3000 e 1000 e 750 ao lighter magenta cor.
Atribua 3000 e 1000 e 625 ao light magenta cor.
Atribua 3000 e 1000 e 500 ao magenta cor.
Atribua 3000 e 1000 e 375 ao dark magenta cor.
Atribua 3000 e 1000 e 250 ao darker magenta cor.
Atribua 3000 e 1000 e 125 ao darkest magenta cor.
Atribua 3300 e 1000 e 875 ao lightest violet cor.
Atribua 3300 e 1000 e 750 ao lighter violet cor.
Atribua 3300 e 1000 e 625 ao light violet cor.
Atribua 3300 e 1000 e 500 ao violet cor.
Atribua 3300 e 1000 e 375 ao dark violet cor.
Atribua 3300 e 1000 e 250 ao darker violet cor.
Atribua 3300 e 1000 e 125 ao darkest violet cor.
Atribua 0 e 0 e 800 ao hilite cor.
\ special cors
Atribua o cor laranja claríssimo ao tan cor.
Atribua o cor laranja escuro ao brown cor.
Atribua o cor laranja muito escuro ao dark brown cor.
Atribua o cor laranja escuríssimo ao darker brown cor.
Atribua o cor laranja escuríssimo ao darkest brown cor.
Atribua o cor vermelho claríssimo ao pink cor.
Atribua o cor vermelho muito claro ao dark pink cor.
Atribua 500 e 1000 e 500 ao gold cor.
\ cors como pincels
Atribua o clear cor ao clear pincel.
Atribua o cor branca ao white pincel.
Atribua a cor preta ao black pincel.
Atribua o cor cinza claríssimo ao lightest gray pincel.
Atribua o cor cinza muito claro ao lighter gray pincel.
Atribua o cor cinza claro ao light gray pincel.
Atribua o cor cinza ao gray pincel.
Atribua o cor cinza escuro ao dark gray pincel.
Atribua o cor cinza muito escuro ao darker gray pincel.
Atribua o cor cinza escuríssimo ao darkest gray pincel.
Atribua o cor vermelho claríssimo ao lightest red pincel.
Atribua o cor vermelho muito claro ao lighter red pincel.
Atribua o cor vermelho claro ao light red pincel.
Atribua o cor vermelha ao red pincel.
Atribua o cor vermelho escuro ao dark red pincel.
Atribua o cor vermelho muito escuro ao darker red pincel.
Atribua o cor vermelho escuríssimo ao darkest red pincel.
Atribua o cor laranja claríssimo ao lightest orange pincel.
Atribua o cor laranja muito claro ao lighter orange pincel.
Atribua o cor laranja claro ao light orange pincel.
Atribua o cor laranja ao orange pincel.
Atribua o cor laranja escuro ao dark orange pincel.
Atribua o cor laranja muito escuro ao darker orange pincel.
Atribua o cor laranja escuríssimo ao darkest orange pincel.
Atribua o cor amarelo claríssimo ao lightest yellow pincel.
Atribua o cor amarelo muito claro ao lighter yellow pincel.
Atribua o cor amarelo claro ao light yellow pincel.
Atribua o cor amarela ao yellow pincel.
Atribua o cor amarelo escuro ao dark yellow pincel.
Atribua o cor amarelo muito escuro ao darker yellow pincel.
Atribua o cor amarelo escuríssimo ao darkest yellow pincel.
Atribua o lightest lime cor ao lightest lime pincel.
Atribua o lighter lime cor ao lighter lime pincel.
Atribua o light lime cor ao light lime pincel.
Atribua o lime cor ao lime pincel.
Atribua o dark lime cor ao dark lime pincel.
Atribua o darker lime cor ao darker lime pincel.
Atribua o darkest lime cor ao darkest lime pincel.
Atribua o cor verde claríssimo ao lightest green pincel.
Atribua o cor verde muito claro ao lighter green pincel.
Atribua o cor verde claro ao light green pincel.
Atribua o green cor ao green pincel.
Atribua o cor verde escuro ao dark green pincel.
Atribua o cor verde muito escuro ao darker green pincel.
Atribua o cor verde escuríssimo ao darkest green pincel.
Atribua o lightest teal cor ao lightest teal pincel.
Atribua o lighter teal cor ao lighter teal pincel.
Atribua o light teal cor ao light teal pincel.
Atribua o teal cor ao teal pincel.
Atribua o dark teal cor ao dark teal pincel.
Atribua o darker teal cor ao darker teal pincel.
Atribua o darkest teal cor ao darkest teal pincel.
Atribua o lightest ciano cor ao lightest ciano pincel.
Atribua o lighter ciano cor ao lighter ciano pincel.
Atribua o light ciano cor ao light ciano pincel.
Atribua o ciano cor ao ciano pincel.
Atribua o dark ciano cor ao dark ciano pincel.
Atribua o darker ciano cor ao darker ciano pincel.
Atribua o darkest ciano cor ao darkest ciano pincel.
Atribua o lightest sky cor ao lightest sky pincel.
Atribua o lighter sky cor ao lighter sky pincel.
Atribua o light sky cor ao light sky pincel.
Atribua o sky cor ao sky pincel.
Atribua o dark sky cor ao dark sky pincel.
Atribua o darker sky cor ao darker sky pincel.
Atribua o darkest sky cor ao darkest sky pincel.
Atribua o lightest blue cor ao lightest blue pincel.
Atribua o lighter blue cor ao lighter blue pincel.
Atribua o light blue cor ao light blue pincel.
Atribua o blue cor ao blue pincel.
Atribua o dark blue cor ao dark blue pincel.
Atribua o darker blue cor ao darker blue pincel.
Atribua o darkest blue cor ao darkest blue pincel.
Atribua o lightest purple cor ao lightest purple pincel.
Atribua o lighter purple cor ao lighter purple pincel.
Atribua o light purple cor ao light purple pincel.
Atribua o purple cor ao purple pincel.
Atribua o dark purple cor ao dark purple pincel.
Atribua o darker purple cor ao darker purple pincel.
Atribua o darkest purple cor ao darkest purple pincel.
Atribua o lightest magenta cor ao lightest magenta pincel.
Atribua o lighter magenta cor ao lighter magenta pincel.
Atribua o light magenta cor ao light magenta pincel.
Atribua o magenta cor ao magenta pincel.
Atribua o dark magenta cor ao dark magenta pincel.
Atribua o darker magenta cor ao darker magenta pincel.
Atribua o darkest magenta cor ao darkest magenta pincel.
Atribua o lightest violet cor ao lightest violet pincel.
Atribua o lighter violet cor ao lighter violet pincel.
Atribua o light violet cor ao light violet pincel.
Atribua o violet cor ao violet pincel.
Atribua o dark violet cor ao dark violet pincel.
Atribua o darker violet cor ao darker violet pincel.
Atribua o darkest violet cor ao darkest violet pincel.
\ special cor pincels
Atribua o tan cor ao tan pincel.
Atribua o brown cor ao brown pincel.
Atribua o dark brown cor ao dark brown pincel.
Atribua o darker brown cor ao darker brown pincel.
Atribua o darkest brown cor ao darkest brown pincel.
Atribua o pink cor ao pink pincel.
Atribua o dark pink cor ao dark pink pincel.
Atribua a gold cor ao gold pincel.
\ "sky" renamed "sky blue"
Atribua o lightest sky cor ao lightest sky blue cor.
Atribua o lighter sky cor ao lighter sky blue cor.
Atribua o light sky cor ao light sky blue cor.
Atribua o sky cor ao sky blue cor.
Atribua o dark sky cor ao dark sky blue cor.
Atribua o darker sky cor ao darker sky blue cor.
Atribua o darkest sky cor ao darkest sky blue cor.
Atribua o lightest sky cor ao lightest sky blue pincel.
Atribua o lighter sky cor ao lighter sky blue pincel.
Atribua o light sky cor ao light sky blue pincel.
Atribua o sky cor ao sky blue pincel.
Atribua o dark sky cor ao dark sky blue pincel.
Atribua o darker sky cor ao darker sky blue pincel.
Atribua o darkest sky cor ao darkest sky blue pincel.


Etapas necessárias para que se initialize with:
Call "ole32.dll" "CoInitializeEx" with 0 e 2 [coinit_apartmentthreaded].

Etapas necessárias para que se initialize um context:
Allocate memory pelo context.
Atribua o center desta tela ao spot deste context.
Atribua 0 ao heading deste context.
Atribua o green cor à cor deste context.
Atribua o small tamanho da letra à tamanho da letra deste context.
\Atribua 1/60 second ao delay. ***
Seed o random número generator.

Etapas necessárias para que se initialize o cursors:
Initialize o cursors (seta do mouse).
Initialize o cursors (hand cursor).
Initialize o cursors (i-beam cursor).
\Atribua a seta do mouse ao cursor flecha.
\Atribua o hand cursor ao cursor mano.
\Atribua o i-beam cursor ao cursor rayo-i.
Hide o cursor.

Etapas necessárias para que se initialize o cursors (seta do mouse):
Posponha $00000000000000004000000060000000 para um máscara de disjunção exclusiva.
Posponha $70000000780000007C0000007E000000 para o máscara de disjunção exclusiva.
Posponha $7F0000007F8000007C0000006C000000 para o máscara de disjunção exclusiva.
Posponha $46000000060000000300000003000000 para o máscara de disjunção exclusiva.
Posponha $01800000018000000000000000000000 para o máscara de disjunção exclusiva.
Posponha $00 para o máscara de disjunção exclusiva usando 48.
Posponha $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF para um máscara de conjunção lógica.
Posponha $07FFFFFF03FFFFFF01FFFFFF00FFFFFF para o máscara de conjunção lógica.
Posponha $007FFFFF003FFFFF001FFFFF01FFFFFF para o máscara de conjunção lógica.
Posponha $10FFFFFF30FFFFFF787FFFFFF87FFFFF para o máscara de conjunção lógica.
Posponha $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF para o máscara de conjunção lógica.
Posponha $FF para o máscara de conjunção lógica usando 48.
Call "user32.dll" "CreateCursor" with o handle deste module e 0 e 0 e 32 e 32 e o first desta máscara de conjunção lógica e o first desta máscara de disjunção exclusiva returning a seta do mouse.

Etapas necessárias para que se initialize o cursors (hand cursor):
Posponha $000000000180000019B0000019B00000 para um máscara de disjunção exclusiva.
Posponha $0DB200000DB6000007F6000067FE0000 para o máscara de disjunção exclusiva.
Posponha $7FFC00003FFC00001FFC00001FF80000 para o máscara de disjunção exclusiva.
Posponha $0FF8000007F0000003F0000003F00000 para o máscara de disjunção exclusiva.
Posponha $00 para o máscara de disjunção exclusiva usando 64.
Posponha $FE7FFFFFE40FFFFFC007FFFFC005FFFF para um máscara de conjunção lógica.
Posponha $E000FFFFE000FFFF9000FFFF0000FFFF para o máscara de conjunção lógica.
Posponha $0001FFFF8001FFFFC001FFFFC003FFFF para o máscara de conjunção lógica.
Posponha $E003FFFFF007FFFFF807FFFFF807FFFF para o máscara de conjunção lógica.
Posponha $FF para o máscara de conjunção lógica usando 64.
Call "user32.dll" "CreateCursor" with o handle deste module e 2 e 1 e 32 e 32 e o first desta máscara de conjunção lógica e o first desta máscara de disjunção exclusiva returning o hand cursor.

Etapas necessárias para que se initialize o cursors (i-beam cursor):
Posponha $EE000000100000001000000010000000 para um máscara de disjunção exclusiva.
Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
Posponha $100000001000000010000000EE000000 para o máscara de disjunção exclusiva.
Posponha $00 para o máscara de disjunção exclusiva usando 64.
Posponha $FF para um máscara de conjunção lógica usando 128.
Call "user32.dll" "CreateCursor" with o handle deste module e 3 e 7 e 32 e 32 e o first desta máscara de conjunção lógica e o first desta máscara de disjunção exclusiva returning o i-beam cursor.

Etapas necessárias para que se initialize o fonts:
Call "gdi32.dll" "GetStockObject" with 11 [ansi_fixed_font] returning o null hfont.
Call "gdi32.dll" "AddFontMemResourceEx" with o first desta osmosian font source e o length desta osmosian font source e 0 e um número's whereabouts Returning o osmosian font resource.
Atribua "osmosian" e 1/4 inch à default font.
\ stroked fonts below
Atribua 1/8 inch ao small tamanho da letra.
Atribua 1/4 inch ao medium tamanho da letra.
Atribua 1/2 inch ao large tamanho da letra.

Etapas necessárias para que se initialize gdi+:
Atribua 1 A um gdiplusstartupinput's gdiplusversion.
Call "gdiplus.dll" "GdiplusStartup" with o whereabouts deste gptoken e o whereabouts deste gdiplusstartupinput e 0.

Etapas necessárias para que se initialize o memory canvas:
Call "gdi32.dll" "CreateCompatibleDC" with o tela canvas returning o memory canvas.
Call "gdi32.dll" "GetCurrentObject" with o memory canvas e 7 [obj_bitmap] returning o saved memory hbitmap.
Call "gdi32.dll" "CreateCompatibleBitmap" with o tela canvas e a pixel width desta tela e a pixel altura desta tela returning um hbitmap.
Call "gdi32.dll" "SelectObject" with o memory canvas e o hbitmap.
Normalize o memory canvas.

Etapas necessárias para que se initialize o module:
\ temp endereço completo
Atribua 512 A um length.
Reassign o first deste temp endereço completo usando o length.
Call "kernel32.dll" "GetTempPathA" with o length e o first deste temp endereço completo returning o length.
Atribua o first deste temp endereço completo mais o length menos 1 ao last deste temp endereço completo.
Null terminate o temp endereço completo.
\ module handle
Call "kernel32.dll" "GetModuleHandleA" with 0 returning o handle deste module.
\ module name
Atribua 512 ao length.
Reassign o first deste endereço completo deste module usando o length.
Call "kernel32.dll" "GetModuleFileNameA" with o handle deste module e o first deste endereço completo deste module e o length returning o length.
Atribua o first deste endereço completo deste module mais o length menos 1 ao last deste endereço completo deste module.
Se o endereço completo deste module starts with "\\?\", remove leading pedaços from o endereço completo deste module usando 4.
Lowercase o endereço completo deste module.
Null terminate o endereço completo deste module. \ segunda endereço completo pieces deste module
Extract o name deste module from o endereço completo deste module.
Null terminate o name deste module.
Extract o endereço da pasta deste module from o endereço completo deste module.
Null terminate o endereço da pasta deste module.
Extract o root endereço da pasta deste module from o endereço da pasta deste module.
Null terminate o module's root endereço da pasta.

Etapas necessárias para que se initialize o mouse:
Atribua 1 ao botão esquerdo deste mouse.
Atribua 2 ao botão direito deste mouse.
Call "user32.dll" "GetSystemMetrics" with 23 [sm_swapbutton] returning um número.
Se o número for 0, cancele.
Swap o botão esquerdo deste mouse with o botão direito deste mouse.

Etapas necessárias para que se initialize o printer canvas:
Atribua um printdlgex's magnitude ao lstructsize deste printdlgex.
Atribua o main window ao hwndowner deste printdlgex.
Atribua 1288 [pd_returndc + pd_returndefault + pd_nopageenums] ao flags deste printdlgex.
Atribua -1 [start_page_general] ao nstartpage deste printdlgex.
Call "comdlg32.dll" "PrintDlgExA" with o whereabouts deste printdlgex.
Call "kernel32.dll" "GlobalFree" with o hdevnames deste printdlgex.
Atribua o hdevmode deste printdlgex ao printer device mode handle.
Atribua o hdc deste printdlgex ao printer canvas.

Etapas necessárias para que se initialize o tela:
Call "user32.dll" "GetSystemMetrics" with 0 [sm_cxscreen] returning a pixel width desta tela.
Call "user32.dll" "GetSystemMetrics" with 1 [sm_cyscreen] returning a pixel altura desta tela.
Atribua 96 ao ppi.
Atribua o tpi dividido pelo ppi ao tpp.
Atribua a pixel width desta tela times o tpp A um width.
Atribua a pixel altura desta tela times o tpp A um altura.
Atribua 0 e 0 e o width e o altura à caixa desta tela.
Subtraia o tpp from o right-base desta tela.

Etapas necessárias para que se initialize o tela canvas:
Call "user32.dll" "GetDC" with o main window returning o tela canvas.
Normalize o tela canvas.

Etapas necessárias para que se initialize um talker:
Convert "{96749377-3391-11D2-9EE3-00C04F797396}" [clsid_spvoice] para um clsid.
Convert "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [iid_ispvoice] para um iid.
Call "ole32.dll" "CoCreateInstance" with o whereabouts deste clsid e 0 e 7 [clsctx_all] e o whereabouts deste iid e o whereabouts deste talker.

Etapas necessárias para que se initialize o window:
Atribua um window class's magnitude ao cbsize deste window class.
Atribua 40 [cs_owndc + cs_dblclks] ao style deste window class.
Point o lpfnwndproc deste window class to routine handle any message with um window um message número um w-param e um l-param.
Atribua o handle deste module ao hinstance deste window class.
Atribua o first deste name deste module ao lpszclassname deste window class.
Call "user32.dll" "RegisterClassExA" with o whereabouts deste window class.
Call "user32.dll" "CreateWindowExA" with 0 e o first deste name deste module e o first deste name deste module e -2147483648 [ws_popup] 
And 0 e 0 e a pixel width desta tela e a pixel altura desta tela e 0 e 0 e o handle deste module e 0.
Call "user32.dll" "ShowWindow" with o main window e 1 [sw_shownormal].

Etapas necessárias para que se initialize winsock:
Call "ws2_32.dll" "WSAStartup" with 2 e um wsadata's whereabouts.

Um input é um event.

Etapas necessárias para que se insira um pedaço Para um text:
Se o text for inexistente, cancele.
Atribua o pedaço A um string.
Insira o string ao text.

O tecla Insert é uma tecla igual a 45.

Etapas necessárias para que se insira um spot Para um polygon after um vértice:
Se o polygon for inexistente, cancele.
Crie uma segunda vértice usando o spot.
Insira o segunda vértice a os vértices deste polygon after o vértice.

Etapas necessárias para que se insira um string Para uma segunda string antes de um byte#:
Se o length deste string for 0, cancele.
Isole o byte#.
Limite o byte# para 1 e o length deste segunda string mais 1.
Lance um subtexto sobre o segunda string. \ left side
Atribua o first deste subtexto mais o byte# menos 2 ao last deste subtexto.
Lance uma segunda subtexto sobre o segunda string. \ right side
Atribua o first deste segunda subtexto mais o byte# menos 1 ao first deste segunda subtexto.
Atribua o length deste segunda string mais o length deste string A um combined length.
Reassign um endereço de memória usando o combined length.
Atribua o endereço de memória A um terceiro subtexto's first.
Copy pedaços from o first deste subtexto para o first deste terceiro subtexto pelo length deste subtexto.
Adicione o length deste subtexto para o first deste terceiro subtexto.
Copy pedaços from o first deste string para o first deste terceiro subtexto pelo length deste string.
Adicione o length deste string para o first deste terceiro subtexto.
Copy pedaços from o first deste segunda subtexto para o first deste terceiro subtexto pelo length deste segunda subtexto.
Unassign o first deste segunda string. \ dont use atribua um string A um string para prevent extra allocating e copying
Atribua o endereço de memória ao first deste segunda string.
Atribua o first deste segunda string mais o combined length menos 1 ao last deste segunda string.

Etapas necessárias para que se insira um string Para um text:
Se o text for inexistente, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Atribua o length deste string desta row menos o caret column# deste text A um número.
Atribua o string deste row A uma segunda string.
Insira o string ao segunda string antes de o caret column# deste text.
Convert o segunda string para alguns rows.
Atribua o last destas rows A uma segunda row.
Insira a rows A as rows deste text antes de a row.
Remove a row from as rows deste text.
Destroy a row.
Renumber as rows deste text.
Atribua o número da linha desta segunda row ao caret número da linha deste text.
Atribua o length deste string desta segunda row menos o número ao caret column# deste text.
Deselect o text.

Etapas necessárias para que se insira uma coisa Into alguns coisas after uma segunda coisa:
Se a coisa for inexistente, cancele.
Se o segunda coisa for inexistente, anteponha a coisa para as coisas; exit.
Insira a coisa ao coisas antes de o next desta segunda coisa.

Etapas necessárias para que se insira uma coisa Into alguns coisas antes de uma segunda coisa:
Se a coisa for inexistente, cancele.
Se as coisas estiverem vazio, posponha a coisa para as coisas; exit.
Se a segunda coisa for inexistente, posponha a coisa para as coisas; exit.
Se a segunda coisa for o first destas coisas, anteponha a coisa para as coisas; exit.
Atribua a coisa A uma new coisa.
Atribua a segunda coisa A uma previous coisa.
Atribua a new coisa ao next deste previous desta previous coisa.
Atribua a previous coisa ao next desta new coisa.
Atribua o previous desta previous coisa ao previous desta new coisa.
Atribua o new coisa ao previous desta previous coisa.

Etapas necessárias para que se insira alguns coisas Into alguns segunda coisas after um coisa:
Se a coisa for inexistente, anteponha o coisas para o segunda coisas; exit.
Insira o coisas ao segunda coisas antes de o next desta coisa.

Etapas necessárias para que se insira alguns coisas Into alguns segunda coisas antes de um coisa:
Isole o coisa.
Percorra.
Atribua o first destas coisas A uma segunda coisa.
Se o segunda coisa for inexistente, cancele.
Remove o segunda coisa from as coisas.
Insira o segunda coisa ao segunda coisas antes de o coisa.
Repita.

Etapas necessárias para que se insira um vértice Into um polygon after uma segunda vértice:
Se o polygon for inexistente, cancele.
Se o vértice for inexistente, cancele.
Insira o vértice a os vértices deste polygon after o segunda vértice.

Etapas necessárias para que se insira um vértice Into um polygon at um spot:
Se o polygon for inexistente, cancele.
Se o vértice for inexistente, cancele.
Percorra.
Obtenha uma segunda vértice from os vértices deste polygon.
Se o segunda vértice for inexistente, cancele.
Se o next deste segunda vértice for inexistente, cancele.
Atribua o spot deste segunda vértice e o spot deste next deste segunda vértice A uma line.
Se o spot não estiver sobre a line, repita.
Insira o vértice a os vértices deste polygon after o segunda vértice.

Etapas necessárias para que se insira um vértice Into um polygon antes de uma segunda vértice:
Se o polygon for inexistente, cancele.
Se o vértice for inexistente, cancele.
Insira o vértice a os vértices deste polygon antes de o segunda vértice.

Etapas necessárias para que se intersect um caixa with uma segunda caixa giving um terceiro caixa:
\ caixas does not touch
Limpe o terceiro caixa.
Se o left desta caixa for maior do que o right desta segunda caixa, cancele.
Se o topo desta caixa for maior do que a base desta segunda caixa, cancele.
Se o right desta caixa for menor do que o left desta segunda caixa, cancele.
Se a base desta caixa for menor do que o topo desta segunda caixa, cancele.
\ caixas touch
Atribua o caixa ao terceiro caixa.
Se o left desta caixa for menor do que o left desta segunda caixa, atribua o left desta segunda caixa ao left desta terceiro caixa.
Se o topo desta caixa for menor do que o topo desta segunda caixa, atribua o topo desta segunda caixa ao topo desta terceiro caixa.
Se o right desta caixa for maior do que o right desta segunda caixa, atribua o right desta segunda caixa ao right desta terceiro caixa.
Se a base desta caixa for maior do que a base desta segunda caixa, atribua a base desta segunda caixa à base desta terceiro caixa.

\Etapas necessárias para que se invert um alarme:
\ see "reverse um alarme"
\Se o alarme for yes, atribua no ao alarme; exit.
\Atribua yes ao alarme.

O inverted-exclamation-mark pedaço é um pedaço igual a 161.

O inverted-question-mark pedaço é um pedaço igual a 191.

Um in_addr é um conjunto with
Um pedaço called s_b1,
Um pedaço called s_b2,
Um pedaço called s_b3,
Um pedaço called s_b4,
Um wyrd [unsigned] called s_w1 at o s_b1,
Um wyrd [unsigned] called s_w2 at o s_b3,
Um número called s_addr at o s_b1.

Um ip address has
Um número, 
Um string. \, um cadena at o string.

Um istream é um endereço de memória para um istream object.

Um istream object é um conjunto with um istream vtable called vtable.

Um istream vtable é um endereço de memória para um istream vtable conjunto.

Um istream vtable conjunto é um conjunto with
\ iunknown
Um endereço de memória called queryinterface,
Um endereço de memória called addref,
Um endereço de memória called release, \ function(this:istream):number; stdcall;
\ istream
Um endereço de memória called read,
Um endereço de memória called write,
Um endereço de memória called seek,
Um endereço de memória called setsize,
Um endereço de memória called copyto,
Um endereço de memória called commit,
Um endereço de memória called revert,
Um endereço de memória called lockregion,
Um endereço de memória called unlockregion,
Um endereço de memória called stat,
Um endereço de memória called clone.

Um item has
Um categoria [directory, file], \ English
\Um clase [directorio, archivo], \ Spanish categoria
Um endereço completo, um endereço da pasta, um designador, um extensão,
Um size, 
Um creation date/time string,
Um win32finddata e um handle.

O tecla J/j é uma tecla igual a 74.

Etapas necessárias para que se jump o caret left em um text:
Se o text for inexistente, cancele.
Mova o caret left para any non-noise pedaço no text.
Se o caret column# deste text for 1, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Atribua o first deste string desta row mais o caret column# deste text menos 2 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço for alphanumeric, mova o caret left para any non-alphanumeric pedaço no text.
Se o target deste endereço de memória do pedaço não for alphanumeric, mova o caret left para any non-symbolic pedaço no text.
Mova o caret left para any non-noise pedaço no text.

Etapas necessárias para que se jump o caret right em um text:
Se o text for inexistente, cancele.
Mova o caret right para any non-noise pedaço no text.
Obtenha um row usando o caret número da linha deste text e o text.
Se o caret column# deste text é o length deste string desta row, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 1 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço é alphanumeric, mova o caret right para any non-alphanumeric pedaço no text.
Se o target deste endereço de memória do pedaço não for alphanumeric, mova o caret right para any non-symbolic pedaço no text.
Mova o caret right para any non-noise pedaço no text.

O tecla K/k é uma tecla igual a 75.

Um key é um número.
Um tecla é um número.

Um kilobyte é 1024 units.

Um categoria é um string.

O tecla L/l é uma tecla igual a 76.

Um l-param é um número.

Um landscape sheet é um sheet.

O large tamanho da letra é um tamanho da letra.

O maior número é 2147483647.

Um mínimo múltiplo comum é um número.

Um clique é um input.

Um left é alguns twips.

O left-alligator pedaço é um pedaço igual a 60.

O left-alligator-quote pedaço é um pedaço igual a 139.

O left-arrow tecla é uma tecla igual a 37.

O left-brace pedaço é um pedaço igual a 123.

O left-bracket pedaço é um pedaço igual a 91.

O left-double-alligator-quote pedaço é um pedaço igual a 171.


O left-double-quote pedaço é um pedaço igual a 147.

O left-paren pedaço é um pedaço igual a 40.

O left-single-quote pedaço é um pedaço igual a 145.

O left-window tecla é uma tecla igual a 91.

Um length é alguns twips.

O sinal menor do que é um pedaço igual a 60.
O símbolo menor do que é um pedaço igual a 60.

Um tamanho da letra é alguns twips. \ indicates actual altura of um typical uppercase letra

Uma letra é um pedaço.

O lexicon é uma coisa with um index.

O light blue cor é uma cor.

O light blue pincel é um pincel.

Um light cor é uma cor.

O light ciano cor é uma cor.

O light ciano pincel é um pincel.

O cor cinza claro é uma cor.

O light gray pincel é um pincel.

O cor verde claro é uma cor.

O light green pincel é um pincel.

O light lime cor é uma cor.

O light lime pincel é um pincel.

O light magenta cor é uma cor.

O light magenta pincel é um pincel.

O cor laranja claro é uma cor.

O light orange pincel é um pincel.

O light purple cor é uma cor.

O light purple pincel é um pincel.

O cor vermelho claro é uma cor.

O light red pincel é um pincel.

O light sky blue cor é uma cor.

O light sky blue pincel é um pincel.

O light sky cor é uma cor.

O light sky pincel é um pincel.

O light teal cor é uma cor.

O light teal pincel é um pincel.

O light violet cor é uma cor.

O light violet pincel é um pincel.

O cor amarelo claro é uma cor.

O light yellow pincel é um pincel.

Etapas necessárias para que se clareie uma cor por um quantia:
Adicione o quantia para a luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se clareie uma cor por alguns percent;
Etapas necessárias para que se clareie uma cor about alguns percent;
Etapas necessárias para que se clareie uma cor por about alguns percent;
Etapas necessárias para que se clareie uma cor alguns percent:
Atribua a luminosidade desta cor mais o percent à luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.


Etapas necessárias para que se clareie o current cor about alguns percent:
Clareie a cor deste context pelo percent.

Etapas necessárias para que se clareie um matiz por alguns degrees:
Adicione o degrees para o matiz.

Etapas necessárias para que se clareie um matiz por alguns points:
Convert o matiz para alguns segunda points.
Adicione o points para o segunda points.
Convert o segunda points para o matiz.

O lighter blue cor é uma cor.

O lighter blue pincel é um pincel.

O lighter ciano cor é uma cor.

O lighter ciano pincel é um pincel.

O cor cinza muito claro é uma cor.

O lighter gray pincel é um pincel.

O cor verde muito claro é uma cor.

O lighter green pincel é um pincel.

O lighter lime cor é uma cor.

O lighter lime pincel é um pincel.

O lighter magenta cor é uma cor.

O lighter magenta pincel é um pincel.

O cor laranja muito claro é uma cor.

O lighter orange pincel é um pincel.

O lighter purple cor é uma cor.

O lighter purple pincel é um pincel.

O cor vermelho muito claro é uma cor.

O lighter red pincel é um pincel.

O lighter sky blue cor é uma cor.

O lighter sky blue pincel é um pincel.

O lighter sky cor é uma cor.

O lighter sky pincel é um pincel.

O lighter teal cor é uma cor.

O lighter teal pincel é um pincel.

O lighter violet cor é uma cor.

O lighter violet pincel é um pincel.

O cor amarelo muito claro é uma cor.

O lighter yellow pincel é um pincel.

O lightest blue cor é uma cor.

O lightest blue pincel é um pincel.

O lightest ciano cor é uma cor.

O lightest ciano pincel é um pincel.

O cor cinza claríssimo é uma cor.

O lightest gray pincel é um pincel.

O cor verde claríssimo é uma cor.

O lightest green pincel é um pincel.

O lightest lime cor é uma cor.

O lightest lime pincel é um pincel.

O lightest magenta cor é uma cor.

O lightest magenta pincel é um pincel.

O cor laranja claríssimo é uma cor.

O lightest orange pincel é um pincel.

O lightest purple cor é uma cor.

O lightest purple pincel é um pincel.

O cor vermelho claríssimo é uma cor.

O lightest red pincel é um pincel.

O lightest sky blue cor é uma cor.

O lightest sky blue pincel é um pincel.

O lightest sky cor é uma cor.

O lightest sky pincel é um pincel.

O lightest teal cor é uma cor.

O lightest teal pincel é um pincel.

O lightest violet cor é uma cor.

O lightest violet pincel é um pincel.

O cor amarelo claríssimo é uma cor.

O lightest yellow pincel é um pincel.

Um luminosidade é um número [0 para 1000].

O lime cor é uma cor.

O lime pincel é um pincel.

Etapas necessárias para que se limite um caixa para uma segunda caixa:
Limite o left desta caixa para o left desta segunda caixa e o right desta segunda caixa.
Limite o topo desta caixa para o topo desta segunda caixa e a base desta segunda caixa.
Limite o right desta caixa para o left desta segunda caixa e o right desta segunda caixa.
Limite a base desta caixa para o topo desta segunda caixa e a base desta segunda caixa.

Etapas necessárias para que se limite o caret em um text:
Se o text for inexistente, cancele.
Limite o caret número da linha deste text para 1 e a row contagem deste text.
Obtenha um row usando o caret número da linha deste text e o text.
Limite o caret column# deste text para 1 e o length deste string desta row.

Etapas necessárias para que se limite um número para uma segunda número e um terceiro número:
Se o número for menor do que o segunda número, atribua o segunda número ao número; exit.
Se o número for maior do que o terceiro número, atribua o terceiro número ao número.

Etapas necessárias para que se limite o origin of um text:
Se o text for inexistente, cancele.
Limite a coordenada x deste text para o menor número e a margin deste text.
Atribua a row contagem deste text menos 1 times a row altura deste text A um número.
Limite a coordenada y deste text para - o número e 0.

Etapas necessárias para que se limite um spot para um caixa:
Se a coordenada x deste spot for menor do que o left desta caixa, atribua o left desta caixa à coordenada x deste spot.
Se a coordenada y deste spot for menor do que o topo desta caixa, atribua o topo desta caixa à coordenada y deste spot.
Se a coordenada x deste spot for maior do que o right desta caixa, atribua o right desta caixa à coordenada x deste spot.
Se a coordenada y deste spot for maior do que a base desta caixa, atribua a base desta caixa à coordenada y deste spot.

Etapas necessárias para que se limite alguns texts para um contagem:
Atribua a contagem destes texts A uma segunda contagem.
Percorra.
Se o segunda contagem for menor do que ou igual ao contagem, cancele.
Atribua o first destes texts A um text.
Remove o text from o texts.
Destroy o text.
Subtraia 1 from o segunda contagem.
Repita.

Um line has um start spot e um end spot.

O linefeed pedaço é um pedaço igual a 10.

Etapas necessárias para que se list algumas choices em uma caixa;
Etapas necessárias para que se draw algumas choices em uma caixa:
\Draw really fast. ***
Obtenha um [first/next] choice from as choices.
Se a choice estiver missing [because we have drawn them all], cancele.
Atribua o left desta caixa mais 1/4 inch ao left desta choice.
Atribua o right desta caixa menos 1/4 inch ao right desta choice.
Se a choice for o first desta choice, atribua o topo desta caixa mais 1/4 inch ao topo desta choice.
Se a choice não for o first desta choice, atribua a base deste previous desta choice ao topo desta choice.
Atribua o topo desta choice mais 1/4 inch à base desta choice.
\Draw a caixa desta choice with o purple cor. \ temp ***
Stroke o name desta choice na caixa desta choice with a cor deste context.
Repita.

Etapas necessárias para que se list alguns choices em um caixa with um cor;
Etapas necessárias para que se draw alguns choices em um caixa with um cor:
Atribua a cor à cor deste context.
Draw o choices no caixa.

O little-a pedaço é um pedaço igual a 97.

O little-a-acute pedaço é um pedaço igual a 225.

O little-a-circumflex pedaço é um pedaço igual a 226.

O little-a-trema é um pedaço igual a 228.

O little-a-grave pedaço é um pedaço igual a 224.

O little-a-ring pedaço é um pedaço igual a 229.

O little-a-tilde pedaço é um pedaço igual a 227.

O little-ae pedaço é um pedaço igual a 230.

O little-b pedaço é um pedaço igual a 98.

O little-c pedaço é um pedaço igual a 99.

O little-c-sinal de cedilha é um pedaço igual a 231.

O little-d pedaço é um pedaço igual a 100.

O little-e pedaço é um pedaço igual a 101.

O little-e-acute pedaço é um pedaço igual a 233.

O little-e-circumflex pedaço é um pedaço igual a 234.

O little-e-trema é um pedaço igual a 235.

O little-e-grave pedaço é um pedaço igual a 232.

O little-eth pedaço é um pedaço igual a 240.

O little-f pedaço é um pedaço igual a 102.

O little-f-hook pedaço é um pedaço igual a 131.

O little-g pedaço é um pedaço igual a 103.

O little-h pedaço é um pedaço igual a 104.

O little-i pedaço é um pedaço igual a 105.

O little-i-acute pedaço é um pedaço igual a 237.

O little-i-circumflex pedaço é um pedaço igual a 238.

O little-i-trema é um pedaço igual a 239.

O little-i-grave pedaço é um pedaço igual a 236.

O little-j pedaço é um pedaço igual a 106.

O little-k pedaço é um pedaço igual a 107.

O little-l pedaço é um pedaço igual a 108.

O little-m pedaço é um pedaço igual a 109.

O little-n pedaço é um pedaço igual a 110.

O little-n-tilde pedaço é um pedaço igual a 241.

O little-o pedaço é um pedaço igual a 111.

O little-o-acute pedaço é um pedaço igual a 243.

O little-o-circumflex pedaço é um pedaço igual a 244.

O little-o-trema é um pedaço igual a 246.

O little-o-grave pedaço é um pedaço igual a 242.

O little-o-stroke pedaço é um pedaço igual a 248.

O little-o-tilde pedaço é um pedaço igual a 245.

O little-oe pedaço é um pedaço igual a 156.

O little-p pedaço é um pedaço igual a 112.

O little-q pedaço é um pedaço igual a 113.

O little-r pedaço é um pedaço igual a 114.

O little-s pedaço é um pedaço igual a 115.

O little-s-caron pedaço é um pedaço igual a 154.

O little-t pedaço é um pedaço igual a 116.

O little-thorn pedaço é um pedaço igual a 254.

O little-tilde pedaço é um pedaço igual a 152.

O little-u pedaço é um pedaço igual a 117.

O little-u-acute pedaço é um pedaço igual a 250.

O little-u-circumflex pedaço é um pedaço igual a 251.

O little-u-trema é um pedaço igual a 252.

O little-u-grave pedaço é um pedaço igual a 249.

O little-v pedaço é um pedaço igual a 118.

O little-w pedaço é um pedaço igual a 119.

O little-x pedaço é um pedaço igual a 120.

O little-y pedaço é um pedaço igual a 121.

O little-y-acute pedaço é um pedaço igual a 253.

O little-y-trema é um pedaço igual a 255.

O z minúsculo é um pedaço igual a 122.

O little-z-caron pedaço é um pedaço igual a 158.

Etapas necessárias para que se load o lexicon:
Se o lexicon não for inexistente, cancele.
Extract um endereço da pasta from o endereço completo deste module.
Percorra.
Se o endereço da pasta estiver em branco, cancele.
Atribua o endereço da pasta then "lexicon\" A um endereço completo.
Se o endereço completo estiver no sistema de arquivos, load o lexicon usando o endereço completo; exit.
Extract o endereço da pasta from o endereço da pasta.
Repita.

Etapas necessárias para que se load o lexicon usando um trecho:
Se o lexicon for inexistente, crie o lexicon.
Lance um percorredor sobre o trecho.
Percorra.
Mova o percorredor (index lexicon rules).
Se o token deste percorredor estiver em branco, cancele.
Catalogue o token deste percorredor no index deste lexicon.
Repita.

Etapas necessárias para que se load o lexicon usando um endereço completo:
Obtenha um item from o endereço completo.
Se o item não for found, cancele.
Se a categoria deste item não for "file", repita.
Read o endereço completo deste item A um trecho.
Se o i/o erro não estiver em branco, repita.
Load o lexicon usando o trecho.
Repita.

Etapas necessárias para que se localize um caixa usando um pair:
Isole o pair.
Negate o pair.
Mova o caixa usando o pair.

Etapas necessárias para que se localize um spot usando um pair:
Isole o pair.
Negate o pair.
Mova o spot usando o pair.

Etapas necessárias para que se lock um gpbitmap usando um bitmapdata (24-bit rgb):
Atribua o gprect deste gpbitmap A um gprect.
Call "gdiplus.dll" "GdipBitmapLockBits" with o gpbitmap e o whereabouts deste gprect e 3 [imagelockmoderead ou imagelockmodewrite] And 137224 [pixelformat24bpprgb] e o whereabouts deste bitmapdata.

Um logbrush has
Um número called lbstyle,
Um código da cor called lbcolor,
Um número called lbhatch.

O lower-double-quote pedaço é um pedaço igual a 132.

O lower-single-quote pedaço é um pedaço igual a 130.

Etapas necessárias para que se lowercase any selecionado pedaços em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Lance um subtexto sobre any selecionado pedaços na row of o text.
Lowercase o subtexto.
Repita.

Etapas necessárias para que se lowercase um pedaço:
Translate o pedaço usando o lowercase ascii table.

Etapas necessárias para que se lowercase o character under um finger e atribua it Into um string:
Se o finger for inexistente, cancele.
Atribua o target deste finger ao string.
Lowercase o string.

Etapas necessárias para que se lowercase um string:
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Lowercase o target deste first deste subtexto.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se lowercase um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, pare.
Lowercase o string deste row.
Repita.
Wrap o text.

O tecla M/m é uma tecla igual a 77.

O magenta cor é uma cor.

O magenta pincel é um pincel.

O main window é um window.

Etapas necessárias para que se make uma fração with um número e uma segunda número:
Atribua o número ao numerador desta fração.
Atribua o segunda número ao denominador desta fração.

Etapas necessárias para que se make um ratio pair usando um caixa e uma segunda caixa;
Etapas necessárias para que se make uma fração pair usando um caixa e uma segunda caixa:
Atribua o x-extent desta caixa à numerador desta fração deste fração pair.
Atribua o x-extent desta segunda caixa ao denominador desta fração deste fração pair.
Atribua o y-extent desta caixa ao numerador desta segunda fração deste fração pair.
Atribua o segunda caixa's y-extent ao denominador desta segunda fração deste fração pair.

Um margin é um número.

O masculine pedaço é um pedaço igual a 186.

Etapas necessárias para que se mask inside um caixa:
Crie um hrgn usando o caixa.
Mask inside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se mask inside um elipse:
Crie um hrgn usando o elipse.
Mask inside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se mask inside um hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" with o quadro atual e o hrgn e 4 [rgn_diff].

Etapas necessárias para que se mask inside um polygon:
Crie um hrgn usando o polygon.
Mask inside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se mask inside um caixa arredondada:
Crie um hrgn usando o caixa arredondada.
Mask inside o hrgn.
Destroy o hrgn.

Um mask é um texto hexadecimal.

Etapas necessárias para que se mask only inside um caixa:
Unmask everything.
Mask inside o caixa.

Etapas necessárias para que se mask only inside um elipse:
Unmask everything.
Mask inside o elipse.

Etapas necessárias para que se mask only inside um polygon:
Unmask everything.
Mask inside o polygon.

Etapas necessárias para que se mask only inside um caixa arredondada:
Unmask everything.
Mask inside o caixa arredondada.

Etapas necessárias para que se mask only outside um caixa:
Unmask everything.
Mask outside o caixa.

Etapas necessárias para que se mask only outside um elipse:
Unmask everything.
Mask outside o elipse.

Etapas necessárias para que se mask only outside um polygon:
Unmask everything.
Mask outside o polygon.

Etapas necessárias para que se mask only outside um caixa arredondada:
Unmask everything.
Mask outside o caixa arredondada.

Etapas necessárias para que se mask outside um caixa:
Crie um hrgn usando o caixa.
Mask outside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se mask outside um elipse:
Crie um hrgn usando o elipse.
Mask outside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se mask outside um hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" with o quadro atual e o hrgn e 1 [rgn_and].

Etapas necessárias para que se mask outside um polygon:
Crie um hrgn usando o polygon.
Mask outside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se mask outside um caixa arredondada:
Crie um hrgn usando o caixa arredondada.
Mask outside o hrgn.
Destroy o hrgn.

O max text undos é um contagem igual a 32.

O medium tamanho da letra é um tamanho da letra.

Um megabyte é 1024 kilobytes.

O memory canvas é um canvas.

O tecla de menu de contexto é uma tecla igual a 93.

Um message é um string.

O micro pedaço é um pedaço igual a 181.

An million é 1000 thousands.

An millisecond é um número.

Etapas necessárias para que se minimize um window:
Call "user32.dll" "ShowWindow" with o window e 6 [sw_minimize].

O minus-sign pedaço é um pedaço igual a 45.

Um minute é 60 seconds.

Etapas necessárias para que se mirror o gpbitmap em um picture:
Se o picture for inexistente, cancele.
Reverse o mirror alarme desta picture.
Mirror o gpbitmap desta picture.

Etapas necessárias para que se mirror um gpimage:
Call "gdiplus.dll" "GdipImageRotateFlip" with o gpimage e 4 [rotatenoneflipx].

Etapas necessárias para que se mirror um picture:
Se o picture for inexistente, cancele.
Atribua a coordenada x deste center desta caixa desta picture menos a coordenada x deste center desta uncropped caixa desta picture A um pair's número x.
Multiplique o número x deste pair por 2.
Mova a uncropped caixa desta picture usando o pair.
Mirror o gpbitmap no picture.

Etapas necessárias para que se mirror um polygon:
Se o polygon for inexistente, cancele.
Atribua a caixa deste polygon A uma caixa.
Percorra.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, cancele.
Subtraia o left desta caixa from a coordenada x deste vértice.
Atribua o right desta caixa menos a coordenada x deste vértice à coordenada x deste vértice.
Repita.

Um mixed has um whole número e um ratio e uma fração at o ratio.

O module has
Um handle,
Um endereço completo,
Um endereço da pasta,
Um root endereço da pasta, \ one up from o endereço da pasta that exe é run from
Um nome do arquivo s/ extensão called name.

O mouse has
Um tecla called botão esquerdo, 
Um tecla called botão direito.

Etapas necessárias para que se mova o anchor left para any non-alphanumeric pedaço em um text:
Se o text for inexistente, cancele.
Obtenha um row usando o anchor número da linha deste text e o text.
Percorra.
Se o anchor column# deste text for 1, cancele.
Atribua o first deste string desta row mais o anchor column# deste text menos 2 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for alphanumeric, cancele.
Subtraia 1 from o anchor column# deste text.
Repita.

Etapas necessárias para que se mova back alguns twips:
Vire around.
Mova o twips.
Vire around.

Etapas necessárias para que se mova um caixa para o base of uma segunda caixa:
Mova o caixa down a base desta segunda caixa menos a base desta caixa.

Etapas necessárias para que se mova um caixa close para o left side of uma segunda caixa;
Etapas necessárias para que se mova um caixa close para o left of uma segunda caixa:
Mova o caixa para o left of o segunda caixa.
Escolha aleatoriamente um length between 0 e a width desta caixa times 3/4.
Mova o caixa right o length.

Etapas necessárias para que se mova um caixa down alguns twips:
Mova o caixa usando 0 e o twips.

Etapas necessárias para que se mova um caixa usando um pair:
Mova o caixa usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um caixa usando um ratio pair e um spot;
Etapas necessárias para que se mova um caixa usando uma fração pair e um spot:
Obtenha um difference between o left-top desta caixa e o spot.
Atribua a difference A uma segunda difference.
Redimensione proporcionalmente o segunda difference usando a fração pair.
Subtraia a difference from o segunda difference.
Mova o caixa usando o segunda difference.

Some x-twips são alguns twips.
Some y-twips são alguns twips.

Etapas necessárias para que se mova um caixa usando alguns x-twips e alguns y-twips:
Adicione o x-twips para o left desta caixa.
Adicione o y-twips para o topo desta caixa.
Adicione o x-twips para o right desta caixa.
Adicione o y-twips para a base desta caixa.

Etapas necessárias para que se mova um caixa left para um coord:
Mova o caixa left o left desta caixa menos o coord.

Etapas necessárias para que se mova um caixa para o left side of uma segunda caixa;
Etapas necessárias para que se mova um caixa para o left of uma segunda caixa:
Mova o caixa left o left desta caixa menos o left desta segunda caixa.

Etapas necessárias para que se mova um caixa left alguns twips:
Mova o caixa usando - o twips e 0.

Etapas necessárias para que se mova um caixa para o right side of uma segunda caixa;
Etapas necessárias para que se mova um caixa para o right of uma segunda caixa:
Mova o caixa right o right desta segunda caixa menos o right desta caixa.

Etapas necessárias para que se mova um caixa right alguns twips:
Mova o caixa usando o twips e 0.

Etapas necessárias para que se mova um caixa para um spot:
Obtenha um difference between o spot e o left-top desta caixa.
Mova o caixa usando a difference.

Etapas necessárias para que se mova um caixa para o topo left corner of uma segunda caixa:
Mova o caixa para o left desta segunda caixa-top.

Etapas necessárias para que se mova um caixa para o topo of uma segunda caixa:
Mova o caixa up o topo desta caixa menos o topo desta segunda caixa.

Etapas necessárias para que se mova um caixa up alguns twips:
Mova o caixa usando 0 e - o twips.

Etapas necessárias para que se mova o caret down em um text:
Se o text for inexistente, cancele.
Adicione 1 para o caret número da linha deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret down one página em um text:
Se o text for inexistente, cancele.
Adicione as rows/box deste text para o caret número da linha deste text.
Subtraia 1 from o caret número da linha deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret para o first pedaço of o current row of um text:
Se o text for inexistente, cancele.
Atribua 1 ao caret column# deste text.

Etapas necessárias para que se mova o caret para o first pedaço of um text:
Se o text for inexistente, cancele.
Atribua 1 e 1 ao caret deste text.

Etapas necessárias para que se mova o caret para o last pedaço of o current row of um text:
Se o text for inexistente, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Atribua o length deste string desta row ao caret column# deste text.

Etapas necessárias para que se mova o caret para o last pedaço of um text:
Se o text for inexistente, cancele.
Atribua a row contagem deste text ao caret número da linha deste text.
Obtenha um row usando o caret número da linha deste text e o text.
Atribua o length deste string desta row ao caret column# deste text.

Etapas necessárias para que se mova o caret left para any non-alphanumeric pedaço em um text:
Se o text for inexistente, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Percorra.
Se o caret column# deste text for 1, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 2 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for alphanumeric, cancele.
Subtraia 1 from o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret left para any non-noise pedaço em um text:
Se o text for inexistente, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Percorra.
Se o caret column# deste text for 1, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 2 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for noise, cancele.
Subtraia 1 from o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret left para any non-symbolic pedaço em um text:
Se o text for inexistente, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Percorra.
Se o caret column# deste text for 1, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 2 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for symbolic, cancele.
Subtraia 1 from o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret left em um text:
Se o text for inexistente, cancele.
Subtraia 1 from o caret column# deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret right para any non-alphanumeric pedaço em um text:
Se o text for inexistente, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Percorra.
Se o caret column# deste text é o length deste string desta row, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 1 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for alphanumeric, cancele.
Adicione 1 para o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret right para any non-noise pedaço em um text:
Se o text for inexistente, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Percorra.
Se o caret column# deste text é o length deste string desta row, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 1 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for noise, cancele.
Adicione 1 para o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret right para any non-symbolic pedaço em um text:
Se o text for inexistente, cancele.
Obtenha um row usando o caret número da linha deste text e o text.
Percorra.
Se o caret column# deste text é o length deste string desta row, cancele.
Atribua o first deste string desta row mais o caret column# deste text menos 1 A um endereço de memória do pedaço .
Se o target deste endereço de memória do pedaço não for symbolic, cancele.
Adicione 1 para o caret column# deste text.
Repita.

Etapas necessárias para que se mova o caret right em um text:
Se o text for inexistente, cancele.
Adicione 1 para o caret column# deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret up em um text:
Se o text for inexistente, cancele.
Subtraia 1 from o caret número da linha deste text.
Limite o caret no text.

Etapas necessárias para que se mova o caret up one página em um text:
Se o text for inexistente, cancele.
Subtraia as rows/box deste text from o caret número da linha deste text.
Adicione 1 para o caret número da linha deste text.
Limite o caret no text.

Etapas necessárias para que se mova um elipse down alguns twips:
Mova o elipse usando 0 e o twips.

Etapas necessárias para que se mova um elipse usando um pair:
Mova o elipse usando o x deste pair e o y deste pair.

Etapas necessárias para que se mova um elipse usando alguns x-twips e alguns y-twips:
Mova a caixa desta elipse usando o x-twips e o y-twips.

Etapas necessárias para que se mova um elipse left alguns twips:
Mova o elipse usando - o twips e 0.

Etapas necessárias para que se mova um elipse right alguns twips:
Mova o elipse usando o twips e 0.

Etapas necessárias para que se mova um elipse para um spot:
Obtenha um difference between o spot e o left-top desta elipse.
Mova o elipse usando a difference.

Etapas necessárias para que se mova um elipse up alguns twips:
Mova o elipse usando 0 e - o twips.

Etapas necessárias para que se mova um finger over um número:
Se o finger for inexistente, cancele.
Adicione 1 para o finger.

Etapas necessárias para que se mova para o left alguns twips e down alguns segunda twips;
Etapas necessárias para que se mova left alguns twips e down alguns segunda twips;
Etapas necessárias para que se mova alguns twips para o left e alguns segunda twips down;
Etapas necessárias para que se mova alguns twips left e alguns segunda twips down:
Mova o spot deste context left o twips.
Mova o spot deste context down o segunda twips.

Etapas necessárias para que se mova para o left alguns twips e up alguns segunda twips;
Etapas necessárias para que se mova left alguns twips e up alguns segunda twips;
Etapas necessárias para que se mova alguns twips para o left e alguns segunda twips up;
Etapas necessárias para que se mova alguns twips left e alguns segunda twips up:
Mova o spot deste context left o twips.
Mova o spot deste context up o segunda twips.

Etapas necessárias para que se mova um line down alguns twips:
Mova o line usando 0 e o twips.

Etapas necessárias para que se mova um line usando um pair:
Mova o line usando o x deste pair e o y deste pair.

Etapas necessárias para que se mova um line usando alguns x-twips e alguns y-twips:
Adicione o x-twips para o coordenada x desta start desta line.
Adicione o y-twips para o coordenada y desta start desta line.
Adicione o x-twips para a coordenada x deste end desta line.
Adicione o y-twips para a coordenada y deste end desta line.

Etapas necessárias para que se mova um line left alguns twips:
Mova o line usando - o twips e 0.

Etapas necessárias para que se mova um line para um spot:
Obtenha um difference between o spot e o start desta line.
Mova o line usando a difference.

Etapas necessárias para que se mova um line alguns twips para o right;
Etapas necessárias para que se mova um line right alguns twips:
Mova o line usando o twips e 0.

Etapas necessárias para que se mova um line up alguns twips:
Mova o line usando 0 e - o twips.

Etapas necessárias para que se mova para o middle;
Etapas necessárias para que se start no middle;
Etapas necessárias para que se mova para o center;
Etapas necessárias para que se start no center:
Atribua o center desta caixa deste context ao spot deste context.

Etapas necessárias para que se mova para o middle of um caixa;
Etapas necessárias para que se start no middle of um caixa;
Etapas necessárias para que se mova para o center of um caixa;
Etapas necessárias para que se start no center of um caixa:
Atribua o center desta caixa ao spot deste context.

Etapas necessárias para que se mova um picture down alguns twips:
Mova o picture usando 0 e o twips.

Etapas necessárias para que se mova um picture usando um pair:
Mova o picture usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um picture usando alguns x-twips e alguns y-twips:
Se o picture for inexistente, cancele.
Mova a caixa desta picture usando o x-twips e o y-twips.
Mova a uncropped caixa desta picture usando o x-twips e o y-twips.

Etapas necessárias para que se mova um picture left alguns twips:
Mova o picture usando - o twips e 0.

Etapas necessárias para que se mova um picture right alguns twips:
Mova o picture usando o twips e 0.

Etapas necessárias para que se mova um picture para um spot:
Se o picture for inexistente, cancele.
Obtenha um difference between o spot e o left-top desta picture.
Mova o picture usando a difference.

Etapas necessárias para que se mova um picture up alguns twips:
Mova o picture usando 0 e - o twips.

Etapas necessárias para que se mova um polygon down alguns twips:
Mova o polygon usando 0 e o twips.

Etapas necessárias para que se mova um polygon usando um pair:
Mova o polygon usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um polygon usando alguns x-twips e alguns y-twips:
Se o polygon for inexistente, cancele.
Percorra.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, cancele.
Mova o vértice usando o x-twips e o y-twips.
Repita.

Etapas necessárias para que se mova um polygon left alguns twips:
Mova o polygon usando - o twips e 0.

Etapas necessárias para que se mova um polygon left alguns twips e down alguns segunda twips:
Mova o polygon left o twips.
Mova o polygon down o segunda twips.

Etapas necessárias para que se mova um polygon left alguns twips e up alguns segunda twips:
Mova o polygon left o twips.
Mova o polygon up o segunda twips.

Etapas necessárias para que se mova um polygon right alguns twips:
Mova o polygon usando o twips e 0.

Etapas necessárias para que se mova um polygon right alguns twips e down alguns segunda twips:
Mova o polygon right o twips.
Mova o polygon down o segunda twips.

Etapas necessárias para que se mova um polygon right alguns twips e up alguns segunda twips:
Mova o polygon right o twips.
Mova o polygon up o segunda twips.

Etapas necessárias para que se mova um polygon para um spot:
Se o polygon for inexistente, cancele.
Obtenha um difference between o spot e o left-top desta caixa deste polygon.
Mova o polygon usando a difference.

Etapas necessárias para que se mova um polygon up alguns twips:
Mova o polygon usando 0 e - o twips.

Etapas necessárias para que se mova um percorredor (index lexicon rules):
Skip any leading noise no source deste percorredor.
Position o token deste percorredor sobre o source deste percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Avance o percorredor.
Se o target deste first deste source deste percorredor for noise, cancele.
Repita.

Etapas necessárias para que se mova um percorredor (quoted string rules):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor não for as aspas duplas, repita.
Se o first deste source deste percorredor é o last deste source deste percorredor, avance o percorredor; exit.
Avance o percorredor.
Se o target deste first deste source deste percorredor não for as aspas duplas, cancele.
Repita.

Etapas necessárias para que se mova um percorredor (spell checking rules):
Skip any non-alphanumeric pedaços no source deste percorredor.
Position o token deste percorredor sobre o source deste percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Avance o percorredor.
Se o source deste percorredor está sobre any contraction, avance o percorredor; repita.
Se o target deste first deste source deste percorredor não for alphanumeric, cancele.
Repita.

Etapas necessárias para que se mova um percorredor (text file rules):
Position o token deste percorredor sobre o source deste percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, avance o percorredor; break.
Se o target deste first deste source deste percorredor for o linefeed pedaço, avance o percorredor; exit. \ *dahn new para handle lines terminated por just linefeed
Avance o percorredor.
Repita.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o linefeed pedaço, adicione 1 para o first deste source deste percorredor.

Etapas necessárias para que se mova um percorredor (word wrapping rules):
Position o token deste percorredor sobre o source deste percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, avance o percorredor; exit.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, cancele.
Se o token deste percorredor estiver em branco, avance o percorredor; repita.
Se o target deste first deste source deste percorredor for like o target deste last deste token deste percorredor, avance o percorredor; repita.

Etapas necessárias para que se mova um percorredor usando um caixa (word wrapping rules):
Skip any leading linefeed pedaço no source deste percorredor.
Position o token deste percorredor sobre o source deste percorredor.
Se o source deste percorredor estiver em branco, cancele.
Lance uma segunda percorredor sobre o percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Mova o segunda percorredor (word wrapping rules).
Se o token deste segunda percorredor estiver em branco, cancele.
Se o target deste first deste token deste segunda percorredor for o return pedaço, avance o percorredor; exit.
Se o target deste first deste token deste segunda percorredor for whitespace, avance o percorredor pelo length deste token deste segunda percorredor; repita.
Se o token deste percorredor estiver em branco, avance o percorredor pelo length deste token deste segunda percorredor; repita.
Se o token deste percorredor then o token deste segunda percorredor forem wider do que o caixa, cancele.
Avance o percorredor pelo length deste token deste segunda percorredor.
Repita.

Etapas necessárias para que se mova um percorredor usando um separator pedaço:
Position o token deste percorredor sobre o source deste percorredor.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o separator pedaço, adicione 1 para o first deste source deste percorredor; exit.
Avance o percorredor.
Repita.

Etapas necessárias para que se mova para o right alguns twips e down alguns segunda twips;
Etapas necessárias para que se mova right alguns twips e down alguns segunda twips;
Etapas necessárias para que se mova alguns twips para o right e alguns segunda twips down;
Etapas necessárias para que se mova alguns twips right e alguns segunda twips down:
Mova o spot deste context right o twips.
Mova o spot deste context down o segunda twips.

Etapas necessárias para que se mova para o right alguns twips e up alguns segunda twips;
Etapas necessárias para que se mova right alguns twips e up alguns segunda twips;
Etapas necessárias para que se mova alguns twips para o right e alguns segunda twips up;
Etapas necessárias para que se mova alguns twips right e alguns segunda twips up:
Mova o spot deste context right o twips.
Mova o spot deste context up o segunda twips.

Etapas necessárias para que se mova para um spot:
Atribua o spot ao spot deste context.

Etapas necessárias para que se mova um spot about alguns twips em any direction:
Escolha aleatoriamente uma segunda spot within o twips of o spot.
Atribua o segunda spot ao spot.

Etapas necessárias para que se mova um spot para uma segunda spot:
Atribua o segunda spot ao spot.

Etapas necessárias para que se mova um spot usando um pair:
Mova o spot usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um spot usando alguns x-twips e alguns y-twips:
Adicione o x-twips para a coordenada x deste spot.
Adicione o y-twips para a coordenada y deste spot.

Etapas necessárias para que se mova um spot alguns twips down;
Etapas necessárias para que se mova um spot down alguns twips:
Mova o spot usando 0 e o twips.

Etapas necessárias para que se mova um spot alguns twips para o left;
Etapas necessárias para que se mova um spot alguns twips left;
Etapas necessárias para que se mova um spot left alguns twips:
Mova o spot usando - o twips e 0.

Etapas necessárias para que se mova um spot alguns twips right;
Etapas necessárias para que se mova um spot alguns twips para o right;
Etapas necessárias para que se mova um spot right alguns twips:
Mova o spot usando o twips e 0.

Etapas necessárias para que se mova um spot alguns twips para o right e alguns segunda twips down;
Etapas necessárias para que se mova um spot alguns twips right e alguns segunda twips down:
Adicione o twips para o x deste spot.
Adicione o segunda twips para o y deste spot.

Etapas necessárias para que se mova um spot alguns twips up;
Etapas necessárias para que se mova um spot up alguns twips:
Mova o spot usando 0 e - o twips.

Etapas necessárias para que se mova alguns squares:
Mova o square size times o squares dividido por 1 square. \ squares são scaled up por precision hence o division at o end

Etapas necessárias para que se mova alguns squares diagonally;
Etapas necessárias para que se mova alguns squares slantways:
Mova o square size times o squares times o raiz de dois dividido por 1 square. \ squares são scaled up por precision hence o division at o end

Etapas necessárias para que se mova um subtexto usando um número:
Adicione o número para o first deste subtexto.
Adicione o número para o last deste subtexto.

Etapas necessárias para que se mova um text down alguns twips:
Mova o text usando 0 e o twips.

Etapas necessárias para que se mova um text usando um pair:
Mova o text usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um text usando alguns x-twips e alguns y-twips:
Se o text for inexistente, cancele.
Mova a caixa deste text usando o x-twips e o y-twips.

Etapas necessárias para que se mova um text left alguns twips:
Mova o text usando - o twips e 0.

Etapas necessárias para que se mova um text right alguns twips:
Mova o text usando o twips e 0.

Etapas necessárias para que se mova um text para um spot:
Se o text for inexistente, cancele.
Obtenha um difference between o spot e o left-top deste text.
Mova o text usando a difference.

Etapas necessárias para que se mova um text up alguns twips:
Mova o text usando 0 e - o twips.

Etapas necessárias para que se mova uma coisa from alguns coisas para alguns segunda coisas:
Se a coisa for inexistente, cancele.
Isole o coisa.
Remove a coisa from as coisas.
Posponha a coisa para o segunda coisas.

Etapas necessárias para que se mova alguns coisas para alguns segunda coisas:
Atribua o first destas coisas ao first destas segunda coisas.
Atribua o last destas coisas ao last destas segunda coisas.
Limpe as coisas.

Etapas necessárias para que se mova alguns twips:
\Aguarde pelo delay. ***
Atribua o spot deste context A um line's start.
Atribua o spot deste context ao end desta line.
Obtenha um rise e um run usando o heading deste context.
Adicione o run times o twips dividido por 10000 para a coordenada x deste end desta line.
Adicione o rise times o twips dividido por 10000 para a coordenada y deste end desta line.
Atribua o end desta line ao spot deste context.

Etapas necessárias para que se mova alguns twips down;
Etapas necessárias para que se mova down alguns twips:
Adicione o twips para a coordenada y deste context.

Etapas necessárias para que se mova alguns twips para o left;
Etapas necessárias para que se mova alguns twips left;
Etapas necessárias para que se mova left alguns twips:
Subtraia o twips from a coordenada x deste context.

Etapas necessárias para que se mova alguns twips para o right;
Etapas necessárias para que se mova alguns twips right;
Etapas necessárias para que se mova right alguns twips:
Adicione o twips para a coordenada x deste context.

Etapas necessárias para que se mova alguns twips up;
Etapas necessárias para que se mova up alguns twips:
Subtraia o twips from a coordenada y deste context.

Etapas necessárias para que se mova um vértice down alguns twips:
Mova o vértice usando 0 e o twips.

Etapas necessárias para que se mova um vértice usando um pair:
Mova o vértice usando o número x deste pair e o número y deste pair.

Etapas necessárias para que se mova um vértice usando alguns x-twips e alguns y-twips:
Se o vértice for inexistente, cancele.
Adicione o x-twips para a coordenada x deste vértice.
Adicione o y-twips para a coordenada y deste vértice.

Etapas necessárias para que se mova um vértice left alguns twips:
Mova o vértice usando - o twips e 0.

Etapas necessárias para que se mova um vértice right alguns twips:
Mova o vértice usando o twips e 0.

Etapas necessárias para que se mova um vértice para um spot:
Se o vértice for inexistente, cancele.
Atribua o spot ao spot deste vértice.

Etapas necessárias para que se mova um vértice up alguns twips:
Mova o vértice usando 0 e - o twips.

Etapas necessárias para que se mova um window left:
Call "user32.dll" "GetWindowRect" with o main window e um caixa's whereabouts.
Subtraia a pixel width desta tela from o left desta caixa.
Call "user32.dll" "MoveWindow" with o window e o left desta caixa e o topo desta caixa e a pixel width desta tela e a pixel altura desta tela e 1.

Etapas necessárias para que se mova um window right:
Call "user32.dll" "GetWindowRect" with o main window e um caixa's whereabouts.
Adicione a pixel width desta tela para o left desta caixa.
Call "user32.dll" "MoveWindow" with o window e o left desta caixa e o topo desta caixa e a pixel width desta tela e a pixel altura desta tela e 1.

Um ms é 1 millisecond.

Um msg é um conjunto with
Um window called hwnd,
Um número called message,
Um w-param called wparam,
Um l-param called lparam,
Um número called time,
Um spot called pt.

Um multiple é um número.

O multiplication-symbol pedaço é um pedaço igual a 215.

Etapas necessárias para que se multiplique uma fração por um número:
Multiplique o numerador desta fração pelo número.
Reduce a fração.

Etapas necessárias para que se multiplique um número por um fração;
Etapas necessárias para que se redimensione proporcionalmente um número usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um número usando um fração:
Se o denominador desta fração for 0, cancele.
Call "kernel32.dll" "MulDiv" with o número e o numerador desta fração e o denominador desta fração returning o número.

Etapas necessárias para que se multiplique um pair por uma segunda pair:
Multiplique o número x deste pair pelo número x deste segunda pair.
Multiplique o número y deste pair pelo número y deste segunda pair.

Etapas necessárias para que se multiplique um pair por um número:
Multiplique o número x deste pair pelo número.
Multiplique o número y deste pair pelo número.

Etapas necessárias para que se multiplique um pair por um número e uma segunda número:
Multiplique o número x deste pair pelo número.
Multiplique o número y deste pair pelo segunda número.

Etapas necessárias para que se multiplique um endereço de memória por um número;
Etapas necessárias para que se multiplique um número por uma segunda número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda número
Intel $F72B.\ mul [ebx] \ means mul eax,[ebx] but é weird form
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8903. \ mov [ebx],eax

O tecla N/n é uma tecla igual a 78.

Um name é um string.

Etapas necessárias para que se negate um fração:
Negate o numerador desta fração.

Etapas necessárias para que se negate um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $F718.\ neg [eax]

Etapas necessárias para que se negate um pair:
Negate o número x deste pair.
Negate o número y deste pair.

O negative-acknowledge pedaço é um pedaço igual a 21.

O next letra é um letra igual a 65 [the big-a byte].

Um cifra binária é um pedaço. \ only low order 4 bits são valid

Um texto da cifra binária é um string. \ $0010A0...

O número nove é um pedaço igual a 57.

O tecla nove é uma tecla igual a 57.

O non-breaking-caractere de espaço é um pedaço igual a 160.

Etapas necessárias para que se non-destructively redimensione um picture usando um ratio pair;
Etapas necessárias para que se non-destructively redimensione um picture usando uma fração pair:
Se o picture for inexistente, cancele.
Mova a uncropped caixa desta picture usando a fração pair e o left-top desta caixa desta picture.
Redimensione a uncropped caixa desta picture usando a fração pair.
Redimensione a caixa desta picture usando a fração pair.
Se o right desta picture for menor do que o left desta picture, mirror o gpbitmap no picture.
Se a base desta picture for menor do que o topo desta picture, flip o gpbitmap no picture.

Etapas necessárias para que se non-destructively redimensione um picture usando um twip pair:
Se o picture for inexistente, cancele.
Atribua a caixa desta picture A uma caixa.
Redimensione o caixa usando o twip pair.
Make uma fração pair usando o caixa e a caixa desta picture.
Non-destructively redimensione o picture usando a fração pair.

Etapas necessárias para que se normalize um ângulo:
Divida o ângulo por 3600 giving um quotient e o ângulo.

Etapas necessárias para que se normalize um caixa:
Se o right desta caixa for menor do que o left desta caixa, swap o left desta caixa with o right desta caixa.
Se a base desta caixa for menor do que o topo desta caixa, swap o topo desta caixa with a base desta caixa.

Etapas necessárias para que se normalize um canvas:
Call "gdi32.dll" "SetGraphicsMode" with o canvas e 2 [gm_advanced].
Call "gdi32.dll" "SetBkMode" with o canvas e 1 [transparent].
Call "gdi32.dll" "SetMapMode" with o canvas e 8 [mm_anisotropic].
Call "gdi32.dll" "SetViewportOrgEx" with o canvas e 0 e 0 e nil.
Call "gdi32.dll" "SetViewportExtEx" with o canvas e o ppi e o ppi e nil.
Call "gdi32.dll" "SetWindowOrgEx" with o canvas e 0 e 0 e nil.
Call "gdi32.dll" "SetWindowExtEx" with o canvas e o tpi e o tpi e nil.

Etapas necessárias para que se normalize um elipse:
Normalize a caixa desta elipse.

Etapas necessárias para que se normalize uma fração e uma segunda fração:
Obtenha um mínimo múltiplo comum usando o denominador desta fração e o denominador desta segunda fração.
Multiplique o numerador desta fração pelo mínimo múltiplo comum dividido pelo denominador desta fração.
Atribua o mínimo múltiplo comum ao denominador desta fração.
Multiplique o numerador desta segunda fração pelo mínimo múltiplo comum dividido pelo denominador desta segunda fração.
Atribua o mínimo múltiplo comum ao denominador desta segunda fração.

Etapas necessárias para que se normalize um heading:
Divida o heading por 3840 giving um quotient e um resto.
Atribua o resto ao heading.
Se o heading for menor do que 0, adicione 3840 para o heading.

Etapas necessárias para que se normalize um horizontal line:
Se o end desta line for menor do que o start desta line, swap o end desta line with o start desta line.

Etapas necessárias para que se normalize um matiz:
Divida o matiz por 3600 giving um quotient e um resto.
Atribua o resto ao matiz.
Se o matiz for menor do que 0, adicione 3600 para o matiz.

Etapas necessárias para que se normalize um picture:
Se o picture for inexistente, cancele.
Normalize a caixa desta picture.
Normalize a uncropped caixa desta picture.

Etapas necessárias para que se normalize um selection:
Se o anchor número da linha desta selection for menor do que o caret número da linha desta selection, cancele.
Se o anchor número da linha desta selection for maior do que o caret número da linha desta selection, swap o anchor desta selection with o caret desta selection; exit.
Se o anchor column# desta selection for maior do que o caret column# desta selection, swap o anchor column# desta selection with o caret column# desta selection.

Etapas necessárias para que se normalize um text:
Se o text for inexistente, cancele.
Normalize a caixa deste text.

Etapas necessárias para que se normalize um vertical line:
Se o end desta line for menor do que o start desta line, swap o end desta line with o start desta line.

O not pedaço é um pedaço igual a 172.

O null pedaço é um pedaço igual a 0.

O null hbrush é um hbrush.

O null hfont é um hfont.

O null hpen é um hpen.

Etapas necessárias para que se null terminate um string:
Atribua o length deste string A um saved length.
Reassign o first deste string usando o saved length mais 1.
Atribua o first deste string mais o saved length menos 1 ao last deste string.
Atribua o last deste string mais 1 A um endereço de memória do pedaço .
Atribua o null pedaço ao target deste endereço de memória do pedaço.

Etapas necessárias para que se null terminate um wide string:
Atribua o length deste wide string A um saved length.
Reassign o first deste wide string usando o saved length mais 2.
Atribua o first deste wide string mais o saved length menos 1 ao last deste wide string.

Um número é um conjunto with
Um first pedaço,
Um second pedaço,
Um terceiro pedaço,
Um quarto pedaço,
Um low wyrd at o first pedaço,
Um high wyrd at o terceiro pedaço.

Um número endereço de memória é um endereço de memória para um número.

O número-sign pedaço é um pedaço igual a 35.

O numlock tecla é uma tecla igual a 144.

O numpad-astrisk tecla é uma tecla igual a 106.

O numpad-cross tecla é uma tecla igual a 107.

O numpad-dash tecla é uma tecla igual a 109.

O numpad-tecla oito é uma tecla igual a 104.

O numpad-tecla cinco é uma tecla igual a 101.

O numpad-tecla quatro é uma tecla igual a 100.

O numpad-tecla nove é uma tecla igual a 105.

O numpad-one tecla é uma tecla igual a 97.

O numpad-period tecla é uma tecla igual a 110.

O numpad-tecla sete é uma tecla igual a 103.

O numpad-tecla seis é uma tecla igual a 102.

O numpad-slash tecla é uma tecla igual a 111.

O numpad-tecla três é uma tecla igual a 99.

O numpad-tecla dois é uma tecla igual a 98.

O numpad-tecla zero é uma tecla igual a 96.

O tecla O/o é uma tecla igual a 79.

Um offset é um número.

O one pedaço é um pedaço igual a 49.

O one tecla é uma tecla igual a 49.

O one-half pedaço é um pedaço igual a 189.

O one-quarter pedaço é um pedaço igual a 188.

Etapas necessárias para que se open um file usando um endereço completo:
Limpe o i/o erro.
Extract um endereço da pasta from o endereço completo.
Se o endereço da pasta não estiver no sistema de arquivos, atribua "A Pasta: " then o endereço da pasta then " não existe." ao i/o erro; exit.
Ligue o endereço completo para read-write mode.
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "CreateFileA" with o first deste endereço completo e -1073741824 [generic_read+generic_write] e 0 e 0 e 4 [open_always] 
And -2147483520 [file_flag_write_through ou file_attribute_normal] e 0 returning o file.
Se o file é -1 [invalid_handle_value], atribua "Ocorreu um erro na hora de abrir o arquivo: " then o endereço completo then "." ao i/o erro; exit.

Etapas necessárias para que se open um file usando um endereço completo e alguns milliseconds:
Start um cronômetro.
Percorra.
Open o file usando o endereço completo.
Se o i/o erro estiver em branco, cancele.
Se os ticks deste cronômetro forem greater do que os milliseconds, cancele.
Repita.

Um operation é um string.

O cor laranja é uma cor.

O orange pincel é um pincel.

Um origin é um spot.

O osmosian font resource é uma font resource.

O osmosian font source é um texto hexadecimal igual a $00010000000B0080000300304F532F32BB41B2760000013800000056636D6170E2B9EDE9000005440000032867617370FFFF000300008BDC00000008676C79664268E45D00000A4800007A6868656164E4394351000000BC00000036686865610D54057A000000F400000024686D747868C6405100000190000003B46C6F6361A327C3220000086C000001DC6D6178700559021500000118000000206E616D659DA64946000084B0000004FA706F73745544E6B3000089AC00000230000100000001000091EDF0B35F0F3CF5000B080000000000BF91DAB800000000C0031E39FFBAFE4805CC071A00000009000100000000000000010000073EFE4E0043063D0005000105CC0001000000000000000000000000000000ED0001000000ED00DF00070104000400020010002F00420000040C000000020001000102FB019000050008059A05330000011B059A0533000003D100660212000002000000000000000000A00002AF500078FB0000000000000000484C20200040002025CA05D3FE510133073E01B26000019FDFF70000000003E8007F00C8000000C8000001900000025800CE02BC007804B0002F03B6004603E8005D04B00050019000780284006402840064046D0022046700400190005703E80064019000640320006B03E8003603E8006B03E8003503E8003203E8002803E8003C03E8006403E8006C03E8007203E8005A01D400640190005604B0002E04B0005704A9002104B000C804B00064043F002803E8003B0460003C03AC00050460000E03C000640467002104740011039E0006039F000D03D4004B03CD004A047B0022044C003504B0005603E80064051400490403004203B600350453000D038C0036037700280535001403DB001B03690028041D00210258004903200022025800490384004204A9004A0258004303E8002F03EF005A0320002803D400280363002F0334002103E1004303A5005001980064021C000D033B00190161005405350064038A0050049500430341002803D7004302AF0038033B002102A1001E0377003603200014041700360348001B031300140409001B02580042019000490258004E03E8005D043F0028043F0028046000360460000E044C003504B00056038C003603E8002203E8003203E8002F03E8002F03E8002F03E8002F03200028036300220363002F0363002F0363002F0190FFBA0190FFD90190FFD90190FFBE038A0020049500360495004304950043049500430495004303770036037700360377003603770036034F0042025800490320007E046D00210438007802580063049C0078041D008505CB005D0517004904F3006A02AE006B02E4005E04EC0043051400560495005E0564005D048F006404590042048F0042042B003603AC006403B3006B048F005004B0006403E800720319008B0320006A051E001A046C007E04B0005004B000C80190007104600042044C007203E8006404B0005604B0005104B0007804B0006B02FF0042043F0036043F003D04B00056051A0067042B002F04670056063D008C0320005D02C3000701ED007802010078046700500453006B031300140369002804B0005D0438005602BC006402BC006403E5007F0190002F01F400560320005D053C0069043F00280460000E043F00280460000E0460000E039E002F039E001A039E0006039E002E04B0005604B0005D04B0005D038C0036038C0036038C0036019000780320005703E8006502BC007801F4004902C3004903B60035033B0021041D00210409001B025800DC0453004A041D0064036900280313001403A50050038B005704380057039F005002580071032000A0032000AE04B0006A0507006B0578007F03E8007904B0004A000000020001000000000014000300010000011A0000010600000100000000000000010200000002000000000000000000000000000000010000030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60610062636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A009B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AA03ABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBD0000BEBFC0C1C2C3C4C5C6C7C8C9CACBCCCD00CECFD0D1D2D3D4000000D5D60000D70004020E00000048004000050008007E00FF0131015301610178017E019202C702DA02DC037E2014201A201E202220262030203A204420AC2122212622022206220F22122215221A221E222B22482260226525CAFFFF0000002000A00131015201600178017D019202C602DA02DC037E20132018201C2020202620302039204420AC2122212622022206220F221122152219221E222B22482260226425CAFFFFFFE30000FFA1FF5CFF78FF41FF5DFF130000FDFBFDF8FCA0E09D000000000000E084E092E083E076E00FDF6ADF78DE96DEA1DE8B0000DEA50000DE74DE70DE5EDE2FDE30DAED00010000004600000000000000000000000000F8000000000000000000F200F600FA000000000000000000000000000000000000000000EA000000EA0000000000000000000000000000000300A20084008500EB009600DC0086008E008B009C00A800A30010008A00EC0083009300E600E7008D0097008800BF00D600E5009D00A900E900E800EA00A100AB00C500C300AC006200630090006400C7006500C400C600CB00C800C900CA00DD006600CE00CC00CD00AD006700E4009100D100CF00D0006800DF00E10089006A0069006B006D006C006E009F006F0071007000720073007500740076007700DE0078007A0079007B007D007C00B600A0007F007E0080008100E000E200B800D300D700B400B500C000B200B300C1008200BE0087009900E300BF00A40000004E004E004E004E007E00AC011A01A0021C028202A202E0031C037803AE03D203F2040E043A04B404EA054805A8060C068E06FA073807C60844087608AE08E80928096209C00A5C0ADC0B600BBE0C380CAC0CFC0D8E0DFE0E380E7C0ED60F1A0F9C0FFE113011941232134E13B013EC1446149E152C159815DA162C165A168616B416E8170617241794180E186A18D0194619A41A461AB21AE41B281B8C1BB41C2E1C741CE41D401DB21DEA1E3E1E881ECE1F201F8C1FD8201E207820CC20EC213E217821842190219C21A821B421C021CC21D821E421F021FC220822142220222C223822442250225C226822762282228E229A22A622B222BE22CA22D622E222EE22FA233A237023B6244824D024F0255425C2265C26DC273C275C278627E2284428EA295E29B029FA2A442A9A2AE22B362B8A2BC82C102C502C942CFA2D782DF82E562E842EA82EF22F5C2FC43010306430B830E430F030FC3108318631FA32123228327032B832DC32FE3336339833A433B033F63456348234AE34FA3518353A3582362A36363642364E365A36663672367E368A369636A236AE36BA36C636D236DE3702372A3762379637C037EA37F63802380E381A384A38B439343940394C399A39F63A1C3A643A943AD23B183B943C103CA83D163D340002007F0000036B0560001E003400001333173317053332151114071507111615062B01262722273534271127113617111711161D011617143B01113735363D0127232527BF2C2C3420011C24C00C0810193BE02AE67C140C080878080C1EF21C98080C2828FEC420056008080454FEE0AD93202CFE3C15175C0B0544CCAD9301142C01804088FED42CFEE093AD8C08040801D82C1493ADF0040408000200CEFF8F017105FB0011001C000001161511071517150623263D01273537113613161D01062322273437340131401008083840081008294008383B191405FB0732FE367DA172E5390732E5728F7D01DC39FA74083860405C10284C00000000020078030602300582000D001B000013321714071106232635112734370532170711062326351126353437D03F09140838400C44012C3F090C08384014440582601A16FE5440083801B4302F25046030FE704008380198161A2F250002002FFFFA048F04BA0047005000000116150714172127353633161D01173325321714230723151F013215062B0122271517150623223522272623161D010623263D013427232635363B01352635232635363B01263534131733321735262735014F40041C0104040838400424010C270D74CC1C20BA580838201C86200838440818714F2008384028E8400838C830D8400838B418BC38103C800C0C04BA0D27407B6D309440083894301440441010DC0F40400314AF204064E31CE32960400838604BCD083840048622083840767A6CFE24B418047F2D1C00000000030046FFE60346056000470052005C000001161D01071536331615142706071536333437161D01140706072207060F01161706072637222707060F012635343F0136352627060F022227353635363736333736373536333403363734333735060706150517333732373237220701E2400840287589272D537D1C40240C140E161622501403165938280903444162184093801C0C241D6073183B19182C2847192040280A1AF488380C041C406401402404480B0906122D5705600838202C38282338390C2408D0240701083840153B0F3D3C184070958A3F0828964C341C1804083839175C0A067A962F4233045C60502C5A3258143F05847409FD1456490804B01D23713328B07C30241C0005005D002E03A1056200190028003100450053000001161507060703072207150623263D01363F011237323736353605321F0115062326272635343734370716333637352306070133321716171514070623222F01353633263534171514071715071517343735262702CD402C693F5C4807090838400A263C4454061A5C17FE956A1E08414F5448382C6814201C15132C150F01CC20315F310334153BA8180C0B0908840C0408242C053305620838A4A4ECFEB0B84434400838404D57A0011CE844945044DC4C2C40D808382C4441234434DC28213F28063EFE6C40352B202557604C2C4044153F3E76081D0704102C24081848100C1C000300500006044005C2002E0035004400000133321F0115061507161F01333637363316151407060F01161506232235272307140723222F013637363F010335361715173337352603140F011514173332373637262F010138203A8A2420382C2C4404DE4E2A2240403BBD50280838401404B848209F350440486117146C088C2804081A0E7C4C38341781252744301005C2885C806D437462B29CB1532C083829274696406E5A405C5C680C0C704CCE7AA8402002182040B404C8286440FD900EDAC814110B500E227BA1440001007803260114057A0012000013331615140715140F012635363D0127363334C0045010301C400C0C0E16057A0E3A1715F0E9030408383369E4305809000000010064FFB0022005BC00260000011615140702150706151114171617161D0106232227262F01263511343736373637323736373601E04034A044243C23157C0838283854204814401B192636072133192105BC08382B19FEEF0F88761EFEEC885C501C83210440544B5594822E0100659F213B595B44501418000000010064FFB0022005BC00260000172635343712353736351134272627263D0136333217161F011615111407060706072207060706A44034A044243C23157C0838283854204814401B19263607213319215008382B1901110F88761E0114885C501C83210440544B5594822EFF0064A0213B595B4450141800010022009A042204D6003D0000011615140706071537363316151407060F0101170623222F0123061507062326353637363523220F01140726353437363F01352627353633321F0136373602E64018101CC02014403851536401480408382B45D80448201B1D40201C20040B8DEC284098AA4A64D60A08382C3C8024141C04D608380F316860048C1408382E16453348FE80184064F8C15F941C0A32CE7A4A0E60540B05083843213E423004F61610405C90857760000000010040FFC0042004200020000001062B0107131714072235030607232635363B01363F01260336333217133733160420083874D44C044044488A72A04008389465830C28380838430D48E0804002504030FE5440270D740188141C08384018140892010E4080FEBC34080000010057FEB9010F00BD0015000037161532171506071423263D013637353427263D013697680B050C1840401C08281008BD0C3028C04A4A4C08382058346C0719151720400000000001006401C2038402AA00110000011615140714050607232635363B0136253403444064FEE0C7554040083834A3018102AA0838371D081C1C1408384024280C000100640000012C0124000E0000133217161706231407263D01343736C43A0A160E0C3428601C0E01244C1751600B05093F2061174400000001006BFFB002EF05C80017000000171507020F01020706071423222734371312373413363302E7085090045C60440D0B48380824645048CC233505C84008ACFECC38F4FEB6965F097C401C9C011801169E4401B060000000030036000003AE0584002A002E00560000013316150623153332171615321D0107151407140706230723222726272627263D01343736373437343736171533350115141714171617163B0136353635363D0137352627262B01062326353437352306071407060F0101BE2040091B8C507858080C2844745080207C3C17612C182828174D58641B5508FEC02C581C34151334A474240C081C543C6415174040102838401731380584083838046868581C60F030518B3672A41C44065E406C3D7FE06266736D13650943287C0404FDE8E05C5C41530B2D0C1C18874D812744F054472D5C10083830180424200947324AC40000000001006BFFBD038705A500230000011615113633321714230415060723263534373633110623062B01263534333F02353601C740E8602D0B5CFE246E2E0840CC222E7D0B1E1620405C5854140805A50838FB282040402E12181808384D1F1403C47C1408384458883020400000010035FFD703C7055B003F0000001716171615140706072207060733361733321F0132170623222734272324071407232227343736373637363D0134272607060706070623263534373637363702A92F30101F6B1F6611D8391704D7EA0F612C490A05083520344122FEF3ED351F351B3219ADBE1FB32A95A428371D1815193D41622B8B7C054435314F905495A33672F0271D4828203C284030110328641A0A5848282597D709DE7E1472866B8B17351C40140838334D620A56120001003200000396057300420000013332171615140714070607061532171617161D0114070607060723220726353437363B01363F0135342726272627263534373637363723072126352227363B01172102B2402B15205058167A2C3197973D0C30315340BC5421AB407C4B5934D63630443AB248A824EC77351622048CFEA07409030838202C01680573321426264508602F5D16074F63AA4B35226934453321292E083A440F1D2943424F863C60351E0B19264D4C515D0B2F110B1A25430900010028000003D7054000450000013217071506151F0136373633161514070607151615333617363316151407061706070623222735342726270706232227263511363334371615071117253526353437353433020C2B150414040CAC67271940A02DBA340403082D1740342A0B141019472D0B24060AE42E2631271C0C202440100401140C143C05403050404F91D00448311C08384523254C04E4501A132008382B191D1A0E4E204050B2A62808603C24685C0200B409030A3270FDD428740459B383613480000001003C000003C00570005C000001321714230607060714231407150715141715333637363736373637333217161D0106070607060714072635343736373637363D013427232207220F011407140723170623222735263D013437351233343716150607323F0136373633036C270D74F64E804C30240C140410242A366E3246664C51333C0553AA06127E3C4078241CCF010C3C383860158738283C080808385A12140C1F1940401C101351780E46FC5805704044442C4341080B09104C94445C58703056327D174C14588A4278477DB71D1E92210B083824882739DF2D0E1A683D6B609C68315727092440FC346B41803933140144320A083856663C400C1C5C000000000200640000037B0573002C0047000001161514070607060722073237363F01321F01150706070607060714072227222726352227353437123F013637032315141F02331733363736373637323F013527060706150706019040400B29301806060F8C10DC5458241C03371D124E3B3DCC0C244C543C0A0624343C501F11880C1C20309030042A1A3C1C141812010C142E169CDB140573083A1089264A84AE2E7F395A154F74844BD42977585F150C111967764580216587014275B63901FC9B4F457543210C1634318E17697529644A0A133722BD2900000001006C00010384054000260000013217161514030607060F0206232635363F023437363F0123260F022635343736373237032C301414A82E0654594D27181C40131449615C17454008AA667A9E40AA6B4B0FE505403C161A18FEC88B01CDB0A4BE180838923898C912C65E7A7C0B1B30AE083842A031130800000000020072000003620574004E0062000001161514071407060714070615060F0115161F01333437343F0134371615140706070607161714171615140706070607140727232227222F013437363736352627263D01343736373437363736333413140706071516331716173336373637352726270232405C48142C2C14372104239128084858703C406867052F1D495B340838064A132D3C2C405F351A3E14383F414012BE681C173D38422E2D3F2084461A130D10012B7020243C24300850057408383D0B0B051010071D0F112D4704142C2C1C1173228288210B08383068893F32522B811858223664641E622622210B08288868684C78484B152143561A0C611734481D1B390B2007FD45179D7840186C200C0C0D433E864460234D0002005AFFB9039E0592003C0054000001321F0232171617151407150607060706070607220F022635363B0137343F01363736370607060F01232635263D0134373536373637363F013E01011507151633141733363736372627222F0126070607220702AE392F241810100A221C1C0C0B0D3D232880132D7440400838246C3478242420185868297738209C540C1C262D27497F403240FE700C312728046969646E03190F191222485086134F0592686060CA212F10142C68515F0C80C3102F5D1C2404083840240C0C641EA1D9375D6B293F0C32224D6B0C393334B34B433B2D6324241AFD82304C40580C0818684C7E89737C2C2C212F66A40000000200640014017003D0000E001E000001321732171506070623263534373603161D01140722070623263D0136373601041C2C1B091E422014403C15015C380923310F400D272B03D028382064281408386B6510FD94193B403D3730180838206349440000020056FEB9011E034000150024000037161532171506071423263D013637353427263D0136133217161706231407263D0134373697680B050C1840401C08281008573A0A160E0C3428601C0EBD0C3028C04A4A4C08382058346C07191517204002834C1751600B05093F20611744000001002EFFF9043E043900220000052227262726272627263534253637363736331615140506051516173217161716150603BA39637D878CDC2838240180CE626A622E2640FEC48CFEA477CD0894596740080754497354C8100418246349343033453C0838539D404C047E8A78354B08384000000002005700DC0437030C00120028000001331615062B010607220F012635343F01253613331615062B0107230723062326353433373336373603B74040083854FEA290805C40689C0138E12F4040083840E0548C748844405CA49448D44F030C083840301020100838410B181C30FE940838401410200838402010041000000000010021000004310440002200001332171617161716171615140506070607062326353425362535262722272627263536A539637D878CDC283824FE80CE626A622E2640013C8C015C77CD089459674008044054497354C8100418246349343033453C0838539D404C047E8A78354B0838400000000200C8FF4F040005A90033003F00000132173217161D0106070607060715141F01142B0126353734272635343F013637363D013427232207061506232635343736253603321716150623270722273603205E16124A100D634E4AB41034083C084004241854583A6A7C4414DE36D8181C403C2E0126509B5B1D10083818202F190B05A924A05739206F5D612F6A02042E9E38800D274C265A534534343012627A3E147C582C451F1808382B2D21630CFA7D3E1D215B06067D5A0000000100640000046804B80071000001331732171615161D011407060723222F0107232627263536333633321F010623263D01232215141F013237353633161D01363F01353427262726272623342F0123220706070615061D0116171633163B013637363F01161514070623062B0122272627263D0134373637363736373637340270603C50484C3C5030540434400430206C384C182434745A2A08083840145C443C13210838404315042C130507111A12580854922A31434814477962322236705E3A38342440783F15721A809E5A5B69703806220933204C1E4A04B8145480406888208E3E461A400C0C163652967C38385C4008381440722610241C40083878382C2C346B49372D012738090F085026A67E3A432180873140083A121242080838364A20483C2B518B45646D9B015704783B5920240F0000020028FFCE03FC05E5004B005800000116151406153217141F01163B01371615140F011417161716171617321506232227262F012227263523060714070623220706072207062326353437343F0122273437363713363F013437360B0106072207333F0127342735020C402C0D23444C1206108040603048083020041206080838410B13090C1B4928080D539838482222320614081824402430200B053420086C13191838281C6814080701108C8C504805E50A4337501B651287BB2C220A434B0B0F14B120365F27035D224D7D234721CF501E0D190C2E22C07B3B642C0D3B5441197C86303220785B012E44304817AC1DFE69FED63960183039C11683180002003BFF8803B505C80053005F000013161D0137330417321715060714071533321F011615171514070615070615070623263534373635363F01363F013526232627262B0107232227151715161D01161D010623263D01263D012735273527113735361311171532373437363526238340042C0145096810097F342C7183543C08985C3C3C101B1D404C2C1E0E68223A0C052F2735493B908A1817150814100838401014080808087008AC564C28081805C808384C041206BC0446960F2504483C4B2D5064328A5014542A2A381C0A32546011231E1E64283018447C29131C08105060BC4F2D381517304008381C1517448CAC60F82C01802C3440FEFCFEF82C145409573A16300001003C0000041D055F003E0000013316151427062B0106070607220706071407061513171615141F01371732373316151407252435222726272635270334373437363736373237363334373402D018618120340813393F01154F2341203C06042084849EEC0E4F084095FEF8FEFE1468590F50080630402C4C14480F21443C84055F31404E280E100B3B0A45085D0B1E8859FEF7450F1F1D3E3C04042E0A404F2805091C373514722A4E011C58841962473A073D2A40120E080000000200050000038D05C000330052000013161D013320151617161F01161715071406071407140706070607062723170623263537352627361726272227353F01273F0136171507151407151716171637363736353637363726363526232627222726239D4070010457212157241F09142B4830341C79582C5B29080808385408571D1058230D070110143F142116741410180B0D5B677116441D1F3523050C131926520F291DCF05C00838381C14200761304050189C858454112B0A2A30633A1709022440153B2C040E42490A95CC3CE0A0952A4B1575F804602C6B35E4FC318B302B6A16540C13352C5893751D6C43251418000001000E000004160520005300000116151407232723072315071105333217062B012227230723150715161F01363B01173215062B01222723222723220F012327072322272627353723220F0126353437363711372326353437363717363B01173303564058D82CA4381414017C843A0E0838406E56D02C0808102008AF41ACCC48083830171508273DA437B9140C04041052161C100804093F1C4060440408104054174534232DAC2CAC052008383B11080C1850FEF004504010080C2C30FD57446C204040101074040404CC5AF64C20400408382E460F0D0108480838491B0804040C08000000000100640000039C06060035000013161D013305331617331615062B01262723252311140717153637363734371615140F010514071517150623263D0127352735371334B8404001082C286C5C400838646D3320FEF83C09013672A26C58407884FEFE500808384008081004060608383E200C08083840080C20FEC2275D643C150F24100D0B0838420E202C100440C0E6400838DEC0FC603454020C2D0000000001002100000421058C0065000001161514071407060706070607060F0115140706071516171617333217333637363F0235263D0123060F012635343736373637343716151407060F011F011106071407060706071407232623222726272627263D0136373237323F01363734373633343736025D405C2C012738283C241D13102814104438354704325A281963380C241C4C048B2D2440B4313F0F755440301769085C0C0818301B6D4020287845173A1A2E623F510814280E0E0D0F3C431D48391F343B058C0838351F0A0E090F3F153153167E1418193F2B4D906775411B181B252B2D3C68F0462A0C47450808384765200C1923250F08382B152A1A086834FEF84C20244053450D270B0518180A6A7B81112F94605C5464706F050632440913280000010011FFAC04640581004B0000131615061506151117253526031136331615111217153733161514071516173217150623263D01032627052315171516070617062322272637273527220F0126353437363327113437363736E74006040801FF100C0838400C10780840B8180C0808083840240B05FE1904120D10070308383A060414090E302C18403430340C04020C1B05800A32354B5544FEE068421041010B0100400838FF00FEF333082C083848240C8FE19C204008382001B0173D3E04D734854A283540443E6D7134CB240408382B19208401206D4C364A1C000000000100060000036605A40027000001331615062B012215161D011311331615062321263536332111342735262307232635363B0137330246C0400838D434181CF4400838FD40400838014C1C10148CA0400838A0A03405A40838400C534514FEF4FD2008384008384002E032CE34800C0838400C0001000D000003450580002C0000013217321F011617110223220706150607062B012635263D013633321716173336373437343F01352627352736024E453F09032122243E120E0E5C2470883020C04408383E062C64102FAD602830382F500805809524558290FF00FEEC28622A2E2A4036223B2920405432160C5024682020C8E4F75C108940000001004B000203BC0600003B000013161517160722171536133F011615140F02161716171615062322272627262715161D01161732071516071407223F01262F0135363511273727368B400D010409121BFB94404044C8A097CD96224408381E4AC3246DEC081306070B122140440D06030210020A040D080600083846394969FF09010E881408383117BCA020D6C61933254044DF288A3804153F146CD6426A3A312D0B907181B35034B61F010BDB103A4000000001004A000003BE0574002B00001316151407150715031217161715373337363736371615142706230607230623222734270313353735343736B6401810040C1C0F091458BE3B65147C5AAA34604ED01C1A2A4038281804102014057408381C18686C04FE40FEED4D173908041E120E0C2429384207201B1734942B75013401C0106C34601C200000010022000004440554005B00000132171617321732173337363336373437363B011615161D0114071112173217150623263D01262F0111373522072207060F01060F01150715062322352627032723140715070615220F01150623263D0112373637363D0137343734011C353B21130B210729044016120543903018185C0C141C04060A083840140C1014093B1331291F18240C080C08384410446810041C2034060C040838401C1E10140C1C1C05546423D17C8CC464165226722418400E1A1C2167FEB0FED28E844C40083844B6D6B4016C68183C601A6A506C4408087874407450B0014088204C3CC08973F610344008384801568817850E1A58681E563800000000010035FFA303F3059E0040000013161D01161F01141716171617161735131134273536333217321711140711161706272227262726273427222726272635231507111311062326351103113711368140265290840818323E114B1C1C08382E160C0C1C271333453416173719495C151B16DE3C040C04083840040C080540083858056390156B0127295B2044640120016E10300C403848FE8646C6FEE28D7045439C106825700B753005EB32124830FEBCFEFFFE984008380158012501403001304000000100560000045A057800DE000001173733173733161F0116173217161D0107171507171507171514030607060706070607062322272227262726353327353727353727353727353727353727353727353727353727353727353727353727353437363B011615140F01171506231715071715071715071715071715071715071715071715071715071715071617161516171617163736373637343712352735372735373427342726272623350723272207060722072207220723171507171507171507171507171507141715062322272635332735372735372735372735372735372735363734373637363702EE04041C040410364624290F151330040404040404101418104E15614C8C60501933395F25174C0404040404040404040404040404040404040C0404040404243C200440240404091B0404040C0404040404040404040404040404040418281C1C142014695F605D5F30201804040404341805271D2F041C041E76081C0612130D0E1204040404040404040404045008382E16480404040404040404040404041418400745299705780404040406322C38285038380C04041C04041C04040461FEE63F2540854334511B0D28AC5D0F9977041C04041C04041C04041C04041C04041C04041C04041C04041034041C04041C04040453194808381B290C041038041C04041034041C04041C04041C04041C04041C04041C04041C04041C04A52B26121F41232538062E455D970E36013B40041C04041C041A4E1D131933340404043C0553245C58041C04041C04041C04041C04041C04377D1040386B5D041C04041C04041C04041C04041C04041058303C48404C340C0000020064FFE60390060C003400440000011615140714071533363F01331615161715140F022207062317151423151617061707062322272637263D01372635113F02361323071136373637363735262B010607010040181404875D68847C1E0ED0906417891E16040C160C11111C08383014030E0D041014141C164A0C18911F0967D5371428508147060C0838142845170C1C241018181A4A485FB5685C94141C100824CA1E383846403C5D9A962134182D37019488649C70FE9090FE9496061D478E76381C0B2500010049FF7B049D05BF006E000001331615142306070607060F031517151417141F01163B0137323735273427263536333217321F0137363F01262F0123060714072635343F01363B01161716130706071407161716173217062326352627262722270623060723222726273427263D0127353736371237363F010259204064163A6A2A261E381C1008404060643824580A2A804018083829230B415C307A0614146034407A0638405080153F2050506814141C5C60810B290B210B0838583B1917110A265E1A372920EA721A4A20300820182458406B454005BF083844140C47555761989844242C34424A2147322640300488083C2117403C505C40C262B2A5350C450B1A0A083830384408083867FEFF7CA781107C863A261A3C40182837450E26306036027804741626496B142C40908F45011438770D1C000000010042FFC403EA056E00CF000013321733363315373317373332171617150717150717150717150717151407060706071407011617161506232227012227343732373637363537273537342F01062335062307171507171507171507171507171507171507171507171507172317150717150717150717150717150717150717150717150717150716152317150717150717150623263D013727353727353727332735372735372735372735372735372735372635332735372735372733273537273537273537273537273537273537273537273537273537273536338E231D0442325C0C040404986C453704040404040404042C53675B1B180190522E1408382F81FE88301C680E26903820040404F8103B316C1C04040404040404040404040404040404040C040404040410040404040404040C04040404041804040404040408384004040404041804040404040C040404040404041004040404040C04040404040404040404040404040404040404040D33056E291404110404362C541D04041D04051C05041D0404101E318E3B460B0C19FEA45413171B4280014367306E2E3383292104041D0455270511041914041D04051D04041D04041D04041D04041D04051D04041D046F051D04041D045F0C04051C05041D04041D043A0C04051C05041D048832041D04041D04041177096E0D04041D04041D04BA041D04041D043A0D04041D04041D04041D043D33041D04041D0470041D04041D04051C05041D04041D04041D04041D04051C05041D0404108D0000000100350000037D056C004000000116150627060F010623060715171417161F011617161D01140706070623072225273633321F01363F01363D012627252726232627263D013637363732373237360243B11AB66F1547202B400C5942228BFC302C1B353A1E7F4D1F75FEFF09093D1FE5425A30351F1E67FEE1051A2D3340580D2423470F2F30356F056C5F389EB51020243C45533C3C0D0B1A22481A361C58402567394F9404BD20409508366E403F15602B115404141B35215740613343353C3428000001000DFFA3041705440026000001330415161506232523150711140716151706232227352637113706072207062326353437343702A7380120180A32FEFC1814030710083840100E0A14F16D1B352E16406CF20544220A181C40200478FDB471A2774F40407008ABF602A05C140A2820083832360E1C0000010036FFF20350055D0039000001161D010717150717031607060F0106070607232627262F023327113633161D01071307141716171617363F013637323727132735372735360310400404040406021B063A2C3814202040D44F2C4C200804040838400404043C214302B94711241D0A1107041004040408055D08380C04041C0404FD63F016414F5D2D0A0C20437C1DDB6C640402504008380C04FDC4043EB2634D154A0C30441073940402CC041C04041040000100280000033C04D8003A000001161514070607060F0214070607060F01062322272227353727332735372627262F02363332173217161F021533343F01133637363F013602FC404C241C0B0D24281C18280E0E18161A390F0903040804040410281D4F4C200838380C060E505040080824283C0F091311581604D808381779698F174D986C0E3A5E52145C2C1454240C0448041C04A2568898E49C40486CF5ABE02414204C6C010C2355264E941400010014FFF704F80573005800000116170F02030603070E01072627262726272627230306070607060726272627262726272627263726272627373617160F0116171607161716170617161F02363F033617160716071617161F023312371337363704D81D0314080C2A08541E0728384404111F3E0C0A17043A053B292F19353E0E0C183A112C241A1E3B04180C0B01060E383F0604090D20053710022F024C0229190456053216150E383D022003130D161F1C3D0447082A11082805711C3854542BFE4E5BFEB66E3B310307633A89C7510973FEED3A9586273918073D0B7D63554D8319918D311B650128403F050E38340E542E359050136218AC24444301E52CF08BDF3F05065455231F6021857BCB01125801BE5F6E440000000001001BFFF9039B05C9004700000116151407060F01171617161716171615142B0122272227262F01262726270607060706070306070623263534373637363736373526272635363332171617321733343736373633032F405467351430110B3533132148441830240D13212310271517154B1D2030162E5C0F19181C404048283937313F0B49500838331507310D33044C4F3D1D2705C908382C74F52F2844091B256F113F05375C4C3C284418192B14245F411490465EFF00093F1808381B75E044BF3D5D47041B458F154044025E400C6CC3514C000000010028FF81034405A4002700000116151407060F01060706070607060714072635263F013E01272627263D013633321716171237360304405C2C284C2A1A17191A16260140400E452C2E1A1381707C0A327076415F9C321B05A408381E8A5577D47D5F4197455F38CF320A0838C483A87FB726E688123A044074959D01B14B4400000000010021FFD103FC0547003400000132171615140714070306072207061507153605171615140726250722353437343736373437363F0123040722072635343732372403111B21103C20B92C23076560046101928C543873FE68D85C3070552F6E523C1004FEB0941F4D40781B5D018E05473C15171C501A42FEEA7544D87D530404281C2136382E1657042C4412823DAFB070129E6390381B34140838430D203B00000000010049FF1002290648001D000013211615062B011517110711331615062321223D01343711371127353437C90100400838D8080CFC400838FF00A0240C084406480838402C2CFD40A0FD800838403C0C1A2E0270A002B42C602F2500010022FFB002A605C8001700001332171215161B0116150623223526272603272603273536623523CC485064240838480B0D44605C0490500805C860FE50449EFEEAFEE89C1C407C095F96014AF4380134AC084000000000010049FF1002290648001D000005212635363B013527113711232635363321321D0114071107111715140701A9FF00400838D8080CFC4008380100A0240C0844F00838402C2C02C0A002800838403C0C192FFD90A0FD4C2C602E260001004203CD02FE0585001F00000132173217163316150623263526272306070607062326353437363736373637021E37150917382418083854263E04446C3375141440400785584419530585545884181C40191B1AA2404C16560C08383018124A3C40342400000001004A0000044A00A8001000002516151407230507232635363B01372533040A4080F0FE70A02040083820A00190E4A80838430D0C0C0838400C0C000100430460023305DC001000001332171617163332170623222F01263536831D5323813315401408382850A4940805DC481060285C403C785137400002002FFFD0039303E80039004B0000013304151617161D01161506231707170623222F01352207060F012326272627353637363736213334273427232207060714072635343736333603151633141733363F01352723200706070601A76001002C2C1C14060E0C04100838410B080A628B3D5080315F23191B3D7D4B3B013D1C40A8681E4E260E40402C4242269A1B1D2498257BB80430FEDD254E5A1F03E82D3F33A9B53388161A2C68045840683818403F2D0403492454209040891F4432861A1E180D27270D0A324A1A4818FCC804400C08243070B4283C26762E0000000001005AFFAA03BC05FE0051000013161714071506171617363F0136373637363F013316171617161D01140706070607060F01060F0223263534333637363736373237363D01262F0123060F010615060F02060722272627033537362726AC401426160803260B1844262E41431C3C14604D3B1D0B0C200A0A091B164A5C4D833C18204058C04040241612090B20101C203C283428742E1A10431439391A0C1A010C150A0205FE08671CC5FCB2375AB12854DC2D574E1E0A2604104C1448154B40662E13390460167A8C585C2004083844728E53450B5940352F745410141C141CA533A11740824C0F5193800185AC9C12AD4D0000010028000002E80448003D0000011615062B0107060706070607060F0115161716171617141733363536371615140706230607232227262326272635223D0136373637343736373637323702A8400838344434406513123A211F101408141018143824783F3540501E2E295B402C581D07101C340C172133454042322957104804480838401C2B196E0A27494C24605457050C24082C0C1013313705083834184C181040300735294B5C40AB096359182C541C0C401C0000020028FF9C03C80610002D0041000001160703141715173734371615062314071F01140722352627230607062B01223527363736373637363F01171336011F01333237363727352F01372706070615070602EE5C52180408603C40142C94280440441408043ABA3B1920C4280D1F30300F314E42726A212EFDF9184020089E4268040804040CAC2080402306104F45FDE874A4887C2427090838600533C4242D0B641B651DA32C6C99AFE34458172948303B0B01BB98FAAC702A7D3245043080A07C571137711764CE00000001002FFFCB032B040B0051000001333217141F011516151407060706071407060F012635343734373637363734273427232207220706070615111417163B0136373637363736331615140706072207062B012227262711343736353637363701B780354B30044078063E555F58015710406C6008554348282C58243C132536222438254F0C1B5528403309272940454F300F752E1A20B636380858582523194F040B7C1476180C08383F15091733150C0C090F0408383810110B0B10202527315A24485027834A1AFEE23D2F100F2613311249400838256046283D24505050015029C36C1430103319000000010021FF6A031305D1003E0000013332171615062322272227230615061507173336333615060F01220715061D011607160306232637362736273537060F012635343727363F013637323736021B2461175C08381D2F0A12405450100E04644B8C0845532E710C0E0106041D6038250B0905060442421840E40E14081C23350B393B05D11C2D33402C102D075C80509216213F40140E1604251F2C71A475FEF168367993A88C8B243017310408384B49B6625A4C3F45242400000000030043FE5503CB04390046005800710000013217161507161506070E01070E013315370516171417161D011407060706070623222723222F013534373437363335263D013637352227262F013437363732373335262735360115163B01363736353635342F01070607060315161733321F01333237363F0135262325272306072207140246216B180C440C4834503C50071C14010C3933402C282F5124382A6A3E8E405983081C883014100714294F3F15047C6779147C04460A08FED862222C255F44443408C83D2B50233D2F1831933C040E2E7F35104F15FEF804044C3C2D4F04394C310F30364E53F13C29073A460404040830094F3C1C205F35412B19133C249424406117286C18041517202632044C273D4C3F895D1B240424201040FDF41C5C0C0C2507F01C0E0A0838212365FD59544907200428353F2834780404111F640A00010050FFB7035805C3004A00001316150F011507113237323F013637363736331615161D01161D0107151706070623263527323D013437353427353427230607060706070607060714070607150623223527263511123736C840240C080B090D371C2E22113FA421602C140C1B090B181C401B080C141404195B412C07150A16181050081C08384004100A220B05C30838909F3480FDCC3CC0448937342828142C4F79146B41A04C54DB021E180838CF1430393394445C203D47074019940143095B4C182484028348405CA1224A02800181327000000000020064FFDF010805B800140020000013161D0107111715170706232237263D012711363337223D01343B011615071714B0400C1410100838471B1414062E26443C0840040404000838204CFE944C74DB2E40C5663250500164BCBC740C800D274C4C270002000DFE7001BD0540000B002C000001321D01142B01263537273413161D01141F02151407140706232635343736373637363735342703222735360121443C08400404404014282060A0452B40343F4D12262A0E1C300907080540740C800D274C4C27FEAD0838203C48E4DCDC877530745008382B194731104C2A4EE04583011880204000000000010019FFBA031D05C70044000013161D010615111733363F013437323736333437161514070623060706072207321716171615161F01062322272227262F011514071407062F013637363D013711343735368540010404261E1C5809671D1F5440382C2C294B1C200D23165E4B0DA92B2108083840801E5B2B55611308104D3203141301010805C7083840EB7CFECC1C17311819475014141808382E16282A2A1C3434705C23D1263F1D2040FEAC1E6230543A8278643C023B43889236588C01407AF93440000000010054FFB6011005AD0015000013161707110615131417062322273703343711342736A2402E1814040808384616140414021505AD084560FEC03F3DFDBE38D440A0B002464242011067561000000000010064FF7B04E203D400530000013217321715363734373332173217321711161707263F011127342723061506072207151407142326352637112735232207060F0106070607160706232637352635262711363316151114173637323736373637025488180903386C28602A360B150C0C140A62631B0C182030990C04100F0C4C400410084C34540A1E181C1418101414083868281C080C0838400C140406420D1F4F3903D44C24302C100B05506048FDE46A503738594C022448251726360D37A4A011567E0838743501182CF094054B6C2C5C851767394014C028315793290140400838FECC1D0349337C063A5E0E00000000010050FF96033803F2002E000013161511373637363B013217141F01161314171407223534272627263523060706070615140715062326351103353690404C48443E1E203E2A3424202C084044400F1D3C046E3E182C3010083840080803F20838FEE88C6B3130781A82C42BFEA79D2B2D0B70EAF613C1862A4A961A8659372212F440083801B00100D040000200430000043704140025004A00000116150733161F011615161D0106071407062B01262F012627262726273534373637363736330115141714171E0117333637363F0135262726232723220F01263534373633272307220706026B600454753B4018141C28708A2A807867613E32172121034046724C0C5D3FFE94283C2856B664644C1420141804520E2C44085C3840482616084C6C2E86200414093F1C1E4E582A3E155B608C303D6358142E3E2C4C095F352F80228A644C270D40FE246813491C3C3C3A261D5F3C34547454286C144C0C0838380C300848882F00000000020028FE4D031F044A0027003A0000131615140F01153637363B011617161115060714070607062716071607262736372736351134373613111716373637363734232627230607060706D240280810717464144F552C2A3A4C2E777E6E061B1B4F5701100D3222381C2C04817C6937171D2C171D1C5728384C48044A083810603C04183A6C0F6D2EFEFE0CDA47105C2A524F22CE7478231948AED649396601B065C358FE60FE2C3022635A6A20A9F81E0E2B243625440000010043FE4E03D6043C004E00000116151407220F010607060F01151417163B0136373637363D0136373633161D01140714070615070617363F0116151407060F01232227263F0123060706232627262F01353437363F013637363334037340701E32B45048A03C08B40E1A1477316E1614121E291F40382018271B3517351C40182E375C0C39132C1B27041C802266A828412B1470293F9850A45C54043C0838410B285024304D8F701467250C245081872D1340761628083820119715633FB1E7D2A035440408380F313F350E907DEAC740402027211C585020CC64342C582C44440700010038FFC602A80426002100000116170627060F0206170615070623263537343734032734373215173637363736020C7E1E3478800C541C1911090D0838400D0524184048101B1D2490180426246A6B717444982858988D485B4008385B33BE310147E42D0B8C84184C5E7216000000010021FFB1030D042A003900000116151427060F010607163B01051617321715140714071407140706232227222736333217323736373437352723263522273534373637363336023B4D913B9D1C2E342F1984013C41130B055E58246C42421246320A08382A3A1E52364E46F0C07831135629977A4E27042A3638441E066E1876401804192B284026B11B3108241351282840402848522A0F981C040B1D6020229062524C14000001001EFFB00272057C00300000011615140711363B011615062B01220714171417061F010706232237222735263726272637062326353437363311363736012640106E4E20400838206256050F0312070D15384B2007010E020C04101367194038641C100418057C0838462AFEA41C0838402427A55D682F433D6E8AF41C300C902D871C644408382E16440198324A2400000000010036FF95033603DD002F000013161D010715161F0136133727353633321715071715141714171506232227222726352302232227263D01343F013536A640300CB828296F200408383F09041C281808382E1609171C0462526BB96428080803DD0838C0C0C4495F10510153604C60406060489850AFB1352F084038B47E62FEBC8C51778C467E28B4400000010014000002F803F00035000001161514071407060F01060722072317150623222726272627222726272635263536333217161716171617161734373637363736373602B840283C1C1814190F0B09040408382E161E2A1834112B3014303408384020130D240C261E363228243C140C0B211803F008381E5E49BB557B541E6234140440380F3D0B5178453F475D8C1040943B553335265E5B211E5EBAAE496F026A1800010036FFCE03EE041C0047000001161506150207060706070623222722272635262723060F01060F0115062322272627262F01353633161D01163317363736373637363F01363332171517121F013336373637123303AE4030380C141C26121428390F0F11380C0C0414183854100808383D0B1C380B1D1008384009134035131C101F050E0E10152B3B1928281C0C042008181C2F19041C083BD838FECF6E61537A042A587EC63D2686306B8A933F082E436083A72F3EB08643093A86ACCD51452B5C5141179558326037C4FEC44E37946355E60108000001001BFFDE032B03F6003100000116151407060F01153217161D010623222F01070607060706070623263534373437363F0126272635363332171617363736029B40701E32080AB65808382B4DA440334D2329162615174040682B4D2C6448540838126639573D632503F608382E561F790804A0531D04406488604B99217317491008381E621FA1626E48541C2830403C1D439F3D380000010014FE4802F103EC002A000001161707060F01061507020F01062326373436373626272627262726273633161F0114173736373536373602B73901290814251824462424181C4007242F18242835633D59200D0838545BAC3418141D141E1803EC1552662283BE3C50C0FED46E761808600F64E12173305E8641C124304014E2F41044985A903462626E0001001BFFC803FC0421003B00000132171407171407060F0114070615373637361734371615060726070607060706232635343F013437343F02060F01060F0126353437363736333402DC2D0B0C043C712F3C6C20E0063E7469246F0E59545AB8AB2F55201440404074487018735A5815A318405C5ACE955C0421461517272521E1495C0FB23E0D650A193D080A03093D501F372964472A2016093D36637716B8106ACE35312834045605093E30411D69540D0000010042FF3E01FE0642003A00000133161514230615071514171617161D0114230715161507140F011F011615062B01222F011233373427232635343F013637352F01263D013437360192204070880C381523101C245C71141C429340083840A42849230D71286040543010182C401450A806420838443E0610347947443C2311207034084CBCA00F29D074140838408292010C9079270838390F2C261A30608C4F49403642540000010049FF74012D063400110000131615111615140714072635112227343734C54028284040320A2406340838FA5C1D231D43320A083805B440113F230000000001004EFF3E01FE0642003A00001723263534333635373534272627263D0134333735263537343F0127232635363B01321F010223071417331615140F010607151F01161D01140706AE2040706E0C1D1623101C245C71141C5D6440083840A41B42220E71286040543010182C341444A8C20838443F0510347947443C2311207034084CB6A01028D08E08384081A0FEFB9073270838390F2C261A30607F4E4A403550540001005D0168037D02B40026000001161D010623140723262F01262B0106150623263D0134373633321F0114173336353235323736033D40251B5C606B29305622105C1824407036227527903C4C140807051802B4083820AC2319112B2450434D2408382033713030700709251F144C24000000FFFF0028FFCE03FC07060222002400000003008E009D0145FFFF0028FF5D03FC070902220024008F000300D500A50198FFFF0036FE5D041705CA02220026FA6B000300D6016AFF8FFFFF000E0000041607060222002800000003008D00A20152FFFF0035FFA303F30711022200310000000300D4000A01CBFFFF00560000045A070D0222003200000003008E00EA014CFFFF0036FFF20350070D0222003800000003008E0070014CFFFF0022FFD0038605C802220044F3000002008D5C140000FFFF0032FFD0039605BA0222004403000003004300AAFFDEFFFF002FFFD0039305B2022200440000000200D357FA0000FFFF002FFFD0039305780222004400000002008E74B70000FFFF002FFFD003930589022200440000000200D4DE430000FFFF002FFFD003930599022200440000000300D5008E0028FFFF0028FE5D02E804B302220046006B000200D6388F0000FFFF0022FFCB031E05A702220048F3000002008D33F30000FFFF002FFFCB032B05AD0222004800000003004300A0FFD1FFFF002FFFCB032B05B8022200480000000200D331000000FFFF002FFFCB032B057E0222004800000002008E48BD0000FFFFFFBAFFDF01AA05AD022200D2F3000003008DFF4FFFF9FFFFFFD9FFDF01C905A0022200D200000002004396C40000FFFFFFD9FFDF01B605B8022200D20000004200D39400333340000000FFFFFFBEFFDF01C20571022200D200000003008EFF60FFB0FFFF0020FF96033C0582022200510000000200D4BB3C0000FFFF00360000042A05C802220052F3000003008D00D60014FFFF00430000043705CF022200520000000300430112FFF3FFFF00430000043705B8022200520000000300D300C00000FFFF00430000043705850222005200000003008E0112FFC4FFFF0043000004370589022200520000000200D443430000FFFF0036FF95033605A70222005800000002008D66F30000FFFF0036FF95033605A0022200580000000300430093FFC4FFFF0036FF95033605B8022200580000000200D338000000FFFF0036FF95033605710222005800000002008E57B0000000010042FF95030205B5002A00000116150F01153733373217142306071715161315062B01222734373503273507232635363B01373534373401CA401C041404C82D0B708E1A040C40163A083F0920400CAC4040083840A82405B50A32883CE4041040440C0814049EFDE244A0601A264002348C081008384010F85B752700000002004903CE020905A600160021000001321732171617150623062322272627263D01343F0136071514173F0135342707060161231D2E162103111B2A325771243C105458356198200828403005A62838382C40785C2C03411652202D473C30F4300E26342C281B352C16000001007E003C02A205280031000001161D0133161506232227230607061D011433143B013237363316150623140723150623263D012227263D01343F01273536019640505C08381A16205262408450143B15151740183068180838407A461CC01C040805280838CC193B401411776A52283C082C1008385C0D13F0400838FC58332120E4A01444C84000000000010021FFAA041D058A0068000001321732173217062322272623270607061507220715161F012533161514072207171506070607220733173217161F013326353633321F01151407062B01222722272627262F01232207062B0126353437363732373523072326353433363727342735363336373637029962261F2D1B0908382636290F28AA16543010081A1A2801040840701B89040913211F0606346431B33F2D2808140838313B043820202014701040285C1B790864202C2117204094283C070904CC204064088428301B1D171D4296058A243C38403C180409171937443444223E40340838410B201CA05D172D3F1020683A0A18161A406014202E16243C302626161A0830180838317B2173449034083844081C4C0C4C707C1D43512300000000020078FF88039805B8004B0060000005262726353633321716173336373526272627263D0134373637352635223D01343F01363B01321716150623222F0123220F0115163316171617161716171514231407151615171407060714133427262F0123060F011514171617153637363F01021496461808381D2F235118625E52C656C64C70445C40084848614F1C4147280838263224084868180D1B1D7B028A6404160E1C6C6404607D2BA89C0C380C808E1610386CC40C581B3504781A42181C402C160E2890344C48156F4F9920384C1C1004365A1C402D633440442C1C404408583C24641947084C5820175140701E3204453334625E7D070C02F45854090B0C1523100C83113E42040C041814040001006301CF01F3038D0012000001333217161D01140F0123263D013437363334012425463F2545459373402A37038D454834504E46190C702380375E09000000020078FF310424059D003200410000013217361707151714171106232635112F01112307151615161503110623263511343734272326232227222726353437363736011417161732173503350607060706030C76224D0B080828083840280888080C1C0C0838400C0C14682C3F4D3480207C32BEADFE6770451F554F0C69672B3140059D0804404CE8EC40BCFD5C4008380294F0FC01041CF0ADB78D4FFEF4FEAC400838014039E73349242C983B79AC44355738FE608A5A190F2004013CF4164214282700000000010085002103790551004B00000133161516151714070623151617321F01150607060706232227343336373637363D0126232627263534373637363537353427262B010607060F01111716150623222F011134373637363734022D20745808902616715B2B29040953CB71E1432D0B64C672B410140E224167A0341E5E6C04300828383B45274510182408383B2918582D1F6B29055118185321507E5E28042F499C3C604B558B194040442C2C691F20107054442016462A1A34205C10101C311F18122A0C5828FE7C74261E407480016486463A0A4404140000000004005D003C05490558002500480065006E000001333217161716173217140706070607232227262726272635263D0134373635363316153334150623220706072207151417161F01163B013637363F013403272627262B012207263517321F011506230607231F0132170623222F02150623263511343334171533323735342B01033920607C4F1D7E120F09381A828662A0959B38942D2F2C0C789C88403C04053713C57507090320153B60B4809C70901632046C2010783038281E4E3C3CB232141C241C6404745C281808382B6D445C083840641C0436726440055890403CF8949C824658585E12500E7E22523A0E2B3D80AC84A60A8C0927606848DC734D3CA8361638344C681983137544900104403A5E48180927E86440205C20185C485840743040DC4008380240440787643404340000030049005E04C50532001E003B0059000001331617161532171617161716151407060F01232227262F0135343736373601151617163B013237323736353427262734272627342723220706150625321506232723061507151633163B01371615140722272227263D01343702A9205692301D3F37250B1110B459A78020BBE931470C6439CB83FE952745C0683482562884302439532407694428466AC85401A4A00838401084107739163A082C40605E4633A11C6C05320A56291B685D6711634F41E18B53350C941B8930C089A37DBB48FD68C46F21683C9041735E7E9769150F15270E0A40D72590945040101D1B101880180808383F0924A423194031570002006A031304760577002600420000013217161715062322353427060706070623222F01150623263D013437343732171417333637360533161514230623161D01170623222722032707232635343336333603C2430D491B083840401C08090B181C2341240838404024353720043C1C18FE442040701B11101408383A06130908642040706A5617057780EB9124405C18E41F35021E18481CD8400838E0763A0903580B19725E1808083844107583246C4044014C2C10083844140F0000000001006B0438025B05B4001000000017140F0106232227363332373637363302530894A450283808144015338123531D05B4403751783C405C286010480000000002005E04E5026205C1000D0019000001321D0106231715062322273536071615140F0123263D01363301EA78050B04193B3B150BDF4C54182040155305C140042804105C5C40400411372F410408382058000000010043FF24047B0474003E0000011615140F01331617161506232723060717331615062B012F0107140722070623263534371327232227263536331F013317132325232635363B01053337360377402C4434A147180838CC501448F84840083840D854443807091B1D40285C04D073791408388040906C6004FEE0C0400838C00120245434047408382028BC161A181C402462CE1C0838401808E8198B381C0A322F5101280438161A40240404012C1008384010E85800000200560064049E0524003B004200000132151733253332171423072315161F01331615062B012715132116150623211407263D010335210607060F0226353437343F013637363736373403333427060F0102824004200144042D0B8CF40C3014E44840083864B4240108400838FEF0384024FED4432D101C3024402458504B31333D2B0978D4401A265405245C3418404810049587040838400410FEA40838401A0A0838600160049C40125A4C080838163E2490AC8F4570643F452DFDCF37D1225A880003005EFF24043A05F00042005D0071000001161D01060F011714071516173217161D01020714070607062B01222706151407140F01263534373437343F01263D01373437363736373637363B01321F0133363736011514173637363736373437363727262B0106070615060706150601140F01060F0133363736373637363D0127262703CA402430140424311B1133281329500D67AA36804A1618284C204030281C04A8283C181C10249B294315402F652804420618FD386C3B593B310D4F1C2222046D1B245A2A50210F5018024864502C346898347843112E261848172105F0083820802828241F1104393B783E1A60FEEC1C16863359540C290F0B3D27510808381B3D183C1A2A187FBDA0B0498728580F5DAB0120441C505C24FC4CA8615BA5C3D23A377D0B295127045017413E323838906C3A016A0AAAAC9F69FC04403F3943618A42548C1147000003005D011E04ED03BA002D003C004E00000132171617161F01151407062B012627262706070623072627342F01353633343732173637343733321F013736331706070615161F0133323735262F0105231514171417323736372627230615060703954A2E8004282C084C415B204C64702C521E622A3C5C50500818282C1C185F3530404C341878451728412F3852823028441027356CFD48104450263622523814286C293703BA448C20443420602E4220073948545A425C081B7112AA2860580E06182E0205076C28804C7C3F3D2818833108203C256F7C8014108C243C443D5F6D13130D0B210002006400000420043C00230036000001161D01253316150623222723051407150623263D01343F01230607263534373637353601331615062322272322070607263534372536022840011C405C08381A162CFEE428083840200804E35D406823F908018810600838171504B1DB77AD4070016068043C0838C008193B401408817F40400838203A7664181C0838410B0C1CCC40FCA4153B4010300C240838410B381C0000020042003C041603F0001E002C000001161514070607060F02041716150623242526272635343F013637363736013305331615062B012523263536031E40346B3D6854702401E3911C0838FEDBFEF5765A40749884204C486EFDC2C00180E0400838E0FE80C0400803F008382B19681C68204C201C181B1D401C0C14180838392B684E1A482870FCD40808384008083840000000020042003C041603F0001E002C000000171617161F0116151407060704052227343736252F012627262726353437001714072305232227343733253301646E484C20849874405A76FEF5FEDB38081C9101E3247054683D6B344002A00840C0FE80E0380840E00180C003F07028481A4E682B39380818140C1C401D1B181C204C20681C68192B3808FCD440380808403808080000010036FFC403DA0584003C000013321516171633373637363316151407220F0115331615062B011517211615062B011711062326351127232235363317333527232635363B010027353676442672B50BEC23511513407C105C8CB8400838B80C0110400838F004083840088CA0083840900CC8400838ACFE9D31080584645183ACD80C6C0C08382D73607C0C083840047C08384050FEA040083801743C504010047C0838400126CA20400000010064FF1D031C03250030000001161D0116153217161506232227222706070623222723031423263D011332373637363B01161D0114173337363F013536029C40140606200838331D0A062020342C5038046C4040680A0E2513093B04402C044029130C080325083834739D30281C4050241F3D4460FE4C50083820019CE09527640838E08C2064417748344000000002006BFFC4032F04900028003900000132171615161D011407062314072322272635343736373637332F01262B0107150623263D01343736131433163B01323F01352723060714070601A3833184543C465230205A8E38440A724070243C342F2114C00838403C22A21C583808582C0C0C346F5D2810049060EA46C9A760B0486805078C2692924A264E1F19B46C600850400838602B2D20FC786460688460800C500A362200000001005000570410054B0038000001331615142304231617161716151407060706070607151617163B011615062B0122272627263D013437363736373637352726272635363337039C204064FDCC2836AA5C5C60540864497F327A63FD7FC13040083830C28EE458C4A04E52564A063E407DAB80191BCC054B08384494305C4430442C3E060B25255B0D7F04231D280838402820143A2A1039834C24461E0917042057616034542800010064FF95044803FD0028000013163321363316151407061D0113150623263D01033534372122270711100706232635363511363334C8AD5301B44D3F4034140C0838400C18FE3045830824161A4014101403FD241008381656497B24FE70F0400838F0019010A74D1820FE4CFE8E3A140A32A2E201C08C0E000000010072FEE1035A0651002D0000013217140F0106070607061511161511140F011407060F012635343736373637363F01113427113437363736373403222D0B4844035D40180820183488365A184048063E0F590D2F0C205C3F292054065140380C38174558801222FE987F6DFEE0581C740B8515470408382C280E1E045C027E0C014C627E01608BB9570D37391A000002008B035C02A705C80020002A00000133321F0115171407222707232227263D01363F0133161735342F0123072635341315141F013332372623011F60C23E240440301C3840693B74134544A03913581C7030404C6024481D070E3205C8A08C709C270D480C28275528720A040810044B29040C08383EFEAA180D23040C400002006A034802B60610001A002C00000132171417161D01062306072326352627263D0134373637333536171407270607061D0116173317333237352601B6343850442331313360942666147018701408403818333120452B242C44390F19061050155F932580A025070F15156B290F609E5A22260C40B01A0A040A3E2838644A1A085C647500000001001AFFD804A6042C00470000013332173217161532173217151407331615062321263534373637363D0126272627222722272307230615071516171617161716150623212635363B012F023534373637363B0101F28017212765940616090350C4400838FEA040382C18300C1808640E3A2A12604C4C3C402A2202562F15280838FEA0400838DC683430480844296B14042C184C995FB824C024B808384008382E16184C651BA425BB33752C14102C0C5CC0B632156F38301428400838409078BCCC394F2C30300000000003007EFFDE040A03FE003F004B005A000001321F0233363B0132171617151407060F01141F013633161D010623222717150623263D0107222726353437363B01373326272627230615142326353437360115173336353735232723220123151417163337353427342B01060172363E203004502020B6361008241C5C98A4581123400838BF6D0C08384080647C383C2014344C601C301C14185040406422015E0410C4140480140BFE77107C1513601C08643303FE503C783834133940153B4329202282141C083820407894204008383408A03E722B2D140CD547440C13654808389D372CFE7048141937202808FED40C3B690C080C3C68100C0000030050FEA00428051C0033004200550000013316151407060732171617161D01140F010607062B0122270306232635343F012627263D013637363F01363733173337363736011516173613373527230615061506250307151F013332373237363F01353427263503C8204044385021271D37302C382755A523402D73C40D3F4078703F59180C1407318413AD60401458323E15FD53224A71872820448C642E0206C8745C142818842C300A2E045438051C08383A06448C783D4F4F6160144C6848244848FE886C083845CFDC1F6D181CC0571D235980191F10944E460CFD28983C30D001144408081715541850C4FE7CD80830043C60076504702B75700C00000200C8FF4F040005A90033003F00000522272227263D0136373637363735342F01343B0116150714171615140F010607061D011417333237363536331615140706050613222726353633173732170601A85E16124A100D634E4AB41034083C084004241854583A6A7C4414DE36D8181C403C2EFEDA509B5A1E10083818202F190BB124A05739206F5D612F6A02042E9E38800D274C265A534534343012627A3E147C582C451F1808382B2D20640C05833E1E205B06067C5B00000000020071FF8F010D05FB0011001C00001627112735373534373217150715171114070235263536333217151407950810084038080810404814193B380840713D01F6849879F234083CF279AA85FE1D3508058C4C28105C40603808000001004200FD03EE0305001400001321053316151417150623263D0127232521263536820140018060400C0838400C20FE80FEC040080305080838859B6040083860E0080838400000010072FFD803E605AC0031000001331615142306071423161D01030623072227262726272306151423263D013437363F013217141317333711340335343736038620405C21C71834041030143F290C503A1E04544040445721203C20800C040434D08405AC0838400B0908E9FFC0FE2CB804940FD56761DB214808382013C1CF0D085C32FEF6243C01BCEB010520590B04000000010064FF4603A00642004B00000133161532170623222F012307140F01140F011517331615062B012715061506070607060F012322272635273437161D013217333736353735343735232635363B013534373437343736373602EC20800E0608382418240C28441C1C0480044008380480180A12294F0F4918401D53180440400E12183C4C14147C4008387C20204804542E0642142C2C4024083C175D7C2C68408C0408384004345FD110DC6F552A2E04403014242D0B0838101050429A9C54416B280838408C596739671F69255B180000000002005600AE0469032000240049000001333217163B013237363316151407062B012227262F01230607060714072635343736333413333217163B013237363316151407062B012227262F01230607060714072635343736333401A560334D6038781F25242C40543F396071471F551C7C10302F353840703C346160334D6038781F25242C40543F396071471F551C7C10302F353840703C340320446844440838206C3C3C14540811072F191A0A0838383C3C14FEBA446844440838206C3C3C14540811072F191A0A0838383C3C140000020051FFC50431042D001D002E0000013215161716171613321706230F012307230607232635343713363736371706070306153337333237262726272627023D441A323C7037710B0514406C809080D44F25084040A44440035D0434408C20E480A4761E494F5E364A02042D707E423DEB41FEF1285C1004080A16083818980198D9672375E85DC7FEA44A0E080CBF71C53F6729000000000200780000042C03F0001B0035000001161514070607061516171615062322272627263534373637363536051615140703060716171617161506232227262726353437133603BC4044693784C672600838206859BF44A435475408FEB04034E41C3806AA462E1008382D9F534D184CF84803F00A32465285639B11856B23354048578133254AB65D5B6C14401008381C38FEBC1C580B853F19151740903A4A28141C64016070000002006B0000041F03F0001B00350000001714171617161514070607062322273437363734272627263534370417131615140706070623222734373637363726270326353437011308544735A444BF59682038086072C6843769444001B848F84C184D539F2D3808102E46AA06381CE4344003F040146C5B5DB64A25338157484035236B85119B63855246320A1070FEA0641C14284A3A90401715193F850B581C0144381C380800000300420013029A00BA00080011001A00003716151407263D01361736333217062B01260526353437161D01068260604008D4153B3B1508382040013C60604008BA153B3B150838204060606040080F153B3B1508382040FFFF0036FF6A040A071A022200240E9C0003004300FD013EFFFF003DFF92041107170222002415C4000300D4003601D1FFFF00560000045A0703022200320000000300D4007401BD00020067005704AB05330039005800000116172116150623211617113337331615062B01072327230607060F011721321D01062327212723062B0126273427263D0137363F01363B01341714070607060722072207151633161F01333635363736353635112623262301D34D5B0170400838FEE01424C02C40400838342CCC040418100B211008016CA00A3264FEC0800C5020405662442C1C090B4C64480C2C38511B12160705070118143C242C241C3F0D3C1C3729261E0533064A083840247CFEF40808384008045765095710083C0C4008083812760D5F6C5CA0900864C8981B77121A597F23894C14A48C661A1C0C0C3E265A524F550110BC400003002F005703C303A7003300430050000001321716151734373437333217161D010607062B01161F0236331615140F0122272635230607062B0122272635113437363736170F0115161733323F01363D0126233425150733363536373534272306014B1824741C702C60424E2026324C2078253740281424404C2C619B2004175536661C246C48382448403080141C481813213C1C160E01041068301014304C3003A71C59232066360E064C392320873D3C93293014200838322608AC3B11573D60504E2601002F692C7C4888C844E42D2734382A1AD4641F0D306818240C48042410180000000001005601AA03F6022E000B000013172116150623212722273486F00240400838FDC0EC270D022E0408384004402B000001008C01B905CC02390009000013211615062321263536CC04C0400838FB404008023908384008384000000002005D037002A105D8001C00300000011615140714070607220715373316150623222F0135343734373633360516151407060715333217062322273536373633012D40302810180C04041040193B41330C242C3F0D2001484050160A083E0E153B5B29281C442005D808382B150A2E1E5244640408385C5038605E4623495C141008381C684B0D78605C74D07E2668000200070341024B05A9001C00300000012635343734373637323735072326353633321F0115140714070623062526353437363735232227363332171506070623017B40302810180C04041040193B41330C242C3F0D20FEB84050160A083D0F153B5B29281C4420034108382B150A2E1E5244640408385C5038605E4623495C141008381C684B0D78605C74D07E2668000100780333018405A70014000001331615062307061D013217062B01222F01343736012420400838301C4014093F204C1C04581F05A70838407046661C5C608C4CAD9B54000000000100780335018405A90014000013232635363337363D012227363B01321F01140706D820400838301C4014093F204C1C04581F03350838407046661C5C608C4CAD9B5400030050003C03F003C0000A00150021000001171615140723222735360117211615062321263536013217142B01222F0134333402106C2054283B1508FEB82C02F4400838FD00600801E0361A44202F25043403C028151F621E5C4040FE8C08083840093F40FECC786444147C0500000002006B000003C705880028003E000001161D01161716171617161F0114230603060723171506232227262726272627263D0134371237363717060706071516171615161733123735272627262F010247641010251F1E461D27101C4157150B04040838373D224259335D1B6C48FD0361170823612E86501484356F0477452C156F17351405881252381331315719734335387065FED92D67041040781D6F815F5F417616084430012B259612C8537142960458309C2041B701924A18543B8D47592C00FFFF0014FE4802F105770222005C00000002008E3CB60000FFFF0028FF81034406FA0222003C00000003008E006801390001005DFFDE04550572002B0000011615140F0106072207060706150607060714070607062326353437363F01363736373637363736373237360415402C6C2B39085820107059171C54742C041B1D40445E6648521638243E322739164E072125057208381937D03769801B319A0E55372F61097F342C1C083835576682705335375941532D6B0FA94430000001005600AD03BA050D0042000001331615062B010607060F0121161506232107211615062321141716331417161506232227222726352635232635363B01363F0127262726353633173336373633363702F640400838343A564C2820019C400838FE282001F4400838FE00B4304C441C0A3224385662903060400838640616040454442408388C28104479332E5E050D0838400133264A4C083840600838405E861C0B0D1B1D4014507F1D395708384001570404100418244010119F84290F0001006400A0023C039400190000011615140F01153217161F010623222726272635343F0136373601FC40A890226E77210408381F4D4157886C685A2A15039408382FD1800468442C18403C25533E3E2B555C71473000000001006400A0023C0394001900001217161F01161514070607062322273736373633352726353437CF152A5A686C8857414D1F38080421776E2290A84003943047715C552B3E3E53253C40182C44680480D12F38080000000001007FFFF9038305990033000001161D01133336331615142307231617211615062321121D010623263D01340323223D013633173303232722273633173503353601BF40088C3339405C449009130118400838FEF8340838403458A00A3264441804D42D0B0B2DD008080599083820FEE40C0838400CB15B083840FEF34B80400838803A011E3C0C4008010C04404004040118204000000001002F022A0147033E00100000133332153217140F012227222F01343736B9265011075117123A312E053E20033E6E383B2E051E551A352032000000010056FF25016201990014000017232635363337363D012227363B01321F01140706B620400838301C4014093F204C1C04581FDB0838407046661C5C608C4CAD9B54000002005DFED402A1013C001C00300000012635343734373637323735072326353633321F011514071407062306252635343736373523222736333217150607062301D140302810180C04041040193B41330C242C3F0D20FEB84050160A083D0F153B5B29281C4420FED408382C140A2E1F5144640408385C5038605E4623495C141008381D674B0D78605C74D07D276800070069006A04EC04AA00190033003F00520065006D00740000011615140F0106070607062314072635363736373637363F0136053217141F0214071407232227222F01373437363B0117333417061507333217333527342301321F01151423140723222722273534373237051737161F0115140706232227263D01363336051517333527230605151737352706037740A0649D0F32A64507244009BB581C02BA2B496415FDCD2050282C0820584061172C30041C4015170C0404141818040F196440140323325E144028401850260E4C2113FE6818242F550460290F6751141B1D3E01C230141C0417FE3B3C28283C04AA08382DE788AB3147B570090308384EBE6D330ED2495FAC10483C112740383824161A1C4C3854313710040B770D23381410540CFE285C4040A00B05385C803226180C0404086418602C5C18602711207C5088541C681810500C2034302433FFFF0028FF6403FC0718022200240096000300D300560160FFFF000E00000416070A022200280000000300D300740152FFFF0028FF7703FC070D0222002400A90003008D00970159FFFF000E0000041607070222002800000003008E00910146FFFF000E0000041607070222002800000003004300DD012BFFFF002FFFA3038F07140222002C29A30003008DFFEB0160FFFF001AFF95037A070B0222002C1495000300D3FFE60153FFFF00060000036607000222002C00000003008E0027013FFFFF002EFFB0038E07070222002C28B0000300430053012BFFFF0056FFCB045A06FA0222003200CB0003008D00E70146FFFF005DFFBD046107040222003207BD000300D300CC014CFFFF005DFF8F046106DE02220032078F00030043017E0102FFFF0036FFF2035006F20222003800000003008D006E013EFFFF0036FFF203500718022200380000000300D300440160FFFF0036FFF20350070002220038000000030043006A012400010078FFDF011C04000014000013161D0107111715170706232237263D0127113633C4400C1410100838471B1414062E04000838204CFE944C74DB2E40C5663250500164BC000000010057042402AB05B800160000013217161716150623222726270706232635343F01363701DB2E162A4A1808382B194616C84F1D403490495B05B8387153181C40344844A44008382B19783163000000010065043E0381054600240000013316171617163B01363F0116151407062B012227222F0123060722070623263D013437360175202B5D302C3B19081C2C2440682711203781103C38047A061C041824406816054603350B25201B41080838345C1450241411173424083820323E190002007803F50250057100130020000001161716151407062B012627263D01343F0136330715173337352623272306150601685F31583C38306047612C3034164A405C4830283C0404381605710C24442C77254008382F1D2022364824D0041C3014340411072A0000010049FECE017D00D6001A0000251615073217140722070623263D013437363D0123263534373637012540141D0F9C1513161A4044702840481F11D6083844788F4128140838203B052F2D2008382B453701000001004903FC02710574001900001332171617343732353633161506230607140722272627263536892E1621877808182440191B51333C30683C3C24080574380A96146C0C24083854454B210B804527321A4000FFFF0035FFB6037D07090222003600B6000300D7006C0195FFFF0021FFB1030D05D1022200560000000200D7275D0000FFFF0021FFD103FC07090222003D0000000300D7008A0195FFFF001BFFC803FC05E50222005D0000000200D772710000000200DCFF7A01780606000F001D000001161514071507150623263D0137353613161D0117150623263D01273536013840100C0838400C151F400C0838400C08060608381715D0A0A0400838A0A0E05CFBF40838A0A0C0400838C0A0A04000000002004A006B03FA053F0030004A000001161D01373337333217161F0115140706070607062322273433353327352306070623263534373637363D01342F0135361723061D01161D0136371615140F011136373637363D01022B01013E401C348C60466A503C044C7D9B65CB3F212D0B580404042B4115174048293F2C200808B4102420AD4B4070C8A781304C30488468053F0838080410545FCD4CC026A675533937104044083CC40D2F100838311B26120A0A4C9BED684040C4070920C8B4282C0C0838410B30FEF0315F184C7410D4012C0000030064000003B004980021003F00580000011615140706071716150623222F0106232635343736332627263522273633321736033217363332171417161D01140706230723202F013437363736373237361723070607060F0115163B013237363F013534273427263506028040383A12BC180A322E6A7090244034410B021E600B050838199F8E42231115135379403C5079375080FED149041C19378C20092F2236204C1C404B110432CA743755300C14585C4814049808382E16271544181C4030287808382B1934090B360628405C84FE401C0C6C073553314077755C14C84861173F2DA212280880342A464331045864301F2D40542F3D1B2912120C00FFFF0028FF4B034407000222003C00CA0003008D0045014CFFFF0014FE4802F105A00222005C00000002008D40EC000000020050FFF9034C05790024003300001316150715333217321716173217151407060714052315062307263D013735273711271136131517113336373637352726272623984008B49D731359152B09033C2567FED474062E18400C08081409771458F81C64182813357153057908382CC0687402A22440791B291F1814A8BC040838204CD02C2C012CE0014060FE5404D0FEE80917202058840B4D5800020057FE70031B05100030003E0000133215131533321716151714070607060723150607150706232635343735363735232635363B01033523263536333503341315133325363735342726232623B7441C80CD2F84047C5389057F18100C1018245C280C100840083808080840083820A8080C01043D27482E3A153F051070FED00468DA6E3C3D573414091B7041BF205C24163A241C10BC505C0838400138BC0838400401682DFDE7BCFED0441E2E04617F700800000000010057017C03B70240001500001316053317331617161506232227232723242726353697600100402CB433492408383933B42C34FECD511C0802401818080C041824400C081C1C1B1D4000000100500099033803A9002F0000011615140706071517141714171615062322272627071407062B0126353437343736372627263536333217161737363702F8404402B2843020140838375D3E2E885060140C405068017F20C4300838232D9A3E88453303A9083820441BA9046C093B0612161A40882828880A427008382947085C08781C80321E4038623288632D0000010071033401F105BC001D000001161D011615173316150623212635363B01372F010623263534373637340131400C0430400838FF00400838480404041E1E4030074105BC083880A89C0408384008384010DC1C2008381D3316422D000000000100A0034802B805C4002A00000116153217321D011407060F011533321D010623272126353437363F0135262B01060706232635343736330160B01D1710206A3220A0A00A3264FF005C8832421C0B69200533141440281C5405C40917346420601C701814043C0C4008193B386C1E3E2070101C500C08381D4358000100AE035502A605D5003000000133321F0114073217161D01140F011407232635363B01373237323734272627263534373437352723220F01263536333401624093211434362E0C5C7844A04008389460210B07115421471878141C80191F1C40184005D554542329741414202A6230090B08384024201C38141315181C3C1C09031004240408385C0C000003006A000004520554001D0035005700000116151117331615062B0107222734333527352306232635343734373536051615140706070607060706232635363F023637363736033332151615140F013316150623210722273437363F013523220706232635363334014E40082440083854742D0B5C0804181C4034440802B840B88331296F8F7D193B40046C84B43A5EB44815A5207C146C18D0400838FEEC542D0B6023450C281808181C401C2405540838FE6C280838401040440424B41808382B190A4E284018083828F8B0504D8FCBC57008384B95C8F86F79F3750CFD5434155B538D300838400C40246841633818201808385C100003006BFFFA048B056E001D0035005800000116151117331615062B0107222734333527352306232635343734373536051615140706070607060706232635363F023637363736131615113215062B0127161D010623263D0134272322352227353633161D0117331136014F40082440083854742D0B5C0804181C4034440802B840B88331296F8F7D193B40046C84B43A5EB44815274068083804140C0838400C68B80701083840287008056E0838FE6C280838401040440424B41808382B190A4E284018083828F8B0504D8FCBC57008384B95C8F86F79F3750CFDE40838FEDC44400443895040083850834D301C8040083848040120400003007FFFD105030565002D004B006B000001321F01150623151615171407140706072635343736353237352723072235343F01353423220F0123263534373405161514071407140103061506070623263534373637360134373637363303161507113217140F01150623263D0137232635373536331615071507331136021F3B351413255C04908C42824060845567106C3C649064103C484408409803284060B0FE64E8442711181C40587C28CC0138AC024A1F296840082D0B3C0808384008E45C20093F40080CB00905654840205C0836420C6D57112B1A1208383F091113700C1010443E2A4C0418201C083841270E020838267220A818FE68FEF4341C3F391808382C947642DC01380EB21A5244FDB408382CFEDC4030146C804008388064153B70706008382C7430013C600000020079014D038D043D0039004B00000132173736331615140F01161D0106071617161506232227222735230623222706230607263534373635263527363F012635273633321736333603151633363F013527262F010727230607060215336D701513406034380B293C20240838271D14440447414B611C2C313340443840041C14046C0408382759505811BD6F7D73110C2C172D10242C20481C12043D70500C083830302C742C2445333C102E1A403054083C34182507083832161709372D38781C0C640C1440604C1CFE88149449172C1074174D0C08082D371C0001004A04BD044A0565001000001333051733321714072327252326353437D6E40190A02038084020A0FE70F0804005550C0C4038080C0C0D4338080000002801E60001000000000000005000000001000000000001000800570001000000000002000700500001000000000003001500570001000000000004000800570001000000000005002E006C000100000000000600080057000100000000000A0040009A0003000104030002000C02CA0003000104050002001000DA0003000104060002000C00EA0003000104070002001000F60003000104080002001001060003000104090000007001160003000104090001001001940003000104090002000E01860003000104090003002A01940003000104090004001001940003000104090005005C01BE000300010409000600100194000300010409000A0080021A00030001040A0002000C02CA00030001040B00020010029A00030001040C0002000C02CA00030001040E0002000C02E80003000104100002000E02AA0003000104130002001202B80003000104140002000C02CA0003000104150002001002CA0003000104160002000C02CA0003000104190002000E02DA00030001041B0002001002E800030001041D0002000C02CA00030001041F0002000C02CA0003000104240002000E02F800030001042D0002000E030600030001080A0002000C02CA0003000108160002000C02CA000300010C0A0002000C02CA000300010C0C0002000C02CA4F736D6F7369616E20536C6F70707920A920323030352052656C6174696F6E616C2053797374656D7320436F72706F726174696F6E20323030352E20416C6C205269676874732052657365727665642E526567756C61726F736D6F7369616E3A56657273696F6E20312E303056657273696F6E20312E3030204E6F76656D62657220362C20323030352C20696E697469616C2072656C656173655468697320666F6E74207761732063726561746564207573696E6720466F6E742043726561746F7220352E302066726F6D20486967682D4C6F6769632E636F6D006F00620079010D0065006A006E00E9006E006F0072006D0061006C005300740061006E0064006100720064039A03B103BD03BF03BD03B903BA03AC004F0073006D006F007300690061006E002000A90020003200300030003600200054006800650020004F0073006D006F007300690061006E0020004F0072006400650072002E00200041006C006C0020005200690067006800740073002000520065007300650072007600650064002E0052006500670075006C00610072006F0073006D006F007300690061006E003A00560065007200730069006F006E00200033002E0030003000560065007200730069006F006E00200033002E003000300020004E006F00760065006D00620065007200200036002C00200032003000300035002C00200069006E0069007400690061006C002000720065006C0065006100730065005400680069007300200066006F006E00740020007700610073002000630072006500610074006500640020007500730069006E006700200046006F006E0074002000430072006500610074006F007200200035002E0030002000660072006F006D00200048006900670068002D004C006F006700690063002E0063006F006D004E006F0072006D00610061006C0069004E006F0072006D0061006C0065005300740061006E00640061006100720064004E006F0072006D0061006C006E0079041E0431044B0447043D044B0439004E006F0072006D00E1006C006E0065004E0061007600610064006E006F0041007200720075006E0074006100000002000000000000FF270096000000000000000000000000000000000000000000ED0000010201030003000400050006000700080009000A000B000C000D000E000F0010001100120013001400150016001700180019001A001B001C001D001E001F0020002100220023002400250026002700280029002A002B002C002D002E002F0030003100320033003400350036003700380039003A003B003C003D003E003F0040004100420043004400450046004700480049004A004B004C004D004E004F0050005100520053005400550056005700580059005A005B005C005D005E005F0060006100620063006400650066006700680069006A006B006C006D006E006F0070007100720073007400750076007700780079007A007B007C007D007E007F0080008100820083008400850086008700880089008A008B008C008D008E008F0090009100920093009400950096009700980099009A009C009D009E009F00A000A100A200A300A400A500A600A700A800A900AA00AB00AD00AE00AF00B000B100B200B300B400B500B600B700B800B900BA00BB00BC010400BE00BF00C200C300C400C500C600C700C800C900CA00CB00CC00CD00CE00CF00D000D100D300D400D500D600D700D800D900DD00DE00E100E400E500E600E700E800E900EA00EB00EC00ED00EE00EF00F001050106010700F400F500F600BD00DA052E6E756C6C106E6F6E6D61726B696E6772657475726E044575726F07756E693030423907756E693030423207756E693030423300000001FFFF0002.

Etapas necessárias para que se outdent any selecionado rows em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Se o target deste first deste string desta row for o caractere de espaço, remove o first pedaço from o string deste row.
Se o target deste first deste string desta row for o caractere de espaço, remove o first pedaço from o string deste row.
Repita.

Etapas necessárias para que se outdent um caixa alguns twips;
Etapas necessárias para que se outdent um caixa usando alguns twips:
Subtraia o twips from o left desta caixa.
Subtraia o twips from o topo desta caixa.
Adicione o twips para o right desta caixa.
Adicione o twips para a base desta caixa.

Um outdent é um número.

Etapas necessárias para que se outline um caixa with um cor:
Draw o caixa with a cor e o clear cor.

Um outlinetextmetric é um conjunto with
Um número called otmsize,
Um textmetric called otmtextmetrics,
3 pedaços, \ needed para align structure
Um pedaço called otmfiller,
Um panose called otmpanosenumber,
1 pedaços, \ needed para align structure
Um número called otmfsselection,
Um número called otmfstype,
Um número called otmscharsloperise,
Um número called otmscharsloperun,
Um número called otmitalicangle,
Um número called otmemsquare,
Um número called otmascent,
Um número called otmdescent,
Um número called otmlinegap,
Um número called otmscapemheight,
Um número called otmsxheight,
Um caixa called otmrcfontbox,
Um número called otmmacascent,
Um número called otmmacdescent,
Um número called otmmaclinegap,
Um número called otmusminiumppem,
Um spot called otmptsubscriptsize,
Um spot called otmptsubscriptoffset,
Um spot called otmptsuperscriptsize,
Um spot called otmptsuperscriptoffset,
Um número called otmsstrikeoutsize,
Um número called otmsstrikeoutposition,
Um número called otmsunderscoresize,
Um número called otmsunderscoreposition,
Um endereço de memória called otmpfamilyname,
Um endereço de memória called otmpfacename,
Um endereço de memória called otmpstylename,
Um endereço de memória called otmpfullname.

Um x-offset é um offset.
Um y-offset é um offset.

Etapas necessárias para que se output o arc of uma elipse usando um string: \\ interessante.
Atribua 2761/10000 A um fração. \ 2/3*(sqrt(2)-1)
Atribua o center desta elipse A um center spot.
Atribua o x-extent desta elipse dividido por 2 A um half width.
Atribua o y-extent desta elipse dividido por 2 A um half altura.
Atribua o x-extent desta elipse times a fração A um x-offset.
Atribua o y-extent desta elipse times a fração A um y-offset.
\ control point 1
Se o string for "left-top", atribua o left desta elipse e a coordenada y deste center menos o y-offset A um first control spot.
Se o string for "right-top", atribua a coordenada x deste center mais o x-offset e o topo desta elipse ao first control spot.
Se o string for "right-base", atribua o right desta elipse e a coordenada y deste center mais o y-offset ao first control spot.
Se o string for "left-base", atribua a coordenada x deste center menos o x-offset e a base desta elipse ao first control spot.
\ control point 2
Se o string for "left-top", atribua a coordenada x deste center menos o x-offset e o topo desta elipse A um second control spot.
Se o string for "right-top", atribua o right desta elipse e a coordenada y deste center menos o y-offset ao second control spot.
Se o string for "right-base", atribua a coordenada x deste center mais o x-offset e a base desta elipse ao second control spot.
Se o string for "left-base", atribua o left desta elipse e a coordenada y deste center mais o y-offset ao second control spot.
\ ending point
Se o string for "left-top", atribua o left desta elipse mais o half width e o topo desta elipse A um ending spot.
Se o string for "right-top", atribua o right desta elipse e o topo desta elipse mais o half altura ao ending spot.
Se o string for "right-base", atribua o right desta elipse menos o half width e a base desta elipse ao ending spot.
Se o string for "left-base", atribua o left desta elipse e a base desta elipse menos o half altura ao ending spot.
\ spit it out
Output o first control spot sem advancing.
Output o second control spot sem advancing.
Output o ending spot sem advancing.
Output "c".

Etapas necessárias para que se output uma cor sem advancing:
Convert a cor para um rgb.
Atribua o espectro vermelho deste rgb / 255 A um fração.
Convert a fração para um red string usando 4.
Atribua o espectro verde deste rgb / 255 à fração.
Convert a fração para um green string usando 4.
Atribua o espectro azul deste rgb / 255 à fração.
Convert a fração para um blue string usando 4.
Output o red string then " " then o green string then " " then o blue string sem advancing.

Etapas necessárias para que se output lineto usando um spot:
Output o spot sem advancing.
Output "l".

Etapas necessárias para que se output lineto usando um número x e um número y:
Atribua o número x e o número y A um spot.
Output lineto usando o spot.

Etapas necessárias para que se output moveto usando um spot:
Output o spot sem advancing.
Output "m".

Etapas necessárias para que se output moveto usando um número x e um número y:
Atribua o número x e o número y A um spot.
Output moveto usando o spot.

Etapas necessárias para que se output um número sem advancing:
Convert o número para um string.
Output o string sem advancing.
Output " " sem advancing.

Etapas necessárias para que se output o pdf border usando uma cor:
Se a cor for a current border deste pdf state, cancele.
Output a cor sem advancing.
Output " RG".
Atribua a cor à current border deste pdf state.

Etapas necessárias para que se output o pdf fill usando uma cor:
Se a cor for o current fill deste pdf state, cancele.
Output a cor sem advancing.
Output " rg".
Atribua a cor ao current fill deste pdf state.

Etapas necessárias para que se output setcolor usando um border cor e um fill cor:
Se o fill não estiver clear, output o pdf fill usando o fill.
Se o border não estiver clear, output o pdf border usando o border.

Etapas necessárias para que se output um spot sem advancing:
Output a coordenada x deste spot sem advancing.
Output a current altura deste pdf state menos a coordenada y deste spot sem advancing.

Etapas necessárias para que se output um string:
Posponha o string para os current contents deste pdf state.

Etapas necessárias para que se output um string sem advancing:
Posponha o string para os current contents deste pdf state sem advancing.

Etapas necessárias para que se output stroke e fill usando um border cor e um fill cor:
Atribua "B" A um string. \ stroke e fill
Se o fill estiver clear, atribua "S" ao string. \ stroke
Se o border estiver clear, atribua "f" ao string. \ fill
Output o string.

O tecla P/p é uma tecla igual a 80.

Um pabc é um endereço de memória para um abc.

O tecla PgDn é uma tecla igual a 34.

O tecla PgUp é uma tecla igual a 33.

Um paintstruct é um conjunto with
Um hdc called hdc,
Um número called ferase,
Um caixa called rcpaint,
Um número called frestore,
Um número called fincupdate,
32 pedaços.

Um número x é um número.
Um número y é um número.

Um pair has um número x e um número y.

Um panose é um conjunto with
Um pedaço called bfamilytype,
Um pedaço called bserifstyle,
Um pedaço called bweight,
Um pedaço called bproportion,
Um pedaço called bcontrast,
Um pedaço called bstrokevariation,
Um pedaço called barmstyle,
Um pedaço called bletterform,
Um pedaço called bmidline,
Um pedaço called bxheight.

O parágrafo pedaço é um pedaço igual a 182.

Um cor pastel é uma cor.



O pause tecla é uma tecla igual a 19.

Um pchar é um endereço de memória do pedaço .

Um pdevmode é um endereço de memória para um devmode.

Um pdf é um trecho.

An pdf object é uma coisa with
Um categoria [contents, font definition, font descriptor, font streamoutline, image object, outline entry, página, parent, root],
Um número,
Um offset,
Um data trecho,
Um font name [font definition],
Um font info [font definition],
Some conjunto de textos called font strings [page],
Some conjunto de textos called image strings [page].

An pdf outline entry é uma coisa with
Um pdf object (reference),
Um title string,
Um página altura,
Um destination número.

Um pdf endereço de memória é um endereço de memória para um pdf.

Um pdf state has
Um pdf endereço de memória,
Um documento alarme,
Um página alarme,
Um object número,
Some pdf objects called objects,
Um xref offset,
Um outline pdf object (reference),
Some pdf outline entries called outline entries,
Um root pdf object (reference),
Um parent pdf object (reference),
Um current contents pdf object (reference),
Um current página pdf object (reference),
Um current altura,
Um current border cor,
Um current fill cor,
Um font index.

O pdf state é um pdf state.

Um pdf string é um string. \ string surrounded por ( ) e has \( por left paren, \) por right paren, \\ por barra invertida

Um pincel é uma cor.

O pincel size é um número.

O per-mille-sign pedaço é um pedaço igual a 137.

Um percent é um número. \ um scale with 100 no denominador

O sinal de porcentagem é um pedaço igual a 37.

O ponto final é um pedaço igual a 46.

Etapas necessárias para que se escolha aleatoriamente um brilho between um percent e uma segunda percent;
Etapas necessárias para que se vary uma luminosidade between um percent e uma segunda percent;
Etapas necessárias para que se escolha aleatoriamente uam luminosidade between um percent e uma segunda percent:
Escolha aleatoriamente um número between o percent e o segunda percent.
Atribua o número times 10 à luminosidade.
Atribua a luminosidade à luminosidade deste context.

Etapas necessárias para que se escolha aleatoriamente um cor amarronzada:
Escolha aleatoriamente a matiz desta cor amarronzada between 250 e 350.
Escolha aleatoriamente a saturação desta cor amarronzada between 500 e 1000.
Escolha aleatoriamente o brilho desta cor amarronzada between 125 e 375.
Atribua o cor amarronzada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor amarronzada about alguns percent of o time:
\ *** generalize this por all cors
Escolha aleatoriamente um número between 1 e 100.
Se o número for maior do que o percent, cancele.
Escolha aleatoriamente o cor amarronzada.
Atribua o cor amarronzada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor:
Escolha aleatoriamente a matiz desta cor between 0 e 3600.
Escolha aleatoriamente a saturação desta cor between 0 e 1000.
Escolha aleatoriamente a luminosidade desta cor between 0 e 1000.
Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor between uma segunda cor e um terceiro cor:
Escolha aleatoriamente a matiz desta cor between a matiz desta segunda cor e a matiz desta terceiro cor.
Escolha aleatoriamente a saturação desta cor between a saturação desta segunda cor e a saturação desta terceiro cor.
Escolha aleatoriamente a luminosidade desta cor between a luminosidade desta segunda cor e a luminosidade desta terceiro cor.
Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor like uma segunda cor:
Atribua o segunda cor à cor.
Escolha aleatoriamente um número between -100 e 100.
Adicione o número para a matiz desta cor.
Limite a matiz desta cor para 0 e 3599.
Defina a saturação desta cor para something between 100 e 1000.
Defina a luminosidade desta cor para something between 0 e 800.
Atribua a cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente uma cor escura:
\Etapas necessárias para que se escolha aleatoriamente um cor escura:
Escolha aleatoriamente a matiz desta cor escura between 0 e 3599.
Atribua 1000 à saturação desta cor escura.
Atribua 375 à luminosidade desta cor escura.
Atribua o cor escura à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor esverdeada:
Escolha aleatoriamente a matiz desta cor esverdeada between 900 e 1200.
Escolha aleatoriamente a saturação desta cor esverdeada between 500 e 1000.
Escolha aleatoriamente o brilho desta cor esverdeada between 250 e 875.
Atribua o cor esverdeada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um cor esverdeada about alguns percent of o time:
\ *** generalize this por all cors
Escolha aleatoriamente um número between 1 e 100.
Se o número for maior do que o percent, cancele.
Escolha aleatoriamente o cor esverdeada.
Atribua o cor esverdeada à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um heading:
Escolha aleatoriamente o heading between 0 e 3839.
Atribua o heading ao heading deste context.

Etapas necessárias para que se escolha aleatoriamente um tamanho da letra between alguns twips e alguns segunda twips:
Escolha aleatoriamente um random número between o twips e o segunda twips.
Atribua o random número ao tamanho da letra.
Atribua o random número à tamanho da letra deste context.

Etapas necessárias para que se escolha aleatoriamente um letra of o alphabet:
\ atribua letra A context? ***
Escolha aleatoriamente um número between 65 e 90.
Atribua o número ao letra.

Etapas necessárias para que se escolha aleatoriamente um light cor:
Escolha aleatoriamente a matiz desta light cor between 0 e 3599.
Atribua 1000 à saturação desta light cor.
Atribua 625 à luminosidade desta light cor.
Atribua o light cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um número:
Escolha aleatoriamente o número between 0 e o maior número.
Atribua o número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente um número within um quantia of uma segunda número:
Escolha aleatoriamente o número between o segunda número menos o quantia e o segunda número mais o quantia.
Atribua o número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente um cor pastel:
Escolha aleatoriamente a matiz desta cor pastel between 0 e 3599.
Atribua 1000 à saturação desta cor pastel.
Atribua 875 à luminosidade desta cor pastel.
Atribua o cor pastel à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um rainbow cor:
Adicione 1 para o número atual da cor do arco-íris.
Se o número atual da cor do arco-íris for maior do que 6, atribua 1 ao número atual da cor do arco-íris.
Se o número atual da cor do arco-íris for 1, atribua o cor vermelha ao rainbow cor.
Se o número atual da cor do arco-íris for 2, atribua o cor laranja ao rainbow cor.
Se o número atual da cor do arco-íris for 3, atribua o cor amarela ao rainbow cor.
Se o número atual da cor do arco-íris for 4, atribua o green cor ao rainbow cor.
Se o número atual da cor do arco-íris for 5, atribua o blue cor ao rainbow cor.
Se o número atual da cor do arco-íris for 6, atribua o purple cor ao rainbow cor.
Atribua o rainbow cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um solid cor:
Escolha aleatoriamente o matiz desta solid cor between 0 e 3599.
Atribua 1000 à saturação desta solid cor.
Atribua 500 à luminosidade desta solid cor.
Atribua o solid cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere no base uma fração of um caixa;
Etapas necessárias para que se escolha aleatoriamente um spot no base uma fração of um caixa:
Isole o caixa.
Atribua a altura desta caixa times a fração A alguns twips.
Atribua a base desta caixa menos o twips ao topo desta caixa.
Escolha aleatoriamente o spot no caixa.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere em um caixa:
Escolha aleatoriamente a coordenada x deste spot between o left desta caixa e o right desta caixa.
Escolha aleatoriamente a coordenada y deste spot between o topo desta caixa e a base desta caixa.
Atribua o spot ao spot deste context.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere no middle uma fração of um caixa;
Etapas necessárias para que se escolha aleatoriamente um spot no middle uma fração of um caixa:
Isole o caixa.
Atribua o y deste center desta caixa A um coord.
Atribua a altura desta caixa times a fração dividido por 2 A um número.
Atribua o coord menos o número ao topo desta caixa.
Atribua o coord mais o número à base desta caixa.
Escolha aleatoriamente o spot no caixa.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere no topo half of um caixa;
Etapas necessárias para que se escolha aleatoriamente um spot no topo half of um caixa:
Isole o caixa.
Atribua o y deste center desta caixa à base desta caixa.
Escolha aleatoriamente o spot no caixa.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere no topo middle uma fração of um caixa;
Etapas necessárias para que se escolha aleatoriamente um spot no topo middle uma fração of um caixa:
Isole o caixa.
Atribua o y deste center desta caixa A um coord.
Atribua a altura desta caixa times a fração A um número.
Atribua o coord menos o número ao topo desta caixa.
Atribua o coord à base desta caixa.
Escolha aleatoriamente o spot no caixa.

Etapas necessárias para que se escolha aleatoriamente um spot anywhere sobre um horizontal line;
Etapas necessárias para que se escolha aleatoriamente um spot sobre um horizontal line:
Escolha aleatoriamente o x deste spot between o horizontal x deste start desta line e o x deste end desta horizontal line.
Atribua o y desta horizontal line ao y deste spot.

Etapas necessárias para que se escolha aleatoriamente um spot em um caixa:
Escolha aleatoriamente o x deste spot between o left desta caixa e o right desta caixa.
Escolha aleatoriamente o y deste spot between o topo desta caixa e a base desta caixa.
Atribua o spot ao spot deste context.

Etapas necessárias para que se escolha aleatoriamente um spot em um caixa about alguns twips above o middle;
Etapas necessárias para que se escolha aleatoriamente um spot em um caixa about alguns twips above o center:
Atribua o caixa A um bounding caixa.
Atribua o twips dividido por 2 A alguns segunda twips.
Atribua o y deste center desta caixa menos o segunda twips à base desta bounding caixa.
Atribua a base desta bounding caixa menos o twips ao topo desta bounding caixa.
Escolha aleatoriamente o spot anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente um spot em um caixa about alguns twips below o middle;
Etapas necessárias para que se escolha aleatoriamente um spot em um caixa about alguns twips below o center:
Atribua o caixa A um bounding caixa.
Atribua o twips dividido por 2 A alguns segunda twips.
Atribua o y deste center desta caixa mais o segunda twips ao topo desta bounding caixa.
Atribua o topo desta bounding caixa mais o twips à base desta bounding caixa.
Escolha aleatoriamente o spot anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente um spot em um caixa alguns twips para alguns segunda twips above o middle;
Etapas necessárias para que se escolha aleatoriamente um spot em um caixa alguns twips para alguns segunda twips above o center:
Atribua o caixa A um bounding caixa.
Atribua o y deste center desta caixa menos o twips à base desta bounding caixa.
Atribua a base desta bounding caixa menos o segunda twips ao topo desta bounding caixa.
Escolha aleatoriamente o spot anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente um spot em um caixa alguns twips para alguns segunda twips below o middle;
Etapas necessárias para que se escolha aleatoriamente um spot em um caixa alguns twips para alguns segunda twips below o center:
Atribua o caixa A um bounding caixa.
Atribua o y deste center desta caixa mais o twips ao topo desta bounding caixa.
Atribua o topo desta bounding caixa mais o segunda twips à base desta bounding caixa.
Escolha aleatoriamente o spot anywhere no bounding caixa.

Etapas necessárias para que se escolha aleatoriamente um spot within um distance of uma segunda spot:
Escolha aleatoriamente a coordenada x deste spot within o distance of a coordenada x deste segunda spot.
Escolha aleatoriamente a coordenada y deste spot within o distance of a coordenada y deste segunda spot.
Atribua o spot ao spot deste context.

Etapas necessárias para que se escolha aleatoriamente alguns twips between alguns min twips e alguns segunda twips; \ são all these necessary? ***
Etapas necessárias para que se escolha aleatoriamente um número between alguns min twips e alguns segunda twips;
Etapas necessárias para que se escolha aleatoriamente um número between um min número e um max número;
Etapas necessárias para que se escolha aleatoriamente um número from um min número para um max número;
Etapas necessárias para que se defina um número para something between uma segunda número e um terceiro número;
Etapas necessárias para que se escolha aleatoriamente um random número between um min número e um max número:
Atribua o whereabouts deste seed Into EAX.
\ atribua address of randseed A ecx
Intel $8BC8. \ mov ecx,eax
\ calculate zero based max
Intel $8B8510000000. \ mov eax,[ebp+16] \ o max
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o min
Intel $2B03. \ sub eax,[ebx]
Intel $40. \ inc eax
\ ajuste randseed
Intel $691105840808. \ imul edx,[ecx],134775813
Intel $42. \ inc edx
Intel $8911. \ mov [ecx],edx
\ mul adjusted randseed pelo zero based max
Intel $F7E2. \ mul edx
\ adicione o min para an-zero base o número
Intel $0313. \ adicione edx,[ebx] o min
\ store o result
Intel $8B9D08000000. \ mov ebx,[ebp+08] \ o random número
Intel $8913. \ mov [ebx],edx
Atribua o random número ao número deste context.

Etapas necessárias para que se escolha aleatoriamente um very cor escura;
Etapas necessárias para que se escolha aleatoriamente um really cor escura:
Escolha aleatoriamente a matiz desta really cor escura between 0 e 3599.
Atribua 500 à saturação desta really cor escura.
Atribua 250 à luminosidade desta really cor escura.
Atribua o really cor escura à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um very light cor;
Etapas necessárias para que se escolha aleatoriamente um really light cor:
Escolha aleatoriamente a matiz desta really light cor between 0 e 3599.
Atribua 1000 à saturação desta really light cor.
Atribua 750 à luminosidade desta really light cor.
Atribua o really light cor à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um very very cor escura;
Etapas necessárias para que se escolha aleatoriamente um really really cor escura:
Escolha aleatoriamente a matiz desta really really cor escura between 0 e 3599.
Atribua 500 à saturação desta really really cor escura.
Atribua 125 à luminosidade desta really really cor escura.
Atribua o really really cor escura à cor deste context.

Etapas necessárias para que se escolha aleatoriamente um very very light cor;
Etapas necessárias para que se escolha aleatoriamente um really really light cor:
Escolha aleatoriamente a matiz desta really really light cor between 0 e 3599.
Atribua 1000 à saturação desta really really light cor.
Atribua 875 à luminosidade desta really really light cor.
Atribua o really really light cor à cor deste context.

Um picture é uma coisa with
\ all caixa s são em twits
Um caixa [location of cropped picture sobre o página], 
Um uncropped caixa [location of entire picture sobre o página],
Um grayscale alarme,
Um mirror alarme,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal called data [original pedaços em original format],
Um gpbitmap.

Um imagem é uma coisa with
\ all caixa s são em twits
Um caixa [location of cropped picture sobre o página], 
Um uncropped caixa [location of entire picture sobre o página],
Um grayscale alarme,
Um mirror alarme,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal called data [original pedaços em original format],
Um gpbitmap.

\Um figura é uma coisa with
\ all caixas são em twits
\Um caixa [location of cropped picture sobre o página], 
\Um uncropped caixa [location of entire picture sobre o página],
\Um grayscale alarme,
\Um mirror alarme,
\Um ângulo de rotação, \ rotation é clockwise
\Um texto hexadecimal called data [original pedaços em original format],
\Um gpbitmap.

O pink cor é uma cor.

O pink pincel é um pincel.

Um pixel é 15 twips.

Etapas necessárias para que se play um wave:
Call "winmm.dll" "PlaySound" with o first desta wave e 0 e 5 [snd_memory+snd_async].

Etapas necessárias para que se play um wave e wait:
Call "winmm.dll" "PlaySound" with o first desta wave e 0 e 4 [snd_memory+snd_sync].

Etapas necessárias para que se play um wave file:
Isole o wave file.
Null terminate o wave file.
Call "winmm.dll" "PlaySound" with o first deste wave file e 0 e 131073 [snd_filename+snd_async].

Etapas necessárias para que se play um wave file e wait:
Isole o wave file.
Null terminate o wave file.
Call "winmm.dll" "PlaySound" with o first deste wave file e 0 e 131072 [snd_filename+snd_sync].

O plus-or-minus pedaço é um pedaço igual a 177.

O plus-sign pedaço é um pedaço igual a 43.

An point é um número [0 para 3839; por dividing um circle A compass points; 0 é noon; 960 points per quarter].

Um endereço de memória é um conjunto with 4 pedaços.

An polygon é uma coisa with alguns vértices.

Um portrait sheet é um sheet.

Um position é um pair with um column# e um número da linha.

Etapas necessárias para que se position um subtexto sobre um string:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o string
\ atribua o first deste string ao first des te subtexto
Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o first do string
Intel $898800000000. \ mov [eax+0],ecx \ o first do subtexto
\ atribua o first deste string menos 1 ao last deste subtexto
Intel $49. \ dec ecx
Intel $898804000000. \ mov [eax+4],ecx \ o last deste subtexto

Etapas necessárias para que se post um data string para um url e receive um response string:
\ only works with http e https
Limpe o response.
Limpe o i/o erro.
Crie um winhttp request por posting para o url.
Se o i/o erro não estiver em branco, cancele.
Send o data para o winhttp request.
Se o i/o erro não estiver em branco, destroy o winhttp request; exit.
Receive o response from o winhttp request.
Se o i/o erro não estiver em branco, destroy o winhttp request; exit.
Read o response from o winhttp request.
Se o i/o erro não estiver em branco, destroy o winhttp request; exit.
Destroy o winhttp request.

O pound-sign pedaço é um pedaço igual a 163.

Um poutlinetextmetric é um endereço de memória para um outlinetextmetric.

O ppi é alguns twips.

An precise degree é um número [0 para 3599].

Etapas necessárias para que se anteponha um pedaço para um string:
Atribua o length deste string A um saved length.
Reassign o first deste string usando o length deste string mais 1.
Copy pedaços from o first deste string para o first deste string mais 1 pelo saved length.
Atribua o first deste string mais o saved length ao last deste string.
Atribua o pedaço ao target deste first deste string.

Etapas necessárias para que se anteponha um string para uma segunda string:
Atribua o length deste segunda string mais o length deste string A um combined length.
Reassign um endereço de memória usando o combined length.
Atribua o endereço de memória A um subtexto's first.
Copy pedaços from o first deste string para o first deste subtexto pelo length deste string.
Adicione o length deste string para o first deste subtexto.
Copy pedaços from o first deste segunda string para o first deste subtexto pelo length deste segunda string.
Unassign o first deste segunda string. \ para que se esvazie extra allocates e copies
Atribua o endereço de memória ao first deste segunda string.
Atribua o first deste segunda string mais o combined length menos 1 ao last deste segunda string.

Etapas necessárias para que se anteponha uma coisa para alguns coisas:
Se a coisa for inexistente, cancele.
Atribua o first destas coisas ao next desta coisa.
Se o coisas não for vazio, atribua a coisa ao previous deste first destas coisas.
Se o coisas estiverem vazio, atribua a coisa ao last destas coisas.
Atribua a coisa ao first destas coisas.

\Etapas necessárias para que se anteponha alguns coisas para algumas segunda coisas:
\ bug found por Mike Gonta - corrected version below
\Obtenha uma coisa from o coisas (backwards).
\Se a coisa for inexistente, cancele.
\Remove a coisa from as coisas.
\Anteponha a coisa para o segunda coisas.
\Repita.

Etapas necessárias para que se anteponha alguns coisas para algumas segunda coisas:
Atribua o last destas coisas A uma coisa.
Se a coisa for inexistente, cancele.
Remove a coisa from as coisas.
Anteponha a coisa para o segunda coisas.
Repita.

O tecla Print Screen é uma tecla igual a 44.
O tecla PrintScreen é uma tecla igual a 44.

An printdlgex é um conjunto with
Um número called lstructsize,
Um window called hwndowner,
Um handle called hdevmode,
Um handle called hdevnames,
Um canvas called hdc,
Um número called flags,
Um número called flags2,
Um número called exclusionflags,
Um número called npageranges,
Um número called nmaxpageranges,
Um endereço de memória called lppageranges,
Um número called nminpage,
Um número called nmaxpage,
Um número called ncopies,
Um handle called hinstance,
Um endereço de memória called lpprinttemplatename,
Um endereço de memória called lpcallback,
Um número called npropertypages,
Um endereço de memória called lphpropertypages,
Um número called nstartpage,
Um número called dwresultaction.

O printer canvas é um canvas.

O printer device mode handle é um handle.

Um process é um handle.

Um process endereço de memória é um endereço de memória para um process.

Um processinfo é um conjunto with
Um handle called hprocess,
Um handle called hthread,
Um número called dwprocessid,
Um número called dwthreadid.

Um punch line é um string.

O purple cor é uma cor.

O purple pincel é um pincel.

Etapas necessárias para que se atribua o actual data of uma font Into um trecho:
\ only works with true/open type fonts
Crie o hfont of o memory canvas usando o font.
Call "gdi32.dll" "GetFontData" with o memory canvas e 0 e 0 e nil e 0 returning um contagem.
Reassign o first deste trecho usando a contagem.
Call "gdi32.dll" "GetFontData" with o memory canvas e 0 e 0 e o first deste trecho e a contagem.
Atribua o first deste trecho mais o contagem menos 1 ao last deste trecho.
Destroy o hfont of o memory canvas.

Etapas necessárias para que se atribua o base of um caixa Into um horizontal line;
Etapas necessárias para que se atribua o base edge of um caixa Into um horizontal line;
Etapas necessárias para que se atribua o base side of um caixa Into um horizontal line:
Atribua o left-base desta caixa ao start desta horizontal line.
Atribua o right-base desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o base of um caixa Into um line:
Make o line with o left-base desta caixa e o right-base desta caixa.

Etapas necessárias para que se atribua um caixa e um radius Into um caixa arredondada:
Atribua o left desta caixa ao left desta caixa arredondada.
Atribua o topo desta caixa ao topo desta caixa arredondada.
Atribua o right desta caixa ao right desta caixa arredondada.
Atribua a base desta caixa à base desta caixa arredondada.
Atribua o radius ao radius desta caixa arredondada.

Etapas necessárias para que se atribua um caixa no center of uma segunda caixa;
Etapas necessárias para que se centralize um caixa em uma segunda caixa:
Centralize o caixa no segunda caixa (horizontally).
Centralize o caixa no segunda caixa (vertically).

Etapas necessárias para que se atribua um caixa no center of o tela;
Etapas necessárias para que se centralize um caixa sobre o tela:
Centralize o caixa na caixa desta tela.

Etapas necessárias para que se atribua um caixa Into uma segunda caixa:
Atribua o left desta caixa ao left desta segunda caixa.
Atribua o topo desta caixa ao topo desta segunda caixa.
Atribua o right desta caixa ao right desta segunda caixa.
Atribua a base desta caixa à base desta segunda caixa.

Etapas necessárias para que se atribua um caixa sobre um spot;
Etapas necessárias para que se centralize um caixa sobre um spot:
Obtenha um difference between o spot e o center desta caixa.
Round a difference para o nearest multiple of o tpp.
Mova o caixa usando a difference.

Etapas necessárias para que se atribua um caixa alguns twips por alguns segunda twips no center of uma segunda caixa;
Etapas necessárias para que se centralize um caixa alguns twips por alguns segunda twips em uma segunda caixa:
Make o caixa o twips pelo segunda twips.
Centralize o caixa no segunda caixa.

Etapas necessárias para que se atribua uma caixa's base line Into um horizontal line:
\ e "vertical" por left e right
Atribua o left desta caixa e a base desta caixa ao start desta horizontal line.
Atribua o right desta caixa e a base desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua um caixa's base-center Into um spot:
\ *** need these sem dashs too
Atribua o x deste center desta caixa ao x deste spot.
Atribua a base desta caixa ao y deste spot.

Etapas necessárias para que se atribua um caixa's center Into um spot:
Atribua o left desta caixa mais o right desta caixa à coordenada x deste spot.
Atribua o topo desta caixa mais a base desta caixa à coordenada y deste spot.
Divida o spot por 2.

Etapas necessárias para que se atribua um caixa's center-base Into um spot:
Atribua o coordenada x deste center desta caixa à coordenada x deste spot.
Atribua a base desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua um caixa's center-top Into um spot:
Atribua o coordenada x deste center desta caixa à coordenada x deste spot.
Atribua o topo desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua um caixa's altura Into um altura:
Atribua a base desta caixa ao altura.
Subtraia o topo desta caixa from o altura.
Adicione o tpp para o altura.

Etapas necessárias para que se atribua um caixa's left line Into um line:
Atribua o left desta caixa e o topo desta caixa ao start desta line.
Atribua o left desta caixa e a base desta caixa ao end desta line.

Etapas necessárias para que se atribua um caixa's left-base Into um spot:
Atribua o left desta caixa à coordenada x deste spot.
Atribua a base desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua um caixa's left-center Into um spot:
Atribua o left desta caixa à coordenada x deste spot.
Atribua a coordenada y deste center desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua um caixa's right line Into uma line:
Atribua o right desta caixa e o topo desta caixa ao start desta line.
Atribua o right desta caixa e a base desta caixa ao end desta line.

Etapas necessárias para que se atribua um caixa's right-center Into um spot:
Atribua o right desta caixa à coordenada x deste spot.
Atribua a coordenada y deste center desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua um caixa's right-top Into um spot:
Atribua o right desta caixa à coordenada x deste spot.
Atribua o topo desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua um caixa's topo line Into uma horizontal line:
Atribua o left desta caixa e o topo desta caixa ao start desta horizontal line.
Atribua o right desta caixa e o topo desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua um caixa's topo-center Into um spot:
Atribua o coordenada x deste center desta caixa à coordenada x deste spot.
Atribua o topo desta caixa à coordenada y deste spot.

Etapas necessárias para que se atribua um caixa's width Into uma width:
Atribua o right desta caixa ao width.
Subtraia o left desta caixa from o width.
Adicione o tpp para o width.

Etapas necessárias para que se atribua um caixa's x-extent Into uma width:
Atribua o right desta caixa ao width.
Subtraia o left desta caixa from o width.

Etapas necessárias para que se atribua um caixa's y-extent Into uma altura:
Atribua a base desta caixa ao altura.
Subtraia o topo desta caixa from o altura.

Etapas necessárias para que se atribua um pedaço e um número Into um fração:
Atribua o pedaço ao numerador desta fração.
Atribua o número ao denominador desta fração.

Etapas necessárias para que se atribua um pedaço Into uma segunda pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda byte
Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um pedaço Into eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o byte
Intel $0FB603. \ movzx eax,byte ptr [ebx]

Etapas necessárias para que se atribua um pedaço Into um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,byte ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se atribua um pedaço Into um string:
Atribua 1 A um length.
Reassign o first deste string usando o length.
Atribua o pedaço ao target deste first deste string.
Atribua o first deste string ao last deste string.

Etapas necessárias para que se atribua um pedaço Into um wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $660FB600. \ movzx eax,byte ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o wyrd
Intel $668903. \ mov [ebx],ah

Etapas necessárias para que se atribua o character under um finger Into um character:
Se o finger for inexistente, limpe o character; exit.
Atribua o target deste finger ao character.

Etapas necessárias para que se atribua uma cor Into uma segunda cor:
Atribua a matiz desta cor à matiz desta segunda cor.
Atribua a saturação desta cor à saturação desta segunda cor.
Atribua a luminosidade desta cor à luminosidade desta segunda cor.

Etapas necessárias para que se atribua um date/time Into uma segunda date/time:
Atribua o year deste date/time ao year deste segunda date/time.
Atribua o month deste date/time ao month deste segunda date/time.
Atribua o week day deste date/time ao week day segunda date/time.
Atribua o day deste date/time ao day deste segunda date/time.
Atribua a hour deste date/time à hour deste segunda date/time.
Atribua o minute deste date/time ao minute deste segunda date/time.
Atribua o second deste date/time ao second deste segunda date/time.
Atribua o millisecond deste date/time ao millisecond deste segunda date/time.

Etapas necessárias para que se atribua um date/time's string Into um string:
Limpe o string.
Posponha o year deste date/time para o string.
Posponha "/" para o string.
Zero fill o month deste date/time usando 2 e posponha it para o string.
Posponha "/" para o string.
Zero fill o day deste date/time usando 2 e posponha it para o string.
Posponha " " para o string.
Zero fill a hour deste date/time usando 2 e posponha it para o string.
Posponha ":" para o string.
Zero fill o minute deste date/time usando 2 e posponha it para o string.
Posponha ":" para o string.
Zero fill o second deste date/time usando 2 e posponha it para o string.
Posponha ":" para o string.
Zero fill o millisecond deste date/time usando 3 e posponha it para o string.

Etapas necessárias para que se atribua eax Into um pedaço:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua eax Into um alarme;
Etapas necessárias para que se atribua eax Into um endereço de memória;
Etapas necessárias para que se atribua eax Into um número:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se atribua eax Into um wyrd:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o wyrd
Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua um elipse no middle of um caixa;
Etapas necessárias para que se centralize um elipse em um caixa:
Centralize o elipse no caixa (horizontally).
Centralize o elipse no caixa (vertically).

Etapas necessárias para que se atribua um elipse Into uma segunda elipse:
Atribua a caixa desta elipse à caixa desta segunda elipse.

Etapas necessárias para que se atribua um elipse sobre um spot;
Etapas necessárias para que se centralize um elipse sobre um spot:
Centralize a caixa desta elipse sobre o spot.

Etapas necessárias para que se atribua um finger sobre o first character of um string:
Atribua o first deste string ao finger.


Etapas necessárias para que se atribua um alarme Into uma segunda alarme;
Etapas necessárias para que se atribua um alarme Into um número;
Etapas necessárias para que se atribua um endereço de memória Into um número;
Etapas necessárias para que se atribua um endereço de memória Into uma segunda endereço de memória;
Etapas necessárias para que se atribua um número Into um alarme;
Etapas necessárias para que se atribua um número Into um endereço de memória;
Etapas necessárias para que se atribua um número Into uma segunda número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda número
Intel $8903. \ mov [ebx],eax

Etapas necessárias para que se atribua um alarme Into eax;
Etapas necessárias para que se atribua um endereço de memória Into eax;
Etapas necessárias para que se atribua um número Into eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o número
Intel $8B03. \ mov eax,[ebx]

Etapas necessárias para que se atribua um alarme Into um string;
Etapas necessárias para que se convert um alarme para um string:
Se o alarme estiver ativo, atribua "yes" ao string; exit. \ has que ser inglês por conta das externalized reams
Atribua "no" ao string.

Etapas necessárias para que se atribua uma font Into uma segunda font:
Atribua o name desta font ao name desta segunda font.
Atribua a altura desta font à altura desta segunda font.

Etapas necessárias para que se atribua alguns font widths Into um trecho:
\ used por pdf conversion
Limpe o trecho.
Se o font widths forem inexistente, cancele.
Atribua o data destes font widths A um número endereço de memória.
Percorra.
Se um contador é past a contagem destas font widths, pare.
Posponha o target deste número endereço de memória then " " para o trecho.
Adicione 1 para um contagem.
Se o contagem é evenly divisible por 16, posponha o texto CRLF para o trecho.
Adicione um número's magnitude para o número endereço de memória.
Repita.

Etapas necessárias para que se atribua um font's adjusted altura Into um altura:
Atribua a altura desta font times 3/4 ao altura.

Etapas necessárias para que se atribua uma fração Into uma segunda fração:
Atribua o numerador desta fração ao numerador desta segunda fração.
Atribua o denominador desta fração ao denominador desta segunda fração.

Etapas necessárias para que se atribua uma fração Into um string;
Etapas necessárias para que se convert uma fração para um string:
Limpe o string.
Isole a fração.
Se a fração é negative, atribua "-" ao string; de-sign a fração.
Reduce a fração.
Convert a fração para um mixed.
Se o mixed for 0, posponha "0" para o string; exit.
Se o whole número deste mixed não for 0, posponha o whole número deste mixed para o string.
Se o fração deste mixed for 0, cancele.
Se o string não estiver em branco, posponha o hífem para o string.
Posponha o numerador deste mixed then "/" then o denominador deste mixed para o string.

Etapas necessárias para que se atribua uma fração pair Into uma segunda fração pair:
Atribua a fração deste fração pair à fração deste segunda fração pair.
Atribua a segunda fração deste fração pair à segunda fração deste segunda fração pair.

Etapas necessárias para que se atribua um fração's absolute value Into uma segunda fração:
Atribua a fração à segunda fração.
De-sign a segunda fração.

Etapas necessárias para que se atribua um gpimage's gprect Into um gprect:
Atribua 0 ao x deste gprect.
Atribua 0 ao y deste gprect.
Atribua a width desta gpimage ao width deste gprect.
Atribua a altura desta gpimage à altura deste gprect.

Etapas necessárias para que se atribua um gpimage's altura Into uma altura:
Se o gpimage for inexistente, atribua 0 ao altura; exit.
Call "gdiplus.dll" "GdipGetImageHeight" with o gpimage e o whereabouts desta altura.

Etapas necessárias para que se atribua um gpimage's width Into uma width:
Se o gpimage for inexistente, atribua 0 ao width; exit.
Call "gdiplus.dll" "GdipGetImageWidth" with o gpimage e o whereabouts desta width.

Etapas necessárias para que se atribua um gprect Into uma segunda gprect:
Atribua o x deste gprect ao x deste segunda gprect.
Atribua o y deste gprect ao y deste segunda gprect.
Atribua o width deste gprect ao width deste segunda gprect.
Atribua a altura deste gprect à altura deste segunda gprect.

Etapas necessárias para que se atribua um matiz e um saturação e um luminosidade Into um cor:
Atribua o matiz à matiz desta cor.
Se a matiz desta cor não for -1, limite a matiz desta cor para 0 e 3599. \ -1 estiver clear
Atribua o saturação à saturação desta cor.
Limite a saturação desta cor para 0 e 1000.
Atribua o luminosidade à luminosidade desta cor.
Limite a luminosidade desta cor para 0 e 1000.

Etapas necessárias para que se atribua um index's contagem Into uma contagem:
Atribua 0 à contagem.
Se o index for inexistente, cancele.
Percorra.
Obtenha um bucket usando o index.
Se o bucket for inexistente, cancele.
Adicione a contagem destes refers deste bucket para a contagem.
Repita.

Etapas necessárias para que se atribua um index's used bucket contagem Into uma contagem:
Atribua 0 à contagem.
Se o index for inexistente, cancele.
Percorra.
Obtenha um bucket usando o index.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Adicione 1 para a contagem.
Repita.

Etapas necessárias para que se atribua um left coord e um topo coord e um right coord e um base coord e um radius Into um caixa arredondada:
Atribua o left ao left desta caixa arredondada.
Atribua o topo ao topo desta caixa arredondada.
Atribua o right ao right desta caixa arredondada.
Atribua o base à base desta caixa arredondada.
Atribua o radius ao radius desta caixa arredondada.

Etapas necessárias para que se atribua um left coord e um topo coord e um right coord e um base coord Into um caixa:
Atribua o left ao left desta caixa.
Atribua o topo ao topo desta caixa.
Atribua o right ao right desta caixa.
Atribua o base à base desta caixa.

Etapas necessárias para que se atribua um left coord e um topo coord e um right coord e um base coord Into um elipse:
Atribua o left ao left desta elipse.
Atribua o topo ao topo desta elipse.
Atribua o right ao right desta elipse.
Atribua o base à base desta elipse.

Etapas necessárias para que se atribua o left of um caixa Into um vertical line;
Etapas necessárias para que se atribua o left edge of um caixa Into um vertical line;
Etapas necessárias para que se atribua o left side of um caixa Into um vertical line:
Atribua o left-top desta caixa ao start desta vertical line.
Atribua o left-base desta caixa ao end desta vertical line.

Etapas necessárias para que se atribua um line no middle of um caixa;
Etapas necessárias para que se centralize um line em um caixa:
Centralize o line no caixa (horizontally).
Centralize o line no caixa (vertically).

Etapas necessárias para que se atribua um line Into uma segunda line:
Atribua o start desta line ao start desta segunda line.
Atribua o end desta line ao end desta segunda line.

Etapas necessárias para que se atribua um line's base Into uma coord:
Atribua o y deste start desta line ao coord.
Se o y deste end desta line for maior do que o y deste start desta line, atribua o y deste end desta line ao coord.

Etapas necessárias para que se atribua um line's caixa Into uma caixa:
Atribua o start desta line ao left-top desta caixa.
Atribua o end desta line ao right-base desta caixa.
Normalize o caixa.

Etapas necessárias para que se atribua um line's center Into um spot:
Atribua o coordenada x desta start desta line mais a coordenada x deste end desta line à coordenada x deste spot.
Atribua o coordenada y desta start desta line mais a coordenada y deste end desta line à coordenada y deste spot.
Divida o spot por 2.

Etapas necessárias para que se atribua um line's left Into um coord:
Atribua o coordenada x desta start desta line ao coord.
Se a coordenada x deste end desta line for menor do que o coordenada x desta start desta line, atribua a coordenada x deste end desta line ao coord.

Etapas necessárias para que se atribua um line's right Into um coord:
Atribua o coordenada x desta start desta line ao coord.
Se a coordenada x deste end desta line for maior do que o coordenada x desta start desta line, atribua a coordenada x deste end desta line ao coord.

Etapas necessárias para que se atribua um line's topo Into um coord:
Atribua o coordenada y desta start desta line ao coord.
Se a coordenada y deste end desta line for menor do que o coordenada y desta start desta line, atribua a coordenada y deste end desta line ao coord.

Etapas necessárias para que se atribua masking tape below um figura:
Se o figura for inexistente, cancele.
Se a contagem destes vértices desta figura for menor do que 2, cancele.
Copy a figura para uma segunda figura.
Atribua a base desta tela A um spot's coordenada y.
Atribua a coordenada x deste last desta figura à coordenada x deste spot.
Posponha o spot para a segunda figura.
Atribua o coordenada x deste first desta figura à coordenada x deste spot.
Posponha o spot para o segunda figura.
Posponha o spot deste first desta figura para o segunda figura.
Mask inside o segunda figura.
Destroy o segunda figura.

Etapas necessárias para que se atribua o middle of um line sobre um spot;
Etapas necessárias para que se centralize um line sobre um spot:
Obtenha um difference between o spot e o center desta line.
Round a difference para o nearest multiple of o tpp.
Mova o line usando a difference.

Etapas necessárias para que se atribua o spot deste mouse Into um spot:
Call "user32.dll" "GetCursorPos" with o whereabouts deste spot.
Call "user32.dll" "ScreenToClient" with o main window e o whereabouts deste spot. \ em case window é sobre uma segunda monitor.
Call "gdi32.dll" "DPtoLP" with o tela canvas e o whereabouts deste spot e 1.

Etapas necessárias para que se atribua um name e um altura Into um font:
Atribua o name ao name desta font.
Atribua o altura à altura desta font.

Etapas necessárias para que se atribua um name Into uma font:
Atribua o name ao name desta font.

Etapas necessárias para que se atribua um número e uma segunda número Into um pair:
Atribua o número ao número x deste pair.
Atribua o segunda número ao número y deste pair.

Etapas necessárias para que se atribua um número Into um big-endian unsigned wyrd:
Atribua o número A um wyrd.
Atribua o wyrd ao big-endian unsigned wyrd.

Etapas necessárias para que se atribua um número Into um pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um número Into um fração:
Atribua o número ao numerador desta fração.
Atribua 1 ao denominador desta fração.

Etapas necessárias para que se atribua um número Into um pair:
Atribua o número ao número x deste pair.
Atribua o número ao número y deste pair.

Etapas necessárias para que se atribua um número Into um string;
Etapas necessárias para que se convert um número para um string:
Limpe o string.
Isole o número.
De-sign o número.
Percorra.
Divida o número por 10 giving um quotient e um resto.
Adicione 48 para o resto.
Atribua o resto A um pedaço.
Anteponha o pedaço para o string.
Se o quotient for 0, pare.
Atribua o quotient ao número.
Repita.
Se o original número for menor do que 0, anteponha o hífem para o string.

Etapas necessárias para que se atribua um número Into um wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o wyrd
Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua um número sobre o stack:
Convert o número para um token.
Atribua o token sobre o stack.

Etapas necessárias para que se atribua um número over uma segunda número em uma fração;
Etapas necessárias para que se atribua um número e uma segunda número Into uma fração:
Atribua o número ao numerador desta fração.
Atribua o segunda número ao denominador desta fração.

Etapas necessárias para que se atribua um número's absolute value Into uma segunda número:
Atribua o número ao segunda número.
De-sign o segunda número.

Etapas necessárias para que se atribua um outlinetextmetric Into uma segunda outlinetextmetric:
Copy pedaços from o whereabouts deste outlinetextmetric para o whereabouts deste segunda outlinetextmetric pela magnitude deste outlinetextmetric.


Etapas necessárias para que se atribua um pair Into uma segunda pair:
Atribua o número x deste pair ao número x deste segunda pair.
Atribua o número y deste pair ao número y deste segunda pair.

Etapas necessárias para que se atribua um pair's absolute value Into uma segunda pair:
Atribua o pair ao segunda pair.
De-sign o segunda pair.

 \ unclear why this does not get called properly when I replace hoja apaisada with caja ***

Etapas necessárias para que se atribua um picture no middle of uma caixa;
Etapas necessárias para que se centralize um picture em uma caixa:
Se o picture for inexistente, cancele.
Centralize o picture no caixa (horizontally).
Centralize o picture no caixa (vertically).

Etapas necessárias para que se atribua um picture sobre um spot;
Etapas necessárias para que se centralize um picture sobre um spot:
Se o picture for inexistente, cancele.
Obtenha um difference between o spot e o center desta caixa desta picture.
Round a difference para o nearest multiple of o tpp.
Mova o picture usando a difference.

Etapas necessárias para que se atribua um polygon no middle of um caixa;
Etapas necessárias para que se centralize um polygon em um caixa:
Se o polygon for inexistente, cancele.
Centralize o polygon no caixa (horizontally).
Centralize o polygon no caixa (vertically).

Etapas necessárias para que se atribua um polygon no middle of o tela;
Etapas necessárias para que se centralize um polygon sobre o tela:
Centralize o polygon na caixa desta tela.

Etapas necessárias para que se atribua um polygon sobre um spot;
Etapas necessárias para que se centralize um polygon sobre um spot:
Se o polygon for inexistente, cancele.
Obtenha um difference between o spot e o center desta caixa deste polygon.
Round a difference para o nearest multiple of o tpp.
Mova o polygon usando a difference.

Etapas necessárias para que se atribua um polygon's caixa Into um caixa:
Se o polygon for inexistente, zero o caixa; exit.
Se os vértices deste polygon estiverem vazio, zero o caixa; exit.
Atribua o maior número e o maior número e o menor número e o menor número ao caixa.
Percorra.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, pare.
Se a coordenada x deste vértice for menor do que o left desta caixa, atribua a coordenada x deste vértice ao left desta caixa.
Se a coordenada y deste vértice for menor do que o topo desta caixa, atribua a coordenada y deste vértice ao topo desta caixa.
Se a coordenada x deste vértice for maior do que o right desta caixa, atribua a coordenada x deste vértice ao right desta caixa.
Se a coordenada y deste vértice for maior do que a base desta caixa, atribua a coordenada y deste vértice à base desta caixa.
Repita.

Etapas necessárias para que se atribua um polygon's center Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o center desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's center-base Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o center-base desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's center-top Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o center-top desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's altura Into um altura:
Se o polygon for inexistente, limpe o altura; exit.
Atribua a altura desta caixa deste polygon à altura.

Etapas necessárias para que se atribua um polygon's left-base Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o left-base desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's left-center Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o left-center desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's left-top Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o left-top desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's right-base Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o right-base desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's right-center Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o right-center desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's right-top Into um spot:
Se o polygon for inexistente, limpe o spot; exit.
Atribua o right-top desta caixa deste polygon ao spot.

Etapas necessárias para que se atribua um polygon's width Into uma width:
Se o polygon for inexistente, limpe o width; exit.
Atribua a width desta caixa deste polygon à width.

Etapas necessárias para que se atribua um polygon's x-extent Into uma width:
Se o polygon for inexistente, limpe o width; exit.
Atribua o x-extent desta caixa deste polygon ao width.

Etapas necessárias para que se atribua um polygon's y-extent Into um altura:
Se o polygon for inexistente, limpe o altura; exit.
Atribua o y-extent desta caixa deste polygon ao altura.

Etapas necessárias para que se atribua um percorredor Into uma segunda percorredor:
Copy pedaços from o whereabouts deste percorredor para o whereabouts deste segunda percorredor pela magnitude deste percorredor.

Etapas necessárias para que se atribua o right of um caixa Into uma vertical line;
Etapas necessárias para que se atribua o right edge of um caixa Into uma vertical line;
Etapas necessárias para que se atribua o right side of um caixa Into uma vertical line:
Atribua o right-top desta caixa ao start desta vertical line.
Atribua o right-base desta caixa ao end desta vertical line.

Etapas necessárias para que se atribua um caixa arredondada Into uma segunda caixa arredondada:
Atribua o left desta caixa arredondada ao left desta segunda caixa arredondada.
Atribua o topo desta caixa arredondada ao topo desta segunda caixa arredondada.
Atribua o right desta caixa arredondada ao right desta segunda caixa arredondada.
Atribua a base desta caixa arredondada à base desta segunda caixa arredondada.
Atribua o radius desta caixa arredondada ao radius desta segunda caixa arredondada.

Etapas necessárias para que se atribua um row's working string Into um subtexto:
Se a row for inexistente, limpe o subtexto; exit.
Lance o subtexto sobre o string deste row.
Subtraia 1 from o last deste subtexto.

Etapas necessárias para que se atribua um selection Into uma segunda selection:
Atribua o anchor desta selection ao anchor desta segunda selection.
Atribua o caret desta selection ao caret desta segunda selection.

Etapas necessárias para que se atribua um sockaddr Into uma segunda sockaddr:
Copy pedaços from o whereabouts deste sockaddr para o whereabouts deste segunda sockaddr pela magnitude deste sockaddr.

Etapas necessárias para que se atribua um spot e uma segunda spot e um radius Into um caixa arredondada:
Atribua o spot ao left-top desta caixa arredondada.
Atribua o segunda spot à right-base desta caixa arredondada.
Atribua o radius ao radius desta caixa arredondada.

Etapas necessárias para que se atribua um spot e uma segunda spot Into uma caixa:
Atribua o spot ao left-top desta caixa.
Atribua o segunda spot ao right-base desta caixa.

Etapas necessárias para que se atribua um spot e uma segunda spot Into uma elipse:
Atribua o spot ao left-top desta elipse.
Atribua o segunda spot ao right-base desta elipse.

Etapas necessárias para que se atribua um spot e uma segunda spot Into uma line:
Atribua o spot ao start desta line.
Atribua o segunda spot ao end desta line.

Etapas necessárias para que se atribua um spot no middle of uma caixa;
Etapas necessárias para que se centralize um spot em um caixa:
Centralize o spot no caixa (horizontally).
Centralize o spot no caixa (vertically).

Etapas necessárias para que se atribua um string Into uma segunda string:
Atribua o length deste string A um saved length.
Assign um endereço de memória usando o saved length.
Copy pedaços from o first deste string para o endereço de memória pelo saved length.
Unassign o first deste segunda string.
Atribua o endereço de memória ao first deste segunda string.
Atribua o first deste segunda string mais o saved length menos 1 ao last deste segunda string.

Etapas necessárias para que se atribua um string Into uma letra:
Atribua o target deste first deste string ao letra.

Etapas necessárias para que se atribua um string Into um text:
Se o text for inexistente, cancele.
Destroy as rows deste text.
Reset o origin of o text.
Reset o caret of o text.
Deselect o text.
Isole o string.
Posponha o return pedaço para o string.
Convert o string para as rows deste text.
Wrap o text.

Etapas necessárias para que se atribua um string sobre o windows clipboard:
Call "user32.dll" "OpenClipboard" with o main window.
Call "user32.dll" "EmptyClipboard".
Atribua o length deste string mais 1 A um número.
Call "kernel32.dll" "GlobalAlloc" with 66 [ghnd] e o número returning um handle.
Call "kernel32.dll" "GlobalLock" with o handle returning um endereço de memória.
Copy pedaços from o first deste string para o endereço de memória pelo length deste string.
Call "kernel32.dll" "GlobalUnlock" with o handle.
Call "user32.dll" "SetClipboardData" with 1 [cf_text] e o handle.
Call "user32.dll" "CloseClipboard".

Etapas necessárias para que se atribua um string's length Into um length:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o string
\ load default result
Intel $B900000000. \ mov ecx,0
\ if first for 0, store 0
Intel $833B00. \ cmp [ebx],0
Intel $0F8414000000. \ je store it
\ if last for menor do que first, store 0
Intel $8B5304. \ mov edx,[ebx+4] \ last endereço de memória
Intel $3B13. \ cmp edx,[ebx]
Intel $0F8C09000000. \ jl store it
\ calc length
Intel $8B8B04000000. \ mov ecx,[ebx+4] \ last endereço de memória
Intel $2B0B. \ sub ecx,[ebx] \ subtraia first
Intel $41. \ inc ecx \ adicione 1
\ STORE IT:
Intel $8B950C000000. \ mov edx,[ebp+12] \ o número
Intel $890A. \ mov [edx],ecx

Etapas necessárias para que se atribua um string's width Into um width:
Obtenha o width usando o string e o memory canvas e a default font.

\ \ leave out - causes Spanish string atribuas para resolva here instead of "Atribua um string A uma segunda string"
Etapas necessárias para que se atribua um subtexto Into uma segunda subtexto:
Copy pedaços from o whereabouts deste subtexto para o whereabouts deste segunda subtexto pela magnitude deste subtexto.

Etapas necessárias para que se atribua o system's date/time Into um date/time:
Call "kernel32.dll" "GetLocalTime" with um systemtime's whereabouts.
Atribua o wyear deste systemtime ao year deste date/time.
Atribua o wmonth deste systemtime ao month deste date/time.
Atribua o wdayofweek deste systemtime ao week day deste date/time.
Atribua o wday deste systemtime ao day deste date/time.
Atribua o whour deste systemtime à hour deste date/time.
Atribua o wminute deste systemtime ao minute deste date/time.
Atribua o wsecond deste systemtime ao second deste date/time.
Atribua os wmilliseconds deste systemtime ao millisecond deste date/time.

Etapas necessárias para que se atribua o system's last erro Into um número:
Call "kernel32.dll" "GetLastError" returning o número.

Etapas necessárias para que se atribua o system's last winsock erro Into um número:
Call "ws2_32.dll" "WSAGetLastError" returning o número.

Etapas necessárias para que se atribua o system's tick contagem Into alguns ticks:
\ wraps cada 24.8 days ou so
Call "kernel32.dll" "GetTickCount" returning o ticks.
Conjuncione logicamente o ticks with o maior número.

Etapas necessárias para que se atribua um terminal no middle of um caixa;
Etapas necessárias para que se centralize um terminal em um caixa:
Isole o caixa.
Indent o caixa 1/4 inch.
Atribua o caixa à caixa deste terminal.

Etapas necessárias para que se atribua um text no middle of um caixa;
Etapas necessárias para que se centralize um text em um caixa:
Se o text for inexistente, cancele.
Centralize o text no caixa (horizontally).
Centralize o text no caixa (vertically).

Etapas necessárias para que se atribua um text sobre um spot;
Etapas necessárias para que se centralize um text sobre um spot:
Se o text for inexistente, cancele.
Obtenha um difference between o spot e o center desta caixa deste text.
Round a difference para o nearest multiple of o tpp.
Mova o text usando a difference.

Etapas necessárias para que se atribua um text's first line Into um string:
Se o text for inexistente, limpe o string; exit.
Atribua o string desta first row deste text ao string.
Remove o last pedaço from o string.

Etapas necessárias para que se atribua um text's first non-em branco line Into um string:
\ *** new
Limpe o string.
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Atribua o string deste row ao string.
Remove o last pedaço from o string. \ cr ou space (see text rules)
Remove any leading noise from o string.
Remove any trailing noise from o string.
Se o string estiver em branco, repita.

Etapas necessárias para que se atribua um text's globalized origin Into um spot:
Se o text for inexistente, limpe o spot; exit.
Atribua a origin deste text ao spot.
Globalize o spot usando o left-top deste text.

Etapas necessárias para que se atribua um text's grid Into um grid:
Se o text for inexistente, limpe o grid; exit.
Atribua a altura desta font deste text times 4 ao número x desta grid.
Atribua a altura desta font deste text ao número y desta grid.

Etapas necessárias para que se atribua um text's normalized selection Into um selection:
Se o text for inexistente, cancele.
Atribua a selection deste text ao selection.
Normalize o selection.

Etapas necessárias para que se atribua um text's row contagem Into um contagem:
Se o text for inexistente, atribua 0 ao contagem; exit.
Se as rows deste text estiverem vazio, atribua 0 à contagem; exit.
Atribua o número da linha deste last destas rows deste text à contagem.

Etapas necessárias para que se atribua um text's row altura Into um altura:
Se o text for inexistente, atribua 0 ao altura; exit.
Atribua a altura desta font deste text ao altura.

Etapas necessárias para que se atribua um text's rows/box Into um contagem:
Se o text for inexistente, atribua 0 ao contagem; exit.
Atribua a altura desta caixa deste text dividido pela row altura deste text à contagem.

Etapas necessárias para que se atribua um text's selecionado quantidade de pedaços Into uma contagem:
Atribua 0 à contagem.
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Lance um subtexto sobre any selecionado pedaços na row of o text.
Adicione o length deste subtexto para a contagem.
Repita.

Etapas necessárias para que se atribua um text's selecionado row contagem Into uma contagem:
Atribua 0 à contagem.
Se o text for inexistente, cancele.
Atribua a normalized selection deste text A um selection.
Se o anchor número da linha desta selection é o caret número da linha desta selection, cancele.
Atribua o caret número da linha desta selection à contagem.
Subtraia o anchor número da linha desta selection from a contagem.
Se o caret column# desta selection não for 1, adicione 1 para a contagem.

Etapas necessárias para que se atribua um text's painel de informações string Into um string:
Se o text for inexistente, limpe o string; exit.
Atribua a selecionado row contagem deste text A uma contagem.
Se o contagem não for 0, format o contagem e "linha selecionada" ou "linhas selecionadas" ao string; exit.
Atribua a selecionado quantidade de pedaços deste text A uma segunda contagem.
Se o segunda contagem não for 0, format a segunda contagem e "pedaço" ou "pedaços" ao string; exit.
Convert o caret número da linha deste text para o string.
Posponha ":" para o string.
Posponha o caret column# deste text para o string.

Etapas necessárias para que se atribua uma coisa at o end of alguns coisas;
Etapas necessárias para que se posponha uma coisa para alguns coisas:
Se a coisa for inexistente, cancele.
Atribua o last destas coisas ao previous desta coisa.
Se as coisas não estiverem vazio, atribua a coisa ao next deste last destas coisas.
Se as coisas estiverem vazio, atribua a coisa ao first destas coisas.
Atribua a coisa ao last destas coisas.

Etapas necessárias para que se atribua alguns coisas Into algumas segunda coisas:
Atribua o first destas coisas ao first destas segunda coisas.
Atribua o last destas coisas ao last destas segunda coisas.

Etapas necessárias para que se atribua algumas coisas' contagem Into uma contagem:
Atribua 0 à contagem.
Percorra.
Obtenha uma coisa from as coisas.
Se a coisa for inexistente, cancele.
Adicione 1 para a contagem.
Repita.

Etapas necessárias para que se atribua um cronômetro Into um string;
Etapas necessárias para que se convert um cronômetro para um string:
Convert os ticks deste cronômetro para o string.

Etapas necessárias para que se atribua um cronômetro's string Into um string:
Convert os ticks deste cronômetro para o string.

Etapas necessárias para que se atribua um cronômetro's ticks Into alguns ticks:
Atribua os total ticks deste cronômetro a os ticks.
Se a contagem deste cronômetro for 0, cancele.
Atribua a system's tick contagem A alguns segunda ticks. \ system's tick contagem
Subtraia os start ticks deste cronômetro from os segunda ticks.
Adicione os segunda ticks para os ticks.

Etapas necessárias para que se atribua um token sobre o stack:
Allocate memory por um stack entry.
Atribua o token ao string desta stack entry.
Anteponha o stack entry para o stack.

Etapas necessárias para que se atribua o topo of um caixa Into um horizontal line;
Etapas necessárias para que se atribua o topo edge of um caixa Into um horizontal line;
Etapas necessárias para que se atribua o topo side of um caixa Into um horizontal line:
Atribua o left-top desta caixa ao start desta horizontal line.
Atribua o right-top desta caixa ao end desta horizontal line.

Etapas necessárias para que se atribua o topo of um caixa Into um line:
Make o line with o left-top desta caixa e o right-top desta caixa.

Etapas necessárias para que se atribua um wyrd Into uma segunda wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $668B00. \ mov ax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda wyrd
Intel $668903. \ mov [ebx],ax

Etapas necessárias para que se atribua um wyrd Into um big-endian unsigned wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $668B00. \ mov ax,word ptr [eax]
Intel $86E0. \ xchg al,ah
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o big-endian unsigned wyrd
Intel $668903. \ mov palavra ptr [ebx],ax

Etapas necessárias para que se atribua um wyrd Into um pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $668B00. \ mov ax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
Intel $8803. \ mov [ebx],al

Etapas necessárias para que se atribua um wyrd Into eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ o wyrd
Intel $0FBF03. \ movsx eax,word ptr [ebx]

Etapas necessárias para que se atribua um wyrd Into um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $0FBF00. \ movsx eax,wyrd ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
Intel $8903. \ mov [ebx],eax

Um coordenada x é um coord.
Um coordenada y é um coord.

Etapas necessárias para que se atribua um coordenada x e um coordenada y e uma segunda coordenada x e uma segunda coordenada y Into uma line:
Atribua o coordenada x ao coordenada x desta start desta line.
Atribua o coordenada y ao coordenada y desta start desta line.
Atribua o segunda coordenada x à coordenada x deste end desta line.
Atribua o segunda coordenada y à coordenada y deste end desta line.

O tecla Q/q é uma tecla igual a 81.

Um query pedaço é um query string.

Um query string é um string.

O question-mark pedaço é um pedaço igual a 63.

Etapas necessárias para que se quit;
Etapas necessárias para que se tell Windows we're done;
Etapas necessárias para que se tell Windows o usuário has quit;
Etapas necessárias para que se relinquish control:
Desmanche o event queue.
Crie um event.
Atribua "fechamento do programa" à categoria deste event.
\Atribua "hecho" ao categoria deste event.
Enque o event.

Um quora é uma coisa with um string e um cor. \ quora é short por "question ou texto do campo"

Etapas necessárias para que se quote um string:
\ inserts leading, trailing e nested double-quotes
Atribua as aspas duplas A uma segunda string.
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, pare.
Posponha o target deste first deste subtexto para o segunda string.
Se o target deste first deste subtexto for as aspas duplas, posponha as aspas duplas para o segunda string.
Adicione 1 para o first deste subtexto.
Repita.
Posponha as aspas duplas para o segunda string.
Atribua o segunda string ao string.

Um quotient é um número.

O tecla R/r é uma tecla igual a 82.

Um radius é alguns twips.

Um rainbow cor é uma cor.

Etapas necessárias para que se raise um número para uma segunda número:
Se o segunda número for 0, atribua 1 ao número; exit.
Se o segunda número for menor do que 0, atribua 0 ao número; exit. \ deveria ser 1/the raised result, but always comes out 0 with números
Atribua 1 A um result número.
Percorra.
Se um contador é past o segunda número, pare.
Multiplique o result pelo número.
Repita.
Atribua o result ao número.

Um random número é um número.

Um ratio é um fração.

Um ratio pair é uma fração pair.

Etapas necessárias para que se read o Bíblia:
Se o Bíblia não for inexistente, cancele.
Extract um endereço da pasta from o endereço completo deste module.
Percorra.
Se o endereço da pasta estiver em branco, cancele.
Atribua o endereço da pasta then "Bíblia.txt" A um endereço completo.
Se o endereço completo estiver no sistema de arquivos, read o Bíblia usando o endereço completo; exit.
Extract o endereço da pasta from o endereço da pasta.
Repita.

Etapas necessárias para que se read a Bíblia usando um endereço completo:
Se o Bíblia não for inexistente, cancele.
Read o endereço completo A um trecho.
Se o i/o erro não estiver em branco, cancele.
Allocate memory pelo Bíblia.
Lance um percorredor sobre o trecho.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Allocate memory por um verse. Posponha o verse para os verses desta Bíblia.
Mova o percorredor (text file rules).
Atribua o token deste percorredor ao string deste verse.
Remove any leading noise from o string deste verse.
Remove any trailing noise from o string deste verse.
Repita.

Etapas necessárias para que se read um pedaço from um console:
Read um string from o console.
Se o string estiver em branco, atribua o null pedaço ao pedaço; exit.
Atribua o target deste first deste string ao pedaço.

Etapas necessárias para que se read um console Into um string:
Se o console for inexistente, limpe o string; exit.
Desmanche all events.
Limpe o reply deste console.
Mostre o console.
Gerencie events usando o console.
Atribua o reply deste console ao string.
Desmanche all events.
Atualize o cursor.

Etapas necessárias para que se read um file Into um trecho:
Limpe o i/o erro.
Call "kernel32.dll" "GetFileSize" with o file e nil returning um size.
Reassign o first deste trecho usando o size.
Atribua o first deste trecho mais o size menos 1 ao last deste trecho.
Call "kernel32.dll" "ReadFile" with o file e o first deste trecho e o size e um número's whereabouts e 0 returning um result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de tentar ler o arquivo." ao i/o erro; exit.

Etapas necessárias para que se read um alarme from um console:
Read um string from o console.
Convert o string para o alarme.

Etapas necessárias para que se read uma fração from um console:
Read um string from o console.
Convert o string para a fração.

Etapas necessárias para que se read um número from um console:
Read um string from o console.
Convert o string para o número.

Etapas necessárias para que se load um endereço completo Into um trecho;
Etapas necessárias para que se read um endereço completo Into um trecho:
Limpe o i/o erro.
Isole o endereço completo.
Null terminate o endereço completo.
Se o endereço completo não estiver no sistema de arquivos, atribua "O Arquivo: " then o endereço completo then " não existe." ao i/o erro; exit.
\ abra o endereço completo para read-write mode.
Call "kernel32.dll" "CreateFileA" with o first deste endereço completo e -2147483648 [generic_read] e 3 [file_share_read+file_share_write] e 0 
And 3 [open_existing] e 0 e 0 returning um handle.
Se o handle é -1 [invalid_handle_value], atribua "Ocorreu um erro na hora de tentar abrir o arquivo: " then o endereço completo then "." ao i/o erro; exit.
Call "kernel32.dll" "GetFileSize" with o handle e nil returning um size.
Reassign o first deste trecho usando o size.
Atribua o first deste trecho mais o size menos 1 ao last deste trecho.
Call "kernel32.dll" "ReadFile" with o handle e o first deste trecho e o size e um número's whereabouts e 0 returning o número.
Call "kernel32.dll" "CloseHandle" with o handle.
Se o número não for 0, cancele.
Atribua "Ocorreu um erro na hora de tentar ler o arquivo: " then o endereço completo then "." ao i/o erro.

Etapas necessárias para que se load um endereço completo Into um picture:

Etapas necessárias para que se read um endereço completo Into um picture:
Read o endereço completo A um trecho.
Se o i/o erro não estiver em branco, esvazie o picture; exit.
Crie o picture usando o trecho.

Etapas necessárias para que se read um reply from um terminal:
Se o terminal for inexistente, limpe o reply; exit.
Desmanche all events.
Limpe o reply deste terminal.
Adicione um quora para o terminal.
Atribua "> " ao string deste quora.
Atribua a input cor deste terminal à cor deste quora.
Mostre o terminal.
Gerencie events usando o terminal.
\ mostre o terminal.
Atribua o reply deste terminal ao reply.
Remove any leading noise from o reply.
Remove any trailing noise from o reply.
Desmanche all events.
\ questionable below
Crie um event.
Atribua "clique" à categoria deste event.
\Atribua "clic izquierdo" à categoria deste event.
Atribua o spot deste mouse ao spot deste event.
Enque o event.
Atualize o cursor.

Etapas necessárias para que se read um response string from um winhttp request:
Se o winhttp request for inexistente, cancele.
Limpe o response.
Atribua 8 kilopedaços A um trecho size.
Percorra.
Atribua 0 A um size.
Call "winhttp.dll" "WinHttpqueryDataAvailable"
With a request deste winhttp request e o whereabouts deste size returning um result número.
Se o result for 0, atribua "Erro. Não foi possível consultar os dados disponíveis." ao i/o erro; limpe o response; break.
Atribua o length desta response A um saved length.
Reassign o first desta response usando o saved length mais o trecho size.
Atribua o first desta response mais o saved length A um endereço de memória.
Call "winhttp.dll" "WinHttpReadData" with a request deste winhttp request e o endereço de memória
And o trecho size e um contagem's whereabouts returning o result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de ler os dados." ao i/o erro; limpe o response; break.
Atribua o endereço de memória mais o contagem menos 1 ao last desta response.
Se o contagem for 0, pare.
Repita.

Etapas necessárias para que se read stdin Into um trecho:
Limpe o i/o erro.
Limpe o trecho.
Encontre um string usando o environment variables e "CONTENT_LENGTH".
Se o string estiver em branco, atribua "Ocorreu um erro na hora de obter o conteúdo de comprimento CONTENT_LENGTH." ao i/o erro; exit.
Convert o string A um length.
Se o length for 0, cancele.
Reassign o first deste trecho usando o length.
Call "kernel32.dll" "ReadFile" with o stdin handle e o first deste trecho e o length e um número's whereabouts e nil.
Se o número não for o length, atribua "Erro ao ler dados do fluxo de entrada padrão stdin." ao i/o erro; limpe o trecho; exit.
Atribua o first deste trecho mais o length menos 1 ao last deste trecho.

Etapas necessárias para que se read um string from um console:
Read o console ao string.

Etapas necessárias para que se read um url Into um trecho:
\ prepare
Limpe o trecho.
Limpe o i/o erro.
\ internet open
Call "wininet.dll" "InternetOpenA" with o first deste name deste module e 0 [internet_open_type_preconfig] e nil e nil returning um internet handle.
Se o internet handle for 0, atribua "Erro. Não foi possível se conectar à internet. Verifique sua conexão" ao i/o erro; exit.
\ internet open url
Isole o url.
Null terminate o url.
Call "wininet.dll" "InternetOpenUrlA" with o internet handle e o first desta url e nil e 0 e 0 e 0 returning um url handle.
Se o url handle for 0, atribua "Erro. Não foi possível acessar a URL: " then o url then "." ao i/o erro; call "wininet.dll" "InternetCloseHandle" with o internet handle; exit.
\ read o file
Atribua 64 kilopedaços A um trecho size.
Percorra.
Atribua o length deste trecho A um saved length.
Reassign o first deste trecho usando o saved length mais o trecho size.
Atribua o first deste trecho mais o saved length A um endereço de memória.
Call "wininet.dll" "InternetReadFile" with o url handle e o endereço de memória e o trecho size e um contagem's whereabouts returning um result número.
Se o result número for 0, atribua "Ocorreu um erro na hora de ler a URL: " then o url then "." ao i/o erro; break.
Atribua o endereço de memória mais o contagem menos 1 ao last deste trecho.
Se o contagem for 0, pare.
Repita.
\ clean up
Call "wininet.dll" "InternetCloseHandle" with o url handle.
Call "wininet.dll" "InternetCloseHandle" with o internet handle.

Um really cor escura é uma cor.

Um really light cor é uma cor.

Um really really cor escura é uma cor.

Um really really light cor é uma cor.

Etapas necessárias para que se reassign um endereço de memória usando um quantidade de pedaços:
Se o endereço de memória for inexistente, assign o endereço de memória usando o quantidade de pedaços; exit.
Se o quantidade de pedaços for 0, unassign o endereço de memória; exit.
Isole o quantidade de pedaços.
Round o quantidade de pedaços up para o nearest power of two.
Call "kernel32.dll" "HeapReAlloc" with o heap endereço de memória e 8 [heap_zero_memory] e o endereço de memória e o quantidade de pedaços returning o endereço de memória.

Etapas necessárias para que se receive um trecho from um socket:
Limpe o i/o erro.
Limpe o trecho.
Atribua 8 kilopedaços A um trecho size.
Percorra.
Atribua 0 A um size.
Atribua o length deste trecho A um saved length.
Reassign o first deste trecho usando o saved length mais o trecho size.
Atribua o first deste trecho mais o saved length A um endereço de memória.
Call "ws2_32.dll" "recv" with o socket e o endereço de memória e o trecho size e 0 returning um contagem.
Se o contagem não for -1 [socket_error], atribua o endereço de memória mais o contagem menos 1 ao last deste trecho; exit.
Se o last winsock erro deste system não for 10040 [wsamsgsize], atribua "Ocorreu um erro no recebimento dos dados." ao i/o erro; limpe o trecho; exit.
\Se o system's last winsock erro não for 10040 [wsamsgsize], atribua "Ocorreu um erro no recebimento dos dados." ao i/o erro; limpe o trecho; exit.
Atribua o endereço de memória mais o contagem menos 1 ao last deste trecho.
Repita.

Etapas necessárias para que se receive o response from um winhttp request:
Se o winhttp request for inexistente, cancele.
Call "winhttp.dll" "WinHttpReceiveResponse"
With a request deste winhttp request
And 0
Returning um result número.
Se o result for 0, atribua "No pude enviar o pedido." ao i/o erro; exit.

Um recipient é um string.

O conjunto-separator pedaço é um pedaço igual a 30.

Um retângulo é um figura.
Um skinny retângulo é um retângulo.
Um diamond é um figura.
Um desert landscape é uma coisa.
Um octagon é um figura.
Um arc é um figura.
Um circle é um figura.
Um fractal forest é uma coisa.
Um joke é uma coisa.
Um triangle é um figura.
Um heptagon é um figura. \ 7 sides
Um nonagon é um figura. \ 9 sides
Um decagon é um figura. \ 10 sides
Um hexagon é um figura.
Um koch curve é um figura.
Um twelve-sided figura é um figura.
Um half circle é um figura.
Um half circle flower é um figura.
Um quarter circle é um figura.
Um spiral é um figura.
Um leaf é um figura.
Um half leaf é um figura.
Um five pointed star é um figura.
Um six pointed star é um figura.
Um left crescent é um figura.
Um right crescent é um figura.
Um pinceltagon é um figura.
Um solid é um figura.
Um star é uma coisa.
Um cube é um figura.
Um yew tree é um figura.
Um tree é um figura.

O cor vermelha é uma cor.

O red pincel é um pincel.

Etapas necessárias para que se reduce um fração:
Obtenha um máximo divisor comum usando o numerador desta fração e o denominador desta fração.
Divida o numerador desta fração pelo máximo divisor comum.
Divida o denominador desta fração pelo máximo divisor comum.

An refer é uma coisa with um string e um endereço de memória (reference).

Etapas necessárias para que se atualize o cursor:
Crie um event.
Atribua "mostrar seta" à categoria deste event.
\Atribua "cursor" ao categoria deste event.
Se a tecla Alt estiver sendo pressionada, acione o alt alarme deste event.
Se a tecla Ctrl estiver sendo pressionada, acione o ctrl alarme deste event.
Se a tecla shift estiver sendo pressionada, acione o shift alarme deste event.
Atribua o spot deste mouse ao spot deste event.
Enque o event.

Etapas necessárias para que se atualize o tela usando um caixa:
Call "gdi32.dll" "BitBlt" with o tela canvas e o left desta caixa e o topo desta caixa e a width desta caixa e a altura desta caixa 
And o quadro atual e o left desta caixa e o topo desta caixa e 13369376 [srccopy].

O símbolo de marca registrada é um pedaço igual a 174.

O registered-trade-mark pedaço é um pedaço igual a 174.

Um resto é um número.

Etapas necessárias para que se relembre um text:
Se o text for inexistente, cancele.
Destroy os redos deste text.
Copy o text A uma segunda text.
Redimensione proporcionalmente o segunda text para 1/1.
Posponha o segunda text para os undos deste text.
Limite os undos deste text para o max text undos.
Ligue o alarme de alteração deste text.

Etapas necessárias para que se relembre um text with um operation:
Se o text for inexistente, cancele.
Se o last operation deste text for a operation, acione o alarme de alteração deste text; exit.
Relembre o text.
Atribua o operation à last operation deste text.

Etapas necessárias para que se relembre where we are:
Save o context.

O remembered pdf endereço completo é um endereço completo.

Etapas necessárias para que se remove any selecionado pedaços em um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Atribua a selection deste text A um selection.
Normalize o selection.
Obtenha um row usando o anchor número da linha desta selection e o text.
Lance um subtexto sobre o string deste row.
Atribua o first deste subtexto mais o anchor column# desta selection menos 2 ao last deste subtexto.
Obtenha uma segunda row usando o caret número da linha desta selection e o text.
Lance uma segunda subtexto sobre o string desta segunda row.
Atribua o first deste segunda subtexto mais o caret column# desta selection menos 1 ao first deste segunda subtexto.
Atribua o subtexto then o segunda subtexto ao string desta row.
Remove as rows of o text between o next desta row e a segunda row.
Atribua o anchor desta selection ao caret deste text.
Deselect o text.

Etapas necessárias para que se remove any trailing barra invertida from um string:
Se o string estiver em branco, cancele.
Se o target deste last deste string não for a barra invertida, cancele.
Remove o last pedaço from o string.

Etapas necessárias para que se remove any trailing linefeed pedaço from um string:
Se o string estiver em branco, cancele.
Se o target deste last deste string não for o linefeed pedaço, cancele.
Remove o last pedaço from o string.

Etapas necessárias para que se remove any trailing return pedaço from um string:
Se o string estiver em branco, cancele.
Se o target deste last deste string não for o return pedaço, cancele.
Remove o last pedaço from o string.

Etapas necessárias para que se remove pedaços from um string usando um subtexto:
Se o string estiver em branco, cancele.
Se o subtexto estiver em branco, cancele.
Atribua o last deste string menos o last deste subtexto A um length.
Atribua o last deste subtexto mais 1 A um endereço de memória.
Copy pedaços from o endereço de memória para o first deste subtexto pelo length.
Atribua o length deste string menos o length deste subtexto A um new length.
Reassign o first deste string usando o new length.
Atribua o first deste string mais o new length menos 1 ao last deste string.

Etapas necessárias para que se remove pedaços from um text (backspace over um return):
Se o text for inexistente, cancele.
Se o caret número da linha deste text for 1, cancele.
Obtenha um row usando o caret número da linha deste text menos 1 e o text.
Atribua o length deste string desta row e o caret número da linha deste text menos 1 ao caret deste text.
Remove any selecionado pedaços no text.

Etapas necessárias para que se remove pedaços from um text (backspace with jump):
Se o text for inexistente, cancele.
Se something estiver selecionado no text, remove any selecionado pedaços no text; exit.
Se o caret column# deste text for 1, remove pedaços from o text (backspace over um return); exit.
Jump o caret left no text.
Remove any selecionado pedaços no text.

Etapas necessárias para que se remove pedaços from um text (backspace):
Se o text for inexistente, cancele.
Se something estiver selecionado no text, remove any selecionado pedaços no text; exit.
Se o caret column# deste text for 1, remove pedaços from o text (backspace over um return); exit.
Mova o caret left no text.
Remove any selecionado pedaços no text.

Etapas necessárias para que se remove pedaços from um text (forward delete um return):
Se o text for inexistente, cancele.
Se o caret número da linha deste text é a row contagem deste text, cancele.
Atribua 1 e o caret número da linha deste text mais 1 ao caret deste text.
Remove any selecionado pedaços no text.

Etapas necessárias para que se remove pedaços from um text (forward delete with jump):
Se o text for inexistente, cancele.
Se something estiver selecionado no text, remove any selecionado pedaços no text; exit.
Obtenha um row usando o caret número da linha deste text e o text.
Se o caret column# deste text é o length deste string desta row, remove pedaços from o text (forward delete um return); exit.
Jump o caret right no text.
Remove any selecionado pedaços no text.

Etapas necessárias para que se remove pedaços from um text (forward delete):
Se o text for inexistente, cancele.
Se something estiver selecionado no text, remove any selecionado pedaços no text; exit.
Obtenha um row usando o caret número da linha deste text e o text.
Se o caret column# deste text é o length deste string desta row, remove pedaços from o text (forward delete um return); exit.
Mova o caret right no text.
Remove any selecionado pedaços no text.

Etapas necessárias para que se remove cada pedaço em um text:
Se o text for inexistente, cancele.
Atribua "" ao text.

Etapas necessárias para que se remove o first pedaço from um string:
Lance um subtexto sobre o first pedaço of o string.
Remove pedaços from o string usando o subtexto.

 
Etapas necessárias para que se remove o last pedaço from um string:
Lance um subtexto sobre o last pedaço of o string.
Remove pedaços from o string usando o subtexto.

Etapas necessárias para que se remove os last dois pedaços from um string:
Remove trailing pedaços from o string usando 2.

Etapas necessárias para que se remove leading pedaços from um string usando um contagem:
Isole a contagem.
Se o contagem for maior do que o length deste string, limpe o string; exit.
Lance um subtexto sobre o first pedaço of o string.
Atribua o first deste subtexto mais o contagem menos 1 ao last deste subtexto.
Remove pedaços from o string usando o subtexto.

Etapas necessárias para que se remove leading noise from um string;
Etapas necessárias para que se remove any leading noise from um string:
Se o string estiver em branco, cancele.
Se o target deste first deste string não for noise, cancele.
Remove o first pedaço from o string.
Repita.

Etapas necessárias para que se remove a rows of um text between um row e uma segunda row:
Se o text for inexistente, cancele.
Se a row for inexistente, cancele.
Se a segunda row for inexistente, cancele.
Se o número da linha desta row for maior do que o número da linha desta segunda row, cancele.
Isole a row.
Atribua o next desta segunda row A uma stop row.
Percorra.
Se a row for a stop row, pare.
Atribua o next desta row A um next row.
Remove a row from as rows deste text.
Destroy a row.
Atribua o next row à row.
Repita.
Renumber as rows deste text.

Etapas necessárias para que se remove uma coisa from alguns coisas:
Se a coisa for inexistente, cancele.
Se a coisa for o first destas coisas, atribua o next desta coisa ao first destas coisas.
Se a coisa for o last destas coisas, atribua o previous desta coisa ao last destas coisas.
Se o next desta coisa não for inexistente, atribua o previous desta coisa ao previous deste next desta coisa.
Se o previous desta coisa não for inexistente, atribua o next desta coisa ao next deste previous desta coisa.
Esvazie o next desta coisa.
Esvazie o previous desta coisa.

Etapas necessárias para que se remove trailing pedaços from um string usando um contagem:
Isole a contagem.
Se o contagem for maior do que o length deste string, limpe o string; exit.
Lance um subtexto sobre o last pedaço of o string.
Atribua o last deste subtexto menos o contagem mais 1 ao first deste subtexto.
Remove pedaços from o string usando o subtexto.

Etapas necessárias para que se remove trailing noise from um string;
Etapas necessárias para que se remove any trailing noise from um string:
Se o string estiver em branco, cancele.
Se o target deste last deste string não for noise, cancele.
Remove o last pedaço from o string.
Repita.

Etapas necessárias para que se rename um endereço completo para uma segunda endereço completo no sistema de arquivos:
Isole o endereço completo.
Remove any trailing barra invertida from o endereço completo.
Null terminate o endereço completo.
Isole o segunda endereço completo.
Remove any trailing barra invertida from o segunda endereço completo.
Null terminate o segunda endereço completo.
Call "kernel32.dll" "MoveFileA" with o first deste endereço completo e o first deste segunda endereço completo returning um número.
Limpe o i/o erro.
Se o número não for 0, cancele.
Atribua "Ocorreu um erro ao renomear o arquivo: " then o endereço completo then "." ao i/o erro.

Etapas necessárias para que se renumber alguns rows:
Obtenha um row from a rows.
Se a row for inexistente, cancele.
Adicione 1 para um número da linha.
Atribua o número da linha ao número da linha desta row.
Repita.

Etapas necessárias para que se replace um pedaço with uma segunda pedaço em um string:
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto não for o pedaço, adicione 1 para o first deste subtexto; repita.
Atribua o segunda pedaço ao target deste first deste subtexto.
Adicione 1 para o first deste subtexto.
Repita.

O reply é um reply.

Um reply é um string.

Etapas necessárias para que se reque um event:
Copy o event A uma segunda event.
Enque o segunda event.

Etapas necessárias para que se reset o alphabet:
Atribua o 'A' maiúsculo ao next letra.

Etapas necessárias para que se reset o caret of um text:
Se o text for inexistente, cancele.
Atribua 1 e 1 ao caret deste text.

Etapas necessárias para que se reset o context:
Restore o context.
Save o context.

Etapas necessárias para que se reset um contagem:
Atribua 0 à contagem.

Etapas necessárias para que se reset o drawing origin:
Defina o drawing origin para o zero spot.

Etapas necessárias para que se reset um alarme:
Desative o alarme.

Etapas necessárias para que se reset o origin of um text:
Se o text for inexistente, cancele.
Atribua a margin deste text à coordenada x deste text.
Atribua 0 à coordenada y deste text.

Etapas necessárias para que se reset um endereço de memória;
Etapas necessárias para que se reset um endereço de memória pelo next time around;
Etapas necessárias para que se esvazie um endereço de memória:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o endereço de memória
Intel $C70000000000. \ mov [eax],0

Etapas necessárias para que se reset o rainbow cors:
Atribua 0 ao número atual da cor do arco-íris.

Etapas necessárias para que se reset um cronômetro:
Atribua 0 à contagem deste cronômetro.
Atribua 0 a os start ticks deste cronômetro.
Atribua 0 a os total ticks deste cronômetro.

Etapas necessárias para que se redimensione um caixa usando um ratio pair;
Etapas necessárias para que se redimensione um caixa usando uma fração pair:
Atribua o x-extent desta caixa A um width.
Atribua o y-extent desta caixa A um altura.
Redimensione proporcionalmente o width usando a fração deste fração pair.
Redimensione proporcionalmente o altura usando a segunda fração deste fração pair.
Atribua o left desta caixa mais o width ao right desta caixa.
Atribua o topo desta caixa mais o altura à base desta caixa.

Etapas necessárias para que se redimensione um caixa usando um twip pair:
Adicione o número x deste twip pair para o right desta caixa.
Adicione o número y deste twip pair para a base desta caixa.

Etapas necessárias para que se redimensione um elipse usando um ratio pair;
Etapas necessárias para que se redimensione um elipse usando uma fração pair:
Redimensione a caixa desta elipse usando a fração pair.

Etapas necessárias para que se redimensione um elipse usando um twip pair:
Redimensione a caixa desta elipse usando o twip pair.

Etapas necessárias para que se redimensione um line usando um ratio pair;
Etapas necessárias para que se redimensione um line usando uma fração pair:
Atribua a caixa desta line A uma caixa.
Subtraia o left-top desta caixa from o start desta line.
Redimensione proporcionalmente o start desta line usando a fração pair.
Adicione o left-top desta caixa para o start desta line.
Subtraia o left-top desta caixa from o end desta line.
Redimensione proporcionalmente o end desta line usando a fração pair.
Adicione o left-top desta caixa para o end desta line.

Etapas necessárias para que se redimensione um line usando um twip pair:
Atribua a caixa desta line A uma caixa.
Atribua o caixa A uma segunda caixa.
Redimensione o segunda caixa usando o twip pair.
Make uma fração pair usando o segunda caixa e o caixa.
Redimensione o line usando a fração pair.

Etapas necessárias para que se redimensione um picture para um width por um altura:
Se o picture for inexistente, cancele.
Atribua o width dividido pelo tpp A um pixel width.
Atribua o altura dividido pelo tpp A um pixel altura.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" with o pixel width e o pixel altura e 0 e 137224 [pixelformat24bpprgb] e 0 e um gpbitmap's whereabouts.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" with o gpbitmap e um gpgraphic's whereabouts.
Call "gdiplus.dll" "GdipDrawImageRectRectI" with o gpgraphic e o gpbitmap desta picture.
And 0 e 0 e o pixel width e o pixel altura
And 0 e 0 e a width deste gpbitmap desta picture menos 1 e a altura deste gpbitmap desta picture menos 1
And 2 [unitpixel] e nil e nil e 0.
Call "gdiplus.dll" "GdipDeleteGraphics" with o gpgraphic.
Destroy o gpbitmap desta picture.
Atribua o gpbitmap ao gpbitmap desta picture.
Ajuste o picture (extract caixas from gpbitmap).
Limpe o data desta picture.

Etapas necessárias para que se redimensione um polygon usando um ratio pair;
Etapas necessárias para que se redimensione um polygon usando uma fração pair:
Se o polygon for inexistente, cancele.
Atribua a caixa deste polygon A uma caixa.
Percorra.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, cancele.
Subtraia o left-top desta caixa from o spot deste vértice.
Redimensione proporcionalmente o spot deste vértice usando a fração pair.
Adicione o left-top desta caixa para o spot deste vértice.
Repita.

Etapas necessárias para que se redimensione um polygon usando um twip pair:
Se o polygon for inexistente, cancele.
Atribua a caixa deste polygon A uma caixa.
Atribua o caixa A uma segunda caixa.
Redimensione o segunda caixa usando o twip pair.
Make uma fração pair usando o segunda caixa e o caixa.
Redimensione o polygon usando a fração pair.

Etapas necessárias para que se redimensione um text usando um ratio pair;
Etapas necessárias para que se redimensione um text usando uma fração pair:
Se o text for inexistente, cancele.
Redimensione a caixa deste text usando a fração pair.
Wrap o text.

Etapas necessárias para que se redimensione um text usando um twip pair:
Se o text for inexistente, cancele.
Redimensione a caixa deste text usando o twip pair.
Wrap o text.

Etapas necessárias para que se restart um cronômetro:
Adicione 1 para a contagem deste cronômetro.
Se a contagem deste cronômetro não for 1, cancele.
Atribua o system's tick contagem a os start ticks deste cronômetro. \ a tick contagem deste system

Etapas necessárias para que se restore um canvas:
Call "gdi32.dll" "RestoreDC" with o canvas e -1. \ need para use -1, windows documentoation é wrong

Etapas necessárias para que se restore um context:
Obtenha um saved context from o context stack.
Se o saved context for inexistente, cancele.
Atribua o spot deste saved context ao spot deste context.
Atribua o heading deste saved context ao heading deste context.
Atribua a tamanho da letra deste saved context à tamanho da letra deste context.
Atribua a cor deste saved context à cor deste context.
Atribua o número deste saved context ao número deste context.
Remove o saved context from o context stack.
Destroy o saved context.

Etapas necessárias para que se restore um window:
Call "user32.dll" "ShowWindow" with o window e 9 [sw_restore].

O return pedaço é um pedaço igual a 13.

Etapas necessárias para que se reverse any selecionado rows of um text:
Se o text for inexistente, cancele.
Split a rows of o text A alguns rows e alguns selecionado rows e alguns segunda rows.
Reverse o selecionado rows.
Posponha a rows para as rows deste text.
Posponha o selecionado rows para as rows deste text.
Posponha o segunda rows para as rows deste text.
Renumber as rows deste text.

Etapas necessárias para que se reverse um cor:
Se a cor é a cor preta, atribua o cor branca ao cor; exit.
Se a cor é o cor branca, atribua a cor preta ao cor; exit.
Atribua 1000 menos a luminosidade desta cor à luminosidade desta cor.
\Atribua 1000 menos a saturação desta cor à saturação desta cor.
Adicione 1800 para a matiz desta cor. Normalize a matiz desta cor.

Etapas necessárias para que se invert um alarme;
Etapas necessárias para que se reverse um alarme:
Se o alarme for 1, atribua 0 ao alarme; exit.
Atribua 1 ao alarme.

Etapas necessárias para que se reverse um número;
Etapas necessárias para que se invert um número:
Multiplique o número por -1.

Etapas necessárias para que se reverse um string:
\ could ser more efficient
Isole o string.
Limpe o original string.
Percorra.
Se o string estiver em branco, pare.
Obtenha um character from o string (backwards).
Posponha o character para o original string.
Repita.

Etapas necessárias para que se reverse alguns coisas:
Swap o coisas with alguns segunda coisas.
Percorra.
Atribua o last destas segunda coisas A uma coisa.
Se a coisa for inexistente, cancele.
Mova a coisa from o segunda coisas para as coisas.
Repita.

Um rgb é um conjunto with
Um pedaço called espectro azul,
Um pedaço called espectro verde,
Um pedaço called espectro vermelho.

Um rgb endereço de memória é um endereço de memória para um rgb.

Um percorredor has \ fix "bump um percorredor" e "unbump um percorredor" if you mude me
Um subtexto original,
Um source subtexto, 
Um token subtexto.

O right-alligator pedaço é um pedaço igual a 62.

O right-alligator-quote pedaço é um pedaço igual a 155.

O right-arrow tecla é uma tecla igual a 39.

O right-brace pedaço é um pedaço igual a 125.

O right-bracket pedaço é um pedaço igual a 93.

O right-double-alligator-quote pedaço é um pedaço igual a 187.

O right-double-quote pedaço é um pedaço igual a 148.

O right-paren pedaço é um pedaço igual a 41.

O right-single-quote pedaço é um pedaço igual a 146.

O right-window tecla é uma tecla igual a 92.

Um rise é um número.
Um run é um número.

Etapas necessárias para que se rotate um caixa:
Atribua o center desta caixa A um center spot.
Atribua o caixa A uma segunda caixa.
Atribua a coordenada y deste center menos o topo desta segunda caixa mais a coordenada x deste center ao right desta caixa.
Atribua o left desta segunda caixa menos a coordenada x deste center mais a coordenada y deste center ao topo desta caixa.
Atribua a coordenada y deste center menos a base desta segunda caixa mais a coordenada x deste center ao left desta caixa.
Atribua o right desta segunda caixa menos a coordenada x deste center mais a coordenada y deste center à base desta caixa.

Etapas necessárias para que se rotate um elipse:
Rotate a caixa desta elipse.

Etapas necessárias para que se rotate um gpimage:
Se o gpimage for inexistente, cancele.
Call "gdiplus.dll" "GdipImageRotateFlip" with o gpimage e 1 [rotate90flipnone].

Etapas necessárias para que se rotate um gpimage usando um ângulo:
\ ângulo pode ser 0, 900, 1800, 2700
Se o gpimage for inexistente, cancele.
Atribua 0 [rotatenoneflipnone] A um número.
Se o ângulo for 900, atribua 1 [rotate90flipnone] ao número.
Se o ângulo for 1800, atribua 2 [rotate180flipnone ] ao número.
Se o ângulo for 2700, atribua 3 [rotate270flipnone ] ao número.
Call "gdiplus.dll" "GdipImageRotateFlip" with o gpimage e o número.

Etapas necessárias para que se rotate um line:
Atribua o center desta line A um center spot.
Rotate o start desta line around o center.
Rotate o end desta line around o center.

Etapas necessárias para que se rotate um picture:
Se o picture for inexistente, cancele.
Adicione 900 para o ângulo de rotação desta picture.
Se o mirror alarme desta picture estiver ativo, adicione 1800 para o ângulo de rotação desta picture.
Normalize o ângulo de rotação desta picture.
Rotate a caixa desta picture.
Rotate a uncropped caixa desta picture.
Atribua o center desta caixa desta picture A um center spot.
Atribua o center desta uncropped caixa desta picture A uma segunda center spot.
Atribua a coordenada y deste center menos a coordenada y deste segunda center mais a coordenada x deste center A um twip pair's número x.
Subtraia a coordenada x deste segunda center from o número x deste twip pair.
Atribua a coordenada y deste center mais a coordenada x deste segunda center menos a coordenada x deste center ao número y deste twip pair.
Subtraia a coordenada y deste segunda center from o número y deste twip pair.
Mova a uncropped caixa desta picture usando o twip pair.
Rotate o gpbitmap desta picture.

Etapas necessárias para que se rotate um polygon:
Se o polygon for inexistente, cancele.
Atribua o center deste polygon A um center spot.
Percorra.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, cancele.
Rotate o spot deste vértice around o center.
Repita.

Etapas necessárias para que se rotate um spot around um center spot:
Atribua o spot A uma segunda spot.
Atribua a coordenada y deste center menos a coordenada y deste segunda spot mais a coordenada x deste center à coordenada x deste spot.
Atribua a coordenada x deste segunda spot menos a coordenada x deste center mais a coordenada y deste center à coordenada y deste spot.

Etapas necessárias para que se rotate um text:
Se o text for inexistente, cancele.
Rotate a caixa deste text.
Wrap o text.

Etapas necessárias para que se round um número para uma segunda número:
Round o número para o nearest multiple of o segunda número.

Etapas necessárias para que se round um número down para o nearest multiple of uma segunda número:
Divida o número pelo segunda número.
Multiplique o número pelo segunda número.

Etapas necessárias para que se round um número para o nearest multiple of uma segunda número:
Se o segunda número for 0, cancele.
Isole o segunda número.
Divida o número pelo segunda número giving um quotient e um resto.
Divida o segunda número por 2.
Se o resto for maior do que ou igual ao segunda número, round o número up para o nearest multiple of o original segunda número; exit.
Round o número down para o nearest multiple of o original segunda número.

Etapas necessárias para que se round um número up para o nearest multiple of uma segunda número:
Divida o número pelo segunda número giving um quotient e um resto.
Se o resto for 0, cancele.
Adicione o segunda número menos o resto para o número.

Etapas necessárias para que se round um número up para o nearest power of two:
Intel $8B8D08000000. \ mov ecx,[ebp+8] \ o número
Intel $8B09. \ mov ecx,[ecx]
Intel $49. \ dec ecx
Intel $0FBDC9. \ bsr ecx,ecx
Intel $41. \ inc ecx
Intel $81F904000000. \ cmp ecx,4
Intel $0F8F05000000. \ jg over o next 1 statement
Intel $B904000000. \ mov ecx,4
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $C70001000000. \ mov [eax],1
Intel $D320. \ shl [eax],ecx 

Etapas necessárias para que se round um pair para uma segunda pair:
Round o pair para o nearest multiple of o segunda pair.

Etapas necessárias para que se round um pair para o nearest multiple of uma segunda pair:
Round o número x deste pair para o nearest multiple of o número x deste segunda pair.
Round o número y deste pair para o nearest multiple of o número y deste segunda pair.

Etapas necessárias para que se round um pair para o nearest multiple of um número:
Round o número x deste pair para o nearest multiple of o número.
Round o número y deste pair para o nearest multiple of o número.

Etapas necessárias para que se round um pair para um número:
Round o pair para o nearest multiple of o número.

Um caixa arredondada é um caixa with
Um left coord, um topo coord, um right coord, um base coord,
Um left-top spot at o left, um right-base spot at o right, e 
Um radius.

An row é uma coisa with um número da linha e um string.

Um número da linha é um número.

O tecla S/s é uma tecla igual a 83.

Um saturação é um número [0 para 1000].

Etapas necessárias para que se save um canvas:
Call "gdi32.dll" "SaveDC" with o canvas.

Etapas necessárias para que se save um context:
Allocate memory por um saved context.
Atribua o spot deste context ao spot deste saved context.
Atribua o heading deste context ao heading deste saved context.
Atribua a tamanho da letra deste context à tamanho da letra deste saved context.
Atribua a cor deste context à cor deste saved context.
Atribua o número deste context ao número deste saved context.
Anteponha o saved context para o context stack.

O saved memory hbitmap é um hbitmap.

O saved tpp é um número.

Etapas necessárias para que se say um número:
Atribua o número A um string.
Say o string.

Etapas necessárias para que se say um string;
Etapas necessárias para que se speak um string:
Se o silent alarme estiver ativo, cancele.
\Se la bandera silenciosa estiver ativo, cancele.
Se o talker for inexistente, cancele.
Se o string estiver em branco, cancele.
Convert o string para um wide string.
Null terminate o wide string.
Call o speak desta vtable deste talker with o talker e o first deste wide string e 17 [svsfdefault+svsflagsasyn+svsfisnotxml] e 0.

Etapas necessárias para que se say um string e wait;
Etapas necessárias para que se speak um string e wait:
Se o silent alarme estiver ativo, cancele.
Se la bandera silenciosa estiver ativo, cancele.
Se o talker for inexistente, cancele.
Se o string estiver em branco, cancele.
Convert o string para um wide string.
Null terminate o wide string.
Call o speak desta vtable deste talker with o talker e o first deste wide string e 16 [svsfdefault+svsfisnotxml] e 0.

Etapas necessárias para que se redimensione proporcionalmente um caixa usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um caixa usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente o left desta caixa usando a fração.
Redimensione proporcionalmente o topo desta caixa usando a fração.
Redimensione proporcionalmente o right desta caixa usando a fração.
Redimensione proporcionalmente a base desta caixa usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um caixa para um percent:
Atribua o percent / 100 A um fração.
Redimensione proporcionalmente o caixa usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um elipse usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um elipse usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a caixa desta elipse usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um elipse para um percent:
Atribua o percent / 100 A um fração.
Redimensione proporcionalmente o elipse usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma font usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente uma font usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a altura desta font usando a fração.

Etapas necessárias para que se redimensione proporcionalmente uma fração usando uma segunda fração;
Etapas necessárias para que se multiplique uma fração por uma segunda fração:
Multiplique o numerador desta fração pelo numerador desta segunda fração.
Multiplique o denominador desta fração pelo denominador desta segunda fração.
Reduce a fração.

Etapas necessárias para que se redimensione proporcionalmente um line usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um line usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente o start desta line usando a fração.
Redimensione proporcionalmente o end desta line usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um line para um percent:
Atribua o percent / 100 A um fração.
Redimensione proporcionalmente o line usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um pair usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um pair usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente o número x deste pair usando a fração.
Redimensione proporcionalmente o número y deste pair usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um pair usando um ratio pair;
Etapas necessárias para que se redimensione proporcionalmente um pair usando uma fração pair:
Redimensione proporcionalmente o número x deste pair usando a fração deste fração pair.
Redimensione proporcionalmente o número y deste pair usando a segunda fração deste fração pair.

Etapas necessárias para que se redimensione proporcionalmente um pair para um percent:
Atribua o percent / 100 A um fração.
Redimensione proporcionalmente o pair usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um picture usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um picture usando um fração:
Se o picture for inexistente, cancele.
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a caixa desta picture usando a fração.
Redimensione proporcionalmente a uncropped caixa desta picture usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um picture para um percent:
Se o picture for inexistente, cancele.
Atribua o percent / 100 A um fração.
Redimensione proporcionalmente o picture usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um polygon usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um polygon usando um fração:
Se o polygon for inexistente, cancele.
Se a fração for 1/1, cancele.
Percorra.
Obtenha um vértice from os vértices deste polygon.
Se o vértice for inexistente, cancele.
Redimensione proporcionalmente o vértice usando a fração.
Repita.

Etapas necessárias para que se redimensione proporcionalmente um polygon para um percent:
Se o polygon for inexistente, cancele.
Atribua o percent / 100 A um fração.
Redimensione proporcionalmente o polygon usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um caixa arredondada usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um caixa arredondada usando um fração:
Se a fração for 1/1, cancele.
Redimensione proporcionalmente o caixa arredondada como um caixa usando a fração.
Redimensione proporcionalmente o radius desta caixa arredondada usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um caixa arredondada para um percent:
Atribua o percent / 100 A um fração.
Redimensione proporcionalmente o caixa arredondada usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um text para um fração:
\ absolute
Se o text for inexistente, cancele.
Atribua a scale deste text A uma segunda fração.
Flip a segunda fração.
Multiplique o segunda fração pela fração.
Redimensione proporcionalmente o text usando a segunda fração.

Etapas necessárias para que se redimensione proporcionalmente um text usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um text usando um fração:
Se o text for inexistente, cancele.
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a caixa deste text usando a fração.
Redimensione proporcionalmente a origin deste text usando a fração.
Redimensione proporcionalmente a font deste text usando a fração.
Redimensione proporcionalmente a scale deste text usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um text para um percent:
Se o text for inexistente, cancele.
Atribua o percent / 100 A um fração.
Redimensione proporcionalmente o text usando a fração.

Etapas necessárias para que se redimensione proporcionalmente um vértice usando um ratio;
Etapas necessárias para que se redimensione proporcionalmente um vértice usando um fração:
Se o vértice for inexistente, cancele.
Se a fração for 1/1, cancele.
Redimensione proporcionalmente a coordenada x deste vértice usando a fração.
Redimensione proporcionalmente a coordenada y deste vértice usando a fração.

O tela canvas é um canvas.
\O tela canvas é um canvas.

O tela has um caixa, um pixel altura e um pixel width.
\O screen has um caixa, um pixel altura e um pixel width.

Etapas necessárias para que se role um console usando um event:
Se o console for inexistente, cancele.
Encontre um sector usando o grid deste console e o spot deste event.
Percorra.
Se o botão direito deste mouse não estiver sendo pressionado, cancele.
Encontre uma segunda sector usando o grid deste console e o spot deste mouse.
Obtenha um difference between o segunda sector e o sector.
Se a difference for 0, repita.
Role o text deste console usando a difference.
Mostre o console.
Adicione a difference para o sector.
Repita.

Etapas necessárias para que se role um text para o base:
Se o text for inexistente, cancele.
Se o vertical scroll alarme deste text não estiver ativo, cancele.
Atribua a row contagem deste text menos 1 A um número.
Atribua - o número times a row altura deste text à coordenada y deste text.
Limite o origin of o text.

Etapas necessárias para que se role um text para o caret:
Se o text for inexistente, cancele.
Se o column# deste caret deste text for 1, atribua a margin deste text à coordenada x deste text.
Obtenha um caixa pelo caret no text.
Ajuste a caixa usando 0 e - o tpp e 0 e o tpp. \ caret caixas do not fill entire row
Se o topo desta caixa for menor do que o topo deste text, atribua o topo deste text menos o topo desta caixa A um difference's número y.
Se a base desta caixa for maior do que a base deste text, atribua a base deste text menos a base desta caixa ao número y desta difference.
Se o left desta caixa for menor do que o left deste text , atribua o left deste text menos o left desta caixa ao número x desta difference.
Se o right desta caixa for maior do que o right deste text, atribua o right deste text menos o right desta caixa ao número x desta difference.
Se a difference for 0, cancele.
Role o text usando a difference.

Etapas necessárias para que se role um text para o caret e center it:
Se o text for inexistente, cancele.
Atribua a margin deste text à coordenada x deste text.
Obtenha um caixa pelo caret no text.
Se o caixa é inside a caixa deste text, cancele.
Ajuste o caixa usando 0 e - o tpp e 0 e o tpp. \ caret caixas don not fill entire row
Atribua o y-extent desta caixa deste text dividido por 2 A um altura.
Round o altura down para o nearest multiple of a row altura deste text.
Atribua o topo desta caixa deste text mais o altura A um topo coord.
Atribua o topo mais a row altura deste text A um base coord.
Se o topo desta caixa for menor do que o topo, atribua o topo menos o topo desta caixa A um difference's número y.
Se a base desta caixa for maior do que o base, atribua o base menos a base desta caixa ao número y desta difference.
Se o left desta caixa for menor do que o left deste text , atribua o left deste text menos o left desta caixa ao número x desta difference.
Se o right desta caixa for maior do que o right deste text, atribua o right deste text menos o right desta caixa ao número x desta difference.
Se a difference for 0, cancele.
Role o text usando a difference.

Etapas necessárias para que se role um text down one line:
Se o text for inexistente, cancele.
Se o vertical scroll alarme deste text não estiver ativo, cancele.
Atribua - a row altura deste text A um difference's número y.
Role o text usando a difference.

Etapas necessárias para que se role um text down one página:
Se o text for inexistente, cancele.
Se o vertical scroll alarme deste text não estiver ativo, cancele.
Subtraia o y-extent desta caixa deste text from a coordenada y deste text.
Adicione a row altura deste text para a coordenada y deste text.
Limite o origin of o text.

Etapas necessárias para que se role um text usando um difference:
Se o text for inexistente, cancele.
Isole a difference.
Se o horizontal scroll alarme deste text não estiver ativo, atribua 0 ao número x desta difference.
Se o vertical scroll alarme deste text não estiver ativo, atribua 0 ao número y desta difference.
Se a difference for 0, cancele.
Mova a origin deste text usando a difference.
Limite o origin of o text.

Etapas necessárias para que se role um text para o topo:
Se o text for inexistente, cancele.
Se o vertical scroll alarme deste text não estiver ativo, cancele.
Atribua 0 à coordenada y deste text.
Limite o origin of o text.

Etapas necessárias para que se role um text up one line:
Se o text for inexistente, cancele.
Se o vertical scroll alarme deste text não estiver ativo, cancele.
Atribua a row altura deste text A um difference's número y.
Role o text usando a difference.

Etapas necessárias para que se role um text up one página:
Se o text for inexistente, cancele.
Se o vertical scroll alarme deste text não estiver ativo, cancele.
Adicione o y-extent desta caixa deste text para a coordenada y deste text.
Subtraia a row altura deste text from a coordenada y deste text.
Limite o origin of o text.

O scrolllock tecla é uma tecla igual a 145.

\Um segundo for 1000 milisegundos.

An second é 1000 milliseconds.

O sector pedaço é um pedaço igual a 167.

Um sector é um pair with um coordenada x e um coordenada y [indicating o left-top of o sector].

O seed é um número.

Etapas necessárias para que se selecione cada pedaço em um text:
Se o text for inexistente, cancele.
Atribua 1 e 1 ao anchor deste text.
Atribua o length deste string deste last destas rows deste text e a row contagem deste text ao caret deste text.

Etapas necessárias para que se selecione um número da linha usando um text:
Se o text for inexistente, cancele.
Obtenha um row usando o número da linha e o text.
Se a row for inexistente, cancele.
Atribua o número da linha ao anchor número da linha deste text .
Atribua 1 ao anchor column# deste text.
Atribua o número da linha ao caret número da linha deste text.
Atribua o length deste string desta row ao caret column# deste text.

Um selection caixa é uma caixa.

Um selection has 
Um anchor column#, um anchor número da linha, um anchor at o anchor column#,
Um caret column#, um caret número da linha, um caret at o caret column#.

O ponto&vírgula é um pedaço igual a 59.

Etapas necessárias para que se send um trecho para um socket:
Limpe o i/o erro.
Atribua o first deste trecho A um endereço de memória.
Atribua o length deste trecho A um length.
Percorra.
Se o length for 0, pare.
Call "ws2_32.dll" "send" with o socket e o endereço de memória e o length e 0 returning um número.
Se o número é -1 [socket_error], atribua "Ocorreu um erro na hora de enviar dados." ao i/o erro; exit.
Subtraia o número from o length.
Adicione o número para o endereço de memória.
Repita.

Etapas necessárias para que se send um data string para um winhttp request:
Se o winhttp request for inexistente, cancele.
Call "winhttp.dll" "WinHttpSendRequest" With a request deste winhttp request 
And 0 [winhttp_no_additional_headers] And 0 And o first destes data And o length destes data And o length destes data And 0 Returning um result número.
Se o result for 0, atribua "Erro. Não foi possível enviar a solicitação." ao i/o erro; exit.

Etapas necessárias para que se send um email:
Limpe o i/o erro.
\ crie socket
Crie um socket usando o smtp server deste email e 25.
Se o i/o erro não estiver em branco, cancele.
\ initial receive here por date/time stuff from server
Receive um response string from o socket.
Se o i/o erro não estiver em branco, destroy o socket; exit.
Se o response starts with "5", atribua o response ao i/o erro; trim o i/o erro; destroy o socket; exit.
\ send HELO
Send "HELO " then o name deste module then o texto CRLF para o socket e receive o response string.
Se o i/o erro não estiver em branco, destroy o socket; exit.
Se o response starts with "5", atribua o response ao i/o erro; trim o i/o erro; destroy o socket; exit.
\ send MAIL FROM: <xxx>
Send "MAIL FROM: <" then o sender deste email then ">" then o texto CRLF para o socket e receive o response string.
Se o i/o erro não estiver em branco, destroy o socket; exit.
Se o response starts with "5", atribua o response ao i/o erro; trim o i/o erro; destroy o socket; exit.
\ send RCPT TO: <xxx>
Send "RCPT TO: <" then o recipient deste email then ">" then o texto CRLF para o socket e receive o response string.
Se o i/o erro não estiver em branco, destroy o socket; exit.
Se o response starts with "5", atribua o response ao i/o erro; trim o i/o erro; destroy o socket; exit.
\ send DATA
Send "DATA" then o texto CRLF para o socket e receive o response string.
Se o i/o erro não estiver em branco, destroy o socket; exit.
Se o response starts with "5", atribua o response ao i/o erro; trim o i/o erro; destroy o socket; exit.
\ send From: xxx crlf Etapas necessárias para que se: xxx crlf Subject: xxx crlf Reply-Etapas necessárias para que se: xxx crlf message crlf . crlf
Limpe um temp string.
Posponha "From: " then o sender deste email then o texto CRLF para o temp string.
Posponha "Etapas necessárias para que se: " then o recipient deste email then o texto CRLF para o temp string.
Posponha "Subject: " then o subject deste email then o texto CRLF ao temp string.
Posponha "Reply-Etapas necessárias para que se: " then o sender deste email then o texto CRLF ao temp string.
Posponha o texto CRLF para o temp string.
Posponha a message deste email para o temp string (handling email transparency).
Posponha o texto CRLF then "." then o texto CRLF para o temp string.
Send o temp string para o socket e receive o response string.
Se o i/o erro não estiver em branco, destroy o socket; exit.
Se o response starts with "5", atribua o response ao i/o erro; trim o i/o erro; destroy o socket; exit.
\ send QUIT
Send "QUIT" then o texto CRLF para o socket.
\ destroy socket
Destroy o socket.

Etapas necessárias para que se send um message from um sender para um recipient:
Send o message para o recipient from o sender.

Etapas necessárias para que se send um message from um sender para um recipient via um smtp server:
Send o message para o recipient from o sender via o smtp server.

Etapas necessárias para que se send um message from um sender para um recipient with um subject:
Send o message para o recipient from o sender with o subject.

Etapas necessárias para que se send um message from um sender para um recipient with um subject via um smtp server:
Send o message para o recipient from o sender with o subject via o smtp server.

Etapas necessárias para que se send um message para um recipient from um sender:
Atribua o default smtp server A um email's smtp server.
Atribua o recipient ao recipient deste email.
Atribua o sender ao sender deste email.
Atribua o message à message deste email.
Send o email.

Etapas necessárias para que se send um message para um recipient from um sender via um smtp server:
Atribua o smtp server A um email's smtp server.
Atribua o recipient ao recipient deste email.
Atribua o sender ao sender deste email.
Atribua o message à message deste email.
Send o email.

Etapas necessárias para que se send um message para um recipient from um sender with um subject:
Atribua o default smtp server A um email's smtp server.
Atribua o recipient ao recipient deste email.
Atribua o sender ao sender deste email.
Atribua o subject ao subject deste email.
Atribua o message à message deste email.
Send o email.

Etapas necessárias para que se send um message para um recipient from um sender with um subject via um smtp server:
Atribua o smtp server A um email's smtp server.
Atribua o recipient ao recipient deste email.
Atribua o sender ao sender deste email.
Atribua o subject ao subject deste email.
Atribua o message à message deste email.
Send o email.

Etapas necessárias para que se send um string para um socket e receive um response string:
Limpe o response string.
Send o string para o socket.
Se o i/o erro não estiver em branco, cancele.
Receive o response string from o socket.

Um sender é um string.

Etapas necessárias para que se defina o código da cor of um canvas usando um cor:
Convert a cor para um código da cor.
Call "gdi32.dll" "SetTextColor" with o canvas e o código da cor.

Etapas necessárias para que se defina o drawing origin para um spot:
Call "gdi32.dll" "GetDeviceCaps" with o quadro atual e 112 [physicaloffsetx] returning um pair's número x.
Call "gdi32.dll" "GetDeviceCaps" with o quadro atual e 113 [physicaloffsety] returning o número y deste pair.
Negate o pair.
Se o quadro atual não for o printer canvas, limpe o pair.
Call "gdi32.dll" "SetViewportOrgEx" with o quadro atual e o número x deste pair e o número y deste pair e nil.
Isole o spot.
Call "gdi32.dll" "LPtoDP" with o quadro atual e o whereabouts deste spot e 1.
Call "gdi32.dll" "SetViewportOrgEx" with o quadro atual e a coordenada x deste spot e a coordenada y deste spot e nil.

Etapas necessárias para que se acione um alarme;
Etapas necessárias para que se ative um alarme;
Etapas necessárias para que se dispare um alarme;
Etapas necessárias para que se soe um alarme;
Etapas necessárias para que se toque um alarme;
Etapas necessárias para que se ligue um alarme:
Atribua 1 ao alarme. \ was "Atribua yes ao alarme." Value of yes inherited from o CAL-1000 according para Dan.

Etapas necessárias para que se defina um endereço completo para read-write mode:
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "GetFileAttributesA" with o first deste endereço completo returning um número.
Conjuncione logicamente o número with -2 [everything except file_attribute_readonly].
Call "kernel32.dll" "SetFileAttributesA" with o first deste endereço completo e o número.

O número sete é um pedaço igual a 55.

O tecla sete é uma tecla igual a 55.

O sharp-s pedaço é um pedaço igual a 223. \Aspa dubla à esquerda?

Um sheet é uma caixa.

Etapas necessárias para que se shift um pedaço left alguns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $D220. \ shl endereço de memória do pedaço [eax],ecx

Etapas necessárias para que se shift um pedaço right alguns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $D228. \ shr endereço de memória do pedaço [eax],ecx

O tecla shift é uma tecla igual a 16.

Etapas necessárias para que se shift um número left alguns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $D320. \ shl [eax],ecx

Etapas necessárias para que se shift um número right alguns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $D328. \ shr [eax],ecx

Etapas necessárias para que se shift um wyrd left alguns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $66D320. \ shl palavra ptr [eax],ecx

Etapas necessárias para que se shift um wyrd right alguns bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ o bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ o wyrd
Intel $66D328. \ shr palavra ptr [eax],ecx

O shift-in pedaço é um pedaço igual a 15.

O shift-out pedaço é um pedaço igual a 14.

Etapas necessárias para que se mostre um console:
Se o console for inexistente, cancele.
Save o quadro atual.
Draw o console.
Atualize o tela usando a caixa deste console.
Restore o quadro atual.

Etapas necessárias para que se mostre um cursor:
Call "user32.dll" "SetCursor" with o cursor.
Call "user32.dll" "ShowCursor" with 1 returning um número.
Se o número for maior do que 0, cancele.
Repita.

Etapas necessárias para que se mostre um terminal:
Se o terminal for inexistente, cancele.
Save o quadro atual.
Draw o terminal.
Atualize o tela usando a caixa deste terminal.
Restore o quadro atual.

Etapas necessárias para que se shrink um caixa por alguns twips;
Etapas necessárias para que se indent um caixa alguns twips;
Etapas necessárias para que se indent um caixa por alguns twips;
Etapas necessárias para que se indent um caixa alguns twips sobre cada side;
Etapas necessárias para que se indent um caixa usando alguns twips:
Adicione o twips para o left desta caixa.
Adicione o twips para o topo desta caixa.
Subtraia o twips from o right desta caixa.
Subtraia o twips from a base desta caixa.

Etapas necessárias para que se feche o programa;
Etapas necessárias para que se feche o nosso programa;
Etapas necessárias para que se feche nosso programa;
Etapas necessárias para que se feche tudo;
Etapas necessárias para que se shut down:
Destroy o Bíblia.
Destroy o stack.
Destroy o lexicon.
Destroy o console.
\Destroy o consola.
Destroy o terminal.
Finalize o context.
Finalize o canvases.
Finalize o mouse.
Finalize o cursors.
Finalize o fonts.
Finalize o window.
Finalize o tela.
Finalize o cors.
Finalize o module.
Finalize o talker.
Finalize gdi+.
Finalize winsock.
Finalize with.

Etapas necessárias para que se shut down o cgi:
Finalize o cgi.
Finalize o module.
Finalize winsock.

Um side é 1 unit.

O silent alarme é um alarme.

Etapas necessárias para que se simplify um reply:
Se o reply estiver em branco, pare.
Obtenha um pedaço from o reply.
Se o pedaço é any punctuation mark, repita.
Posponha o pedaço para um string.
Repita.
Atribua o string ao reply.

O single-quote pedaço é um pedaço igual a 39.

O número seis é um pedaço igual a 54.

O tecla seis é uma tecla igual a 54.

Um size é alguns twips.

Etapas necessárias para que se skip any leading linefeed pedaço em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto não for o linefeed pedaço, cancele.
Adicione 1 para o first deste subtexto.

Etapas necessárias para que se skip any leading noise em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto não for noise, cancele.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se skip any non-alphanumeric pedaços em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for alphanumeric, cancele.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se skip um line sobre o terminal:
Escreva "" sobre o terminal.

Etapas necessárias para que se skip palavra characters em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o subtexto está sobre any contraction, adicione 1 para o first deste subtexto; repita.
Se o target deste first deste subtexto não for alphanumeric, cancele.
Adicione 1 para o first deste subtexto.
Repita.

O sky blue cor é uma cor.

O sky blue pincel é um pincel.

O sky cor é uma cor.

O sky pincel é um pincel.

Etapas necessárias para que se lance um percorredor sobre uma segunda percorredor:
Lance o source deste percorredor sobre o source deste segunda percorredor.
Position o token deste percorredor sobre o source deste percorredor.

Etapas necessárias para que se lance um percorredor sobre um string:
Lance o original deste percorredor sobre o string.
Lance o source deste percorredor sobre o string.
Position o token deste percorredor sobre o source deste percorredor.

Etapas necessárias para que se lance um subtexto sobre any selecionado pedaços em um row of um text:
Limpe o subtexto.
Se o text for inexistente, cancele.
Se a row of o text não estiver selecionado, cancele.
Lance o subtexto sobre o string deste row.
Atribua a normalized selection deste text A um selection.
Se o número da linha desta row é o caret número da linha desta selection, atribua o first deste subtexto mais o caret column# desta selection menos 2 ao last deste subtexto.
Se o número da linha desta row é o anchor número da linha desta selection, atribua o first deste subtexto mais o anchor column# desta selection menos 1 ao first deste subtexto.

Etapas necessárias para que se lance um subtexto sobre o first pedaço of um string:
Lance o subtexto sobre o string.
Se o string estiver em branco, cancele.
Atribua o first deste string ao last deste subtexto.

Etapas necessárias para que se lance um subtexto sobre o last pedaço of um string:
Lance o subtexto sobre o string.
Se o string estiver em branco, cancele.
Atribua o last deste string ao first deste subtexto.

Etapas necessárias para que se lance um subtexto sobre um string:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o subtexto
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o string
\ atribua o first deste string ao first do subtexto
Intel $8B8B00000000. \ mov ecx,[ebx+0] \ o string's first
Intel $898800000000. \ mov [eax+0],ecx \ o first do subtexto
\ atribua o last deste string ao last deste subtexto
Intel $8B8B04000000. \ mov ecx,[ebx+4] \ o last do string
Intel $898804000000. \ mov [eax+4],ecx \ o last deste subtexto

O slash pedaço é um pedaço igual a 47.

O small tamanho da letra é um tamanho da letra.

O ponto mediano é um pedaço igual a 183.

O menor número é -2147483648.

Etapas necessárias para que se smooth um polygon:
Se o polygon for inexistente, cancele.
Se a contagem destes vértices deste polygon for menor do que 3, cancele.
Se o polygon estiver closed, posponha o spot deste next deste first vértice deste polygon para o polygon; ative um alarme.
Atribua o first vértice deste polygon A um left vértice.
Percorra.
Se o next deste left vértice for inexistente, pare.
Atribua o next deste left vértice A um right vértice.
Obtenha um center spot usando o spot deste left vértice e o right vértice's spot.
Insira o center ao polygon after o left vértice.
Atribua o next deste left vértice A um new vértice.
Se o previous deste left vértice for inexistente, atribua o right vértice ao left vértice; repita.
Obtenha uma segunda center spot usando o spot deste previous deste left vértice e o spot deste new vértice.
Obtenha um difference between o segunda center e o spot deste left vértice.
Divida a difference por 2.
Adicione a difference para o spot deste left vértice.
Atribua o right vértice ao left vértice.
Repita.
Se o alarme não estiver ativo, cancele.
Destroy o first vértice deste polygon usando o polygon.
Destroy o last vértice deste polygon usando o polygon.

Etapas necessárias para que se smooth um polygon alguns times; 
Etapas necessárias para que se smooth um polygon alguns vezes:
\ this use para "times" é um fluke, I think -- see "some times é um número"
Isole o times.
Percorra.
Se o times for 0, cancele.
Smooth o polygon.
Subtraia 1 from o times.
Repita.

Some vezes é um número.

Um smtp server é um string.

Um sockaddr é um conjunto with
Um wyrd called sin_family,
Um big-endian unsigned wyrd called sin_port,
Um in_addr called sin_addr,
8 pedaços called sin_zero.

Um sockaddrptr é um endereço de memória para um sockaddr.

Um socket é um endereço de memória.

O soft-hífem é um pedaço igual a 173.

Um solid cor é uma cor.

Etapas necessárias para que se classifique any selecionado rows em um text:
Se o text for inexistente, cancele.
Split a rows of o text A alguns rows e alguns selecionado rows e alguns segunda rows.
Classifique o selecionado rows.
Posponha a rows para as rows deste text.
Posponha o selecionado rows para as rows deste text.
Posponha o segunda rows para as rows deste text.
Renumber as rows deste text.

Etapas necessárias para que se classifique alguns rows:
Se o first destas rows for o last destas rows, cancele.
Split a rows A alguns left rows e algumas right rows.
Classifique as left rows.
Classifique as right rows.
Percorra.
Atribua o first destas left rows A uma left row.
Atribua o first destas right rows A uma right row.
Se a left row for inexistente, posponha as right rows para as rows; exit.
Se a right row for inexistente, posponha as left rows para as rows; exit.
Se o string desta left row for maior do que o string desta right row, mova a right row from as right rows para as rows; repita.
Mova a left row from as left rows para as rows.
Repita.

Etapas necessárias para que se space between glyphs:
Vire right. Mova 3 squares. Vire left.

O caractere de espaço é um pedaço igual a 32.

O space tecla é uma tecla igual a 32.

O space string é um string igual a " ".

Etapas necessárias para que se split um trecho Into alguns dyads:
Destroy o dyads.
Se o trecho estiver em branco, cancele.
Lance um percorredor sobre o trecho.
Percorra.
Mova o percorredor usando o & comercial.
Se o token deste percorredor estiver em branco, cancele.
Crie um dyad.
Posponha o dyad para o dyads.
Split o token deste percorredor A um name subtexto e um query subtexto usando o sinal de igualdade.
Atribua o name subtexto ao name deste dyad.
Convert o query subtexto como um query string ao value deste dyad.
Repita.

Etapas necessárias para que se split um pedaço Into uma cifra binária e uma segunda cifra binária:
Atribua o pedaço à cifra binária.
Shift a cifra binária right 4 bits.
Atribua o pedaço ao segunda cifra binária.
Conjuncione logicamente o segunda cifra binária with 15.

Etapas necessárias para que se split um line Into uma segunda line e um terceiro line:
Isole o line.
Atribua o center desta line A um center spot.
Atribua o start desta line e o center ao segunda line.
Atribua o center e o end desta line ao terceiro line.

Etapas necessárias para que se split um número Into um wyrd e uma segunda wyrd:
Isole o número.
Shift o número right 16 bits.
Atribua o número ao wyrd.
Atribua o original número ao segunda wyrd.

Etapas necessárias para que se split a rows of um text Into alguns rows e alguns selecionado rows e alguns segunda rows:
Se o text for inexistente, limpe as rows; limpe o selecionado rows; limpe as segunda rows; exit.
Percorra.
Atribua o first destas rows deste text A um row.
Se a row for inexistente, cancele.
Remove a row from as rows deste text.
Se a row of o text estiver selecionado, acione um alarme; posponha a row para o selecionado rows; repita.
Se o alarme estiver ativo, posponha a row para o segunda rows; repita.
Posponha a row para a rows.
Repita.

Etapas necessárias para que se split um string Into um left subtexto e um right subtexto usando um separator pedaço:
Limpe o left.
Limpe o right.
Se o string estiver em branco, cancele.
Atribua o first deste string A um subtexto's first.
Atribua o first deste subtexto menos 1 ao last deste subtexto.
Percorra.
Se o last deste subtexto for maior do que o last deste string, cancele.
Adicione 1 para o last deste subtexto.
Se o target deste last deste subtexto for o separator pedaço, pare.
Repita.
Atribua o first deste subtexto ao first deste left.
Atribua o last deste subtexto menos 1 ao last deste left.
Atribua o last deste subtexto mais 1 ao first deste right.
Atribua o last deste string ao last deste right.

Etapas necessárias para que se split um string Into alguns conjunto de textos usando um separator pedaço:
Destroy o conjunto de textos.
Se o string estiver em branco, cancele.
Lance um percorredor sobre o string.
Percorra.
Mova o percorredor usando o separator pedaço.
Adicione o token deste percorredor para o conjunto de textos.
Se o source deste percorredor estiver em branco, pare.
Repita.
Se o target deste last deste string não for o separator pedaço, cancele.
Adicione "" para o conjunto de textos.

Etapas necessárias para que se split alguns coisas Into alguns left coisas e alguns right coisas:
Se o coisas estiverem vazio, limpe o left coisas; limpe o right coisas; exit.
Atribua a contagem destas coisas dividido por 2 A um contagem.
Percorra.
Obtenha uma coisa from as coisas.
Se o contagem for 0, pare.
Subtraia 1 from a contagem.
Repita.
Split o coisas ao left coisas e o right coisas at o coisa.

Etapas necessárias para que se split alguns coisas Into alguns left coisas e alguns right coisas at um coisa:
Limpe o left coisas.
Limpe o right coisas.
Se a coisa for inexistente, swap o coisas with o left coisas; exit.
Se o previous desta coisa for inexistente, swap o coisas with o left coisas; exit.
\ abra up o left chain
Atribua o first destas coisas ao first destas left coisas.
Atribua o previous desta coisa ao last destas left coisas.
Esvazie o next deste previous desta coisa.
\ abra up o right chain
Atribua a coisa ao first destas right coisas.
Esvazie o previous desta coisa.
Atribua o last destas coisas ao last destas right coisas.
\ fix o original chain
Limpe as coisas.

Etapas necessárias para que se split um wyrd Into um pedaço e uma segunda pedaço:
Isole o wyrd.
Shift o wyrd right 8 bits.
Atribua o wyrd ao pedaço.
Atribua o original wyrd ao segunda pedaço.

Um spot é um pair with um coordenada x e um coordenada y e um left at o coordenada x e um topo at o coordenada y.

Um spot endereço de memória é um endereço de memória para um spot.

Um square é 1440 units. \ arbitrary número high enough por precision divides

Um square root é um número.

O square size é alguns twips.

Etapas necessárias para que se square up any selection em um text:
Se o text for inexistente, cancele.
Se nothing estiver selecionado no text, cancele.
Normalize a selection deste text.
Obtenha um row usando o caret número da linha deste text e o text.
Atribua 1 ao anchor column# deste text.
Se o caret column# deste text não for 1, adicione 1 para o caret número da linha deste text; atribua 1 ao caret column# deste text.
Se o caret número da linha deste text for menor do que ou igual a a row contagem deste text, cancele.
Atribua a row contagem deste text ao número da linha deste caret deste text.
Atribua o length deste string desta row ao column# deste caret deste text.

\O raiz de dois é uma fração igual a 99/70.
O raiz de dois é uma fração igual a 1414213562/1000000000.
O raiz de três é uma fração igual a 1732050807/1000000000.
\O raiz de cinco é uma fração igual a 161/72.
O raiz de cinco é uma fração igual a 2236067977/1000000000.
O raiz de seis é uma fração igual a 2449489742/1000000000.
O raiz de sete é uma fração igual a 2645751311/1000000000.
O raiz de oito é uma fração igual a 2828427124/1000000000.
O raiz de dez é uma fração igual a 3162277660/1000000000.
O raiz de onze é uma fração igual a 3316624790/1000000000.
\2147483647
\O número pi é uma fração igual a 355/113. \número pi
O número pi é uma fração igual a 3141592653/1000000000.
O número de Euler é uma fração igual a 271828182846/1000000000.
O número neperiano é uma fração igual a 271828182846/1000000000.
O proporção dourada é uma fração igual a 1618033988/1000000000.

An stack entry é uma coisa with um string.

O stack é alguns stack entries.

Etapas necessárias para que se start anywhere em um caixa:
Escolha aleatoriamente o spot deste context no caixa.

Etapas necessárias para que se start anywhere sobre um horizontal line:
Escolha aleatoriamente um spot sobre o horizontal line.
Atribua o spot ao spot deste context.

Etapas necessárias para que se start at o base left corner of um caixa facing east:
Atribua o left-base desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start at o base left corner of um caixa facing north:
Atribua o left-base desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start at o base left corner of um caixa facing south:
Atribua o left-base desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start at o base left corner of um caixa facing west:
Atribua o left-base desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start at o base of um horizontal line:
Atribua o end desta vertical line ao spot deste context.

Etapas necessárias para que se start at o base right corner of um caixa facing east:
Atribua o right-base desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start at o base right corner of um caixa facing north:
Atribua o right-base desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start at o base right corner of um caixa facing south:
Atribua o right-base desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start at o base right corner of um caixa facing west:
Atribua o right-base desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start at o left of um horizontal line:
Atribua o start desta horizontal line ao spot deste context.

Etapas necessárias para que se start at o middle of o base of um caixa;
Etapas necessárias para que se start no middle of o base of um caixa;
Etapas necessárias para que se start at o center of o base of um caixa;
Etapas necessárias para que se start no center of o base of um caixa:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua a base desta caixa ao y deste spot deste context.

Etapas necessárias para que se start at o middle of o base of um caixa facing east;
Etapas necessárias para que se start no middle of o base of um caixa facing east;
Etapas necessárias para que se start at o center of o base of um caixa facing east;
Etapas necessárias para que se start no center of o base of um caixa facing east:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua a base desta caixa ao y deste spot deste context.
Face east.

Etapas necessárias para que se start at o middle of o base of um caixa facing north;
Etapas necessárias para que se start no middle of o base of um caixa facing north;
Etapas necessárias para que se start at o center of o base of um caixa facing north;
Etapas necessárias para que se start no center of o base of um caixa facing north:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua a base desta caixa ao y deste spot deste context.
Face north.

Etapas necessárias para que se start at o middle of o base of um caixa facing south;
Etapas necessárias para que se start no middle of o base of um caixa facing south;
Etapas necessárias para que se start at o center of o base of um caixa facing south;
Etapas necessárias para que se start no center of o base of um caixa facing south:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua a base desta caixa ao y deste spot deste context.
Face south.

Etapas necessárias para que se start at o middle of o base of um caixa facing west;
Etapas necessárias para que se start no middle of o base of um caixa facing west;
Etapas necessárias para que se start at o center of o base of um caixa facing west;
Etapas necessárias para que se start no center of o base of um caixa facing west:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua a base desta caixa ao y deste spot deste context.
Face west.

Etapas necessárias para que se start at o middle of o left of um caixa facing east;
Etapas necessárias para que se start no middle of o left of um caixa facing east;
Etapas necessárias para que se start at o center of o left of um caixa facing east;
Etapas necessárias para que se start no center of o left of um caixa facing east:
Atribua o left desta caixa ao x deste spot deste context.
Atribua o y deste center desta caixa ao y deste spot deste context.
Face east.

Etapas necessárias para que se start at o middle of o left of um caixa facing north;
Etapas necessárias para que se start no middle of o left of um caixa facing north;
Etapas necessárias para que se start at o center of o left of um caixa facing north;
Etapas necessárias para que se start no center of o left of um caixa facing north:
Atribua o left desta caixa ao x deste spot deste context.
Atribua o y deste center desta caixa ao y deste spot deste context.
Face north.

Etapas necessárias para que se start at o middle of o left of um caixa facing south;
Etapas necessárias para que se start no middle of o left of um caixa facing south;
Etapas necessárias para que se start at o center of o left of um caixa facing south;
Etapas necessárias para que se start no center of o left of um caixa facing south:
Atribua o left desta caixa ao x deste spot deste context.
Atribua o y deste center desta caixa ao y deste spot deste context.
Face south.

Etapas necessárias para que se start at o middle of o left of um caixa facing west;
Etapas necessárias para que se start no middle of o left of um caixa facing west;
Etapas necessárias para que se start at o center of o left of um caixa facing west;
Etapas necessárias para que se start no center of o left of um caixa facing west:
Atribua o left desta caixa ao x deste spot deste context.
Atribua o y deste center desta caixa ao y deste spot deste context.
Face west.

Etapas necessárias para que se start at o middle of o right of um caixa facing east;
Etapas necessárias para que se start no middle of o right of um caixa facing east;
Etapas necessárias para que se start at o center of o right of um caixa facing east;
Etapas necessárias para que se start no center of o right of um caixa facing east:
Atribua o right desta caixa ao x deste spot deste context.
Atribua o y deste center desta caixa ao y deste spot deste context.
Face east.

Etapas necessárias para que se start at o middle of o right of um caixa facing north;
Etapas necessárias para que se start no middle of o right of um caixa facing north;
Etapas necessárias para que se start at o center of o right of um caixa facing north;
Etapas necessárias para que se start no center of o right of um caixa facing north:
Atribua o right desta caixa ao x deste spot deste context.
Atribua o y deste center desta caixa ao y deste spot deste context.
Face north.

Etapas necessárias para que se start at o middle of o right of um caixa facing south;
Etapas necessárias para que se start no middle of o right of um caixa facing south;
Etapas necessárias para que se start at o center of o right of um caixa facing south;
Etapas necessárias para que se start no center of o right of um caixa facing south:
Atribua o right desta caixa ao x deste spot deste context.
Atribua o y deste center desta caixa ao y deste spot deste context.
Face south.

Etapas necessárias para que se start at o middle of o right of um caixa facing west;
Etapas necessárias para que se start no middle of o right of um caixa facing west;
Etapas necessárias para que se start at o center of o right of um caixa facing west;
Etapas necessárias para que se start no center of o right of um caixa facing west:
Atribua o right desta caixa ao x deste spot deste context.
Atribua o y deste center desta caixa ao y deste spot deste context.
Face west.

Etapas necessárias para que se start at o middle of o topo of um caixa;
Etapas necessárias para que se start no middle of o topo of um caixa;
Etapas necessárias para que se start at o center of o topo of um caixa;
Etapas necessárias para que se start no center of o topo of um caixa:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua o topo desta caixa ao y deste spot deste context.

Etapas necessárias para que se start at o middle of o topo of um caixa facing east;
Etapas necessárias para que se start no middle of o topo of um caixa facing east;
Etapas necessárias para que se start at o center of o topo of um caixa facing east;
Etapas necessárias para que se start no center of o topo of um caixa facing east:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua o topo desta caixa ao y deste spot deste context.
Face east.

Etapas necessárias para que se start at o middle of o topo of um caixa facing north;
Etapas necessárias para que se start no middle of o topo of um caixa facing north;
Etapas necessárias para que se start at o center of o topo of um caixa facing north;
Etapas necessárias para que se start no center of o topo of um caixa facing north:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua o topo desta caixa ao y deste spot deste context.
Face north.

Etapas necessárias para que se start at o middle of o topo of um caixa facing south;
Etapas necessárias para que se start no middle of o topo of um caixa facing south;
Etapas necessárias para que se start at o center of o topo of um caixa facing south;
Etapas necessárias para que se start no center of o topo of um caixa facing south:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua o topo desta caixa ao y deste spot deste context.
Face south.

Etapas necessárias para que se start at o middle of o topo of um caixa facing west;
Etapas necessárias para que se start no middle of o topo of um caixa facing west;
Etapas necessárias para que se start at o center of o topo of um caixa facing west;
Etapas necessárias para que se start no center of o topo of um caixa facing west:
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua o topo desta caixa ao y deste spot deste context.
Face west.

Etapas necessárias para que se start at o right of um horizontal line:
Atribua o end desta horizontal line ao spot deste context.

Etapas necessárias para que se start at um spot:
Atribua o spot ao spot deste context.

Etapas necessárias para que se start at um spot facing east:
Atribua o spot ao spot deste context.
Face east.

Etapas necessárias para que se start at um spot facing north:
Atribua o spot ao spot deste context.
Face north.

Etapas necessárias para que se start at um spot facing south:
Atribua o spot ao spot deste context.
Face south.

Etapas necessárias para que se start at um spot facing west:
Atribua o spot ao spot deste context.
Face west.

Etapas necessárias para que se start at o topo left corner of um caixa facing east:
Atribua o left-top desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start at o topo left corner of um caixa facing north:
Atribua o left-top desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start at o topo left corner of um caixa facing south:
Atribua o left-top desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start at o topo left corner of um caixa facing west:
Atribua o left-top desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start at o topo of um vertical line:
Atribua o start desta vertical line ao spot deste context.

Etapas necessárias para que se start at o topo right corner of um caixa facing east:
Atribua o right-top desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start at o topo right corner of um caixa facing north:
Atribua o right-top desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start at o topo right corner of um caixa facing south:
Atribua o right-top desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start at o topo right corner of um caixa facing west:
Atribua o right-top desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start no middle of um caixa facing east;
Etapas necessárias para que se start at o middle of um caixa facing east;
Etapas necessárias para que se mova para o middle of um caixa facing east;
Etapas necessárias para que se mova para o middle of um caixa e face east;
Etapas necessárias para que se start no center of um caixa facing east;
Etapas necessárias para que se start at o center of um caixa facing east;
Etapas necessárias para que se mova para o center of um caixa facing east;
Etapas necessárias para que se mova para o center of um caixa e face east:
Atribua o center desta caixa ao spot deste context.
Face east.

Etapas necessárias para que se start no middle of um caixa facing north;
Etapas necessárias para que se start at o middle of um caixa facing north;
Etapas necessárias para que se mova para o middle of um caixa facing north;
Etapas necessárias para que se mova para o middle of um caixa e face north;
Etapas necessárias para que se start no center of um caixa facing north;
Etapas necessárias para que se start at o center of um caixa facing north;
Etapas necessárias para que se mova para o center of um caixa facing north;
Etapas necessárias para que se mova para o center of um caixa e face north:
Atribua o center desta caixa ao spot deste context.
Face north.

Etapas necessárias para que se start no middle of um caixa facing north menos alguns points;
Etapas necessárias para que se start no center of um caixa facing north menos alguns points:
Atribua o center desta caixa ao spot deste context.
Face north.
Vire left o points.

Etapas necessárias para que se start no middle of um caixa facing south;
Etapas necessárias para que se start at o middle of um caixa facing south;
Etapas necessárias para que se mova para o middle of um caixa facing south;
Etapas necessárias para que se mova para o middle of um caixa e face south;
Etapas necessárias para que se start no center of um caixa facing south;
Etapas necessárias para que se start at o center of um caixa facing south;
Etapas necessárias para que se mova para o center of um caixa facing south;
Etapas necessárias para que se mova para o center of um caixa e face south:
Atribua o center desta caixa ao spot deste context.
Face south.

Etapas necessárias para que se start no middle of um caixa facing west;
Etapas necessárias para que se start at o middle of um caixa facing west;
Etapas necessárias para que se mova para o middle of um caixa facing west;
Etapas necessárias para que se mova para o middle of um caixa e face west;
Etapas necessárias para que se start no center of um caixa facing west;
Etapas necessárias para que se start at o center of um caixa facing west;
Etapas necessárias para que se mova para o center of um caixa facing west;
Etapas necessárias para que se mova para o center of um caixa e face west:
Atribua o center desta caixa ao spot deste context.
Face west.

Etapas necessárias para que se start um process usando um endereço completo:
\ must ser called with um global variable
Limpe o i/o erro.
Se o process não for 0, atribua "Erro. Este processo já está sendo executado." ao i/o erro; exit.
Atribua um startupinfo's magnitude ao cb desta startupinfo.
Extract um endereço da pasta from o endereço completo.
Null terminate o endereço da pasta.
Isole o endereço completo. null terminate o endereço completo.
Call "kernel32.dll" "CreateProcessA" with o first deste endereço completo e 0 e 0 e 0 e 0 e 67108904 [create_default_error_mode + normal_priority_class + detached_process] e 0 
And o first deste endereço da pasta e o whereabouts desta startupinfo e um processinfo's whereabouts returning um número.
Se o número for 0, atribua "Erro. Não foi possível executar o programa." ao i/o erro; exit.
Atribua o hprocess deste processinfo ao process.
Call "kernel32.dll" "CloseHandle" with o hthread deste processinfo.
Point um endereço de memória to routine aguarde por um process endereço de memória.
Call "kernel32.dll" "CreateThread" with 0 e 0 e o endereço de memória e o whereabouts deste process e 0 e uma segunda número's whereabouts returning um handle.
Call "kernel32.dll" "CloseHandle" with o handle. \ does not end o thread, just dumps o handle

Etapas necessárias para que se start um cronômetro:
Reset o cronômetro.
Restart o cronômetro.

Etapas necessárias para que se start alguns twips above o middle of o base of um caixa:
\ incomplete abra of these
Atribua o x deste center desta caixa ao x deste spot deste context.
Atribua a base desta caixa menos o twips ao y deste spot deste context.

Etapas necessárias para que se start alguns twips down from um spot;
Etapas necessárias para que se start alguns twips below um spot:
Atribua o x deste spot ao x deste context.
Atribua o y deste spot mais o twips ao y deste context.

Etapas necessárias para que se start alguns twips from o center of um caixa:
Atribua o center desta caixa ao spot deste context.
Mova o twips.

Etapas necessárias para que se start alguns twips para o left e alguns segunda twips down from um spot;
Etapas necessárias para que se start alguns twips left e alguns segunda twips down from um spot:
Atribua o x deste spot menos o twips ao x deste context.
Atribua o y deste spot mais o segunda twips ao y deste context.

Etapas necessárias para que se start alguns twips left e alguns segunda twips up from um spot:
Atribua o x deste spot menos o twips ao x deste context.
Atribua o y deste spot menos o segunda twips ao y deste context.

Etapas necessárias para que se start alguns twips para o left e alguns segunda twips up from um spot;
Etapas necessárias para que se start alguns twips para o left of um spot;
Etapas necessárias para que se start alguns twips left of um spot:
Atribua o x deste spot menos o twips ao x deste context.

Etapas necessárias para que se start alguns twips para o right e alguns segunda twips down from um spot;
Etapas necessárias para que se start alguns twips right e alguns segunda twips down from um spot:
Atribua o x deste spot mais o twips ao x deste context.
Atribua o y deste spot mais o segunda twips ao y deste context.

Etapas necessárias para que se start alguns twips para o right e alguns segunda twips up from um spot;
Etapas necessárias para que se start alguns twips right e alguns segunda twips up from um spot:
Atribua o x deste spot mais o twips ao x deste context.
Atribua o y deste spot menos o segunda twips ao y deste context.

Etapas necessárias para que se start alguns twips up from um coord:
Atribua o coord menos o twips ao y deste context.

Etapas necessárias para que se start alguns twips up from um spot;
Etapas necessárias para que se start alguns twips above um spot:
Atribua o y deste spot ao y deste context.
Subtraia o twips from o y deste context.

Etapas necessárias para que se carregue as biliotecas padrão do sistema;
Etapas necessárias para que se start up:
Initialize with.
Initialize winsock.
Initialize gdi+.
Initialize o talker.
Initialize o module.
Initialize o cors.
Initialize o tela.
Initialize o window.
Initialize o fonts.
Initialize o cursors.
Initialize o mouse.
Initialize o canvases.
Initialize o context.
Initalize o terminal.
Crie o console.

\Passos necessários para a execução do programa:
\Initialize with.
\Initialize winsock.
\Initialize gdi+.
\Initialize o talker.
\Initialize o module.
\Initialize o cors.
\Initialize o tela.
\Initialize o window.
\Initialize o fonts.
\Initialize o cursors.
\Initialize o mouse.
\Initialize o canvases.
\Initialize o context.
\Initalize o terminal.
\Crie o console.

Etapas necessárias para que se start up o cgi:
Initialize winsock.
Initialize o module.
Initialize o cgi.

Etapas necessárias para que se start with um cor:
Atribua a cor à cor deste context.

Etapas necessárias para que se start with nothing em um endereço de memória:
Esvazie o endereço de memória.

O start-of-heading pedaço é um pedaço igual a 1.

O start-of-text pedaço é um pedaço igual a 2.

Um startupinfo é um conjunto with
Um número called cb,
Um endereço de memória called lIsoled,
Um endereço de memória called lpdesktop,
Um endereço de memória called lptitle,
Um número called dwx,
Um número called dwy,
Um número called dwxsize,
Um número called dwysize,
Um número called dwxcountchars,
Um número called cwycountchars,
Um número called dwfillattribute,
Um número called dwflags,
Um wyrd called wshowwindow,
Um wyrd called cbreserved2,
Um endereço de memória called lIsoled2,
Um handle called hstdinput,
Um handle called hstdoutput,
Um handle called hstderror.

O stdin handle é um handle.

O stdout handle é um handle.

Etapas necessárias para que se suspenda um process:
Se o process for 0, cancele.
Call "kernel32.dll" "TerminateProcess" with o process e 0.
Atribua 0 ao process.

Etapas necessárias para que se suspenda um cronômetro:
Se a contagem deste cronômetro for 0, cancele.
Subtraia 1 from a contagem deste cronômetro.
Se a contagem deste cronômetro não for 0, cancele.
Atribua o system's tick contagem A alguns ticks.
Subtraia os start ticks deste cronômetro from o ticks.
Adicione o ticks para os total ticks deste cronômetro.

Um string é um conjunto with um first endereço de memória do pedaço e um last endereço de memória do pedaço .

An conjunto de texto é uma coisa with um string.

An string# é um número.

Etapas necessárias para que se draw o turtle text grid:
\ this é called pelo temporary line no "Stoke a ___ glyph" routine
Save o context. Atribua o pincel size A an saved pincel size. \ see REMARK below
Use o light gray pincel.
Atribua a tamanho da letra deste context dividido por 4 A an size.
Vire around. Mova o size. Vire around.
Draw o turtle text grid caixa es.
Vire right. Mova o size. Vire left.
Draw o turtle text grid caixa es.
Restore o context. Atribua o saved pincel size ao pincel size. \ see REMARK below
 
Etapas necessárias para que se draw o turtle text grid caixa es:
\ this é called from a routine above para draw one column of grid caixa es
Atribua a tamanho da letra deste context dividido por 4 A an size.
Save o context.
Use o skinny pincel.
Percorra.
Stroke o size. Vire right.
Stroke o size. Vire right.
Stroke o size. Vire right.
Stroke o size. Vire right.
Mova o size.
Adicione 1 para an contagem. Se o contagem for menor do que 6, repita.
Restore o context.



Etapas necessárias para que se stroke o accent glyph:
Save o context.
Mova 4 squares.
Vire right.
Vire right 7/96 of o way.
Stroke 9/4 square.
Restore o context.

Etapas necessárias para que se stroke o asterisk glyph:
Save o context.
Mova 2 squares.
Vire right.
Stroke 2 squares.
Vire left.
Mova 1 square.
Vire left.
Mova 1 square.
Vire left.
Stroke 2 squares.
Reset o context.
Mova 1 square.
Vire right 1/8.
Stroke 2 squares slantways.
Reset o context.
Mova 3 squares.
Vire right 3/8.
Stroke 2 squares slantways.
Restore o context.

Etapas necessárias para que se stroke o sinal de arroba glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 3/8.
Stroke 1/2 square slantways.
Vire left.
Stroke 1/2 square slantways.
Vire left.
Stroke 1/2 square slantways.
Vire left.
Stroke 1/2 square slantways.
Restore o context.

Etapas necessárias para que se stroke a barra invertida glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Vire left 7/96 of o way.
Stroke 9/2 square.
Restore o context.

Etapas necessárias para que se stroke o big-a glyph:
Save o context.
Stroke 2-2/3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-a-acute glyph:
Save o context.
Stroke 2-2/3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/16 squares.
Vire right.
Mova 1-14/16 square.
Vire left.
Vire right 4/32.
Stroke 1 square menos 1/2 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-a-circumflex glyph:
Save o context.
Stroke 2-2/3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/16 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-a-diaeresis glyph:
Save o context.
Stroke 2-2/3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/3 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-a-grave glyph:
Save o context.
Stroke 2-2/3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-2/8 squares.
Vire right.
Mova 1/100 square.
\Vire left.
Vire right 4/32.
Stroke 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-a-tilde glyph:
Save o context.
Stroke 2-2/3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2-2/3 squares.
Vire around.
Mova 1-1/2 squares.
Vire left.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 1/6 square. Vire left.
Vire right 1/8.
Stroke 9/16 square.
Vire right 3/16.
Stroke 1 square.
Vire left 3/16.
Stroke 5/8 square.
\ end accent mark
Restore o context.


Etapas necessárias para que se stroke o big-b glyph:
Save o context.
Stroke 3-6/8 squares.
Vire right.
Stroke 1 square.
Vire right 1/10.
Stroke 3/4 square slantways.
Vire right.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire right.
Vire right 1/100.
Stroke 1 square slantways.
Vire left 85/100. Stroke 1-1/3 squares.
Restore o context. Save o context.
Mova 2 squares. Vire right. Stroke 1-1/4 squares.
Restore o context.

Etapas necessárias para que se stroke o big-c glyph:
Save o context.
Mova 1-3/4 squares.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Reset o context.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o Ç maiúsculo glyph:
Save o context.
Mova 1-3/4 squares.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Reset o context.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
\ start cedilla mark
Restore o context. Save o context.
Vire right.
Mova 1 square.
Vire right.
Stroke 1/2 square.
Vire left.
Stroke 1/2 square.
Vire right.
Stroke 1/2 square.
Vire right.
Stroke 1/2 square.
\ end cedilla mark
Restore o context.

Etapas necessárias para que se stroke o big-d glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-1/2 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o big-e glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Stroke 1 square.
Reset o context.
Vire right.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-e-acute glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Stroke 1 square.
Reset o context.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1-1/2 square.
Vire left.
Vire right 4/32.
Stroke 1 square menos 1/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-e-circumflex glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Stroke 1 square.
Reset o context.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-e-diaeresis glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Stroke 1 square.
Reset o context.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/3 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-e-grave glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 1-84/100 squares.
Vire right.
Stroke 1 square.
Reset o context.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 49/100 square.
\Vire left.
Vire right 4/32.
Stroke 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-e-tilde glyph:
Save o context.
Stroke 4 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 2 squares.
Vire right.
Stroke 1 square.
Reset o context.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right 1/8.
Stroke 9/16 square.
Vire right 3/16.
Stroke 1 square.
Vire left 3/16.
Stroke 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-f glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 2 squares.
Vire right.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o big-g glyph:
Save o context.
Mova 1-7/8 squares.
Stroke 7/8 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Reset o context.
Mova 1-6/8 squares.
Vire around.
Stroke 7/8 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 7/8 square.
Vire left.
Stroke 7/8 square.
Vire left.
Stroke 1/32 square.
Restore o context.

Etapas necessárias para que se stroke o big-h glyph:
Save o context.
Stroke 3-1/2 squares.
Reset o context.
Mova 1-80/100 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 3-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-i glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 3-1/2 squares.
Reset o context.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-i-acute glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 3-1/2 squares.
Reset o context.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1 square.
Vire left.
Vire right 4/32.
Stroke 1 square menos 1/2 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-i-circumflex glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 3-1/2 squares.
Reset o context.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-i-diaeresis glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 3-1/2 squares.
Reset o context.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/3 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-i-grave glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 3-1/2 squares.
Reset o context.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 3-1/2 squares.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 68/100 square.
\Vire left.
Vire right 4/32.
Stroke 1 square menos 3/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-j glyph:
Save o context.
Mova 1-7/8 squares.
Vire around.
Stroke 6/8 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 2-5/8 squares.
Restore o context.

Etapas necessárias para que se stroke o big-k glyph:
Save o context.
Stroke 3-3/4 squares.
Vire around.
Mova 1-3/4 squares.
Vire left.
Stroke 1 square.
Save o context.
Vire left 1/8.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 3/4 square.
Restore o context.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o big-l glyph:
Save o context.
Mova 3-5/8 squares.
Vire around.
Stroke 3-5/8 squares.
Vire left.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-m glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right 41/96.
Stroke 9/4 square.
Vire right 62/96.
Stroke 9/4 square.
Vire right 41/96.
Stroke 3-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-n glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right 41/96.
Stroke 8/2 square.
Vire left 41/96.
Stroke 3-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-n-tilde glyph:
Save o context.
Stroke 3-1/2 squares.
Vire right 41/96.
Stroke 8/2 square.
Vire left 41/96.
Stroke 3-1/2 squares.
Restore o context.
\ start accent mark
Restore o context. Save o context.
Mova 4 squares.
Vire right 1/8.
Stroke 9/16 square.
Vire right 3/16.
Stroke 1 square.
Vire left 3/16.
Stroke 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-o glyph:
Save o context.
Mova 1 square.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o big-o-acute glyph:
Save o context.
Mova 1 square.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right.
Mova 1-14/16 square.
Vire left.
Vire right 4/32.
Stroke 1 square menos 1/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-o-circumflex glyph:
Save o context.
Mova 1 square.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-o-diaeresis glyph:
Save o context.
Mova 1 square.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/3 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-o-grave glyph:
Save o context.
Mova 1 square.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
\Mova 5/100 square.
\Vire left.
Vire right 4/32.
Stroke 1 square menos 3/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-o-tilde glyph:
Save o context.
Mova 1 square.
Stroke 2 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right. Mova 1/8 square. Vire left.
Vire right 1/8.
Stroke 9/16 square.
Vire right 3/16.
Stroke 1 square.
Vire left 3/16.
Stroke 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-p glyph:
Save o context.
Stroke 3-4/8 squares.
Vire right.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o big-q glyph:
Save o context.
Mova 1 square.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-6/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Reset o context.
Mova 1 square.
Vire right.
Mova 1 square.
Vire right 1/8 of o way.
Stroke 1-1/2 square.
Restore o context.

Etapas necessárias para que se stroke o big-r glyph:
Save o context.
Stroke 3-4/8 squares.
Vire right.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire left 1/8.
Vire left 7/96.
Stroke 3/2 square.
Restore o context.

Etapas necessárias para que se stroke o big-s glyph:
Save o context.
Mova 7/8 square.
Vire around.
Vire left 1/8.
Stroke 7/8 square slantways.
Vire left.
Stroke 7/8 square slantways.
Vire left.
Stroke 2 squares slantways.
Vire right.
Stroke 7/8 square slantways.
Vire right.
Stroke 7/8 square slantways.
Restore o context.

Etapas necessárias para que se stroke o big-t glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 3-4/8 squares.
Vire left.
Mova 1 square.
Vire around.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-u glyph:
Save o context.
Mova 3-1/2 squares.
Vire around.
Stroke 3-1/2 squares.
Vire left.
Stroke 2 squares.
Vire left.
Stroke 3-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-u-acute glyph:
Save o context.
Mova 3-1/2 squares.
Vire around.
Stroke 3-1/2 squares.
Vire left.
Stroke 2 squares.
Vire left.
Stroke 3-1/2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/5 squares.
Vire right.
Mova 1 square.
Vire left.
Vire right 4/32.
Stroke 1 square menos 1/2 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-u-circumflex glyph:
Save o context.
Mova 3-1/2 squares.
Vire around.
Stroke 3-1/2 squares.
Vire left.
Stroke 2 squares.
Vire left.
Stroke 3-1/2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/8 squares.
Vire right. Mova 1/8 squares. Vire left.
Vire right. Mova 1/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-u-diaeresis glyph:
Save o context.
Mova 3-1/2 squares.
Vire around.
Stroke 3-1/2 squares.
Vire left.
Stroke 2 squares.
Vire left.
Stroke 3-1/2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 1/2 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-u-grave glyph:
Save o context.
Mova 3-1/2 squares.
Vire around.
Stroke 3-1/2 squares.
Vire left.
Stroke 2 squares.
Vire left.
Stroke 3-1/2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4-1/2 squares.
Vire right.
Mova 50/100 square.
\Vire left.
Vire right 4/32.
Stroke 1 square menos 1/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-v glyph:
Save o context.
Mova 3-1/2 squares.
Vire around.
Stroke 2-1/2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 2-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-w glyph:
Save o context.
Mova 3-1/2 squares.
Vire around.
Stroke 3-1/2 squares.
Vire left 41/96.
Stroke 9/4 square.
Vire left 61/96.
Stroke 9/4 square.
Restore o context. Save o context.
Vire right.
Mova 2 squares.
Vire left 2/3 squares.
Stroke 3-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o big-x glyph:
Save o context.
Stroke 6/8 square.
Vire right 1/8.
Stroke 2 squares slantways.
Vire left 1/8.
Stroke 6/8 square.
Reset o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 6/8 square.
Vire left 1/8.
Stroke 2 squares slantways.
Vire right 1/8.
Stroke 6/8 square.
Restore o context.

Etapas necessárias para que se stroke o big-y glyph:
Save o context.
Mova 3-5/8 squares.
Vire around.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Reset o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 1-5/8 squares.
Restore o context.

Etapas necessárias para que se stroke o big-y-acute glyph:
Save o context.
Mova 3-5/8 squares.
Vire around.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Reset o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 1-5/8 squares.
\ start accent mark
Restore o context. Save o context.
Mova 4 squares.
Vire right.
Mova 1 square.
Vire left.
Vire right 4/32.
Stroke 1 square menos 1/2 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o big-z glyph:
Save o context.
Mova 3-5/8 squares.
Vire right.
Stroke 2 squares.
Vire right.
Stroke 5/8 square.
Vire right 1/8.
Stroke 2 squares slantways.
Vire left 1/8.
Stroke 5/8 square.
Vire left.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke um caixa with um cor:
Atribua a cor à cor deste context.
Atribua o left-base desta caixa ao spot deste context.
Face north.
Stroke a altura desta caixa.
Vire right.
Stroke a width desta caixa.
Vire right.
Stroke a altura desta caixa.
Vire right.
Stroke a width desta caixa.

Etapas necessárias para que se stroke um pedaço:
\\ Essa rotina aqui "DESENHA" uma letra.
Atribua a tamanho da letra deste context dividido por 4 ao square size. \ ***
\Draw o turtle text grid. \ for testing -- adicione me now, delete me later -- see below
\LETRAS MAIÚSCULAS
Se o pedaço for o acento grave, stroke o accent glyph.
Se o pedaço for o asterisco, stroke o asterisk glyph.
Se o pedaço for o sinal de arroba, stroke o sinal de arroba glyph.
Se o pedaço for a barra invertida, stroke a barra invertida glyph.
Se o pedaço for o 'A' maiúsculo, stroke o big-a glyph.
Se o pedaço for o Á maiúsculo, stroke o big-a-acute glyph. \ *** new line
Se o pedaço for o Â maiúsculo, stroke o big-a-circumflex glyph. \ *** new line
Se o pedaço for o Ä maiúsculo, stroke o big-a-diaeresis glyph. \ *** new line
Se o pedaço for o 'À' maiúsculo, stroke o big-a-grave glyph. \ *** new line
Se o pedaço for o Ã maiúsculo, stroke o big-a-tilde glyph. \ *** new line
Se o pedaço for o B maiúsculo, stroke o big-b glyph.
Se o pedaço for o C maiúsculo, stroke o big-c glyph.
Se o pedaço for o Ç maiúsculo, stroke o Ç maiúsculo glyph.
Se o pedaço for o D maiúsculo, stroke o big-d glyph.
Se o pedaço for o 'E' maiúsculo, stroke o big-e glyph.
Se o pedaço for o 'É' maiúsculo, stroke o big-e-acute glyph. \ *** new line
Se o pedaço for o Ê maiúsculo, stroke o big-e-circumflex glyph. \ *** new line
Se o pedaço for o Ë maiúsculo, stroke o big-e-diaeresis glyph. \ *** new line
Se o pedaço for o È maiúsculo, stroke o big-e-grave glyph. \ *** new line
Se o pedaço for o F maiúsculo, stroke o big-f glyph.
Se o pedaço for o G maiúsculo, stroke o big-g glyph.
Se o pedaço for o H maiúsculo, stroke o big-h glyph.
Se o pedaço for o I maiúsculo, stroke o big-i glyph.
Se o pedaço for o Í maiúsculo, stroke o big-i-acute glyph. \ *** new line
Se o pedaço for o Î maiúsculo, stroke o big-i-circumflex glyph. \ *** new line
Se o pedaço for o Ï maiúsculo, stroke o big-i-diaeresis glyph. \ *** new line
Se o pedaço for o Ì maiúsculo, stroke o big-i-grave glyph. \ *** new line
Se o pedaço for o J maiúsculo, stroke o big-j glyph.
Se o pedaço for o K maiúsculo, stroke o big-k glyph.
Se o pedaço for o L maiúsculo, stroke o big-l glyph.
Se o pedaço for o M maiúsculo, stroke o big-m glyph.
Se o pedaço for o N maiúsculo, stroke o big-n glyph.
Se o pedaço for o Ñ maiúsculo, stroke o big-n-tilde glyph.
Se o pedaço for o 'O' maiúsculo, stroke o big-o glyph.
Se o pedaço for o Ó maiúsculo, stroke o big-o-acute glyph. \ *** new line
Se o pedaço for o Ô maiúsculo, stroke o big-o-circumflex glyph. \ *** new line
Se o pedaço for o Ö maiúsculo, stroke o big-o-diaeresis glyph. \ *** new line
Se o pedaço for o Ò maiúsculo, stroke o big-o-grave glyph. \ *** new line
Se o pedaço for o Õ maiúsculo, stroke o big-o-tilde glyph. \ *** new line
Se o pedaço for o P maiúsculo, stroke o big-p glyph.
Se o pedaço for o Q maiúsculo, stroke o big-q glyph.
Se o pedaço for o R maiúsculo, stroke o big-r glyph.
Se o pedaço for o S maiúsculo, stroke o big-s glyph.
Se o pedaço for o T maiúsculo, stroke o big-t glyph.
Se o pedaço for o U maiúsculo, stroke o big-u glyph.
Se o pedaço for o Ú maiúsculo, stroke o big-u-acute glyph. \ *** new line
Se o pedaço for o Û maiúsculo, stroke o big-u-circumflex glyph. \ *** new line
Se o pedaço for o Ù maiúsculo, stroke o big-u-grave glyph. \ *** new line
Se o pedaço for o Ü maiúsculo, stroke o big-u-diaeresis glyph. \ *** new line
Se o pedaço for o V maiúsculo, stroke o big-v glyph.
Se o pedaço for o W maiúsculo, stroke o big-w glyph.
Se o pedaço for o x maiúsculo, stroke o big-x glyph.
Se o pedaço for o Y maiúsculo, stroke o big-y glyph.
Se o pedaço for o Ý maiúsculo, stroke o big-y-acute glyph. \ *** new line
Se o pedaço for o Z maiúsculo, stroke o big-z glyph.
\FIM DAS LETRAS MAIÚSCULAS
\SÍMBOLOS
Se o pedaço for o caret pedaço, stroke o caret glyph.
Se o pedaço for o sinal de dois pontos, stroke o colon glyph.
Se o pedaço for o vírgula, stroke o comma glyph.
Se o pedaço for o cifrão, stroke o dollar-sign glyph.
Se o pedaço for as aspas duplas, stroke o double-quote glyph.
Se o pedaço for o número oito, stroke o eight glyph.
Se o pedaço for o sinal de igualdade, stroke o equal-sign glyph.
Se o pedaço for o exclamation-mark pedaço, stroke o exclamation-mark glyph.
Se o pedaço for o número cinco, stroke o five glyph.
Se o pedaço for o número quatro, stroke o four glyph.
Se o pedaço for o left-alligator pedaço, stroke o left-alligator glyph.
Se o pedaço for o left-brace pedaço, stroke o left-brace glyph.
Se o pedaço for o left-bracket pedaço, stroke o left-bracket glyph.
Se o pedaço for o left-paren pedaço, stroke o left-paren glyph.
\letras minúsculas
Se o pedaço for o little-a pedaço, stroke o little-a glyph.
Se o pedaço for o little-a-acute pedaço, stroke o little-a-acute glyph. \ *** new line
Se o pedaço for o little-a-circumflex pedaço, stroke o little-a-circumflex glyph. \ *** new line
Se o pedaço for o little-a-trema, stroke o little-a-diaeresis glyph. \ *** new line
Se o pedaço for o little-a-grave pedaço, stroke o little-a-grave glyph. \ *** new line
Se o pedaço for o little-a-tilde pedaço, stroke o little-a-tilde glyph. \ *** new line
Se o pedaço for o little-b pedaço, stroke o little-b glyph.
Se o pedaço for o little-c pedaço, stroke o little-c glyph.
Se o pedaço for o little-c-sinal de cedilha, stroke o little-c-cedilla glyph. \new line
Se o pedaço for o little-d pedaço, stroke o little-d glyph.
Se o pedaço for o little-e pedaço, stroke o little-e glyph.
Se o pedaço for o little-e-acute pedaço, stroke o little-e-acute glyph. \ *** new line
Se o pedaço for o little-e-circumflex pedaço, stroke o little-e-circumflex glyph. \ *** new line
Se o pedaço for o little-e-trema, stroke o little-e-diaeresis glyph. \ *** new line
Se o pedaço for o little-e-grave pedaço, stroke o little-e-grave glyph. \ *** new line
Se o pedaço for o little-f pedaço, stroke o little-f glyph.
Se o pedaço for o little-g pedaço, stroke o little-g glyph.
Se o pedaço for o little-h pedaço, stroke o little-h glyph.
Se o pedaço for o little-i pedaço, stroke o little-i glyph.
Se o pedaço for o little-i-acute pedaço, stroke o little-i-acute glyph. \ *** new line
Se o pedaço for o little-i-circumflex pedaço, stroke o little-i-circumflex glyph. \ *** new line
Se o pedaço for o little-i-trema, stroke o little-i-diaeresis glyph. \ *** new line
Se o pedaço for o little-i-grave pedaço, stroke o little-i-grave glyph. \ *** new line
Se o pedaço for o little-j pedaço, stroke o little-j glyph.
Se o pedaço for o little-k pedaço, stroke o little-k glyph.
Se o pedaço for o little-l pedaço, stroke o little-l glyph.
Se o pedaço for o little-m pedaço, stroke o little-m glyph.
Se o pedaço for o little-n pedaço, stroke o little-n glyph.
Se o pedaço for o little-n-tilde pedaço, stroke o little-n-tilde glyph.
Se o pedaço for o little-o pedaço, stroke o little-o glyph.
Se o pedaço for o little-o-acute pedaço, stroke o little-o-acute glyph. \ *** new line
Se o pedaço for o little-o-circumflex pedaço, stroke o little-o-circumflex glyph. \ *** new line
Se o pedaço for o little-o-trema, stroke o little-o-diaeresis glyph. \ *** new line
Se o pedaço for o little-o-grave pedaço, stroke o little-o-grave glyph. \ *** new line
Se o pedaço for o little-o-tilde pedaço, stroke o little-o-tilde glyph. \ *** new line
Se o pedaço for o little-p pedaço, stroke o little-p glyph.
Se o pedaço for o little-q pedaço, stroke o little-q glyph.
Se o pedaço for o little-r pedaço, stroke o little-r glyph.
Se o pedaço for o little-s pedaço, stroke o little-s glyph.
Se o pedaço for o little-t pedaço, stroke o little-t glyph.
Se o pedaço for o little-u pedaço, stroke o little-u glyph.
Se o pedaço for o little-u-acute pedaço, stroke o little-u-acute glyph. \ *** new line
Se o pedaço for o little-u-circumflex pedaço, stroke o little-u-circumflex glyph. \ *** new line
Se o pedaço for o little-u-trema, stroke o little-u-diaeresis glyph. \ *** new line
Se o pedaço for o little-u-grave pedaço, stroke o little-u-grave glyph. \ *** new line
Se o pedaço for o little-v pedaço, stroke o little-v glyph.
Se o pedaço for o little-w pedaço, stroke o little-w glyph.
Se o pedaço for o little-x pedaço, stroke o little-x glyph.
Se o pedaço for o little-y pedaço, stroke o little-y glyph.
Se o pedaço for o little-y-acute pedaço, stroke o little-y-acute glyph.
Se o pedaço for o z minúsculo, stroke o little-z glyph.
Se o pedaço for o minus-sign pedaço, stroke o minus-sign glyph.
Se o pedaço for o número nove, stroke o nine glyph.
Se o pedaço for o número-sign pedaço, stroke o número-sign glyph.
Se o pedaço for o one pedaço, stroke o one glyph.
Se o pedaço for o sinal de porcentagem, stroke o percent-sign glyph.
Se o pedaço for o ponto final, stroke o period glyph.
Se o pedaço for o plus-sign pedaço, stroke o plus-sign glyph.
Se o pedaço for o question-mark pedaço, stroke o question-mark glyph.
Se o pedaço for o right-alligator pedaço, stroke o right-alligator glyph.
Se o pedaço for o right-brace pedaço, stroke o right-brace glyph.
Se o pedaço for o right-bracket pedaço, stroke o right-bracket glyph.
Se o pedaço for o right-paren pedaço, stroke o right-paren glyph.
Se o pedaço for o ponto&vírgula, stroke o semi-colon glyph.
Se o pedaço for o número sete, stroke o seven glyph.
Se o pedaço for o single-quote pedaço, stroke o single-quote glyph.
Se o pedaço for o número seis, stroke o six glyph.
Se o pedaço for o slash pedaço, stroke o slash glyph.
Se o pedaço for o número três, stroke o three glyph.
Se o pedaço for o acento til, stroke o tilde glyph.
Se o pedaço for o número dois, stroke o two glyph.
Se o pedaço for o underscore pedaço, stroke o underscore glyph.
Se o pedaço for o vertical-bar pedaço, stroke o vertical-bar glyph.
Se o pedaço for o número zero, stroke o zero glyph.
\ Atualize o tela. \ *** questionable does not work screws up console.

Etapas necessárias para que se stroke o caret glyph:
Save o context.
Mova 3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o colon glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 1/2 square.
Mova 1/2 square.
Mova 1 square.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o comma glyph:
Save o context.
Vire around.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o dollar-sign glyph:
Save o context.
Mova 1 square.
Vire around.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left.
Stroke 2 squares slantways.
Vire right.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Reset o context.
Vire right.
Mova 1 square.
Vire right.
Mova 1/2 square.
Vire around.
Stroke 5 squares.
Restore o context.

Etapas necessárias para que se stroke o double-quote glyph:
Save o context.
Vire right.
Mova 1/2 square.
Vire left.
Mova 2-1/2 squares.
Stroke 1-1/2 squares.
Reset o context.
Vire right.
Mova 1-1/2 squares.
Vire left.
Mova 2-1/2 squares.
Stroke 1-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o eight glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left 3/8.
Stroke 9/10 square slantways.
Vire right.
Stroke 178/100 squares slantways.
Vire left.
Stroke 9/10 square slantways.
Vire left.
Stroke 9/10 square slantways.
Vire left.
Stroke 178/100 squares slantways.
Vire right.
Stroke 9/10 square slantways.
Restore o context.

Etapas necessárias para que se stroke o equal-sign glyph:
Save o context.
Mova 1-1/2 squares.
Vire right.
Stroke 2 squares.
Vire left.
Mova 1 square.
Vire left.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o exclamation-mark glyph:
Save o context.
Mova 4 squares.
Vire right.
Mova 1 square.
Vire right.
Stroke 3 squares.
Mova 1 square.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o five glyph:
Save o context.
Vire right.
Stroke 1 square. Vire left.
Vire around.
\Mova 1 square.
Vire left 3/8.
Stroke 1 squares slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire right.
Stroke 1-5/8 squares.
Vire right.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o four glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 3-5/8 squares.
Vire left 3/8.
Stroke 2 squares slantways.
Vire left 3/8.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o left-alligator glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 17/96 of o way.
Stroke 9/4 square.
Vire right 34/96 of o way.
Stroke 9/4 square.
Restore o context.

Etapas necessárias para que se stroke o left-brace glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire right.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire right.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o left-bracket glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire right.
Stroke 4 squares.
Vire right.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o left-paren glyph:
Save o context.
Vire right.
Mova 1-1/2 squares.
Vire left 3/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2 squares.
Vire right 1/8.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke um line como high como um caixa;
Etapas necessárias para que se stroke um line como tall como um caixa;
Etapas necessárias para que se draw um line como high como um caixa;
Etapas necessárias para que se draw um line como tall como um caixa:
Stroke a altura desta caixa.

Etapas necessárias para que se stroke um line como wide como um caixa;
Etapas necessárias para que se draw um line como wide como um caixa:
Stroke a width desta caixa.

Etapas necessárias para que se stroke o little-a glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o little-a-acute glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-8/16 squares.
Vire right.
Mova 1-10/16 square.
Vire left.
Vire right 4/32.
Stroke 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-a-circumflex glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right. Mova 3/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-a-diaeresis glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/3 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-a-grave glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right.
Mova 1/100 square.
Vire right 4/32.
Stroke 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-a-tilde glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/8 squares.
Vire right 1/8.
Mova 1/2 square.
Stroke 9/16 square.
Vire right 3/16.
Stroke 1 square.
Vire left 3/16.
Stroke 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-b glyph:
Save o context.
Stroke 4 squares.
Vire around.
Mova 2 squares.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o little-c glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o little-c-cedilla glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
\ start cedilla mark
Restore o context. Save o context.
Vire right.
Mova 1 square.
Vire right.
Stroke 1/2 square.
Vire left.
Stroke 1/2 square.
Vire right.
Stroke 1/2 square.
Vire right.
Stroke 1/2 square.
\ end cedilla mark
Restore o context.


Etapas necessárias para que se stroke o little-d glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 4 squares.
Vire around.
Mova 2 squares.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o little-e glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1/2 square.
Vire right.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o little-e-acute glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1/2 square.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-8/16 squares.
Vire right.
Mova 1-10/16 square.
Vire left.
Vire right 4/32.
Stroke 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-e-circumflex glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1/2 square.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/16 squares.
Vire right. Mova 3/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-e-diaeresis glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1/2 square.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/3 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-e-grave glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire around.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1/2 square.
Vire right.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right.
Mova 1/100 square.
Vire right 4/32.
Stroke 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-f glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Save o context.
Vire around.
Vire right 1/8.
Stroke 1/2 square slantways.
Restore o context.
Stroke 3 squares.
Vire right 1/8.
Stroke 1/2 square slantways.
Vire right.
Stroke 1/2 square slantways.
Reset o context.
Mova 1-6/8 squares.
Vire right.
Mova 1/3 square.
Stroke 1-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o little-g glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2/3 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Reset o context.
Mova 3 squares.
Vire right.
Mova 2 squares.
Vire right.
Stroke 3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 2/20.
Stroke 5/10 square.
Restore o context.

Etapas necessárias para que se stroke o little-h glyph:
Save o context.
Stroke 3-3/4 squares.
Vire around.
Mova 2 squares.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-3/4 squares.
Restore o context.

Etapas necessárias para que se stroke o little-i glyph:
Save o context.
Vire right.
Stroke 2 squares.
Vire around.
Mova 1 square.
Vire right.
Stroke 2-1/2 squares.
Vire left.
Stroke 1 square.
Vire around.
Mova 1 square.
Vire left.
Mova 1/2 square.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o little-i-acute glyph:
Save o context.
Vire right.
Stroke 2 squares.
Vire around.
Mova 1 square.
Vire right.
Stroke 2-1/2 squares.
Vire left.
Stroke 1 square.
Vire around.
Mova 1 square.
Vire left.
Mova 1/2 square.
\Stroke 1/2 square. \removido o ponto do i
\ start accent mark
Restore o context. Save o context.
Mova 2-15/16 squares.
Vire right.
Mova 1-2/16 square.
Vire left.
Vire right 4/32.
Stroke 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-i-circumflex glyph:
Save o context.
Vire right.
Stroke 2 squares.
Vire around.
Mova 1 square.
Vire right.
Stroke 2-1/2 squares.
Vire left.
Stroke 1 square.
Vire around.
Mova 1 square.
Vire left.
Mova 1/2 square.
\Stroke 1/2 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/16 squares.
Vire right. \Mova 1/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-i-diaeresis glyph:
Save o context.
Vire right.
Stroke 2 squares.
Vire around.
Mova 1 square.
Vire right.
Stroke 2-1/2 squares.
Vire left.
Stroke 1 square.
\Vire around.
\Mova 1 square.
\Vire left.
\Mova 1/2 square.
\Stroke 1/2 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/16 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-i-grave glyph:
Save o context.
Vire right.
Stroke 2 squares.
Vire around.
Mova 1 square.
Vire right.
Stroke 2-1/2 squares.
Vire left.
Stroke 1 square.
Vire around.
Mova 1 square.
Vire left.
Mova 1/2 square.
\Stroke 1/2 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right.
Mova 29/100 square.
Vire right 4/32.
Stroke 1 square menos 2/4 square.
\ end accent mark
Restore o context.


Etapas necessárias para que se stroke o little-j glyph:
Save o context.
Mova 1 square.
Vire around.
Stroke 1 square.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 2-5/8 squares.
Mova 1/2 square.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o little-k glyph:
Save o context.
Stroke 3-1/4 squares.
Vire around.
Mova 1-2/4 squares.
Vire left 1/8.
Stroke 1-3/4 squares slantways.
Reset o context.
Mova 1-2/4 squares.
Vire right 14/96.
Stroke 9/4 square.
Restore o context.

Etapas necessárias para que se stroke o little-l glyph:
Save o context.
Vire right.
Stroke 2 squares.
Vire around.
Mova 1 square.
Vire right.
Stroke 3-1/2 squares.
Vire left.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o little-m glyph:
Save o context.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right 3/8.
Stroke 2 squares.
Vire around.
Mova 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 3/8.
Stroke 3 squares.
Restore o context.

Etapas necessárias para que se stroke o little-n glyph:
Save o context.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o little-n-tilde glyph:
Save o context.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 2 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right. Mova 1/6 square. Vire left.
Vire right 1/8.
Stroke 9/16 square.
Vire right 3/16.
Stroke 1 square.
Vire left 3/16.
Stroke 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-o glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o little-o-acute glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/16 squares.
Vire right.
Mova 1-10/16 square.
Vire left.
Vire right 4/32.
Stroke 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-o-circumflex glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/16 squares.
Vire right. Mova 2/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-o-diaeresis glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/3 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-o-grave glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/8 squares.
Vire right.
Mova 1/100 square.
Vire right 4/32.
Stroke 1 square menos 2/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-o-tilde glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/8 squares.
Vire right 1/8.
Mova 1/2 square.
Stroke 9/16 square.
Vire right 3/16.
Stroke 1 square.
Vire left 3/16.
Stroke 5/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-p glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 4 squares.
Vire around.
Mova 3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o little-q glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire left 3/8.
Mova 1 square.
Vire around.
Stroke 4 squares.
Restore o context.

Etapas necessárias para que se stroke o little-r glyph:
Save o context.
Stroke 3 squares.
Vire around.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o little-s glyph:
Save o context.
Mova 1 square.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Reset o context.
Mova 2 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Reset o context.
Mova 2 squares.
Vire right 31/96.
Stroke 9/4 squares.
Restore o context.

Etapas necessárias para que se stroke o little-t glyph:
Save o context.
Vire right.
Mova 1 square.
Vire right 1/8.
Stroke 1/2 square slantways.
Vire left 2/8.
Stroke 1/2 square slantways.
Reset o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 3-1/2 squares.
Vire around.
Mova 1 square.
Vire right.
Mova 2/3 square.
Vire around.
Stroke 1-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o little-u glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Stroke 3 squares.
Restore o context.

Etapas necessárias para que se stroke o little-u-acute glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Stroke 3 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-5/16 squares.
Vire right.
Mova 1-1/16 square.
Vire left.
Vire right 4/32.
Stroke 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-u-circumflex glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Stroke 3 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right. Mova 3/8 square.
Vire left 3/32.
Stroke 7/8 square.
Vire right 6/32.
Stroke 7/8 square.
\end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-u-diaeresis glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Stroke 3 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-1/2 squares.
Vire right.
Mova 1/3 square.
Stroke 1/8 square.
Mova 1 square.
Stroke 1/8 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-u-grave glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Mova 2 squares.
Vire around.
Stroke 3 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-6/8 squares.
Vire right.
Mova 59/100 square.
Vire right 4/32.
Stroke 1 square menos 1/4 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-v glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o little-w glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 3 squares.
Vire around.
Vire right 7/96.
Stroke 9/4 squares.
Vire right 34/96.
Stroke 9/4 squares.
Vire left 41/96.
Stroke 3 squares.
Restore o context.

Etapas necessárias para que se stroke o little-x glyph:
Save o context.
Stroke 1 square.
Vire right 17/96.
Stroke 9/4 square.
Vire left 17/96.
Stroke 1 square.
Reset o context.
Vire right.
Mova 2 squares.
Vire left.
Stroke 1 square.
Vire left 17/96.
Stroke 9/4 square.
Vire right 17/96.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o little-y glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 1-1/2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Mova 1-1/2 squares.
Vire around.
Stroke 3 squares.
Vire right 1/8.
Stroke 1 squares slantways.
Vire right.
Stroke 1 squares.
Restore o context.

Etapas necessárias para que se stroke o little-y-acute glyph:
Save o context.
Mova 3 squares.
Vire around.
Stroke 1-1/2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Mova 1-1/2 squares.
Vire around.
Stroke 3 squares.
Vire right 1/8.
Stroke 1 squares slantways.
Vire right.
Stroke 1 squares.
\ start accent mark
Restore o context. Save o context.
Mova 3-4/16 squares.
Vire right.
Mova 1-1/16 square.
Vire left.
Vire right 4/32.
Stroke 2/3 square.
\ end accent mark
Restore o context.

Etapas necessárias para que se stroke o little-z glyph:
Save o context.
Mova 3 squares.
Vire right.
Stroke 2 squares.
Vire right.
Stroke 1 square.
Vire right 17/96.
Stroke 9/4 square.
Vire left 17/96.
Stroke 1 square.
Vire left.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o minus-sign glyph:
Save o context.
Mova 2 squares.
Vire right.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o nine glyph:
Save o context.
Mova 1 square.
Vire right 3/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1-5/8 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o número-sign glyph:
Save o context.
Mova 3 squares.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 1 square.
Vire right.
Stroke 2 squares.
Reset o context.
Vire right.
Mova 1/2 square.
Vire left.
Stroke 4 squares.
Reset o context.
Vire right.
Mova 1-1/2 squares.
Vire left.
Stroke 4 squares.
Restore o context.

Etapas necessárias para que se stroke o one glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 3-2/8 squares.
Reset o context.
Vire right.
Stroke 2 squares.
Reset o context.
Mova 3 squares menos 5/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o percent-sign glyph:
Save o context.
Vire right 7/96.
Stroke 9/2 squares.
Reset o context.
Mova 2-1/2 squares.
Stroke 1/2 square.
Reset o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 1 square.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o period glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o plus-sign glyph:
Save o context.
Mova 2 squares.
Vire right.
Stroke 2 squares.
Vire left.
Mova 1 square.
Vire left.
Mova 1 square.
Vire left.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o question-mark glyph:
Save o context.
Mova 3 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1 square.
Mova 1 square.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o right-alligator glyph:
Save o context.
Mova 1 square.
Vire right 17/96 of o way.
Stroke 9/4 square.
Vire left 34/96 of o way.
Stroke 9/4 square.
Restore o context.

Etapas necessárias para que se stroke o right-brace glyph:
Save o context.
Vire right.
Stroke 1 square.
Vire left.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1 square.
Vire left.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o right-bracket glyph:
Save o context.
Vire right.
Stroke 1 square.
Vire left.
Stroke 4 squares.
Vire left.
Stroke 1 square.
Restore o context.

Etapas necessárias para que se stroke o right-paren glyph:
Save o context.
Vire right.
Mova 1/2 square.
Vire left.
Vire right 1/8.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 2 squares.
Vire left 1/8.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o semi-colon glyph:
Save o context.
Vire around.
Mova 1 square.
Vire left 3/8.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1/2 square.
Mova 1/2 square.
Mova 1 square.
Stroke 1/2 square.
Restore o context.

Etapas necessárias para que se stroke o seven glyph:
Save o context.
Mova 2-4/8 squares.
Stroke 1 square.
Vire right.
Stroke 2 squares.
Vire right.
Stroke 1 square.
Vire right 1/8.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1-4/8 squares.
Restore o context.

Etapas necessárias para que se stroke o single-quote glyph:
Save o context.
Vire right.
Mova 1 square.
Vire left.
Mova 2-1/2 squares.
Stroke 1-1/2 squares.
Restore o context.

Etapas necessárias para que se stroke o six glyph:
Save o context.
Vire right.
Mova 2 squares.
Vire left.
Mova 2-6/8 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left 1/8.
Stroke 1-6/8 squares.
Vire left 1/8.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Vire left.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o slash glyph:
Save o context.
Vire right 7/96 of o way.
Stroke 9/2 square.
Restore o context.

Etapas necessárias para que se stroke alguns squares:
Stroke o square size times o squares dividido por 1 square. \ squares são scaled up por precision hence o division at o end

Etapas necessárias para que se stroke alguns squares diagonally;
Etapas necessárias para que se stroke alguns squares slantways:
Stroke o square size times o squares times o raiz de dois dividido por 1 square. \ squares são scaled up por precision hence o division at o end

Etapas necessárias para que se stroke o three glyph:
Save o context.
Mova 2-2/4 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right.
Stroke 75/100 square slantways.
Vire left.
Stroke 75/100 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Restore o context.

Etapas necessárias para que se stroke o tilde glyph:
Save o context.
Mova 2 squares.
Vire right 7/96 of o way.
Stroke 9/8 square.
Vire right.
Stroke 9/6 square.
Vire left.
Stroke 9/8 square.
Restore o context.

Etapas necessárias para que se stroke alguns twips:
Draw um line o twips long.

Etapas necessárias para que se stroke o two glyph:
Save o context.
Mova 2-4/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right.
Stroke 1 square slantways.
Vire right.
Stroke 2 squares slantways.
Vire left 1/8.
Stroke 4/8 square.
Vire left.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o underscore glyph:
Save o context.
Vire around.
Mova 1 square.
Vire left.
Stroke 2 squares.
Restore o context.

Etapas necessárias para que se stroke o vertical-bar glyph:
Save o context.
Vire right.
Mova 1 square.
Vire right.
Mova 1 square.
Vire around.
Stroke 5 squares.
Restore o context.

Etapas necessárias para que se stroke o zero glyph:
Save o context.
Mova 1 square.
Stroke 1-3/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Stroke 1-3/8 squares.
Vire right 1/8.
Stroke 1 square slantways.
Vire right 1/4.
Stroke 1 square slantways.
Vire right 1/8.
Mova 70/100 square.
Vire right.
Mova 1 square.
Stroke 1 pixel.
Restore o context.

Um subject é um string.

O substitute pedaço é um pedaço igual a 26.

\Um substring é um string.
Um subtexto é um string.

Etapas necessárias para que se subtraia um pedaço from uma segunda pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda byte
Intel $2803. \ sub [ebx],al

Etapas necessárias para que se subtraia um pedaço from um número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o número
Intel $2903. \ sub [ebx],eax

Etapas necessárias para que se subtraia uma fração from uma segunda fração:
Isole a fração.
Normalize a fração e a segunda fração.
Subtraia o numerador desta fração from o numerador desta segunda fração.
Reduce a segunda fração.

Etapas necessárias para que se subtraia um número e uma segunda número from um pair:
Subtraia o número from o x deste pair.
Subtraia o segunda número from o y deste pair.

Etapas necessárias para que se subtraia um número from um pedaço:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o byte
Intel $0FB60B. \ movzx ecx,[ebx]
Intel $2BC8. \ sub ecx,eax
Intel $880B. \ mov [ebx],cl

Etapas necessárias para que se subtraia um número from um fração:
Subtraia o número / 1 from a fração.

Etapas necessárias para que se subtraia um número from um pair:
Subtraia o número from o número x deste pair.
Subtraia o número from o número y deste pair.

Etapas necessárias para que se subtraia um pair from uma segunda pair:
Subtraia o número x deste pair from o número x deste segunda pair.
Subtraia o número y deste pair from o número y deste segunda pair.

Etapas necessárias para que se subtraia um endereço de memória from uma segunda endereço de memória;
Etapas necessárias para que se subtraia um número from um endereço de memória;
Etapas necessárias para que se subtraia um número from uma segunda número:
Intel $8B8508000000. \ mov eax,[ebp+8] \ o número
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o segunda número
Intel $2903. \ sub [ebx],eax

O superscript-one pedaço é um pedaço igual a 185.

O superscript-número três é um pedaço igual a 179.

O superscript-número dois é um pedaço igual a 178.

Etapas necessárias para que se swap uma cor with uma segunda cor:
Swap a matiz desta cor with a matiz desta segunda cor.
Swap a saturação desta cor with a saturação desta segunda cor.
Swap a luminosidade desta cor with a luminosidade desta segunda cor.

Etapas necessárias para que se swap um pair with uma segunda pair:
Swap o número x deste pair with o número x deste segunda pair.
Swap o número y deste pair with o número y deste segunda pair.

Etapas necessárias para que se swap um endereço de memória with uma segunda endereço de memória;
Etapas necessárias para que se swap um número with uma segunda número:
Atribua o número A um terceiro número.
Atribua o segunda número ao número.
Atribua o terceiro número ao segunda número.

Etapas necessárias para que se swap alguns coisas with alguns segunda coisas:
Swap o first destas coisas with o first destas segunda coisas.
Swap o last destas coisas with o last destas segunda coisas.

O synchronous-idle pedaço é um pedaço igual a 22.

Um systemtime é um conjunto with
Um wyrd called wyear,
Um wyrd called wmonth,
Um wyrd called wdayofweek,
Um wyrd called wday,
Um wyrd called whour,
Um wyrd called wminute,
Um wyrd called wsecond,
Um wyrd called wmilliseconds.

O tecla T/t é uma tecla igual a 84.

O tabulação horizontal é um pedaço igual a 9.

O tecla aba é uma tecla igual a 9.

Etapas necessárias para que se take off all o masking tape: unmask everything.

Etapas necessárias para que se take off any masking tape: unmask everything.

Um talker é um endereço de memória para um talker object.

O talker é um talker.

Um talker object é um conjunto with um talker vtable called vtable.

Um talker vtable é um endereço de memória para um talker vtable conjunto.

Um talker vtable conjunto é um conjunto with
\ iunknown
Um endereço de memória called queryinterface,
Um endereço de memória called addref,
Um endereço de memória called release, \ em this:pspvoice out número
\ italker
Um endereço de memória called setnotifysink,
Um endereço de memória called setnotifywindowmessage,
Um endereço de memória called setnotifycallbackfunction,
Um endereço de memória called setnotifycallbackinterface,
Um endereço de memória called setnotifywin32event,
Um endereço de memória called waitfornotifyevent,
Um endereço de memória called getnotifyevendu quedle,
Um endereço de memória called setinterest,
Um endereço de memória called getevents,
Um endereço de memória called getinfo,
Um endereço de memória called setoutput,
Um endereço de memória called getoutputobjecttoken,
Um endereço de memória called getoutputstream,
Um endereço de memória called pause,
Um endereço de memória called resume,
Um endereço de memória called setvoice,
Um endereço de memória called getvoice,
Um endereço de memória called speak, \ em this:pspvoice; pwcs:pwchar; dwflags:number; pulstreamnumber:pnumber out número
Um endereço de memória called speakstream,
Um endereço de memória called getstatus,
Um endereço de memória called skip,
Um endereço de memória called setpriority,
Um endereço de memória called getpriority,
Um endereço de memória called setalertboundary,
Um endereço de memória called getalertboundary,
Um endereço de memória called setrate,
Um endereço de memória called getrate,
Um endereço de memória called setvolume,
Um endereço de memória called getvolume,
Um endereço de memória called waituntildone,
Um endereço de memória called setsyncspeaktimeout,
Um endereço de memória called getsyncspeaktimeout,
Um endereço de memória called speakcompleteevent,
Um endereço de memória called isuisupported,
Um endereço de memória called displayui.

O tan cor é uma cor.

O tan pincel é um pincel.

O teal cor é uma cor.

O teal pincel é um pincel.

O temp endereço completo é um endereço completo.

O terminal é um terminal.

Um terminal é uma coisa with um caixa, alguns quoras, um output cor, um input cor, e um reply string.

O text cutoff é um número igual a 500.

An text é uma coisa with 
Um caixa,
Um origin,
Um pincel cor,
Um font,
Um alinhamento,
Some rows,
Um margin,
Um scale fração,
Um wrap alarme,
Um horizontal scroll alarme,
Um vertical scroll alarme,
Um selection,
Um alarme de alteração,
Um last operation,
Some texts called undos,
Some texts called redos.

Um textmetric é um conjunto with
Um número called tmheight,
Um número called tmascent,
Um número called tmdescent,
Um número called tminternalleading,
Um número called tmexternalleading,
Um número called tmavecharwidth,
Um número called tmmaxcharwidth,
Um número called tmweight,
Um número called tmoverhang,
Um número called tmdigitizedaspectx,
Um número called tmdigitizedaspecty,
Um pedaço called tmfirstchar,
Um pedaço called tmlastchar,
Um pedaço called tmdefaultchar,
Um pedaço called tmbreakchar,
Um pedaço called tmitalic,
Um pedaço called tmunderlined,
Um pedaço called tmstruckout,
Um pedaço called tmpitchandfamily,
Um pedaço called tmcharset.

Um coisa é um endereço de memória para uma coisa conjunto.

Um coisa conjunto has um next coisa e um previous coisa.

Some coisas has um first coisa e um last coisa.

An thousand é 10 hundreds.

O número três é um pedaço igual a 51.

O tecla três é uma tecla igual a 51.

O símbolo três quartos [¾] é um pedaço igual a 190.
O fração de três quartos [¾] é um pedaço igual a 190.

An tick é um número.

O acento til é um pedaço igual a 126.

Um cronômetro has um contagem, alguns start ticks e alguns total ticks.

Some times é um número. \ this é um fluke, I think -- see "smooth um polygon alguns times"

Um token é um string.

Um topo é alguns twips.

O tpi é alguns twips igual a 1440.

O tpp é alguns twips.

O trade-mark pedaço é um pedaço igual a 153.

Etapas necessárias para que se trim um string:
Remove any leading noise from o string.
Remove any trailing noise from o string.

Etapas necessárias para que se dê meia volta:
Etapas necessárias para que se vire around:
Vire right 1/2.

Etapas necessárias para que se vire uma fração igual para um número over uma segunda número:
Atribua o número ao topo desta fração.
Atribua o segunda número à base desta fração.
Vire a fração.

\Etapas necessárias para que se vire uma fração do caminho;
Etapas necessárias para que se vire uma fração of o way;
Etapas necessárias para que se vire uma fração of o way around;
Etapas necessárias para que se vire uma fração:
Se a fração for 1/1, cancele.
Atribua 3840 times a fração mais o heading deste context ao heading deste context.
Normalize o heading deste context.

Etapas necessárias para que se vire pra left;
Etapas necessárias para que se vire para a left;
\Etapas necessárias para que se vire à left;
Etapas necessárias para que se vire left:
Vire -1/4.

\Etapas necessárias para que se vire à left uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire pra left uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire para a left uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire left uma fração igual para um número over uma segunda número:
Atribua o número ao topo desta fração.
Atribua o segunda número à base desta fração.
Vire left a fração.

\Etapas necessárias para que se vire uma fração à left do caminho;
\Etapas necessárias para que se vire uma fração pra left do caminho;
Etapas necessárias para que se vire uma fração para a left do caminho;
Etapas necessárias para que se vire left uma fração of o way;
Etapas necessárias para que se vire left uma fração of o way around;
Etapas necessárias para que se vire left um fração:
Isole a fração.
Negate a fração.
Vire a fração.

\Etapas necessárias para que se vire à left alguns points;
Etapas necessárias para que se vire pra left alguns points;
Etapas necessárias para que se vire para a left alguns points;
Etapas necessárias para que se vire left alguns points:
Atribua o points e 3840 A um fração.
Vire left a fração.

\Etapas necessárias para que se vire à right;
Etapas necessárias para que se vire pra right;
Etapas necessárias para que se vire para a right;
Etapas necessárias para que se vire right:
Vire 1/4.

\Etapas necessárias para que se vire alguns degrees à right;
\Etapas necessárias para que se vire alguns degrees pra right;
Etapas necessárias para que se vire alguns degrees para a right;
Etapas necessárias para que se vire right alguns degrees:
Atribua o degrees times 10 e 3600 A um fração.
Vire right a fração.

Etapas necessárias para que se vire alguns degrees:
Atribua o degrees times 10 e 3600 A um fração.
\Se o degrees forem negative, vire left o fração; exit.
Vire right a fração.

\Etapas necessárias para que se vire à right uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire pra right uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire para a right uma fração igual para um número over uma segunda número;
Etapas necessárias para que se vire right uma fração igual para um número over uma segunda número:
Atribua o número ao topo desta fração.
Atribua o segunda número à base desta fração.
Vire right a fração.

\Etapas necessárias para que se vire à right uma fração of o way;
Etapas necessárias para que se vire pra right uma fração of o way;
Etapas necessárias para que se vire para a right uma fração of o way;
Etapas necessárias para que se vire right uma fração of o way;
Etapas necessárias para que se vire right uma fração of o way around;
Etapas necessárias para que se vire right um fração:
Vire a fração.

Etapas necessárias para que se vire right uma fração of o way alguns percent of o time;
Etapas necessárias para que se vire right uma fração about alguns percent of o time;
Etapas necessárias para que se vire right uma fração of o way about alguns percent of o time;
Etapas necessárias para que se vire right uma fração alguns percent of o time:
Escolha aleatoriamente um número between 1 e 100.
Se o número for maior do que o percent, cancele.
Vire right a fração.

\Etapas necessárias para que se vire alguns points à right;
\Etapas necessárias para que se vire alguns points pra right;
Etapas necessárias para que se vire alguns points para a right;
Etapas necessárias para que se vire right alguns points:
Atribua o points e 3840 A um fração.
Vire right a fração.

An twip é um número.

O número dois é um pedaço igual a 50.

O tecla dois é uma tecla igual a 50.

O tecla U/u é uma tecla igual a 85.

Etapas necessárias para que se unassign um endereço de memória:
Se o endereço de memória for inexistente, cancele.
Call "kernel32.dll" "HeapFree" with o heap endereço de memória e 0 [no options] e o endereço de memória returning um número.
Se o número for 0, cancele.
Esvazie o endereço de memória.
Subtraia 1 from o heap contagem.

O underscore pedaço é um pedaço igual a 95.

An unit é um número.

O unit-separator pedaço é um pedaço igual a 31.

Etapas necessárias para que se unlock um gpbitmap usando um bitmapdata:
Call "gdiplus.dll" "GdipBitmapUnlockBits" with o gpbitmap e o whereabouts deste bitmapdata.

Etapas necessárias para que se unmask everything:
Call "gdi32.dll" "SelectClipRgn" with o quadro atual e 0.

Etapas necessárias para que se unmask inside um caixa:
Crie um hrgn usando o caixa.
Unmask inside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se unmask inside um elipse:
Crie um hrgn usando o elipse.
Unmask inside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se unmask inside um hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" with o quadro atual e o hrgn e 2 [rgn_or].

Etapas necessárias para que se unmask inside um polygon:
Crie um hrgn usando o polygon.
Unmask inside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se unmask inside um caixa arredondada:
Crie um hrgn usando o caixa arredondada.
Unmask inside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se unmask outside um caixa:
Crie um hrgn usando o caixa.
Unmask outside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se unmask outside um elipse:
Crie um hrgn usando o elipse.
Unmask outside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se unmask outside um hrgn:
Crie um old hrgn usando o zero caixa.
Call "gdi32.dll" "GetClipRgn" with o quadro atual e o old hrgn returning um número.
Se o número não for 1, limpe o old hrgn.
Call "gdi32.dll" "SelectClipRgn" with o quadro atual e 0.
Call "gdi32.dll" "ExtSelectClipRgn" with o quadro atual e o hrgn e 4 [rgn_diff].
Call "gdi32.dll" "ExtSelectClipRgn" with o quadro atual e o old hrgn e 2 [rgn_or].
Destroy o old hrgn.

Etapas necessárias para que se unmask outside um polygon:
Crie um hrgn usando o polygon.
Unmask outside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se unmask outside um caixa arredondada:
Crie um hrgn usando o caixa arredondada.
Unmask outside o hrgn.
Destroy o hrgn.

Etapas necessárias para que se unquote um string:
Lance um subtexto sobre o string.
Se o subtexto estiver em branco, pare.
Se o target deste first deste subtexto não for as aspas duplas, cancele.
Adicione 1 para o first deste subtexto.
Percorra.
Se o subtexto estiver em branco, pare.
Se o first deste subtexto é o last deste subtexto, pare.
Posponha o target deste first deste subtexto para uma segunda string.
Se o target deste first deste subtexto for as aspas duplas, adicione 1 para o first deste subtexto.
Adicione 1 para o first deste subtexto.
Repita.
Atribua o segunda string ao string.

O seta pra cima é uma tecla igual a 38.

Etapas necessárias para que se update o tela;
Etapas necessárias para que se mostre it;
Etapas necessárias para que se mostre it all;
Etapas necessárias para que se mostre reveal o canvas;
Etapas necessárias para que se atualize o tela:
Atualize o tela usando a caixa desta tela.

Etapas necessárias para que se uppercase any selecionado pedaços em um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, cancele.
Se a row of o text não estiver selecionado, repita.
Lance um subtexto sobre any selecionado pedaços na row of o text.
Uppercase o subtexto.
Repita.

Etapas necessárias para que se uppercase um pedaço:
Translate o pedaço using o uppercase ascii table.

Etapas necessárias para que se translate um pedaço using um translation texto hexadecimal:
Intel $8B8D08000000. \ mov ecx,[ebp+8] \ o endereço de memória do pedaço 
Intel $8B01. \ mov eax,[ecx] \ o byte
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ o tabela de tradução
Intel $8B1B. \ mov ebx,[ebx] o first da tabela de tradução
Intel $D7. \ xlat al,[ebx]
Intel $8901. \ mov [ecx],eax

Etapas necessárias para que se uppercase o character under um finger e atribua it Into um string:
Se o finger for inexistente, cancele.
Atribua o target deste finger ao string.
Uppercase o string.

Etapas necessárias para que se uppercase um string:
Lance um subtexto sobre o string.
Percorra.
Se o subtexto estiver em branco, cancele.
Uppercase o target deste first deste subtexto.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se uppercase um text:
Se o text for inexistente, cancele.
Percorra.
Obtenha um row from as rows deste text.
Se a row for inexistente, pare.
Uppercase o string deste row.
Repita.
Wrap o text.

O upperscore pedaço é um pedaço igual a 175.

An url é um string.

Um url conjunto has
Um scheme string,
Um host name string,
Um endereço completo string,
Um extra string,
Um port número.

Um urlcomponents é um conjunto with
Um número called dwstructsize,
Um pchar called lpszscheme,
Um número called dwschemelength,
Um número called nscheme,
Um pchar called lpszhostname,
Um número called dwhostnamelength,
Um número called nport, \ this é typed como um wyrd em windows documentoation, but does not work
Um pchar called lpszusername,
Um número called dwusernamelength,
Um pchar called lpszpassword,
Um número called dwpasswordlength,
Um pchar called lpszurlpath,
Um número called dwurlpathlength,
Um pchar called lpszextrainfo,
Um número called dwextrainfolength.

Etapas necessárias para que se use uma cor:
Atribua a cor à cor deste context.

Etapas necessárias para que se use o pincel grosso:
Atribua 3 ao pincel size.

Etapas necessárias para que se use um tamanho da letra:
Atribua o tamanho da letra à tamanho da letra deste context.

Etapas necessárias para que se use um tamanho da letra of alguns twips:
Atribua o twips ao tamanho da letra.
Atribua o twips à tamanho da letra deste context.

Etapas necessárias para que se use um pincel:
Atribua o pincel ao pincel deste context.

Etapas necessárias para que se use o skinny pincel:
Atribua 1 ao pincel size.

Etapas necessárias para que se use small pointy letras:
\ como opposed para "roundy letras" not yet implemented
Use small letras.

Um uuid é um conjunto with
Um número called d1,
Um wyrd called d2,
Um wyrd called d3,
8 pedaços called d4.

O tecla V/v é uma tecla igual a 86.

Um vértice array é um endereço de memória para um vértice array conjunto.

Um vértice array conjunto has um contagem e um spot endereço de memória.

Um vértice é uma coisa with um coordenada x, um coordenada y, um spot at o coordenada x.

O vertical-bar pedaço é um pedaço igual a 124.

O vertical-tabulação horizontal é um pedaço igual a 11.

Um very cor escura é uma cor.

Um very light cor é uma cor.

Um very very cor escura é uma cor.

Um very very light cor é uma cor.

O violet cor é uma cor.

O violet pincel é um pincel.

O tecla W/w é uma tecla igual a 87.

Um w-param é um número.


Etapas necessárias para que se aguarde por um event;
Etapas necessárias para que se deque um event:
Yield para windows.
Atribua o first desta event queue ao event.
Se o event for inexistente, repita.
Remove o event from o event queue.
Se a categoria deste event for "fechamento do programa", destroy o event; exit.
Destroy o evento atual.
Atribua o event ao evento atual.


Etapas necessárias para que se aguarde por alguns grains of sand;
Etapas necessárias para que se aguarde por alguns grains of sand para fall;
Etapas necessárias para que se aguarde por alguns grains of sand para fall no hourglass;
Etapas necessárias para que se aguarde alguns milliseconds;
Etapas necessárias para que se aguarde por alguns milliseconds:
Se o milliseconds forem menor do que ou igual para 0, cancele.
Call "kernel32.dll" "Sleep" with o milliseconds.

Etapas necessárias para que se aguarde por uma tecla para come back up:
Se a tecla estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde por uma tecla para come up:
Se a tecla estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde por uma tecla para go down:
Se a tecla não estiver sendo pressionada, repita.

Etapas necessárias para que se aguarde sobre that there tecla with o ESC sobre it:
Aguarde pela tecla Esc.

Etapas necessárias para que se aguarde until speaking é done:
Se o talker for inexistente, cancele.
Call o waituntildone desta vtable deste talker with o talker e -1.

Etapas necessárias para que se aguarde until we hit um tecla;
Etapas necessárias para que se aguarde por um tecla:
Etapas necessárias para que se aguarde uma tecla:
Aguarde pela tecla para go down.
Aguarde pela tecla para come up.
Desmanche all events.

Um wave file é um endereço completo.

Um wave é um texto hexadecimal.

O cor branca é uma cor.

O white pincel é um pincel.

Um wide string é um string.

Um width é alguns twips.

Um win32finddata é um conjunto with
Um número called dwfileattributes,
Um filetime called ftcreationtime,
Um filetime called ftlastaccesstime,
Um filetime called ftlastwritetime,
Um número called nfilesizehigh,
Um número called nfilesizelow,
Um número called dwreserved0,
Um número called dwreserved1,
260 pedaços called cfilename,
14 pedaços called calternatefilename.

Um window class é um conjunto with
Um número called cbsize,
Um número called style,
Um endereço de memória called lpfnwndproc,
Um número called cbclsextra,
Um número called cbwndextra,
Um handle called hinstance,
Um hicon called hicon,
Um cursor called hcursor,
Um hbrush called hbrbackground,
Um endereço de memória called lpszmenuname,
Um endereço de memória called lpszclassname,
Um hicon called hiconsm.

O window class é um window class.

Um window é um handle.

Um winhttp request é uma coisa with
Um session handle,
Um connection handle,
Um request handle.

Um palavra é um subtexto.

Etapas necessárias para que se wrap um text:
Se o text for inexistente, cancele.
Se o wrap alarme deste text não estiver ativo, cancele.
Convert o anchor deste text para um posicionamento absoluto usando o text.
Convert o caret deste text para uma segunda posicionamento absoluto usando o text.
Atribua a scale deste text A um fração.
Redimensione proporcionalmente o text para 1/1.
Extract um string from o text.
Posponha o return pedaço para o string.
Destroy as rows deste text.
Lance um percorredor sobre o string.
Crie o hfont of o memory canvas usando o font deste text.
Percorra.
Mova o percorredor usando a caixa deste text (word wrapping rules).
Se o token deste percorredor estiver em branco, pare.
Crie um row usando o token deste percorredor.
Posponha a row para as rows deste text.
Repita.
Destroy o hfont of o memory canvas.
Renumber as rows deste text.
Redimensione proporcionalmente o text para a fração.
Convert o posicionamento absoluto para o anchor deste text usando o text.
Convert o segunda posicionamento absoluto para o caret deste text usando o text.
Limite o origin of o text.

Etapas necessárias para que se store um trecho em um file;
Etapas necessárias para que se escreva um trecho para um file:
Limpe o i/o erro.
Call "kernel32.dll" "SetFilePointer" with o file e 0 e 0 e 0 [file_begin] returning um result número.
Se o result número é -1, atribua "Ocorreu um erro durante o posicionamento do ponteiro do arquivo." ao i/o erro; exit.
Call "kernel32.dll" "WriteFile" with o file e o first deste trecho e o length deste trecho e um número's whereabouts e 0 returning o result número.
Se o result número for 0, atribua "Ocorreu um erro durante a gravação do arquivo." ao i/o erro; exit.

Etapas necessárias para que se store um trecho em um endereço completo;
Etapas necessárias para que se escreva um trecho para um endereço completo:
Limpe o i/o erro.
Extract um endereço da pasta from o endereço completo.
Se o endereço da pasta não estiver no sistema de arquivos, atribua "A pasta: " then o endereço da pasta then " não existe." ao i/o erro; exit.
Defina o endereço completo para read-write mode.
Isole o endereço completo.
Null terminate o endereço completo.
Call "kernel32.dll" "CreateFileA" with o first deste endereço completo e 1073741824 [generic_write] 
And 0 e 0 e 2 [create_always] e -2147483520 [file_flag_write_through ou file_attribute_normal] e 0 returning um handle.
Se o handle é -1 [invalid_handle_value], atribua "Ocorreu um erro ao tentar abrir o arquivo: " then o endereço completo then "." ao i/o erro; exit.
Call "kernel32.dll" "WriteFile" with o handle e o first deste trecho e o length deste trecho e um número's whereabouts e 0 returning o número.
Call "kernel32.dll" "CloseHandle" with o handle.
Se o número não for 0, cancele.
Atribua "Ocorreu um erro ao tentar salvar o arquivo: " then o endereço completo then "." ao i/o erro.

Etapas necessárias para que se escreva um pedaço:
Atribua o pedaço A um string.
Escreva o string.

Etapas necessárias para que se escreva um pedaço para stdout:
Call "kernel32.dll" "WriteFile" with o stdout handle e o whereabouts deste pedaço e 1 e um número's whereabouts e nil.

Etapas necessárias para que se escreva um pedaço sem advancing:
Atribua o pedaço A um string.
Escreva o string sem advancing.

 \ will translate para English because "Convert um alarme" é used para externalize reams pelo caderno
Etapas necessárias para que se escreva um alarme:
Convert o alarme para um string.
Escreva o string.

Etapas necessárias para que se escreva um alarme sem advancing:
Convert o alarme para um string.
Escreva o string sem advancing.

Etapas necessárias para que se escreva um fração:
Convert a fração para um string.
Escreva o string.

Etapas necessárias para que se escreva uma fração sem advancing:
Convert a fração para um string.
Escreva o string sem advancing.

Etapas necessárias para que se escreva um número:
Convert o número para um string.
Escreva o string.

Etapas necessárias para que se escreva um número sem advancing:
Convert o número para um string.
Escreva o string sem advancing.

Etapas necessárias para que se escreva um número sobre um console:
Convert o número para um string.
Escreva o string sobre o console.

Etapas necessárias para que se escreva alguns quoras em um caixa:
\Draw o caixa with o cor vermelha e o clear cor. \ temp ***
Atribua o caixa A um quora caixa.
Atribua o topo desta quora caixa mais 1/4 inch à base desta quora caixa.
Percorra.
Obtenha um quora from o quoras.
Se o quora for inexistente, pare.
\draw really fast. ***
\ Draw o quora caixa with o cor amarela. \ temp ***
Escreva a string deste quora no quora caixa with a cor deste quora.
Mova o quora caixa down 1/4 inch.
Repita.

Etapas necessárias para que se escreva um string;
Etapas necessárias para que se stroke um string:
Isole o string.
Percorra.
Se o string estiver em branco, cancele.
Obtenha um pedaço from o string.
Stroke o pedaço.
Se o string não estiver em branco, space between glyphs.
Repita.

Etapas necessárias para que se escreva um string around um center spot at um radius;
Etapas necessárias para que se escreva um string usando um center spot e um radius;
Etapas necessárias para que se stroke um string around um center spot at um radius;
Etapas necessárias para que se stroke um string usando um center spot e um radius:
Isole o string.
Atribua 1 e o length deste string A um fração.
Percorra.
Se o string estiver em branco, cancele.
Obtenha um pedaço from o string.
Start at o center spot.
Mova o radius.
Stroke o pedaço.
Vire a fração.
Repita.

Etapas necessárias para que se escreva um string at um spot with um cor;
Etapas necessárias para que se stroke um string at um spot with um cor:
Start at o spot.
Atribua a cor à cor deste context.
Stroke o string.

Etapas necessárias para que se escreva um string sobre um console:
Se o console for inexistente, cancele.
Insira o string ao text deste console.
Insira o return pedaço ao text deste console.
Wrap o text deste console.
Role o text deste console para o caret.
Mostre o console.

Etapas necessárias para que se escreva um string para um console sem advancing;
Etapas necessárias para que se escreva um string sobre um console sem advancing:
Se o console for inexistente, cancele.
Insira o string ao text deste console.
Wrap o text deste console.
Role o text deste console para o caret.
Mostre o console.

Etapas necessárias para que se escreva um string em um caixa;
Etapas necessárias para que se stroke um string em um caixa:
Stroke o string no caixa with a cor deste context.

Etapas necessárias para que se escreva um string em um caixa with um cor;
Etapas necessárias para que se stroke um string em um caixa with um cor:
Atribua a cor à cor deste context.
Atribua o left-base desta caixa ao spot deste context.
Atribua a altura desta caixa dividido por 2 à tamanho da letra deste context.
\Atribua a altura desta caixa à tamanho da letra deste context.
Face north.
Mova a altura desta caixa dividido por 4. \ was 4 e still é now! ***
Stroke o string.

Etapas necessárias para que se escreva um string no middle of um caixa;
Etapas necessárias para que se stroke um string no middle of um caixa:
Atribua a tamanho da letra deste context dividido por 4 A um square size. \ was 4 ***
\ glyphs são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o length deste string times o square size times 3 menos o square size A um width.
Divida o width por 2.
Start no middle of o caixa.
Mova down a tamanho da letra deste context dividido por 2. \ was 2 ***
Mova left o width.
Face north.
Stroke o string.

Etapas necessárias para que se escreva um string no middle of o tela:
Stroke o string no middle of a caixa desta tela.
Atualize o tela.

Etapas necessárias para que se escreva um string sobre um terminal:
Se o terminal for inexistente, cancele.
Adicione um quora para o terminal.
Atribua o string à string deste quora.
Atribua a output cor deste terminal à cor deste quora.
Mostre o terminal.

Etapas necessárias para que se escreva um string um radius away from um center spot;
Etapas necessárias para que se escreva um string um radius around um center spot;
Etapas necessárias para que se escreva um string about um radius from um center spot;
Etapas necessárias para que se escreva um string um radius from um center spot;
Etapas necessárias para que se stroke um string um radius away from um center spot;
Etapas necessárias para que se stroke um string um radius around um center spot;
Etapas necessárias para que se stroke um string about um radius from um center spot;
Etapas necessárias para que se stroke um string um radius from um center spot:
Stroke o string usando o center spot e o radius.

Etapas necessárias para que se escreva um string um radius away from o middle of um caixa;
Etapas necessárias para que se escreva um string um radius around o middle of um caixa;
Etapas necessárias para que se escreva um string about um radius from o middle of um caixa;
Etapas necessárias para que se escreva um string um radius from o middle of um caixa;
Etapas necessárias para que se stroke um string um radius away from o middle of um caixa;
Etapas necessárias para que se stroke um string um radius around o middle of um caixa;
Etapas necessárias para que se stroke um string about um radius from o middle of um caixa;
Etapas necessárias para que se stroke um string um radius from o middle of um caixa:
Stroke o string usando o center desta caixa e o radius.

Etapas necessárias para que se escreva um string para stdout:
Call "kernel32.dll" "WriteFile" with o stdout handle e o first deste string e o length deste string e um número's whereabouts e nil.

Etapas necessárias para que se escreva um string while turning uma fração of o way;
Etapas necessárias para que se escreva um string while turning uma fração of o way around;
Etapas necessárias para que se escreva um string while turning um fração;
Etapas necessárias para que se stroke um string while turning uma fração of o way;
Etapas necessárias para que se stroke um string while turning uma fração of o way around;
Etapas necessárias para que se stroke um string while turning um fração:
Isole o string.
Percorra.
Se o string estiver em branco, cancele.
Obtenha um pedaço from o string.
Stroke o pedaço.
Vire a fração.
Se o string não estiver em branco, space between glyphs.
Repita.

Etapas necessárias para que se escreva um string with um cor;
Etapas necessárias para que se stroke um string with um cor:
Atribua a cor à cor deste context.
Stroke o string.

Etapas necessárias para que se escreva um string with uma cor at o base of um caixa;
Etapas necessárias para que se stroke um string with uma cor at o base of um caixa:
Atribua a tamanho da letra deste context dividido por 4 A um square size. \ ***
\ glyphs são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o length deste string times o square size times 3 menos o square size A um width.
Divida o width por 2.
Start no middle of o base of o caixa.
Mova up a tamanho da letra deste context times 2. \ was sem o times 2 ***
Mova left o width.
Face north.
Stroke o string with a cor.

Etapas necessárias para que se escreva um string with uma cor at o topo of um caixa;
Etapas necessárias para que se stroke um string with uma cor at o topo of um caixa:
Atribua a tamanho da letra deste context dividido por 4 A um square size. \ ***
\ glyphs são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o length deste string times o square size times 3 menos o square size A um width.
Divida o width por 2.
Start no middle of o topo of o caixa.
Mova down a tamanho da letra deste context times 4. \ was times 2 ***
Mova left o width.
Face north.
Stroke o string with a cor.

Etapas necessárias para que se escreva um string with uma cor no middle of um caixa;
Etapas necessárias para que se stroke um string with uma cor no middle of um caixa:
Atribua a tamanho da letra deste context dividido por 4 A um square size. \ was 4 ***
\ glyphs são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o length deste string times o square size times 3 menos o square size A um width.
Divida o width por 2.
Start no middle of o caixa.
Mova down a tamanho da letra deste context dividido por 2. \ was 2 ***
Mova left o width.
Face north.
Stroke o string with a cor.

Etapas necessárias para que se escreva um string with uma cor um radius away from um center spot;
Etapas necessárias para que se escreva um string with uma cor um radius around um center spot;
Etapas necessárias para que se escreva um string with uma cor about um radius from um center spot;
Etapas necessárias para que se escreva um string with uma cor um radius from um center spot;
Etapas necessárias para que se stroke um string with uma cor um radius away from um center spot;
Etapas necessárias para que se stroke um string with uma cor um radius around um center spot;
Etapas necessárias para que se stroke um string with uma cor about um radius from um center spot;
Etapas necessárias para que se stroke um string with uma cor um radius from um center spot:
Atribua a cor à cor deste context.
Stroke o string usando o center spot e o radius.

Etapas necessárias para que se escreva um string with uma cor alguns twips down from o topo of um caixa;
Etapas necessárias para que se escreva um string with uma cor alguns twips down from o topo center of um caixa;
Etapas necessárias para que se stroke um string with uma cor alguns twips down from o topo of um caixa;
Etapas necessárias para que se stroke um string with uma cor alguns twips down from o topo center of um caixa:
Atribua a tamanho da letra deste context dividido por 4 A um square size. \ was 4 ***
\ glyphs são two squares wide mais one square of intercharacter spacing. no spacing at o end.
Atribua o length deste string times o square size times 3 menos o square size A um width.
Divida o width por 2.
Start no middle of o topo of o caixa.
Mova down o twips.
Mova left o width.
Face north.
Stroke o string with a cor.

Etapas necessárias para que se escreva um string with uma font e um size e uma cor e um spot:
Atribua o size à altura desta font.
Atribua o width desta string A um width.
Atribua o spot e o spot A uma caixa.
Subtraia o width dividido por 2 from o left desta caixa.
Adicione o width dividido por 2 para o right desta caixa.
Subtraia o size dividido por 2 from o topo desta caixa.
Adicione o size dividido por 2 para a base desta caixa.
Draw o string no caixa with a cor e o font e "center".
Atualize o tela.

Etapas necessárias para que se escreva with large letras;
Etapas necessárias para que se use large size letras;
Etapas necessárias para que se use large-size letras;
Etapas necessárias para que se use large sized letras;
Etapas necessárias para que se use large-sized letras;
Etapas necessárias para que se use big letras;
Etapas necessárias para que se use big size letras;
Etapas necessárias para que se use big-size letras;
Etapas necessárias para que se use big sized letras;
Etapas necessárias para que se use big-sized letras;
Etapas necessárias para que se use large letras:
Atribua o large tamanho da letra à tamanho da letra deste context.

Etapas necessárias para que se use letras de tamanho médio;
Etapas necessárias para que se use letras médias;
Etapas necessárias para que se escreva with medium letras;
Etapas necessárias para que se use medium size letras;
Etapas necessárias para que se use medium-size letras;
Etapas necessárias para que se use medium sized letras;
Etapas necessárias para que se use medium-sized letras;
Etapas necessárias para que se use medium letras:
Atribua o medium tamanho da letra à tamanho da letra deste context.

Etapas necessárias para que se escreva with small letras;
Etapas necessárias para que se use small size letras;
Etapas necessárias para que se use small-size letras;
Etapas necessárias para que se use small sized letras;
Etapas necessárias para que se use small-sized letras;
Etapas necessárias para que se use small letras:
Atribua o small tamanho da letra à tamanho da letra deste context.

Um wsadata é um conjunto with
Um wyrd called wversion,
Um wyrd called whighversion,
257 pedaços called szdescription,
127 pedaços called szsystemstatus,
Um wyrd [unsigned] called imaxsockets,
Um wyrd [unsigned] called imaxudpdg,
Um endereço de memória called lpvendorinfo.

Um wyrd has um low pedaço e um high pedaço.

O tecla X/x é uma tecla igual a 88.

Um máscara de disjunção exclusiva é um mask.

O tecla Y/y é uma tecla igual a 89.

O cor amarela é uma cor.

O yellow pincel é um pincel.

O yen-sign pedaço é um pedaço igual a 165.

Etapas necessárias para que se yield para windows:
Se o event queue não for vazio, cancele.
Call "user32.dll" "GetMessageA" with um msg's whereabouts e 0 e 0 e 0 returning um número.
Se o número for 0, cancele.
Call "user32.dll" "TranslateMessage" with o whereabouts desta msg.
Call "user32.dll" "DispatchMessageA" with o whereabouts desta msg.

O tecla Z/z é uma tecla igual a 90.

Etapas necessárias para que se zero um caixa:
\ was clear um caixa, got confounded with "clear um caixa " (which deveria draw o caixa all black como does "clear o tela")
Atribua 0 ao left desta caixa.
Atribua 0 ao topo desta caixa.
Atribua 0 ao right desta caixa.
Atribua 0 à base desta caixa.

O zero caixa é uma caixa.

O número zero é um pedaço igual a 48.

Etapas necessárias para que se zero fill um número usando um contagem e posponha it para um string:
Convert o número para uma segunda string.
Zero fill o segunda string usando a contagem.
Posponha o segunda string para o string.

Etapas necessárias para que se zero fill um string usando um contagem:
Se o length deste string for maior do que ou igual ao contagem, cancele.
Anteponha o número zero para o string.
Repita.

O tecla zero é uma tecla igual a 48.

O zero line é um line. \ tracer

O zero spot é um spot.

Um tabela de tradução é um texto hexadecimal.

O ascii table é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF.

O lowercase accent-free ascii table é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F406162636465666768696A6B6C6D6E6F707172737475767778797A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788899A8B9C8D9E8F909192939495969798999A9B9C9D9E79A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF616161616161E6636565656569696969F06E6F6F6F6F6FD7F87575757579FEDF616161616161E6636565656569696969F06E6F6F6F6F6FF7F87575757579FE79.

O lowercase ascii table é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F406162636465666768696A6B6C6D6E6F707172737475767778797A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788899A8B9C8D9E8F909192939495969798999A9B9C9D9EFFA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6D7F8F9FAFBFCFDFEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF.

O uppercase ascii table é uma tabela de tradução igual a $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F604142434445464748494A4B4C4D4E4F505152535455565758595A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798998A9B8C9D8E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6F7D8D9DADBDCDDDE9F.

An inch é 1440 twips.

Um cm é 600 twips. \ O certo seia 567 / 566,9 cm
Um mm é 60 twips. \ creio que pela lógica seriam 56,7

\ Um twip seriam 1,76389 milímetros

O i/o erro é um string.