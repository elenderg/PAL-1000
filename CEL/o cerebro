\ O Cérebro - A Sociedade Osmosiana de Programadores de Linguagens Naturais - desde 2006.

\ Regras:
\ No geral, cada linha deve terminar com um ponto final.
\ As exceções são quando você está declarando uma variável do tipo conjunto, 
\ (cujas linhas podem terminar com uma vírgula, exceto no último item do conjunto)
\ Ou quando você estiver declarando um cabeçalho de rotina (que termina com sinal de dois pontos)
\ Quando um campo de texto é convertido para texto puro, 
\ o caractere especial LF é adicionado depois do caractere especial CR
\ Já quando um texto é transformado em um campo de texto, o caractere LF é removido.
\ Existe sempre uma linha, no mínimo.
\ Existe sempre um caractere CR no fim da ultima linha.
\Assim, linha de texto pode ser traduzido como linha.

\o verbo "criar" envolve alocação de memória
\o verbo fazer usa a memória já alocada

Uma URL é uma string.

Um intervalo é um número.
\Um intervalo inicial é um intervalo.
\Um intervalo total é um intervalo.

Uma caixa de texto é uma coisa com 
  Uma caixa,
  Uma origem,
  Uma cor do pincel,
  Uma fonte,
  Um alinhamento,
  Umas linhas des textos,
  Uma margem,
  Uma scale fração,
  Um detector de quebra de texto,
  Um detector de rolagem horizontal,
  Um detector de rolagem vertical,
  Uma seleção,
  Um detector de alteração,
  Uma última operação,
  Umas caixas des textos denominadas desfeitos,
  Umas caixas des textos denominadas refeitos.

Um campo de texto é uma coisa com
  Uma caixa,
  Uma origem,
  Uma cor do pincel,
  Uma fonte,
  Um alinhamento,
  Some linhas des textos,
  Uma margem,
  Uma scale fração,
  Um detector de quebra de texto,
  Um detector de rolagem horizontal,
  Um detector de rolagem vertical,
  Uma seleção,
  Um detector de alteração,
  Uma última operação,
  Some caixas des textos denominado desfeitos, \, desfeiteado manipulações anteriores
  Some caixas des textos denominado refeitos. \ manipulações posteriores

Os campos de textos são uns campos des textos. \preciso consertar esse plural bugado

Um número do texto é um número.

An stack entry é uma coisa com uma string.

A stack é umas stack entries.

Uma linha de texto é uma coisa com 
  Um número da linha e 
  Uma string.

Uma referência é uma coisa com 
  Uma string e 
  Um ponteiro (reference).

Um GpImageAttributes é um ponteiro.

Um evento é uma coisa com
  Uma categoria [atualização de tela, mostrar seta, pressionamento de tecla, clique, clique duplo, clique direito, clique direito duplo, deactivate, activate, done], \ 
  Um detector de tecla Shift, 
  Um detector de tecla Ctrl, 
  Um detector de tecla Alt, 
  Uma localização, 
  Uma tecla, 
  Um byte.

Uma díade é uma coisa com
  Um nome,
  Uma value string.

Um contexto é uma coisa com \Um contexto de dispositivo é uma estrutura que define um conjunto de objetos gráficos e seus atributos associados, 
  Uma localização,  \bem como os modos gráficos que afetam a saída.
  Uma caixa, 
  Uma orientação, 
  Um tamanho da letra, 
  Uma cor, um pincel sob a cor,
  Um número e
  Uma grossura do pincel.\ largura?
  \OBS: A "grossura do pincel" não estava originalmente nessa estrutura, mas deveria.
  

Um byte# é um número.

Um canvas é um hDC. \ hDC = handle to a device context

Um bucket# é um número.

Um bit é uma unidade.

Um percorredor é um conjunto com \ Não se esqueça de alterar as rotinas "avance um percorredor" e "recue um percorredor" se você alterar isso aqui
  Um subtexto original, \ usado para verificar a string original
  Um segmento final, \ último byte da string.
  Um segmento inicial. \ primeiro byte da string
  \ 

Um segmento inicial é um subtexto.
Um segmento final é um subtexto.

Uma string é um conjunto com 
  Um caractere inicial e 
  Um caractere final.

Um caractere inicial é um ponteiro para um byte.
Um caractere final é um ponteiro para um byte.
Um ponteiro do byte é um ponteiro para um byte.

Etapas para que se avance um percorredor até encontrar o próximo espaço;
Etapas para que se avance um percorredor até o próximo espaço:
  Avance o percorredor.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o caractere de espaço, recomece.
  \Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o caractere de espaço, recomece.

Etapas para que se recue um percorredor até o próximo espaço;
Etapas para que se recue um percorredor até encontrar o próximo espaço:
  Recue o percorredor.
  Recue o percorredor.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o caractere de espaço, recomece.
  \Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o caractere de espaço, recomece.

Etapas para que se recue um percorredor por um número:
  Subtraia o número desde o caractere inicial deste segmento inicial deste percorredor.
  Subtraia o número desde o caractere final deste segmento final deste percorredor.

A contagem total é um número igual a 0.

O detector de ignição é um detector igual a 1.

O sinal de desligamento é um detector igual a 0.

Um posicionamento absoluto é um número.

Etapas para que se adicione uma fração para uma segunda fração:
  Isole a fração.
  Normalize a fração e a segunda fração.
  Adicione o numerador desta fração para o numerador desta segunda fração.
  Reduza a segunda fração.

Uns twips horizontais são uns twips.
Uns twips verticais são uns twips.
Uma localização atual é uma localização.

Etapas para que se adicione uns twips horizontais e uns twips verticais para a localização atual:
  Adicione os twips horizontais para a coordenada X desta localização deste contexto.
  Adicione os twips verticais para a coordenada Y desta localização deste contexto.

\ linha, traço, risco, traçado, listra
Etapas para que se adicione uma linha reta para uma figura:
  Se a figura for inexistente, crie a figura; posponha a figura para as figuras.
  Adicione a localização inicial desta linha reta para a figura.
  Adicione a localização final desta linha reta para a figura.

Etapas para que se adicione um nome para umas escolhas:
  Aloque memória para uma escolha.
  Atribua o nome ao nome desta escolha.
  Atribua a escolha sob o end of as escolhas.

Etapas para que se adicione um número e um segundo número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o segundo número para o número Y deste par de números.

Etapas para que se adicione um número para um segundo número e um terceiro número para um quarto número:
  Adicione o número para o segundo número.
  Adicione o terceiro número para o quarto número.

Etapas para que se adicione um número para uma fração:
  Adicione o número / 1 para a fração. \ não seria o caso de apenas adicionar o número para a fração?
  \ Eu faria assim:
  \ Converta o número para uma nova fração.
  \ Adicione a nova fração à primeira fração.

Etapas para que se adicione um número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o número para o número Y deste par de números.

Etapas para que se adicione um par de números para um segundo par de números:
  Adicione o número X deste par de números para o número X deste segundo par de números.
  Adicione o número Y deste par de números para o número Y deste segundo par de números.

Etapas para que se adicione um quora para um terminal:
  Crie o quora.
  Posponha o quora para o quora deste terminal.
  Se o terminal não estiver totalmente prenchido, cancele.
  Atribua o first destes quoras deste terminal a um doomed quora.
  Remove o doomed quora desde os quoras deste terminal.
  Destrua o doomed quora.

Etapas para que se adicione uma localização para um figura:
  Posponha a localização para a figura.

Etapas para que se adicione uma string para uns conjuntos des textos:
  Crie um conjunto de texto usando a string.
  Posponha o conjunto de texto para o conjuntos des textos. \plural bacana aqui

\O título ideal seria algo como: Etapas para que se ajuse o posicionamento de uma caixa a partir de 4 diferentes números:
Etapas para que se ajuste uma caixa usando um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para a coordenada X do canto superior esquerdo desta caixa.
  Adicione o segundo número para a coordenada Y do canto superior esquerdo desta caixa.
  Adicione o terceiro número para a coordenada X do canto inferior direito desta caixa.
  Adicione o quarto número para a coordenada Y do canto inferior direito desta caixa.

Etapas para que se ajuste um item:
  Atribua os dwFileAttributes deste WIN32FINDDATA deste item a um número.
  Conjuncione logicamente o número com 16 [FILE_ATTRIBUTE_DIRECTORY].
  Se o número for 0, atribua "arquivo" à categoria deste item. \
  Se o número não for 0, atribua "endereço de pasta" à categoria deste item.\
  Converta o ftCreationTime deste WIN32FINDDATA deste item para a grupo data/hora de criação deste item . \ adicionado para classificação de e-mails.
  Atribua o endereçamento deste cFileName deste WIN32FINDDATA deste item a um endereçamento de caractere.
  Converta o endereçamento de caractere para o designador deste item.
  Se a categoria deste item for "endereço de pasta", posponha "\" para o designador deste item.
  Atribua o endereço da pasta deste item junto com o designador deste item ao endereço completo deste item.
  Extraia a extensão deste item desde o designador deste item como um endereço completo.
  Atribua o nFileSizeLow deste WIN32FINDDATA deste item ao size deste item.
  Se o conteúdo deste caractere inicial deste designador deste item não for o ponto final, cancele.
  Obtenha o item (novamente).

Etapas para que se ajuste uma linha reta com um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para a coordenada X desta localização inicial desta linha reta.
  Adicione o segundo número para a coordenada Y desta localização inicial desta linha reta.
  Adicione o terceiro número para a coordenada X desta localização final desta linha reta.
  Adicione o quarto número para a coordenada Y desta localização final desta linha reta.

Etapas para que se ajuste uma imagem (extraindo as caixas do gpBitmap):
  Se a imagem for inexistente, cancele.
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa desta imagem.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa desta imagem.
  Atribua a largura deste gpBitmap desta imagem menos 1 times a quantidade de twips/pixel à coordenada X do canto inferior direito desta caixa desta imagem.
  Atribua a altura deste gpBitmap desta imagem menos 1 times a quantidade de twips/pixel à coordenada Y do canto inferior direito desta caixa desta imagem.
  Atribua a caixa desta imagem à caixa intacta desta imagem.

Etapas para que se ajuste espaçamento da fonte usando uma string:
  Se o quadro atual não for a área de impressão, cancele.
  Call "gdi32.dll" "SetTextCharacterExtra" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-settextcharacterextra
  \A função SetTextCharacterExtra define o espaçamento entre caracteres e adiciona espaço extra para cada célula de caractere na fonte selecionada, 
  \incluindo o caractere de quebra,  quando o sistema grava uma linha de texto.
    A área de impressão  [hDC]\ Um identificador para o contexto do dispositivo.
    e 0. [extra]   \ A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
    \quero traduzir esse comando como: Mande a área de impressão e o código 0 para a função "SetTextCharacterExtra" da biblioteca "gdi32.dll".
  Call "gdi32.dll" "GetCurrentObject" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getcurrentobject
  \A função GetCurrentObject retorna um identificador que identifica a caneta, pincel, paleta, bitmap ou fonte atual 
  \e a função GetObject inicializa uma estrutura contendo os atributos desse objeto. 
  \Algumas impressoras fornecem canetas, pincéis e fontes residentes que podem ser usados para melhorar a velocidade de desenho em um aplicativo.
    A área de impressão [hDC] \ Um identificador para o contexto do dispositivo.
    e 6 [type OBJ_FONT]  \ O tipo de objeto a ser consultado. Este parâmetro pode ser vários valores.
    \ OBJ_FONT -> Retorna a fonte selecionada no momento.
    devolvendo um número identificador. [h] \ Se a função for bem-sucedida, o valor de retorno é um identificador para o objeto especificado. 
    \Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hDC] \ Um identificador para o contexto do dispositivo.
    e O número identificador. [h] \ Um identificador para o objeto a ser selecionado. Nesse caso é o número do comando anterior (a fonte selecionada no momento), retornado pelo GetCurrentObject acima
  Obtenha uma largura usando a string e o memory canvas.
  Call "gdi32.dll" "SelectObject" com 
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hDC] \ Um identificador para o contexto do dispositivo.
    e O null número da fonte.  [h] \ Um identificador para o objeto a ser selecionado. 
    \Nesse caso é também é um número identificador de fonte, mas  este valor é o da função GetStockObject 
    \O sistema oferece seis fontes de estoque. Uma fonte de estoque é uma fonte lógica que um aplicativo pode obter chamando a função GetStockObject e especificando a fonte solicitada. 
    \Esse valor corresponde à ANSI_FIXED_FONT que especifica uma fonte monoespaçada baseada no conjunto de caracteres ANSI do Windows. Uma fonte Courier é normalmente usada.
  Obtenha uma segunda largura usando a string e a área de impressão.
  Atribua a largura menos a segunda largura dividido pelo quantidade de caracteres desta string a um número.
  Call "gdi32.dll" "SetTextCharacterExtra" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-settextcharacterextra
    \A função SetTextCharacterExtra define o espaçamento entre caracteres. 
    \O espaçamento entre caracteres é adicionado a cada caractere, incluindo caracteres de quebra, quando o sistema grava uma linha de texto.
    A área de impressão [hDC] \Um identificador para o contexto do dispositivo.
    e O número. [extra] \A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
    \Se o modo de mapeamento atual não for MM_TEXT, o parâmetro nCharExtra é transformado e arredondado para o pixel mais próximo.

Etapas para que se alinhe uma caixa de texto usando um alinhamento:
  Atribua o alinhamento ao alinhamento desta caixa de texto.

Um alinhamento é uma string [centro, esquerda ou direita].

Uma quantia é um número.

Uma anchor é um position.

Uma máscara de conjunção lógica é uma mask.

Um ângulo é uns precises degrees. [cujos valores variam ente 0 e 3599]

Etapas para que se posponha um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-setfilepointer
  \Esta função armazena o ponteiro do arquivo em dois valores LONG.
  \Quando um arquivo é aberto, o Windows associa um ponteiro de arquivo com o fluxo padrão. 
  \Esse ponteiro de arquivo é um valor de deslocamento que especifica o próximo byte a ser lido ou o local para receber o próximo byte escrito.
    O file [hFile]\ O número identificador do arquivo.
    e 0 [lDistanceToMove] \ Um valor positivo para lDistanceToMove move o ponteiro do arquivo para frente no arquivo 
    \e um valor negativo move o ponteiro para trás no arquivo .
    e 0 [lpDistanceToMoveHigh] \Serve apenas para operações com 64 bits. Quando não é utilizado, esse valor deve ser 0 (NULL). 
    e 2 [dwMoveMethod = FILE_END] \ O ponto de partida para o movimento do ponteiro do arquivo.
    \ Este parâmetro pode ser um dos seguintes valores.
    \0 = FILE_BEGIN ->  O ponto de partida é zero ou o início do arquivo.
    \ 1 = FILE_CURRENT -> O ponto de partida é o valor atual do ponteiro do arquivo.
    \ 2 = FILE_END -> O ponto de partida é a posição atual de fim de arquivo.
    devolvendo um número resultante.
    \Se a função for bem-sucedida e lpDistanceToMoveHigh for NULL, o valor de retorno será o DWORD de ordem inferior do novo ponteiro de arquivo. 
    \Obs: Se a função retornar qualquer valor que não seja -1 (INVALID_SET_FILE_POINTER), isso significa que a chamada para SetFilePointer foi bem-sucedida.
  Se o número resultante for -1, atribua "Ocorreu um erro na hora de posicionar o ponteiro do arquivo." ao erro do fluxo de entrada/saída; saia.
    \ Se o ponteiro de arquivo for um valor negativo, a função falhará, o ponteiro de arquivo não será movido e o código retornado por GetLastError será ERROR_NEGATIVE_SEEK.
    \Observação: Como o valor -1 (INVALID_SET_FILE_POINTER) é um valor válido para o DWORD de ordem inferior do novo ponteiro de arquivo, 
   \O certo seria verificar o valor de retorno da função e o código de erro retornado por GetLastError para determinar se um erro ocorreu ou não. 
    \Se ocorreu um erro, o valor de retorno de SetFilePointer será -1 (INVALID_SET_FILE_POINTER) e a função GetLastError retornará um valor diferente de 0 (NO_ERROR ).  
  Call "kernel32.dll" "WriteFile" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-writefile
  \ Essa função serve pra gravar dados no arquivo ou dispositivo de entrada / saída (E/S) especificado.
    O file [hFile]  \ Um identificador para o arquivo ou dispositivo de E/S 
    \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    e O caractere inicial deste trecho [lpBuffer]  \ Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    e A quantidade de caracteres deste trecho [nNumberOfBytesToWrite] \ O número de bytes a serem gravados no arquivo ou dispositivo.
    \ Um valor zero especifica uma operação de gravação nula. 
    \O comportamento de uma operação de gravação nula depende do sistema de arquivos subjacente ou da tecnologia de comunicação.
    [Creio que seja preciso corrigir o texto abaixo]
    e um [o] endereçamento desse número [lpNumberOfBytesWritten]  \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono. 
    \ WriteFile define esse valor como zero antes de fazer qualquer trabalho ou verificação de erro.
    \ Use NULL para este parâmetro se esta for uma operação assíncrona para evitar resultados potencialmente errôneos.
    \Este parâmetro pode ser NULL somente quando o próximo parâmetro [lpOverlapped] não for 0 (NULL).
    e 0 [lpOverlapped]  \ utilizado somente quando se deseja gravar em outro lugar do arquivo, como por exemplo, no final. 
    \ Se não for o caso, esse parâmetro pode ser 0 (NULL)
    devolvendo o número resultante. \ Se a função for bem-sucedida, o valor de retorno será diferente de 0 (VERDADEIRO).
    \ Se a função falhar ou estiver sendo concluída de forma assíncrona, o valor de retorno será 0 (FALSO). 
    \Para obter informações de erro estendidas, chame a função GetLastError.
    \ Nota: Se GetLastError fornecer um valor igual a 997 ou -2147023899 (ERROR_IO_PENDING), isso não indica uma falha na gravação do arquivo; 
    \indica apenas que a operação de gravação ainda está com conclusão pendente devido ser uma operação de gravação de forma assíncrona. 
    \ Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
  Se o número resultante for 0, atribua "Ocorreu um erro na hora de salvar o arquivo." ao erro do fluxo de entrada/saída; saia.

Etapas para que se posponha um byte para uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o caractere inicial desta string usando a quantidade de caracteres desta string mais 1.
  Atribua o caractere inicial desta string mais a quantidade de caracteres armazenados ao caractere final desta string.
  Atribua o byte para o conteúdo deste caractere final desta string.

Etapas para que se posponha um byte para uma string usando uma contagem:
  Isole a contagem.
  Comece. [a executar o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha o byte para a string.
    Subtraia 1 desde a contagem.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha um detector para uma string:
  Converta o detector para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha uma fração para uma string:
  Converta a fração para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um número para uma string:
  Converta o número para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um ponteiro para uma string:
  Converta o ponteiro para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha uma localização para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a localização.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha uma string para uma segunda string:
  Se a string estiver em branco, cancele.
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Atribua a quantidade de caracteres desta segunda string a uma quantidade de caracteres armazenados.
  Adicione a quantidade de caracteres armazenados para a quantidade de caracteres agrupados.
  Reassign o caractere inicial desta segunda string usando a quantidade de caracteres agrupados.
  Atribua o caractere inicial desta segunda string mais a quantidade de caracteres armazenados a um ponteiro.
  Copie bytes desde o caractere inicial desta string para o ponteiro pelo quantidade de caracteres desta string.
  Atribua o caractere inicial desta segunda string mais a quantidade de caracteres agrupados menos 1 ao caractere final desta segunda string.

Etapas para que se posponha uma string para uma segunda string (handling email transparency):
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Comece. [a executar o código abaixo]
    Mova o percorredor (caixa de texto file rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor começa com ".", posponha "." para a segunda string.
    Posponha o segmento inicial deste percorredor para a segunda string.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha uma string para uma segunda string usando uma contagem:
  Isole a contagem.
  Comece. [a executar o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha a string para a segunda string.
    Subtraia 1 desde a contagem.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha umas coisas para umas outras coisas:
  Atribua a first coisa destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Posponha a coisa para a outras coisas.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha um temporizador para uma string:
  Converta o temporizador para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um vértice para um polígono:
  Se o polígono for inexistente, cancele.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha uma coordenada X e uma coordenada Y para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a coordenada X e a coordenada Y.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha zeros para uma string até que its quantidade de caracteres é um número:
  Se a quantidade de caracteres desta string for maior do que ou igual ao número, cancele.
  Posponha "0" para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se assign um ponteiro usando um quantidade de bytes:  \Assinale? Institua? Instale? Instaure? Crie? Inaugure? Monte? Componha? Constitua? Designe? Declare?
  Se o quantidade de bytes for 0, esvazie o ponteiro; saia.
  Isole o quantidade de bytes.
  Arredonde o quantidade de bytes para cima para o próxima potência of two.
  Call "kernel32.dll" "HeapAlloc" com \ https://docs.microsoft.com/pt-br/windows/win32/api/heapapi/nf-heapapi-heapalloc
  \Aloca um bloco de memória de um heap. A memória alocada não é móvel.
    O endereço heap [hHeap] \ Um identificador para o heap do qual a memória será alocada. Esse identificador é retornado pela função HeapCreate ou GetProcessHeap .
    e 8 [dwFlags ] \As opções de alocação de heap. A especificação de qualquer um desses valores substituirá o valor correspondente especificado quando o heap foi criado com HeapCreate . 
    [8 = HEAP_ZERO_MEMORY]  \A memória alocada será inicializada em zero. Caso contrário, a memória não é inicializada para zero.
    e A quantidade de bytes [dwBytes] \O número de bytes a serem alocados.
    devolvendo o ponteiro. [LPVOID ] \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o bloco de memória alocado.
  Se o ponteiro não for inexistente, adicione 1 para a contagem do heap; saia.

Etapas para que se role automaticamente uma caixa de texto usando uma localização e um detector:
  Se a caixa de texto for inexistente, desative o detector; saia.
  Atribua a altura desta fonte desta caixa de texto a um número.
  Limpe um difference.
  Atribua a caixa desta caixa de texto a uma caixa.
  Indent a caixa usando a quantidade de twips/pixel .
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua o número ao número Y desta difference.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua o número ao número Y desta difference; negate o número Y desta difference.
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua o número ao número X desta difference.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, atribua o número ao número X desta difference; negate o número X desta difference.
  Se o detector de rolagem horizontal desta caixa de texto não estiver ativo, atribua 0 ao número X desta difference.
  Se o detector de rolagem vertical desta caixa de texto não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, desative o detector; saia.
  Ligue o detector.
  Role a caixa de texto usando a difference.
  Aguarde por 50 milliseconds.

\Um baseline é um número. \ variável não utilizada


Etapas para que se faça bi-bi:
  Call "user32.dll" "MessageBeep" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-messagebeep
  \Reproduz um som waveform. O som waveform para cada tipo de som é identificado por uma entrada no registro.
  0. [uType] \O som a ser reproduzido. Os sons são definidos pelo usuário por meio do aplicativo de painel de controle de Som e, a seguir, armazenados no registro.
  \O valor 0 é o som especificado como o som Beep padrão do Windows.
  Call "user32.dll" "MessageBeep" com 
  0.

Etapas para que se inicie uma folha modo paisagem:
  Faça a folha modo paisagem 1056 pixels por 816 pixels.
  Inicie uma folha com a folha modo paisagem.

Etapas para que se inicie uma folha modo retrato:
  Faça a folha modo retrato 816 pixels por 1056 pixels.
  \para referência, uma folha A4 possui 3508 x 2480 px, praticamente 10x maio
  Inicie uma folha com a folha modo retrato.

Etapas para que se inicie a impressão:
  Inicialize a área de impressão.
  Atribua a magnitude desse DOCINFO ao cbSize deste DOCINFO.
  Atribua o caractere inicial deste nome deste module ao lpszDocName deste DOCINFO.
  Call "gdi32.dll" "StartDocA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-startdoca
  \A função StartDoc inicia um trabalho de impressão.
    A área de impressão [hDC] \Um identificador para o contexto do dispositivo para o trabalho de impressão.
    e O endereçamento deste DOCINFO. [*lpdi] \Um ponteiro para uma estrutura DOCINFO contendo o nome do arquivo de documento e o nome do arquivo de saída.

Etapas para que se inicie uma folha:
  Inicie a folha como uma folha modo retrato.

Um título de índice remissivo é uma string.

Etapas para que se inicie uma folha usando um título de índice remissivo:
  Inicie uma folha modo retrato usando o título de índice remissivo.

A Bíblia é uma coisa com uns versos.

Um verso é uma coisa com uma string.

Uma word big-endian unsigned é um conjunto com 2 bytes.

Um código binário é uma string.

Uma caixa é um conjunto com
  Uma coordenada X do canto superior esquerdo , 
  Uma coordenada Y do canto superior esquerdo, 
  Uma coordenada X do canto inferior direito, 
  Uma coordenada Y do canto inferior direito,  
  Um canto superior esquerdo localização sob a coordenada X do canto superior esquerdo, e 
  Um canto inferior direito localização sob a coordenada X do canto inferior direito.

Um brilho é uma luminosidade.

Um contagem de buckets é uma contagem.
Um conjunto de buckets é um conjunto com uns referências.
Um bucket é um ponteiro para um conjunto de buckets.

Um trecho é uma string.

\Etapas para que se avance um byte limitando-a para um segundo byte e um terceiro byte;
Etapas para que se avance um byte limitando-o para um segundo byte e um terceiro byte:
  Adicione 1 para o byte.
  Se o byte for maior do que o terceiro byte, atribua o segundo byte ao byte.

Etapas para que se avance um número:
  Adicione 1 para o número.

\Etapas para que se avance um número limitando-a para um segundo número e um terceiro número;
Etapas para que se avance um número limitando-o para um segundo número e um terceiro número:
  Adicione 1 para o número.
  Se o número for maior do que o terceiro número, atribua o segundo número ao número.

Etapas para que se avance um percorredor por um número:
  Adicione o número para o caractere final deste segmento inicial deste percorredor.
  Adicione o número para o caractere inicial deste segmento final deste percorredor.

Etapas para que se assobie:
  Call "kernel32.dll" "Beep" com \ https://docs.microsoft.com/pt-br/windows/win32/api/utilapiset/nf-utilapiset-beep
    \Gera tons simples no alto-falante. A função é síncrona; ele executa uma espera alertável e não retorna o controle para seu chamador até que o som termine.
    220 [dwFreq] \A frequência do som, em hertz. Este parâmetro deve estar no intervalo de 37 a 32.767 (0x25 a 0x7FFF).
    e 200. [dwDuration] \A duração do som, em milissegundos

Uma quantidade de bytes é uma contagem.



Etapas para que se capitalize algum tipo de linhas des textos selecionadas em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se a linha de texto of a caixa de texto não estiver selecionado, recomece.
    Se a linha de texto estiver em branco, recomece.
    Capitalize a string deste linha de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se capitalize uma string:
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste caractere inicial deste subtexto não for irrelevante, pare.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  Uppercase o conteúdo deste caractere inicial deste subtexto.

Etapas para que se capitalize uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, pare.
    Capitalize a string deste linha de texto.
  Recomece. [percorra novamente o código acima]
  Wrap a caixa de texto.

Um cursor de texto é um position.

Etapas para que se centralize uma caixa sob o base of uma segunda caixa:
  Centralize a caixa no segunda caixa (horizontalmente).
  Atribua a altura desta caixa a uma altura.
  Atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto inferior direito desta caixa menos a altura à coordenada Y do canto superior esquerdo desta caixa.

Etapas para que se centralize uma caixa em uma segunda caixa (horizontalmente):
  Atribua a coordenada X deste centro desta segunda caixa menos a coordenada X deste centro desta caixa a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa usando o número e 0.

Etapas para que se centralize uma caixa em uma segunda caixa (verticalmente):
  Atribua a coordenada Y deste centro desta segunda caixa menos a coordenada Y deste centro desta caixa a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa usando 0 e o número.

Etapas para que se centralize um dot sobre a localização atual:
  Centralize o dot sobre a localização deste contexto.

Etapas para que se centralize uma elipse em uma caixa (horizontalmente):
  Centralize a caixa desta elipse na caixa (horizontalmente).

Etapas para que se centralize uma elipse em uma caixa (verticalmente):
  Centralize a caixa desta elipse na caixa (verticalmente).

Etapas para que se centralize uma linha reta em uma caixa (horizontalmente):
  Atribua a coordenada X deste centro desta caixa menos a coordenada X deste centro desta linha reta a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a linha reta usando o número e 0.

Etapas para que se centralize uma linha reta em uma caixa (verticalmente):
  Atribua a coordenada Y deste centro desta caixa menos a coordenada Y deste centro desta linha reta a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a linha reta usando 0 e o número.

Etapas para que se centralize uma imagem em uma caixa (horizontalmente):
  Se a imagem for inexistente, cancele.
  Atribua a coordenada X deste centro desta caixa menos a coordenada X deste centro desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando o número e 0.

Etapas para que se centralize uma imagem em uma caixa (verticalmente):
  Se a imagem for inexistente, cancele.
  Atribua a coordenada Y deste centro desta caixa menos a coordenada Y deste centro desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando 0 e o número.

Etapas para que se centralize um polígono em uma caixa (horizontalmente):
  Se o polígono for inexistente, cancele.
  Atribua a coordenada X deste centro desta caixa menos a coordenada X deste centro desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o polígono usando o número e 0.

Etapas para que se centralize um polígono em uma caixa (verticalmente):
  Se o polígono for inexistente, cancele.
  Atribua o y deste centro desta caixa menos o y deste centro desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o polígono usando 0 e o número.

Etapas para que se centralize uma localização em uma caixa (horizontalmente):
  Atribua a coordenada X deste centro desta caixa menos a coordenada X desta localização a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a localização usando o número e 0.

Etapas para que se centralize uma localização em uma caixa (verticalmente):
  Atribua o y deste centro desta caixa menos a coordenada Y desta localização a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a localização usando 0 e o número.

Etapas para que se centralize uma caixa de texto em uma caixa (horizontalmente):
  Se a caixa de texto for inexistente, cancele.
  Atribua a coordenada X deste centro desta caixa menos a coordenada X deste centro desta caixa desta caixa de texto a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa de texto usando o número e 0.

Etapas para que se centralize uma caixa de texto em uma caixa (verticalmente):
  Se a caixa de texto for inexistente, cancele.
  Atribua a coordenada Y deste centro desta caixa menos a coordenada Y deste centro desta caixa desta caixa de texto a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa de texto usando 0 e o número.

Etapas para que se modifique o current matiz por uns points;
Etapas para que se altere o current matiz por uns points;
Etapas para que se mude o current matiz por uns points:
  Mude a matiz deste contexto por os points.

Etapas para que se modifique um matiz por uns points;
Etapas para que se altere um matiz por uns points;
Etapas para que se mude um matiz por uns points:
  Adicione o points para o matiz.

Etapas para que se modifique uma caixa arredondada usando um raio;
Etapas para que se altere uma caixa arredondada usando um raio;
Etapas para que se mude uma caixa arredondada usando um raio:
  Atribua o raio ao raio desta caixa arredondada.

Etapas para que se modifique uma caixa de texto usando uma caixa;
Etapas para que se altere uma caixa de texto usando uma caixa;
Etapas para que se mude uma caixa de texto usando uma caixa:
  Se a caixa de texto for inexistente, cancele.
  Atribua a caixa à caixa desta caixa de texto.
  Wrap a caixa de texto.

Etapas para que se modifique uma caixa de texto usando uma altura da fonte;
Etapas para que se altere uma caixa de texto usando uma altura da fonte;
Etapas para que se mude uma caixa de texto usando uma altura da fonte:
  Se a caixa de texto for inexistente, cancele.
  Subtraia a margem desta caixa de texto desde a coordenada X desta caixa de texto.
  Atribua a origem desta caixa de texto dividido pela malha desta caixa de texto a um par de números.
  Atribua a altura da fonte à altura desta fonte desta caixa de texto.
  Redimensione proporcionalmente a altura desta fonte desta caixa de texto usando a scale desta caixa de texto.
  Atribua o par de números times a malha desta caixa de texto à origem desta caixa de texto.
  Adicione a margem desta caixa de texto para a coordenada X desta caixa de texto.
  Limite a origem of a caixa de texto.
  Wrap a caixa de texto.

Um nome da fonte é um nome.

Etapas para que se modifique uma caixa de texto usando uma nome da fonte;
Etapas para que se altere uma caixa de texto usando uma nome da fonte;
Etapas para que se mude uma caixa de texto usando uma nome da fonte:
  Se a caixa de texto for inexistente, cancele.
  Atribua o nome da fonte ao nome desta fonte desta caixa de texto.
  Wrap a caixa de texto.

Um character é um byte.

Uma escolha é uma coisa com um nome e uma caixa.

As escolhas são umas escolhas.

Etapas para que se limpe uma caixa:
  Atribua 0 e 0 e 0 e 0 ao caixa. \ caderno depends disso

Etapas para que se limpe um byte:
  Atribua o caractere null ao byte.

Etapas para que se limpe uma cor:
  Atribua 0 e 0 e 0 à cor.

Etapas para que se limpe uma elipse:
  Limpe a caixa desta elipse.

Etapas para que se desative um detector;
Etapas para que se desligue um detector:
  Atribua 0 ao detector. \ era "Atribua no ao detector." O valor da keyword "no" estava no executável do CAL-1000, de acordo com o  Dahn.

Etapas para que se limpe uma fonte:
  Atribua "" e 0 à fonte.

Etapas para que se limpe uma fração:
  Atribua 0 e 1 à fração.

Etapas para que se limpe um Endereço IP:
  Limpe o número deste Endereço IP.
  Limpe a string deste Endereço IP.

Etapas para que se limpe uma linha reta:
  Limpe a localização inicial desta linha reta.
  Limpe a localização final desta linha reta.

Etapas para que se limpe um número:
  Atribua 0 ao número.

Etapas para que se limpe um par de números:
  Atribua 0 e 0 ao par de números.

Etapas para que se limpe um percorredor:
  Limpe o subtexto original deste percorredor.
  Limpe o segmento final deste percorredor.
  Limpe o segmento inicial deste percorredor.

Etapas para que se erase a tela;
Etapas para que se escureça a tela;
Etapas para que se apague a tela;
Etapas para que se limpe a tela:
  Exponha tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste contexto.

Etapas para que se pinte a tela com uma cor; \ pinte a tela de uma só cor [ou] pinte a tela com uma só cor, etc
Etapas para que se limpe a tela usando uma cor:
  Exponha tudo.
  Pinte a caixa desta tela com a cor e a cor.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste contexto.

Etapas para que se branqueie a tela;
Etapas para que se pinte a tela de branco;
Etapas para que se limpe a tela usando a cor branca:
  \ \ needs special handling
  Exponha tudo.
  Pinte a caixa desta tela com a cor branca e a cor branca.
  Atualize o tela.
  Atribua a caixa desta tela à caixa deste contexto.

Etapas para que se limpe a tela sem atualizá-la:
  Exponha tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atribua a caixa desta tela à caixa deste contexto.

Etapas para que se limpe uma seleção:
  Limpe o anchor desta seleção.
  Limpe o cursor de texto desta seleção.

Etapas para que se limpe o stack:
  \ necessário aprimoramentos
  Destrua o stack.

Etapas para que se limpe uma string:
  Unassign o caractere inicial desta string.
  Esvazie o caractere final desta string.

Etapas para que se limpe um subtexto:
  Esvazie o caractere inicial deste subtexto.
  Esvazie o caractere final deste subtexto.

Etapas para que se limpe um terminal:
  Destrua os quoras deste terminal.

Etapas para que se limpe umas coisas:
  Esvazie a first coisa destas coisas.
  Esvazie a last coisa destas coisas.

Etapas para que se limpe uma word:
  Atribua 0 ao word.

Etapas para que se close um file:
  Call "kernel32.dll" "CloseHandle" com \ https://docs.microsoft.com/pt-br/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
  \Em geral, CloseHandle invalida o identificador do objeto especificado, diminui a contagem do identificador do objeto e executa verificações de retenção do objeto. 
  \Depois que o último identificador para um objeto é fechado, o objeto é removido do sistema. .
    O file. [hObject] \Um identificador válido para um objeto aberto.

Etapas para que se avise:
  Toque o som de aviso.

Um número de coluna é um número.

Etapas para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres devolvendo um número:
  Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos ascii devolvendo o número.
  \Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos s/ acento ascii devolvendo o número.

Etapas para que se compativelmente handle algum tipo de message com um janela do programa um message número um wParam e um lParam:
  Se a message for 006 [WM_ACTIVATE], execute algum tipo de WM_ACTIVATE com o wParam; [especifica se a janela está sendo ativada ou desativada]
   Atribua 0 para EAX; saia.
  Se a message for 258 [WM_CHAR hex 102], execute algum tipo de WM_CHAR com o wParam [O código do caractere da tecla.] e o lParam;  
  [lParam é a contagem de repetição, código de varredura, sinalizador de chave estendida, código de contexto, sinalizador de estado da chave anterior ou sinalizador de estado de transição]
  \ Essa mensagem é enviada para a janela com o foco do teclado quando uma mensagem WM_KEYDOWN é traduzida pela função TranslateMessage. 
  \A mensagem WM_CHAR contém o código de caractere da tecla que foi pressionada.
  atribua 0 para EAX; saia.
  Se a message for 001 [WM_CREATE], execute algum tipo de WM_CREATE com a janela do programa; 
  \Enviado quando um aplicativo solicita que uma janela seja criada chamando a função CreateWindowEx ou CreateWindow.   
  \O procedimento de janela da nova janela recebe essa mensagem depois que a janela é criada, mas antes que a janela se torne visível.
  \Uma janela recebe essa mensagem por meio de sua função WindowProc.
  atribua 0 para EAX; saia.
  Se a message for 002 [WM_DESTROY], execute algum tipo de WM_DESTROY; atribua 0 para EAX; saia.
  \ Enviado quando uma janela está sendo destruída. 
  \É enviado para o procedimento de janela da janela sendo destruída após a janela ser removida da tela. 
  \Essa mensagem é enviada primeiro para a janela que está sendo destruída e, em seguida, para as janelas filhas (se houver) à medida que são destruídas. 
  \Durante o processamento da mensagem, pode-se supor que todas as janelas filho ainda existam.
  Se a message for 256 [WM_KEYDOWN Hex 100], execute algum tipo de WM_KEYDOWN 
  \Essa mensagem é enviada para a janela com o foco do teclado quando uma tecla não pertencente ao sistema é pressionada. 
  \Uma tecla que não é do sistema é aquela que é pressionada quando a tecla ALT não está pressionada.
  com O wParam [O código de tecla virtual da tecla não pertencente ao sistema. Consulte Códigos de teclas virtuals ]\-> https://docs.microsoft.com/pt-br/windows/win32/inputdev/virtual-key-codes
    e O lParam; [Pode ser a contagem de repetição, um código de varredura, sinalizador de chave estendida, código de contexto, sinalizador de estado-chave anterior e sinalizador de estado de transição,]
  \ veja detalhes aqui: https://docs.microsoft.com/pt-br/windows/win32/inputdev/wm-keydown
   atribua 0 para EAX; saia.
  Se a message for 513 [WM_LBUTTONDOWN Hex 201], execute algum tipo de WM_LBUTTONDOWN
  \Postado quando o usuário pressiona o botão esquerdo do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. 
  \Caso contrário, a mensagem é postada na janela que capturou o mouse.
  \Uma janela recebe essa mensagem por meio de sua função WindowProc.
  \ o wParam Indica se as teclas virtuais estão pressionadas ou não, podendo ser mais de uma
   com o lParam;  \ especifica a coordenada do cursor. A coordenada é relativa ao canto superior esquerdo da área do cliente.
   atribua 0 para EAX; saia.
  Se a message for 515 [WM_LBUTTONDBLCLK Hex 203], execute algum tipo de WM_LBUTTONDBLCLK com o lParam; atribua 0 para EAX; saia.
  \Postado quando o usuário clica duas vezes com o botão esquerdo do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 015 [WM_PAINT Hex 0000000F], execute algum tipo de WM_PAINT com o janela do programa; atribua 0 para EAX; saia.
  \A mensagem WM_PAINT é enviada quando o sistema ou outro aplicativo faz uma solicitação para pintar uma parte da janela de um aplicativo. 
  \A mensagem é enviada quando a função UpdateWindow ou RedrawWindow é chamada 
  \ou pela função DispatchMessage quando o aplicativo obtém uma mensagem WM_PAINT usando a função GetMessage ou PeekMessage .
  Se a message for 516 [WM_RBUTTONDOWN Hex 204], execute algum tipo de WM_RBUTTONDOWN com o lParam; atribua 0 para EAX; saia.
  \Postado quando o usuário pressiona o botão direito do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 518 [WM_RBUTTONDBLCLK Hex 206], execute algum tipo de WM_RBUTTONDBLCLK com o lParam; atribua 0 para EAX; saia.
  \Postado quando o usuário clica duas vezes com o botão direito do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 032 [WM_SETCURSOR Hex 20], execute algum tipo de WM_SETCURSOR; atribua 1 para EAX; saia.
  \Enviado para uma janela se o mouse fizer com que o cursor se mova dentro de uma janela e a entrada do mouse não for capturada.
  Se a message for 260 [WM_SYSKEYDOWN Hex 104], execute algum tipo de WM_SYSKEYDOWN com o wParam e o lParam; atribua 0 para EAX; saia.
  \Postado na janela com o foco do teclado quando o usuário pressiona a tecla F10 (que ativa a barra de menus) ou mantém pressionada a tecla ALT e pressiona outra tecla. 
  \Também ocorre quando nenhuma janela tem o foco do teclado; neste caso, a mensagem WM_SYSKEYDOWN é enviada para a janela ativa. 
  \A janela que recebe a mensagem pode distinguir entre esses dois contextos, verificando o código de contexto no parâmetro lParam .
  Call "user32.dll" "DefWindowProcA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-defwindowproca
  \Chama o procedimento de janela padrão para fornecer processamento padrão para todas as mensagens de janela que um aplicativo não processa. 
  \Esta função garante que todas as mensagens sejam processadas. DefWindowProc é chamado com os mesmos parâmetros recebidos pelo procedimento de janela.
    A janela do programa [hWnd] \Um identificador para o procedimento de janela que recebeu a mensagem.
    e A message [Msg] \A mensagem em si.
    e O wParam [wParam] \Informações adicionais da mensagem. O conteúdo deste parâmetro depende do valor do parâmetro Msg.
    e O lParam. [lParam] \Informações adicionais da mensagem. O conteúdo deste parâmetro depende do valor do parâmetro Msg.

Etapas para que se compativelmente aguarde por um process ponteiro:
  Call "kernel32.dll" "WaitForSingleObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject
  \Espera até que o objeto especificado esteja no estado sinalizado ou o intervalo de tempo limite expire.
    O conteúdo deste process ponteiro [hHandle]  \o número identificador do objeto
    e -1. [dwMilliseconds]  \intervalo de tempo limite, em milisegundos.  O valor -1 informa que a função retornará apenas quando o objeto for sinalizado.]
  Call "kernel32.dll" "CloseHandle" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
    O conteúdo deste process ponteiro. [hObject]  \Um identificador válido para um objeto aberto.
  Atribua 0 ao conteúdo deste process ponteiro. \  
  Call "user32.dll" "GetForegroundWindow" \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getforegroundwindow
  \Recupera um identificador para a janela do primeiro plano (a janela com a qual o usuário está trabalhando atualmente). 
  \O sistema atribui uma prioridade um pouco mais alta ao encadeamento que cria a janela de primeiro plano do que aos outros encadeamentos.
    devolvendo uma janela do programa. \O valor de retorno é um identificador para a janela do primeiro plano. 
   \A janela de primeiro plano pode ser NULL em certas circunstâncias, como quando uma janela está perdendo a ativação.
  Se a janela do programa for a janela principal do programa, atribua 0 para EAX; saia.
  Call "user32.dll" "ShowWindow" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-showwindow
 \Define o estado de exibição da janela especificada.
    A janela principal do programa [hWnd] \Um número identificador para a janela.
    e 6 [nCmdShow SW_MINIMIZE]. \Controla como a janela deve ser exibida. 
    \SW_MINIMIZE Minimiza a janela especificada e ativa a próxima janela de nível superior na ordem Z.
  Call "user32.dll" "ShowWindow" com 
    A janela principal do programa [hWnd]  \Um número identificador para a janela.
    e 9 [nCmdShow SW_RESTORE]. \Ativa e exibe a janela. 
    \Se a janela for minimizada ou maximizada, o sistema a restaurará para seu tamanho e posição originais. 
    \Um aplicativo deve especificar este sinalizador ao restaurar uma janela minimizada.
  Atribua 0 para EAX. \ abra return value of thread

Um console é uma coisa com 
  Uma caixa, 
  Uma cor da borda,
  Uma cor de preenchimento, 
  Uma caixa de texto, 
  Uma malha, 
  Um texto retornado string.

O contexto é um contexto.



O contexto stack é uns contextos.

Etapas para que se converta um posicionamento absoluto para uma position usando uma caixa de texto:
  Se a caixa de texto for inexistente, limpe o position; saia.
  Isole o posicionamento absoluto.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, limpe o position; saia.
    Atribua o número da linha desta linha de texto ao número da linha desta position.
    Atribua o posicionamento absoluto ao número de coluna desta position.
    Subtraia a quantidade de caracteres desta string desta linha de texto desde o posicionamento absoluto.
    Se o posicionamento absoluto for menor do que 1, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta um código binário Para um número:
  Atribua 0 ao número.
  Atribua 1 a um value número.
  Comece. [a executar o código abaixo]
    Se o código binário estiver em branco, cancele.
    Obtenha um character desde o código binário (backwards). \ was backwards
    Se o character for "1", adicione o value para o número.
    Double o value.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta uma caixa para uma string:
  Limpe a string.
  Posponha a coordenada X do canto superior esquerdo desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada Y do canto superior esquerdo desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada X do canto inferior direito desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada Y do canto inferior direito desta caixa para a string.

Etapas para que se converta um byte para uma cifra binária:
  Atribua o byte à cifra binária como um byte.
  Uppercase a cifra binária.
  Se a cifra binária for maior do que o número nove, subtraia 7 desde a cifra binária.
  Subtraia 48 desde a cifra binária.

Etapas para que se converta um byte para uma cifra hexadecimal:
  Separe o byte a uma cifra binária e uma segunda cifra binária.
  Converta a cifra binária para a cifra hexadecimal.
  Converta a segunda cifra binária para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para a cifra hexadecimal.

Etapas para que se converta um byte para um query byte:
  Se o byte estiver entre 48 e 57, atribua o byte ao query byte; saia. \ 0-9
  Se o byte estiver entre 65 e 90, atribua o byte ao query byte; saia. \ A-Z
  Se o byte estiver entre 97 e 122, atribua o byte ao query byte; saia. \ a-z
  Se o byte for 32, atribua "+" ao query byte; saia. \ space
  Converta o byte para uma cifra hexadecimal.
  Atribua "%" junto com a cifra hexadecimal ao query byte.

Etapas para que se converta uma cor para um código da cor:
  Se a cor estiver clear, atribua 16777215 [$00FFFFFF] ao código da cor; saia. \ a cor transparente fica branca 
  Isole a cor.
  Redimensione proporcionalmente a saturação desta cor usando 240/1000.
  Limite a saturação desta cor para 1 e 239.
  Redimensione proporcionalmente a luminosidade desta cor usando 240/1000.
  Limite a luminosidade desta cor para 1 e 239.
  Redimensione proporcionalmente a matiz desta cor usando 240/3600.
  Limite a matiz desta cor para 1 e 239.
  Call "shlwapi.dll" "ColorHLSToRGB" com \ https://docs.microsoft.com/pt-br/windows/win32/api/shlwapi/nf-shlwapi-colorhlstorgb
  \ Converte cores de matiz-luminância-saturação (HLS) para o formato RGB.
    A matiz desta cor [wHue] \O valor de matiz HLS original.
    e A luminosidade desta cor  [wLuminance] \O valor de luminância HLS original.
    e A saturação desta cor [wSaturation] \O valor de saturação HLS original.
    devolvendo o código da cor. [COLORREF] \Retorna o valor RGB.

Etapas para que se converta uma cor para um espaço de cor RGB:
  Converta a cor para um código da cor.
  Converta o código da cor para o espaço de cor RGB.

Etapas para que se converta um código da cor para uma cor:
  Call "shlwapi.dll" "ColorRGBToHLS" com \ https://docs.microsoft.com/pt-br/windows/win32/api/shlwapi/nf-shlwapi-colorrgbtohls
    O código da cor e [clrRGB] \ A cor RGB original.
    O endereçamento desse word [*pwHue] \ Um ponteiro para um valor que, quando esse método retorna com êxito, recebe o valor de matiz HLS.
    e O endereçamento dessa segunda word [*pwLuminance] \ Um ponteiro para um valor que, quando este método retorna com sucesso, recebe o valor de luminância HLS.
    e O endereçamento desse terceiro word.[*pwSaturation] \ Um ponteiro para um valor que, quando este método retorna com sucesso, recebe o valor de saturação HLS.
  Atribua a word à matiz desta cor.
  Atribua a segunda word à luminosidade desta cor.
  Atribua o terceiro word à saturação desta cor.
  Redimensione proporcionalmente a matiz desta cor usando 3600/240.
  Limite a matiz desta cor para 0 e 3600.
  Redimensione proporcionalmente a saturação desta cor usando 1000/240.
  Limite a saturação desta cor para 0 e 1000.
  Redimensione proporcionalmente a luminosidade desta cor usando 1000/240.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se converta um código da cor para um espaço de cor RGB:
  Isole o código da cor.
  Desloque o código da cor para a direita 0 bits.
  Atribua o código da cor ao espectro vermelho deste espaço de cor RGB.
  Desloque o código da cor para a direita 8 bits.
  Atribua o código da cor ao espectro verde deste espaço de cor RGB.
  Desloque o código da cor para a direita 8 bits.
  Atribua o código da cor ao espectro azul deste espaço de cor RGB.

Etapas para que se converta um filetime para uma string:
  Limpe a string.
  Call "kernel32.dll" "FileTimeToSystemTime" com \ https://docs.microsoft.com/pt-br/windows/win32/api/timezoneapi/nf-timezoneapi-filetimetosystemtime
  \ Converte a hora do arquivo em formato de hora do sistema. A hora do sistema é baseada na hora universal coordenada (UTC).
    O endereçamento deste filetime [*lpFileTime] \ Um ponteiro para uma estrutura FILETIME contendo a hora do arquivo a ser convertida para o formato de data e hora do sistema (UTC).
    e O endereçamento desse SYSTEMTIME [lpSystemTime] \ Um ponteiro para uma estrutura SYSTEMTIME para receber a hora do arquivo convertido.
    devolvendo um número. \ Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Se o número for 0, cancele. \Se a função falhar, o valor de retorno é zero.
  Atribua o wYear deste SYSTEMTIME ao year desse date/time.
  Atribua o wMonth deste SYSTEMTIME ao month deste date/time.
  Atribua o wDayOfWeek deste SYSTEMTIME ao week day deste date/time.
  Atribua o wDay deste SYSTEMTIME ao day deste date/time.
  Atribua o wHour deste SYSTEMTIME à hour deste date/time.
  Atribua o wMinute deste SYSTEMTIME ao minute deste date/time.
  Atribua o wSecond deste SYSTEMTIME ao second deste date/time.
  Atribua os wMilliseconds deste SYSTEMTIME ao millisecond deste date/time.
  Atribua a string deste date/time à string.

Etapas para que se converta um detector para um texto hexadecimal:
  Reassign o caractere inicial deste texto hexadecimal usando a magnitude deste detector.
  Copie bytes desde o endereçamento deste detector para o caractere inicial deste texto hexadecimal pela magnitude deste detector.
  Atribua o caractere inicial deste texto hexadecimal mais a magnitude deste detector menos 1 ao caractere final deste texto hexadecimal.

Etapas para que se converta uma fonte para um número da fonte:
  Isole a fonte.
  Anexe o caractere NULL o nome desta fonte.
  Call "gdi32.dll" "CreateFontA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-createfonta
  \A função CreateFont cria uma fonte lógica com as características especificadas. A fonte lógica pode ser posteriormente selecionada como a fonte para qualquer dispositivo.
   - a altura desta fonte times 3 [e depois] dividido por 4 [cHeight] \A altura, em unidades lógicas, da célula ou caractere da fonte. 
   \O valor da altura do caractere (também conhecido como altura EM) é o valor da altura da célula do caractere menos o principal valor interno.
   \Para todas as comparações de altura, o mapeador de fonte procura a maior fonte que não exceda o tamanho solicitado.
    \Esse mapeamento ocorre quando a fonte é usada pela primeira vez.
    e 0 [cWidth] \A largura média, em unidades lógicas, de caracteres na fonte solicitada. 
   \Se este valor for zero, o mapeador de fonte escolhe um valor de correspondência mais próximo. 
   \O valor de correspondência mais próximo é determinado 
   \comparando os valores absolutos da diferença entre a proporção de aspecto do dispositivo atual e a proporção de aspecto digitalizado das fontes disponíveis.
    e 0 [cEscapement] \O ângulo, em décimos de graus, entre o vetor de escape e o eixo x do dispositivo. 
    \O vetor de escape é paralelo à linha de base de uma linha de texto.
    e 0 [cOrientation] \O ângulo, em décimos de graus, entre a linha de base de cada personagem e o eixo x do dispositivo.
    e 0 [cWeight] \A espessura da fonte no intervalo de 0 a 1000. Por exemplo, 400 é normal e 700 é negrito. Se este valor for zero, um peso padrão é usado.
    e 0 [bItalic] \Especifica uma fonte em itálico se definida como TRUE.
    e 0 [bUnderline] \Especifica uma fonte sublinhada se definida como TRUE.
    e 0 [bStrikeOut] \Especifica uma fonte riscada se definida como TRUE.
    e 1 [iCharSet = DEFAULT_CHARSET]  \O conjunto de caracteres. 
    \DEFAULT_CHARSET é definido com um valor baseado na localidade do sistema atual. 
    \Por exemplo, quando a localidade do sistema é inglês (Estados Unidos), ela é definida como ANSI_CHARSET.
    e 0 [iOutPrecision] \A precisão de saída. 
    \A precisão da saída define o quanto a saída deve corresponder à altura, largura, orientação do caractere, escape, densidade e tipo de fonte da fonte solicitada.
    e 0 [iClipPrecision] \A precisão do recorte. A precisão de recorte define como recortar caracteres que estão parcialmente fora da região de recorte.
    e 5 [iQuality = CLEARTYPE_QUALITY]  \A qualidade da saída. 
    \A qualidade de saída define com que cuidado o GDI deve tentar corresponder os atributos de fonte lógica aos de uma fonte física real.
    \Se CLEARTYPE_QUALITY for definido, o texto é renderizado (quando possível) usando o método de suavização ClearType.
    e 4 [iPitchAndFamily = TRUETYPE_FONTTYPE]  \O pitch e a família da fonte.
    e O caractere inicial deste nome desta fonte [pszFaceName] \Um ponteiro para uma string terminada em nulo que especifica o nome do tipo da fonte. 
    \O comprimento desta string não deve exceder 32 caracteres, incluindo o caractere nulo de terminação.
    devolvendo o número da fonte. \Se a função for bem-sucedida, o valor de retorno é um identificador para uma fonte lógica.
    \Se a função falhar, o valor de retorno será NULL.

Etapas para que se converta uma fração para um texto hexadecimal:
  Reassign o caractere inicial deste texto hexadecimal usando a magnitude desta fração.
  Copie bytes desde o endereçamento desta fração para o caractere inicial deste texto hexadecimal pela magnitude desta fração.
  Atribua o caractere inicial deste texto hexadecimal mais a magnitude desta fração menos 1 ao caractere final deste texto hexadecimal.

Etapas para que se converta uma fração para um número misto:
  Se o denominador desta fração for 0, atribua 0 ao número inteiro deste número misto; atribua 0 à proporção deste número misto; saia.
  Divida o numerador desta fração pelo denominador desta fração usando o número inteiro deste número misto e um resto.
  Atribua o resto e o denominador desta fração ao fração deste número misto.

Etapas para que se converta uma fração para uma string usando um número:
  \ converts para um decimal representation com "the número" of places
  Limpe a string.
  Se o número for menor do que 1, cancele.
  Atribua 10 a um value número.
  Raise o value para o número.
  Isole a fração.
  Se a fração for negativa, acione um detector; de-sign a fração.
  Multiplique o value pela fração.
  Zero preencha o value usando o número e posponha it para a string.
  Atribua a quantidade de caracteres desta string menos o número mais 1 a um byte#.
  Insira "." à string antes de o byte#.
  Se o conteúdo deste caractere inicial desta string for o ponto final, anteponha "0" para a string.
  Se o detector estiver ativo, anteponha "-" para a string.

Etapas para que se converta um texto hexadecimal para uma fração:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude desta fração, atribua 0 e 1 à proporção; saia.
  Copie bytes desde o caractere inicial deste texto hexadecimal para o endereçamento desta fração pela magnitude desta fração.

Etapas para que se converta um texto hexadecimal para um número:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude deste número, limpe o número; saia.
  Copie bytes desde o caractere inicial deste texto hexadecimal para o endereçamento destte número pela magnitude deste número.

Etapas para que se converta um lParam para um tecla:
  \ assumes lParam desde wm_char message
  Atribua o lParam à tecla.
  Desloque a tecla 16 bits para a direita .
  \ https://docs.microsoft.com/pt-br/windows/win32/inputdev/virtual-key-codes
  Conjuncione logicamente a tecla com 255. \11111111 ou FF
  Call "user32.dll" "MapVirtualKeyA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-mapvirtualkeya
  \Traduz (mapeia) um código de tecla virtual em um código de varredura ou valor de caractere, ou traduz um código de varredura em um código de tecla virtual.
    A tecla [uCode] \O código de chave virtual ou código de leitura de uma chave. 
    \Como esse valor é interpretado depende do valor do parâmetro uMapType.
    \A partir do Windows Vista, o byte alto do valor uCode pode conter 0xe0 ou 0xe1 para especificar o código de verificação estendida.
    e 1 [uMapType MAPVK_VSC_TO_VK]  \A tradução a ser executada. O valor deste parâmetro depende do valor do parâmetro uCode.
    \ Usando MAPVK_VSC_TO_VK, O parâmetro uCode é um código de varredura e é traduzido em um código de tecla virtual que não distingue entre as teclas esquerda e direita. Se não houver tradução, a função retorna 0.
    devolvendo a tecla. \O valor de retorno é um código de varredura, um código de chave virtual ou um valor de caractere, dependendo do valor de uCode e uMapType. 
    \Se não houver tradução, o valor de retorno é zero.
  Se a tecla NumLock não estiver ativada, cancele.
  Se a tecla for a tecla Insert, atribua a tecla zero do teclado numérico à tecla; saia.
  Se a tecla for a tecla Delete, atribua a numpad-period tecla à tecla; saia.
  Se a tecla for a tecla Home, atribua a tecla sete do teclado numérico à tecla; saia.
  Se a tecla for a tecla End, atribua a tecla End do teclado numérico à tecla; saia.
  Se a tecla for a tecla PgUp, atribua a tecla nove do teclado numérico à tecla; saia.
  Se a tecla for a tecla PgDn, atribua a tecla três do teclado numérico à tecla; saia.
  Se a tecla for a seta pra esquerda, atribua a tecla quatro do teclado numérico à tecla; saia.
  Se a tecla for a seta pra cima, atribua a tecla oito do teclado numérico à tecla; saia.
  Se a tecla for a seta pra direita, atribua a tecla seis do teclado numérico à tecla; saia.
  Se a tecla for a seta pra baixo, atribua a tecla dois do teclado numérico à tecla; saia.
  Se a tecla for a tecla Clear, atribua a tecla cinco do teclado numérico à tecla; saia.

Etapas para que se converta um lParam para uma localização:
  Separe o lParam a um word e uma segunda word.
  Atribua a word à coordenada Y desta localização.
  Atribua a segunda word à coordenada X desta localização.
  Multiplique a localização pelo quantidade de twips/pixel .

Etapas para que se converta um número misto para uma fração:
  Atribua o fração deste número misto à fração.
  Adicione o número inteiro deste número misto times o denominador desta fração para o numerador desta fração.

Etapas para que se converta uma cifra binária para uma cifra hexadecimal:
  Isole a cifra binária.
  Se a cifra binária for maior do que 9, adicione 7 para a cifra binária.
  Adicione 48 para a cifra binária.
  Atribua a cifra binária ao cifra hexadecimal.

Etapas para que se converta uma cifra hexadecimal para um texto hexadecimal:
  Isole a cifra hexadecimal.
  Limpe o texto hexadecimal.
  Se a quantidade de caracteres deste cifra hexadecimal for ímpar, anteponha o número zero para a cifra hexadecimal.
  Lance um subtexto sobre a cifra hexadecimal.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste caractere inicial deste subtexto para uma cifra binária.
    Desloque a cifra binária 4 bits para a esquerda.
    Adicione 1 para o caractere inicial deste subtexto.
    Converta o conteúdo deste caractere inicial deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Posponha a cifra binária para o texto hexadecimal.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta um número para um byte:
  Atribua o número ao byte.

Etapas para que se converta um endereçamento de caractere para uma string:
  Limpe a string.
  Se o endereçamento de caractere for inexistente, cancele.
  Isole o endereçamento de caractere.
  Comece. [a executar o código abaixo]
    Se o conteúdo deste endereçamento de caractere for o caractere null, cancele.
    Posponha o conteúdo deste endereçamento de caractere para a string.
    Adicione 1 para o endereçamento de caractere.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta um ponteiro e uma quantidade de caracteres para uma string:
  Limpe a string.
  Se o ponteiro for inexistente, cancele.
  Se a quantidade de caracteres for 0, cancele.
  Reassign o caractere inicial desta string usando a quantidade de caracteres.
  Copie bytes desde o ponteiro para o caractere inicial desta string pelo quantidade de caracteres.
  Atribua o caractere inicial desta string mais a quantidade de caracteres menos 1 ao caractere final desta string.

Etapas para que se converta um ponteiro para um texto hexadecimal;
Etapas para que se converta um número para um texto hexadecimal:
  Reassign o caractere inicial deste texto hexadecimal usando a magnitude deste número.
  Copie bytes desde o endereçamento deste número para o caractere inicial deste texto hexadecimal pela magnitude deste número.
  Atribua o caractere inicial deste texto hexadecimal mais a magnitude deste número menos 1 ao caractere final deste texto hexadecimal.

Etapas para que se converta um ponteiro para uma cifra hexadecimal;
Etapas para que se converta um número para uma cifra hexadecimal:
  Separe o número a um word e uma segunda word.
  Converta a word para a cifra hexadecimal.
  Converta a segunda word para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para a cifra hexadecimal.

Etapas para que se converta um ponteiro para uma string:
  Converta o ponteiro para a string como uma cifra hexadecimal.

Etapas para que se converta uns points para uns precises degrees:
  Atribua o points times 3840 dividido por 3600 ao precises degrees.

Etapas para que se converta uma position para um posicionamento absoluto usando uma caixa de texto:
  Se a caixa de texto for inexistente, limpe o posicionamento absoluto; saia.
  Atribua 0 ao posicionamento absoluto.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se o número da linha desta linha de texto for menor do que o número da linha desta position, adicione a quantidade de caracteres desta string desta linha de texto para o posicionamento absoluto; recomece.
  Adicione o número de coluna desta position para o posicionamento absoluto.

Etapas para que se converta uns precises degrees para uns points:
  Atribua os precises degrees times 3600 dividido por 3840 ao points.

Etapas para que se converta um texto de consulta para uma string:
  Limpe a string.
  Se o texto de consulta estiver em branco, cancele.
  Lance um subtexto sobre o texto de consulta.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste caractere inicial deste subtexto for o sinal de adição, posponha " " para a string; adicione 1 para o caractere inicial deste subtexto; recomece.
    Se o conteúdo deste caractere inicial deste subtexto não for o sinal de porcentagem, posponha o conteúdo deste caractere inicial deste subtexto para a string; adicione 1 para o caractere inicial deste subtexto; recomece.
    Se a quantidade de caracteres deste subtexto for menor do que 3, cancele.
    Adicione 1 para o caractere inicial deste subtexto.
    Converta o conteúdo deste caractere inicial deste subtexto para uma cifra binária.
    Desloque a cifra binária 4 bits para a esquerda.
    Adicione 1 para o caractere inicial deste subtexto.
    Converta o conteúdo deste caractere inicial deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Adicione 1 para o caractere inicial deste subtexto.
    Posponha a cifra binária para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta umas linhas des textos para uma string:
  Limpe a string.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos.
    Se a linha de texto for inexistente, cancele.
    Posponha a string deste linha de texto para a string.
    Se o conteúdo deste caractere final desta string é o retorno de carro, posponha a quebra de linha para a string; recomece.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta umas linhas des textos para uma string (sem adicionar quebras de linha):
  Limpe a string.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos.
    Se a linha de texto for inexistente, cancele.
    Posponha a string deste linha de texto para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta uma string para um detector:
  Se a string for "s", acione o detector; saia.
  Se a string for "sim", acione o detector; saia.
  Se a string for "y", acione o detector; saia.
  Se a string for "yes", acione o detector; saia.
  [Se o texto informado não for nenhuma dessas opções, então:] 
  Desative o detector.

Etapas para que se converta uma string para uma fração:
  Limpe a fração.
  Se a string estiver em branco, cancele.
  Se a string for algum tipo de integer, converta a string para o numerador desta fração; saia.
  Lance um subtexto sobre a string.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Separe o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto estiver em branco, atribua o subtexto à fração subtexto.
  Separe a fração subtexto a um numerador subtexto e um denominador subtexto usando o slash byte.
  Converta o integer subtexto para um número inteiro.
  Converta o numerador subtexto para um numerador número.
  Converta o denominador subtexto para um denominador número.
  Se o número inteiro for negativo, cancele.
  Se o numerador número for negativo, cancele.
  Se o denominador número for negativo, cancele.
  Se o denominador número for 0, cancele.
  Se o número inteiro não for 0, adicione o denominador número times o número inteiro para o numerador número.
  Atribua o numerador número ao numerador desta fração.
  Atribua o denominador número ao denominador desta fração.
  Se o conteúdo deste caractere inicial desta string for o hífem, negate a fração.

Etapas para que se converta uma string para uma cifra hexadecimal:
  Limpe a cifra hexadecimal.
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste caractere inicial deste subtexto para uma segunda cifra hexadecimal.
    Posponha a segunda cifra hexadecimal para a cifra hexadecimal.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta uma string para um número:
  Atribua 0 ao número.
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, pare.
    Multiplique o número por 10.
    Atribua o conteúdo deste caractere inicial deste subtexto a um segundo número.
    Subtraia 48 desde o segundo número.
    Adicione o segundo número para o número.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  Se o conteúdo deste caractere inicial desta string for o hífem, negate o número.

Etapas para que se converta uma string para um número entre um segundo número e um terceiro número:
  Converta a string para o número.
  Limite o número para o segundo número e o terceiro número.

Etapas para que se converta uma string para um ponteiro:
  \ presume que o ponteiro está em cifra binária format
  Converta a string como uma cifra hexadecimal para um texto hexadecimal.
  Esvazie o ponteiro.
  Lance um subtexto sobre o texto hexadecimal.
  Atribua 24 a um contagem de deslocamentos.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se a contagem de deslocamentos for menor do que 0, cancele.
    Atribua o conteúdo deste caractere inicial deste subtexto a um número.
    Desloque o número para a esquerda a contagem de deslocamentos.
    Disjuncione logicamente o ponteiro como um número com o número.
    Adicione 1 para o caractere inicial deste subtexto.
    Subtraia 8 desde a contagem de deslocamentos.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta uma string para um texto de consulta:
  Limpe o texto de consulta.
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
  Se o subtexto estiver em branco, pare.
    Converta o conteúdo deste caractere inicial deste subtexto para um query byte.
    Posponha o query byte para o texto de consulta.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta uma string para umas linhas des textos:
  Lance um percorredor sobre a string.
  Comece. [a executar o código abaixo]
    Mova o percorredor (caixa de texto file rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma linha de texto usando o segmento inicial deste percorredor.
    Posponha a linha de texto para as linhas des textos.
    Se o conteúdo deste caractere final desta string desta linha de texto for a quebra de linha [LF], atribua o retorno de carro [CR] ao conteúdo deste caractere final desta string desta linha de texto. 
    \ *Rotina nova criada pelo Dahn para abranger linhas que terminam apenas com um LF
  Recomece. [percorra novamente o código acima]
  Renumere as linhas des textos.

Etapas para que se converta uma string para um UUID:
  Converta a string para uma string composta de caracteres amplos e Anexe o caractere NULL.
  Call "ole32.dll" "CLSIDFromString" com \ https://docs.microsoft.com/pt-br/windows/win32/api/combaseapi/nf-combaseapi-clsidfromstring
  \Converte uma seqüência de caracteres gerada pela função StringFromCLSID de volta pro CLSID original.
    O caractere inicial desta string composta de caracteres amplos [lpsz] \A representação da seqüência de caracteres do CLSID.
    e O endereçamento deste UUID. [pclsid] \Um ponteiro para o CLSID.
    \Esta função pode retornar o valor de retorno padrão -2147024809 (E_INVALIDARG), bem como os seguintes valores.
    \0 (NOERROR) -> O CLSID foi obtido com sucesso.
    \-2147221005 (CO_E_CLASSSTRING) -> A string da classe foi formatada incorretamente.
    \-2147221164 (REGDB_E_CLASSNOTREG) -> O CLSID correspondente à seqüência de classe não foi encontrado no registro.
    \-2147221168 (REGDB_E_READREGDB) -> Não foi possível abrir o registro para leitura.
    
Etapas para que se converta uma string para uma string composta de caracteres amplos:
  Limpe a string composta de caracteres amplos.
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Posponha o conteúdo deste caractere inicial deste subtexto para a string composta de caracteres amplos.
    Posponha o caractere null para a string composta de caracteres amplos.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta uma string para uma string composta de caracteres amplos e Anexe o caractere NULL:
  Converta a string para a string composta de caracteres amplos.
  Anexe o caractere NULL a string composta de caracteres amplos.

Etapas para que se converta uma URL para uma URL simplificada:
  Isole a URL.
  Anexe o caractere NULL a URL.
  Atribua a magnitude desses URL_COMPONENTS ao dwStructSize destes URL_COMPONENTS.
  Atribua 1 ao dwSchemeLength destes URL_COMPONENTS.
  Atribua 1 ao dwHostNameLength destes URL_COMPONENTS.
  Atribua 1 ao dwUrlPathLength destes URL_COMPONENTS.
  Atribua 1 ao dwExtraInfoLength destes URL_COMPONENTS.
  Call "wininet.dll" "InternetCrackUrlA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wininet/nf-wininet-internetcrackurla
  \"Racha" uma URL em suas partes componentes.
    O caractere inicial desta URL [lpszUrl] \ Ponteiro para uma string que contém a URL canônica a ser quebrada.
    e 0 [dwUrlLength] \ Tamanho da string lpszUrl, em TCHARs, ou zero se lpszUrl for uma string ASCIIZ.
    e 0 [dwFlags] \ Controla a operação.
    e O endereçamento destes URL_COMPONENTS [lpUrlComponents] \Pointer to a URL_COMPONENTS structure that receives the URL components.
    devolvendo um número. \Retorna TRUE se a função for bem-sucedida ou FALSE caso contrário.
  Converta o lpszScheme destes URL_COMPONENTS e o dwSchemeLength destes URL_COMPONENTS para o nome do protocolo desta URL simplificada.
  Converta o lpszHostName destes URL_COMPONENTS e o dwHostNameLength destes URL_COMPONENTS para o nome de host desta URL simplificada.
  Converta o lpszUrlPath destes URL_COMPONENTS e o dwUrlPathLength destes URL_COMPONENTS para o endereço de recurso desta URL simplificada.
  Converta o lpszExtraInfo destes URL_COMPONENTS e o dwExtraInfoLength destes URL_COMPONENTS para a parâmetro de consulta desta URL simplificada.
  Atribua o nPort destes URL_COMPONENTS ao número de porta desta URL simplificada.

Etapas para que se converta um word para uma cifra hexadecimal:
  Separe a word a um byte e um segundo byte.
  Converta o byte para a cifra hexadecimal.
  Converta o segundo byte para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para a cifra hexadecimal.

Uma coordenada é uns twips.

Etapas para que se copie um evento para um segundo evento: \ mudar o "segunda" aqui
  Se o evento for inexistente, esvazie o segundo evento; saia.
  Crie o segundo evento.
  Atribua a categoria deste evento à categoria deste segundo evento.
  Atribua o detector de tecla Shift deste evento ao detector de tecla Shift deste segundo evento.
  Atribua o detector de tecla Ctrl deste evento ao detector de tecla Ctrl deste segundo evento.
  Atribua o detector de tecla Alt deste evento ao detector de tecla Alt deste segundo evento.
  Atribua a localização deste evento à localização deste segundo evento.
  Atribua a tecla deste evento à tecla deste segundo evento.
  Atribua o byte deste evento ao byte deste segundo evento.

Etapas para que se copie um gpBitmap Para um segundo gpBitmap: \verificar
  Se o gpBitmap for inexistente, esvazie o segundo gpBitmap; saia.
  Call "gdiplus.dll" "GdipCloneBitmapAreaI" com \https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusheaders/nf-gdiplusheaders-bitmap-clone(int_int_int_int_pixelformat)
    0 [x] \Valor longo que especifica a coordenada x do canto superior esquerdo do retângulo que especifica a parte deste bitmap a ser copiada.
    e 0 [y] \Valor longo que especifica a coordenada y do canto superior esquerdo do retângulo que especifica a parte deste bitmap a ser copiada.
    e A largura deste gpBitmap [width] \Valor longo que especifica a largura do retângulo que especifica a parte deste bitmap a ser copiada.
    e A altura deste gpBitmap [height] \Valor longo que especifica a altura do retângulo que especifica a parte da imagem a ser copiada.
    e 0 [format = PixelFormatDontCare]  \Valor inteiro longo que especifica o formato de pixel do novo bitmap.
    \O valor 0 não especifica o formato do pixel.
    \https://docs.microsoft.com/pt-br/windows/win32/gdiplus/-gdiplus-constant-image-pixel-format-constants
    e O gpBitmap [*srcBitmap] \Ponteiro para o objeto Bitmap de origem.
    e O endereçamento deste segundo gpBitmap. [**dstBitmap] \Ponteiro para uma variável DWORD que recebeu um ponteiro para o objeto Bitmap clonado.
    \Este método retorna um ponteiro para o novo objeto Bitmap.

Etapas para que se copie as propriedades of uma caixa de texto Para um segundo caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se o segundo caixa de texto for inexistente, cancele.
  Atribua a caixa desta caixa de texto à caixa deste segundo caixa de texto.
  Atribua a origem desta caixa de texto à origem deste segundo caixa de texto.
  Atribua a cor do pincel desta caixa de texto à cor do pincel desta segundo caixa de texto.
  Atribua a fonte desta caixa de texto à fonte deste segundo caixa de texto.
  Atribua o alinhamento desta caixa de texto ao alinhamento deste segundo caixa de texto.
  Copie as linhas des textos desta caixa de texto para as linhas des textos deste segundo caixa de texto.
  Atribua a margem desta caixa de texto à margem deste segundo caixa de texto.
  Atribua a scale desta caixa de texto à scale deste segundo caixa de texto.
  Atribua o detector de quebra de texto desta caixa de texto ao detector de quebra de texto deste segundo caixa de texto.
  Atribua o detector de rolagem horizontal desta caixa de texto ao detector de rolagem horizontal deste segundo caixa de texto.
  Atribua o detector de rolagem vertical desta caixa de texto ao detector de rolagem vertical deste segundo caixa de texto.
  Atribua a seleção desta caixa de texto à seleção deste segundo caixa de texto.
  Atribua o detector de alteração desta caixa de texto ao detector de alteração deste segundo caixa de texto.
  Atribua o última operação desta caixa de texto ao última operação deste segundo caixa de texto.
  \ dont copie desfeitos e refeitos

O número de cópias é um número.

Etapas para que se copie uma imagem Para uma segunda imagem:
  Se a imagem for inexistente, esvazie a segunda imagem; saia.
  Aloque memória para a segunda imagem.
  Atribua a caixa desta imagem à caixa desta segunda imagem.
  Atribua a caixa intacta desta imagem à caixa intacta desta segunda imagem.
  Atribua o grayscale detector desta imagem ao grayscale detector desta segunda imagem.
  Atribua o mirror detector desta imagem ao mirror detector desta segunda imagem.
  Atribua o ângulo de rotação desta imagem ao ângulo de rotação desta segunda imagem.
  Atribua os data desta imagem aos data desta segunda imagem.
  Copie o gpBitmap desta imagem ao gpBitmap desta segunda imagem.

Etapas para que se copie um polígono Para um segundo polígono:
  Se o polígono for inexistente, esvazie o segundo polígono; saia.
  Aloque memória para o segundo polígono.
  Copie os vértices deste polígono aos vértices deste segundo polígono.

Etapas para que se copie uma linha de texto Para uma segunda linha de texto:
  Se a linha de texto for inexistente, esvazie a segunda linha de texto; saia.
  Aloque memória para o segunda linha de texto.
  Atribua a número da linha desta linha de texto ao número da linha desta segunda linha de texto.
  Atribua a string desta linha de texto à string desta segunda linha de texto.

Etapas para que se copie umas linhas des textos Para uns segunda linhas des textos:
  Destrua a segunda linhas des textos.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos.
    Se a linha de texto for inexistente, cancele.
    Copie a linha de texto a uma segunda linha de texto.
    Posponha a segunda linha de texto para a segunda linhas des textos.
  Recomece. [percorra novamente o código acima]

Etapas para que se copie uma caixa de texto Para um segundo caixa de texto:
  Se a caixa de texto for inexistente, esvazie o segundo caixa de texto; saia.
  Aloque memória para o segundo caixa de texto.
  Copie as propriedades of a caixa de texto para o segundo caixa de texto.

Etapas para que se copie um vértice Para um segundo vértice:
  Se o vértice for inexistente, esvazie o segundo vértice; saia.
  Aloque memória para o segundo vértice.
  Atribua a coordenada X deste vértice à coordenada X deste segundo vértice.
  Atribua a coordenada Y deste vértice à coordenada Y deste segundo vértice.

Etapas para que se copie uns vértices Para uns segundo vértices:
  Destrua os segundo vértices.
  Comece. [a executar o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Copie o vértice a um segundo vértice.
    Posponha o segundo vértice para o segundo vértices.
  Recomece. [percorra novamente o código acima]

Uma contagem é um número.

Um contador é um número.

Etapas para que se crie o connect handle of uma requisição WinHTTP using uma URL simplificada:
  Se a requisição WinHTTP for inexistente, cancele.
  Converta o nome de host desta URL simplificada a uma string composta de caracteres amplos denominado wide host nome e Anexe o caractere NULL.
  Call "WinHTTP.dll" "WinHttpConnect" com \ https://docs.microsoft.com/pt-br/windows/win32/api/WinHTTP/nf-WinHTTP-winhttpconnect
    \A função WinHttpConnect faz 2 coisas:
    \1. Especifica o servidor de destino inicial de uma solicitação HTTP e;
    \2. Retorna um identificador de conexão HINTERNET de uma sessão HTTP para esse destino inicial.
    O número identificador de sessão deste número identificador de requisição desta requisição WinHTTP [hSession] 
    \Um identificador de sessão WinHTTP HINTERNET válido retornado por uma chamada anterior para WinHttpOpen.
    e o caractere inicial deste wide host nome [pswzServerName] 
    \Ponteiro para uma string terminada em nulo que contém o nome do host de um servidor HTTP. 
    \Como alternativa, a string pode conter o endereço IP do site em ASCII, por exemplo, 10.0.1.45. 
    \Observe que WinHttp não aceita nomes de host internacionais sem convertê-los primeiro para Punycode.
    e o número de porta desta URL simplificada [nServerPort] \ 80 = http / 443 = https
    \Inteiro não assinado que especifica a porta TCP / IP no servidor ao qual a conexão é feita. Este parâmetro pode ser qualquer número de porta TCP / IP válido
    e 0 [dwReserved] \Este parâmetro é reservado e seu valor deve ser igual 0.
    devolvendo o número identificador de conexão desta requisição WinHTTP.
    \Retorna um identificador de conexão válido para a sessão HTTP se a conexão for bem-sucedida ou NULL caso contrário.
  Se o número identificador de conexão desta requisição WinHTTP for 0, atribua "Erro. Não foi possível estabelecer uma conexão." ao erro do fluxo de entrada/saída; saia.

Etapas para que se crie um console:
  Aloque memória para o console.
  Atribua a cor de borda de janela à cor da borda deste console.
  Atribua a cor preta à cor de preenchimento deste console.
  Atribua a caixa desta tela à caixa deste console.
  Atribua a caixa desta tela a uma caixa.
  Subtraia a altura desta fonte padrão desde a coordenada Y do canto inferior direito desta caixa.
  Atribua a altura desta caixa dividido pela altura desta fonte padrão times a altura desta fonte padrão a uma altura.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura à coordenada Y do canto inferior direito desta caixa.
  Centralize a caixa na caixa desta tela (verticalmente).
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada X do canto superior esquerdo desta caixa.
  Subtraia a coordenada Y do canto superior esquerdo desta caixa desde a coordenada X do canto inferior direito desta caixa.
  Crie a caixa de texto deste console.
  Atribua a caixa à caixa desta caixa de texto deste console.
  Ligue o detector de quebra de texto desta caixa de texto deste console.
  Desative o detector de rolagem horizontal desta caixa de texto deste console.
  Ligue o detector de rolagem vertical desta caixa de texto deste console.
  Atribua a altura desta fonte padrão ao malha deste console.
  Multiplique o número X deste malha deste console por 2.

O nome do provedor criptográfico é uma string.
  
Etapas para que se crie um crypt session com uma passphrase string:
  \ define o erro do fluxo de entrada/saída em caso de falha
  Limpe o erro do fluxo de entrada/saída.
  Aloque memória para o crypt session.
  Atribua "Microsoft Enhanced Cryptographic Provider v1.0" ao nome do provedor criptográfico. [MS_ENHANCED_PROV] 
  \ Documentação: -> https://docs.microsoft.com/pt-br/windows/win32/seccertenroll/cryptoapi-cryptographic-service-providers  
  Call "advapi32.dll" "CryptAcquireContextA" com \usada para adquirir um identificador de um contêiner de chave específico do provedor de serviços criptográficos (CSP). 
  \ Documentação: -> https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta
    O endereçamento deste hCryptProv deste crypt session [*phProv] \Um ponteiro para um identificador de um provedor de serviços criptográficos (CSP). 
    e 0 [szContainer] \O nome do contêiner de chave. Na maioria dos casos, deve ser definido como NULL.
    e o caractere inicial deste nome do provedor criptográfico [szProvider]  
    \Uma string terminada em nulo que contém o nome do CSP a ser usado.
    \Se este parâmetro for NULL, o provedor padrão do usuário será usado. 
    \Para obter mais informações, consulte Contextos do provedor de serviços criptográficos.
    \Para obter uma lista de provedores criptográficos disponíveis, consulte Nomes de provedores criptográficos.
    e 1 [dwProvType PROV_RSA_FULL]  \Especifica o tipo de provedor a ser adquirido. 
    \Os tipos de provedor definidos são discutidos em Tipos de provedor criptográfico.
    \O tipo de provedor PROV_RSA_FULL oferece suporte a assinaturas digitais e criptografia de dados. 
    \É considerado um CSP de propósito geral. O algoritmo de chave pública RSA é usado para todas as operações de chave pública.
    e -268435456 [dwFlags CRYPT_VERIFYCONTEXT]  \Valores de sinalização. 
    \Este parâmetro geralmente é definido como zero, mas existe uma gama de valores possíveis.
    \CRYPT_VERIFYCONTEXT
    \Esta opção se destina a aplicativos que usam chaves efêmeras ou aplicativos que não requerem acesso a chaves privadas persistentes, 
    \como aplicativos que executam apenas hash, criptografia e verificação de assinatura digital. 
    \Apenas os aplicativos que criam assinaturas ou decriptografam mensagens precisam de acesso a uma chave privada. 
   \Na maioria dos casos, é esse sinalizador deve ser escolhido.
    devolvendo um número resultante. \Se a função for bem-sucedida, ela retornará um valor diferente de zero (VERDADEIRO).
    \Se a função falhar, ele retorna zero (FALSO).
  Se o número resultante for 0, atribua "Erro. Não foi possível adquirir o identificador do contêiner de chave do provedor de serviços criptográficos ." ao erro do fluxo de entrada/saída; destrua o crypt session; saia.
  \ criação do hash
  Call "advapi32.dll" "CryptCreateHash" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-cryptcreatehash
    \A função CryptCreateHash inicializa o hash de um fluxo de dados. 
    \Ele cria e retorna ao aplicativo de chamada um identificador para um objeto hash do provedor de serviços de criptografia (CSP).
    o hCryptProv deste crypt session [hProv] \Um identificador para um CSP criado por uma chamada feita para a função CryptAcquireContext acima.
    e 32771 [Algid CALG_MD5]  \Um valor ALG_ID que identifica o algoritmo de hash a ser usado. 
    \O tipo de dados ALG_ID especifica um identificador de algoritmo. Os parâmetros desse tipo de dados são passados para a maioria das funções na CryptoAPI.
    \Os valores válidos para este parâmetro variam, dependendo do CSP usado.
    \CALG_MD5 é um Algoritmo de hash MD5. Este algoritmo é suportado pelo Microsoft Base Cryptographic Provider.
    e 0 [hKey] \A chave para o hash é passada neste parâmetro. Para algoritmos não chaveados, este parâmetro deve ser definido como zero.
    e 0 [dwFlags] \O seguinte valor de sinalizador é definido:
    \Valor CRYPT_SECRETDIGEST (0x00000001)  Significado: Este sinalizador não é usado.
    e o endereçamento deste HCRYPTHASH deste crypt session [*phHash] \O endereço para o qual a função copia um identificador para o novo objeto hash.
    devolvendo o número resultante. \Se a função for bem-sucedida, ela retornará TRUE.
    \Se a função falhar, ele retornará FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível criar o hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; saia.
  \ hash passphrase
  Call "advapi32.dll" "CryptHashData" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-crypthashdata
    \A função CryptHashData adiciona dados a um objeto hash especificado. 
    \ Esta função e CryptHashSessionKey podem ser chamadas várias vezes para calcular o hash de fluxos de dados longos ou descontínuos.
    O HCRYPTHASH deste crypt session [hHash] \O número dentificador do objeto hash.
    e O caractere inicial desta passphrase [*pbData] \Um ponteiro para um buffer que contém os dados a serem adicionados ao objeto hash.
    e A quantidade de caracteres desta passphrase [dwDataLen] \Número de bytes de dados a serem adicionados. 
    \Deve ser zero se o sinalizador CRYPT_USERDATA estiver definido.
    e 0 [dwFlags] \Todos os provedores criptográficos da Microsoft ignoram esse parâmetro. 
    \Para qualquer CSP que não ignore este parâmetro, se este sinalizador for definido, o CSP solicita que o usuário insira os dados diretamente. 
   \Esses dados são adicionados ao hash. O aplicativo não tem permissão para acessar os dados. 
    \Este sinalizador pode ser usado para permitir que o usuário insira um PIN no sistema.
    devolvendo o número resultante. \Se a função for bem-sucedida, o valor de retorno será TRUE.
    \Se a função falhar, o valor de retorno será FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível adicionar dados ao hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; saia.
 \ gera a chave da sessão criptográfica
  Call "advapi32.dll" "CryptDeriveKey" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey
  \A função CryptDeriveKey gera chaves de sessão criptográficas derivadas de um valor de dados base. 
  \Esta função garante que quando o mesmo provedor de serviços criptográficos (CSP) e algoritmos são usados, as chaves geradas a partir da mesma base de dados são idênticas. 
  \Os dados da base podem ser uma senha ou quaisquer outros dados do usuário.
    O hCryptProv deste crypt session [hProv] \Um identificador hCryptProv de um CSP criado por uma chamada para CryptAcquireContext.
    e 26625 [CALG_RC4  Stream Cipher Algid] \Uma estrutura ALG_ID que identifica o algoritmo de criptografia simétrica para o qual a chave deve ser gerada. 
    \Os algoritmos disponíveis provavelmente serão diferentes para cada CSP. 
    \Para obter mais informações sobre qual identificador de algoritmo é usado pelos diferentes provedores para as especificações de chave AT_KEYEXCHANGE e AT_SIGNATURE, consulte ALG_ID. 
    e O HCRYPTHASH deste crypt session [hBaseData] \Um identificador para um objeto hash que foi alimentado com os dados de base exatos.
    e 8388608 [dwFlags Key length: 128 bit]  \Especifica o tipo de chave gerada. Os tamanhos de uma chave de sessão podem ser definidos quando a chave é gerada. O tamanho da chave, representando o comprimento do módulo da chave em bits, é definido com os 16 bits superiores deste parâmetro. Assim, se uma chave de sessão RC4 de 128 bits deve ser gerada, o valor 0x00800000 é combinado com qualquer outro valor predefinido dwFlags com um operati bit a bit OR
    e O endereçamento deste hCryptKey desta crypt session  [phKey] \Um ponteiro para uma variável HCRYPTKEY para receber o endereço do identificador da chave recém-gerada.
    devolvendo o número resultante. \Se a função for bem-sucedida, o valor de retorno será TRUE.
    \Se a função falhar, o valor de retorno será FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível derivar a chave da sessão." ao erro do fluxo de entrada/saída; destrua o crypt session; saia.

Etapas para que se crie uma díade:
  Aloque memória para a díade.

Etapas para que se crie um evento:
  Aloque memória para o evento.

Etapas para que se crie uma fonte info usando uma fonte:
  Crie a fonte info usando a fonte (basic data).
  Crie as fonte larguras desta fonte info usando a fonte.

Etapas para que se crie uma fonte info usando uma fonte (basic data):
  Aloque memória para a fonte info.
  Atribua a fonte ao fonte desta fonte info.
  Obtenha um OutlineTextmetric usando a fonte.
  Atribua 32 aos flags deste fonte info. \ poderia ser atualizado com mais uma informação
  Atribua o tmInternalLeading destes otmTextMetrics deste OutlineTextmetric ao internal leading desta fonte info.
  Atribua o otmEMSquare deste OutlineTextmetric ao emsquare desta fonte info.
  Atribua o tmAscent deste otmTextMetrics deste OutlineTextmetric ao ascent desta fonte info.
  Atribua - o tmDescent deste otmTextMetrics deste OutlineTextmetric ao descent desta fonte info.
  Atribua o otmsCapEmHeight deste OutlineTextmetric ao capheight desta fonte info.
  Atribua o otmItalicAngle deste OutlineTextmetric ao italicangle desta fonte info.
  Atribua 0 ao StemV desta fonte info. \ dont know where para obtenha this desde
  Atribua o otmrcFontBox deste OutlineTextmetric ao fonte caixa desta fonte info.

Etapas para que se crie uma fonte info usando uma fonte e uma string:
  \ cria larguras baseadas nos caracteres da string
  Crie a fonte info usando a fonte (basic data).
  Crie as fonte larguras desta fonte info usando a fonte e a string.

Etapas para que se crie umas fonte larguras usando uma fonte:
  Aloque memória para a fonte larguras.
  Atribua a fonte à fonte destas fonte larguras.
  Atribua 256 à contagem destas fonte larguras.
  Assign o data destes fonte larguras usando a contagem destas fonte larguras times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando a fonte.
  Assign um original endereço do ABC usando 256 times a magnitude desse ABC.
  Call "gdi32.dll" "GetCharABCWidthsA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsa
    \ A função GetCharABCWidths recupera as larguras, em unidades lógicas, de caracteres consecutivos em um intervalo especificado da fonte TrueType atual. 
    \ Esta função é só funciona com fontes TrueType.
    O memory canvas [hDC] \ Um identificador para o contexto do dispositivo.
    e 0 [wFirst] \ O primeiro caractere do grupo de caracteres consecutivos da fonte atual.
    e 255 [wLast] \O último caractere no grupo de caracteres consecutivos da fonte atual.
    e o original endereço do ABC. [lpABC] \ Um ponteiro para uma matriz de estruturas ABC que recebe as larguras dos caracteres, em unidades lógicas. 
    \Esta matriz deve conter, no mínimo, a mesma quantidade estruturas ABC que a quantidade de caracteres no intervalo especificado pelos parâmetros uFirstChar e uLastChar.
    \ Para obter mais informações, veja o site abaixo: 
    \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/ns-wingdi-ABC
  Destrua o número da fonte of o memory canvas.
  Atribua o original endereço do ABC a um endereço do ABC.
  Atribua o data destes fonte larguras a um endereço numérico.
  Comece. [a executar o código abaixo]
    Se um contador estiver past 256, pare.
    Atribua o abcA deste endereço do ABC ao conteúdo deste endereço numérico .
    Adicione o abcB deste endereço do ABC para o conteúdo deste endereço numérico .
    Adicione o abcC deste endereço do ABC para o conteúdo deste endereço numérico .
    Adicione a magnitude deste ABC para o endereço do ABC.
    Adicione a magnitude deste número para o endereço numérico.
  Recomece. [percorra novamente o código acima]
  Unassign o original endereço do ABC.

Etapas para que se crie uns fonte larguras usando uma fonte e uma string:
  Aloque memória para a fonte larguras.
  Atribua a fonte à fonte destas fonte larguras.
  Atribua a quantidade de caracteres desta string à contagem destas fonte larguras.
  Se a string estiver em branco, cancele.
  Atribua a magnitude desse GcpResults ao lStructSize destes GcpResults.
  Atribua a quantidade de caracteres desta string ao nglyphs destes GcpResults.
  Assign o lpDX destes GcpResults usando a quantidade de caracteres desta string times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando a fonte.
  Call "gdi32.dll" "GetCharacterPlacementA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementa
    \A função GetCharacterPlacement recupera informações sobre uma string de caracteres, tais como larguras de caracteres, posicionamento de circunflexo, ordenação dentro da string e renderização de glifo.
    \A função copia as informações para a estrutura GCP_RESULTS especificada ou para uma ou mais matrizes especificadas pela estrutura.
    \Embora essa função já tenha sido adequada para trabalhar com cadeias de caracteres, 
    \ a necessidade de trabalhar com um número crescente de linguagens e sistemas de escrita a tornou obsoleta. 
    \Ela foi substituído pela funcionalidade do módulo Uniscribe. Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/Intl/uniscribe
    O memory canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O caractere inicial desta string [lpString] \Um ponteiro para a sequência de caracteres a ser processada. 
    \A string acima não precisa ser terminada em zero, pois nCount especifica o comprimento da string.
    e A quantidade de caracteres desta string [nCount] \O comprimento da string apontada por lpString.
    e 0 [nMexExtent] \A extensão máxima (em unidades lógicas) na qual a string é processada. 
    \Os caracteres que, se processados, excederiam essa extensão são ignorados. 
     \Os cálculos para qualquer pedido obrigatório ou matrizes de glifos aplicam-se apenas aos caracteres incluídos. 
     \ Este parâmetro é usado apenas se o valor GCP_MAXEXTENT for especificado no parâmetro dwFlags.
     \ Conforme a função processa a string de entrada, cada caractere e sua extensão são adicionados à saída, à extensão e à outras matrizes
     \  apenas se a extensão total ainda não tiver excedido o máximo. Assim que o limite for atingido, o processamento será interrompido.
    e O endereçamento deste GcpResults [lpResults] \Um ponteiro para uma estrutura GCP_RESULTS que recebe os resultados da função.
    e 0. [dwFlags] \ serve para especificar como processar a string nas matrizes necessárias. nesse caso não foi especificado (valor nulo/ inválido)
  Destrua o número da fonte of o memory canvas.
  Atribua o lpDX destes GcpResults ao data destes fonte larguras.

Etapas para que se crie um gpBitmap usando um trecho:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "GlobalAlloc" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globalalloc
    \Aloca o número especificado de bytes do heap.
  2 [uFlags GMEM_MOVEABLE] \Os atributos de alocação de memória. Se zero for especificado, o padrão é GMEM_FIXED.
  \GMEM_MOVEABLE = 0x0002
   \Aloca memória móvel. Os blocos de memória nunca são movidos na memória física, mas podem ser movidos dentro do heap padrão.
    \O valor de retorno é um identificador para o objeto de memória. Para converter o identificador em um ponteiro, use a função GlobalLock.
    \Este valor não pode ser combinado com GMEM_FIXED.
    e A quantidade de caracteres deste trecho [dwBytes] \O número de bytes a serem alocados. 
    \Se este parâmetro for zero e o parâmetro uFlags especificar GMEM_MOVEABLE, 
    \a função retornará um identificador para um objeto de memória que está marcado como descartado.
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno será um identificador para o objeto de memória recém-alocado.
    \Se a função falhar, o valor de retorno será NULL. 
    \A função GlobalLock bloqueia um objeto de memória global e aumenta a contagem de bloqueios em um. 
    \A função GlobalUnlock o desbloqueia e diminui a contagem de bloqueios em um. 
    \Para obter a contagem de bloqueios de um objeto de memória global, use a função GlobalFlags.
  Call "kernel32.dll" "GlobalLock" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globallock
    \Bloqueia um objeto de memória global e retorna um ponteiro para o primeiro byte do bloco de memória do objeto.
    \Observação: As funções globais têm maior sobrecarga e fornecem menos recursos do que outras funções de gerenciamento de memória. 
    \Novos aplicativos devem usar as funções de heap, a menos que a documentação indique que uma função global deve ser usada.
    O número identificador [hMem] \Um identificador para o objeto de memória global. Nesse caso o identificador é número identificador retornado pela função GlobalAlloc .
    devolvendo um ponteiro. \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o primeiro byte do bloco de memória.
    \Se a função falhar, o valor de retorno será NULL.
    \Observações
    \As estruturas de dados internas para cada objeto de memória incluem uma contagem de bloqueio que é inicialmente zero. 
    \Para objetos de memória móvel, GlobalLock aumenta a contagem em um e a função GlobalUnlock diminui a contagem em um. 
    \Cada chamada bem-sucedida que um processo faz ao GlobalLock para um objeto deve ser correspondida por uma chamada correspondente ao GlobalUnlock. 
    \A memória bloqueada não será movida ou descartada, a menos que o objeto de memória seja realocado usando a função GlobalReAlloc. 
    \O bloco de memória de um objeto de memória bloqueado permanece bloqueado até que sua contagem de bloqueios diminua para zero, momento em que pode ser movido ou descartado.
  Copie bytes desde o caractere inicial deste trecho para o ponteiro pelo quantidade de caracteres deste trecho.
  Call "kernel32.dll" "GlobalUnlock" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globalunlock
    \Diminui a contagem de bloqueios associada a um objeto de memória que foi alocado com GMEM_MOVEABLE. 
    \Esta função não tem efeito em objetos de memória alocados com GMEM_FIXED.
    O número identificador. [hMem] \Um identificador para o objeto de memória global. Nese caso o identificador é número identificador retornado pela função GlobalAlloc .
    \Se o objeto de memória ainda estiver bloqueado após diminuir a contagem de bloqueios, o valor de retorno será um valor diferente de zero. 
    \Se o objeto de memória for desbloqueado após diminuir a contagem de bloqueios, a função retornará zero e GetLastError retornará 0 (NO_ERROR).
    \Um processo não deve depender do valor de retorno para determinar o número de vezes que ele deve subsequentemente chamar GlobalUnlock para um objeto de memória.
  Call "ole32.dll" "CreateStreamOnHGlobal" com \ https://docs.microsoft.com/pt-br/windows/win32/api/combaseapi/nf-combaseapi-createstreamonhglobal
    \A função CreateStreamOnHGlobal cria um objeto de fluxo que usa um identificador de memória HGLOBAL para armazenar o conteúdo do fluxo. 
    \Este objeto é a implementação da interface IStream fornecida por OLE.
    \O objeto de fluxo retornado oferece suporte para leitura e gravação, não é transacionado e não oferece suporte para bloqueio de região. 
    \O objeto chama a função GlobalReAlloc para aumentar o bloco de memória conforme necessário.
    \Dica: Considere o uso da função SHCreateMemStream, que produz melhor desempenho,
    O número identificador [hGlobal] \Um identificador de memória alocado pela função GlobalAlloc ou, se NULL, um novo identificador deve ser alocado. 
    \O identificador deve ser alocado como móvel e não descartável.
    e 1 [fDeleteOnRelease = TRUE] \Um valor que indica se o identificador subjacente para este objeto de fluxo deve ser liberado automaticamente quando o objeto de fluxo é liberado. 
    \Se definido como FALSE, o chamador deve liberar o hGlobal após a versão final. 
    \Se definido como TRUE, a versão final irá liberar automaticamente o identificador subjacente.
    e O endereçamento desse istream. [*ppstm] \O endereço da variável de ponteiro IStream*  (LPSTREAM) que recebe o ponteiro de interface para o novo objeto de fluxo. Seu valor não pode ser NULL.
    \Observações
    \Se hGlobal for NULL, a função aloca um novo identificador de memória e o fluxo está inicialmente vazio.
    \Se hGlobal não for NULL, o conteúdo inicial do fluxo será o conteúdo atual do bloco de memória. 
    \Portanto, CreateStreamOnHGlobal pode ser usado para abrir um fluxo existente na memória. 
    \O identificador de memória e seu conteúdo não são perturbados pela criação do novo objeto de fluxo.
    \O tamanho inicial do fluxo é o tamanho de hGlobal conforme retornado pela função GlobalSize. 
    \Por causa do arredondamento, este não é necessariamente o mesmo tamanho que foi originalmente alocado para o identificador.
  Call "gdiplus.dll" "GdipCreateBitmapFromStream" com \https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusheaders/nf-gdiplusheaders-bitmap-bitmap(istream_bool)
  \Cria um objeto Bitmapbaseado em um um stream. https://docs.microsoft.com/pt-br/windows/win32/api/objidl/nn-objidl-istream
  \A interface IStream permite ler e gravar dados em objetos de fluxo. 
  \Os objetos de fluxo contêm os dados em um objeto de armazenamento estruturado, onde os armazenamentos fornecem a estrutura. 
  \Dados simples podem ser gravados diretamente em um fluxo, mas, mais frequentemente, os fluxos são elementos aninhados em um objeto de armazenamento. 
  \Eles são semelhantes ao arquivo padrão
    O istream [stream] \Ponteiro para uma interface IStream COM.
    e O endereçamento deste gpBitmap [**bitmap] \Ponteiro para uma variável DWORD (endereçamento) que recebe um ponteiro para um objeto Bitmap (o gpBitmap).
    devolvendo um número.
  Se o número não for 0, atribua "Não sei como processar este tipo de imagem." ao erro do fluxo de entrada/saída; esvazie o gpBitmap.
  Call o release deste vtable deste istream com o istream. \verificar isso com calma

Etapas para que se crie um GpImageAttributes (escala de cinza):
  Call "gdiplus.dll" "GdipCreateImageAttributes" com 
    \Um objeto ImageAttributes contém informações sobre como as cores de bitmap e metarquivo são manipuladas durante a renderização.
    O endereçamento destes GpImageAttributes. [**imageattr] \Ponteiro para uma variável (GpImageAttributes).
    \Essa variável contém um ponteiro para o objeto ImageAttributes. 
    \( ou seja, o número identificador do objeto ImageAttributes)
  Call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" com 
    O GpImageAttributes [ imageattr] \Ponteiro para o objeto ImageAttributes.
   e 0 [type = ColorAdjustTypeDefault ] \Elemento da enumeração ColorAdjustType que especifica a categoria para a qual a matriz de ajuste de cor é definida. O valor padrão é ColorAdjustTypeDefault.
   e 1 [enableFlag] \Valor booleano que especifica se um ajuste de cor separado está habilitado para a categoria especificada pelo parâmetro type (ColorAdjustTypeDefault).
   e o caractere inicial desta matriz de tons de cinza [colorMatrix] \Ponteiro para uma matriz 5x5 de ajuste de cor .
   e 0 [grayMatrix] \Especifica uma matriz a ser usada para ajustar os tons de cinza quando o valor do parâmetro flags é igual ColorMatrixFlagsAltGray.
   e 0 [flags = ColorMatrixFlagsDefault]. \Elemento da enumeração ColorMatrixFlags que especifica o tipo de imagem e a cor que serão afetados pela matriz de ajuste de cor.

Etapas para que se crie o hBrush of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor for clear, atribua o null hBrush a um hBrush.
  Se a cor não for clear, Call "gdi32.dll" "CreateSolidBrush" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-createsolidbrush
    \A função CreateSolidBrush cria um pincel lógico que possui a cor sólida especificada.
    O código da cor [color] \A cor do pincel. Para criar um valor de cor COLORREF, use a macro RGB.
    devolvendo o hBrush. \Se a função for bem-sucedida, o valor de retorno identifica um pincel lógico.
    \Se a função falhar, o valor de retorno será NULL.
    \Um pincel sólido é um bitmap que o sistema usa para pintar o interior de formas preenchidas.
     \Depois que um aplicativo cria um pincel chamando CreateSolidBrush, ele pode selecionar esse pincel em qualquer contexto de dispositivo chamando a função SelecionarObjeto
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O hBrush. [h] \Um identificador para o objeto a ser selecionado.

Etapas para que se crie o número da fonte of um canvas usando uma fonte:
  Converta a fonte para um número da fonte.
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O número da fonte. [h] \Um número identificador para o objeto a ser selecionado.

Etapas para que se crie o hPen of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor estiver clear, atribua o null hPen a um hPen.
  Atribua a quantidade de twips/pixel times o grossura do pincel a um número.
  Se o canvas for a área de impressão, atribua 1 pixel times o grossura do pincel ao número.
  Se a cor não estiver clear, Call "gdi32.dll" "CreatePen" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-createpen
  \A função CreatePen cria uma caneta lógica que possui o estilo, largura e cor especificados. 
  \A caneta pode ser posteriormente selecionada em um contexto de dispositivo e usada para desenhar linhas e curvas.
    0 [iStyle = PS_SOLID]  \O estilo da caneta. PS_SOLID = A linha da caneta é "sólida" (sem traços ou pontilhados).
    e O número [cWidth] \A largura da caneta, em unidades lógicas. Se nWidth é zero, a caneta tem um único pixel de largura, independentemente da transformação atual.
    e O código da cor [color]  \Uma referência de cor para a cor da caneta. Para gerar uma estrutura COLORREF, use a macro RGB.
    devolvendo o hPen. \Se a função for bem-sucedida, o valor de retorno é um identificador que identifica uma caneta lógica.
    \Se a função falhar, o valor de retorno será NULL.
     \Depois que um aplicativo cria uma caneta lógica, ele pode selecionar essa caneta em um contexto de dispositivo chamando a função SelecionarObjeto. 
      \Depois que uma caneta é selecionada em um contexto de dispositivo, ela pode ser usada para desenhar linhas e curvas.
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O hPen. [h] \Um número identificador para o objeto a ser selecionado.

Etapas para que se crie um hRgn usando uma caixa: 
  \ hRgn = número identificador da região que será desenhada na tela
  Isole a caixa.
  Adicione a quantidade de twips/pixel para o canto inferior direito desta caixa.
  Call "gdi32.dll" "BeginPath" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-beginpath
    \A função BeginPath abre um suporte de caminho no contexto de dispositivo especificado.
    O quadro atual.[hDC] \Um identificador para o contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "Rectangle" com \ Documentação: -> https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-rectangle
    \A função Retângulo desenha um retângulo. O retângulo é delineado com a caneta (pincel) atual e preenchido com a cor do pincel (brush) atual.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A coordenada X do canto inferior direito desta caixa 
    e A coordenada Y do canto inferior direito desta caixa.    
  Call "gdi32.dll" "EndPath" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-endpath
    \A função EndPath fecha um suporte de caminho e seleciona o caminho definido pelo suporte no contexto de dispositivo especificado.
    O quadro atual. [hDC] \Um identificador para o contexto de dispositivo no qual o novo caminho é selecionado.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "PathToRegion" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-pathtoregion
  \A função PathToRegion cria uma região do caminho que é selecionado no contexto de dispositivo especificado. A região resultante usa coordenadas do dispositivo.
    O quadro atual [hDC] \Identificador para um contexto de dispositivo que contém um caminho fechado.
   devolvendo o hRgn. \Se a função for bem-sucedida, o valor de retorno é um identificador válido para a região.
    \ Se a função falhar, o valor de retorno é zero.

Etapas para que se crie um hRgn usando uma elipse:
  \ hRgn = número identificador da região que será desenhada na tela
  Atribua a caixa desta elipse a uma caixa. \ No windows, toda elipse é desenhada dentro de uma caixa
  Call "gdi32.dll" "BeginPath" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-beginpath
    \A função BeginPath abre um suporte de caminho no contexto de dispositivo especificado.
    O quadro atual.[hDC] \Um identificador para o contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "Ellipse" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-ellipse
  \A função Ellipse desenha uma elipse. O centro da elipse é o centro do retângulo delimitador especificado. A elipse é delineada com a caneta atual e preenchida com a cor do pincel atual.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A coordenada X do canto inferior direito desta caixa 
    e A coordenada Y do canto inferior direito desta caixa.
  Call "gdi32.dll" "EndPath" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-endpath
    \A função EndPath fecha um suporte de caminho e seleciona o caminho definido pelo suporte no contexto de dispositivo especificado.
    O quadro atual. [hDC] \Um identificador para o contexto de dispositivo no qual o novo caminho é selecionado.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "PathToRegion" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-pathtoregion
  \A função PathToRegion cria uma região do caminho que é selecionado no contexto de dispositivo especificado. A região resultante usa coordenadas do dispositivo.
    O quadro atual [hDC] \Identificador para um contexto de dispositivo que contém um caminho fechado.
   devolvendo o hRgn. \Se a função for bem-sucedida, o valor de retorno é um identificador válido para a região.
    \ Se a função falhar, o valor de retorno é zero.

Etapas para que se crie um hRgn usando um polígono:
  \ hRgn = número identificador da região que será desenhada na tela
  Se o polígono for inexistente, atribua 0 ao hRgn; saia.
  [caso o polígono exista, então:] Crie uma série de vértices usando os vértices deste polígono.
  Call "gdi32.dll" "LPtoDP" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-lptodp
  \A função LPtoDP converte coordenadas lógicas em coordenadas de dispositivo.
  \A conversão depende do modo de mapeamento do contexto do dispositivo, das configurações das origens e extensões da janela e da janela de visualização e da transformação do mundo.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e O ponteiro da localização desta série de vértices [lppt] \Um ponteiro para uma matriz de estruturas POINT. 
    \As coordenadas x e as coordenadas y contidas em cada uma das estruturas POINT serão transformadas.
    \A estrutura POINT define as coordenadas X e Y de um ponto.
    e A quantidade de vértices desta série de vértices. [c] \O número de pontos na matriz/série de vértices.
  \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "CreatePolygonRgn" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn
  \A função CreatePolygonRgn cria uma região poligonal.
    O ponteiro da localização desta série de vértices  [*pptl] \Um ponteiro para uma matriz de estruturas POINT que definem os vértices do polígono em unidades lógicas. 
   \O polígono é presumido como sendo um polígono fechado. Cada vértice pode ser especificado apenas uma vez.
    e A quantidade de vértices desta série de vértices [cPoint] \O número de pontos na matriz.
    e 2 [iMode = WINDING] \O modo de preenchimento usado para determinar quais pixels estão na região.  -> exemplo: https://docs.microsoft.com/pt-br/windows/win32/gdi/images/csrgn-03.png
    \Este parâmetro pode ser um dos seguintes valores.
    \ ALTERNATE ou Seleciona o modo alternativo (preenche a área entre os lados ímpares e pares do polígono em cada linha de varredura).
    \WINDING = Seleciona o modo de enrolamento (preenche qualquer região com um valor de enrolamento diferente de zero).
    \Para obter mais informações sobre esses modos, consulte a função SetPolyFillMode, ou leia mais abaixo:    
    \Um aplicativo preenche o interior de uma região chamando a função FillRgn e fornecendo um identificador que identifica um pincel específico. 
    \Quando um aplicativo chama FillRgn, o sistema preenche a região com a cor do pincel usando o modo de preenchimento atual para o contexto de dispositivo especificado. 
    \Existem dois modos de preenchimento: alternado e enrolamento. 
    \O aplicativo pode definir o modo de preenchimento para um contexto de dispositivo chamando a função SetPolyFillMode. 
    \O aplicativo pode recuperar o modo de preenchimento atual para um contexto de dispositivo chamando a função GetPolyFillMode.    
    \Modo Alternativo
    \Para determinar quais pixels o sistema destaca quando o modo alternativo é especificado, execute o seguinte teste:
    \Selecione um pixel no interior da região.
    \Desenhe um raio imaginário, na direção x positiva, desse pixel em direção ao infinito.
    \Cada vez que o raio cruza uma linha limite, aumente um valor de contagem.
    \O sistema destaca o pixel se o valor da contagem for um número ímpar.    
    \Modo de enrolamento
    \Para determinar quais pixels o sistema destaca quando o modo de enrolamento é especificado, execute o seguinte teste:
    \Determine a direção em que cada linha de limite é desenhada.
    \Selecione um pixel no interior da região.
    \Desenhe um raio imaginário, na direção x positiva, do pixel em direção ao infinito.
    \Cada vez que o raio intercepta uma linha limite com um componente y positivo, aumente um valor de contagem. 
    \Cada vez que o raio cruza uma linha limite com um componente y negativo, diminua o valor de contagem.
    \O sistema destaca o pixel se o valor da contagem for diferente de zero.
    devolvendo o hRgn. \Se a função for bem-sucedida, o valor de retorno será o número identificador da região.
    \Se a função falhar, o valor de retorno será NULL.
  Destrua a série de vértices.

Etapas para que se crie um hRgn usando uma caixa arredondada:
  Se o raio desta caixa arredondada for 0, crie o hRgn usando a caixa arredondada como [se fosse] uma caixa [normal]; saia.
  Atribua a caixa arredondada a uma caixa.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "BeginPath" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-beginpath
    \A função BeginPath abre um suporte de caminho no contexto de dispositivo especificado.
    O quadro atual.[hDC] \Um identificador para o contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "RoundRect" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-roundrect
  \A função RoundRect desenha um retângulo com cantos arredondados. O retângulo é delineado com a caneta atual e preenchido com a cor do pincel atual.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A coordenada X do canto inferior direito desta caixa 
    e A coordenada Y do canto inferior direito desta caixa 
    e O diameter [width] \A largura, em coordenadas lógicas, da elipse usada para desenhar os cantos arredondados.
    e O diameter. [height] \A altura, em coordenadas lógicas, da elipse usada para desenhar os cantos arredondados.    
  Call "gdi32.dll" "EndPath" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-endpath
    \A função EndPath fecha um suporte de caminho e seleciona o caminho definido pelo suporte no contexto de dispositivo especificado.
    O quadro atual. [hDC] \Um identificador para o contexto de dispositivo no qual o novo caminho é selecionado.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "PathToRegion" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-pathtoregion
  \A função PathToRegion cria uma região do caminho que é selecionado no contexto de dispositivo especificado. A região resultante usa coordenadas do dispositivo.
    O quadro atual [hDC] \Identificador para um contexto de dispositivo que contém um caminho fechado.
   devolvendo o hRgn. \Se a função for bem-sucedida, o valor de retorno é um identificador válido para a região.
    \ Se a função falhar, o valor de retorno é zero.

Etapas para que se crie um catálogo usando uma contagem de buckets:
  Aloque memória para o catálogo.
  Atribua a contagem de buckets à contagem de buckets deste catálogo.
  Atribua o magnitude desse conjunto de buckets a uma largura.
  Atribua a contagem de buckets deste catálogo times a largura a um número.
  Assign o first bucket deste catálogo usando o número.
  Atribua o first bucket deste catálogo mais o número menos a largura ao last bucket deste catálogo.

Etapas para que se crie o dicionário léxico:
  Aloque memória para o dicionário léxico.
  Crie o catálogo deste dicionário léxico usando 4027.

Etapas para que se crie o número identificador de abertura of uma requisição WinHTTP:
  Se a requisição WinHTTP for inexistente, cancele.
  Converta o nome deste module para uma string composta de caracteres amplos denominado wide module nome e Anexe o caractere NULL.
  Call "WinHTTP.dll" "WinHttpOpen" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winhttp/nf-winhttp-winhttpopen
  \A função WinHttpOpen inicializa, para um aplicativo, o uso de funções WinHTTP e retorna um identificador de sessão WinHTTP.
  \A função WinHttpOpen é a primeira das funções WinHTTP chamadas por um aplicativo. 
  \Ela inicializa estruturas de dados WinHTTP internas e prepara-as para chamadas futuras do aplicativo.
    O caractere inicial deste wide module nome [pszAgentW] \Opcional. 
    \Trata-se de um ponteiro para uma variável de string que contém o nome do aplicativo ou entidade que chama as funções WinHTTP. 
    \Este nome é usado como o agente do usuário no protocolo HTTP.
    e 0 [dwAccessType = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY] \Tipo de acesso requerido
    \A Opção WINHTTP_ACCESS_TYPE_DEFAULT_PROXY recupera o proxy estático ou a configuração direta do registro. 
    \WINHTTP_ACCESS_TYPE_DEFAULT_PROXY não herda as configurações de proxy do navegador.
    \A configuração do proxy WinHTTP é definida por um desses mecanismos.
    \pelo utilitário proxycfg.exe no Windows XP e Windows Server 2003 ou anterior.
    \pelo utilitário netsh.exe no Windows Vista e Windows Server 2008 ou posterior.
    \pela função WinHttpSetDefaultProxyConfiguration em todas as plataformas.
    \Importante O uso desta opção está obsoleto no Windows 8.1 e nas versões mais recentes do Windows.
    \Em vez disso, use o valor 4 que representa a opção WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY.
    \Obs: só é possível usa a opção WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXYno Windows 8.1 e nas versões mais recentes do Windows.
    e 0 [pszProxyW = WINHTTP_NO_PROXY_NAME] 
    \Um ponteiro para uma variável de seqüência de caracteres que contém o nome do servidor proxy a ser usado 
    \quando o acesso do proxy é especificado, definindo dwAccessType como 3 (WINHTTP_ACCESS_TYPE_NAMED_PROXY).
    \Se dwAccessType não estiver definido como WINHTTP_ACCESS_TYPE_NAMED_PROXY, este parâmetro deve ser definido como 0 (WINHTTP_NO_PROXY_NAME).
    e 0 [pszProxyBypassW = WINHTTP_NO_PROXY_BYPASS] 
    \Um ponteiro para uma variável de seqüência de caracteres que contém uma lista opcional delimitada por ponto-e-vírgula de nomes de host ou endereços IP,
    \ou ambos, que não deve ser roteado por meio do proxy quando dwAccessType é definido como WINHTTP_ACCESS_TYPE_NAMED_PROXY. 
    \A lista pode conter caracteres curinga. Não use uma string vazia, porque a função WinHttpOpen a usa como a lista de ignorar proxy. 
    \Se este parâmetro especificar a macro "<local>" na lista como a única entrada, esta função ignora qualquer nome de host que não contenha um ponto. 
    \Se dwAccessType não estiver definido como WINHTTP_ACCESS_TYPE_NAMED_PROXY, este parâmetro deve ser definido como WINHTTP_NO_PROXY_BYPASS.
    e 0 [dwFlags] \Valor inteiro longo sem sinal que contém os sinalizadores que indicam várias opções que afetam o comportamento desta função.
    \ Em tese, os únicos valores disponíveis seriam 268435456 (WINHTTP_FLAG_ASYNC) e 805306368 (WINHTTP_FLAG_SECURE_DEFAULTS)
    devolvendo o número identificador de sessão deste número identificador de requisição desta requisição WinHTTP.
    \Retorna um identificador de sessão válido se for bem-sucedido ou NULL caso contrário.
  Se o número identificador de sessão deste número identificador de requisição desta requisição WinHTTP for 0, atribua "Erro. Não foi possível iniciar a conexão." ao erro do fluxo de entrada/saída; saia.

Etapas para que se crie um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, crie o endereço completo no sistema de arquivos (pasta)[endereço]; saia.
  Se o endereço completo for file-format, crie o endereço completo no sistema de arquivos (arquivo); saia.

Etapas para que se crie um endereço completo no sistema de arquivos (pasta)[endereço]:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateDirectoryA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-createdirectorya
  \Cria um novo diretório. Se o sistema de arquivos subjacente oferecer suporte à segurança em arquivos e diretórios, a função aplicará um descritor de segurança especificado ao novo diretório.
  \Para especificar um diretório de modelo, use a função CreateDirectoryEx.
    O caractere inicial deste endereço completo [lpPathName] \O caminho do diretório a ser criado.
  \Para a versão ANSI desta função, há um limite de tamanho de string padrão para caminhos de 248 caracteres (MAX_PATH - espaço suficiente para um nome de arquivo 8.3). 
  \Para estender esse limite para 32.767 caracteres largos, chame a versão Unicode da função e acrescente "\\? \" ao caminho. 
  \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/naming-a-file
  \Dica A partir do Windows 10, versão 1607, para a versão unicode desta função (CreateDirectoryW), você pode optar por remover a limitação de 248 caracteres sem incluir "\\? \" no início. 
  \O limite de 255 caracteres por segmento de caminho ainda se aplica. 
    \Consulte a seção "Limitação de comprimento máximo do caminho" do site acima para obter detalhes.
    e 0 [lpSecurityAttributes] \Um ponteiro para uma estrutura SECURITY_ATTRIBUTES. https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
    \O membro lpSecurityDescriptor da estrutura especifica um descritor de segurança para o novo diretório. 
    \Se lpSecurityAttributes for NULL, o diretório obterá um descritor de segurança padrão. 
    \As ACLs no descritor de segurança padrão para um diretório são herdadas de seu diretório pai.
    \O sistema de arquivos de destino deve suportar segurança em arquivos e diretórios para que este parâmetro tenha efeito. 
    \(Isso é indicado quando GetVolumeInformation retorna FS_PERSISTENT_ACLS.) https://docs.microsoft.com/pt-br/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  \Se a função falhar, o valor de retorno é zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, saia. \Se o número for 0, então faça o seguinte:
  Atribua "Erro. Não foi possível criar a pasta '" junto com o endereço completo seguido de "'. Provavelmente a pasta já existe no sistema de arquivos ou você não tem permissão de escrita" ao erro do fluxo de entrada/saída.

Etapas para que se crie um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-createfilea
  \Cria ou abre um arquivo ou dispositivo de E/S. 
  \Os dispositivos de E / S mais comumente usados são os seguintes: 
  \arquivo, fluxo de arquivo, diretório, disco físico, volume, buffer de console, unidade de fita, recurso de comunicação, slot de correio e canal. 
  \A função retorna um identificador que pode ser usado para acessar o arquivo ou dispositivo para vários tipos de E / S, 
  \dependendo do arquivo ou dispositivo e dos sinalizadores e atributos especificados.
    O caractere inicial deste endereço completo [lpFileName] \ O nome do arquivo ou dispositivo a ser criado ou aberto. 
    \Você pode usar barras (/) ou barras invertidas (\) neste nome.
  \Na versão ANSI desta função, o nome é limitado a MAX_PATH caracteres.
  \Para estender esse limite para 32.767 caracteres largos, chame a versão Unicode da função e acrescente "\\? \" ao caminho. 
  \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/naming-a-file
  \Para obter informações sobre nomes de dispositivos especiais, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/defining-an-ms-dos-device-name
  \Para criar um fluxo de arquivo, especifique o nome do arquivo, dois pontos e o nome do fluxo. 
  \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-streams
  \Dica A partir do Windows 10, versão 1607, para a versão Unicode desta função (CreateFileW), você pode optar por remover a limitação MAX_PATH sem acrescentar "\\? \". 
  \Consulte a seção "Limitação de comprimento máximo do caminho" do site https://docs.microsoft.com/pt-br/windows/desktop/FileIO/naming-a-file  para detalhes
    e 1073741824 [dwDesiredAccess = GENERIC_WRITE] \O acesso solicitado ao arquivo ou dispositivo, que pode ser resumido como leitura, gravação, ambos ou nenhum zero).
    \Os valores mais comumente usados são -2147483648 (GENERIC_READ), 1073741824 (GENERIC_WRITE) ou ambos -1073741824 (GENERIC_READ | GENERIC_WRITE). 
    \Para obter mais informações, consulte os sites:
    \ https://docs.microsoft.com/pt-br/windows/desktop/SecAuthZ/generic-access-rights
    \ https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-security-and-access-rights
    \ https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-access-rights-constants
    \ https://docs.microsoft.com/pt-br/windows/desktop/SecAuthZ/access-mask
    \Se este parâmetro for zero, o aplicativo pode consultar certos metadados, como arquivo, diretório ou atributos de dispositivo sem acessar esse arquivo ou dispositivo, 
    \mesmo se o acesso GENERIC_READ tivesse sido negado.
    e 0 [dwShareMode] \O modo de compartilhamento solicitado do arquivo ou dispositivo, que pode ser lido, escrito, ambos, excluir, todos ou nenhum. 
    \Os pedidos de acesso a atributos ou atributos estendidos não são afetados por este sinalizador.
    \O valor 0 impede que outros processos abram esse arquivo ou dispositivo se solicitarem acesso de exclusão, leitura ou gravação.
  \Se este parâmetro for 0 e CreateFile for bem-sucedido, o arquivo ou dispositivo não pode ser compartilhado e não pode ser aberto novamente até que o identificador para o arquivo ou dispositivo seja fechado.   
    e 0 [lpSecurityAttributes] \Um ponteiro para uma estrutura SECURITY_ATTRIBUTES que contém dois membros de dados separados, mas relacionados: 
    \ https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
    \um descritor de segurança opcional e um valor booleano que determina se o identificador retornado pode ser herdado por processos filho.
    \Este parâmetro pode ser NULL.
    \Se este parâmetro for NULL, o identificador retornado por CreateFile não pode ser herdado por nenhum processo filho que o aplicativo possa criar 
    \e o arquivo ou dispositivo associado ao identificador retornado obtém um descritor de segurança padrão.
    e 1 [dwCreationDisposition = CREATE_NEW] \Uma ação a ser executada em um arquivo ou dispositivo existente ou não.
    \Para dispositivos diferentes de arquivos, este parâmetro geralmente é definido como OPEN_EXISTING.
    \O valor 1 (CREATE_NEW) cria um novo arquivo, apenas se ainda não existir.
    \Se o arquivo especificado existir, a função falhará e o código do último erro será definido como ERROR_FILE_EXISTS (80).
    \Se o arquivo especificado não existir e for um caminho válido para um local gravável, um novo arquivo será criado.
    e 128 [dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL] \Os atributos e sinalizadores de arquivo ou dispositivo, sendo que FILE_ATTRIBUTE_NORMAL é o valor padrão mais comum para arquivos.
  \Quando o valor é 128 (FILE_ATTRIBUTE_NORMAL) o arquivo não possui outros atributos definidos. Este atributo é válido apenas se usado sozinho.
  \Este parâmetro pode incluir qualquer combinação dos atributos de arquivo disponíveis (FILE_ATTRIBUTE_ *). 
  \Todos os outros atributos de arquivo substituem FILE_ATTRIBUTE_NORMAL.
  \Para obter acesso mais avançado aos atributos de arquivo, consulte https://docs.microsoft.com/pt-br/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa
  \Para obter uma lista completa de todos os atributos de arquivo com seus valores e descrições, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-attribute-constants
    e 0 [hTemplateFile] \Um identificador válido para um arquivo de modelo com o direito de acesso GENERIC_READ. 
    \O arquivo de modelo fornece atributos de arquivo e atributos estendidos para o arquivo que está sendo criado.
    \Este parâmetro pode ser NULL.
    \Ao abrir um arquivo existente, CreateFile ignora este parâmetro
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno será um identificador aberto para o arquivo, dispositivo, canal nomeado ou slot de correio especificado.
    \Se a função falhar, o valor de retorno é -1 (INVALID_HANDLE_VALUE).
  Call "kernel32.dll" "CloseHandle" com \ https://docs.microsoft.com/pt-br/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
  \CloseHandle deve ser usado quando você terminar com o objeto. 
  \Em geral, CloseHandle invalida o identificador do objeto especificado, diminui a contagem do identificador do objeto e executa verificações de retenção do objeto. 
  \Depois que o último identificador para um objeto é fechado, o objeto é removido do sistema.
    O número identificador. [hObject] \Um identificador válido para um objeto aberto.
    \Se o aplicativo estiver sendo executado em um depurador, a função lançará uma exceção se receber um valor de identificador inválido ou um valor de pseudo-identificador. 
    \Isso pode acontecer se você fechar um identificador duas vezes ou se você chamar CloseHandle em um identificador retornado pela função FindFirstFile em vez de chamar a função FindClose.
  Limpe o erro do fluxo de entrada/saída.
  \Geralmente, um aplicativo deve chamar CloseHandle uma vez para cada identificador que abre. 
  \Geralmente não é necessário chamar CloseHandle se uma função que usa um identificador falhar com ERROR_INVALID_HANDLE, 
  \porque esse erro geralmente indica que o identificador já está invalidado. 
  \No entanto, algumas funções usam ERROR_INVALID_HANDLE para indicar que o próprio objeto não é mais válido. 
  \Por exemplo, uma função que tenta usar um identificador para um arquivo em uma rede pode falhar com ERROR_INVALID_HANDLE se a conexão de rede for interrompida, 
  \porque o objeto de arquivo não está mais disponível. 
  \Nesse caso, o aplicativo deve fechar o identificador.
  \Se a função CloseHandle for bem-sucedida, o valor de retorno será diferente de zero.
  \Se a função CloseHandle  falhar, o valor de retorno será zero.
  Se o número identificador [da função CreateFileA] não for -1 [INVALID_HANDLE_VALUE], cancele. \ Se a função CreateFileA falhar, o valor de retorno é -1 (INVALID_HANDLE_VALUE).
  Atribua "Erro. Não foi possível criar o arquivo '" junto com o endereço completo seguido de "'." ao erro do fluxo de entrada/saída.

Etapas para que se crie uma imagem:
  Aloque memória para a imagem.

Etapas para que se crie uma imagem usando um trecho:
  Crie um gpBitmap usando o trecho.
  Se o gpBitmap for inexistente, esvazie a imagem; saia.
  Aloque memória para a imagem.
  Atribua o trecho ao data desta imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).

Etapas para que se crie uma imagem usando um gpBitmap:
  Se o gpBitmap for inexistente, esvazie a imagem; saia.
  Aloque memória para a imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).

Etapas para que se crie uma imagem usando uma URL:
  Read o URL a um trecho.
  Crie a imagem usando o trecho.

Etapas para que se crie um polígono:
  Aloque memória para o polígono.

Etapas para que se crie um quora:
  Aloque memória para o quora.

Etapas para que se crie um referência:
  Aloque memória para o referência.

\socket = encaixe
Etapas para que se crie o número identificador da requisição of uma requisição WinHTTP using uma URL simplificada:
  Se a requisição WinHTTP for inexistente, cancele.
  Converta o endereço de recurso desta URL simplificada para uma string composta de caracteres amplos denominada endereço composto de caracteres amplos e Anexe o caractere NULL.
  Converta "POST" para uma string composta de caracteres amplos denominado POST composto de caracteres amplos e Anexe o caractere NULL.
  Se o nome do protocolo desta URL simplificada for "https", atribua 8388608 [WINHTTP_FLAG_SECURE] a um secure número.
  Call "WinHTTP.dll" "WinHttpOpenRequest" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winhttp/nf-winhttp-winhttpopenrequest
  \A função WinHttpOpenRequest cria um identificador de solicitação HTTP.
    O número identificador de conexão desta requisição WinHTTP [hConnect] \Número identificador de conexão HINTERNET de uma sessão HTTP retornada pela função WinHttpConnect.
    \Para detalhes consulte HINTERNET: https://docs.microsoft.com/pt-br/windows/desktop/WinHttp/hinternet-handles-in-winhttp
    \e também a função WinHttpConnect https://docs.microsoft.com/pt-br/windows/desktop/api/winhttp/nf-winhttp-winhttpconnect
    e O caractere inicial deste POST composto de caracteres amplos [pwszVerb] \Ponteiro para uma string que contém o verbo HTTP a ser usado na solicitação. 
    \Se este parâmetro for NULL, a função usará GET como o verbo HTTP. 
    \Observação: Esta string deve estar toda em maiúsculas. 
    \Muitos servidores tratam os verbos HTTP com distinção entre maiúsculas e minúsculas, e
    \as Solicitações de Comentários (RFCs) da Internet Engineering Task Force (IETF) soletram esses verbos usando apenas caracteres maiúsculos.
    e O caractere inicial deste endereço composto de caracteres amplos [pwszObjectName] 
    \Ponteiro para uma string que contém o nome do recurso de destino do verbo HTTP especificado. 
    \Geralmente é um nome de arquivo, um módulo executável ou um especificador de pesquisa.
    e 0 [pwszVersion = L"HTTP/1.1"] \Ponteiro para uma string que contém a versão HTTP. Se este parâmetro for NULL, a função usará HTTP / 1.1.
    e 0 [pwszReferrer = WINHTTP_NO_REFERER]  \Ponteiro para uma string que especifica a URL do documento a partir do qual a URL na solicitação pwszObjectName foi obtida. 
    \Se este parâmetro for definido como WINHTTP_NO_REFERER, nenhum documento de referência será especificado.
    e 0 [*ppwszAcceptTypes = WINHTTP_DEFAULT_ACCEPT_TYPES]  \Ponteiro para uma matriz terminada em nulo de ponteiros de string que especifica os tipos de mídia aceitos pelo cliente. 
    \Se este parâmetro for definido como WINHTTP_DEFAULT_ACCEPT_TYPES, nenhum tipo será aceito pelo cliente. 
    \Normalmente, os servidores lidam com a falta de tipos aceitos como indicação de que o cliente aceita apenas documentos do tipo "caixa de texto / *"; 
    \ou seja, apenas documentos de texto - sem imagens ou outros arquivos binários. 
    \Para obter uma lista de tipos de mídia válidos, consulte Tipos de mídia definidos pela IANA em http://www.iana.org/assignments/media-types/
    e O secure número [dwFlags] \Valor inteiro longo sem sinal que contém os valores dos sinalizadores da Internet
    devolvendo o número identificador de requisição desta requisição WinHTTP. \Retorna um identificador de solicitação HTTP válido se for bem-sucedido ou NULL se não for.
  Se o número identificador de requisição desta requisição WinHTTP for 0, atribua "Erro ao chamar a função 'WinHttpOpenRequest' da biblioteca 'WinHTTP.dll'. Não foi possível obter o número identificador da requisição." ao erro do fluxo de entrada/saída; saia.

Etapas para que se crie uma linha de texto usando um byte:
  Aloque memória para a linha de texto.
  Atribua o byte à string deste linha de texto.

Etapas para que se crie uma linha de texto usando uma string:
  Aloque memória para a linha de texto.
  Atribua a string à string deste linha de texto.

Etapas para que se crie um socket usando um host string e um número de porta:
  \ esta rotina cria, conecta e define o erro se houver um problema
  Limpe o erro do fluxo de entrada/saída.
  \ obtém o sockaddr
  Obtenha um sockaddr usando o host.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua 2 [AF_INET ] ao sin_family deste sockaddr.
  Atribua o port ao sin_port deste sockaddr.
  \ cria o socket 
  Call "ws2_32.dll" "socket" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winsock2/nf-winsock2-socket
  \A função de soquete cria um soquete (encaixe/tomada) que está vinculado a um provedor de serviços de transporte específico.
    2 [af = AF_INET ] \ Valor da família de endereços do endereço de transporte. 
    \O valor AF_INET é usado para endereços IPV4
    e 1 [type = SOCK_STREAM ]  \O tipo do novo soquete.
    \SOCK_STREAM é um tipo de soquete que fornece fluxos de bytes sequenciados, confiáveis, bidirecionais e baseados em conexão com um mecanismo de transmissão de dados OOB. 
    \Este tipo de soquete usa o TCP para a família de endereços da Internet (ipv4 e ipv6)
    e 0 [protocol = IPPROTO_IP] \O protocolo a ser usado. 
   \Se um valor de 0 for especificado, o chamador não deseja especificar um protocolo e o provedor de serviços escolherá o protocolo a ser usado.
   \Normalmente, existe apenas um único protocolo para oferecer suporte a um determinado tipo de soquete dentro de uma determinada família de protocolos; nesse caso, o protocolo pode ser especificado como 0.
    devolvendo o socket. \Se nenhum erro ocorrer, o socket retorna um descritor referenciando o novo socket. WSAAPI 
  \Caso contrário, um valor de INVALID_SOCKET é retornado
  Se o socket for -1 [INVALID_SOCKET ], atribua "Erro. O soquete informado não é um soquete válido." ao erro do fluxo de entrada/saída; saia.
  \ connect socket
  Call "ws2_32.dll" "connect" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winsock2/nf-winsock2-connect
  \A função connect estabelece uma conexão com um soquete especificado.
    O socket [s] \Um descritor que identifica um soquete não conectado.
    e O endereçamento deste sockaddr [*name] \Um ponteiro para a estrutura sockaddr com a qual a conexão deve ser estabelecida.
    \ https://docs.microsoft.com/pt-br/windows/desktop/WinSock/sockaddr-2
    e A magnitude deste sockaddr [namelen] \O comprimento, em bytes, da estrutura sockaddr apontada pelo parâmetro name.
    devolvendo um número resultante.\Se nenhum erro ocorrer, a conexão retorna zero. Caso contrário, retorna SOCKET_ERROR
  Se o número resultante não for 0 [SOCKET_ERROR], atribua "Erro. Não foi possível estabelecer uma conexão com o soquete informado." ao erro do fluxo de entrada/saída; saia.
  \ abra send timeout 30 seconds
  Atribua 30 seconds a um novo número.
  Call "ws2_32.dll" "setsockopt" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winsock/nf-winsock-setsockopt
  \A função setsockopt define uma opção de socket.
    O socket [s] \Um descritor que identifica um soquete.
    e 65535 [level] \O nível em que a opção é definida (por exemplo, SOL_SOCKET).
    e 4101 [optname SO_SNDTIMEO 0x00001005]  \A opção de soquete para a qual o valor deve ser definido (por exemplo, SO_BROADCAST). 
    \O parâmetro optname deve ser uma opção de soquete definida dentro do nível especificado, ou o comportamento é indefinido.
    \O tempo limite, em milissegundos, para bloquear chamadas enviadas.
    e o endereçamento deste novo número [30 seconds' endereçamento ][*optval] \Um ponteiro para o buffer no qual o valor da opção solicitada é especificado.
    e 4 [optlen] \O tamanho, em bytes, do buffer apontado pelo parâmetro optval.
    devolvendo o número resultante. \Se nenhum erro ocorrer, setsockopt retorna zero. Caso contrário, um valor de SOCKET_ERROR é retornado
  Se o número resultante não for 0 [SOCKET_ERROR ], atribua "Erro na função 'setsockopt' da biblioteca 'ws2_32.dll'. Não foi possível definiro tempo limite de envio SO_SNDTIMEO (4101) do soquete. " ao erro do fluxo de entrada/saída; saia.
  \ abra receive timeout 30 seconds
  Atribua 30 seconds a um novo número.
  Call "ws2_32.dll" "setsockopt" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winsock/nf-winsock-setsockopt
  \A função setsockopt define uma opção de socket.
    O socket [s] \Um descritor que identifica um soquete.
    e 65535 [level] \O nível em que a opção é definida (por exemplo, SOL_SOCKET).
    e 4102 [optname SO_RCVTIMEO  0x00001006]    \Define o tempo limite, em milissegundos, para bloquear chamadas recebidas.
    \A opção de soquete para a qual o valor deve ser definido (por exemplo, SO_BROADCAST). 
    \O parâmetro optname deve ser uma opção de soquete definida dentro do nível especificado, ou o comportamento é indefinido.
    \O tempo limite, em milissegundos, para bloquear chamadas enviadas.
    e o endereçamento deste novo número [30 seconds' endereçamento] [*optval] \Um ponteiro para o buffer no qual o valor da opção solicitada é especificado.
    e 4 [optlen] \O tamanho, em bytes, do buffer apontado pelo parâmetro optval.
    devolvendo o número resultante. \Se nenhum erro ocorrer, setsockopt retorna zero. Caso contrário, um valor de SOCKET_ERROR é retornado
  Se o número resultante não for 0, atribua "Erro na função 'setsockopt' da biblioteca 'ws2_32.dll'. Não foi possível definir o tempo limite de recepção  SO_RCVTIMEO (4102)  do soquete." ao erro do fluxo de entrada/saída; saia.

Etapas para que se crie um conjunto de texto usando uma string:
  Aloque memória para o conjunto de texto.
  Atribua a string à string deste conjunto de texto.

Etapas para que se crie um terminal em uma caixa:
  Aloque memória para o terminal.
  Atribua a caixa à caixa deste terminal.
  Atribua a cor verde ao output cor deste terminal.
  Atribua a cor verde claríssimo ao input cor deste terminal.

Etapas para que se crie uma caixa de texto:
  Aloque memória para a caixa de texto.
  Atribua a cor preta à cor do pincel desta caixa de texto.
  Atribua a fonte padrão ao fonte desta caixa de texto.
  Atribua "à esquerda" ao alinhamento desta caixa de texto.
  Atribua 1/1 à scale desta caixa de texto.
  Garanta one linha de texto na caixa de texto.
  Redefina a origem of a caixa de texto.
  Redefina o cursor de texto of a caixa de texto.
  Desvencilhe-se de a caixa de texto.

Etapas para que se crie um vértice:
  Aloque memória para o vértice.

Etapas para que se crie uma série de vértices usando uma contagem:
  Isole a contagem.
  Aloque memória para a série de vértices.
  Atribua a contagem à quantidade de vértices desta série de vértices.
  Multiplique a contagem pela magnitude desse localização.
  Assign o ponteiro da localização desta série de vértices usando a contagem.

Etapas para que se crie uma série de vértices usando uns vértices:
  Crie a série de vértices usando a contagem destes vértices.
  Atribua o ponteiro da localização desta série de vértices a um ponteiro da localização.
  Comece. [a executar o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Atribua a localização deste vértice ao conteúdo deste ponteiro da localização.
    Adicione a magnitude desta localização deste vértice para o ponteiro da localização.
  Recomece. [percorra novamente o código acima]

Etapas para que se crie um vértice usando uma localização:
  Aloque memória para o vértice.
  Atribua a localização à localização deste vértice.

Etapas para que se crie um vértice usando uma coordenada X e uma coordenada Y:
  Aloque memória para o vértice.
  Atribua a coordenada X à coordenada X deste vértice.
  Atribua a coordenada Y à coordenada Y deste vértice.

Etapas para que se crie uma requisição WinHTTP por posting para uma URL:
  Aloque memória para a requisição WinHTTP.
  Converta o URL para uma URL simplificada.
  Crie o número identificador de abertura of a requisição WinHTTP.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua a requisição WinHTTP; saia.
  Crie o connect handle of a requisição WinHTTP using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua a requisição WinHTTP; saia.
  Crie o número identificador da requisição of a requisição WinHTTP using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua a requisição WinHTTP; saia.

O console é um console.

O quadro atual é um canvas.

O evento atual é um evento.

Um cursor é um número identificador.

Etapas para que se corte um número pela metade:
  Divida o número por 2.

Um date/time é um conjunto com
  Um year número,
  Um month número,
  Um week day número,
  Um day número,
  Um hour número,
  Um minute número,
  Um second número,
  Um millisecond número.

Etapas para que se de-sign uma fração:
  De-sign o numerador desta fração.
  De-sign o denominador desta fração.

Etapas para que se de-sign um número:
  Se o número for o menor número, atribua o maior número ao número; saia.
  Se o número for menor do que 0, negate o número.

Etapas para que se de-sign um par de números:
  De-sign o número X deste par de números.
  De-sign o número Y deste par de números.

Etapas para que se de-sign uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste caractere inicial desta string for tipo de sinal aritmético, remove o first byte desde a string.

Um relatório é uma string.
Um relatório de informações é uma string.
Um relatório de bugs é uma string.
Um relatório de erros é uma string.
Um relatório de falhas é uma string.
Um relatório de panes é uma string.

Etapas para que se produza o relatório de bugs usando uma caixa;
Etapas para que se produza o relatório de falhas usando uma caixa;
Etapas para que se produza o relatório de panes usando uma caixa;
Etapas para que se produza o relatório de erros usando uma caixa;
Etapas para que se produza o relatório de informações usando uma caixa:
  Limpe um relatório.
  Posponha "Coordenada esquerda = " para o relatório.
  Posponha a coordenada X do canto superior esquerdo desta caixa para o relatório.
  Posponha ", Coordenada superior = " para o relatório.
  Posponha a coordenada Y do canto superior esquerdo desta caixa para o relatório.
  Posponha ", Coordenada direita = " para o relatório.
  Posponha a coordenada X do canto inferior direito desta caixa para o relatório.
  Posponha ", Coordenada inferior = " para o relatório.
  Posponha a coordenada Y do canto inferior direito desta caixa para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um byte;
Etapas para que se produza o relatório de falhas usando um byte;
Etapas para que se produza o relatório de panes usando um byte;
Etapas para que se produza o relatório de bugs usando um byte;
Etapas para que se produza o relatório de informações usando um byte:
  Atribua o byte a um número.
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma cor;
Etapas para que se produza o relatório de falhas usando uma cor;
Etapas para que se produza o relatório de panes usando uma cor;
Etapas para que se produza o relatório de bugs usando uma cor;
Etapas para que se produza o relatório de informações usando uma cor:
  Limpe um relatório.
  Posponha "Matiz = " para o relatório.
  Posponha a matiz desta cor para o relatório.
  Posponha ", Saturação = " para o relatório.
  Posponha a saturação desta cor para o relatório.
  Posponha ", Luminosidade = " para o relatório.
  Posponha a luminosidade desta cor para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um detector;
Etapas para que se produza o relatório de falhas usando um detector;
Etapas para que se produza o relatório de panes usando um detector;
Etapas para que se produza o relatório de bugs usando um detector;
Etapas para que se produza o relatório de informações usando um detector:
  Converta o detector para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de bugs usando uma fonte;
Etapas para que se produza o relatório de erros usando uma fonte;
Etapas para que se produza o relatório de falhas usando uma fonte;
Etapas para que se produza o relatório de panes usando uma fonte;
Etapas para que se produza o relatório de informações usando uma fonte:
  Limpe um relatório.
  Posponha " Nome da fonte = '" para o relatório seguido de "'".
  Posponha o nome desta fonte para o relatório.
  Posponha ", Tamanho da fonte = " para o relatório.
  Posponha a altura desta fonte para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma fração;
Etapas para que se produza o relatório de falhas usando uma fração;
Etapas para que se produza o relatório de panes usando uma fração;
Etapas para que se produza o relatório de bugs usando uma fração;
Etapas para que se produza o relatório de informações usando uma fração:
  Limpe um relatório.
  Posponha "Numerador = " para o relatório.
  Posponha o numerador desta fração para o relatório.
  Posponha ", Denominador = " para o relatório.
  Posponha o denominador desta fração para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de bugs usando uma linha reta;
Etapas para que se produza o relatório de falhas usando uma linha reta;
Etapas para que se produza o relatório de panes usando uma linha reta;
Etapas para que se produza o relatório de erros usando uma linha reta;
Etapas para que se produza o relatório de informações usando uma linha reta:
  Limpe um relatório.
  Posponha " Começo da linha = " para o relatório.
  Posponha a coordenada X desta localização inicial desta linha reta para o relatório.
  Posponha "," para o relatório.
  Posponha a coordenada Y desta localização inicial desta linha reta para o relatório.
  Posponha " Fim da linha = " para o relatório.
  Posponha a coordenada X desta localização final desta linha reta para o relatório.
  Posponha "," para o relatório.
  Posponha a coordenada Y desta localização final desta linha reta para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de falhas usando um número;
Etapas para que se produza o relatório de panes usando um número;
Etapas para que se produza o relatório de erros usando um número;
Etapas para que se produza o relatório de bugs usando um número;
Etapas para que se produza o relatório de informações usando um número:
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um número e um segundo número;
Etapas para que se produza o relatório de falhas usando um número e um segundo número;
Etapas para que se produza o relatório de panes usando um número e um segundo número;
Etapas para que se produza o relatório de bugs usando um número e um segundo número;
Etapas para que se produza o relatório de informações usando um número e um segundo número:
  Produza o relatório de informações usando o número seguido de ", " junto com o segundo número.

Etapas para que se produza o relatório de falhas usando um par de números;
Etapas para que se produza o relatório de panes usando um par de números;
Etapas para que se produza o relatório de erros usando um par de números;
Etapas para que se produza o relatório de bugs usando um par de números;
Etapas para que se produza o relatório de informações usando um par de números:
  Limpe um relatório.
  Posponha "Coordenada X = " para o relatório.
  Posponha o número X deste par de números para o relatório.
  Posponha ", Coordenada Y = " para o relatório.
  Posponha o número Y deste par de números para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de panes usando um ponteiro;
Etapas para que se produza o relatório de falhas usando um ponteiro;
Etapas para que se produza o relatório de erros usando um ponteiro;
Etapas para que se produza o relatório de bugs usando um ponteiro;
Etapas para que se produza o relatório de informações usando um ponteiro:
  Converta o ponteiro para uma cifra hexadecimal.
  Produza o relatório de informações usando "$" junto com a cifra hexadecimal.
  Produza o relatório de informações usando "0x" junto com a cifra hexadecimal.

Etapas para que se produza o relatório de panes usando um espaço de cor RGB;
Etapas para que se produza o relatório de falhas usando um espaço de cor RGB;
Etapas para que se produza o relatório de erros usando um espaço de cor RGB;
Etapas para que se produza o relatório de bugs usando um espaço de cor RGB;
Etapas para que se produza o relatório de informações usando um espaço de cor RGB:
  Limpe um relatório.
  Posponha "Vermelho = " para o relatório. Atribua o espectro vermelho deste espaço de cor RGB a um número.
  Posponha o número para o relatório.
  Posponha ", Verde = " para o relatório. Atribua o espectro verde deste espaço de cor RGB ao número.
  Posponha o número para o relatório.
  Posponha ", Azul = " para o relatório. Atribua o espectro azul deste espaço de cor RGB ao número.
  Posponha o número para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de falhas usando um relatório;
Etapas para que se produza o relatório de panes usando um relatório;
Etapas para que se produza o relatório de erros usando um relatório;
Etapas para que se produza o relatório de bugs usando um relatório;
Etapas para que se produza o relatório de informações usando um relatório:
  Isole o relatório.
  Anexe o caractere NULL o relatório.
  Atribua "Detalhes: " a um relatório de erros.
  \Chame função "MessageBoxA" contida na biblioteca "user32.dll" informando os parâmetros a seguir: 0, o primeiro caractere do texto em questão, o primeiro caractere de "debug" e 0.
  Call "user32.dll" "MessageBoxA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-messageboxa
  \Exibe uma caixa de diálogo modal que contém um ícone do sistema, um conjunto de botões e uma breve mensagem específica do aplicativo, como status ou informações de erro. 
  \A caixa de mensagem retorna um valor inteiro que indica em qual botão o usuário clicou.
    0 [hWnd] \Um identificador para a janela do proprietário da caixa de mensagem a ser criada. 
    \Se este parâmetro for 0 [NULL], a caixa de mensagem não terá janela do proprietário.
    e O caractere inicial deste relatório [lpText] \A mensagem a ser exibida. 
    \Se a string consistir em mais de uma linha, você pode separar as linhas usando um retorno de carro e / ou um caractere de avanço de linha entre cada linha.
    e O caractere inicial deste relatório de erros [lpCaption] \ O título da caixa de diálogo. Se este parâmetro for NULL, o título padrão é Erro.
    e 0. [uType] \O conteúdo e o comportamento da caixa de diálogo. Quando o valor é igual a 0 a caixa de mensagem contém apenas um botão: OK. Este é o  valor padrão.
    \Se a caixa de mensagem tiver um botão Cancelar, a função retornará o valor IDCANCEL se a tecla ESC for pressionada ou o botão Cancelar for selecionado. 
    \Se a caixa de mensagem não tiver o botão Cancelar, pressionar ESC não terá efeito - a menos que um botão MB_OK esteja presente. 
    \Se um botão MB_OK for exibido e o usuário pressionar ESC, o valor de retorno será IDOK.
    \Se a função falhar, o valor de retorno é zero.

Etapas para que se produza o relatório de erros usando um relatório (com aspas);
Etapas para que se produza o relatório de panes usando um relatório (com aspas);
Etapas para que se produza o relatório de falhas usando um relatório (com aspas);
Etapas para que se produza o relatório de bugs usando um relatório (com aspas);
Etapas para que se produza o relatório de informações usando um relatório (com aspas):
  Isole o relatório.
  Anteponha as aspas duplas para o relatório.
  Posponha as aspas duplas para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma word;
Etapas para que se produza o relatório de panes usando uma word;
Etapas para que se produza o relatório de falhas usando uma word;
Etapas para que se produza o relatório de bugs usando uma word;
Etapas para que se produza o relatório de informações usando uma word:
  Atribua a word a um número.
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se determine se uma caixa é uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta caixa não for a coordenada X do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta caixa não for a coordenada Y do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada X do canto inferior direito desta caixa não for a coordenada X do canto inferior direito desta segunda caixa, diga não.
  Se a coordenada Y do canto inferior direito desta caixa não for a coordenada Y do canto inferior direito desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa está still em uma segunda caixa;
Etapas para que se determine se uma caixa está em uma segunda caixa;
Etapas para que se determine se uma caixa está inside uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, diga não.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa está tocando uma segunda caixa:
  Se a coordenada X do canto inferior direito desta segunda caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y do canto inferior direito desta segunda caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada X do canto superior esquerdo desta segunda caixa for maior do que a coordenada X do canto inferior direito desta caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta segunda caixa for maior do que a coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um byte é alfanumérico:
  Se o byte for algum tipo de letra, diga sim.
  Se o byte for algum tipo de digit, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é um segundo byte ou um terceiro byte:
  Se o byte for o segundo byte, diga sim.
  Se o byte for o terceiro byte, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é alguma consoante:
  Se o byte estiver em "bcdfghjklmnpqrstvwxyzçñ", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum tipo de digit:
  Se o byte for menor do que o número zero, diga não.
  Se o byte for maior do que o número nove, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um byte é algum tipo de letra:
  Se o byte estiver entre o 'A' maiúsculo e o Z maiúsculo, diga sim.
  Se o byte estiver entre o 'a' minúsculo e o z minúsculo, diga sim.
  Se o byte for 131 ou 138, diga sim.
  Se o byte for 140 ou 142, diga sim.
  Se o byte for 154 ou 156, diga sim.
  Se o byte estiver entre 158 e 159, diga sim.
  Se o byte estiver entre 192 e 214, diga sim.
  Se o byte estiver entre 216 e 246, diga sim.
  Se o byte estiver entre 248 e 255, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum tipo de indicador numérico:
  Se o byte é algum tipo de digit, diga sim.
  Se o byte é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum tipo de sinal de pontuação:
  \ precisa ser aprimorado
  Se o byte for o caractere de espaço, diga não.
  Se o byte não for alfanumérico, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é tipo de sinal aritmético:
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o sinal de subtração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum tipo de unidade de disco válida:
  Atribua o byte a um endereço completo.
  Posponha ":\" para o endereço completo.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Se a categoria da unidade de disco for "", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um byte é algum tipo de vogal:
  Se o byte estiver em "aeiouyáéíóúýãõäëïöüÿâêîôûàèìòù", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte está entre um segundo byte e um terceiro byte:
  Se o byte for menor do que o segundo byte, diga não.
  Se o byte for maior do que o terceiro byte, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um byte está entre um número e um segundo número:
  Se o byte for menor do que o número, diga não.
  Se o byte for maior do que o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um byte estiver em uma string:
  Isole o byte.
  Lowercase o byte.
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, diga não.
    Atribua o conteúdo deste caractere inicial deste subtexto a um segundo byte.
    Lowercase o segundo byte.
    Se o segundo byte for o byte, diga sim.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um byte é like um segundo byte:
  \ used internally para palavra wrap
  Se o byte for whitespace, acione um detector.
  Se o segundo byte for whitespace, acione um segundo detector.
  Se o detector for o segundo detector, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é irrelevante:
  Se o byte for menor do que ou igual ao caractere de espaço, diga sim.
  Se o byte for o antigo símbolo de delete [que agora está descontinuado], diga sim.
  Se o byte for o espaço rígido, diga sim.
  Se o byte for 129, diga sim.
  Se o byte for 141, diga sim.
  Se o byte for 143, diga sim.
  Se o byte for 144, diga sim.
  Se o byte for 157, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é um número ou um segundo número:
  Se o byte for o número, diga sim.
  Se o byte for o segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é imprimível:
  Se o byte for menor do que o caractere de espaço, diga não.
  Se o byte for o antigo símbolo de delete [que agora está descontinuado], diga não.
  Se o byte for 129, diga não.
  Se o byte for 141, diga não.
  Se o byte for 143, diga não.
  Se o byte for 144, diga não.
  Se o byte for 157, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um byte é uma string:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Isole o byte.
  Lowercase o byte.
  Atribua o conteúdo deste caractere inicial desta string a um segundo byte.
  Lowercase o segundo byte.
  Se o byte for o segundo byte, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é symbolic:
  Se o byte estiver entre o ponto de exclamação e o slash byte, diga sim.
  Se o byte estiver entre o sinal de dois pontos e o sinal de arroba, diga sim.
  Se o byte estiver entre o colchete esquerdo e o acento grave, diga sim.
  Se o byte estiver entre o chave esquerda e o acento til, diga sim.
  Se o byte for 128, diga sim.
  Se o byte for 130, diga sim.
  Se o byte estiver entre 132 e 137, diga sim.
  Se o byte for 139, diga sim.
  Se o byte estiver entre 145 e 153, diga sim.
  Se o byte for 155, diga sim.
  Se o byte estiver entre 161 e 180, diga sim.
  Se o byte estiver entre 183 e 191, diga sim.
  Se o byte for 215, diga sim.
  Se o byte for 247, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é whitespace:
  Se o byte for o caractere de espaço, diga sim.
  Se o byte for o tabulação horizontal, diga sim.
  Se o byte for o retorno de carro, diga sim.
  Se o byte for a quebra de linha, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o cursor de texto of uma caixa de texto é sob o beginning:
  Se a caixa de texto for inexistente, diga não.
  Se o número de linhas do cursor desta caixa de texto não for 1, diga não.
  Se o cursor de texto número de coluna desta caixa de texto não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o cursor de texto of uma caixa de texto é sob o end:
  Se a caixa de texto for inexistente, diga não.
  Se o número de linhas do cursor desta caixa de texto não for a contagem destas linhas des textos desta caixa de texto, diga não.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Se o cursor de texto número de coluna desta caixa de texto não for a quantidade de caracteres desta string desta linha de texto, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o cursor de texto of uma caixa de texto está sobre o first linha reta:
  Se a caixa de texto for inexistente, diga não.
  Se o número de linhas do cursor desta caixa de texto não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o cursor de texto of uma caixa de texto está sobre o last linha reta:
  Se a caixa de texto for inexistente, diga não.
  Se as linhas des textos desta caixa de texto estiverem vazias, diga não.
  Se o número de linhas do cursor desta caixa de texto não for o número da linha desta last linha de texto desta caixa de texto, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma escolha é uma string:
  Se a escolha for inexistente, diga não.
  Se o nome desta escolha for a string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor e uma segunda cor estão clear:
  Se a cor não for clear, diga não.
  Se a segunda cor não for clear, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma cor é uma segunda cor:
  Se a matiz desta cor não for a matiz desta segunda cor, diga não.
  Se a saturação desta cor não for a saturação desta segunda cor, diga não.
  Se a luminosidade desta cor não for a luminosidade desta segunda cor, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma cor está clear:
  Se a matiz desta cor for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é escura:
  Se a luminosidade desta cor estiver entre 250 e 374, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é clara:
  Se a luminosidade desta cor estiver entre 625 e 749, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é normal:
  Se a luminosidade desta cor estiver entre 375 e 624, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muito escura:
  Se a luminosidade desta cor estiver entre 125 e 249, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muito clara:
  Se a luminosidade desta cor estiver entre 750 e 874, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muitíssimo escura:
  Se a luminosidade desta cor for menor do que ou igual para 124, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muitíssimo clara:
  Se a luminosidade desta cor for maior do que ou igual para 875, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um contador é past um número:
  Adicione 1 para o contador.
  Se o contador for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está acima of ou debaixo of uma caixa:
  Se a localização deste contexto estiver acima of ou debaixo of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está lado esquerdo ou lado direito of uma caixa:
  Se a localização deste contexto estiver lado esquerdo ou lado direito of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está para o lado direito of uma caixa:
  Se a coordenada X desta localização deste contexto for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está within uns twips of uma caixa:
  Se a localização deste contexto estiver within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um difference está within uma malha:
  Isole a difference.
  De-sign a difference.
  Se o número X desta difference for maior do que ou igual ao número X desta malha, diga não.
  Se o número Y desta difference for maior do que ou igual ao número Y desta malha, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um evento é algum tipo de atalho de tecla:
  Se o evento for inexistente, diga não.
  Se a categoria deste evento não for "pressionamento de tecla", diga não.
  Se o evento não foi alterado, diga não.
  Se a tecla deste evento estiver entre a tecla A/a e a tecla Z/z, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um evento foi alterado:
  Se o detector de tecla Ctrl deste evento estiver ativo, diga sim.
  Se o detector de tecla Alt deste evento estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um finger é past o end of uma string:
  Se o finger for inexistente, diga sim.
  Se o finger for maior do que o caractere final desta string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se um detector está on:
\ alterne como uma segunda nome por detector also ? ***
\Se o detector estiver ativo, diga sim.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um detector está presente;
Etapas para que se determine se um detector está em vigor;
Etapas para que se determine se um detector está levantada;
Etapas para que se determine se um detector está ligado; \foi ligado também funciona
Etapas para que se determine se um detector está ativo;
Etapas para que se determine se um detector está ativado; \foi ativado
\Etapas para que se determine se um detector já está ativado;
Etapas para que se determine se um detector já foi ativado anteriomente;
\Etapas para que se determine se um detector foi ativado anteriomente;
Etapas para que se determine se um detector está tocando;
Etapas para que se determine se um detector está soando;
Etapas para que se determine se um detector soou;
\Etapas para que se determine se um detector já soou;
Etapas para que se determine se um detector está disparando;
\Etapas para que se determine se um detector disparou;
Etapas para que se determine se um detector está alarmando;
\Etapas para que se determine se um detector disparou;
Etapas para que se determine se um detector está sendo mostrada;
Etapas para que se determine se um detector está sendo exibida;
Etapas para que se determine se um detector está verde:
  Se o detector for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um detector está dormente;
Etapas para que se determine se um detector está suspenso;
Etapas para que se determine se um detector está inativo;
Etapas para que se determine se um detector está desligado;
Etapas para que se determine se um detector está desativado;
Etapas para que se determine se um detector está vermelho:
  Se o detector for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração é o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é maior que uma segunda fração;
Etapas para que se determine se uma fração é maior do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é maior do que ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é menor que uma segunda fração;
Etapas para que se determine se uma fração é menor do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração for menor do que ou igual para uma segunda fração;
Etapas para que se determine se uma fração for menor que ou igual para uma segunda fração;
Etapas para que se determine se uma fração for menor ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é negativa:
  Se o numerador desta fração for menor do que 0, reverse um detector.
  Se o denominador desta fração for menor do que 0, reverse o detector.
  \ Say o detector. \ does not work em SAL; no detector literals anymore
  Se o detector estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é um número:
  Se a fração é o número / 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um catálogo está vazia;
Etapas para que se determine se um catálogo estão vazias;
Etapas para que se determine se um catálogo estão vazios;
Etapas para que se determine se um catálogo está vazio:
  Se o catálogo for inexistente, diga sim.
  Comece. [a executar o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, diga sim.
    Se os referências deste bucket não estiverem vazios, diga não.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um input é um clique:
  Esvazie o clique.
  Se a categoria deste input não for "clique", diga não.
  Atribua o input ao clique.

Etapas para que se determine se um item é encontrado:
  Se a categoria deste item não estiver em branco, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de digit tecla:
  Se a tecla estiver entre 48 e 57, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de letra tecla:
  Se a tecla estiver entre 65 e 90, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de tecla modificadora:
  Se a tecla for a tecla Alt, diga sim.
  Se a tecla for a tecla Ctrl, diga sim.
  Se a tecla for a tecla Shift, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de pad tecla:
  Se a tecla estiver entre 96 e 111, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de tecla imprimível:
  Se a tecla for o barra de espaço, diga sim.
  Se a tecla for algum tipo de digit tecla, diga sim.
  Se a tecla for algum tipo de letra tecla, diga sim.
  Se a tecla for algum tipo de pad tecla, diga sim.
  Se a tecla for algum tipo de symbol tecla, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de symbol tecla:
  Se a tecla estiver entre 186 e 192, diga sim.
  Se a tecla estiver entre 219 e 222, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de WM_CHAR tecla:
  Se a tecla não for algum tipo de tecla imprimível , diga não.
  Se a tecla Alt está para baixo, diga não.
  Se a tecla Ctrl está para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma tecla [ou botão do mouse] está sendo pressionado;
Etapas para que se determine se uma [determinada] tecla [específica] está sendo pressionada:
  Call "user32.dll" "GetAsyncKeyState" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getasynckeystate
  \GetAsyncKeyState Determina se uma tecla está ativada ou desativada no momento em que a função é chamada e se a tecla foi pressionada após uma chamada anterior para GetAsyncKeyState.
    A tecla [vKey] \O código de tecla virtual. Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/inputdev/virtual-key-codes
    \Você pode diferenciar as teclas iguais do teclado se precisar saber se uma tecla específica está sendo pressionada . 
    devolvendo um word. \Se a função for bem-sucedida, o valor de retorno especifica se a tecla foi pressionada desde a última chamada para GetAsyncKeyState e se a tecla está ativada ou desativada. 
    \Se o bit mais significativo estiver definido, a tecla está sendo pressionada e, 
    \se o bit menos significativo estiver definido, a tecla foi pressionada após a chamada anterior para GetAsyncKeyState. 
    \No entanto, você não deve confiar neste último comportamento;
    \Embora o bit menos significativo do valor de retorno indique se a tecla foi pressionada desde a última consulta, devido à natureza multitarefa preemptiva do Windows, 
    \outro aplicativo pode chamar GetAsyncKeyState e receber o bit "pressionado recentemente" em vez de seu aplicativo. 
    \O comportamento do bit menos significativo do valor de retorno é retido estritamente para compatibilidade com aplicativos do Windows de 16 bits (que não são preemptivos) e não deve ser considerado.
    \A função GetAsyncKeyState também funciona com botões do mouse. 
    \No entanto, ela verifica o estado dos botões físicos do mouse, não os botões lógicos do mouse para os quais os botões físicos estão mapeados. 
    \Por exemplo, a chamada GetAsyncKeyState (VK_LBUTTON) sempre retorna o estado do botão físico esquerdo do mouse, 
    \independentemente de estar mapeado para o botão lógico esquerdo ou direito do mouse. 
    \Você pode determinar o mapeamento atual do sistema de botões físicos do mouse para botões lógicos do mouse chamando GetSystemMetrics (SM_SWAPBUTTON).
    \que retorna TRUE se os botões do mouse foram trocados.
  Atribua a word a um número.
  \O valor de retorno é zero para os seguintes casos:
  \A área de trabalho atual não é a área de trabalho ativa
  \O segmento de primeiro plano pertence a outro processo e a área de trabalho não permite que a operação seja realizada
  Se o número for menor do que 0, diga sim. \Se o bit mais significativo estiver definido (ou seja, se o número for negativo), a tecla está sendo pressionada
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla está para baixo:
  Call "user32.dll" "GetKeyState" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getkeystate
  \Recupera o status da tecla virtual especificada. 
  \O status especifica se a tecla está para cima, para baixo ou alternada (ligada, desligada - alternando cada vez que a tecla é pressionada).
    A tecla [nVirtKey] \Uma chave virtual. Se a chave virtual desejada for uma letra ou dígito (A-Z, a-z ou 0-9), nVirtKey deve ser definido com o valor ASCII desse caractere. 
    \Para as demais teclas, deve ser um código de tecla virtual.
    \Se um layout de teclado diferente do inglês for usado, as teclas virtuais com valores no intervalo ASCII A a Z e 0 a 9 serão usadas para especificar a maioria das teclas de caracteres. 
    \Por exemplo, para o layout de teclado alemão, a tecla virtual de valor ASCII O (0x4F) se refere à tecla "o", enquanto VK_OEM_1 se refere à tecla "ö (o com trema)".
    devolvendo um word. \O valor de retorno especifica o status da tecla virtual especificada, da seguinte maneira:
    \Se o bit de ordem superior for 1, a tecla está para baixo; caso contrário, está para cima.
    \Se o bit de ordem inferior for 1, a chave está alternada. 
    \Uma tecla, como a tecla CAPS LOCK, está alternada se estiver ativada. 
    \A tecla está desligada e não alternada se o bit de ordem inferior for 0. 
    \Uma luz indicadora da tecla de alternância (se houver) no teclado ficará acesa quando a tecla for alternada e desligada quando a tecla for desativada.
  Atribua a word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.
\O status da tecla retornada por esta função muda conforme um thread lê as mensagens principais de sua fila de mensagens. 
\O status não reflete o estado do nível de interrupção associado ao hardware. Use a função GetAsyncKeyState da rotina acima para recuperar essas informações.
\Um aplicativo chama GetKeyState em resposta a uma mensagem de entrada do teclado. Esta função recupera o estado da tecla quando a mensagem de entrada foi gerada.
\Para recuperar informações de estado para todas as chaves virtuais, use a função GetKeyboardState.

\GetAsyncKeyState () obtém o estado da chave de forma assíncrona, ou seja, sem esperar por nada, ou seja, AGORA.
\GetKeyState () obtém o estado da chave de forma síncrona, é o estado da chave que você está prestes a ler. 
\Ele é enfileirado no buffer do teclado junto com os pressionamentos de tecla propriamente ditos.

\A entrada do teclado no Windows é armazenada em buffer. 
\Isso garante que o usuário possa continuar digitando, mesmo se o programa estiver temporariamente sem resposta. 
\Sempre ocorre, até certo ponto, nenhuma perda de digitação dessa maneira. 
\As teclas são adicionadas à fila de mensagens, o loop de mensagens do programa os recupera com GetMessage () posteriormente.
\Junto com o pressionamento de tecla, o windows também armazena o estado de todas as outras teclas. 
\Para garantir que, quando a mensagem for finalmente recuperada, você possa dizer com segurança quais outras chaves estavam desativadas. 
\Muito importante para as teclas modificadoras, por exemplo. 
\Um pressionamento de tecla de atalho como Ctrl + A não funcionaria de forma confiável de outra forma.
\Portanto, geralmente você sempre usa GetKeyState(), obtém o estado das chaves conforme foram gravadas originalmente. 
\Ou GetKeyboardState (), você obtém a lista inteira. 
\Usar GetAsyncKeyState () é muito menos comum, não depende do estado de buffer, necessário apenas se o aplicativo tiver um tratamento de mensagens muito incomum. 
\Pode ser apropriado em um jogo, talvez.

\GetKeyState retorna o estado da tecla virtual. 
\Em outras palavras, GetKeyState relata o estado do teclado com base nas mensagens que você recuperou de sua fila de entrada. 
\Este não é o mesmo que o estado físico do teclado:
\Se o usuário digitou anteriormente, GetKeyState não relata essas alterações até que você use a função PeekMessage ou a função GetMessage para recuperar a mensagem de sua fila de entrada.
\Se o usuário mudou para outro programa, a função GetKeyState não verá a entrada que o usuário digitou naquele outro programa, uma vez que essa entrada não foi enviada para a fila de entrada.
\Quando você deve usar GetKeyState e quando deve usar GetAsyncKeyState?
\Para o trabalho de interface do usuário, quase sempre você deseja GetKeyState.

\Se você está respondendo a uma mensagem de entrada e deseja saber quais teclas foram pressionadas no momento em que a entrada foi gerada, você deseja usar GetKeyState. 
\Por exemplo, se você deseja distinguir um clique esquerdo do mouse de Alt + LeftClick, você deve usar GetKeyState para consultar o estado da tecla Alt (conhecido como VK_MENU por razões históricas). 
\Isso porque você deseja saber se a tecla Alt estava pressionada quando o usuário clicou com o mouse, não se a tecla está pressionada neste exato instante. 
\Se o usuário liberou a tecla Alt entre o momento em que clicou e o momento em que você processou a mensagem, é irrelevante. 
\Você se preocupa se a tecla Alt estava pressionada no momento do clique.

Etapas para que se determine se uma tecla está ligada;
Etapas para que se determine se uma tecla está alternada;
Etapas para que se determine se uma tecla está ativada:
  Call "user32.dll" "GetKeyState" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getkeystate
  \Recupera o status da tecla virtual especificada. 
  \O status especifica se a tecla está para cima, para baixo ou alternada (ligada, desligada - alternando cada vez que a tecla é pressionada).
    A tecla [nVirtKey] \Uma chave virtual. Se a chave virtual desejada for uma letra ou dígito (A-Z, a-z ou 0-9), nVirtKey deve ser definido com o valor ASCII desse caractere. 
    \Para as demais teclas, deve ser um código de tecla virtual.
    \Se um layout de teclado diferente do inglês for usado, as teclas virtuais com valores no intervalo ASCII A a Z e 0 a 9 serão usadas para especificar a maioria das teclas de caracteres. 
    \Por exemplo, para o layout de teclado alemão, a tecla virtual de valor ASCII O (0x4F) se refere à tecla "o", enquanto VK_OEM_1 se refere à tecla "ö (o com trema)".
    devolvendo um word. \O valor de retorno especifica o status da tecla virtual especificada, da seguinte maneira:
    \Se o bit de ordem superior for 1, a tecla está para baixo; caso contrário, está para cima.
    \Se o bit de ordem inferior for 1, a chave está alternada. 
    \Uma tecla, como a tecla CAPS LOCK, está alternada se estiver ativada. 
    \A tecla está desligada e não alternada se o bit de ordem inferior for 0. 
    \Uma luz indicadora da tecla de alternância (se houver) no teclado ficará acesa quando a tecla for alternada e desligada quando a tecla for desativada.
  Atribua a word a um número.
  Conjuncione logicamente o número com 1.
  Se o número for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla está para cima:
  Se a tecla está para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma tecla com um lParam é alguma tecla de cancelamento ou tecla modificadora:
  Atribua o lParam a um número.
  Conjuncione logicamente o número com 1073741824 [$40000000].
  Se o número for 0, diga não.
  Se a tecla for a tecla Esc, diga sim.
  Se a tecla for algum tipo de tecla modificadora, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o botão esquerdo do mouse está para baixo:
  Se o botão esquerdo deste mouse estiver sendo pressionado, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma linha reta está acima of uma caixa:
  Se a coordenada Y desta localização inicial desta linha reta for maior do que ou igual à coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y desta localização final desta linha reta for maior do que ou igual à coordenada Y do canto superior esquerdo desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha reta está acima of uma coordenada:
  Se a coordenada Y desta localização inicial desta linha reta for maior do que ou igual à coordenada, diga não.
  Se a coordenada Y desta localização final desta linha reta for maior do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha reta está debaixo of uma caixa:
  Se a coordenada Y desta localização inicial desta linha reta for menor do que ou igual à coordenada Y do canto inferior direito desta caixa, diga não.
  Se a coordenada Y desta localização final desta linha reta for menor do que ou igual à coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha reta está debaixo of uma coordenada:
  Se a coordenada Y desta localização inicial desta linha reta for menor do que ou igual à coordenada, diga não.
  Se a coordenada Y desta localização final desta linha reta for menor do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha reta está still em uma caixa;
Etapas para que se determine se uma linha reta está em uma caixa:
  Se a localização inicial desta linha reta não estiver na caixa, diga não.
  Se a localização final desta linha reta não estiver na caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número misto é um número:
  Converta o número misto para uma fração.
  Se a fração for o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o mouse foi arrastado desde uma localização usando uma malha:
  Se o botão esquerdo deste mouse não estiver sendo pressionado, diga não.
  Atribua a localização deste mouse a uma segunda localização.
  Obtenha um difference entre a segunda localização e a localização.
  Se a difference estiver within a malha, recomece.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o mouse está em uma caixa:
  Se a localização deste mouse estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é um segundo número e uma string é uma segunda string:
  Se o número não for o segundo número, diga não.
  Se a string não for a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número está entre um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, diga não.
  Se o número for maior do que o terceiro número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é par:
  Se o número for ímpar, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é uniformemente divisível por um segundo número:
  Isole o número.
  Divida o número pelo segundo número usando um quociente e um resto.
  Se o resto for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é um múltiplo of um segundo número:
  Se o número for uniformemente divisível pelo segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é negativo:
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é ímpar:
  Isole o número.
  Conjuncione logicamente o número com 1.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é positive:
  Se o número for menor do que 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é prime:
  Se o número for menor do que 2, diga não.
  Se o número for 2, diga sim.
  Atribua o número menos 1 a um segundo número.
  Comece. [a executar o código abaixo]
    Se o número é uniformemente divisível pelo segundo número, diga não.
    Subtraia 1 desde o segundo número.
    Se o segundo número for maior do que 1, recomece.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um segundo par de números:
  Se o número X deste par de números não for o número X deste segundo par de números, diga não.
  Se o número Y deste par de números não for o número Y deste segundo par de números, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um número e um segundo número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo é endereço da pasta-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste caractere final deste endereço completo for a barra invertida, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo é drive-format:
  Se o endereço completo começa com "\\", diga sim.
  Se a quantidade de caracteres deste endereço completo não for 3, diga não.
  Se o endereço completo termina com ":\", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo está vazia no sistema de arquivos;
Etapas para que se determine se um endereço completo estão vazias no sistema de arquivos;
Etapas para que se determine se um endereço completo estão vazios no sistema de arquivos;
Etapas para que se determine se um endereço completo está vazio no sistema de arquivos:
  Se o endereço completo não estiver no sistema de arquivos, diga sim.
  Obtenha uma contagem of items no endereço completo no sistema de arquivos.
  Se a contagem for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo é file-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste caractere final deste endereço completo for o sinal de dois pontos, diga não.
  Se o conteúdo deste caractere final deste endereço completo for a barra invertida, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo está no sistema de arquivos:
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-getfileattributesa
  \Obtém atributos do sistema de arquivos para um arquivo ou diretório especificado.
  \Para obter mais informações sobre o atributo obtido, use a função GetFileAttributesEx.
  \Os atributos de arquivo são valores de metadados armazenados pelo sistema de arquivos em disco 
  \e são usados pelo sistema e estão disponíveis para desenvolvedores por meio de várias APIs de E/S de arquivo.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo ou diretório.
    \Na versão ANSI desta função, o nome é limitado a MAX_PATH caracteres. 
    \Para estender esse limite para 32.767 caracteres largos, chame a versão Unicode da função (GetFileAttributesW) e acrescente "\\? \" Ao caminho. 
    \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/naming-a-file
    \A partir do Windows 10, versão 1607, para a versão Unicode desta função (GetFileAttributesW), 
    \você pode optar por remover a limitação de caracteres MAX_PATH sem incluir "\\? \" No início.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno conterá os atributos do arquivo ou diretório especificado. 
    \Para obter uma lista de valores de atributo e suas descrições, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-attribute-constants
    \Se a função falhar, o valor de retorno é -1 (INVALID_FILE_ATTRIBUTES).
  Se o número for menor do que 0, diga não. \Acho que pode melhorar isso aqui
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo é somente leitura:
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-getfileattributesa
  \Obtém atributos do sistema de arquivos para um arquivo ou diretório especificado.
  \Para obter mais informações sobre o atributo obtido, use a função GetFileAttributesEx.
  \Os atributos de arquivo são valores de metadados armazenados pelo sistema de arquivos em disco 
  \e são usados pelo sistema e estão disponíveis para desenvolvedores por meio de várias APIs de E/S de arquivo.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo ou diretório.
    \Na versão ANSI desta função, o nome é limitado a MAX_PATH caracteres. 
    \Para estender esse limite para 32.767 caracteres largos, chame a versão Unicode da função (GetFileAttributesW) e acrescente "\\? \" Ao caminho. 
    \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/naming-a-file
    \A partir do Windows 10, versão 1607, para a versão Unicode desta função (GetFileAttributesW), 
    \você pode optar por remover a limitação de caracteres MAX_PATH sem incluir "\\? \" No início.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno conterá os atributos do arquivo ou diretório especificado. 
    \Para obter uma lista de valores de atributo e suas descrições, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-attribute-constants
    \Se a função falhar, o valor de retorno é -1 (INVALID_FILE_ATTRIBUTES).
  Conjuncione logicamente o número com 1 [FILE_ATTRIBUTE_READONLY]. \Um arquivo que é somente leitura. 
  \Os aplicativos podem ler o arquivo, mas não podem gravá-lo ou excluí-lo. Este regra não é respeitada em diretórios, a não ser que sejam diretórios de sistema
  Se o número não for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um ponteiro pode ser encontrado;
\Etapas para que se determine se um ponteiro é encontrado;
Etapas para que se determine se um ponteiro foi encontrado;
Etapas para que se determine se um ponteiro existe:
  Se o ponteiro for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um ponteiro está sumido do mapa;
Etapas para que se determine se um ponteiro é null e vazio:
  Se o ponteiro for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um polígono está closed:
  Se o polígono for inexistente, diga não.
  Se a contagem destes vértices deste polígono for menor do que 3, diga não.
  Se a localização deste first vértice deste polígono for a localização deste last vértice deste polígono, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um texto retornado é something like uma segunda texto retornado:
  Isole o texto retornado.
  Isole a segunda texto retornado.
  Simplify o texto retornado.
  Simplify a segunda texto retornado.
  Se o texto retornado é a segunda texto retornado, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma linha de texto está em branco:
  Se a linha de texto for inexistente, diga sim.
  Lance um subtexto sobre a string deste linha de texto.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste caractere inicial deste subtexto não for irrelevante, diga não.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma linha de texto of uma caixa de texto está selecionado:
  Se a caixa de texto for inexistente, diga não.
  Se a linha de texto for inexistente, diga não.
  Se nada estiver selecionado na caixa de texto, diga não.
  Atribua a normalized seleção desta caixa de texto a uma seleção.
  Se o número da linha desta linha de texto for menor do que o anchor número da linha desta seleção, diga não.
  Se o número da linha desta linha de texto for maior do que o número de linhas do cursor desta seleção, diga não.
  Se o número da linha desta linha de texto não for o número de linhas do cursor desta seleção, diga sim.
  Se o cursor de texto número de coluna desta seleção for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha de texto of uma caixa de texto é visível:
  Se a caixa de texto for inexistente, diga não.
  Se a linha de texto for inexistente, diga não.
  Obtenha uma caixa usando a linha de texto e a caixa de texto.
  Atribua a caixa desta caixa de texto a uma segunda caixa.
  Ajuste a segunda caixa usando 0 e a quantidade de twips/pixel e 0 e - a quantidade de twips/pixel .
  Se a caixa estiver tocando a segunda caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma seleção é uma segunda seleção:
  Se o anchor desta seleção não for o anchor desta segunda seleção, diga não.
  Se o cursor de texto desta seleção não for o cursor de texto desta segunda seleção, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se something está selecionado em uma caixa de texto:
  Se o anchor desta caixa de texto for o cursor de texto desta caixa de texto, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está acima of uma caixa:
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está acima of um linha reta horizontal:
  Se a coordenada Y desta localização for menor do que o horizontal y desta localização inicial desta linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está acima of ou debaixo of uma caixa:
  Se a localização está acima of a caixa, diga sim.
  Se a localização é debaixo of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é debaixo of uma caixa:
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é debaixo of um linha reta horizontal:
  Se a coordenada Y desta localização for maior do que o horizontal y desta localização inicial desta linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está em uma elipse:
  Crie um hRgn usando a elipse.
  Isole a localização.
  Divida a localização pelo quantidade de twips/pixel .
  Call "gdi32.dll" "PtInRegion" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-ptinregion
  \A função PtInRegion determina se o ponto especificado está dentro da região especificada.
    O hRgn [hrgn] \O número identificador da região a ser examinada.
    e A coordenada X desta localização [x] \Especifica a coordenada x do ponto em unidades lógicas.
    e A coordenada Y desta localização [y] \Especifica a coordenada y do ponto em unidades lógicas.
    devolvendo um número. \Se o ponto especificado estiver na região, o valor de retorno será diferente de zero.
  Destrua o hRgn.
  \Se o ponto especificado não estiver na região, o valor de retorno é zero.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em uma imagem:
  Se a imagem for inexistente, diga não.
  Se a localização estiver na caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está em um polígono:
  Se o polígono for inexistente, diga não.
  Crie uma série de vértices usando os vértices deste polígono.
  Call "gdi32.dll" "CreatePolygonRgn" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn
  \A função CreatePolygonRgn cria uma região poligonal.
    O ponteiro da localização desta série de vértices  [*pptl] \Um ponteiro para uma matriz de estruturas POINT que definem os vértices do polígono em unidades lógicas. 
   \O polígono é presumido como sendo um polígono fechado. Cada vértice pode ser especificado apenas uma vez.
    e A quantidade de vértices desta série de vértices [cPoint] \O número de pontos na matriz.
    e 2 [iMode = WINDING] \O modo de preenchimento usado para determinar quais pixels estão na região.  -> exemplo: https://docs.microsoft.com/pt-br/windows/win32/gdi/images/csrgn-03.png
    \Este parâmetro pode ser um dos seguintes valores.
    \ ALTERNATE ou Seleciona o modo alternativo (preenche a área entre os lados ímpares e pares do polígono em cada linha de varredura).
    \WINDING = Seleciona o modo de enrolamento (preenche qualquer região com um valor de enrolamento diferente de zero).
    \Para obter mais informações sobre esses modos, consulte a função SetPolyFillMode, ou leia mais abaixo:    
    \Um aplicativo preenche o interior de uma região chamando a função FillRgn e fornecendo um identificador que identifica um pincel específico. 
    \Quando um aplicativo chama FillRgn, o sistema preenche a região com a cor do pincel usando o modo de preenchimento atual para o contexto de dispositivo especificado. 
    \Existem dois modos de preenchimento: alternado e enrolamento. 
    \O aplicativo pode definir o modo de preenchimento para um contexto de dispositivo chamando a função SetPolyFillMode. 
    \O aplicativo pode recuperar o modo de preenchimento atual para um contexto de dispositivo chamando a função GetPolyFillMode.    
    \Modo Alternativo
    \Para determinar quais pixels o sistema destaca quando o modo alternativo é especificado, execute o seguinte teste:
    \Selecione um pixel no interior da região.
    \Desenhe um raio imaginário, na direção x positiva, desse pixel em direção ao infinito.
    \Cada vez que o raio cruza uma linha limite, aumente um valor de contagem.
    \O sistema destaca o pixel se o valor da contagem for um número ímpar.    
    \Modo de enrolamento
    \Para determinar quais pixels o sistema destaca quando o modo de enrolamento é especificado, execute o seguinte teste:
    \Determine a direção em que cada linha de limite é desenhada.
    \Selecione um pixel no interior da região.
    \Desenhe um raio imaginário, na direção x positiva, do pixel em direção ao infinito.
    \Cada vez que o raio intercepta uma linha limite com um componente y positivo, aumente um valor de contagem. 
    \Cada vez que o raio cruza uma linha limite com um componente y negativo, diminua o valor de contagem.
    \O sistema destaca o pixel se o valor da contagem for diferente de zero.
    devolvendo um hRgn. \Se a função for bem-sucedida, o valor de retorno será o número identificador da região.
    \Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "PtInRegion" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-ptinregion
  \A função PtInRegion determina se o ponto especificado está dentro da região especificada.
    O hRgn [hrgn] \O número identificador da região a ser examinada.
    e A coordenada X desta localização [x] \Especifica a coordenada x do ponto em unidades lógicas.
    e A coordenada Y desta localização [y] \Especifica a coordenada y do ponto em unidades lógicas.
    devolvendo um número. \Se o ponto especificado estiver na região, o valor de retorno será diferente de zero.
    \Se o ponto especificado não estiver na região, o valor de retorno é zero.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hRgn. [ho] \Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Destrua a série de vértices.
  \Se o identificador especificado não é válido ou está atualmente selecionado em um DC, o valor de retorno é zero.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em uns polígonos:
  Obtenha um polígono desde o polígonos.
  Se o polígono for inexistente, diga não.
  Se a localização estiver no polígono, diga sim.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma localização está em uma caixa arredondada:
  Isole a caixa arredondada.
  Adicione a quantidade de twips/pixel para a canto inferior direito desta caixa arredondada.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "CreateRoundRectRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-createroundrectrgn
  \A função CreateRoundRectRgn cria uma região retangular com cantos arredondados.
    A coordenada X do canto superior esquerdo desta caixa arredondada [x1] \todas as coordenadas estão em unidades de dispositivo
    e A coordenada Y do canto superior esquerdo desta caixa arredondada [y2]
    e A coordenada X do canto inferior direito desta caixa arredondada [x2]
    e A coordenada Y do canto inferior direito desta caixa arredondada [y2]
    e O diameter [w] \Especifica a largura da elipse (em unidades de dispositivo) usada para criar os cantos arredondados .
    e O diameter [h] \Especifica a altura da elipse (em unidades de dispositivo) usada para criar os cantos arredondados .
    devolvendo um hRgn. \Se a função for bem-sucedida, o valor de retorno será o identificador para a região.
    \Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "PtInRegion" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-ptinregion
  \A função PtInRegion determina se o ponto especificado está dentro da região especificada.
    O hRgn [hrgn] \O número identificador da região a ser examinada.
    e A coordenada X desta localização [x] \Especifica a coordenada x do ponto em unidades lógicas.
    e A coordenada Y desta localização [y] \Especifica a coordenada y do ponto em unidades lógicas.
    devolvendo um número. \Se o ponto especificado estiver na região, o valor de retorno será diferente de zero.
    \Se o ponto especificado estiver na região, o valor de retorno será diferente de zero.
    \Se o ponto especificado não estiver na região, o valor de retorno é zero.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hRgn. [ho] \Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em uma caixa de texto:
  Se a caixa de texto for inexistente, diga não.
  Se a localização estiver na caixa desta caixa de texto, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está inside uma caixa;
Etapas para que se determine se uma localização está within uma caixa;
Etapas para que se determine se uma localização está em uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, diga não.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está para a esquerda of uma caixa;
Etapas para que se determine se uma localização está para o lado esquerdo of uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está para a direita ou para a esquerda of uma caixa;
Etapas para que se determine se uma localização está para a esquerda ou para a direita of uma caixa;
Etapas para que se determine se uma localização está no lado esquerdo ou no lado direito of uma caixa;
Etapas para que se determine se uma localização está lado esquerdo ou lado direito of uma caixa:
  Se a localização estiver para o lado esquerdo of a caixa, diga sim.
  Se a localização estiver para o lado direito of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está sobre uma caixa:
  Atribua a caixa a uma segunda caixa.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a segunda caixa usando o número.
  Se a localização não estiver no segunda caixa, diga não.
  Atribua a caixa a um terceiro caixa.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent o terceiro caixa usando o segundo número.
  Se a localização estiver no terceiro caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está sobre uma elipse:
  Atribua a elipse a uma segunda elipse.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a caixa desta segunda elipse usando o número.
  Se a localização não estiver na segunda elipse, diga não.
  Atribua a elipse a uma terceiro elipse.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent a caixa desta terceiro elipse usando o segundo número.
  Se a localização estiver na terceiro elipse, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está sobre uma linha reta:
  Isole a linha reta.
  Atribua 3 times a quantidade de twips/pixel a um número.
  Comece. [a executar o código abaixo]
    Obtenha uma distance entre a localização e o centro desta linha reta (chessboard).
    Se a distance for menor do que ou igual ao número, diga sim.
    Obtenha a distance entre a localização inicial desta linha reta e a localização final desta linha reta (chessboard).
    Se a distance for menor do que ou igual ao quantidade de twips/pixel , diga não.
    Separe a linha reta à linha reta e uma segunda linha reta.
    Obtenha a distance entre a localização e o centro desta linha reta (chessboard).
    Obtenha uma segunda distance entre a localização e o centro desta segunda linha reta (chessboard).
    Se a distance for maior do que a segunda distance, atribua a segunda linha reta ao linha reta.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma localização está sobre uma imagem:
  Se a imagem for inexistente, diga não.
  Se a localização estiver sobre a caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está sobre um polígono:
  Se o polígono for inexistente, diga não.
  Comece. [a executar o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, diga não.
    Se o next deste vértice for inexistente, diga não.
    Atribua a localização deste vértice e a localização deste next deste vértice a uma linha reta.
    Se a localização estiver sobre a linha reta, diga sim.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma localização está sobre uma caixa arredondada:
  Atribua a caixa arredondada a uma segunda caixa arredondada.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a segunda caixa arredondada usando o número.
  Se a localização não estiver no segunda caixa arredondada, diga não.
  Atribua a caixa arredondada a um terceiro caixa arredondada.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent o terceiro caixa arredondada usando o segundo número.
  Se a localização estiver no terceiro caixa arredondada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é outside uma caixa:
  Se a localização é inside a caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é para o lado direito of uma caixa:
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é tocando uma caixa:
  Se a localização estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uma malha of uma segunda localização:
  Obtenha um difference entre a segunda localização e a localização.
  Se a difference está within a malha, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uns twips of uma segunda localização:
  Atribua os twips e os twips a uma malha.
  Se a localização estiver within a malha of a segunda localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uns twips of uma caixa:
  Isole a caixa.
  Outdent a caixa usando os twips.
  Se a localização estiver within a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o stack has just one coisa sobre it:
  Se a contagem deste stack for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se uma string does end com uma segunda string;
Etapas para que se determine se uma string termina com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o caractere final deste subtexto menos a quantidade de caracteres desta segunda string mais 1 ao caractere inicial deste subtexto.
  Se o subtexto for a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does start com uma segunda string;
Etapas para que se determine se uma string começa com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao caractere final deste subtexto.
  Se o subtexto é a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does start com um byte;
Etapas para que se determine se uma string começa com um byte:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o byte, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does end com um byte; \ adicionado por Mike Gonta
Etapas para que se determine se uma string termina com um byte:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string for o byte, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é uma segunda string (comparação de caracteres acentuados):
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos s/ acento ascii (equal only).

Etapas para que se determine se uma string é uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos ascii (equal only).

Etapas para que se determine se uma string é uma segunda string ou um terceiro string:
  Se a string é a segunda string, diga sim.
  Se a string é o terceiro string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de fração literal;
Etapas para que se determine se uma string é algum tipo de proporção literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Separe o subtexto a um numerador subtexto e um denominador subtexto usando o slash byte.
  Se o numerador subtexto não for algum tipo de integer literal, diga não.
  Se o denominador subtexto não for algum tipo de integer literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

\Etapas para que se determine se uma string é algum tipo de inteiro:
\ parece ser uma duplicata da rotina abaixo
\Lance um subtexto sobre a string.
\Se o subtexto estiver em branco, diga não.
\Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
\Se o subtexto estiver em branco, diga não.
\Comece. [a executar o código abaixo]
 \Se o conteúdo deste caractere inicial deste subtexto não for algum tipo de digit, diga não.
 \Adicione 1 para o caractere inicial deste subtexto.
\Se o subtexto estiver em branco, diga sim.
\Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma string é algum tipo de integer;
Etapas para que se determine se uma string é algum tipo de integer literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Comece. [a executar o código abaixo]
    Se o conteúdo deste caractere inicial deste subtexto não for algum tipo de digit, diga não.
    Adicione 1 para o caractere inicial deste subtexto.
    Se o subtexto estiver em branco, diga sim.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma string é algum tipo de número misto literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Separe o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto não for algum tipo de integer literal, diga não.
  Se a fração subtexto não for algum tipo de fração literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum tipo de numeric literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string não for algum tipo de indicador numérico, diga não.
  Se a string é algum tipo de integer literal, diga sim.
  Se a string é algum tipo de fração literal, diga sim.
  Se a string é algum tipo de número misto literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é tipo de sinal aritmético:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de palavra:
  Se a quantidade de caracteres desta string for menor do que 2, diga não.
  Lance um subtexto sobre a string.
  Subtraia 1 desde o caractere inicial deste subtexto.
  Comece. [a executar o código abaixo]
    Adicione 1 para o caractere inicial deste subtexto.
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste caractere inicial deste subtexto for algum tipo de letra, recomece.
    Se o conteúdo deste caractere inicial deste subtexto for o single-quote byte, recomece.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.



Etapas para que se determine se uma string é um byte:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string é o byte, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é dos-compatible:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string é o ponto final, diga não.
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste caractere inicial deste subtexto for o slash byte, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for a barra invertida, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o sinal de dois pontos, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o asterisco, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o ponto de interrogação, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for as aspas duplas, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o símbolo menor do que, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o símbolo maior do que, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o barra vertical, diga não.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma string é maior que uma segunda string;
Etapas para que se determine se uma string é maior do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é maior do que ou igual para uma segunda string;
Etapas para que se determine se uma string é maior que ou igual para uma segunda string;
Etapas para que se determine se uma string é maior ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string estiver em uma segunda string:
  Lance um subtexto sobre a segunda string.
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres desta string menos 1 ao caractere final deste subtexto.
  Comece. [a executar o código abaixo]
    Se o caractere final deste subtexto for maior do que o caractere final desta segunda string, diga não.
    Se o subtexto é a string, diga sim.
    Mova o subtexto usando 1.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma string estiver em um catálogo:
  Se o catálogo for inexistente, diga não.
  Se a string estiver em branco, diga não.
  Encontre um referência usando a string e o catálogo.
  Se o referência for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é menor que uma segunda string;
Etapas para que se determine se uma string é menor do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é menor do que ou igual para uma segunda string;
Etapas para que se determine se uma string é menor que ou igual para uma segunda string;
Etapas para que se determine se uma string é menor ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\ needs work por Spanish
Etapas para que se determine se uma string está escrito incorretamente:
  Se o dicionário léxico for inexistente, diga não.
  Se a string não for algum tipo de palavra, diga não.
  Isole a string.
  Se a string termina com "'s", remove os last dois bytes desde a string.
  Se a string estiver no catálogo deste dicionário léxico, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é wider do que uma caixa:
  \ presume que a fonte esteja selecionada no memory canvas
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Obtenha uma largura usando a string e o memory canvas.
  Subtraia o abcA desde a largura.
  Subtraia o abcC desde a largura.
  Se a largura for maior do que a largura desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um subtexto está sobre alguma espécie de contração:
  Atribua o caractere inicial deste subtexto mais 1 a um ponteiro do byte .
  Se o ponteiro do byte for maior do que o caractere final deste subtexto, diga não.
  Se o conteúdo deste caractere inicial deste subtexto não for o single-quote byte, diga não.
  Se o conteúdo deste ponteiro do byte não for algum tipo de letra, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um terminal está totalmente prenchido:
  Atribua a altura deste terminal dividido por 24 pixels a um número.
  Se a contagem destes quoras deste terminal for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma caixa de texto pode ser refeito:
  Se a caixa de texto for inexistente, diga não.
  Se o last destes refeitos desta caixa de texto for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa de texto pode ser desfeito:
  Se a caixa de texto for inexistente, diga não.
  Se o last destes desfeitos desta caixa de texto for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa de texto foi alterado:
  Se a caixa de texto for inexistente, diga não.
  Se o detector de alteração desta caixa de texto estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe something para backspace em uma caixa de texto:
  Se a caixa de texto for inexistente, diga não.
  Se something estiver selecionado na caixa de texto, diga sim.
  Se o número de linhas do cursor desta caixa de texto não for 1, diga sim.
  Se o cursor de texto número de coluna desta caixa de texto não for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe something para remove em uma caixa de texto:
  Se a caixa de texto for inexistente, diga não.
  Se something estiver selecionado na caixa de texto, diga sim.
  Se o número de linhas do cursor desta caixa de texto não for a contagem de linhas desta caixa de texto, diga sim.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Se o cursor de texto número de coluna desta caixa de texto não for a quantidade de caracteres desta string desta linha de texto, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se há caixa de texto na área de transferência do Windows;
Etapas para que se determine se existe caixa de texto sobre a área de transferência do Windows:
  Call "user32.dll" "IsClipboardFormatAvailable" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-isclipboardformatavailable
  \Determina se a área de transferência contém dados no formato especificado.
  1 [format = CF_TEXT]  \Um formato de área de transferência padrão ou registrado. 
  \Para obter uma descrição dos formatos padrão da área de transferência, consulte https://docs.microsoft.com/pt-br/windows/win32/dataxchg/standard-clipboard-formats
  \CF_TEXT = Formato de texto. 
  \Cada linha termina com uma combinação de retorno de carro / avanço de linha (CR-LF). 
  \Um caractere nulo sinaliza o fim dos dados. 
  \Use este formato para texto ANSI.
    devolvendo um número.
    \Se o formato da área de transferência estiver disponível, o valor de retorno será diferente de zero.
    \Se o formato da área de transferência não estiver disponível, o valor de retorno será zero.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se umas coisas estão vazios;
Etapas para que se determine se umas coisas estão vazias;
Etapas para que se determine se umas coisas estão vazia;
Etapas para que se determine se umas coisas estão vazio:
  Se a first coisa destas coisas for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um segmento inicial é numeric:
  Isole o segmento inicial.
  Remove algum tipo de leading noise desde o segmento inicial.
  Se o segmento inicial estiver em branco, diga não.
  Comece. [a executar o código abaixo]
    Obtenha um byte desde o segmento inicial.
    Se o byte não for algum tipo de digit, diga não.
    Se o segmento inicial estiver em branco, diga sim.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se o usuário está clicking em umas escolhas;
Etapas para que se determine se o usuário has clicked em umas escolhas;
Etapas para que se determine se o usuário clicked em umas escolhas;
Etapas para que se determine se o usuário clicks em umas escolhas;
Etapas para que se determine se o usuário está clicking sobre umas escolhas;
Etapas para que se determine se o usuário has clicked sobre umas escolhas;
Etapas para que se determine se o usuário clicked sobre umas escolhas;
Etapas para que se determine se o usuário clicks sobre umas escolhas:
Etapas para que se determine se o usuário clickou sobre umas escolhas:
Etapas para que se determine se o usuário clicou sobre umas escolhas:
Etapas para que se determine se o usuário clickou em umas escolhas:
Etapas para que se determine se o usuário clicou em umas escolhas:
  Comece. [a executar o código abaixo]
  Se o botão esquerdo deste mouse não estiver para baixo, diga não.
  Encontre uma escolha usando a localização deste mouse.
  Se a escolha can't ser encontrado, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

  

Etapas para que se determine se we pode encontre um ponteiro:
  \ deveria ser "can" not "ca", compilador bug
  Se o ponteiro for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we could encontre um ponteiro:
  Se o ponteiro for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we did encontre um ponteiro:
  Se o ponteiro for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we're acima of uma caixa:
  Se a coordenada Y deste contexto for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're acima of uma coordenada:
  Se a coordenada Y deste contexto for menor do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're acima of um linha reta horizontal:
  Se a localização deste contexto está acima of o linha reta horizontal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're acima of ou debaixo of uma caixa:
  Se a coordenada Y deste contexto for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
  Se a coordenada Y deste contexto for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're acima of uma localização:
  Se a coordenada Y deste contexto for menor do que a coordenada Y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're debaixo of uma caixa:
  Se a coordenada Y deste contexto for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're debaixo of uma coordenada:
  Se a coordenada Y deste contexto for maior do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're debaixo of um linha reta horizontal:
  Se a localização deste contexto é debaixo of o linha reta horizontal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're debaixo of uma localização:
  Se a coordenada Y deste contexto for maior do que a coordenada Y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're facing north:
  \ *** need east, south, west
  Normalize a orientação deste contexto.
  Se a orientação deste contexto for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're no lado esquerdo of uma caixa;
Etapas para que se determine se we're esquerda of uma caixa;
Etapas para que se determine se we're lado esquerdo of uma caixa:
  Se a coordenada X deste contexto for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're no lado esquerdo ou no lado direito of uma caixa;
Etapas para que se determine se we're esquerda ou direita of uma caixa;
Etapas para que se determine se we're lado esquerdo ou lado direito of uma caixa:
  Se a coordenada X deste contexto for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
  Se a coordenada X deste contexto for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're outside uma caixa:
  Se a localização deste contexto estiver outside a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're lado direito of uma caixa:
  Se a coordenada X deste contexto for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're still em uma caixa;
Etapas para que se determine se we're em uma caixa:
  Se a localização deste contexto estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're within uns twips of uma caixa:
  Se a localização deste contexto está within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se you feel like it:
  Escolha aleatoriamente um número entre 1 e 100.
  Se o número for menor do que 51, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se decifre um trecho usando uma passphrase string:
  \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie uma crypt session usando o passphrase.
  Se a crypt session for inexistente, cancele.
  Converta o trecho como uma cifra hexadecimal para um texto hexadecimal.
  Atribua a quantidade de caracteres deste texto hexadecimal a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptDecrypt" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-cryptdecrypt
  \A função CryptDecrypt descriptografa os dados criptografados anteriormente usando a função CryptEncrypt.
  \Importante: Esta API está obsoleta. 
  \Softwares deveriam começar a usar APIs de criptografia de última geração. 
  \A Microsoft pode remover esta API em versões futuras.
    A hCryptKey desta crypt session [hKey] \Um identificador para a chave a ser usada para a descriptografia. 
    \Um aplicativo pode obter esse identificador usando a função CryptGenKey ou CryptImportKey.
    \ https://docs.microsoft.com/pt-br/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey
    \ https://docs.microsoft.com/pt-br/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey
    \Esta chave especifica o algoritmo de descriptografia a ser usado.
    e 0 [hHash] \Um identificador para um objeto hash. 
    \Se os dados devem ser descriptografados e hasheadps simultaneamente, um identificador para um objeto hash é passado neste parâmetro. 
    \O valor do hash é atualizado com o texto simples descriptografado. 
    \Esta opção é útil ao descriptografar e verificar uma assinatura simultaneamente.
    \Antes de chamar CryptDecrypt, o aplicativo deve obter um identificador para o objeto hash chamando a função CryptCreateHash. 
    \ https://docs.microsoft.com/pt-br/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash
    \Depois que a descriptografia for concluída, o valor de hash pode ser obtido usando a função CryptGetHashParam, 
    \ https://docs.microsoft.com/pt-br/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam
    \ele também pode ser assinado usando a função CryptSignHash 
    \ https://docs.microsoft.com/pt-br/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha
    \ou pode ser usado para verificar uma assinatura digital usando a função CryptVerifySignature.
    \ https://docs.microsoft.com/pt-br/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea
    \Se nenhum hash for feito, este parâmetro deve ser zero.
    e 1 [Final] \Um valor booleano que especifica se esta é a última seção de uma série que está sendo descriptografada. 
    \Este valor é TRUE se este for o último ou único bloco. Se este não for o último bloco, o valor é FALSE.
    e 0 [dwFlags] \ não define nenhuma opção
    e O caractere inicial deste texto hexadecimal [*pbData] \Um ponteiro para um buffer que contém os dados a serem descriptografados. 
    \Depois que a descriptografia foi executada, o texto simples é colocado de volta neste mesmo buffer.
    \O número de bytes criptografados neste buffer é especificado por pdwDataLen abaixo
    e O endereçamento deste quantidade de caracteres [*pdwDataLen] \Um ponteiro para um valor DWORD que indica o comprimento do buffer pbData. 
    \Antes de chamar essa função, o aplicativo de chamada define o valor DWORD como o número de bytes a serem descriptografados. 
    \Ao retornar, o valor DWORD contém o número de bytes do texto simples descriptografado.
    \Quando uma cifra de bloco é usada, esse comprimento de dados deve ser um múltiplo do tamanho do bloco, a menos que esta seja a seção final dos dados a ser descriptografada e o parâmetro Final seja TRUE.
    devolvendo um número resultante. \Se a função for bem-sucedida, ela retornará um valor diferente de zero (VERDADEIRO).
    \Se a função falhar, ele retornará zero (FALSO).
  Se o número resultante for 0, atribua "Ocorreu um erro ao tentar decifrar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; saia.
  Destrua o crypt session.
  Atribua o texto hexadecimal ao trecho.

O fonte padrão é uma fonte.

O default smtp server é "localhost".

Um degree é um número [cujos valores variam entre 0 até 359].

Um depth é uns twips.

Um description é uma string.

Etapas para que se desvencilhe-se de uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua o cursor de texto desta caixa de texto ao anchor desta caixa de texto.

Etapas para que se destrua um crypt session:
  Se o crypt session for inexistente, cancele.
  Call "advapi32.dll" "CryptDestroyKey" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-cryptdestroykey
  \A função CryptDestroyKey libera o identificador referenciado pelo parâmetro hKey.
  \Se o identificador se referir a uma chave de sessão ou a uma chave pública que foi importada para o provedor de serviços de criptografia (CSP) por meio de CryptImportKey, 
  \essa função destrói a chave e libera a memória que a chave usou. 
  \Muitos CSPs sobrescrevem a memória onde a chave estava armazenada antes de liberá-la. 
  \No entanto, o par de chaves pública / privada subjacente não é destruído por esta função. Apenas o identificador é destruído.
    A hCryptKey desta crypt session.[hKey] \O número identificador da chave a ser destruída.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "advapi32.dll" "CryptDestroyHash" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-cryptdestroyhash
  \A função CryptDestroyHash destrói o objeto hash referenciado pelo parâmetro hHash. 
  \Depois que um objeto hash é destruído, ele não pode mais ser usado.
 \Para ajudar a garantir a segurança, recomendamos que os objetos hash sejam destruídos depois de usados.
  \Importante: Esta API está obsoleta. O softwares deveriam começar a usar APIs de criptografia de última geração. A Microsoft pode remover esta API em versões futuras.
  \Quando um objeto hash é destruído, muitos CSPs sobrescrevem a memória no CSP onde o objeto hash foi mantido. A memória CSP é então liberada.
  \Deve haver uma correspondência um para um entre as chamadas para CryptCreateHash e CryptDestroyHash.
  \Todos os objetos hash que foram criados usando um CSP específico devem ser destruídos antes que o identificador CSP seja liberado com a função CryptReleaseContext.
    O hcrypthash desta crypt session. [hHash] \O identificador do objeto hash a ser destruído.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "advapi32.dll" "CryptReleaseContext" com \https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-cryptreleasecontext
  \A função CryptReleaseContext libera o identificador de um provedor de serviços criptográficos (CSP) e um contêiner de chave. 
  \A cada chamada para esta função, a contagem de referência no CSP é reduzida em um. 
  \Quando a contagem de referência chega a zero, o contexto é totalmente liberado e não pode mais ser usado por nenhuma função no aplicativo.
  \Um aplicativo chama essa função após terminar o uso do CSP. 
  \Depois que essa função é chamada, o identificador CSP liberado não é mais válido. 
  \Esta função não destrói contêineres de chaves ou pares de chaves.
  \Importante: Esta API está obsoleta. O softwares deveriam começar a usar APIs de criptografia de última geração. A Microsoft pode remover esta API em versões futuras.
  \Depois que essa função for chamada, a sessão CSP é concluída e todas as chaves de sessão existentes e objetos hash criados usando o identificador hProv não são mais válidos. 
  \Na prática, todos esses objetos devem ser destruídos com chamadas para CryptDestroyKey e CryptDestroyHash antes de CryptReleaseContext ser chamado.
    O hCryptProv desta crypt session [hProv] \Identificador de um provedor de serviços criptográficos (CSP) criado por uma chamada para CryptAcquireContext.
    e 0. [dwFlags] \Reservado para uso futuro e deve ser zero. 
    \Se dwFlags não estiver definido como zero, esta função retornará FALSE, mas o CSP será liberado
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero (VERDADEIRO).
    \Se a função falhar, o valor de retorno é zero (FALSO)..
  Desaloque o crypt session.

Etapas para que se destrua um GpImage:
  Se o GpImage for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImage" com
\Descarta o objeto Image especificado.  
  o GpImage. [*image]
  \GpImage é um ponteiro para o objeto Imagem que será descartado.
  \Geralmente refere-se a uma imagem criada pelas funções GdipLoadImageFromFile, GdipLoadImageFromStream e outras funções construtoras de imagem.
  \Obs: A função retorna o valor GpStatus, sendo que o valor 0 significa que função foi bem-sucedida.
  Esvazie o GpImage.

Etapas para que se destrua um GpImageAttributes:
  Se o GpImageAttributes for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImageAttributes" com o GpImageAttributes. [*imageattr]
  \GpImageAttributes é um ponteiro para o objeto ImageAttributes a ser descartado.
  \O Objeto ImageAttributes é retornado por uma das duas funções para criar objetos ImageAttributes .
  \Esta função destrói o objeto ImageAttributes e libera os recursos associados.
  \Cada chamada bem-sucedida para uma das duas funções para criar objetos ImageAttributes deve corresponder a uma chamada para essa função.
  \As funções para criar um ImageAttributes são as seguintes:
  \GdipCloneImageAttributes
  \GdipCreateImageAttributes
  \Obs: A função retorna o valor GpStatus, sendo que o valor 0 significa que função foi bem-sucedida.
  \Ou seja, se a função for bem-sucedida, ela retornará 0, que é uma constante da enumeração de status .
   \Se a função falhar, ela retornará um dos outros valores da enumeração de status .
  Esvazie o GpImageAttributes.

Etapas para que se destrua o hBrush of um canvas:
  Call "gdi32.dll" "SelectObject" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O null hBrush  [h] \O número identificador do objeto a ser selecionado.
    devolvendo um hBrush. \Se o objeto selecionado não for uma região e a função for bem-sucedida, o valor de retorno é um identificador para o objeto que está sendo substituído.
    \Se o objeto selecionado for uma região e a função for bem-sucedida, o valor de retorno será
    \1 (NULLREGION quando a região estiver vazia.)
    \2 (SIMPLEREGION - quando a região consistir em um único retângulo.)
    \3 (COMPLEXREGION - quando a região consistir em mais de um retângulo.)
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hBrush. \Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.

Etapas para que se destrua o número da fonte of um canvas:
  Call "gdi32.dll" "SelectObject" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O null número da fonte [h] \O número identificador do objeto a ser selecionado.
    devolvendo um número da fonte.\Se o objeto selecionado não for uma região e a função for bem-sucedida, o valor de retorno é um identificador para o objeto que está sendo substituído.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O número da fonte.\Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.

Etapas para que se destrua o hPen of um canvas:
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O null hPen  [h] \O número identificador do objeto a ser selecionado.
    devolvendo um hPen.\Se o objeto selecionado não for uma região e a função for bem-sucedida, o valor de retorno é um identificador para o objeto que está sendo substituído.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hPen.\Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.

Etapas para que se destrua um hRgn:
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hRgn. [ho] \Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.

Etapas para que se destrua um catálogo:
  Se o catálogo for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, pare.
    Destrua os referências deste bucket.
  Recomece. [percorra novamente o código acima]
  Unassign o first bucket deste catálogo.
  Desaloque o catálogo.

Etapas para que se destrua um endereço completo no sistema de arquivos:
  Defina o endereço completo para read-write mode.
  Se o endereço completo é endereço da pasta-format, destrua o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, destrua o endereço completo no sistema de arquivos (arquivo).

Etapas para que se destrua um endereço completo no sistema de arquivos (pasta)[endereço]:
  Comece. [a executar o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for encontrado, pare.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Destrua a segunda endereço completo no sistema de arquivos.
    Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Recomece. [percorra novamente o código acima]
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "RemoveDirectoryA" com \https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-removedirectorya
  \A função RemoveDirectoryA exclui um diretório vazio existente.
    O caractere inicial deste endereço completo [lpPathName] \O caminho do diretório a ser removido. 
    \Este caminho deve especificar um diretório vazio e o processo de chamada deve ter acesso de exclusão ao diretório.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, saia. \Se a função falhar, o valor de retorno é zero.
  Atribua "Erro. Não foi possível apagar a pasta '" junto com o endereço completo seguido de "'." ao erro do fluxo de entrada/saída.

Etapas para que se destrua uma endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "DeleteFileA" com \https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-deletefilea
  \A função DeleteFileA exclui um arquivo existente.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo a ser excluído.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, saia. \Se a função falhar, o valor de retorno é zero (0).
  Atribua "Erro. Não foi possível apagar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se destrua uma imagem:
  Se a imagem for inexistente, cancele.
  Destrua o gpBitmap desta imagem.
  Desaloque a imagem.

Etapas para que se destrua um socket: 
  Call "ws2_32.dll" "closesocket" com \https://docs.microsoft.com/pt-br/windows/win32/api/winsock/nf-winsock-closesocket
  \A função closesocket fecha um socket existente.
    O socket.[s] \Um descritor que identifica o soquete a ser fechado.
  \Se nenhum erro ocorrer, closesocket retorna zero. 
  \Caso contrário, um valor de SOCKET_ERROR é retornado e um código de erro específico pode ser recuperado chamando WSAGetLastError.
  \A função closesocket fecha um socket. 
  \Use-o para liberar o descritor de soquete passado no parâmetro s. 
  \Observe que o descritor de socket passado no parâmetro s pode ser imediatamente reutilizado pelo sistema assim que a função closesocket for emitida. 
  \Como resultado, não é confiável esperar que referências adicionais ao descritor de soquete passado no parâmetro s falhem com o erro WSAENOTSOCK. 
  \Um cliente Winsock nunca deve emitir closesocket em s simultaneamente com outra chamada de função Winsock

Etapas para que se destrua um vértice usando um polígono:
  Se o vértice for inexistente, cancele.
  Se o polígono for inexistente, cancele.
  Isole o vértice.
  Remove o vértice desde os vértices deste polígono.
  Destrua o vértice.

Etapas para que se destrua uma requisição WinHTTP:
  Se a requisição WinHTTP for inexistente, cancele.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com \https://docs.microsoft.com/pt-br/windows/win32/api/winhttp/nf-winhttp-winhttpclosehandle
  \A função WinHttpCloseHandle fecha um único identificador HINTERNET. 
  \O Microsoft Windows HTTP Services (WinHTTP) usa identificadores para controlar as configurações e as informações necessárias ao usar o protocolo HTTP. 
  \Cada identificador mantém informações pertinentes a uma sessão HTTP, uma conexão com um servidor HTTP ou um recurso específico.
  \Os identificadores criados e usados pelo WinHTTP são chamados de identificadores HINTERNET.
  \Para mais detalhes, consulte https://docs.microsoft.com/pt-br/windows/win32/winhttp/hinternet-handles-in-winhttp
    O número identificador de requisição [hInternet] desta requisição WinHTTP. 
    \Um identificador HINTERNET válido a ser fechado.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com 
    O número identificador de conexão [hInternet] desta requisição WinHTTP.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com 
    O número identificador de sessão [hInternet] deste número identificador de requisição desta requisição WinHTTP.
    \O valor de retorno da função WinHttpCloseHandle é TRUE se o identificador for fechado com sucesso, caso contrário é FALSE.
  Deallocate a requisição WinHTTP.

Uma difference é um par de números.

Um file é um número identificador.
Um nome do arquivo é uma string. \ é o nome que vem depois da barra / até o final da extensão. Exemplo: arquivo.txt
Um nome do arquivo s/ extensão é uma string. \ Auto explicativo. 
Um extensão é uma string. \ Contém o ponto. Exemplo: .txt
Um endereço da pasta é um endereço completo. \ Exemplo: c:\pasta1\pasta2\
Um endereço completo é uma string. \Endereço completo do arquivo. Exemplo: c:\pasta1\pasta2\arquivo.txt
Um nome do diretório é uma string. \ nome da pasta com a barra no final. Exemplo = pasta2\
Um designador é uma string. \  pode ser igual ao nome do diretório ou igual ao nome do arquivo, se houver
Um nome da pasta é uma string. \ nome da pasta sem a barra no final. Exemplo = pasta2
Um unidade de disco é uma string. \ Exemplo: c:\ ou  \\NomeDoPC\DiretórioCompartilhado\
Um unidade de rede é uma string. \ é basicamente a cópia da variável anterior. Nome diferente pra evitar confusão.
Um categoria da unidade de disco é uma string. \HD, Pen-drive, Disquete, DVD, etc
Um nome da unidade de disco é uma string.

Um distance é uns twips.

Etapas para que se divida uma fração por uma segunda fração:
  Isole a segunda fração.
  Flip a segunda fração.
  Multiplique a fração pela segunda fração.

Etapas para que se divida uma fração por um número:
  Multiplique o denominador desta fração pelo número.
  Reduza a fração.

Etapas para que se divida um número por uma fração:
  Isole a fração.
  Flip a fração.
  Multiplique o número pela fração.

Etapas para que se divida um par de números por um segundo par de números:
  Divida o número X deste par de números pelo número X deste segundo par de números.
  Divida o número Y deste par de números pelo número Y deste segundo par de números.

Etapas para que se divida um par de números por um número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo número.

Etapas para que se divida um par de números por um número e um segundo número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo segundo número.

\Um DOCINFO é um conjunto com
\Um número denominado cbSize,
\Um ponteiro denominado lpszDocName,
\Um ponteiro denominado lpszoutput,
\Um ponteiro denominado lpszdatadtype,
\Um número denominado fwtype.

Um dot é uma elipse.

Etapas para que se double um número:
  Adicione o número para o número.

Etapas para que se pinte e preencha uma caixa com uma cor:
  Pinte a caixa com a cor e a cor.

Etapas para que se pinte algum tipo de visível linhas des textos of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se a linha de texto of a caixa de texto não estiver visível, recomece.
    Pinte a linha de texto of a caixa de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte algum tipo de visível linhas des textos of uma caixa de texto (editing):
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se a linha de texto of a caixa de texto não for visível, recomece.
    Pinte a linha de texto of a caixa de texto (editing).
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas para que se pinte uma caixa (focus style):
  Isole a caixa.
  Adicione a quantidade de twips/pixel para o canto inferior direito desta caixa.
  Call "gdi32.dll" "LPtoDP" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-lptodp
  \A função LPtoDP converte coordenadas lógicas em coordenadas de dispositivo. 
  \A conversão depende do modo de mapeamento do contexto do dispositivo, 
  \das configurações das origens e extensões da janela e da janela de visualização e da transformação do mundo.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e O endereçamento desta caixa [lppt] \Um ponteiro para uma matriz de estruturas POINT. 
    \ https://docs.microsoft.com/pt-br/previous-versions/dd162805(v=vs.85)
    \As coordenadas x e y contidas em cada uma das estruturas POINT serão transformadas.
    e 2. [c] \O número de pontos na matriz.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
  Converta a cor branca para um código da cor. \ sugestões de termo: código de pigmento/tonalidade
  Call "gdi32.dll" "SetBkColor" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setbkcolor
  \A função SetBkColor define a cor de fundo atual para o valor da cor especificada 
  \ou para a cor física mais próxima se o dispositivo não puder representar o valor da cor especificada.
  \Esta função preenche as lacunas entre as linhas estilizadas desenhadas com uma caneta criada pela função CreatePen; 
  \ela não preenche as lacunas entre as linhas estilizadas desenhadas com uma caneta criada pela função ExtCreatePen. 
  \A função SetBkColor também define as cores de fundo para TextOut e ExtTextOut.
  \Se o modo de fundo for OPACO, a cor de fundo será usada para preencher as lacunas 
  \entre as linhas estilizadas, lacunas entre as linhas hachuradas em pincéis e células de caracteres. 
  \A cor de fundo também é usada ao converter bitmaps coloridos em monocromáticos e vice-versa.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e O código da cor. [color] \A nova cor de fundo. Para criar um valor COLORREF, use a macro RGB.
    \Se a função for bem-sucedida, o valor de retorno especifica a cor de fundo anterior como um valor COLORREF.
    \Se a função falhar, o valor de retorno é CLR_INVALID.
  Converta a cor preta para um segundo código da cor.
  Call "gdi32.dll" "SetTextColor" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-settextcolor
  \A função SetTextColor define a cor do texto para o contexto de dispositivo especificado para a cor especificada.
  \A cor do texto é usada para desenhar a face de cada caractere escrito pelas funções TextOut e ExtTextOut. 
  \A cor do texto também é usada na conversão de bitmaps coloridos em monocromáticos e vice-versa.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e O segundo código da cor. [color] \A cor do texto.
    \Se a função for bem-sucedida, o valor de retorno é uma referência de cor para a cor do texto anterior como um valor COLORREF.
    \Se a função falhar, o valor de retorno é CLR_INVALID.
  Call "gdi32.dll" "SetMapMode" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setmapmode
  \A função SetMapMode define o modo de mapeamento do contexto de dispositivo especificado. 
  \O modo de mapeamento define a unidade de medida usada para transformar unidades de espaço de página em unidades de espaço de dispositivo 
  \e também define a orientação dos eixos x e y do dispositivo.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e 1 [iMode = MM_TEXT]. \iMode refere-se ao novo modo de mapeamento. / o modo de mapeamento para o contexto de dispositivo do seu aplicativo
    \Com o valor MM_TEXT, cada unidade lógica é mapeada para um pixel de dispositivo. 
    \O modo MM_TEXT permite que os aplicativos funcionem em pixels de dispositivo, cujo tamanho varia de acordo com a resolução da tela/monitor
    \ x (positivo) fica à direita; y (positivo) fica embaixo.
    \Se a função for bem-sucedida, o valor de retorno identifica o modo de mapeamento anterior.
    \Se a função falhar, o valor de retorno é zero.
  Call "user32.dll" "DrawFocusRect" com \https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-drawfocusrect
  \A função DrawFocusRect desenha um retângulo estilizado. 
  \A estilização é utilizada para indicar que o retângulo está sob o foco atual.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e O endereçamento desta caixa.[*lprc] \Um ponteiro para uma estrutura RECT que especifica as coordenadas lógicas do retângulo.
    \https://docs.microsoft.com/pt-br/windows/win32/api/windef/ns-windef-rect
  Normalize o quadro atual.

\Etapas para que se pinte uma caixa de uma cor;
Etapas para que se pinte uma caixa em uma cor:
  Pinte a caixa com a cor [preenchimento] e a cor preta [borda].

Etapas para que se pinte o cursor de texto em uma caixa de texto:
\refere-se ao cursor de texto dos arquivos de texto
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma caixa por [para] o cursor de texto na caixa de texto.
  Se a caixa não estiver tocando a caixa desta caixa de texto, cancele.
  Atribua o canto superior esquerdo desta caixa e o canto inferior direito desta caixa a uma linha reta.
  Pinte a linha reta com a cor azul.

Etapas para que se pinte um círculo aproximadamente uns twips wide;
Etapas para que se pinte um círculo usando uma largura;
Etapas para que se pinte um círculo uns twips em largura;
Etapas para que se pinte um círculo uns twips wide:
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Comece. [a executar o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire para 1/48.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um círculo uns twips wide (backwards);
Etapas para que se pinte um círculo uns twips wide (counterclockwise):
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Comece. [a executar o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire para a esquerda.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um console:
  Se o console for inexistente, cancele.
  Salve o quadro atual.
  Cubra somente fora de a caixa deste console .
  Pinte a caixa deste console com a cor da borda deste console e a cor de preenchimento deste console.
  Atribua a cor branca ao cor do pincel desta caixa de texto deste console.
  Pinte a caixa de texto deste console.
  Restaure o quadro atual.

Etapas para que se pinte um dot uns twips wide sobre a localização atual com uma cor:
  Faça o dot os twips wide.
  Centralize o dot sobre a localização deste contexto.
  Pinte o dot com a cor.

Etapas para que se pinte um dot uns twips wide sobre uma localização com uma cor:
  Faça o dot os twips wide.
  Centralize o dot sobre a localização.
  Pinte o dot com a cor.

Etapas para que se pinte uma elipse:
  Pinte a elipse com a cor preta e a cor branca.

Etapas para que se pinte uma elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor e a cor preta.

Etapas para que se pinte uma elipse com uma cor:
  Pinte a elipse com a cor e a cor.

Etapas para que se pinte uma flecha estilizada uns twips long com uma cor:
  Atribua a cor à cor deste contexto.
  Salve o contexto.
  Pinte os twips.
  Dê meia volta.
  Mova os twips dividido por 8.
  Salve o contexto.
  Vire para a esquerda 1/8.
  Pinte um spiral começando com os twips dividido por 4.
  Restaure o contexto.
  Vire para 1/8.
  Pinte uma segunda spiral backwards começando com os twips dividido por 4.
  Restaure o contexto.

Etapas para que se pinte um figura com uma cor:
  Pinte a figura com a cor e a cor preta.

Etapas para que se pinte um figura com uns sides aproximadamente uns twips wide:
  Atribua 1 e o side contagem a uma fração.
  Atribua os twips times o número pi dividido pelo sides a uma quantidade de caracteres do segmento.
  Se o sides são 4, atribua os twips times 7/8 ao quantidade de caracteres do segmento. \ what é this? ***
  Comece. [a executar o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire a fração.
    Adicione 1 para uma contagem. 
    Se a contagem for os sides, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um figura com uns sides uns twips long;
Etapas para que se pinte um figura com uns sides e uns twips:
  Atribua 1 e o sides a uma fração.
  Comece. [a executar o código abaixo]
    Pinte os twips.
    Vire a fração.
    Adicione 1 para uma contagem. Se a contagem é o sides, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um figura com uns sides uns twips long using uma cor;
Etapas para que se pinte um figura com uns sides e uns twips using uma cor:
  Atribua a cor à cor deste contexto.
  Pinte a figura com o sides e os twips.

Etapas para que se pinte um half círculo aproximadamente uns twips wide;
Etapas para que se pinte um half círculo usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Comece. [a executar o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire para 1/48.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um half círculo usando um size (backwards);
Etapas para que se pinte um half círculo usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Comece. [a executar o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire para a esquerda 1/48.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um hexagon usando um side quantidade de caracteres:
  Pinte o side quantidade de caracteres.
  Vire para 1/6.
  Adicione 1 para uma contagem. Se a contagem for 6, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte uma linha reta:
  Pinte a linha reta com a cor deste contexto.

Etapas para que se pinte uma linha reta around uns twips long; \ "around" é significante aqui
Etapas para que se pinte uma linha reta aproximadamente uns twips long: \ "aproximadamente" é significante aqui
  \ "aproximadamente" é significante aqui
  Atribua os twips dividido por 2 a uns outros twips.
  Escolha aleatoriamente uns terceiro twips entre os twips menos os outros twips e os twips mais os outros twips.
  Pinte a linha reta o terceiro twips long.

Etapas para que se pinte uma linha reta como tall como uma caixa com uma cor:
  Atribua a cor à cor deste contexto.
  Pinte a altura desta caixa.

Etapas para que se pinte uma linha reta como wide como uma caixa com uma cor:
  Atribua a cor à cor deste contexto.
  Pinte a largura desta caixa.

Etapas para que se pinte uma linha reta entre uns twips e uns outros twips long;
Etapas para que se pinte uma linha reta entre uns twips para uns outros twips long;
Etapas para que se pinte uma linha reta uns twips para uns outros twips long:
  Escolha aleatoriamente uns terceiro twips entre os twips e os outros twips.
  Pinte a linha reta o terceiro twips long.

Etapas para que se pinte uma linha reta uns twips long:
  \Aguarde pelo delay. ***
  Atribua a localização deste contexto ao localização inicial desta linha reta.
  Atribua a localização deste contexto ao localização final desta linha reta.
  Obtenha um deslocamento vertical e um deslocamento horizontal usando a orientação deste contexto.
  Adicione o deslocamento horizontal times os twips dividido por 10000 para a coordenada X desta localização final desta linha reta.
  Adicione o deslocamento vertical times os twips dividido por 10000 para a coordenada Y desta localização final desta linha reta.
  Atribua a localização final desta linha reta à localização deste contexto.
  Pinte a linha reta com a cor deste contexto.
  \Se o delay for positive, atualize o tela.

Etapas para que se pinte uma linha reta using uns twips como a quantidade de caracteres;
Etapas para que se pinte uma linha reta using uns twips pelo quantidade de caracteres:
  Pinte os twips.

Etapas para que se pinte uma linha reta com uma cor around uns twips long; \ "around" é significant here
Etapas para que se pinte uma linha reta com uma cor aproximadamente uns twips long:\ "aproximadamente" é significant here
  Atribua os twips dividido por 2 a uns outros twips.
  Escolha aleatoriamente uns terceiro twips entre os twips menos os outros twips e os twips mais os outros twips.
  Pinte a linha reta com a cor o terceiro twips long.

Etapas para que se pinte uma linha reta com uma cor uns twips long:
  Atribua a cor à cor deste contexto.
  Atribua a localização deste contexto ao localização inicial desta linha reta.
  Pinte os twips.
  Atribua a localização deste contexto ao localização final desta linha reta.

Etapas para que se pinte uma linha reta com uma cor uns twips para uns outros twips long:
  Escolha aleatoriamente uns terceiro twips entre os twips e os outros twips.
  Pinte a linha reta com a cor o terceiro twips long.

Etapas para que se pinte um número em uma caixa com uma cor:
  Atribua o número a uma string.
  Pinte a string na caixa com a cor e "centralizado".

Etapas para que se pinte only within uma caixa;
Etapas para que se pinte only inside uma caixa;
Etapas para que se pinte only em uma caixa;
Etapas para que se pinte only within uma caixa desde now on;
Etapas para que se pinte only inside uma caixa desde now on;
Etapas para que se pinte only em uma caixa desde now on;
Etapas para que se only pinte within uma caixa desde now on;
Etapas para que se only pinte inside uma caixa desde now on;
Etapas para que se only pinte em uma caixa desde now on;
Etapas para que se only pinte within uma caixa;
Etapas para que se only pinte inside uma caixa;
Etapas para que se only pinte em uma caixa;
Etapas para que se pinte within uma caixa only;
Etapas para que se pinte inside uma caixa only;
Etapas para que se pinte em uma caixa only;
Etapas para que se atribua masking tape all around uma caixa;
Etapas para que se atribua masking tape around uma caixa:
  \ note that this masks a cor da borda da caixa as well
  Isole a caixa.
  Indent a caixa 1 pixel.
  Cubra externamente a caixa.
  Atribua a original caixa à caixa deste contexto. \ *** original caixa ? ou indented one?

Etapas para que se pinte uma imagem sobre um gpGraphic sob uma coordenada X e uma coordenada Y:
  Se a imagem for inexistente, cancele.
  Se o grayscale detector desta imagem estiver ativo, crie um GpImageAttributes (escala de cinza).
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com 
  \Esta função pode ser usada para desenhar imagens com cores ou faixas de cores transparentes.
  \Observações: a parte da imagem de origem a ser desenhada é redimensionada para caber no retângulo.
    O gpGraphic [*graphics] \Identificador/Ponteiro para o objeto Graphics.
    e O gpBitmap desta imagem [*image] \Identificador/Ponteiro para um objeto Image que especifica a imagem de origem a ser desenhada.
    e A coordenada X [dstx] \especifica a coordenada x do canto superior esquerdo da área de desenho da imagem.
    e A coordenada Y [dsty] \especifica a coordenada y do canto superior esquerdo da área de desenho da imagem.
    e A largura desta caixa intacta desta imagem [dstwidth] \especifica a largura da área de desenho a ser desenhada.
    e A altura desta caixa intacta desta imagem [dstwidth] \especifica a altura da área de desenho
    e 0 [srcx] \Especifica a coordenada x do canto superior esquerdo da parte da imagem de origem a ser desenhada.
    e 0 [srcy] \Especifica a coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.
    e A largura deste gpBitmap desta imagem [srcwidth] \Especifica a largura da parte da imagem de origem a ser desenhada.
    e A altura deste gpBitmap desta imagem [srcheight] \Especifica a altura da parte da imagem de origem a ser desenhada.
    e 2 [srcUnit = UnitPixel] \Elemento da enumeração Unit que especifica a unidade de medida da imagem. O valor padrão é UnitPixel.
    \https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusenums/ne-gdiplusenums-unit
    \A enumeração Unit especifica a unidade de medida para um determinado tipo de dados.
    \UnitPixel especifica que uma unidade tem 1 pixel.
    e O GpImageAttributes [imageAttributes] \Ponteiro para uma estrutura ImageAttributes que especifica os atributos de cor e tamanho da imagem a ser desenhada. 
    \O valor padrão é NULL.
    e nil [callback] \Método de retorno de chamada usado para cancelar o desenho em andamento. 
    \O valor padrão é NULL.
    e 0. [callbackData] \Ponteiro para dados adicionais usados pelo método especificado pelo parâmetro de retorno de chamada. 
    \O valor padrão é NULL.
    \Valor de retorno da função: retorna o valor GpStatus, sendo que o valor 0 significa que a função foi bem-sucedida.
  Se o GpImageAttributes não for inexistente, destrua o GpImageAttributes.

Etapas para que se pinte um polígono:
  Pinte o polígono com a cor preta e a cor branca.

Etapas para que se pinte um polígono com uma cor:
  Pinte o polígono com a cor e a cor.

Etapas para que se pinte um polígono com uma cor (border only):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hPen of o quadro atual usando a cor.
  Obtenha um vértice desde os vértices deste polígono.
  Se o vértice for inexistente, cancele.
  Call "gdi32.dll" "MoveToEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-movetoex
  \A função MoveToEx atualiza a posição atual para o ponto especificado e, opcionalmente, retorna a posição anterior.
    O quadro atual [hdc] \o número identificador do contexto do dispositivo.
    e A coordenada X deste vértice [x] \Especifica a coordenada x da nova posição, em unidades lógicas.
    e A coordenada Y deste vértice [y] \Especifica a coordenada y da nova posição, em unidades lógicas.
    e nil. [lppt] \Ponteiro para uma estrutura POINT que recebe a posição atual anterior. 
    \Se este parâmetro for um ponteiro NULL, a posição anterior não será retornada.
    \https://docs.microsoft.com/pt-br/previous-versions/dd162805(v=vs.85)
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Comece. [a executar o código abaixo]
    Obtenha o vértice desde os vértices deste polígono.
    Se o vértice for inexistente, pare.
    Call "gdi32.dll" "LineTo" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-lineto
    \A função LineTo desenha uma linha da posição atual até, mas não incluindo, o ponto especificado.
    \A linha é desenhada usando a caneta atual e, se a caneta for uma caneta geométrica, a cor do pincel atual.
    \Se LineTo for bem-sucedido, a posição atual será definida como o ponto final especificado.
      O quadro atual [hdc] \o número identificador do contexto do dispositivo.
      e A coordenada X deste vértice [x] \Especifica a coordenada x, em unidades lógicas, do ponto final da linha.
      e A coordenada Y deste vértice.[y] \Especifica a coordenada y, em unidades lógicas, do ponto final da linha.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Recomece. [percorra novamente o código acima]
  Destrua o hPen of o quadro atual.
  Se a localização deste first vértice destes vértices deste polígono for a localização deste last vértice destes vértices deste polígono, cancele.
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setpixelv
  \A função SetPixelV define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada. 
  \O ponto deve estar na região de recorte e na parte visível da superfície do dispositivo.
  \Observação: Nem todos os dispositivos suportam a função SetPixelV. 
  \Para obter mais informações, consulte a descrição do recurso RC_BITBLT na função GetDeviceCaps.
  \SetPixelV é mais rápido do que SetPixel porque não precisa retornar o valor da cor do ponto realmente pintado.
    O quadro atual [hdc] \O identificador do contexto do dispositivo.
    e A coordenada X deste last vértice destes vértices deste polígono [x] \A coordenada x, em unidades lógicas, do ponto a ser definido.
    e A coordenada Y deste last vértice destes vértices deste polígono [y] \A coordenada y, em unidades lógicas, do ponto a ser definido.
    e O código da cor.[color] \A cor a ser usada para pintar o ponto. Para criar um valor de cor COLORREF, use a macro RGB.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.

Etapas para que se pinte um polígono com uma cor (apenas a cor de preenchimento):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hPen of o quadro atual usando a cor preta.
  Crie o hBrush of o quadro atual usando a cor.
  Call "gdi32.dll" "SetPolyFillMode" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setpolyfillmode
  \A função SetPolyFillMode define o modo de preenchimento do polígono para funções que preenchem polígonos.
    O quadro atual [hdc] \O identificador do contexto do dispositivo.
    e 2 [mode = WINDING].\O novo modo de preenchimento.
    \WINDING seleciona o modo de enrolamento (preenche qualquer região com um valor de enrolamento diferente de zero).
    \Em geral, os modos diferem apenas nos casos em que um polígono complexo e sobreposto deve ser preenchido
    \(por exemplo, um polígono de cinco lados que forma uma estrela de cinco pontas com um pentágono no centro). 
    \Nesses casos, o modo ALTERNATE preenche todas as outras regiões fechadas dentro do polígono (ou seja, as pontas da estrela), 
    \enquanto o modo WINDING preenche todas as regiões (ou seja, as pontas e o pentágono).
    \Quando o modo de preenchimento é ALTERNATIVO, o GDI preenche a área entre os lados ímpares e pares do polígono em cada linha de varredura. 
    \Ou seja, o GDI preenche a área entre o primeiro e o segundo lado, entre o terceiro e o quarto lado e assim por diante.
    \Quando o modo de preenchimento é WINDING, GDI preenche qualquer região que tenha um valor de enrolamento diferente de zero. 
    \Este valor é definido como o número de vezes que uma caneta usada para desenhar o polígono contornaria a região. 
    \A direção de cada aresta do polígono é importante.
    \O valor de retorno especifica o modo de preenchimento anterior. Se ocorrer um erro, o valor de retorno é zero.
  Crie uma série de vértices usando os vértices deste polígono.
  Call "gdi32.dll" "Polygon" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-polygon
  \A função Polygon desenha um polígono que consiste em dois ou mais vértices conectados por linhas retas. 
  \O polígono é delineado usando a caneta atual e preenchido usando a cor do pincel atual e o modo de preenchimento de polígono.
    O quadro atual [hdc] \O identificador do contexto do dispositivo.
    e O ponteiro da localização desta série de vértices [*apt] \Um ponteiro para uma matriz de estruturas POINT que especificam os vértices do polígono, em coordenadas lógicas.
    \https://docs.microsoft.com/pt-br/previous-versions/dd162805(v=vs.85)
    e A quantidade de vértices desta série de vértices. [cpt] \O número de vértices na matriz. Este valor deve ser maior ou igual a 2.
  Destrua a série de vértices.
  Destrua o hBrush of o quadro atual.
  Destrua o hPen of o quadro atual.

Etapas para que se pinte um quadrante circular aproximadamente uns twips wide;
Etapas para que se pinte um quadrante circular usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Comece. [a executar o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire para 1/48.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um quadrante circular entre uns twips e uns outros twips wide:
  Escolha aleatoriamente uns terceiro twips entre os twips e os outros twips.
  Pinte um quadrante circular usando o terceiro twips.

Etapas para que se pinte um quadrante circular usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Comece. [a executar o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire para a esquerda 1/48.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um retângulo uns twips por uns outros twips;
Etapas para que se pinte um retângulo uns twips wide por uns outros twips high:
  Pinte os outros twips.
  Vire para a direita.
  Pinte os twips.
  Vire para a direita.
  Pinte os outros twips.
  Vire para a direita.
  Pinte os twips.
  Vire para a direita.

Etapas para que se pinte uma caixa arredondada:
  Pinte a caixa arredondada com a cor preta e a cor branca.

Etapas para que se pinte uma caixa arredondada com uma cor:
  Pinte a caixa arredondada com a cor e a cor.

Etapas para que se pinte uma linha de texto of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Obtenha uma caixa usando a linha de texto e a caixa de texto.
  Pinte o working string desta linha de texto na caixa com a cor do pincel desta caixa de texto e a fonte desta caixa de texto e o alinhamento desta caixa de texto.

Etapas para que se pinte uma linha de texto of uma caixa de texto (editing):
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Pinte a caixa de seleção pela linha de texto of a caixa de texto.
  Obtenha uma caixa usando a linha de texto e a caixa de texto.
  Pinte o working string desta linha de texto na caixa com a cor do pincel desta caixa de texto e a fonte desta caixa de texto e o alinhamento desta caixa de texto.

Etapas para que se pinte a caixa de seleção por uma linha de texto of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Se a linha de texto of a caixa de texto não estiver selecionado, cancele.
  Obtenha uma caixa de seleção usando a linha de texto e a caixa de texto.
  Pinte a caixa de seleção com o cor hilite e o cor hilite.

Etapas para que se pinte um spiral backward usando uns twips;
Etapas para que se pinte um spiral backward começando com uns twips;
Etapas para que se pinte um spiral usando um size (backwards):
  Isole o size.
  Comece. [a executar o código abaixo]
    Pinte um half círculo usando o size (backwards).
    Divida o size por 2.
    Adicione 1 para uma contagem.
    Se a contagem for 5, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte um spiral começando com uns twips;
Etapas para que se pinte um spiral usando um size:
  Isole o size.
  Comece. [a executar o código abaixo]
    Pinte um half círculo usando o size.
    Divida o size por 2.
    Adicione 1 para uma contagem. 
    Se a contagem for 5, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte uma localização:
  Pinte a localização com a cor preta.

Etapas para que se pinte uma localização com uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setpixelv
  \A função SetPixelV define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada. 
  \O ponto deve estar na região de recorte e na parte visível da superfície do dispositivo.
  \Observação: Nem todos os dispositivos suportam a função SetPixelV. 
  \Para obter mais informações, consulte a descrição do recurso RC_BITBLT na função GetDeviceCaps.
  \SetPixelV é mais rápido do que SetPixel porque não precisa retornar o valor da cor do ponto realmente pintado.
    O quadro atual [hdc] \O identificador do contexto do dispositivo.
    e A coordenada X desta localização [x] \A coordenada x, em unidades lógicas, do ponto a ser definido.
    e A coordenada Y desta localização [y] \A coordenada y, em unidades lógicas, do ponto a ser definido.
    e O código da cor.\A cor a ser usada para pintar o ponto. Para criar um valor de cor COLORREF, use a macro RGB.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.

Etapas para que se pinte uma estrela usando uma point contagem e um size:
  Atribua 1 e a point contagem a uma fração.
  Comece. [a executar o código abaixo]
    Vire para 1/48.
    Pinte o size.
    Dê meia volta.
    Vire para a esquerda 1/24.
    Pinte o size.
    Dê meia volta.
    Vire para 1/48.
    Vire para a fração.
    Adicione 1 para uma contagem. 
    Se a contagem for o point contagem, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se pinte uma string sob a esquerda of uma caixa;
Etapas para que se pinte uma string sob o lado esquerdo of uma caixa:
  Pinte a string sob o lado esquerdo of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string sob a esquerda of uma caixa com uma cor;
Etapas para que se pinte uma string sob o lado esquerdo of uma caixa com uma cor:
  Pinte a string sob o lado esquerdo of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string sob a esquerda of uma caixa com uma cor e uma fonte;
Etapas para que se pinte uma string sob o lado esquerdo of uma caixa com uma cor e uma fonte:
  Pinte a string na caixa com a cor e a fonte e "à esquerda".

Etapas para que se pinte uma string sob a esquerda of uma caixa com uma fonte;
Etapas para que se pinte uma string sob o lado esquerdo of uma caixa com uma fonte:
  Pinte a string sob o lado esquerdo of a caixa com a cor preta e a fonte.

Etapas para que se pinte uma string sob a direita of uma caixa;
Etapas para que se pinte uma string sob o lado direito of uma caixa:
  Pinte a string sob o lado direito of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string sob a direita of uma caixa com uma cor;
Etapas para que se pinte uma string sob o lado direito of uma caixa com uma cor:
  Pinte a string sob o lado direito of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string sob a direita of uma caixa com uma cor e uma fonte;
Etapas para que se pinte uma string sob o lado direito of uma caixa com uma cor e uma fonte:
  Pinte a string na caixa com a cor e a fonte e "à direita".

Etapas para que se pinte uma string sob a direita of uma caixa com uma fonte;
Etapas para que se pinte uma string sob o lado direito of uma caixa com uma fonte:
  Pinte a string sob o lado direito of a caixa com a cor preta e a fonte.

Etapas para que se pinte uma string sob uma localização com uma cor:
  Pinte a string sob a localização com a cor e a fonte padrão.

Etapas para que se pinte uma string em uma caixa:
  Pinte a string na caixa com a cor preta e a fonte padrão e "à esquerda".

Etapas para que se pinte uma string em uma caixa over um número com uma cor e uma fonte e um alinhamento:
  Isole a caixa.
  Se o alinhamento for "à esquerda", adicione o número para a coordenada X do canto superior esquerdo desta caixa.  
  Se o alinhamento for "à direita", subtraia o número desde a coordenada X do canto inferior direito desta caixa.
  Pinte a string na caixa com a cor e a fonte e o alinhamento.

Etapas para que se pinte uma string em uma caixa com um alinhamento:
  Pinte a string na caixa com a cor preta e a fonte padrão e o alinhamento.

Etapas para que se pinte uma string em uma caixa com uma cor:
  Pinte a string na caixa com a cor e a fonte padrão e "à esquerda".

Etapas para que se pinte uma string em uma caixa com uma cor e um alinhamento:
  Pinte a string na caixa com a cor e a fonte padrão e o alinhamento.

Etapas para que se pinte uma string em uma caixa com uma cor e uma fonte e um alinhamento:
  Obtenha um offset par de números usando a string e a caixa e a fonte e o alinhamento.
  Pinte a string sob o canto superior esquerdo desta caixa mais o offset par de números com a cor e a fonte.

Etapas para que se pinte uma string em uma caixa com uma fonte e um alinhamento:
  Pinte a string na caixa com a cor preta e a fonte e o alinhamento.

Etapas para que se pinte uma string no centro of uma caixa:
  Pinte a string no centro of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string no centro of uma caixa com uma cor:
  Pinte a string no centro of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string no centro of uma caixa com uma cor e uma fonte:
  Pinte a string na caixa com a cor e a fonte e "centralizado".

Etapas para que se pinte uma string no centro of uma caixa com uma fonte:
  Pinte a string no centro of a caixa com a cor preta e a fonte.

Etapas para que se pinte um terminal:
  Se o terminal for inexistente, cancele.
  Salve o quadro atual.
  Cubra somente fora de a caixa deste terminal.
  Pinte e preencha a caixa deste terminal com a cor preta.
  Escreva os quoras deste terminal na caixa deste terminal.
  Restaure o quadro atual.

Etapas para que se pinte uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Salve o quadro atual.
  Cubra externamente a caixa desta caixa de texto.
  Pinte algum tipo de visível linhas des textos of a caixa de texto.
  Restaure o quadro atual.

Etapas para que se pinte uma caixa de texto (editing):
  Se a caixa de texto for inexistente, cancele.
  Salve o quadro atual.
  Cubra externamente a caixa desta caixa de texto.
  Pinte algum tipo de visível linhas des textos of a caixa de texto (editing).
  Pinte o cursor de texto na caixa de texto.
  Restaure o quadro atual.

Etapas para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos:
  Se o endereço completo é endereço da pasta-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (arquivo).

Etapas para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (pasta)[endereço]:
  Se o endereço completo estiver no segunda endereço completo, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de ". - erro de recursão inválida." ao erro do fluxo de entrada/saída; saia.
  Se o endereço completo não estiver no sistema de arquivos, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; saia.
  Se a segunda endereço completo não estiver no sistema de arquivos, crie a segunda endereço completo no sistema de arquivos.
  Comece. [a executar o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for encontrado, cancele.
    Atribua o endereço completo a um terceiro endereço completo.
    Posponha o designador deste item para o terceiro endereço completo.
    Atribua a segunda endereço completo a um quarto endereço completo.
    Posponha o designador deste item para o quarto endereço completo.
    Duplicate o terceiro endereço completo para o quarto endereço completo no sistema de arquivos.
  Recomece. [percorra novamente o código acima]

Etapas para que se duplicate um endereço completo para um segundo endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Isole o segundo endereço completo.
  Anexe o caractere NULL o segundo endereço completo.
  Call "kernel32.dll" "CopyFileA" com \https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-copyfilea
  \A função CopyFileA copia um arquivo existente para um novo arquivo.
    O caractere inicial deste endereço completo [lpExistingFileName] \ O nome de um arquivo existente.
    e O caractere inicial deste segundo endereço completo [lpNewFileName] \ O nome do novo arquivo.
    e 0 [bFailIfExists] \Se este parâmetro for TRUE e o novo arquivo especificado por lpNewFileName já existir, a função falhará. 
    \Se este parâmetro for FALSE e o novo arquivo já existir, a função sobrescreve o arquivo existente e é bem-sucedida.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, defina o endereço completo para read-write mode; saia. \Se a função falhar, o valor de retorno é zero.
  Atribua "Ocorreu um erro na hora de duplicar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Uma elipse é um conjunto com uma caixa.

Um email é um conjunto com
  Um smtp server,
  Um sender,
  Um recipient,
  Um subject,
  Uma message.

Etapas para que se encrypt um trecho usando um passphrase string:
  \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie um crypt session usando o passphrase.
  Se o crypt session for inexistente, cancele.
  Atribua o trecho a um temp trecho.
  Atribua a quantidade de caracteres deste temp trecho a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptEncrypt" com \https://docs.microsoft.com/pt-br/windows/win32/api/wincrypt/nf-wincrypt-cryptencrypt
  \A função CryptEncrypt criptografa os dados. 
  \O algoritmo usado para criptografar os dados é designado pela chave mantida pelo módulo CSP e é referenciado pelo parâmetro hKey
  \Importante Esta API está obsoleta. 
  \O software novo e o existente devem começar a usar APIs de criptografia de última geração. 
  \A Microsoft pode remover esta API em versões futuras.
    A hCryptKey desta crypt session [hKey] \o número identificador da chave de criptografia. 
    \Um aplicativo obtém esse identificador usando a função CryptGenKey ou CryptImportKey.
    \A chave especifica o algoritmo de criptografia usado.
    e 0 [hHash] \Um identificador para um objeto hash. 
    \Se os dados tiverem que ser criptografados e criptografados simultaneamente, um identificador para um objeto hash pode ser passado no parâmetro hHash. 
    \O valor hash é atualizado com o texto simples passado. Esta opção é útil ao gerar texto assinado e criptografado.
    \Antes de chamar CryptEncrypt, o aplicativo deve obter um identificador para o objeto hash chamando a função CryptCreateHash. 
    \Depois que a criptografia for concluída, o valor do hash pode ser obtido usando a função CryptGetHashParam 
    \ou o hash pode ser assinado usando a função CryptSignHash.
    \Se nenhum hash deve ser feito, este parâmetro deve ser NULL.
    e 1 [Final] \Um valor booleano que especifica se esta é a última seção de uma série que está sendo criptografada. 
    \Final é definido como TRUE para o último ou único bloco e como FALSE se houver mais blocos a serem criptografados.
    e 0 [dwFlags] \reservado para uso futuro
    e O caractere inicial deste temp trecho [*pbData] \Um ponteiro para um buffer que contém o texto simples a ser criptografado. 
    \O texto simples neste buffer é substituído pelo texto cifrado criado por esta função.
    \O parâmetro pdwDataLen aponta para uma variável que contém o comprimento, em bytes, do texto simples. 
    \O parâmetro dwBufLen contém o tamanho total, em bytes, desse buffer.
    \Se este parâmetro contiver NULL, esta função calculará o tamanho necessário para o texto cifrado e o colocará no valor apontado pelo parâmetro pdwDataLen.
    e O endereçamento deste quantidade de caracteres [*pdwDataLen] \Um ponteiro para um valor DWORD que, na entrada, contém o comprimento, em bytes, do texto sem formatação no buffer pbData. 
    \Na saída, este DWORD contém o comprimento, em bytes, do texto cifrado gravado no buffer pbData.
    \Se o buffer alocado para pbData não for grande o suficiente para conter os dados criptografados, 
    \GetLastError retorna ERROR_MORE_DATA e armazena o tamanho do buffer necessário, em bytes, no valor DWORD apontado por pdwDataLen.
    \Se pbData for NULL, nenhum erro será retornado e a função armazenará o tamanho dos dados criptografados, em bytes, no valor DWORD apontado por pdwDataLen. 
    \Isso permite que um aplicativo determine o tamanho correto do buffer.
    \Quando uma cifra de bloco é usada, esse comprimento de dados deve ser um múltiplo do tamanho do bloco, 
    \a menos que esta seja a seção final dos dados a serem criptografados e o parâmetro Final seja TRUE.
    e A quantidade de caracteres [dwBufLen] \Especifica o tamanho total, em bytes, do buffer pbData de entrada.
    \Observe que, dependendo do algoritmo usado, o texto criptografado pode ser maior do que o texto simples original. 
    \Nesse caso, o buffer pbData precisa ser grande o suficiente para conter o texto criptografado e qualquer preenchimento.
    \Como regra, se uma cifra de fluxo for usada, o texto cifrado terá o mesmo tamanho do texto simples. 
    \Se uma cifra de bloco for usada, o texto cifrado terá um comprimento de bloco maior do que o texto simples.
    devolvendo um número resultante. \Se a função for bem-sucedida, ela retornará um valor diferente de zero (VERDADEIRO).
    \Se a função falhar, ele retornará zero (FALSO).
  Se o número resultante for 0, atribua "Ocorreu um erro ao criptografar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; saia.
  \Se uma grande quantidade de dados deve ser criptografada, isso pode ser feito em seções chamando CryptEncrypt repetidamente. 
  \O parâmetro Final deve ser definido como TRUE na última chamada para CryptEncrypt, 
  \para que o mecanismo de criptografia possa terminar corretamente o processo de criptografia.
  Destrua o crypt session.
  Converta o temp trecho para uma cifra hexadecimal.
  Atribua a cifra hexadecimal ao trecho.

Etapas para que se enlarge uma caixa por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta caixa.
  Adicione os twips para o canto inferior direito desta caixa.

Etapas para que se enlarge uma elipse por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta elipse.
  Adicione os twips para o canto inferior direito desta elipse.

Etapas para que se enfileire um evento:
  Posponha o evento para a fila de eventos.

Etapas para que se erase o insides of uma caixa;
Etapas para que se erase inside uma caixa;
Etapas para que se limpe inside uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas para que se estime um deslocamento vertical e um deslocamento horizontal usando uma orientação:
  Atribua a orientação a uma low orientação.
  Arredonde a low orientação para baixo para o múltiplo imediato of 20.
  Obtenha um low deslocamento vertical e um low deslocamento horizontal usando a low orientação.
  Atribua a orientação a um high orientação.
  Arredonde o high orientação para cima para o múltiplo imediato of 20.
  Obtenha um high deslocamento vertical e um high deslocamento horizontal usando o high orientação.
  Atribua o low deslocamento vertical mais o high deslocamento vertical dividido por 2 ao deslocamento vertical.
  Atribua o low deslocamento horizontal mais o high deslocamento horizontal dividido por 2 ao deslocamento horizontal.

A fila de eventos é uma fila de eventos.

Uma fila de eventos é uns eventos.

Etapas para que se extend algum tipo de seleção em uma caixa de texto usando uma localização:
  Se a caixa de texto for inexistente, cancele.
  Obtenha o cursor de texto desta caixa de texto usando a localização e a caixa de texto.
  Limpe a última operação desta caixa de texto.

Etapas para que se extend uma caixa para include uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta segunda caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua a coordenada X do canto superior esquerdo desta segunda caixa à coordenada X do canto superior esquerdo desta caixa.
  Se a coordenada Y do canto superior esquerdo desta segunda caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua a coordenada Y do canto superior esquerdo desta segunda caixa à coordenada Y do canto superior esquerdo desta caixa.
  Se a coordenada X do canto inferior direito desta segunda caixa for maior do que a coordenada X do canto inferior direito desta caixa, atribua a coordenada X do canto inferior direito desta segunda caixa à coordenada X do canto inferior direito desta caixa.
  Se a coordenada Y do canto inferior direito desta segunda caixa for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta caixa.

Some extra points são uns points.

Etapas para que se extraia um designador desde um endereço completo:
  Limpe o designador.
  Extraia um unidade de disco desde o endereço completo.
  Lance um endereço completo subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o caractere inicial deste endereço completo subtexto.
  Se o endereço completo subtexto estiver em branco, atribua o unidade de disco ao designador; saia.
  Lance um subtexto sobre o last byte of o endereço completo subtexto.
  Se o conteúdo deste caractere inicial deste subtexto for a barra invertida, subtraia 1 desde o caractere inicial deste subtexto.
  Comece. [a executar o código abaixo]
    Se o caractere inicial deste subtexto for menor do que o caractere inicial deste endereço completo subtexto, pare.
    Se o conteúdo deste caractere inicial deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  Adicione 1 para o caractere inicial deste subtexto.
  Atribua o subtexto ao designador.

Etapas para que se extraia um endereço da pasta desde um endereço completo:
  Limpe o endereço da pasta.
  Extraia um unidade de disco desde o endereço completo.
  Se o unidade de disco estiver em branco, cancele.
  Lance um subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o caractere inicial deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere final deste subtexto for a barra invertida, subtraia 1 desde o caractere final deste subtexto.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, pare.
    Se o conteúdo deste caractere final deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]
  Atribua a unidade de disco junto com o subtexto ao endereço da pasta.

Etapas para que se extraia um nome do diretório desde um endereço completo:
  Limpe o nome do diretório.
  Se o endereço completo não for endereço da pasta-format, cancele.
  Extraia o nome do diretório como um designador desde o endereço completo.

Etapas para que se extraia um nome da pasta desde um endereço completo:
  Extraia o nome da pasta como um nome do diretório desde o endereço completo.
  Se o nome da pasta estiver em branco, cancele.
  Remove o last byte desde o nome da pasta.

Etapas para que se extraia um unidade de disco desde um endereço completo:
  Limpe o unidade de disco.
  Se a quantidade de caracteres deste endereço completo for menor do que 3, cancele.
  Lance um subtexto sobre o first byte of o endereço completo.
  Adicione 2 para o caractere final deste subtexto.
  Se o subtexto termina com ":\", atribua o subtexto ao unidade de disco; saia.
  Se o subtexto não começa com "\\", cancele.
  Lance o subtexto sobre o first byte of o endereço completo.
  Comece. [a executar o código abaixo]
    Se o caractere final deste subtexto for maior do que o caractere final deste endereço completo, cancele.
    Se o conteúdo deste caractere final deste subtexto for a barra invertida, adicione 1 para uma contagem.
    Se a contagem for 4, pare. \ "\\computer\share\"
    Adicione 1 para o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]
  Atribua o subtexto ao unidade de disco.

Etapas para que se extraia um extensão desde um endereço completo:
  Limpe o extensão.
  Se o endereço completo estiver em branco, cancele.
  Lance um subtexto sobre o last byte of o endereço completo.
  Comece. [a executar o código abaixo]
    Se o caractere inicial deste subtexto for menor do que o caractere inicial deste endereço completo, cancele.
    Se o conteúdo deste caractere inicial deste subtexto for o sinal de dois pontos, cancele.
    Se o conteúdo deste caractere inicial deste subtexto for a barra invertida, cancele.
    Se o conteúdo deste caractere inicial deste subtexto for o ponto final, pare.
    Subtraia 1 desde o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  Atribua o subtexto ao extensão.

Etapas para que se extraia um nome do arquivo desde um endereço completo:
  Limpe o nome do arquivo.
  Se o endereço completo não for file-format, cancele.
  Extraia o nome do arquivo como um designador desde o endereço completo.

Etapas para que se extraia um nome do arquivo s/ extensão desde um endereço completo:
  Extraia o nome do arquivo s/ extensão como um nome do arquivo desde o endereço completo.
  Extraia um extensão desde o endereço completo.
  Remove trailing bytes desde o nome do arquivo s/ extensão usando a quantidade de caracteres desta extensão.

Etapas para que se extraia uma imagem usando uma caixa:
  Atribua a largura desta caixa dividido pelo quantidade de twips/pixel a uma largura.
  Atribua a altura desta caixa dividido pelo quantidade de twips/pixel a uma altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
  \Cria um objeto Bitmap com base em uma matriz de bytes junto com informações de tamanho e formato.
    A largura [width] \Valor inteiro longo que especifica a largura, em pixels, do bitmap.
    e A altura [height] \ especifica a altura, em pixels, do bitmap.
    e 0 [stride] \especifica o deslocamento de byte entre o início de uma linha de varredura e a próxima. 
    \Isso é geralmente (mas não necessariamente) o número de bytes no formato de pixel (por exemplo, 2 para 16 bits por pixel) multiplicado pela largura do bitmap. 
    \O valor passado para este parâmetro deve ser um múltiplo de quatro.
    e 137224 [format = PixelFormat24bppRGB] \Especifica o formato de pixel do bitmap. 
    \PixelFormat24bppRGB Especifica que o formato é de 24 bits por pixel; 8 bits cada são usados para os componentes vermelho, verde e azul.
    e 0 [scan0] \O parâmetro scan0 é tratado como uma matriz de bytes. Ponteiro para uma matriz de bytes que contém os dados de pixel. 
    \O chamador é responsável por alocar e liberar o bloco de memória apontado por este parâmetro.
    e O endereçamento desse gpBitmap. [*bitmap] \Ponteiro para uma variável DWORD que recives um ponteiro para um objeto Bitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
  \Esta função é usada para criar um objeto Graphics associado a um objeto de imagem.
  \A função falhará se a imagem for baseada em um metarquivo que foi aberto para leitura
  \(com as funções GdipLoadImageFromFile, GdipLoadImageFromFileICM, GdipCreateMetafileFromFile, GdipCreateMetafileFromWmfFile). 
  \Para abrir um metarquivo para escrita, use funções em metarquivos que usam um identificador de contexto de dispositivo (hdc).
  \A função também falhará se a imagem usar um dos seguintes formatos de pixel:
    \#PixelFormatUndefined
    \# PixelFormatDontCare
    \# PixelFormat1bppIndexed
    \# PixelFormat4bppIndexed
    \# PixelFormat8bppIndexed
    \# PixelFormat16bppGrayScale
    \# PixelFormat16bppARGB1555
    O gpBitmap [*image] \Ponteiro para um objeto de imagem que será associado ao novo objeto *graphics.
    e O endereçamento desse gpGraphic. [**graphics] \Ponteiro para uma variável que recebe um ponteiro para o novo objeto Graphics.
    \*graphics receberá um ponteiro para um objeto Graphics associado à imagem.
    \Se a função for bem-sucedida, ela retornará #Ok, que é uma constante da enumeração de status.
    \Se a função falhar, ela retornará um dos outros valores da enumeração de status.
  Call "gdiplus.dll" "GdipGetDC" com 
  \Esta função é usada para encontrar o identificador do contexto do dispositivo associado ao gráfico.
    O gpGraphic [graphics] \Identificador para um objeto Graphics criado pelas funções GdipCreateFromHDC, 
    \GdipCreateFromHDC2, GdipCreateFromHWND ou GdipGetImageGraphicsContext.
    e O endereçamento desse bitmap canvas.[hdc] \Identificador do contexto de dispositivo associado a este objeto Graphics
    \Cada chamada para a função GdipGetDC deve ser emparelhada com uma chamada para a função GdipReleaseDC. 
    \Não chame nenhuma função Graphics entre as chamadas para GdipGetDC e GdipReleaseDC. 
    \Se você tentar chamar uma função Graphics entre GdipGetDC e GdipReleaseDC, o método falhará e retornará ObjectBusy.
    \Quaisquer alterações de estado feitas no contexto do dispositivo entre GdipGetDC e GdipReleaseDC serão ignoradas pelo GDI + 
    \e não serão refletidas na renderização feita pelo GDI +.
    \Se a função for bem-sucedida, ela retornará 0, que é uma constante da enumeração de status.
    \Se a função falhar, ela retornará um dos outros valores da enumeração de status.
  Normalize o bitmap canvas.
  Call "gdi32.dll" "BitBlt" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-bitblt
  \A função BitBlt executa uma transferência de bloco de bits dos dados de cor 
  \correspondentes a um retângulo de pixels do contexto de dispositivo de origem especificado 
  \para um contexto de dispositivo de destino.
  \BitBlt só faz recorte no controlador de domínio de destino.
  \Se uma rotação ou transformação de cisalhamento estiver em vigor no contexto do dispositivo de origem, BitBlt retornará um erro. 
  \Se outras transformações existirem no contexto do dispositivo de origem
   \(e uma transformação correspondente não estiver em vigor no contexto do dispositivo de destino), 
   \o retângulo no contexto do dispositivo de destino será esticado, compactado ou girado, conforme necessário.
   \Se os formatos de cor dos contextos de dispositivo de origem e destino não corresponderem, a função 
   \BitBlt converte o formato de cor de origem para corresponder ao formato de destino.
   \Quando um metarquivo avançado está sendo gravado, 
   \ocorre um erro se o contexto do dispositivo de origem identifica um contexto de dispositivo de metarquivo avançado.
    O bitmap canvas [hdc] \Um identificador para o contexto do dispositivo de destino.
    e 0 [x] \A coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.
    e 0 [y] \A coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.
    e A largura desta caixa [cx] \A largura, em unidades lógicas, dos retângulos de origem e destino.
    e A altura desta caixa [cy] \A altura, em unidades lógicas, dos retângulos de origem e destino.
   e o quadro atual  [hdcSrc] \Um identificador para o contexto do dispositivo de origem.
   e a coordenada X do canto superior esquerdo desta caixa [x1] \A coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.
   e a coordenada Y do canto superior esquerdo desta caixa [y1] \A coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.
   e 13369376 [rop = SRCCOPY]. \Um código de operação de varredura. 
   \Esses códigos definem como os dados de cor do retângulo de origem devem ser combinados com os dados de cor do retângulo de destino para obter a cor final.
   \SRCCOPY = Copia o retângulo de origem diretamente para o retângulo de destino.
   \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
   \Se a função falhar, o valor de retorno é zero.
  Call "gdiplus.dll" "GdipReleaseDC" com 
    O gpGraphic [graphics] \Identificador de um objeto Graphics 
    \criado a partir das funções GdipCreateFromHDC, GdipCreateFromHDC2, GdipCreateFromHWND ou GdipGetImageGraphicsContext.
    e O bitmap canvas. [hdc] \Identificador para o contexto de dispositivo
   \ que foi criado por uma chamada anterior para o método GdipGetHDC usando o identificador Graphics acima.
   \Valor de retorno: não retorna um valor.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
  \ Exclui o objeto Graphics especificado.
    O gpGraphic. [*graphics] \ponteito do número identificador do objeto Graphics.
   \Valor de retorno da funlção: Retorna o valor GpStatus, sendo que o valor 0 significa que a função foi bem sucedida.
  Crie a imagem usando o gpBitmap.
  Atribua a caixa à caixa desta imagem.
  Atribua a caixa à caixa intacta desta imagem.

Etapas para que se extraia uma string desde uma caixa de texto:
  Se a caixa de texto for inexistente, limpe a string; saia.
  Converta as linhas des textos desta caixa de texto para a string.
  Remove algum tipo de trailing quebra de linha desde a string.
  Remove algum tipo de trailing retorno de carro desde a string.

Etapas para que se extraia uma string desde uma caixa de texto (sem adicionar quebras de linha):
  Se a caixa de texto for inexistente, limpe a string; saia.
  Converta as linhas des textos desta caixa de texto para a string (sem adicionar quebras de linha).
  Remove algum tipo de trailing retorno de carro desde a string.

Etapas para que se extraia uma string desde uma caixa de texto (trecho selecionado):
  Limpe a string.
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Lance um subtexto sobre qualquer trecho selecionado na linha de texto of a caixa de texto.
    Se o subtexto estiver em branco, recomece.
    Posponha o subtexto para a string.
    Se o conteúdo deste caractere final deste subtexto for o retorno de carro, posponha a quebra de linha para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se escolha uma orientação aleatória:
  Escolha aleatoriamente uma orientação.

Etapas para que se face east:
  Atribua 960 à orientação deste contexto.

Etapas para que se vira para cima:
  Atribua 0 à orientação deste contexto.

Etapas para que se face south:
  Atribua 1920 à orientação deste contexto.

Etapas para que se face west:
  Atribua 2880 à orientação deste contexto.

Etapas para que se preencha uma caixa com uma cor:
  Pinte a caixa com a cor preta e a cor.

Etapas para que se preencha uma elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor preta e a cor.

Etapas para que se preencha uma string com um byte usando uma contagem:
  Reassign o caractere inicial desta string usando a contagem.
  Preencha bytes com o byte começando sob o caractere inicial desta string pela contagem.
  Atribua o caractere inicial desta string mais a contagem menos 1 ao caractere final desta string.

Etapas para que se finalize after run:
  Se a contagem do heap for 0, cancele.
  Atribua a contagem do heap a uma contagem.
  Atribua "Você esqueceu de destruir " junto com a contagem seguido de " elemento(s) no heap." a uma string.
  Produza o relatório de informações usando a string.

Etapas para que se finalize os canvases:
  Finalize o memory canvas.
  Finalize o tela canvas.

Etapas para que se finalize o cgi:
  Call "kernel32.dll" "FreeConsole". \https://docs.microsoft.com/pt-br/windows/console/freeconsole
  \Desanexa o processo de chamada de seu console.
  \Essa função não tem parâmetros.
  \Se a função for bem-sucedida, o valor retornado será diferente de zero.
  \Se a função falhar, o valor retornado será zero.
  \Um processo pode ser anexado a no máximo um console. 
  \Se o processo de chamada ainda não estiver anexado a um console, o código de erro retornado será ERROR_INVALID_PARAMETER (87).
  \Um processo pode usar a função FreeConsole para desconectar-se de seu console. 
  \Se outros processos compartilharem o console, o console não será destruído, mas o processo chamado FreeConsole não poderá se referir a ele. 
  \Um console é fechado quando o último processo anexado a ele termina ou chama FreeConsole. 
  \Depois que um processo chama FreeConsole, ele pode chamar a função AllocConsole para criar um novo console ou AttachConsole para anexar a outro console.

Etapas para que se finalize as cores:

Etapas para que se finalize COM:
  Call "ole32.dll" "CoUninitialize". \https://docs.microsoft.com/pt-br/windows/win32/api/combaseapi/nf-combaseapi-couninitialize
  \A função CoUninitialize fecha a biblioteca COM no thread atual, 
  \descarrega todas as DLLs carregadas pelo thread, 
  \libera quaisquer outros recursos que o thread mantém 
  \e força o fechamento de todas as conexões RPC no thread.
  \Um thread deve chamar CoUninitialize uma vez para cada chamada bem-sucedida feita para a função CoInitialize ou CoInitializeEx, incluindo qualquer chamada que retorna S_FALSE. 
  \Apenas a chamada CoUninitialize correspondente à chamada CoInitialize ou CoInitializeEx que inicializou a biblioteca pode fechá-la.
  \CoUninitialize deve ser chamado no encerramento do aplicativo, como a última chamada feita para a biblioteca COM depois que o aplicativo oculta suas janelas principais e cai em seu loop de mensagem principal. 
  \Se houver conversas abertas restantes, CoUninitialize inicia um loop de mensagem modal e despacha todas as mensagens pendentes dos contêineres ou servidor para este aplicativo COM. 
  \Ao despachar as mensagens, CoUninitialize garante que o aplicativo não feche antes de receber todas as mensagens pendentes. 
  \Mensagens não COM são descartadas.

Etapas para que se finalize um contexto:
  Destrua as escolhas.
  Destrua as figuras.
  Destrua o contexto stack.
  Destrua o contexto.

Etapas para que se finalize os cursors:  
  Call "user32.dll" "DestroyCursor" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-destroycursor
  \A função DestroyCursor destrói um cursor e libera qualquer memória ocupada por ele. 
    O i-beam cursor. [hCursor] \O identificador do cursor a ser destruída. 
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "user32.dll" "DestroyCursor" com \A função DestroyCursor destrói um cursor não compartilhado. 
  \Não use esta função para destruir um cursor compartilhado. 
  \Um cursor compartilhado é válido enquanto o módulo do qual foi carregado permanecer na memória.
    O hand cursor. [hCursor] \As seguintes funções obtêm um cursor compartilhado:
    \LoadCursor \LoadImage (se você usar o sinalizador LR_SHARED)
    \LoadCursorFromFile \CopyImage (se você usar a sinalização LR_COPYRETURNORG e o parâmetro hImage for um cursor compartilhado)
  Call "user32.dll" "DestroyCursor" com 
    A seta do mouse. [hCursor] 

Etapas para que se finalize as fontes:
  \Call "gdi32.dll" "RemoveFontMemResourceEx" com o osmosian fonte resource.
  \Call "gdi32.dll" "RemoveFontMemResourceEx" com o Segoe UI resource.
  Call "gdi32.dll" "RemoveFontMemResourceEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-RemoveFontMemResourceEx
  \A função RemoveFontMemResourceEx remove as fontes que foram adicionadas a partir de um arquivo de imagem de memória.
    O recurso de fonte Tahoma. [h] \Um identificador para o recurso de fonte. Esse identificador é retornado pela função AddFontMemResourceEx.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
    \Esta função remove uma fonte que foi adicionada pela função AddFontMemResourceEx. 
    \Para remover a fonte, especifique o mesmo caminho e sinalizadores que foram usados em AddFontMemResourceEx. 
    \Esta função removerá apenas a fonte especificada por fh.

Etapas para que se finalize gdi+:
  Call "gdiplus.dll" "GdiplusShutdown" com \https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusinit/nf-gdiplusinit-gdiplusshutdown
  \A função GdiplusShutdown limpa os recursos usados pelo Windows GDI +. 
  \Cada chamada para GdiplusStartup deve ser emparelhada com uma chamada para GdiplusShutdown.
    O gpToken. [token] \ O Token retornado por uma chamada anterior para GdiplusStartup.
    \Você deve chamar GdiplusStartup antes de criar quaisquer objetos GDI + 
    \e deve excluir todos os seus objetos GDI + (ou fazer com que saiam do escopo) antes de chamar GdiplusShutdown.
    \Observação: Para o Windows 7 e anteriores, se GDI + não puder criar uma família de fontes, 
    \ele substitui a família Sans Serif genérica e armazena em cache do lado do cliente o ponteiro para a família genérica. 
    \Como as chamadas para GdiplusStartup e GdiplusShutdown não estão cientes desse armazenamento em cache, 
    \o sistema operacional retém o ponteiro para o objeto de família genérica após o tempo de vida do objeto, o que faz com que o sistema operacional trave por completo. 
    \Para o Windows 8 e posterior, GDI + retorna um valor sentinela para o objeto da família genérica que permanece constante nas chamadas para GdiplusStartup 
    \e GdiplusShutdown para que o sistema operacional não retenha o ponteiro para o objeto da família genérica após a vida útil do objeto.

Etapas para que se finalize o memory canvas:
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hdc] \identificador do contexto de dispositivo
    e O saved memory hBitMap [h] \O identificador do objeto a ser selecionado.
    \ Neste caso, O objeto especificado deve ter sido criado usando uma das seguintes funções:
    \CreateBitmap, CreateBitmapIndirect, CreateCompatibleBitmap, CreateDIBitmap, CreateDIBSection
    \Os bitmaps só podem ser selecionados em DCs de memória. Um único bitmap não pode ser selecionado em mais de um DC ao mesmo tempo.
    devolvendo um hBitMap. [] \Se o objeto selecionado não for uma região e a função for bem-sucedida, o valor de retorno é um identificador para o objeto que está sendo substituído. 
    \Se o objeto selecionado for uma região e a função for bem-sucedida, o valor de retorno será um dos seguintes valores.
    \A região SIMPLEREGION consiste em um único retângulo. A região COMPLEXREGION consiste em mais de um retângulo.
    \A região NULLREGION é uma região vazia.
    \Se ocorrer um erro e o objeto selecionado não for uma região, o valor de retorno será NULL. Caso contrário, é HGDI_ERROR.
    \Observações: Esta função retorna o objeto selecionado anteriormente do tipo especificado. 
    \Um aplicativo deve sempre substituir um novo objeto pelo objeto padrão original depois de terminar de desenhar com o novo objeto.
    \Um aplicativo não pode selecionar um único bitmap em mais de um DC de cada vez.
    \ICM: Se o objeto selecionado for um pincel ou uma caneta, o gerenciamento de cores é executado.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógico, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hBitMap. [ho] \O indentificador de uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se o identificador especificado não é válido ou está atualmente selecionado em um DC, o valor de retorno é zero.
    \Não exclua um objeto de desenho (caneta ou pincel) enquanto ele ainda estiver selecionado em um DC.
    \Quando um pincel de padrão é excluído, o bitmap associado à cor do pincel não é excluído. O bitmap deve ser excluído independentemente.
  Call "gdi32.dll" "DeleteDC" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-deletedc
  \A função DeleteDC exclui o contexto de dispositivo especificado (DC).
    O memory canvas. [hdc] \O identificador do contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
    \Um aplicativo não deve excluir um controlador de domínio cujo identificador foi obtido chamando a função GetDC. 
    \Em vez disso, ele deve chamar a função ReleaseDC para liberar o DC.

Etapas para que se finalize o module:

Etapas para que se finalize o mouse:

Etapas para que se finalize a área de impressão:
  Call "kernel32.dll" "GlobalFree" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globalfree
  \A função GlobalFree libera o objeto de memória global especificado e invalida seu identificador.
    O número identificador do modo de dispositivo da impressora.[hMem] \ O número identificador do objeto de memória global. 
    \Esse identificador é retornado pela função GlobalAlloc ou GlobalReAlloc. 
    \Não é seguro liberar memória alocada com LocalAlloc.
    \As funções globais têm maior sobrecarga e fornecem menos recursos do que outras funções de gerenciamento de memória. 
    \Novos aplicativos devem usar as funções de heap, a menos que a documentação indique que uma função global deve ser usada. 
    \Para obter mais informações, consulte Funções globais e locais.
    \Se o processo examinar ou modificar a memória depois de liberada, 
    \pode ocorrer corrupção de heap ou pode ser gerada uma exceção de violação de acesso (EXCEPTION_ACCESS_VIOLATION).
    \A função GlobalFree irá liberar um objeto de memória bloqueado. 
    \Um objeto de memória bloqueado possui uma contagem de bloqueio maior que zero. 
    \A função GlobalLock bloqueia um objeto de memória global e aumenta a contagem de bloqueios em 1. 
    \A função GlobalUnlock o desbloqueia e diminui a contagem de bloqueios em 1. 
    \Para obter a contagem de bloqueios de um objeto de memória global, use a função GlobalFlags.
    \Se um aplicativo estiver sendo executado em uma versão de depuração do sistema, 
    \a função GlobalFree emitirá uma mensagem informando que um objeto bloqueado está sendo liberado. 
    \Se você estiver depurando o aplicativo, GlobalFree entrará em um ponto de interrupção antes de liberar um objeto bloqueado. 
    \Isso permite que você verifique o comportamento pretendido e, em seguida, continue a execução.
  Atribua 0 à área de impressão.

Etapas para que se finalize a tela:

Etapas para que se finalize o tela canvas:

Etapas para que se finalize um talker:
  Se o talker for inexistente, cancele.
  Call a release desta vtable deste talker com o talker.
  Atribua nil ao talker.

Etapas para que se finalize o janela do programa:
  Call "user32.dll" "DestroyWindow" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-destroywindow
  \A função DestroyWindow destrói a janela especificada. 
  \A função envia mensagens WM_DESTROY e WM_NCDESTROY para a janela para desativá-la e remover o foco do teclado dela. 
  \A função também destrói o menu da janela, 
  \esvazia a fila de mensagens do tópico, 
  \destrói temporizadores, 
  \remove a propriedade da área de transferência e 
  \quebra a cadeia do visualizador da área de transferência (se a janela estiver no topo da cadeia do visualizador).
  \Se a janela especificada for uma janela pai ou proprietária, 
  \DestroyWindow destrói automaticamente as janelas filhas ou proprietárias associadas ao destruir a janela pai ou proprietária. 
  \A função primeiro destrói as janelas filhas ou proprietárias e, em seguida, destrói a janela pai ou proprietária.
  \DestroyWindow também destrói caixas de diálogo não modais criadas pela função CreateDialog.
    A janela principal do programa. [hWnd] \O número identificador da janela a ser destruída.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
    \Um thread não pode usar DestroyWindow para destruir uma janela criada por um thread diferente.
    \Se a janela que está sendo destruída for uma janela filho que não tem o estilo WS_EX_NOPARENTNOTIFY, uma mensagem WM_PARENTNOTIFY é enviada ao pai.
  Comece. [a executar o código abaixo]
  \ Execute a função "GetMessageA" da biblioteca "user32.dll" usando como argumentos os seguintes parâmetros: 
  \\o endereçamento dessa MSG e os valores 0, 0 e 0, esperando um número como resultado.
  Call "user32.dll" "GetMessageA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getmessagea
  \A função GetMessageA obtém uma mensagem da fila de mensagens do thread de chamada. 
  \A função despacha mensagens enviadas de entrada até que uma mensagem postada esteja disponível para obtenção.
      O endereçamento dessa MSG [lpMsg] \Um ponteiro para uma estrutura MSG que recebe informações da mensagem da fila de mensagens do segmento.
      \https://docs.microsoft.com/pt-br/windows/desktop/api/winuser/ns-winuser-MSG
      e 0 [hWnd]  \Um identificador para a janela cujas mensagens devem ser recuperadas. A janela deve pertencer ao segmento atual.
    \Se hWnd for NULL, GetMessage recuperará mensagens para qualquer janela que pertença ao segmento atual 
    \e quaisquer mensagens na fila de mensagens do segmento atual cujo valor hwnd seja NULL.
    \Portanto, se hWnd for NULL, tanto as mensagens da janela quanto as mensagens do thread serão processadas.
      e 0 [wMsgFilterMin] \O valor inteiro do menor valor da mensagem a ser recuperado. 
      e 0 [wMsgFilterMax] \O valor inteiro do maior valor da mensagem a ser recuperado. 
    \Se wMsgFilterMin e wMsgFilterMax forem 0, GetMessage retorna todas as mensagens disponíveis (ou seja, nenhuma filtragem de intervalo é executada).
      devolvendo um número. \Se a função recuperar uma mensagem diferente de WM_QUIT, o valor de retorno será diferente de zero.    
    \Se houver um erro, o valor de retorno é -1. 
    \Por exemplo, a função falhará se hWnd for um identificador de janela inválido ou lpMsg for um ponteiro inválido. 
    Se o número for menor do que 1, pare. \Se a função recuperar a mensagem WM_QUIT, o valor de retorno será zero.
    Call "user32.dll" "TranslateMessage" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-translatemessage
    \Traduz mensagens de teclas virtuais em mensagens de caracteres. 
    \As mensagens de caracteres são postadas na fila de mensagens do thread de chamada, 
    \para serem lidas na próxima vez que o thread chamar a função GetMessage ou PeekMessage.
      o endereçamento desta MSG. [*lpMsg] \Um ponteiro para uma estrutura MSG 
      \ https://docs.microsoft.com/pt-br/windows/desktop/api/winuser/ns-winuser-msg
      \que contém informações de mensagem recuperadas da fila de mensagens do thread de chamada usando a função GetMessage ou PeekMessage.
      \Se a mensagem for traduzida (ou seja, uma mensagem de caractere é postada na fila de mensagens do encadeamento), o valor de retorno é diferente de zero.
      \Se a mensagem for WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN ou WM_SYSKEYUP, o valor de retorno será diferente de zero, independentemente da tradução.
    \Se a mensagem não for traduzida (ou seja, uma mensagem de caractere não é postada na fila de mensagens do encadeamento), o valor de retorno é zero.
    Call "user32.dll" "DispatchMessageA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-dispatchmessagea
    \Envia uma mensagem para um procedimento de janela. Normalmente é usado para despachar uma mensagem recuperada pela função GetMessage.
      o endereçamento desta MSG.[*lpMsg]  \Um ponteiro para uma estrutura que contém a mensagem.
      \O valor de retorno especifica o valor retornado pelo procedimento de janela. E
      \mbora seu significado dependa da mensagem que está sendo despachada, o valor de retorno geralmente é ignorado.
  Recomece. [percorra novamente o código acima]
  Desmanche a fila de eventos.
  Destrua o evento atual.

Etapas para que se finalize winsock:
  Call "ws2_32.dll" "WSACleanup". \https://docs.microsoft.com/pt-br/windows/win32/api/winsock/nf-winsock-wsacleanup
  \A função WSACleanup encerra o uso da DLL Winsock 2 (Ws2_32.dll).
  \O valor de retorno é zero se a operação foi bem-sucedida. Caso contrário, o valor SOCKET_ERROR é retornado.
  \Um aplicativo ou DLL é necessário para executar uma chamada WSAStartup com êxito antes de usar os serviços do Windows Sockets. 
  \Quando tiver concluído o uso de Windows Sockets, 
  \o aplicativo ou DLL deve chamar WSACleanup para cancelar o registro de uma implementação de Windows Sockets
\  e permitir que a implementação libere quaisquer recursos alocados em nome do aplicativo ou DLL.

A find anchor é uma anchor.

Etapas para que se encontre uma escolha usando uma localização:
  Start com nada no escolha.
  Comece. [a executar o código abaixo]
    Obtenha o [first/next] escolha desde as escolhas.
    Se o escolha estiver sumido do mapa, cancele.
    Se a localização estiver na caixa desta escolha, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre uma díade usando umas díades e um nome:
  Esvazie a díade.
  Comece. [a executar o código abaixo]
    Obtenha a díade desde as díades.
    Se a díade for inexistente, cancele.
    Se o nome deste díade for o nome, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre next usando uma linha de texto e uma caixa de texto e um detector:
  Desative o detector.
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Lance um subtexto sobre a string deste linha de texto.
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres deste texto pesquisado menos 1 ao caractere final deste subtexto.
  Se o número da linha desta linha de texto for o número da linha deste find anchor, mova o subtexto usando o número de coluna deste find anchor menos 1.
  Comece. [a executar o código abaixo]
    Se o caractere final deste subtexto for maior do que ou igual ao caractere final desta string desta linha de texto, cancele.
    Se o subtexto for o texto pesquisado (comparação de caracteres acentuados), pare. \ for spanish incremental find
    Mova o subtexto usando 1.
  Recomece. [percorra novamente o código acima]
  Ligue o detector.
  Atribua o caractere inicial deste subtexto menos o caractere inicial desta string desta linha de texto mais 1 ao anchor número de coluna desta caixa de texto.
  Atribua o número da linha desta linha de texto ao anchor número da linha desta caixa de texto .
  Atribua o caractere final deste subtexto menos o caractere inicial desta string desta linha de texto mais 2 ao cursor de texto número de coluna desta caixa de texto.
  Atribua o número da linha desta linha de texto ao número de linhas do cursor desta caixa de texto.

Etapas para que se encontre next usando uma caixa de texto e um detector:
  Se o detector de quebra de texto desta caixa de texto estiver ativo, encontre next usando a caixa de texto e o detector (wrapped caixa de texto); saia.
  Desative o detector.
  Se a caixa de texto for inexistente, cancele.
  Se a quantidade de caracteres deste texto pesquisado for 0, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se o número da linha desta linha de texto for menor do que o número da linha deste find anchor, recomece.
    Encontre next usando a linha de texto e a caixa de texto e o detector.
    Se o detector estiver ativo, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre next usando uma caixa de texto e um detector (wrapped caixa de texto):
  Desative o detector.
  Se a caixa de texto for inexistente, cancele.
  Converta o find anchor para um posicionamento absoluto denominado offset usando a caixa de texto.
  Extraia uma string desde a caixa de texto (sem adicionar quebras de linha).
  Atribua o caractere inicial desta string mais o offset menos 1 ao caractere inicial desse subtexto.
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres deste texto pesquisado menos 1 ao caractere final deste subtexto.
  Comece. [a executar o código abaixo]
    Se o caractere final deste subtexto for maior do que o caractere final desta string, cancele.
    Se o subtexto for a texto pesquisado (comparação de caracteres acentuados), pare. \ para A spanish incremental find
    Mova o subtexto usando 1.
  Recomece. [percorra novamente o código acima]
  Ligue o detector.
  Atribua o caractere inicial deste subtexto menos o caractere inicial desta string mais 1 a um anchor posicionamento absoluto.
  Atribua o caractere final deste subtexto menos o caractere inicial desta string mais 2 a um cursor de texto posicionamento absoluto.
  Converta o anchor posicionamento absoluto para o anchor desta caixa de texto usando a caixa de texto.
  Converta o cursor de texto posicionamento absoluto para o cursor de texto desta caixa de texto usando a caixa de texto.

Etapas para que se encontre o next misspelling usando uma linha de texto e uma caixa de texto e um detector:
  Desative o detector.
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Lance um percorredor sobre a string deste linha de texto.
  Se o número da linha desta linha de texto for o número da linha deste find anchor, adicione o número de coluna deste find anchor menos 1 para o caractere inicial deste segmento final deste percorredor.
  Se o caractere inicial deste segmento final deste percorredor não for o caractere inicial desta string desta linha de texto, skip palavra characters no segmento final deste percorredor.
  Comece. [a executar o código abaixo]
    Mova o percorredor (spell checking rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor não estiver escrito incorretamente, recomece.
  Ligue o detector.
  Atribua o caractere inicial deste segmento inicial deste percorredor menos o caractere inicial desta string desta linha de texto mais 1 ao anchor número de coluna desta caixa de texto.
  Atribua o número da linha desta linha de texto ao anchor número da linha desta caixa de texto .
  Atribua o caractere final deste segmento inicial deste percorredor menos o caractere inicial desta string desta linha de texto mais 2 ao cursor de texto número de coluna desta caixa de texto.
  Atribua o número da linha desta linha de texto ao número de linhas do cursor desta caixa de texto.

Etapas para que se encontre o next misspelling em uma caixa de texto usando um detector:
  Desative o detector.
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se o número da linha desta linha de texto for menor do que o número da linha deste find anchor, recomece.
    Encontre o next misspelling usando a linha de texto e a caixa de texto e o detector.
    Se o detector estiver ativo, cancele.
  Recomece. [percorra novamente o código acima]



Etapas para que se encontre um ponteiro usando uma string e um catálogo:
  Encontre um referência usando a string e o catálogo.
  Se o referência não for inexistente, atribua o ponteiro deste referência ao ponteiro; saia.
  Esvazie o ponteiro.

Etapas para que se encontre um referência usando uma string e um catálogo:
  Se o catálogo for inexistente, cancele.
  Se a string estiver em branco, esvazie o referência; saia.
  Obtenha um bucket usando a string e o catálogo.
  Encontre o referência usando a string e os referências deste bucket.

Etapas para que se encontre um referência usando uma string e uns referências:
  Esvazie o referência.
  Comece. [a executar o código abaixo]
    Obtenha o referência desde o referências.
    Se o referência for inexistente, cancele.
    Se a string for a string deste referência, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um sector usando uma malha e uma localização:
  Atribua a coordenada X desta localização dividido pelo número X desta malha times o número X desta malha à coordenada X deste sector.
  Atribua a coordenada Y desta localização dividido pelo número Y desta malha times o número Y desta malha à coordenada Y deste sector.

Etapas para que se encontre um square root of um número:
  \ arredonda para baixo
  Isole o número.
  De-sign o número.
  Se o número for 0, atribua 0 ao square root; saia.
  Se o número for 1, atribua 1 ao square root; saia.
  Atribua 1 a um square número.
  Atribua 3 a um delta número.
  Comece. [a executar o código abaixo]
    Se o square for maior do que o número, pare.
    Adicione o delta para o square.
    Adicione 2 para o delta.
  Recomece. [percorra novamente o código acima]
  Atribua o delta dividido por 2 menos 1 ao square root.

Etapas para que se encontre uma string usando uns conjuntos des textos e um número do texto:
  Limpe a string.
  Comece. [a executar o código abaixo]
    Obtenha um conjunto de texto desde o conjuntos des textos.
    Se o conjunto de texto for inexistente, cancele.
    Adicione 1 para uma contagem.
    Se a contagem não for o número do texto, recomece.
  Atribua a string deste conjunto de texto à string.

O texto pesquisado é uma string.

Etapas para que se encontre um conjunto de texto usando uma string e uns conjuntos des textos:
  Esvazie o conjunto de texto.
  Comece. [a executar o código abaixo]
    Obtenha o conjunto de texto usando o conjuntos des textos.
    Se o conjunto de texto for inexistente, pare.
    Se a string deste conjunto de texto é a string, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um subtexto em uma string usando uma segunda string:
  Lance o subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o subtexto começa com a segunda string, pare.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao caractere final deste subtexto.

Etapas para que se encontre um value string usando umas díades e um nome:
  Encontre uma díade usando as díades e o nome.
  Se a díade for inexistente, limpe o value string; saia.
  Atribua a value string deste díade ao value string.

Etapas para que se encontre uma value string usando o environment variáveis e um nome:
  Isole o nome.
  Anexe o caractere NULL o nome.
  Atribua 32767 a uma quantidade de caracteres. \ max size de environment variável
  Reassign o caractere inicial desta value string usando a quantidade de caracteres.
  Call "kernel32.dll" "GetEnvironmentVariableA" com \https://docs.microsoft.com/pt-br/windows/win32/api/processenv/nf-processenv-getenvironmentvariablea
  \Recupera o conteúdo da variável especificada do bloco de ambiente do processo de chamada.
    O caractere inicial deste nome [lpName] \O nome da variável de ambiente.
    e O caractere inicial desta value string [lpBuffer] \Um ponteiro para um buffer que recebe o conteúdo da variável de ambiente especificada como uma string terminada em nulo. 
    \Uma variável de ambiente tem um limite máximo de tamanho de 32.767 caracteres, incluindo o caractere de terminação nula.
    e A quantidade de caracteres [nSize] \O tamanho do buffer apontado pelo parâmetro lpBuffer , incluindo o caractere de terminação nula, em caracteres.
    devolvendo a quantidade de caracteres. \Se a função for bem-sucedida, o valor de retorno é o número de caracteres armazenados no buffer apontado por lpBuffer , 
    \sem incluir o caractere nulo de terminação.
    \Se lpBuffer não for grande o suficiente para conter os dados, o valor de retorno é o tamanho do buffer, em caracteres, 
    \necessário para conter a string e seu caractere nulo de terminação e o conteúdo de lpBuffer são indefinidos.
    \Se a função falhar, o valor de retorno é zero. 
  Atribua o caractere inicial desta value string mais a quantidade de caracteres menos 1 ao caractere final desta value string. 

Um finger é um ponteiro do byte .

\Um flag has 4 bytes.
Um detector é uma conjunto com 4 bytes. \é um conjunto com

Etapas para que se flip uma fração:
  Permute o numerador desta fração com o denominador desta fração.

Etapas para que se flip o gpBitmap em uma imagem:
  Se a imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Flip o gpBitmap desta imagem.

Etapas para que se flip um GpImage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusheaders/nf-gdiplusheaders-image-rotateflip
  \A função GdipImageRotateFlip gira e/ou inverte a imagem. É a imagem que sofre a transformação e não o gráfico no qual será exibida.
   \O ângulo e a inversão são definidos por uma das constantes da enumeração RotateFlipType .
    O GpImage [*image] \Ponteiro para o objeto Image .
    e 6 [rfType = RotateNoneFlipY aka Rotate180FlipX]. \ Elemento da enumeração RotateFlipType que especifica o tipo de rotação e o tipo de inversão.
    \#RotateNoneFlipY = # Rotate180FlipX Especifica nenhuma rotação seguida por uma inversão vertical.
    \Se a função for bem-sucedida, ela retornará 0, que é uma constante da enumeração de status .
    \Se a função falhar, ela retornará um dos outros valores da enumeração de status .

Etapas para que se flip uma imagem:
  Se a imagem for inexistente, cancele.
  Atribua a coordenada Y deste centro desta caixa desta imagem menos a coordenada Y deste centro desta caixa intacta desta imagem ao número Y desse par de números.
  Multiplique o número Y deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Flip o gpBitmap no imagem.

Etapas para que se flip um polígono:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Comece. [a executar o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia a coordenada Y do canto superior esquerdo desta caixa desde a coordenada Y deste vértice.
    Atribua a coordenada Y do canto inferior direito desta caixa menos a coordenada Y deste vértice à coordenada Y deste vértice.
  Recomece. [percorra novamente o código acima]

Etapas para que se desmanche all input;
Etapas para que se desmanche all inputs;
Etapas para que se desmanche all eventos:
  Desmanche algum tipo de messages.
  Desmanche a fila de eventos.

Etapas para que se desmanche algum tipo de messages:
  Call "user32.dll" "PeekMessageA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-peekmessagea
  \Despacha as mensagens enviadas recebidas, verifica a fila de mensagens do thread para uma mensagem postada e recupera a mensagem (se houver).
    O endereçamento dessa MSG [lpMsg] \ Um ponteiro para uma estrutura MSG que recebe informações da mensagem.
    e 0 [hWnd] \ Um identificador para a janela cujas mensagens devem ser recuperadas. A janela deve pertencer ao segmento atual.
    \Se hWnd for NULL , PeekMessage recupera mensagens para qualquer janela que pertença ao segmento atual e todas as mensagens na fila de mensagens do segmento atual cujo valor hwnd é NULL (consulte a estrutura MSG ). 
    \Portanto, se hWnd for NULL , as mensagens da janela e as mensagens do thread serão processadas.
    e 0 [wMsgFilterMin] \ O valor da primeira mensagem no intervalo de mensagens a serem examinadas. 
    \Use WM_KEYFIRST (0x0100) para especificar a primeira mensagem do teclado ou WM_MOUSEFIRST (0x0200) para especificar a primeira mensagem do mouse.
    \Se wMsgFilterMin e wMsgFilterMax forem zero, PeekMessage retorna todas as mensagens disponíveis (ou seja, nenhuma filtragem de intervalo é executada).
    e 0 [wMsgFilterMax] \ O valor da última mensagem no intervalo de mensagens a serem examinadas. 
    \Use WM_KEYLAST para especificar a última mensagem do teclado ou WM_MOUSELAST para especificar a última mensagem do mouse.
    e 1 [wRemoveMsg = PM_REMOVE] \ Especifica como as mensagens devem ser tratadas. 
    \PM_REMOVE = As mensagens não são removidas da fila após o processamento por PeekMessage .
    devolvendo um número. \Se uma mensagem estiver disponível, o valor de retorno será diferente de zero.
  Se o número for 0, cancele. \Se nenhuma mensagem estiver disponível, o valor de retorno é zero.
  Se a message desta MSG for 15 [WM_PAINT], Call "user32.dll" "ValidateRect" com a janela principal do programa e 0. \ que tal ter uma rotina específica para isso?
  Recomece. [percorra novamente o código acima]

Etapas para que se desmanche um fila de eventos:
  Obtenha um evento desde a fila de eventos.
  Se o evento for inexistente, cancele.
  Remove o evento desde a fila de eventos.
  Destrua o evento.
  Recomece. [percorra novamente o código acima]

Uma fonte é um conjunto com 
  Um nome e 
  Uma altura.

Um altura da fonte é uns twips. \ indicates linha reta altura - o letras will fit nicely em uma caixa of this altura

Um fonte resource é um número identificador.

Um pé são 12 polegadas.

Etapas para que se format um número e um singular string ou um plural string Para uma string: \verificar
  Converta o número para a string.
  Posponha o caractere de espaço para a string.
  Se o número for 1, posponha o singular para a string.
  Se o número não for 1, posponha o plural para a string.

Uma fração é um conjunto com 
  Um numerador número e 
  Um denominador número, e 
  Um topo número sob o numerador e 
  Um base número sob o denominador.

Um par de números fracionários é um conjunto com 
  Uma fração e 
  Uma segunda fração.

Um máximo divisor comum é um número.

Um figura geométrica é um figura.

Etapas para que se obtenha um abcA e um abcC usando uma string e um canvas:
  Atribua 0 ao abcA.
  Atribua 0 ao abcC.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsa
  \A função GetCharABCWidths recupera as larguras, em unidades lógicas, de caracteres consecutivos em um intervalo especificado da fonte TrueType atual. 
  \Esta função é funciona apenas com fontes TrueType.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O conteúdo deste caractere inicial desta string [wFirst] \ O primeiro caractere no grupo de caracteres consecutivos da fonte atual.
    e O conteúdo deste caractere inicial desta string [wLast] \ O último caractere no grupo de caracteres consecutivos da fonte atual.
    e O endereçamento desse ABC. [lpABC] \ Um ponteiro para uma matriz de estruturas ABC que recebe as larguras dos caracteres, em unidades lógicas. 
    \Esta matriz tem que conter, a mesma quantidade de estruturas ABC que a quantidade de caracteres no intervalo especificado pelos parâmetros uFirstChar e uLastChar .
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
  Atribua o abcA deste ABC ao abcA.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste caractere final desta string 
    e O conteúdo deste caractere final desta string 
    e O endereçamento desse segundo ABC.
  Atribua o abcC deste segundo ABC ao abcC.

Etapas para que se obtenha um abcA usando uma string e um canvas:
  Atribua 0 ao abcA.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste caractere inicial desta string 
    e O conteúdo deste caractere inicial desta string 
    e O endereçamento desse ABC.
  Atribua o abcA deste ABC ao abcA.

Etapas para que se obtenha uns addrinfo routines:
  Limpe o erro do fluxo de entrada/saída.
  Atribua "ws2_32.dll" a uma nova string.
  Call "kernel32.dll" "LoadLibraryA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya
  \Carrega o módulo especificado no espaço de endereço do processo de chamada. 
  \O módulo especificado pode fazer com que outros módulos sejam carregados.
    O caractere inicial desta nova string [lpLibFileName] \O nome do módulo. 
    \Pode ser um módulo de biblioteca (um arquivo .dll) ou um módulo executável (um arquivo .exe). 
    \O nome especificado é o nome do arquivo do módulo e não está relacionado ao nome armazenado no próprio módulo de biblioteca, 
    \conforme especificado pela palavra-chave LIBRARY no arquivo de definição de módulo (.def).
    \Se a string especifica um caminho completo, a função pesquisa apenas esse caminho para o módulo.
    \Se a string especifica um caminho relativo ou um nome de módulo sem um caminho, 
    \a função usa uma estratégia de pesquisa padrão para encontrar o módulo.
    \Se a função não conseguir encontrar o módulo, a função falha. 
    \Ao especificar um caminho, certifique-se de usar barras invertidas (\), não barras (/).
    \Se a string especifica um nome de módulo sem um caminho e a extensão do nome do arquivo é omitida, 
    \a função anexa a extensão da biblioteca padrão .dll ao nome do módulo. 
    \Para evitar que a função acrescente .dll ao nome do módulo, inclua um caractere de ponto final (.) na string do nome do módulo.
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno é um identificador para o módulo.
    \Se a função falhar, o valor de retorno será NULL.
  Se o número identificador for 0, atribua "A função LoadLibraryA da biblioteca ws2_32.dll retornou um erro. Não foi possível obteridentificador do módulo a ser carregado." ao erro do fluxo de entrada/saída; saia.
  Atribua "getaddrinfo" a uma nova string.
  Call "kernel32.dll" "GetProcAddress" com \https://docs.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress
  \Recupera o endereço de uma função ou variável exportada da biblioteca de vínculo dinâmico (DLL) especificada.
    O número identificador [hModule] \Um identificador para o módulo DLL que contém a função ou variável. 
    \A função LoadLibrary, LoadLibraryEx, LoadPackagedLibrary ou GetModuleHandle retorna esse identificador.
    e o caractere inicial desta nova string [lpProcName] [ponteiro para uma string constante]  \ O nome da função ou variável, ou o valor ordinal da função. 
    \Se este parâmetro for um valor ordinal, ele deve estar contido na word de ordem inferior; a word de ordem superior deve ser zero.
    devolvendo um ponteiro. \ obtendo/recebendo/aguardando como resultado
    \Se a função for bem-sucedida, o valor de retorno será o endereço da função ou variável exportada.
    \Se a função falhar, o valor de retorno será NULL.
  Se o ponteiro for inexistente, atribua "Infelizmente essa rotinas só funcionam no Windows XP ou superior." ao erro do fluxo de entrada/saída; saia.
  Atribua o ponteiro ao getaddrinfo ponteiro destas addrinfo routines.
  Atribua "freeaddrinfo" a uma string atual.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador [hModule]
    e o caractere inicial desta  string atual [lpProcName = ponteiro para uma string constante] 
    devolvendo o ponteiro.
  Se o ponteiro for inexistente, atribua "Infelizmente essas rotinas só funcionam no Windows XP ou numa versão superior do Windows." ao erro do fluxo de entrada/saída; saia.
  Atribua o ponteiro ao freeaddrinfo ponteiro destas addrinfo routines.

Etapas para que se obtenha uma caixa pelo cursor de texto em uma caixa de texto:
  Se a caixa de texto for inexistente, zero a caixa; saia.
  Obtenha uma localização usando o cursor de texto desta caixa de texto e a caixa de texto.
  Atribua a localização e a localização ao caixa.
  Adicione a altura da linha desta caixa de texto para a coordenada Y do canto inferior direito desta caixa.
  Ajuste a caixa usando 0 e a quantidade de twips/pixel e 0 e - a quantidade de twips/pixel .
  Atribua a globalized origem desta caixa de texto a um origem.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X desta origem, atribua a coordenada X desta origem à coordenada X do canto superior esquerdo desta caixa; atribua a coordenada X desta origem à coordenada X do canto inferior direito desta caixa.
  Se o detector de quebra de texto desta caixa de texto não estiver ativo, cancele.
  Limite a coordenada X do canto superior esquerdo desta caixa para a coordenada X do canto superior esquerdo desta caixa de texto e a coordenada X do canto inferior direito desta caixa de texto.
  Limite a coordenada X do canto inferior direito desta caixa para a coordenada X do canto superior esquerdo desta caixa de texto e a coordenada X do canto inferior direito desta caixa de texto.

Etapas para que se obtenha uma caixa por uma linha reta:
  Atribua a localização inicial desta linha reta ao canto superior esquerdo desta caixa.
  Atribua a localização final desta linha reta ao canto inferior direito desta caixa.
  Normalize a caixa.

Etapas para que se obtenha uma caixa usando uma linha de texto e uma caixa de texto:
  Se a caixa de texto for inexistente, zero a caixa; saia.
  Se a linha de texto for inexistente, zero a caixa; saia.
  Atribua a globalized origem desta caixa de texto ao canto superior esquerdo desta caixa.
  Adicione o número da linha desta linha de texto menos 1 times a altura da linha desta caixa de texto para a coordenada Y do canto superior esquerdo desta caixa.
  Atribua a coordenada X do canto inferior direito desta caixa de texto à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura da linha desta caixa de texto à coordenada Y do canto inferior direito desta caixa.

Etapas para que se obtenha um bucket usando um bucket# e um catálogo:
  \ if o catálogo for inexistente, esvazie o bucket; saia. \ para fazer compilador faster
  Atribua o first bucket deste catálogo ao bucket.
  Adicione o bucket# times a magnitude desse conjunto de buckets para o bucket.

Etapas para que se obtenha um bucket usando um catálogo:
  \Se o catálogo for inexistente, esvazie o bucket; saia. \ para fazer o compilador mais rápido
  Se o bucket for inexistente, atribua o first bucket deste catálogo ao bucket; saia.
  Se o bucket for o last bucket deste catálogo, esvazie o bucket; saia.
  Adicione a magnitude desse conjunto de buckets para o bucket.

Etapas para que se obtenha um bucket usando uma string e um catálogo:
  \ if o catálogo for inexistente, esvazie o bucket; saia. \ para fazer compilador faster
  Obtenha um bucket# usando a string e o catálogo.
  Obtenha o bucket usando o bucket# e o catálogo.

Etapas para que se obtenha um bucket# usando uma string e um catálogo:
  \ baseado no algoritmo djb2 
  \ if o catálogo for inexistente, atribua 0 ao bucket#; saia. \ para fazer compilador faster
  Atribua a quantidade de caracteres desta string ao bucket#.
  Se o bucket# for 0, cancele.
  Adicione 5381 para o bucket#.
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Atribua o conteúdo deste caractere inicial deste subtexto a um byte.
    Lowercase o byte.
    Atribua o bucket# a um número.
    Desloque o bucket# 5 bits para a esquerda.
    Adicione o número para o bucket#.
    Adicione o byte para o bucket#.
    Adicione 3 para o caractere inicial deste subtexto.
    Se o subtexto estiver em branco, pare.
  Recomece. [percorra novamente o código acima]
  Conjuncione logicamente o bucket# com o maior número.
  Divida o bucket# pela contagem de buckets deste catálogo usando um quociente e o bucket#.

Etapas para que se obtenha um byte desde uma string:
  Se a string estiver em branco, atribua o caractere null ao byte; saia.
  Atribua o conteúdo deste caractere inicial desta string ao byte.
  Remove o first byte desde a string.

Etapas para que se obtenha um byte desde uma string (backwards):
  Se a string estiver em branco, atribua o caractere null ao byte; saia.
  Atribua o conteúdo deste caractere final desta string ao byte.
  Remove o last byte desde a string.

Etapas para que se obtenha um centro localização usando uma localização e uma segunda localização:
  Atribua a localização e a segunda localização a uma linha reta.
  Atribua o centro desta linha reta ao centro.

Etapas para que se obtenha uma cor usando uma localização:
  Call "gdi32.dll" "GetPixel" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getpixel
    O quadro atual [hdc] \Um identificador para o contexto do dispositivo.
    e A coordenada X desta localização [x] \A coordenada x, em unidades lógicas, do pixel a ser examinado.
    e A coordenada Y desta localização [y] \A coordenada y, em unidades lógicas, do pixel a ser examinado.
    devolvendo um código da cor. \O valor de retorno é o valor COLORREF que especifica o RGB do pixel. 
    \Se o pixel estiver fora da região de recorte atual, o valor de retorno é CLR_INVALID (-1, 4294967295 ou 0xFFFFFFFF definido em Wingdi.h).
  Converta o código da cor para a cor.

Etapas para que se obtenha um número de coluna usando uma linha de texto e uma localização e uma caixa de texto:
  Atribua 0 ao número de coluna.
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Obtenha uma caixa usando a linha de texto e a caixa de texto.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a quantidade de caracteres desta string desta linha de texto ao número de coluna; saia. \ only happens sobre last linha de texto of caixa de texto
  Crie o número da fonte of o memory canvas usando a fonte desta caixa de texto.
  Obtenha um start largura e um subtexto usando a linha de texto e a localização e a caixa de texto (for "get um número de coluna usando uma linha de texto...").
  Comece. [a executar o código abaixo]
    Se o caractere final deste subtexto é o caractere final desta string desta linha de texto, pare.
    Obtenha uma largura usando o subtexto e o memory canvas.
    Adicione o start largura para a largura.
    Obtenha uma segunda largura usando o conteúdo deste caractere final deste subtexto e o memory canvas.
    Divida a segunda largura por 2.
    Subtraia a segunda largura desde a largura.
    Se a coordenada X desta localização for menor do que a largura, pare.
    Adicione 1 para o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]
  Atribua o caractere final deste subtexto menos o caractere inicial desta string desta linha de texto mais 1 ao número de coluna.
  Destrua o número da fonte of o memory canvas.

Etapas para que se obtenha uma contagem of items em um endereço completo no sistema de arquivos:
  Atribua 0 à contagem.
  Comece. [a executar o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for encontrado, cancele.
    Adicione 1 para a contagem.
  Recomece. [percorra novamente o código acima]

Etapas para que se obtenha um description por um endereço completo:
  Limpe o description.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Atribua a categoria da unidade de disco ao description.
  Obtenha um nome da unidade de disco pelo endereço completo.
  Se o nome da unidade de disco não estiver em branco, atribua o nome da unidade de disco ao description.
  Lowercase o description.

Etapas para que se obtenha um difference entre um par de números e um segundo par de números:
  Atribua o par de números à difference.
  Subtraia o segundo par de números desde a difference.

Etapas para que se obtenha um difference entre um par de números e um segundo par de números usando uma malha par de números:
  Obtenha a difference entre o par de números e o segundo par de números.
  Arredonde a difference para a malha.

Etapas para que se obtenha um distance entre uma localização e uma segunda localização (approximate):
  Atribua a coordenada X desta localização menos o x desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos o y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número times o número ao distance.
  Adicione o segundo número times o segundo número para o distance.
  Encontre um square root of o distance.
  Atribua o square root ao distance.
  Se a tecla D/d estiver sendo pressionada, produza o relatório de informações usando o distance.

Etapas para que se obtenha um distance entre uma localização e uma segunda localização (chessboard):
  Atribua a coordenada X desta localização menos a coordenada X desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos a coordenada Y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número ao distance.
  Se o segundo número for maior do que o número, atribua o segundo número ao distance.

Etapas para que se obtenha um categoria da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetDriveTypeA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-getdrivetypea
  \Determina se uma unidade de disco é removível, fixa, CD-ROM, disco RAM ou unidade de rede.
  \Para determinar se uma unidade é do tipo USB, chame SetupDiGetDeviceRegistryProperty e especifique a propriedade SPDRP_REMOVAL_POLICY.
    O caractere inicial deste endereço completo [lpRootPathName] \O diretório raiz da unidade.
    \Uma barra invertida final é necessária. Se este parâmetro for NULL, a função usará a raiz do diretório atual.
    devolvendo um número. \O valor de retorno especifica o tipo de unidade, que pode ser um dos seguintes valores.
    \0 = O tipo de unidade não pode ser determinado.
    \1 = O caminho raiz é inválido; por exemplo, não há volume montado no caminho especificado.
  Se o número for 2 [DRIVE_REMOVABLE], atribua "Disco removível" à categoria da unidade de disco; saia. \ removable drive
  Se o número for 3 [DRIVE_FIXED], atribua "Disco Rígido / Pendrive" à categoria da unidade de disco; saia.\ hard disk / flash drive
  Se o número for 4 [DRIVE_REMOTE], atribua "Unidade de rede" à categoria da unidade de disco; saia. \ network drive
  Se o número for 5 [DRIVE_CDROM], atribua "Unidade de CD/DVD" à categoria da unidade de disco; saia. \ cd-rom / dvd drive
  Se o número for 6 [DRIVE_RAMDISK], atribua "Unidade de disco RAM" à categoria da unidade de disco; saia. \ unidade virtual de disco criada a partir da RAM
  Atribua "" à categoria da unidade de disco.

Etapas para que se obtenha um nome da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Atribua 512 a uma quantidade de caracteres.
  Reassign o caractere inicial desse trecho usando a quantidade de caracteres.
  Call "kernel32.dll" "GetVolumeInformationA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationa
  \Recupera informações sobre o sistema de arquivos e o volume associado ao diretório raiz especificado.
    O caractere inicial deste endereço completo [lpRootPathName] \ Um ponteiro para uma string que contém o diretório raiz do volume a ser descrito.
    \Se este parâmetro for NULL, a raiz do diretório atual será usada. 
    \Uma barra invertida final é necessária. 
    \Por exemplo,  \\MyServer\MyShare fica "\\MyServer\MyShare\" e a unidade C fica "C:\".
    e O caractere inicial deste trecho [lpVolumeNameBuffer] \ Um ponteiro para um buffer que recebe o nome de um volume especificado. 
    \O tamanho do buffer é especificado pelo parâmetro nVolumeNameSize
   e A quantidade de caracteres [nVolumeNameSize] \ O comprimento de um buffer de nome de volume, em TCHARs. 
   \O tamanho máximo do buffer é MAX_PATH + 1. Este parâmetro é ignorado se o buffer do nome do volume não for fornecido.
   e 0 [lpVolumeSerialNumber] \ Um ponteiro para uma variável que recebe o número de série do volume.
   \Este parâmetro pode ser NULL se o número de série não for necessário.
   \Esta função retorna o número de série do volume que o sistema operacional atribui quando um disco rígido é formatado.
   e 0 [lpMaximumComponentLength] \ Um ponteiro para uma variável que recebe o comprimento máximo, em TCHARs, 
   \de um componente de nome de arquivo que um sistema de arquivo especificado suporta.
   \Um componente de nome de arquivo é a parte de um nome de arquivo entre barras invertidas.
   \O valor armazenado na variável para a qual * lpMaximumComponentLength aponta 
   \é usado para indicar que um sistema de arquivos especificado oferece suporte a nomes longos. 
   \Por exemplo, para um sistema de arquivos FAT que suporta nomes longos, a função armazena o valor 255, em vez do indicador 8.3 anterior.
   e 0 [lpFileSystemFlags] \ Um ponteiro para uma variável que recebe sinalizadores associados ao sistema de arquivos especificado.
   e 0 [lpFileSystemNameBuffer] \ Um ponteiro para um buffer que recebe o nome do sistema de arquivos, por exemplo, o sistema de arquivos FAT ou NTFS. 
   \O tamanho do buffer é especificado pelo parâmetro nFileSystemNameSize.
   e 0 [nFileSystemNameSize] \O comprimento do buffer do nome do sistema de arquivos, em TCHARs. 
   \O tamanho máximo do buffer é MAX_PATH + 1.
   \Este parâmetro é ignorado se o buffer do nome do sistema de arquivos não for fornecido.
   devolvendo um número. \Se todas as informações solicitadas forem recuperadas, o valor de retorno será diferente de zero.
  \Se nem todas as informações solicitadas forem recuperadas, o valor de retorno será zero.
  Se o número for 0, limpe o nome da unidade de disco; saia.
  Converta o caractere inicial deste trecho como um endereçamento de caractere para o nome da unidade de disco.

Etapas para que se obtenha o first-eighth equivalent of uma orientação:
  Obtenha o first-quarter equivalent of a orientação.
  Se a orientação for menor do que 480, cancele.
  Subtraia 960 desde a orientação.
  De-sign a orientação.

Etapas para que se obtenha o first-quarter equivalent of uma orientação:
  Se a orientação for menor do que 960, cancele.
  Subtraia 960 desde a orientação.
  Recomece. [percorra novamente o código acima]

Etapas para que se obtenha novos números aleatórios;
Etapas para que se seed o número aleatório generator:
  Atribua a contagem de intervalos do sistema à seed.

Etapas para que se obtenha um máximo divisor comum usando um número e um segundo número:
  Atribua o número a um dividend número.
  Atribua o segundo número ao máximo divisor comum.
  De-sign o dividend número.
  De-sign o máximo divisor comum.
  Se o dividend for menor do que o máximo divisor comum, permute o dividend com o máximo divisor comum.
  Se o máximo divisor comum for 0, atribua 1 ao máximo divisor comum; saia.
  Comece. [a executar o código abaixo]
    Divida o dividend pelo máximo divisor comum usando um quociente e um resto.
    Se o resto for 0, cancele.
    Atribua o máximo divisor comum ao dividend.
    Atribua o resto ao máximo divisor comum.
  Recomece. [percorra novamente o código acima]

Etapas para que se obtenha um Endereço IP usando um host string:
  Limpe o Endereço IP.
  Obtenha um sockaddr usando o host string.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua o s_addr deste sin_addr deste sockaddr ao número deste Endereço IP.
  Call "ws2_32.dll" "inet_ntoa" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winsock/nf-winsock-inet_ntoa
  \A função inet_ntoa converte um endereço de rede da Internet (Ipv4) em uma string ASCII no formato decimal com pontos padrão da Internet.
  \A função inet_ntoa usa uma estrutura de endereço da Internet especificada pelo parâmetro in e retorna uma string ASCII terminada em NULL 
  \que representa o endereço em notação de "." (ponto)  como em "192.168.16.0", um exemplo de um endereço IPv4 em notação decimal com pontos.
    O número deste Endereço IP [in] \auto explicativo
    devolvendo um endereçamento de caractere. 
    \Se nenhum erro ocorrer, inet_ntoa retorna um ponteiro de caractere para um buffer estático contendo o endereço de texto na notação padrão ". ''. 
    \Caso contrário, ele retorna NULL.
  Converta o endereçamento de caractere para a string deste Endereço IP.

Etapas para que se obtenha um item (novamente):
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "FindNextFileA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-findnextfilea
  \Continua uma pesquisa de arquivo que ocorreu em uma chamada anterior para as funções FindFirstFile, FindFirstFileEx ou FindFirstFileTransacted.
    O número identificador deste item [hFindFile] \ O identificador de pesquisa retornado por uma chamada anterior para a função FindFirstFile ou FindFirstFileEx.
    e O endereçamento deste WIN32FINDDATA deste item [lpFindFileData] \ Um ponteiro para a estrutura WIN32_FIND_DATA que recebe informações sobre o arquivo ou subdiretório encontrado.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero e o parâmetro lpFindFileData conterá informações sobre o próximo arquivo ou diretório encontrado.
    \Se a função falhar, o valor de retorno é zero e o conteúdo de lpFindFileData é indeterminado.
  Se o número não for 0, ajuste o item; saia.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindClose" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-findclose
  \Fecha um identificador de pesquisa de arquivo aberto pelas funções FindFirstFile, FindFirstFileEx, FindFirstFileNameW, 
  \FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW ou FindFirstStreamW.
    O número identificador deste item. [hFindFile] \ O identificador de pesquisa de arquivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.

Etapas para que se obtenha um item desde um endereço completo:
  Se o endereço completo não for endereço da pasta-format, cancele.
  Atribua o endereço completo ao endereço da pasta deste item.
  Se a categoria deste item estiver em branco, obtenha o item desde o endereço completo (pela primeira vez); saia.
  Obtenha o item (novamente).

Etapas para que se obtenha um item desde um endereço completo (pela primeira vez):
  Limpe o erro do fluxo de entrada/saída.
  Isole o endereço completo.
  Posponha "*.*" para o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindFirstFileA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-findfirstfilea
  \Pesquisa um diretório por um arquivo ou subdiretório por um nome que corresponda a um nome específico (ou nome parcial se curingas forem usados).
    O caractere inicial deste endereço completo [lpFileName] \ O diretório ou caminho e o nome do arquivo. 
    \O nome do arquivo pode incluir caracteres curinga, como por exemplo, um asterisco (*) ou um ponto de interrogação (?).
    \Este parâmetro não pode ser NULL 
    \nem pode ser uma string inválida (por exemplo, uma string vazia ou uma string sem o caractere nulo final) 
    \ nem pode terminar com uma barra invertida (\).
    \Se a string terminar com um caractere curinga, ponto (.) Ou nome de diretório, 
    \o usuário deve ter permissões de acesso à raiz e a todos os subdiretórios no caminho.
    e O endereçamento deste WIN32FINDDATA deste item [lpFindFileData] 
    \ Um ponteiro para a estrutura WIN32_FIND_DATA que recebe informações sobre um arquivo ou diretório encontrado.
    devolvendo o número identificador deste item. \
  Se o número identificador deste item for -1 [INVALID_HANDLE_VALUE], cancele.
  Ajuste o item.

Etapas para que se obtenha um mínimo múltiplo comum usando um número e um segundo número:
  Obtenha um máximo divisor comum usando o número e o segundo número.
  Call "kernel32.dll" "MulDiv" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-muldiv
  \Multiplica dois valores de 32 bits e, em seguida, divide o resultado de 64 bits por um terceiro valor de 32 bits. 
  \O resultado final é arredondado para o número inteiro mais próximo.
    O número [nNumber] \ O multiplicando.
    e O segundo número [nNumerator] \ O multiplicador.
    e O máximo divisor comum [nDenominator] \ O número pelo qual o resultado da operação de multiplicação deve ser dividido.
    devolvendo o mínimo múltiplo comum. 
    \Se a função for bem-sucedida, o valor de retorno é o resultado da multiplicação e divisão, arredondado para o número inteiro mais próximo. 
    \Se o resultado for um meio inteiro positivo (termina em 0,5), ele será arredondado para cima. 
    \Se o resultado for um meio inteiro negativo, ele será arredondado para baixo.
    \Se um ocorrer uma extrapolação de valores ou nDenominator era 0, o valor de retorno é -1.

Etapas para que se obtenha uma letra desde o alfabeto:
  Atribua a próxima letra à letra.
  Avance a próxima letra limitando-a para o 'A' maiúsculo e o Z maiúsculo.
  Adicione 1 para a próxima letra.
  Se a próxima letra for maior do que o Z maiúsculo, atribua o 'A' maiúsculo à próxima letra.

Etapas para que se obtenha um número desde a stack:
  Atribua 0 ao número.
  Obtenha um stack entry desde o stack.
  Se a stack entry for inexistente, cancele.
  Converta a string desta stack entry para o número.
  Remove a stack entry desde o stack.
  Destrua a stack entry.

Etapas para que se obtenha um offset par de números usando uma string e uma caixa e uma fonte e um alinhamento:
  Crie o número da fonte of o memory canvas usando a fonte.
  Obtenha o offset par de números usando a string e a caixa e a fonte e o alinhamento (fast).
  Destrua o número da fonte of o memory canvas.

Etapas para que se obtenha um offset par de números usando uma string e uma caixa e uma fonte e um alinhamento (fast):
  Se o alinhamento for "à esquerda", obtenha o número X deste offset par de números usando a string e a caixa (rápido - esquerda).
  Se o alinhamento for "à direita", obtenha o número X deste offset par de números usando a string e a caixa (rápido - direita).
  Se o alinhamento for "centralizado", obtenha o número X deste offset par de números usando a string e a caixa (rápido - centralizado).
  Call "gdi32.dll" "GetTextMetricsA" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-gettextmetricsa
  \A função GetTextMetrics preenche o buffer especificado com as métricas para a fonte atualmente selecionada.
    O memory canvas [hdc] \Um identificador para o contexto do dispositivo
    e O endereçamento desse TEXTMETRIC. [lptm] \Um ponteiro para a estrutura TEXTMETRIC que recebe as métricas de texto.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Adicione a altura desta caixa menos a tmHeight deste TEXTMETRIC dividido por 2 para o número Y deste offset par de números.

Etapas para que se obtenha uma position usando uma localização e uma caixa de texto:
  Se a caixa de texto for inexistente, limpe o position; saia.
  Obtenha uma linha de texto usando a localização e a caixa de texto.
  Atribua o número da linha desta linha de texto ao número da linha desta position.
  Obtenha o número de coluna desta position usando a linha de texto e a localização e a caixa de texto.

Etapas para que se obtenha um ponteiro RGB desde um BitmapData sob um número da linha e um número de coluna:
  \ 1 based
  Atribua o scan0 deste BitmapData ao ponteiro RGB.
  Adicione o número da linha menos 1 times o stride deste BitmapData para o ponteiro RGB.
  Adicione o número de coluna menos 1 times a magnitude desse espaço de cor RGB para o ponteiro RGB.

Etapas para que se obtenha um deslocamento vertical e um deslocamento horizontal usando uma orientação: \deslocamento horizontal e vertical ou distância e altitude
  \ Consulte https://pt.wikipedia.org/wiki/Trigonometria_racional  
  \ A trigonometria racional evita o uso direto de funções transcendentes, como seno e cosseno, substituindo-as por seus equivalentes quadráticos.
  Isole a orientação.
  Normalize a orientação.
  Normalize o original orientação.
  Se a orientação não for uniformemente divisível por 20, estime o deslocamento vertical e o deslocamento horizontal usando a orientação; saia.
  \ special cases
  Se a orientação for 0, atribua -10000 ao deslocamento vertical; atribua -0 ao deslocamento horizontal; saia. \ 0 graus
  Se a orientação for 960, atribua 10000 ao deslocamento horizontal; atribua -0 ao deslocamento vertical; saia. \ 90 graus
  Se a orientação for 1920, atribua 10000 ao deslocamento vertical; atribua 0 ao deslocamento horizontal; saia. \ 180 graus
  Se a orientação for 2880, atribua -10000 ao deslocamento horizontal; atribua 0 ao deslocamento vertical; saia. \ 270 graus
  Se a orientação for 3840, produza o relatório de informações usando "orientação inválida"; produza o relatório de informações usando a orientação; produza o relatório de informações usando o original orientação.
  \ force it ao first eighth of o círculo
  Obtenha o first-eighth equivalent of a orientação.
  \ encontre o first eighth of o círculo unsigned values
  Se a orientação for 20, atribua 0327 ao deslocamento horizontal; atribua 9995 ao deslocamento vertical; pare. \ 1.875 degrees
  Se a orientação for 40, atribua 0654 ao deslocamento horizontal; atribua 9979 ao deslocamento vertical; pare. \ 3.75 degrees
  Se a orientação for 60, atribua 0980 ao deslocamento horizontal; atribua 9952 ao deslocamento vertical; pare. \ 5.625 degrees = 1/64 of o caminho
  Se a orientação for 80, atribua 1305 ao deslocamento horizontal; atribua 9914 ao deslocamento vertical; pare. \7.5 degrees
  Se a orientação for 100, atribua 1629 ao deslocamento horizontal; atribua 9866 ao deslocamento vertical; pare. \ 9.375 degrees
  Se a orientação for 120, atribua 1951 ao deslocamento horizontal; atribua 9808 ao deslocamento vertical; pare. \ 11.25 degrees = 2/64 of o caminho
  Se a orientação for 140, atribua 2271 ao deslocamento horizontal; atribua 9739 ao deslocamento vertical; pare. \ 13.125 degrees
  Se a orientação for 160, atribua 2588 ao deslocamento horizontal; atribua 9659 ao deslocamento vertical; pare. \ 15 degrees
  Se a orientação for 180, atribua 2903 ao deslocamento horizontal; atribua 9569 ao deslocamento vertical; pare. \ 16.875 degrees = 3/64 of o caminho
  Se a orientação for 200, atribua 3214 ao deslocamento horizontal; atribua 9469 ao deslocamento vertical; pare. \ 18.75 degrees
  Se a orientação for 220, atribua 3523 ao deslocamento horizontal; atribua 9359 ao deslocamento vertical; pare. \ 20.625 degrees
  Se a orientação for 240, atribua 3827 ao deslocamento horizontal; atribua 9239 ao deslocamento vertical; pare. \ 22.5 degrees = 4/64 of o caminho
  Se a orientação for 260, atribua 4127 ao deslocamento horizontal; atribua 9109 ao deslocamento vertical; pare. \ 24.375 degrees
  Se a orientação for 280, atribua 4423 ao deslocamento horizontal; atribua 8969 ao deslocamento vertical; pare. \ 26.25 degrees
  Se a orientação for 300, atribua 4714 ao deslocamento horizontal; atribua 8819 ao deslocamento vertical; pare. \ 28.125 degrees = 5/64 of o caminho
  Se a orientação for 320, atribua 5000 ao deslocamento horizontal; atribua 8660 ao deslocamento vertical; pare. \ 30 degrees
  Se a orientação for 340, atribua 5281 ao deslocamento horizontal; atribua 8492 ao deslocamento vertical; pare. \ 31.875 degrees
  Se a orientação for 360, atribua 5556 ao deslocamento horizontal; atribua 8315 ao deslocamento vertical; pare. \ 33.75 degrees = 6/64 of o caminho
  Se a orientação for 380, atribua 5825 ao deslocamento horizontal; atribua 8128 ao deslocamento vertical; pare. \ 35.625 degrees
  Se a orientação for 400, atribua 6088 ao deslocamento horizontal; atribua 7934 ao deslocamento vertical; pare. \ 37.5 degrees
  Se a orientação for 420, atribua 6344 ao deslocamento horizontal; atribua 7730 ao deslocamento vertical; pare. \ 39.375 degrees = 7/64 of o caminho
  Se a orientação for 440, atribua 6593 ao deslocamento horizontal; atribua 7518 ao deslocamento vertical; pare. \ 41.25 degrees
  Se a orientação for 460, atribua 6836 ao deslocamento horizontal; atribua 7299 ao deslocamento vertical; pare. \ 43.125 degrees
  Se a orientação for 480, atribua 7071 ao deslocamento horizontal; atribua 7071 ao deslocamento vertical; pare. \ 45 degrees = 8/64 of o caminho
  Recomece. [percorra novamente o código acima] \ não é realmente um comando de repetição, é apenas um marcador para as "breaks" aí de cima.
  \ ajuste por segunda eighths of o círculo
  Se o original orientação estiver entre 0 e 480, negate o deslocamento vertical; saia. \ 1st eighth (12:00 para 1:30)
  Se o original orientação estiver entre 480 e 960, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento vertical; saia. \ 2nd eighth (1:30 para 3:00)
  Se o original orientação estiver entre 960 e 1440, permute o deslocamento horizontal com o deslocamento vertical; saia. \ 3rd eighth (3:00 para 4:30)
  Se o original orientação estiver entre 1440 e 1920, cancele. \ 4th eighth (4:30 para 6:00)
  Se o original orientação estiver entre 1920 e 2400, negate o deslocamento horizontal; saia. \ 5th eighth (6:00 para 7:30)
  Se o original orientação estiver entre 2400 e 2880, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; saia. \ 6th eighth (7:30 para 9:00)
  Se o original orientação estiver entre 2880 e 3360, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; negate o deslocamento vertical; saia. \ 7th eighth (9:00 para 10:30)
  Se o original orientação estiver entre 3360 e 3840, negate o deslocamento horizontal; negate o deslocamento vertical; saia. \ 8th eighth (10:30 para 12:00)

Etapas para que se obtenha uma linha de texto usando um número da linha e uma caixa de texto:
  Esvazie a linha de texto.
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha a linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se o número da linha desta linha de texto for o número da linha, cancele.
  Recomece. [percorra novamente o código acima]

Etapas para que se obtenha uma linha de texto usando uma localização e uma caixa de texto:
  Se a caixa de texto for inexistente, esvazie a linha de texto; saia.
  Atribua a coordenada Y desta localização a uma coordenada Y.
  Limite a coordenada Y para a coordenada Y do canto superior esquerdo desta caixa de texto e a coordenada Y do canto inferior direito desta caixa de texto.
  Atribua a coordenada Y menos a coordenada Y desta globalized origem desta caixa de texto dividido pela altura da linha desta caixa de texto mais 1 a um número da linha.
  Limite o número da linha para 1 e a contagem de linhas desta caixa de texto.
  Obtenha a linha de texto usando o número da linha e a caixa de texto.

Etapas para que se obtenha uma caixa de seleção usando uma linha de texto e uma caixa de texto:
  Limpe a caixa de seleção.
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Obtenha uma caixa usando a linha de texto e a caixa de texto.
  Atribua a caixa ao caixa de seleção.
  Obtenha a caixa de seleção usando a linha de texto e a caixa de texto (lado esquerdo).
  Obtenha a caixa de seleção usando a linha de texto e a caixa de texto (lado direito).

Etapas para que se obtenha uma caixa de seleção usando uma linha de texto e uma caixa de texto (lado esquerdo):
  Atribua a normalized seleção desta caixa de texto a uma seleção.
  Atribua a coordenada X desta globalized origem desta caixa de texto à coordenada X do canto superior esquerdo desta caixa de seleção.
  Se o anchor número da linha desta seleção for o número da linha desta linha de texto, obtenha uma localização usando o anchor desta seleção e a caixa de texto; atribua a coordenada X desta localização à coordenada X do canto superior esquerdo desta caixa de seleção.
  Limite a coordenada X do canto superior esquerdo desta caixa de seleção para a coordenada X do canto superior esquerdo desta caixa de texto e a coordenada X do canto inferior direito desta caixa de texto.

Etapas para que se obtenha uma caixa de seleção usando uma linha de texto e uma caixa de texto (lado direito):
  Atribua a normalized seleção desta caixa de texto a uma seleção.
  Atribua a coordenada X do canto inferior direito desta caixa de texto à coordenada X do canto inferior direito desta caixa de seleção.
  Se o número de linhas do cursor desta seleção for o número da linha desta linha de texto, obtenha uma localização usando o cursor de texto desta seleção e a caixa de texto; atribua a coordenada X desta localização à coordenada X do canto inferior direito desta caixa de seleção.
  Limite a coordenada X do canto inferior direito desta caixa de seleção para a coordenada X do canto superior esquerdo desta caixa de texto e a coordenada X do canto inferior direito desta caixa de texto.

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, obtenha o size usando o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo for file-format, obtenha o size usando o endereço completo no sistema de arquivos (arquivo).

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos (pasta)[endereço]:
  Atribua 0 ao size.
  Comece. [a executar o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for encontrado, cancele.
    Se a categoria deste item for "arquivo", adicione o size deste item para o size; recomece.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Obtenha uma segunda size usando a segunda endereço completo no sistema de arquivos.
    Adicione a segunda size para o size.
  Recomece. [percorra novamente o código acima]

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesExA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-getfileattributesexa
  \Recupera atributos de um arquivo ou de um diretório especificado.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo ou diretório.
    e 0 [fInfoLevelId] \Uma classe de informações de atributos a serem recuperadas.
    \Este parâmetro aceita os valores da enumeração GET_FILEEX_INFO_LEVELS. https://docs.microsoft.com/pt-br/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels
    \Se fInfoLevelId for GetFileExInfoStandard ele representa uma estrutura WIN32_FILE_ATTRIBUTE_DATA.
    \https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/ns-fileapi-win32_file_attribute_data
    e O endereçamento desse WIN32FINDDATA. [lpFileInformation] \Um ponteiro para um buffer que recebe as informações do atributo.
   \O tipo de informações de atributo armazenadas neste buffer é determinado pelo valor de fInfoLevelId.
  Atribua o nFileSizeLow deste WIN32FINDDATA ao size.

Etapas para que se obtenha um sockaddr usando um host string:
  Limpe o erro do fluxo de entrada/saída.
  \ prepare strings
  Isole o host string.
  Anexe o caractere NULL o host string.
  \ obtenha o function addresses
  Obtenha uns addrinfo routines.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  \ obtenha o sockaddr
  Atribua 2 [AF_INET] ao ai_family desse addrinfo. \A família de endereços do protocolo da Internet versão 4 (IPv4).
  Atribua 1 [SOCK_STREAM] ao ai_sockettype deste addrinfo. 
  \\Fornece fluxos de bytes sequenciados, confiáveis, bidirecionais e baseados em conexão com um mecanismo de transmissão de dados OOB. 
  \Usa o Transmission Control Protocol (TCP) para a família de endereços da Internet (AF_INET ou AF_INET6).
  Atribua 6 [IPPROTO_TCP] ao ai_protocol deste addrinfo. \O protocolo de controle de transmissão (TCP). 
  \Este é um valor possível quando o membro ai_family é AF_INET ou AF_INET6 e o ??membro ai_socktype é SOCK_STREAM.
  Call o getaddrinfo destas addrinfo routines com 
    O caractere inicial desta host string 
    e 0 e o endereçamento deste addrinfo
   e o endereçamento desse addrinfoptr 
     devolvendo um número resultante.
  Se o número resultante não for 0, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; saia.
  Se o addrinfoptr for inexistente, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; saia.
  Atribua o conteúdo deste ai_addr deste addrinfoptr ao sockaddr.
  Call o freeaddrinfo destas addrinfo routines com o addrinfoptr.

Etapas para que se obtenha uma localização usando uma position e uma caixa de texto:
  Limpe a localização.
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número da linha desta position e a caixa de texto.
  Obtenha uma caixa usando a linha de texto e a caixa de texto.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização.
  Atribua o caractere inicial desta string desta linha de texto ao caractere inicial desse subtexto.
  Atribua o caractere inicial deste subtexto mais o número de coluna desta position menos 2 ao caractere final deste subtexto.
  Obtenha uma largura usando o subtexto e o memory canvas e a fonte desta caixa de texto.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais a largura à coordenada X desta localização.
  Obtenha um offset par de números usando o working string desta linha de texto e a caixa e a fonte desta caixa de texto e o alinhamento desta caixa de texto.
  Adicione o número X deste offset par de números para a coordenada X desta localização.

Etapas para que se obtenha um start largura e um subtexto usando uma linha de texto e uma localização e uma caixa de texto (for "get um número de coluna usando uma linha de texto..."):
  Limpe o start largura.
  Limpe o subtexto.
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Obtenha uma caixa usando a linha de texto e a caixa de texto.
  Lance o subtexto sobre o working string desta linha de texto.
  Obtenha um offset par de números usando o subtexto e a caixa e a fonte desta caixa de texto e o alinhamento desta caixa de texto (fast).
  Atribua a coordenada X desta globalized origem desta caixa de texto mais o número X deste offset par de números ao start largura.
  Atribua o caractere inicial deste subtexto mais a caixa de texto cutoff menos 1 ao caractere final deste subtexto.
  Comece. [a executar o código abaixo]
    Se o caractere final deste subtexto for maior do que ou igual ao caractere final desta string desta linha de texto, pare.
    Obtenha uma largura usando o subtexto e o memory canvas.
    Atribua o start largura mais a largura a uma segunda largura.
    Se a coordenada X desta localização for menor do que ou igual ao segunda largura, pare.
    Adicione a largura para o start largura.
    Mova o subtexto usando a caixa de texto cutoff.
  Recomece. [percorra novamente o código acima]
  Atribua o caractere inicial deste subtexto ao caractere final deste subtexto.

Etapas para que se obtenha uma string desde o stack:
  Limpe a string.
  Obtenha um stack entry desde o stack.
  Se o stack entry for inexistente, atribua "ERRO" à string; saia.
  Atribua a string desta stack entry para a string.
  Remove o stack entry desde o stack.
  Destrua o stack entry.

Etapas para que se obtenha uma string desde a área de transferência do Windows:
  Limpe a string.
  Call "user32.dll" "OpenClipboard" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-openclipboard
  \Abre a área de transferência para exame e impede que outros aplicativos modifiquem o conteúdo da área de transferência.
    A janela principal do programa. [hWndNewOwner] \Um identificador para a janela a ser associada à área de transferência aberta. 
    \Se este parâmetro for NULL, a área de transferência aberta será associada à tarefa atual.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
    \O OpenClipboard falhará se outra janela estiver com a área de transferência aberta.
    \Um aplicativo deve chamar a função CloseClipboard após cada chamada bem-sucedida para OpenClipboard.
  Call "user32.dll" "GetClipboardData" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getclipboarddata
  \Recupera dados da área de transferência em um formato especificado. A área de transferência deve ter sido aberta anteriormente.
  1 [uFormat = CF_TEXT] \Um formato de área de transferência. 
  \Para obter uma descrição dos formatos padrão da área de transferência, consulte
  \ https://docs.microsoft.com/pt-br/windows/desktop/dataxchg/clipboard-formats
    devolvendo um número identificador. 
    \Se a função for bem-sucedida, o valor de retorno será o identificador para um objeto da área de transferência no formato especificado.
    \Se a função falhar, o valor de retorno será NULL.
  Se o número identificador for 0, Call "user32.dll" "CloseClipboard"; saia.
  \CloseClipboard fecha a área de transferência. Isso permite que outras janelas acessem a área de transferência.
  Call "kernel32.dll" "GlobalLock" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globallock
    \Bloqueia um objeto de memória global e retorna um ponteiro para o primeiro byte do bloco de memória do objeto.
    \Observação: As funções globais têm maior sobrecarga e fornecem menos recursos do que outras funções de gerenciamento de memória. 
    \Novos aplicativos devem usar as funções de heap, a menos que a documentação indique que uma função global deve ser usada.
    O número identificador  [hMem] \Um identificador para o objeto de memória global. 
    devolvendo um endereçamento de caractere. \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o primeiro byte do bloco de memória.
    \Se a função falhar, o valor de retorno será NULL.
  Converta o endereçamento de caractere para a string.
  Call "kernel32.dll" "GlobalUnlock" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globalunlock
    \Diminui a contagem de bloqueios associada a um objeto de memória que foi alocado com GMEM_MOVEABLE. 
    \Esta função não tem efeito em objetos de memória alocados com GMEM_FIXED.
    O número identificador. [hMem] \Um identificador para o objeto de memória global
  Call "user32.dll" "CloseClipboard".  \CloseClipboard fecha a área de transferência. Isso permite que outras janelas acessem a área de transferência.

Etapas para que se obtenha uma coisa desde umas coisas:
  Se  as coisas estiverem vazias, esvazie a coisa; saia.
  Se a coisa for inexistente, atribua a first coisa destas coisas à coisa; saia.
  Atribua o next coisa desta coisa à coisa.

Etapas para que se obtenha uma coisa desde umas coisas (backwards):
  Se  as coisas estiverem vazias, esvazie a coisa; saia.
  Se a coisa for inexistente, atribua a last coisa destas coisas à coisa; saia.
  Atribua o previous coisa desta coisa à coisa.

Etapas para que se obtenha um segmento inicial desde um texto retornado:
  Remove algum tipo de leading noise desde o texto retornado.
  Limpe o segmento inicial.
  Comece. [a executar o código abaixo]
    Se o texto retornado estiver em branco, cancele.
    Obtenha um byte desde o texto retornado.
    Se o byte for o caractere de espaço, cancele.
    Posponha o byte para o segmento inicial.
  Recomece. [percorra novamente o código acima]

Etapas para que se obtenha uma largura usando um byte e um canvas:
  Call "gdi32.dll" "GetTextExtentPoint32A" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-gettextextentpoint32a
  \A função GetTextExtentPoint32 calcula a largura e a altura da seqüência de caracteres de texto especificada.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O endereçamento deste byte [lpString] \ Um ponteiro para um buffer que especifica a string de texto. 
    \A string não precisa ter terminação nula, porque o parâmetro c especifica o comprimento da string.
    e 1 [c] \ O comprimento da string apontada por lpString.
    \ https://docs.microsoft.com/pt-br/windows/win32/gdi/specifying-length-of-caixa de texto-output-string
    e O endereçamento desse par de números. [psizl] \ Um ponteiro para uma estrutura SIZE que recebe as dimensões da string, em unidades lógicas.
    \A estrutura SIZE especifica a largura e a altura de um retângulo.
    \ https://docs.microsoft.com/pt-br/previous-versions/dd145106(v=vs.85)
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
  Atribua o número X deste par de números à largura.

Etapas para que se obtenha uma largura usando um byte e uns fonte larguras:
  Atribua o byte a um número.
  Obtenha a largura usando o número e a fonte larguras.

Etapas para que se obtenha uma largura usando um número e uns fonte larguras:
  \ indexes são 0 based
  Se a fonte larguras são nil, limpe a largura; saia.
  Atribua o data destes fonte larguras a um endereço numérico.
  Adicione o número times a magnitude deste número para o endereço numérico.
  Atribua o conteúdo deste endereço numérico ao largura.

Etapas para que se obtenha uma largura usando uma string e um canvas:
  \ presume que a fonte já esteja selecionada no canvas
  Call "gdi32.dll" "GetTextExtentPoint32A" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-gettextextentpoint32a
  \A função GetTextExtentPoint32 calcula a largura e a altura da seqüência de caracteres de texto especificada.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O caractere inicial desta string [lpString] \ Um ponteiro para um buffer que especifica a string de texto. 
    \A string não precisa ter terminação nula, porque o parâmetro c especifica o comprimento da string.
    e A quantidade de caracteres desta string [c] \ O comprimento da string apontada por lpString.
    \ https://docs.microsoft.com/pt-br/windows/win32/gdi/specifying-length-of-caixa de texto-output-string
    e O endereçamento desse par de números. [psizl] \ Um ponteiro para uma estrutura SIZE que recebe as dimensões da string, em unidades lógicas.
    \A estrutura SIZE especifica a largura e a altura de um retângulo.
    \ https://docs.microsoft.com/pt-br/previous-versions/dd145106(v=vs.85)
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
  Atribua o número X deste par de números ao largura.

Etapas para que se obtenha uma largura usando uma string e um canvas e uma fonte:
  Crie o número da fonte of o canvas usando a fonte.
  Obtenha a largura usando a string e o canvas.
  Destrua o número da fonte of o canvas.

Etapas para que se obtenha uma largura usando uma string e uma fonte:
  \ assumes memory canvas
  Obtenha a largura usando a string e o memory canvas e a fonte.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (rápido - centralizado):
  Obtenha uma largura usando a string e o memory canvas.
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Atribua a largura menos o abcA menos o abcC ao largura.
  Atribua a largura desta caixa menos a largura dividido por 2 menos o abcA à coordenada X.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (rápido - esquerda):
  Obtenha um abcA usando a string e o memory canvas.
  Atribua - o abcA à coordenada X.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (rápido - direita):
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Obtenha uma largura usando a string e o memory canvas.
  Atribua a largura menos o abcA menos o abcC ao largura.
  Atribua a largura desta caixa menos a largura menos o abcA à coordenada X.

Um gigabyte é 1024 megabytes.

Etapas para que se globalize uma caixa usando um par de números:
  Mova a caixa usando o par de números.

Etapas para que se globalize uma localização usando um par de números:
  Mova a localização usando o par de números.

Etapas para que se go back para where we were:
  Restaure o contexto.

Um GpBitmap é um GpImage.

Um GpGraphic é um ponteiro.

Um GpImage é um ponteiro.

Um GpRect é um conjunto com
  Um número denominado x,
  Um número denominado y,
  Um número denominado largura,
  Um número denominado altura.

O gpToken é um gpToken.

Um gpToken é um número.

Uma malha é um par de números.

Etapas para que se garanta one linha de texto em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se as linhas des textos desta caixa de texto não estiverem vazias, cancele.
  Crie uma linha de texto usando o retorno de carro.
  Posponha a linha de texto para as linhas des textos desta caixa de texto.
  Renumere as linhas des textos desta caixa de texto.

Um GUID é um UUID. \ identificador único global
\Um GUID identifica um objeto, como interfaces COM, um objeto de classe COM ou um vetor de ponto de entrada do gerenciador (EPV). 
\Um GUID é um valor de 128 bits que consiste em 
\um grupo de 8 dígitos hexadecimais, 
\seguido por três grupos de 4 dígitos hexadecimais cada, 
\seguido por um grupo de 12 dígitos hexadecimais. 
\O seguinte GUID de exemplo mostra os agrupamentos de dígitos hexadecimais em um GUID: 6B29FC40-CA47-1067-B31D-00DD010662DA.
\A estrutura GUID armazena um GUID.

O hand cursor é um cursor.

Etapas para que se mude alinhamento usando uma caixa de texto e um alinhamento:
  Se a caixa de texto for inexistente, cancele.
  Relembre a caixa de texto com "alinhamento".
  Alinhe a caixa de texto usando o alinhamento.

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam:
  Separe o wParam a um word e uma segunda word.
  Atribua a segunda word a um número.
  Se o número for 0, execute algum tipo de WM_ACTIVATE com o wParam (deactivate); saia.
  Execute algum tipo de WM_ACTIVATE com o wParam (activate).

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam (activate):
  Call "user32.dll" "SetFocus" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-setfocus
  \Define o foco do teclado para a janela especificada. A janela deve ser anexada à fila de mensagens do segmento de chamada.
    A janela principal do programa.[hWnd] \Um identificador para a janela que receberá a entrada do teclado. 
    \Se este parâmetro for NULL, os pressionamentos de tecla serão ignorados.
    \Se a função for bem-sucedida, o valor de retorno é o identificador para a janela que anteriormente tinha o foco do teclado. 
    \Se o parâmetro hWnd for inválido ou a janela não estiver anexada à fila de mensagens do thread de chamada, o valor de retorno será NULL.
  Call "user32.dll" "ClipCursor" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-clipcursor
  \Limita o cursor a uma área retangular na tela. 
  \Se uma posição subsequente do cursor (definida pela função SetCursorPos ou pelo mouse) ficar fora do retângulo, 
  \o sistema ajusta automaticamente a posição para manter o cursor dentro da área retangular.
  0. [*lpRect] \Um ponteiro para a estrutura que contém as coordenadas da tela dos cantos superior esquerdo e inferior direito do retângulo de confinamento. 
  \Se este parâmetro for NULL, o cursor ficará livre para se mover em qualquer lugar da tela.
  \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
  \ seterrormode(sem_failcriticalerrors) \ keeps certain disk erros desde appearing
  \https://docs.microsoft.com/pt-br/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode
  \Função SetErrorMode Controla se o sistema tratará os tipos especificados de erros graves ou se o processo os tratará.
  \SEM_FAILCRITICALERRORS 0x0001 = O sistema não exibe a caixa de mensagem do manipulador de erros críticos. 
  \Em vez disso, o sistema envia o erro para o processo de chamada.
  \A prática recomendada é que todos os aplicativos chamem a função SetErrorMode de todo o processo com um parâmetro SEM_FAILCRITICALERRORS na inicialização. 
  \Isso evita que os diálogos do modo de erro travem o aplicativo.
  Crie um evento.
  Atribua "activate" à categoria deste evento. \pode ser traduzido
  Enfileire o evento.
  Call "user32.dll" "PostMessageA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-postmessagea
  \Coloca (posta) uma mensagem na fila de mensagens 
  \associada ao encadeamento que criou a janela especificada e retorna sem esperar que o encadeamento processe a mensagem.
    A janela principal do programa [hWnd] \Um identificador para a janela cujo procedimento de janela é para receber a mensagem.
    e 0 [Msg = WM_NULL]  \A mensagem a ser postada. WM_NULL Não executa nenhuma operação. 
    \Um aplicativo envia a mensagem WM_NULL se quiser postar uma mensagem que a janela do destinatário irá ignorar.
    \Uma janela recebe essa mensagem por meio de sua função WindowProc.
    e 0 [wParam] \Informações adicionais específicas da mensagem.
    e 0. [lParam] \Informações adicionais específicas da mensagem.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam (deactivate):
  Crie um evento.
  Atribua "deactivate" à categoria deste evento. \pode ser traduzido
  Enfileire o evento.
  Call "user32.dll" "PostMessageA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-postmessagea
  \Coloca (posta) uma mensagem na fila de mensagens 
  \associada ao encadeamento que criou a janela especificada e retorna sem esperar que o encadeamento processe a mensagem.
    A janela principal do programa [hWnd] \Um identificador para a janela cujo procedimento de janela é para receber a mensagem.
    e 0 [Msg = WM_NULL]  \A mensagem a ser postada. WM_NULL Não executa nenhuma operação. 
    \Um aplicativo envia a mensagem WM_NULL se quiser postar uma mensagem que a janela do destinatário irá ignorar.
    \Uma janela recebe essa mensagem por meio de sua função WindowProc.
    e 0 [wParam] \Informações adicionais específicas da mensagem.
    e 0. [lParam] \Informações adicionais específicas da mensagem.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.

Etapas para que se execute algum tipo de WM_CHAR com um wParam e um lParam:
  \Se a tecla Alt está para baixo, cancele. \ removed por Spanish teclado AltGr e ctrl+alt characters
  \Se a tecla Ctrl está para baixo, cancele. \ removed por Spanish teclado AltGr e ctrl+alt characters
  Atribua o wParam a um byte.
  Se o byte não for imprimível, cancele.
  Crie um evento.
  Atribua "pressionamento de tecla" à categoria deste evento. \traduzido
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste evento.
  Atribua o byte ao byte deste evento.
  Converta o lParam para a tecla deste evento.
  Enfileire o evento.

Etapas para que se execute algum tipo de WM_CREATE com um janela do programa:
  Atribua a janela do programa à janela principal do programa.

Etapas para que se execute algum tipo de WM_DESTROY:
  Call "user32.dll" "PostQuitMessage" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-postquitmessage
  \Indica ao sistema que um thread fez uma solicitação para encerrar (sair). 
  \Normalmente é usado em resposta a uma mensagem WM_DESTROY.
  \ https://docs.microsoft.com/pt-br/windows/win32/winmsg/wm-destroy
  0. [nExitCode] \ O código de saída do aplicativo. Este valor é usado como o parâmetro wParam da mensagem WM_QUIT.
  \ https://docs.microsoft.com/pt-br/windows/win32/winmsg/wm-quit
  

Etapas para que se execute algum tipo de WM_LBUTTONDBLCLK com um lParam:
  Crie um evento.
  Atribua "clique duplo" à categoria deste evento. \traduzido
  Se a tecla Alt estiver para baixo, acione o detector de tecla Alt deste evento.
  Se a tecla Ctrl estiver para baixo, acione o detector de tecla Ctrl deste evento.
  Se a tecla Shift estiver para baixo, acione o detector de tecla Shift deste evento.
  Converta o lParam para a localização deste evento.
  Enfileire o evento.

Etapas para que se execute algum tipo de WM_LBUTTONDOWN com um lParam:
  Crie um evento.
  Atribua "clique" à categoria deste evento. \traduzido
  Se a tecla Alt estiver para baixo, acione o detector de tecla Alt deste evento.
  Se a tecla Ctrl estiver para baixo, acione o detector de tecla Ctrl deste evento.
  Se a tecla Shift estiver para baixo, acione o detector de tecla Shift deste evento.
  Converta o lParam para a localização deste evento.
  Enfileire o evento.

Etapas para que se execute algum tipo de WM_PAINT com um janela do programa:
  Call "user32.dll" "BeginPaint" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-beginpaint
  \ A função BeginPaint prepara a janela especificada para pintura e preenche uma estrutura PAINTSTRUCT com informações sobre a pintura.
    A janela do programa [hWnd] \Um número identificador para a janela a ser repintada.
    e O endereçamento desse paintstruct.[lpPaint] \Pointer to the PAINTSTRUCT structure that will receive painting information.
    \https://docs.microsoft.com/pt-br/windows/win32/api/winuser/ns-winuser-paintstruct
    \Se a função for bem-sucedida, o valor de retorno é o identificador para um contexto de dispositivo de exibição para a janela especificada.
    \Se a função falhar, o valor de retorno é NULL, indicando que nenhum contexto de dispositivo de exibição está disponível.
  Call "user32.dll" "EndPaint" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-endpaint
  \A função EndPaint marca o fim da pintura na janela especificada. 
  \Esta função é necessária para cada chamada à função BeginPaint, mas somente após a conclusão da pintura.
    A janela do programa [hWnd] \número identificador para a janela que foi repintada.
    e O endereçamento desta paintstruct. [*lpPaint] \Ponteiro para uma estrutura PAINTSTRUCT que contém as informações de pintura recuperadas por BeginPaint.
    \O valor de retorno é sempre diferente de zero.
  Crie um evento.
  Atribua "atualização de tela" à categoria deste evento.
  Enfileire o evento.

Etapas para que se execute algum tipo de WM_RBUTTONDBLCLK com um lParam:
  Crie um evento.
  Atribua "clique direito duplo" à categoria deste evento.
  Se a tecla Alt está para baixo, acione o detector de tecla Alt deste evento.
  Se a tecla Ctrl está para baixo, acione o detector de tecla Ctrl deste evento.
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste evento.
  Converta o lParam para a localização deste evento.
  Enfileire o evento.

Etapas para que se execute algum tipo de WM_RBUTTONDOWN com um lParam:
  Crie um evento.
  Atribua "clique direito" à categoria deste evento.
  Se a tecla Alt está para baixo, acione o detector de tecla Alt deste evento.
  Se a tecla Ctrl está para baixo, acione o detector de tecla Ctrl deste evento.
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste evento.
  Converta o lParam para a localização deste evento.
  Enfileire o evento.

Etapas para que se execute algum tipo de WM_SETCURSOR:
  Atualize o cursor.

Etapas para que se execute algum tipo de WM_SYSKEYDOWN com um wParam e um lParam;
Etapas para que se execute algum tipo de WM_KEYDOWN com um wParam e um lParam:
  Atribua o wParam a um tecla.
  Se a tecla com o lParam é alguma tecla de cancelamento ou tecla modificadora, cancele.
  Se a tecla for algum tipo de WM_CHAR tecla, cancele.
  Crie um evento.
  Atribua "pressionamento de tecla" à categoria deste evento.
  Se a tecla Alt está para baixo, acione o detector de tecla Alt deste evento.
  Se a tecla Ctrl está para baixo, acione o detector de tecla Ctrl deste evento.
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste evento.
  Atribua a tecla à tecla deste evento.
  Enfileire o evento.

Etapas para que se execute capitalize usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Relembre a caixa de texto com "capitalize".
  Capitalize algum tipo de linhas des textos selecionadas na caixa de texto.
  Square para cima algum tipo de seleção na caixa de texto.
  Wrap a caixa de texto.

Etapas para que se efetue cópias usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Extraia uma string desde a caixa de texto (trecho selecionado).
  Atribua a string sobre a área de transferência do Windows.

Etapas para que se execute cut usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Relembre a caixa de texto.
  Extraia uma string desde a caixa de texto (trecho selecionado).
  Atribua a string sobre a área de transferência do Windows.
  Remove qualquer trecho selecionado na caixa de texto.
  Wrap a caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando um console:
  Se o console for inexistente, cancele. \não falta o clique normal aqui?
  Se a categoria deste evento for "pressionamento de tecla", execute o evento usando o console (pressionamento de tecla); saia.
  Se a categoria deste evento for "atualização de tela", execute o evento usando o console (atualização de tela); saia.
  Se a categoria deste evento for "clique direito", execute o evento usando o console (clique direito); saia.
  Se a categoria deste evento for "mostrar seta", execute o evento usando o console (mostrar seta do mouse); saia.

Etapas para que se execute um evento usando um console (tecla backspace):
  Se o texto retornado deste console estiver em branco, cancele.
  Se o evento foi alterado, cancele.
  Execute o evento usando a caixa de texto deste console (tecla backspace).
  Remove o last byte desde o texto retornado deste console.
  Mostre o console.

Etapas para que se execute um evento usando um console (seta pra baixo):
  Role a caixa de texto deste console para baixo one linha reta.
  Mostre o console.

Etapas para que se execute um evento usando um console (tecla End):
  Role a caixa de texto deste console para o base.
  Mostre o console.

Etapas para que se execute um evento usando um console (tecla Enter):
  Execute o evento usando a caixa de texto deste console (tecla Enter).
  Relinquish control.

Etapas para que se execute um evento usando um console (tecla Home):
  Role a caixa de texto deste console para o topo.
  Mostre o console.

Etapas para que se execute um evento usando um console (pressionamento de tecla):
  Se a tecla deste evento for a tecla backspace, execute o evento usando o console (tecla backspace); saia.
  Se a tecla deste evento for a seta pra baixo, execute o evento usando o console (seta pra baixo); saia.
  Se a tecla deste evento for a tecla End, execute o evento usando o console (tecla End); saia.
  Se a tecla deste evento for a tecla Enter, execute o evento usando o console (tecla Enter); saia.
  Se a tecla deste evento for a tecla Home, execute o evento usando o console (tecla Home); saia.
  Se a tecla deste evento for a tecla PgDn, execute o evento usando o console (tecla Page Down); saia.
  Se a tecla deste evento for a tecla PgUp, execute o evento usando o console (tecla Page Up); saia.
  Se a tecla deste evento for a seta pra cima, execute o evento usando o console (seta pra cima); saia.
  Se o byte deste evento não for imprimível, cancele.
  Posponha o byte deste evento para o texto retornado deste console.
  Execute o evento usando a caixa de texto deste console (caracteres gráficos).
  Mostre o console.

Etapas para que se execute um evento usando um console (tecla Page Down):
  Role a caixa de texto deste console para baixo one página.
  Mostre o console.

Etapas para que se execute um evento usando um console (tecla Page Up):
  Role a caixa de texto deste console para cima one página.
  Mostre o console.

Etapas para que se execute um evento usando um console (atualização de tela):
  Mostre o console.

Etapas para que se execute um evento usando um console (clique direito):
  Mostre o hand cursor.
  Role o console usando o evento.
  Atualize o cursor.

Etapas para que se execute um evento usando um console (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas para que se execute um evento usando um console (seta pra cima):
  Role a caixa de texto deste console para cima one linha reta.
  Mostre o console.

Etapas para que se execute um evento usando um terminal:
  Se o terminal for inexistente, cancele.
  Se a categoria deste evento for "pressionamento de tecla", execute o evento usando o terminal (pressionamento de tecla); saia.
  Se a categoria deste evento for "atualização de tela", execute o evento usando o terminal (atualização de tela); saia.
  Se a categoria deste evento for "mostrar seta", execute o evento usando o terminal (mostrar seta do mouse); saia.
  Se a categoria deste evento for "clique", relinquish control. \ *** added por invisível turtle book questionable

Etapas para que se execute um evento usando um terminal (tecla backspace):
  Se o texto retornado deste terminal estiver em branco, cancele.
  Se o evento foi alterado, cancele.
  Remove o last byte desde o texto retornado deste terminal.
  Remove o last byte desde a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas para que se execute um evento usando um terminal (tecla Enter):
  Relinquish control. \Abdique

Etapas para que se execute um evento usando um terminal (pressionamento de tecla):
  Se a tecla deste evento for a tecla backspace, execute o evento usando o terminal (tecla backspace); saia.
  Se a tecla deste evento for a tecla Enter, execute o evento usando o terminal (tecla Enter); saia.
  Se o byte deste evento não for imprimível, cancele.
  Posponha o byte deste evento para o texto retornado deste terminal.
  Posponha o byte deste evento para a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas para que se execute um evento usando um terminal (atualização de tela):
  Mostre o terminal.

Etapas para que se execute um evento usando um terminal (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas para que se execute um evento usando uma caixa de texto (tecla backspace):
  Se a caixa de texto for inexistente, cancele.
  Se não existir something para backspace na caixa de texto, cancele.
  Relembre a caixa de texto com "backspace".
  Se o evento foi alterado, remove bytes de a caixa de texto (backspace com jump).
  Se o evento não foi alterado, remove bytes de a caixa de texto (backspace).
  Wrap a caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (tecla Delete):
  Se a caixa de texto for inexistente, cancele.
  Se não existir something para remove na caixa de texto, cancele.
  Relembre a caixa de texto com "delete".
  Se o evento foi alterado, remove bytes de a caixa de texto (forward delete com jump).
  Se o evento não foi alterado, remove bytes de a caixa de texto (forward delete).
  Wrap a caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (seta pra baixo):
  Se a caixa de texto for inexistente, cancele.
  Se o cursor de texto of a caixa de texto é sobre o last linha reta, acione um detector.
  Se o detector estiver ativo, mova o cursor de texto para o last byte of a caixa de texto.
  Se o detector não estiver ativo, mova o cursor de texto para baixo na caixa de texto.
  Se o detector de tecla Shift deste evento não estiver ativo, desvencilhe-se de a caixa de texto.
  Limpe a última operação desta caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (tecla End):
  Se a caixa de texto for inexistente, cancele.
  Se o evento foi alterado, mova o cursor de texto para o last byte of a caixa de texto.
  Se o evento não foi alterado, mova o cursor de texto para o last byte of o current linha de texto of a caixa de texto.
  Se o detector de tecla Shift deste evento não estiver ativo, desvencilhe-se de a caixa de texto.
  Limpe a última operação desta caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (tecla Enter):
  Se a caixa de texto for inexistente, cancele.
  Relembre a caixa de texto com "insert return".
  Remove qualquer trecho selecionado na caixa de texto.
  Insira o retorno de carro ao caixa de texto.
  Wrap a caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (tecla Esc):
  Se a caixa de texto for inexistente, cancele.
  Desvencilhe-se de a caixa de texto.

Etapas para que se execute um evento usando uma caixa de texto (tecla Home):
  Se a caixa de texto for inexistente, cancele.
  Se o evento foi alterado, mova o cursor de texto para o first byte of a caixa de texto.
  Se o evento não foi alterado, mova o cursor de texto para o first byte of o current linha de texto of a caixa de texto.
  Se o detector de tecla Shift deste evento não estiver ativo, desvencilhe-se de a caixa de texto.
  Limpe a última operação desta caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (clique duplo):
  Se a caixa de texto for inexistente, cancele.
  Desvencilhe-se de a caixa de texto.
  Mova o cursor de texto para a direita para algum tipo de non-alfanumérico byte na caixa de texto.
  Mova o anchor para o lado esquerdo para algum tipo de non-alfanumérico byte na caixa de texto.

Etapas para que se execute um evento usando uma caixa de texto (seta esquerda):
  Se a caixa de texto for inexistente, cancele.
  Se o evento foi alterado, jump o cursor de texto para a esquerda na caixa de texto.
  Se o evento não foi alterado, mova o cursor de texto para a esquerda na caixa de texto.
  Se o detector de tecla Shift deste evento não estiver ativo, desvencilhe-se de a caixa de texto.
  Limpe a última operação desta caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (tecla Page Down):
  Se a caixa de texto for inexistente, cancele.
  Role a caixa de texto para baixo one página.
  Mova o cursor de texto para baixo one página na caixa de texto.
  Se o detector de tecla Shift deste evento não estiver ativo, desvencilhe-se de a caixa de texto.
  Limpe a última operação desta caixa de texto.

Etapas para que se execute um evento usando uma caixa de texto (tecla Page Up):
  Se a caixa de texto for inexistente, cancele.
  Role a caixa de texto para cima one página.
  Mova o cursor de texto para cima one página na caixa de texto.
  Se o detector de tecla Shift deste evento não estiver ativo, desvencilhe-se de a caixa de texto.
  Limpe a última operação desta caixa de texto.

Etapas para que se execute um evento usando uma caixa de texto (caracteres gráficos):
  Relembre a caixa de texto com "insert".
  Remove qualquer trecho selecionado na caixa de texto.
  Insira o byte deste evento ao caixa de texto.
  Wrap a caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (seta direita):
  Se a caixa de texto for inexistente, cancele.
  Se o evento foi alterado, jump o cursor de texto para a direita na caixa de texto.
  Se o evento não foi alterado, mova o cursor de texto para a direita na caixa de texto.
  Se o detector de tecla Shift deste evento não estiver ativo, desvencilhe-se de a caixa de texto.
  Limpe a última operação desta caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (tecla Tab):
  Se a caixa de texto for inexistente, cancele.
  Relembre a caixa de texto com "insert".
  Remove qualquer trecho selecionado na caixa de texto.
  Insira o caractere de espaço ao caixa de texto.
  Divida o cursor de texto número de coluna desta caixa de texto por 2 usando um quociente e um resto.
  Se o resto for 0, insira o caractere de espaço ao caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute um evento usando uma caixa de texto (seta pra cima):
  Se a caixa de texto for inexistente, cancele.
  Mova o cursor de texto para cima na caixa de texto.
  Se o detector de tecla Shift deste evento não estiver ativo, desvencilhe-se de a caixa de texto.
  Limpe a última operação desta caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se execute eventos usando um console:
  Se o console for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Desenfileire um evento.
    Se o evento for inexistente, cancele.
    Execute o evento usando o console.
  Recomece. [percorra novamente o código acima]

Etapas para que se execute eventos usando um terminal:
  Se o terminal for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Desenfileire um evento.
    Se o evento for inexistente, cancele.
    Execute o evento usando o terminal.
  Recomece. [percorra novamente o código acima]

Etapas para que se mude tamanho usando uma caixa de texto e uma caixa e uma altura da fonte:
  Se a caixa de texto for inexistente, cancele.
  Relembre a caixa de texto com "altura da fonte".
  Mude a caixa de texto usando a caixa.
  Mude a caixa de texto usando a altura da fonte.

Etapas para que se mude tamanho usando uma caixa de texto e uma altura da fonte:
  Se a caixa de texto for inexistente, cancele.
  Relembre a caixa de texto com "altura da fonte".
  Mude a caixa de texto usando a altura da fonte.

Etapas para que se mude nome da fonte usando uma caixa de texto e uma nome da fonte:
  Se a caixa de texto for inexistente, cancele.
  Relembre a caixa de texto com "nome da fonte".
  Mude a caixa de texto usando o nome da fonte.

Etapas para que se execute indent usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Relembre a caixa de texto com "dent".
  Indent algum tipo de linhas des textos selecionadas na caixa de texto.
  Square para cima algum tipo de seleção na caixa de texto.
  Wrap a caixa de texto.

Um número identificador é um número.

Etapas para que se execute lowercase usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Relembre a caixa de texto com "case".
  Lowercase qualquer trecho selecionado na caixa de texto.
  Wrap a caixa de texto.

Etapas para que se execute outdent usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Relembre a caixa de texto com "dent".
  Outdent algum tipo de linhas des textos selecionadas na caixa de texto.
  Square para cima algum tipo de seleção na caixa de texto.
  Wrap a caixa de texto.

Etapas para que se execute paste usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se não existir caixa de texto sobre a área de transferência do Windows, cancele.
  Relembre a caixa de texto.
  Remove qualquer trecho selecionado na caixa de texto.
  Obtenha uma string desde o área de transferência do Windows.
  Insira a string ao caixa de texto.
  Wrap a caixa de texto.
  Role a caixa de texto para o cursor de texto.

Etapas para que se efetue alteração de cor usando uma caixa de texto e uma cor:
  Se a caixa de texto for inexistente, cancele.
  Relembre a caixa de texto com "pincel".
  Atribua a cor à cor do pincel desta caixa de texto.

Etapas para que se execute refeito usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se o last destes refeitos desta caixa de texto for inexistente, cancele.
  Copie a caixa de texto a um segundo caixa de texto.
  Posponha o segundo caixa de texto para os desfeitos desta caixa de texto.
  Atribua o last destes refeitos desta caixa de texto a um terceiro caixa de texto.
  Remove o terceiro caixa de texto desde os refeitos desta caixa de texto.
  Copie as propriedades of o terceiro caixa de texto para a caixa de texto.
  Destrua o terceiro caixa de texto.
  Ligue o detector de alteração desta caixa de texto.

Etapas para que se execute reverse usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Relembre a caixa de texto com "reverse".
  Reverse algum tipo de linhas des textos selecionadas of a caixa de texto.
  Square para cima algum tipo de seleção na caixa de texto.
  Wrap a caixa de texto.

Etapas para que se execute select all usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Selecione cada byte na caixa de texto.

Etapas para que se execute classifique algum tipo de linhas des textos selecionadas usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Relembre a caixa de texto com "classifique linhas des textos selecionadas".
  Classifique algum tipo de linhas des textos selecionadas na caixa de texto.
  Square para cima algum tipo de seleção na caixa de texto.
  Wrap a caixa de texto.

Etapas para que se execute desfeito usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se o last destes desfeitos desta caixa de texto for inexistente, cancele.
  Copie a caixa de texto a um segundo caixa de texto.
  Posponha o segundo caixa de texto para os refeitos desta caixa de texto.
  Atribua o last destes desfeitos desta caixa de texto a um terceiro caixa de texto.
  Remove o terceiro caixa de texto desde os desfeitos desta caixa de texto.
  Copie as propriedades of o terceiro caixa de texto para a caixa de texto.
  Destrua o terceiro caixa de texto.
  Ligue o detector de alteração desta caixa de texto.

Etapas para que se execute uppercase usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Relembre a caixa de texto com "case".
  Uppercase qualquer trecho selecionado na caixa de texto.
  Wrap a caixa de texto.

Um hBitMap é um número identificador.

Um hBrush é um número identificador.

Um hDC é um número identificador.

Um orientação é uns points.

A contagem do heap é um número.

O endereço heap é um ponteiro.

Um altura é uns twips.

Um texto hexadecimal é uma string.

Um número da fonte é um número identificador.

Um hIcon é um número identificador.

Etapas para que se oculte o cursor:
  Call "user32.dll" "ShowCursor" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-showcursor
  \Exibe ou oculta o cursor.
  0 [bShow] \Se bShow for TRUE, a contagem de exibição é incrementada em um. Se bShow for FALSE, a contagem de exibição é diminuída em um.
    devolvendo um número. \O valor de retorno especifica o novo contador de exibição.
    \Esta função define um contador interno de exibição que determina se o cursor deve ser exibido. 
    \O cursor é exibido apenas se a contagem de exibição for maior ou igual a 0. 
    \Se um mouse for instalado, a contagem de exibição inicial será 0. Se nenhum mouse estiver instalado, a contagem de exibição será -1.
  Se o número for menor do que 0, cancele.
  Recomece. [percorra novamente o código acima]

Um linha reta horizontal é uma linha reta.

Um hour é 60 minutes.

Um hPen é um número identificador.

Um hRgn é um número identificador.



O i-beam cursor é um cursor.

Um IID é um UUID. \ Um interface identifier é um Identificador único universal

Etapas para que se imagine uma caixa uns twips por uns outros twips;
Etapas para que se faça uma caixa uns twips por uns outros twips:
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa.
  Atribua os twips à coordenada X do canto inferior direito desta caixa.
  Atribua os outros twips à coordenada Y do canto inferior direito desta caixa.

Etapas para que se imagine uma caixa uns twips high por uns outros twips wide;
Etapas para que se faça uma caixa uns twips high por uns outros twips wide:
  Atribua 0 e 0 e os outros twips e os twips ao caixa.

Etapas para que se imagine uma caixa uns twips smaller do que uma segunda caixa;
Etapas para que se faça uma caixa uns twips smaller do que uma segunda caixa:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips dividido por 2.

Etapas para que se imagine uma caixa uns twips smaller do que uma segunda caixa sobre cada side:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips.

Etapas para que se imagine uma caixa uns twips wide por uns outros twips high;
Etapas para que se faça uma caixa uns twips wide por uns outros twips high:
  Atribua 0 e 0 e os twips e os outros twips ao caixa.

Etapas para que se imagine uma caixa com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito;
Etapas para que se faça uma caixa com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito ao caixa.

Etapas para que se imagine uma caixa com uma localização e uma segunda localização;
Etapas para que se faça uma caixa com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao caixa.

Etapas para que se imagine uma cor desde um matiz e um saturação e um luminosidade;
Etapas para que se faça uma cor desde um matiz e um saturação e um luminosidade:
  Atribua o matiz e o saturação e o luminosidade à cor.

Etapas para que se imagine um dot aproximadamente uns twips wide;
Etapas para que se faça um dot aproximadamente uns twips wide;
Etapas para que se faça um dot uns twips wide:
  Faça o dot os twips pelo twips.

Etapas para que se imagine um dot entre uns twips e uns outros twips wide;
Etapas para que se faça um dot entre uns twips e uns outros twips wide:
  Escolha aleatoriamente uns terceiro twips entre os twips e os outros twips.
  Faça o dot o terceiro twips wide.

Etapas para que se imagine uma elipse usando uma caixa;
Etapas para que se faça uma elipse usando uma caixa:
  Atribua a caixa à caixa desta elipse.

Etapas para que se imagine uma elipse uns twips por uns outros twips;
Etapas para que se faça uma elipse uns twips por uns outros twips:
  Atribua 0 à coordenada X do canto superior esquerdo desta elipse.
  Atribua 0 à coordenada Y do canto superior esquerdo desta elipse.
  Atribua os twips à coordenada X do canto inferior direito desta elipse.
  Atribua os outros twips à coordenada Y do canto inferior direito desta elipse.

Etapas para que se imagine uma elipse com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito;
Etapas para que se faça uma elipse com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito ao elipse.

Etapas para que se imagine uma elipse com uma localização e uma segunda localização;
Etapas para que se faça uma elipse com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao elipse.

Etapas para que se imagine uma figura using uma string e uma localização;
Etapas para que se faça uma figura using uma string e uma localização;
Etapas para que se crie uma figura using uma string e um centro localização:
  Crie a figura.
  Posponha a figura para as figuras.
  Isole a string.
  Lowercase a string.
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
  Skip algum tipo de leading noise no subtexto.
  Se a quantidade de caracteres deste subtexto for menor do que 2, cancele.
  Atribua o conteúdo deste caractere inicial deste subtexto a um byte.
  Atribua o byte menos o 'a' minúsculo ao y desse localização.
  Adicione 1 para o caractere inicial deste subtexto.
  Atribua o conteúdo deste caractere inicial deste subtexto ao byte.
  Atribua o byte menos o 'a' minúsculo ao x desta localização.
  Multiplique a localização por 24 px.
  Adicione o x deste centro localização menos 299 pixels para a coordenada X desta localização.
  Adicione o y deste centro localização menos 299 pixels para a coordenada Y desta localização.
  Posponha a localização para a figura.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se imagine um linha reta horizontal uma fração of o caminho para cima desde o base of uma caixa;
Etapas para que se faça um linha reta horizontal uma fração of o caminho para cima desde o base of uma caixa:
  Imagine o linha reta horizontal across a caixa a fração of o caminho para cima desde o base.

Etapas para que se imagine uma linha reta across o base of uma caixa;
Etapas para que se faça uma linha reta across o base of uma caixa;
Etapas para que se imagine uma linha reta along o base of uma caixa;
Etapas para que se faça uma linha reta along o base of uma caixa:
  Atribua a coordenada Y do canto inferior direito desta caixa linha reta ao linha reta.

Etapas para que se imagine uma linha reta across uma caixa uma fração of o caminho para cima desde o base;
Etapas para que se faça uma linha reta across uma caixa uma fração of o caminho para cima desde o base:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa times a fração a uns twips.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização inicial desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização final desta linha reta.

Etapas para que se imagine uma linha reta across o topo of uma caixa;
Etapas para que se faça uma linha reta across o topo of uma caixa;
Etapas para que se imagine uma linha reta along o topo of uma caixa;
Etapas para que se faça uma linha reta along o topo of uma caixa:
  Atribua a coordenada Y do canto superior esquerdo desta caixa linha reta ao linha reta.

Etapas para que se imagine uma linha reta no middle of uma caixa;
Etapas para que se faça uma linha reta no middle of uma caixa;
Etapas para que se imagine uma linha reta across o middle of uma caixa;
Etapas para que se faça uma linha reta across o middle of uma caixa;
Etapas para que se imagine uma linha reta no centro of uma caixa;
Etapas para que se faça uma linha reta no centro of uma caixa;
Etapas para que se imagine uma linha reta across o centro of uma caixa;
Etapas para que se faça uma linha reta across o centro of uma caixa:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua o y deste centro desta caixa ao y desta localização inicial desta linha reta.
  Atribua o y deste centro desta caixa ao y desta localização final desta linha reta.

Etapas para que se imagine uma linha reta uns twips para cima desde o base of uma caixa;
Etapas para que se faça uma linha reta uns twips para cima desde o base of uma caixa:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização inicial desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização final desta linha reta.

Etapas para que se imagine uma linha reta com uma localização e uma segunda localização;
Etapas para que se faça uma linha reta com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao linha reta.

Etapas para que se imagine uma linha reta com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y;
Etapas para que se faça uma linha reta com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y:
  Atribua a coordenada X e a coordenada Y e a segunda coordenada X e a segunda coordenada Y ao linha reta.

Etapas para que se imagine uma caixa arredondada desde uma caixa e um raio;
Etapas para que se faça uma caixa arredondada desde uma caixa e um raio:
  Atribua a caixa e o raio ao caixa arredondada.

Etapas para que se imagine uma caixa arredondada uns twips por uns outros twips;
Etapas para que se faça uma caixa arredondada uns twips por uns outros twips com um raio:
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa arredondada.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa arredondada.
  Atribua os twips à coordenada X do canto inferior direito desta caixa arredondada.
  Atribua os outros twips à coordenada Y do canto inferior direito desta caixa arredondada.
  Atribua o raio ao raio desta caixa arredondada.

Etapas para que se imagine uma caixa arredondada com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito e um raio;
Etapas para que se faça uma caixa arredondada com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito e um raio:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito e o raio ao caixa arredondada.

Etapas para que se imagine uma caixa arredondada com uma localização e uma segunda localização e um raio;
Etapas para que se faça uma caixa arredondada com uma localização e uma segunda localização e um raio:
  Atribua a localização e a segunda localização e o raio ao caixa arredondada.

Etapas para que se imagine uma localização com uma coordenada X e uma coordenada Y;
Etapas para que se faça uma localização com uma coordenada X e uma coordenada Y:
  Atribua a coordenada X e a coordenada Y à localização.

Etapas para que se indent algum tipo de linhas des textos selecionadas em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
  Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
  Se a linha de texto for inexistente, cancele.
  Se a linha de texto of a caixa de texto não estiver selecionado, recomece.
  Se a linha de texto estiver em branco, recomece.
  Anteponha o caractere de espaço para a string deste linha de texto.
  Anteponha o caractere de espaço para a string deste linha de texto.
  Recomece. [percorra novamente o código acima]

Um indent é uma contagem.

Um catálogo é uma coisa com
Um contagem de buckets,
Um first bucket e um last bucket.

Etapas para que se catalogue um ponteiro usando uma string e um catálogo:
    \ if o catálogo for inexistente, cancele. \ para fazer compilador faster
  Se a quantidade de caracteres desta string for 0, cancele.
  Obtenha um bucket usando a string e o catálogo.
  Crie um referência.
  Posponha o referência para os referências deste bucket.
  Atribua a string à string deste referência.
  Atribua o ponteiro ao ponteiro deste referência.

Etapas para que se catalogue uma string em um catálogo:
  \ if o catálogo for inexistente, cancele. \ para fazer compilador faster
  Catalogue nil usando a string e o catálogo.

Etapas para que se initalize o terminal:
  Crie o terminal na caixa desta tela.

Etapas para que se initialize before run:
  Call "user32.dll" "DisableProcessWindowsGhosting".\ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-disableprocesswindowsghosting
  \Desativa o recurso de imagem fantasma da janela para o processo de chamada da GUI. 
  \O fantasma de janela é um recurso do Gerenciador do Windows 
  \que permite ao usuário minimizar, mover ou fechar a janela principal de um aplicativo que não está respondendo.
  Call "kernel32.dll" "GetProcessHeap" \ https://docs.microsoft.com/pt-br/windows/win32/api/heapapi/nf-heapapi-getprocessheap
  \Recupera um identificador para o heap padrão do processo de chamada. 
  \Esse identificador pode então ser usado em chamadas subsequentes para as funções de heap.
    devolvendo o endereço heap. \Se a função for bem-sucedida, o valor de retorno será um identificador para o heap do processo de chamada.
    \Se a função falhar, o valor de retorno será NULL.
    Atribua "kernel32.dll" a uma nova string.
    Atribua "HeapSetInformation.dll" a uma novíssima string.
  Call "kernel32.dll" "LoadLibraryA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya
  \Carrega o módulo especificado no espaço de endereço do processo de chamada. 
  \O módulo especificado pode fazer com que outros módulos sejam carregados.
    O caractere inicial desta nova string [lpLibFileName] \O nome do módulo. 
    \Pode ser um módulo de biblioteca (um arquivo .dll) ou um módulo executável (um arquivo .exe).
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno é um identificador para o módulo.
    \Se a função falhar, o valor de retorno será NULL.
  Se o número identificador não for 0, Call "kernel32.dll" "GetProcAddress" com \ https://docs.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress
  \Recupera o endereço de uma função ou variável exportada da biblioteca de vínculo dinâmico (DLL) especificada.
    O número identificador [hModule] \Um identificador para o módulo DLL que contém a função ou variável.
    e o caractere inicial desta novíssima string [lpProcName] \O nome da função ou variável, ou o valor ordinal da função. 
    \Se este parâmetro for um valor ordinal, ele deve estar na word de ordem inferior; a word de ordem superior deve ser zero.
    devolvendo um ponteiro. \Se a função for bem-sucedida, o valor de retorno será o endereço da função ou variável exportada.
    \Se a função falhar, o valor de retorno será NULL.
  Se o ponteiro não for inexistente, 
     Atribua 1 a um novo número; 
    Call o ponteiro com 
        o endereço heap 
        e 0 
        e o endereçamento deste novo número 
        e 4.

Etapas para que se inicialize os canvases:
  Inicialize o tela canvas.
  Inicialize o memory canvas.
  Atribua o memory canvas ao quadro atual.

Etapas para que se inicialize o cgi:
  Call "kernel32.dll" "AllocConsole". \ https://docs.microsoft.com/pt-br/windows/console/allocconsole
  \Aloca um novo console para o processo de chamada.
  Call "kernel32.dll" "GetStdHandle" com \ https://docs.microsoft.com/pt-br/windows/console/getstdhandle
  \A função GetStdHandle recupera um identificador para o dispositivo padrão especificado (entrada padrão, saída padrão ou erro padrão).
  -10 [nStdHandle = STD_INPUT_HANDLE] \ O desvio padrão. 
  \STD_INPUT_HANDLE é o dispositivo de entrada padrão. Inicialmente, esse é o buffer de entrada do console, CONIN$.
    devolvendo o número identificador do fluxo de entrada padrão.
    \Se a função for bem-sucedida, o valor retornado será um identificador para o dispositivo especificado
\    ou um identificador redirecionado definido por uma chamada anterior para SetStdHandle. 
    \Os identificadores retornados por GetStdHandle podem ser usados por aplicativos que precisam fazer a leitura do console ou a gravação nele. 
    \Quando um console é criado, o identificador de entrada padrão é um identificador para o buffer de entrada do console, 
    \e os identificadores de saída padrão e de erro padrão são identificadores do buffer de tela ativo do console. 
    \Esses identificadores podem ser usados pelas funções ReadFile e WriteFile 
    \ou por qualquer uma das funções de console que acessam o buffer de entrada do console ou um buffer de saída
  Call "kernel32.dll" "GetStdHandle" com 
  -11 [nStdHandle = STD_OUTPUT_HANDLE] \ STD_OUTPUT_HANDLE é o dispositivo de saída padrão. ,
  \Inicialmente, esse é o buffer de tela do console ativo, CONOUT$.
    devolvendo o número identificador do fluxo de saída padrão.

\Etapas para que se inicialize o Component Object Model:
\Mande os códigos 0 e 2 para a função "CoInitializeEx" da biblioteca "ole32.dll" [COINIT_APARTMENTTHREADED].

Etapas para que se inicialize o Component Object Model:
  Call "ole32.dll" "CoInitializeEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex
  \Inicializa a biblioteca COM para uso pelo thread de chamada, 
  \define o modelo de simultaneidade do thread e 
  \cria um novo compartimento para o thread, se necessário.
  0 [pvReserved] \Este parâmetro é reservado e deve ser NULL.
    e 2 [dwCoInit = COINIT_APARTMENTTHREADED]. \O modelo de simultaneidade e as opções de inicialização para o encadeamento. 
    \Os valores para este parâmetro são retirados da enumeração COINIT. 
    \ https://docs.microsoft.com/pt-br/windows/win32/api/objbase/ne-objbase-coinit
    \Qualquer combinação de valores de COINIT pode ser usada, 
    \exceto que os sinalizadores COINIT_APARTMENTTHREADED e COINIT_MULTITHREADED não podem ser definidos juntos. 
    \O padrão é COINIT_MULTITHREADED.
    \COINIT_APARTMENTTHREADED inicializa o thread para simultaneidade de objetos apartment-threaded
    \Quando um thread é inicializado por meio de uma chamada para CoInitializeEx, 
    \você escolhe se deseja inicializá-lo como thread de apartamento ou multithread, 
    \designando um dos membros de COINIT como seu segundo parâmetro. 
    \Isso designa como as chamadas de entrada para qualquer objeto criado por esse thread são tratadas, ou seja, a simultaneidade do objeto.
    \O threading de apartamento, enquanto permite vários threads de execução, 
    \serializa todas as chamadas de entrada exigindo que as chamadas para métodos de objetos criados por esse thread 
    \sempre sejam executados no mesmo thread, ou seja, o apartment / thread que os criou. 
    \Além disso, as chamadas podem chegar apenas nos limites da fila de mensagens. 
    \Por causa dessa serialização, normalmente não é necessário gravar o controle de simultaneidade no código do objeto, 
    \a não ser para evitar chamadas para PeekMessage e SendMessage durante o processamento 
    \que não devem ser interrompidas por outras invocações de método ou chamadas para outros objetos no mesmo apartamento /thread.

Etapas para que se inicialize um contexto:
  Aloque memória para o contexto.
  Atribua o centro desta tela à localização deste contexto.
  Atribua 0 à orientação deste contexto.
  Atribua a cor verde à cor deste contexto.
  Atribua o tamanho de letra pequena à tamanho da letra deste contexto.
  \Atribua 1/60 second ao delay. ***
  Seed o número aleatório generator.

Etapas para que se inicialize os cursors:
  Inicialize os cursors (seta do mouse).
  Inicialize os cursors (hand cursor).
  Inicialize os cursors (i-beam cursor).
  \Atribua a seta do mouse ao cursor flecha.
  \Atribua o hand cursor ao cursor mano.
  \Atribua o i-beam cursor ao cursor rayo-i.
  Oculte o cursor.

Etapas para que se inicialize os cursors (seta do mouse):
  Posponha $00000000000000004000000060000000 para uma máscara de disjunção exclusiva.
  Posponha $70000000780000007C0000007E000000 para a máscara de disjunção exclusiva.
  Posponha $7F0000007F8000007C0000006C000000 para a máscara de disjunção exclusiva.
  Posponha $46000000060000000300000003000000 para a máscara de disjunção exclusiva.
  Posponha $01800000018000000000000000000000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 48.
  Posponha $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF para uma máscara de conjunção lógica.
  Posponha $07FFFFFF03FFFFFF01FFFFFF00FFFFFF para a máscara de conjunção lógica.
  Posponha $007FFFFF003FFFFF001FFFFF01FFFFFF para a máscara de conjunção lógica.
  Posponha $10FFFFFF30FFFFFF787FFFFFF87FFFFF para a máscara de conjunção lógica.
  Posponha $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 48.
  Call "user32.dll" "CreateCursor" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-createcursor
  \Cria um cursor com o tamanho, padrões de bits e ponto de acesso especificados.
    O número identificador deste module [hInst] \ Um identificador para a instância atual do aplicativo que cria o cursor.
    e 0 [xHotSpot] \ A posição horizontal do ponto de acesso do cursor.
    e 0 [yHotSpot] \ A posição vertical do ponto de acesso do cursor.
    e 32 [nWidth] \ A largura do cursor, em pixels.
    e 32 [nHeight] \ A altura do cursor, em pixels.
    e O caractere inicial desta máscara de conjunção lógica [*pvANDPlane] 
    \ Uma matriz de bytes que contém os valores de bit para a máscara AND do cursor, como em um bitmap monocromático dependente de dispositivo.
    e O caractere inicial desta máscara de disjunção exclusiva [*pvXORPlane] 
    \ Uma matriz de bytes que contém os valores de bit para a máscara XOR do cursor, como em um bitmap monocromático dependente de dispositivo.
    devolvendo a seta do mouse. \Se a função for bem-sucedida, o valor de retorno é um identificador para o cursor.

Etapas para que se inicialize o cursors (hand cursor):
  Posponha $000000000180000019B0000019B00000 para uma máscara de disjunção exclusiva.
  Posponha $0DB200000DB6000007F6000067FE0000 para a máscara de disjunção exclusiva.
  Posponha $7FFC00003FFC00001FFC00001FF80000 para a máscara de disjunção exclusiva.
  Posponha $0FF8000007F0000003F0000003F00000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 64.
  Posponha $FE7FFFFFE40FFFFFC007FFFFC005FFFF para uma máscara de conjunção lógica.
  Posponha $E000FFFFE000FFFF9000FFFF0000FFFF para a máscara de conjunção lógica.
  Posponha $0001FFFF8001FFFFC001FFFFC003FFFF para a máscara de conjunção lógica.
  Posponha $E003FFFFF007FFFFF807FFFFF807FFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 64.
  Call "user32.dll" "CreateCursor" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-createcursor
  \Cria um cursor com o tamanho, padrões de bits e ponto de acesso especificados.
    O número identificador deste module [hInst] \ Um identificador para a instância atual do aplicativo que cria o cursor.
    e 2 [xHotSpot] \ A posição horizontal do ponto de acesso do cursor.
    e 1 [yHotSpot] \ A posição vertical do ponto de acesso do cursor.
    e 32 [nWidth] \ A largura do cursor, em pixels.
    e 32 [nHeight] \ A altura do cursor, em pixels.
    e O caractere inicial desta máscara de conjunção lógica [*pvANDPlane] 
    \ Uma matriz de bytes que contém os valores de bit para a máscara AND do cursor, como em um bitmap monocromático dependente de dispositivo.
    e O caractere inicial desta máscara de disjunção exclusiva [*pvXORPlane] 
    \ Uma matriz de bytes que contém os valores de bit para a máscara XOR do cursor, como em um bitmap monocromático dependente de dispositivo.
    devolvendo o hand cursor. \Se a função for bem-sucedida, o valor de retorno é um identificador para o cursor.

Etapas para que se inicialize o cursors (i-beam cursor):
  Posponha $EE000000100000001000000010000000 para um máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $100000001000000010000000EE000000 para o máscara de disjunção exclusiva.
  Posponha $00 para o máscara de disjunção exclusiva usando 64.
  Posponha $FF para um máscara de conjunção lógica usando 128.
  Call "user32.dll" "CreateCursor" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-createcursor
  \Cria um cursor com o tamanho, padrões de bits e ponto de acesso especificados.
    O número identificador deste module [hInst] \ Um identificador para a instância atual do aplicativo que cria o cursor.
    e 3 [xHotSpot] \ A posição horizontal do ponto de acesso do cursor.
    e 7 [yHotSpot] \ A posição vertical do ponto de acesso do cursor.
   e 32 [nWidth] \ A largura do cursor, em pixels.
    e 32 [nHeight] \ A altura do cursor, em pixels.
    e O caractere inicial desta máscara de conjunção lógica [*pvANDPlane] 
    \ Uma matriz de bytes que contém os valores de bit para a máscara AND do cursor, como em um bitmap monocromático dependente de dispositivo.
    e O caractere inicial desta máscara de disjunção exclusiva [*pvXORPlane] 
    \ Uma matriz de bytes que contém os valores de bit para a máscara XOR do cursor, como em um bitmap monocromático dependente de dispositivo.
    devolvendo o i-beam cursor. \Se a função for bem-sucedida, o valor de retorno é um identificador para o cursor.

Etapas para que se inicialize as fontes:
  Call "gdi32.dll" "GetStockObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getstockobject
  \A função GetStockObject recupera um identificador para uma das canetas, pincéis, fontes ou paletas de estoque.
  11 [i = ANSI_FIXED_FONT 0x0000000B] \ O tipo de objeto de estoque.
  \ANSI_FIXED_FONT = Fonte do sistema de pitch fixo (monoespaçada) do Windows.
    devolvendo o null número da fonte. \Se a função for bem-sucedida, o valor de retorno é um identificador para o objeto lógico solicitado.
    \Se a função falhar, o valor de retorno será NULL.
  \Call "gdi32.dll" "AddFontMemResourceEx" com o caractere inicial desta osmosian fonte source e a quantidade de caracteres desta osmosian fonte source e 0 e o endereçamento desse número devolvendo o osmosian fonte resource.
  \Call "gdi32.dll" "AddFontMemResourceEx" com o caractere inicial desta fonte Segoe UI e a quantidade de caracteres desta fonte Segoe UI e 0 e o endereçamento desse número devolvendo o Segoe UI resource.
  Call "gdi32.dll" "AddFontMemResourceEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-addfontmemresourceex
  \A função AddFontMemResourceEx adiciona o recurso de fonte de uma imagem de memória ao sistema.
    O caractere inicial desta fonte Tahoma [pFileView] \ Um ponteiro para um recurso de fonte.
    e A quantidade de caracteres desta fonte Tahoma [cjSize] \ O número de bytes no recurso de fonte apontado por pbFont.
    e 0 [pvResrved] \ Reservado. Deve ser 0.
    e O endereçamento desse número [*pNumFonts] \ Um ponteiro para uma variável que especifica o número de fontes instaladas.
    devolvendo o recurso de fonte Tahoma. \Se a função for bem-sucedida, o valor de retorno especifica o identificador para a fonte adicionada. 
    \Este identificador identifica exclusivamente as fontes que foram instaladas no sistema. Se a função falhar, o valor de retorno é zero.
  \Atribua "Segoe UI" e 1/6 polegada à fonte padrão.
  \Atribua "osmosian" e 24 pixels à fonte padrão.
  Atribua "Tahoma" e 20 pixels à fonte padrão.
  \ stroked fontes abaixo
  Atribua 12 pixels ao tamanho de letra pequena.
  Atribua 24 pixels ao tamanho de letra médio.
  Atribua 48 pixels ao tamanho de letra grande.

Etapas para que se inicialize gdi+:
  Atribua 1 ao GdiplusVersion desse GdiplusStartupInput.
  Call "gdiplus.dll" "GdiplusStartup" com \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusinit/nf-gdiplusinit-gdiplusstartup
  \A função GdiplusStartup inicializa o Windows GDI +. 
    O endereçamento deste gpToken [*token] \ Ponteiro para um ULONG_PTR que recebe um token. 
    \ o token é passado para GdiplusShutdown quando terminar de usar GDI +. https://docs.microsoft.com/pt-br/windows/desktop/api/gdiplusinit/nf-gdiplusinit-gdiplusshutdown
    e O endereçamento deste GdiplusStartupInput [*input] \ Ponteiro para uma estrutura GdiplusStartupInput que contém a versão GDI +,
    \https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusinit/ns-gdiplusinit-gdiplusstartupinput 
    \um ponteiro para uma função de retorno de chamada de depuração, 
    \um valor booleano que especifica se deve suprimir o thread de segundo plano 
    \e um valor booleano que especifica se deve suprimir codecs de imagem externos.
    e 0. [*output] \ Ponteiro para uma estrutura GdiplusStartupOutput 
    \que recebe um ponteiro para uma função de gancho de notificação 
    \e um ponteiro para uma função de desbloqueio de notificação. 
    \Se o membro de dados SuppressBackgroundThread do parâmetro de entrada for FALSE, esse parâmetro pode ser NULL.
    \https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusinit/ns-gdiplusinit-gdiplusstartupoutput
    \Windows GDI+ é uma API baseada em classe para programadores C/C++. 
    \Ela permite que os aplicativos usem elementos gráficos e texto formatado na exibição de vídeo e na impressora. 
    \Aplicativos baseados na API do Microsoft Win32 não acessam diretamente o hardware gráfico. 
    \Em vez disso, GDI+ interage com drivers de dispositivo em nome de aplicativos. 

Etapas para que se inicialize o memory canvas:
  Call "gdi32.dll" "CreateCompatibleDC" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-createcompatibledc
  \A função CreateCompatibleDC cria um contexto de dispositivo de memória (DC) compatível com o dispositivo especificado.
    O tela canvas [hdc] \ Um identificador para um DC existente. 
    \Se esse identificador for NULL, a função criará uma memória DC compatível com a tela atual do aplicativo.
    devolvendo o memory canvas. \Se a função for bem-sucedida, o valor de retorno é o identificador para um DC de memória.
  Call "gdi32.dll" "GetCurrentObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getcurrentobject
  \A função GetCurrentObject retorna um identificador que identifica a caneta, pincel, paleta, bitmap ou fonte atual 
  \e a função GetObject inicializa uma estrutura contendo os atributos desse objeto. 
  \Algumas impressoras fornecem canetas, pincéis e fontes residentes que podem ser usados para melhorar a velocidade de desenho em um aplicativo.
    O memory canvas [hDC] \ Um identificador para o contexto do dispositivo.
    e 7 [OBJ_BITMAP] \ O tipo de objeto a ser consultado. Este parâmetro pode ser vários valores.
    \OBJ_BITMAP Retorna o bitmap selecionado atualmente.
    devolvendo o saved memory hBitMap. [h] \ Se a função for bem-sucedida, o valor de retorno é um identificador para o objeto especificado. 
    \Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "CreateCompatibleBitmap" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-createcompatiblebitmap
  \A função CreateCompatibleBitmap cria um bitmap compatível com o dispositivo que está associado ao contexto de dispositivo especificado.
    O tela canvas [hdc] \ Um identificador para um contexto de dispositivo.
    e A pixel largura desta tela [cx] \ A largura do bitmap, em pixels.
    e A pixel altura desta tela [xy] \ A altura do bitmap, em pixels.
    devolvendo um hBitMap. \ Se a função for bem-sucedida, o valor de retorno é um identificador para o bitmap compatível (DDB).
    \Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hdc] \ Um identificador para um contexto de dispositivo.
    e O hBitMap. [h] \ Um identificador para o objeto a ser selecionado.
    \Os bitmaps só podem ser selecionados em DCs de memória. Um único bitmap não pode ser selecionado em mais de um DC ao mesmo tempo.
  Normalize o memory canvas.

Etapas para que se inicialize o module:
  \ temp endereço completo
  Atribua 512 a uma quantidade de caracteres.
  Reassign o caractere inicial deste temp endereço completo usando a quantidade de caracteres.
  Call "kernel32.dll" "GetTempPathA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-gettemppatha
  \Recupera o caminho do diretório designado para arquivos temporários.
    A quantidade de caracteres [nBufferLength] \ O tamanho do buffer de string identificado por lpBuffer, em TCHARs.
    e O caractere inicial deste temp endereço completo [lpBuffer] \ Um ponteiro para um buffer de string 
    \que recebe a string terminada em nulo especificando o caminho do arquivo temporário. 
    \A string retornada termina com uma barra invertida, por exemplo, "C:\TEMP\".
    devolvendo a quantidade de caracteres. \Se a função for bem-sucedida, o valor de retorno é o comprimento, 
    \em TCHARs, da string copiada para lpBuffer, sem incluir o caractere nulo de terminação. 
    \Se o valor de retorno for maior que nBufferLength, o valor de retorno será o comprimento, em TCHARs, do buffer necessário para conter o caminho.
    \Se a função falhar, o valor de retorno é zero.
  Atribua o caractere inicial deste temp endereço completo mais a quantidade de caracteres menos 1 ao caractere final deste temp endereço completo.
  Anexe o caractere NULL o temp endereço completo.
  \ module handle
  Call "kernel32.dll" "GetModuleHandleA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea
  \Recupera um identificador de módulo para o módulo especificado. O módulo deve ter sido carregado pelo processo de chamada.
  0 [lpModuleName] \ O nome do módulo carregado (um arquivo .dll ou .exe). 
  \Se a extensão do nome do arquivo for omitida, a extensão da biblioteca padrão .dll será anexada. 
  \A string do nome do arquivo pode incluir um caractere de ponto final (.) Para indicar que o nome do módulo não tem extensão. 
  \A string não precisa especificar um caminho. 
  \Ao especificar um caminho, certifique-se de usar barras invertidas (\), não barras (/). 
  \O nome é comparado (independentemente de maiúsculas e minúsculas) aos nomes dos módulos atualmente mapeados no espaço de endereço do processo de chamada.
  \Se este parâmetro for NULL, GetModuleHandle retorna um identificador para o arquivo usado para criar o processo de chamada (arquivo .exe).
    devolvendo o número identificador deste module. \
  \ module nome
  Atribua 512 à quantidade de caracteres.
  Reassign o caractere inicial deste endereço completo deste module usando a quantidade de caracteres.
  Call "kernel32.dll" "GetModuleFileNameA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea
  \ Recupera o caminho totalmente qualificado para o arquivo que contém o módulo especificado. O módulo deve ter sido carregado pelo processo atual.
    O número identificador deste module [hModule] \ Um identificador para o módulo carregado cujo caminho está sendo solicitado. 
    \Se este parâmetro for NULL, GetModuleFileName recupera o caminho do arquivo executável do processo atual.
    e O caractere inicial deste endereço completo deste module [lpFilename] \ Um ponteiro para um buffer que recebe o caminho totalmente qualificado do módulo. 
    \Se o comprimento do caminho for menor que o tamanho que o parâmetro nSize especifica, 
    \a função é bem-sucedida e o caminho é retornado como uma string terminada em nulo.
    e A quantidade de caracteres  [nSize] \ O tamanho do buffer lpFilename, em TCHARs.
    devolvendo a quantidade de caracteres. 
    \Se a função for bem-sucedida, o valor de retorno será o comprimento da string copiada para o buffer, em caracteres, não incluindo o caractere nulo de terminação.
  Atribua o caractere inicial deste endereço completo deste module mais a quantidade de caracteres menos 1 ao caractere final deste endereço completo deste module.
  Se o endereço completo deste module começa com "\\?\", remove leading bytes desde o endereço completo deste module usando 4.
  Lowercase o endereço completo deste module.
  Anexe o caractere NULL o endereço completo deste module. \ segunda endereço completo pieces deste module
  Extraia o nome deste module desde o endereço completo deste module.
  Anexe o caractere NULL o nome deste module.
  Extraia o endereço da pasta deste module desde o endereço completo deste module.
  Anexe o caractere NULL o endereço da pasta deste module.
  Extraia o root endereço da pasta deste module desde o endereço da pasta deste module.
  Anexe o caractere NULL o root endereço da pasta deste module.

Etapas para que se inicialize o mouse:
  Atribua 1 ao botão esquerdo deste mouse.
  Atribua 2 ao botão direito deste mouse.
  Call "user32.dll" "GetSystemMetrics" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getsystemmetrics
  \Recupera a métrica do sistema especificada ou a definição de configuração do sistema.
  \Observe que todas as dimensões recuperadas por GetSystemMetrics estão em pixels.
  23 [nIndex = SM_SWAPBUTTON] \ A métrica do sistema ou definição de configuração a ser recuperada.
  \SM_SWAPBUTTON (23) recebe um valor diferente de 0 se os cliques dos botões esquerdo e direito do mouse estiverem invertidos; caso contrário seu valor será 0.
    devolvendo um número. \ Se a função for bem-sucedida, o valor de retorno será a métrica do sistema ou definição de configuração solicitada.
  Se o número for 0, saia.
  Permute o botão esquerdo deste mouse com o botão direito deste mouse.

Etapas para que se inicialize a área de impressão:
  Atribua a magnitude [quantidade de bytes] desse PrintDlgEx ao lStructSize deste PrintDlgEx.
  Atribua a janela principal do programa ao hwndowner deste PrintDlgEx.
  Atribua 1288 \ resultado da combinação da disjunção lógica dos valores 256 | 1024 | 8
  \ O significado de cada valor está descrito, sequenciadamente, abaixo
  [PD_RETURNDC (256)] \ Faz com que PrintDlg retorne um contexto de dispositivo que corresponda às seleções feitas pelo usuário na caixa de diálogo. 
  \O contexto do dispositivo é retornado em hDC.
  [+ PD_RETURNDEFAULT (1024)] \ Se este sinalizador for definido, a função PrintDlg não exibe a caixa de diálogo. 
  \Em vez disso, ele define os membros hDevNames e hDevMode para manipular as estruturas DEVMODE e DEVNAMES que são inicializadas para a impressora padrão do sistema. 
  \Ambos hDevNames e hDevMode devem ser NULL ou PrintDlg retornará um erro.
  [+ PD_NOPAGENUMS (8)] \ Desativa o botão de opção Páginas e os controles de edição associados. 
  \Além disso, faz com que a caixa de seleção Agrupar apareça na caixa de diálogo.
 ao flags deste PrintDlgEx.
  Atribua -1 [START_PAGE_GENERAL] ao nStartPage deste PrintDlgEx. \A página de propriedades que é exibida inicialmente. 
  \Para exibir a página Geral, especifique START_PAGE_GENERAL.
  Call "comdlg32.dll" "PrintDlgExA" com \ https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/legacy/ms646942(v=vs.85)
  \ Exibe uma folha de propriedades de impressão que permite ao usuário especificar as propriedades de um determinado trabalho de impressão. 
  \Uma folha de propriedades de impressão possui uma página Geral que contém controles semelhantes à caixa de diálogo Imprimir. 
  \A folha de propriedades também pode ter páginas de propriedades adicionais específicas do aplicativo e do driver, bem como a página Geral.
    O endereçamento deste PrintDlgEx. [lppd] \ Um ponteiro para uma estrutura PRINTDLGEX que contém informações usadas para inicializar a folha de propriedades. 
    \Quando PrintDlgEx retorna, esta estrutura contém informações sobre as seleções do usuário.
    \Essa estrutura deve ser declarada dinamicamente usando uma função de alocação de memória.
  Call "kernel32.dll" "GlobalFree" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globalfree
  \A função GlobalFree libera o objeto de memória global especificado e invalida seu identificador
    O hDevNames deste PrintDlgEx.[hMem] \ O número identificador do objeto de memória global. 
    \Esse identificador é retornado pela função GlobalAlloc ou GlobalReAlloc. 
    \Não é seguro liberar memória alocada com LocalAlloc.
    \As funções globais têm maior sobrecarga e fornecem menos recursos do que outras funções de gerenciamento de memória. 
    \Novos aplicativos devem usar as funções de heap, a menos que a documentação indique que uma função global deve ser usada. 
    \Para obter mais informações, consulte Funções globais e locais.
    \Se o processo examinar ou modificar a memória depois de liberada, 
    \pode ocorrer corrupção de heap ou pode ser gerada uma exceção de violação de acesso (EXCEPTION_ACCESS_VIOLATION).
    \A função GlobalFree irá liberar um objeto de memória bloqueado. 
    \Um objeto de memória bloqueado possui uma contagem de bloqueio maior que zero. 
    \A função GlobalLock bloqueia um objeto de memória global e aumenta a contagem de bloqueios em 1. 
    \A função GlobalUnlock o desbloqueia e diminui a contagem de bloqueios em 1. 
    \Para obter a contagem de bloqueios de um objeto de memória global, use a função GlobalFlags.
    \Se um aplicativo estiver sendo executado em uma versão de depuração do sistema, 
    \a função GlobalFree emitirá uma mensagem informando que um objeto bloqueado está sendo liberado. 
    \Se você estiver depurando o aplicativo, GlobalFree entrará em um ponto de interrupção antes de liberar um objeto bloqueado. 
    \Isso permite que você verifique o comportamento pretendido e, em seguida, continue a execução.
  Atribua o hDevMode deste PrintDlgEx ao número identificador do modo de dispositivo da impressora.
  Atribua o hDC deste PrintDlgEx à área de impressão.

Etapas para que se inicialize a tela:
  Call "user32.dll" "GetSystemMetrics" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getsystemmetrics
  \Recupera a métrica do sistema especificada ou a definição de configuração do sistema.
  \Observe que todas as dimensões recuperadas por GetSystemMetrics estão em pixels.
  0 [nIndex = SM_CXSCREEN] \ A métrica do sistema ou definição de configuração a ser recuperada.
  \SM_CXSCREEN = A largura da tela do monitor principal, em pixels.
    devolvendo a pixel largura desta tela.
  Call "user32.dll" "GetSystemMetrics" com 
  1 [nIndex = SM_CYSCREEN] \A altura da tela do monitor principal, em pixels.
    devolvendo a pixel altura desta tela.
  Atribua 96 ao ppi.
  Atribua o tpi dividido pelo ppi ao quantidade de twips/pixel .
  Atribua a pixel largura desta tela times a quantidade de twips/pixel a uma largura.
  Atribua a pixel altura desta tela times a quantidade de twips/pixel a uma altura.
  Atribua 0 e 0 e a largura e a altura à caixa desta tela.
  Subtraia a quantidade de twips/pixel desde o canto inferior direito desta tela.

Etapas para que se inicialize o tela canvas:
  Call "user32.dll" "GetDC" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getdc
  \A função GetDC recupera um identificador para um contexto de dispositivo (DC) para a área do cliente de uma janela especificada ou para a tela inteira. 
  \Você pode usar o identificador retornado em funções GDI subseqüentes para desenhar no DC. 
  \O contexto do dispositivo é uma estrutura de dados opaca, cujos valores são usados internamente pelo GDI.
  \Um contexto de dispositivo (DC) é uma estrutura de dados que contém informações dos atributos de desenho de um dispositivo de saída, 
  \tais como uma placa de vídeo ou uma impressora, e usada nas práticas de programação gráfica do Windows.
  \Para desenhar algo em uma janela, o programador deve obter o contexto do dispositivo da janela. 
  \Todo o desenho e pintura são feitos no identificador de contexto do dispositivo.
  \UM CONTEXTO DE DISPOSITIVO É UMA ESTRUTURA QUE DEFINE UM CONJUNTO DE OBJETOS GRÁFICOS E SEUS ATRIBUTOS ASSOCIADOS E OS MODOS GRÁFICOS QUE AFETAM A SAÍDA. 
  \Os objetos gráficos incluem uma caneta para desenho de linha, um pincel para pintar e preencher, um bitmap para copiar ou rolar partes da tela, 
  \uma paleta para definir o conjunto de cores disponíveis, uma região para recorte e outras operações e um caminho para operações de pintura e desenho.
  \Podemos desenhar algo na janela do evento WM_PAINT. 
  \O evento WM_PAINT é enviado pela estrutura da GUI do Win32 no momento do desenho da janela ou quando uma parte da janela requer uma atualização.
  \O programador deve obter o contexto do dispositivo usando a chamada de API BeginPaint () e,
  \em seguida, o desenho pode ser feito usando várias chamadas GDI. No final das chamadas GDI, os programadores devem chamar EndPaint ().
  \O contexto do dispositivo é uma abstração do Windows para acessar qualquer hardware de saída, como adaptadores gráficos ou impressoras que exibem texto e desenhos gráficos. 
  \O sistema operacional Windows retorna um identificador para o contexto de dispositivo do dispositivo. 
  \O contexto do dispositivo é uma estrutura no modo kernel do sistema operacional onde ele armazena os atributos e outras propriedades do dispositivo. 
  \O hardware pode variar em muitos aspectos, mas o contexto do dispositivo é comum para todos, para qualquer tipo de dispositivo específico.
  \O que é um DC? Um Device Context (DC) é o núcleo da GDI (Graphics Device Interface), biblioteca gráfica do Windows. 
  \Nos bastidores, o DC é a interface entre nossos aplicativos e o hardware de saída, no entanto, ao desenvolver com eles raramente vemos esse aspecto
  \e podemos apenas pensar neles como um suporte para vários objetos de desenho e propriedades. 
  \Como o próprio nome sugere, um DC coloca todos os objetos que ele contém no contexto de um dispositivo específico 
  \que e irá descobrir como formatar esses objetos para serem compatíveis e eficientes com o dispositivo desejado. 
  \Um DC também armazena informações sobre o dispositivo que está vinculado e o que é capaz de renderizar, 
  \além de conter várias propriedades que podem afetar o resultado de várias rotinas de desenho.
  \O que é um contexto de dispositivo? O contexto de um dispositivo é o estado atual do hardware do dispositivo. 
  \O driver do dispositivo gerencia o contexto do dispositivo para um processo em nome do processo. 
  \O driver deve manter um contexto de dispositivo separado para cada processo que acessa o dispositivo. 
  \O driver do dispositivo tem a responsabilidade de restaurar o contexto correto do dispositivo quando um processo acessa o dispositivo.
  \Realmente, ... o que é um contexto de dispositivo ???
  \Um contexto de dispositivo é uma estrutura de dados do Windows que contém informações sobre os atributos de desenho de um dispositivo, como um monitor ou uma impressora. 
  \Todas as chamadas de desenho são feitas por meio de um objeto de contexto de dispositivo, que encapsula as APIs do Windows para desenhar linhas, formas e texto. 
  \Contextos de dispositivo permitem desenho independente de dispositivo no Windows. 
  \Os contextos do dispositivo podem ser usados para desenhar na tela, na impressora ou em um metarquivo.
    A janela principal do programa [hWnd] \Um identificador para a janela cujo DC deve ser recuperado.
    devolvendo o tela canvas. \Se a função for bem-sucedida, o valor de retorno é um identificador para o controlador de domínio para a área de cliente da janela especificada.
  Normalize o tela canvas.

Etapas para que se inicialize um talker:
  Converta "{96749377-3391-11D2-9EE3-00C04F797396}" [CLSID_SpVoice] para um CLSID.
  Converta "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [IID_ISpVoice] para um IID.
  Call "ole32.dll" "CoCreateInstance" com \ https://docs.microsoft.com/pt-br/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance
  \Cria e inicializa por padrão um único objeto da classe associada a um CLSID especificado.
    O endereçamento deste CLSID [rclsid] \O CLSID associado aos dados e ao código que serão usados para criar o objeto.
    e 0 [pUnkOuter] \Se NULL, indica que o objeto não está sendo criado como parte de um agregado.
    e 7 [dwClsContext = CLSCTX_ALL] \ Contexto no qual o código que gerencia o objeto recém-criado será executado. Os valores são retirados da enumeração CLSCTX.
    \ https://docs.microsoft.com/pt-br/windows/desktop/api/wtypesbase/ne-wtypesbase-clsctx
    \CLSCTX_ALL = /*CLSCTX_INPROC_SERVER*/1 | /*CLSCTX_INPROC_HANDLER*/2 | /*CLSCTX_LOCAL_SERVER*/4 | /*CLSCTX_REMOTE_SERVER*/16;
    \CLSCTX_INPROC_SERVER = O código que cria e gerencia objetos dessa classe é uma DLL que é executada no mesmo processo do chamador da função que especifica o contexto da classe.
    \CLSCTX_INPROC_HANDLER = O código que gerencia objetos desta classe é um manipulador em processo. 
    \Esta é uma DLL que é executada no processo do cliente e implementa estruturas do lado do cliente desta classe quando as instâncias da classe são acessadas remotamente.
    \CLSCTX_LOCAL_SERVER = O código EXE que cria e gerencia objetos dessa classe é executado na mesma máquina, mas é carregado em um espaço de processo separado.
    \CLSCTX_REMOTE_SERVER Um contexto remoto. O código LocalServer32 ou LocalService que cria e gerencia objetos dessa classe é executado em um computador diferente.
    \https://docs.microsoft.com/pt-br/windows/win32/com/localservice
    \https://docs.microsoft.com/pt-br/windows/win32/com/localserver32
    e O endereçamento deste IID [riid] \Uma referência ao identificador da interface a ser usada para se comunicar com o objeto.
    e O endereçamento deste talker.[*ppv] \Endereço da variável de ponteiro que recebe o ponteiro de interface solicitado em riid. 
    \Após o retorno bem-sucedido, * ppv contém o ponteiro de interface solicitado. Em caso de falha, * ppv contém NULL.

Etapas para que se inicialize a janela do programa: \\ para inicializar a janela
  Atribua a magnitude [tamanho em bytes] dessa janela do programa class [estrutura] ao cbSize deste janela do programa class.
  Atribua 40 [CS_OWNDC + CS_DBLCLKS] ao style deste janela do programa class.
  \O valor CS_OWNDC aloca um contexto de dispositivo exclusivo para cada janela da classe.
  \O valor CS_DBLCLKS permite que o windows informe ao programa que aquele é um clique duplo (ao invés de dois cliques separados)
  Point o lpfnWndProc deste janela do programa class para rotina handle algum tipo de message com um janela do programa um message número um wParam e um lParam.
  \Isso define o procedimento da classe dessa janela como sendo WndProc
  \LPARAM é um typedef para um LONG_PTR que é um número inteiro (32 bits com sinal) no win32 e __int64 (64 bits com sinal) no x86_64.
  \WPARAM é um typedef para um UINT_PTR que é um número (32 bits sem sinal) no win32 e __int64 (64 bits sem sinal) no x86_64.
  Atribua o número identificador deste module ao hInstance desta janela do programa class.
  Atribua o caractere inicial deste nome deste module ao lpszClassName desta janela do programa class.
  Call "user32.dll" "RegisterClassExA" \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-registerclassexa
  \Registra uma classe de janela para uso subsequente em chamadas para a função CreateWindow ou CreateWindowEx.
  \Antes de criar uma janela, você deve registrar uma classe pra essa janela chamando a função RegisterClass.
  com o endereçamento deste janela do programa class. [*unnamedParam1] \Esta função requer um único parâmetro, que é um ponteiro para uma estrutura do tipo WNDCLASS.
  \Você deve preencher a estrutura com os valores apropriados antes de passá-la para a função.
  Call "user32.dll" "CreateWindowExA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-createwindowexa
  \Cria uma janela sobreposta, pop-up ou filha com um estilo de janela estendida; caso contrário, essa função é idêntica à função CreateWindow. 
  \Para obter mais informações sobre como criar uma janela e para obter descrições completas dos outros parâmetros de CreateWindowEx, consulte 
  \https://docs.microsoft.com/pt-br/windows/desktop/api/winuser/nf-winuser-createwindowa 
    0 [dwExStyle] \ o estilo opcional da janela, como transparências por exemplo. 
    \Veja mais detalhes em https://docs.microsoft.com/pt-br/windows/win32/winmsg/extended-window-styles
    e O caractere inicial deste nome deste module [lpClassName]  \O nome da classe da janela
    e O caractere inicial deste nome deste module  [lpWindowName] \O texto do título da janela
    e 2147483648 [dwStyle]  [-2147483648 = WS_POPUP 0x80000000] \\  aqui define o tipo da janela. Use valores em decimal;  
    [13565952  WS_OVERLAPPEDWINDOW 0x00CF0000]  
    \para isso Converta os valores hexadecimais da lista  https://www.autoitscript.com/autoit3/docs/appendix/GUIStyles.htm para decimal;
    \outra opção mais fácil é usar o site https://www.magnumdb.com/
    \ O valor na documentação do windows está em hexadecimal (ou em string), mas esse compilador usa números inteiros (longint). 
    \ Para colocar a barra padrão, use o valor 13565952
    e 0 [x] \posição horizontal inicial da janela
    e 0 [y] \posição vertical inicial da janela
    e A pixel largura desta tela [nWidth] \ A largura da janela em pixels;
    e A pixel altura desta tela  [nHeight] \ A altura da janela em pixels
    e 0 [hWndParent] \ opcional. Informa o número identificador do controle pai da janela (se existir) ou da janela em si
    e 0 [hMenu] \ Um identificador para um menu
    e O número identificador deste module [hInstance] \ Um identificador para a instância do módulo a ser associado à janela.
    e 0. [lpParam] \ aqui é um ponteiro que passa uma informação extra pra janela. Usamos um valor nulo porque não precisamos passar mais nenhuma informação.
  Call "user32.dll" "ShowWindow" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-showwindow
  \Define o estado de exibição da janela especificada.
    A janela principal do programa [hWnd] \Um identificador da janela.
    e 1 [nCmdShow = SW_SHOWNORMAL]. \Controla como a janela deve ser exibida.
    \SW_SHOWNORMAL Ativa e exibe uma janela. Se a janela for minimizada ou maximizada, o sistema a restaurará para seu tamanho e posição originais. 
    \Um aplicativo deve especificar este sinalizador ao exibir a janela pela primeira vez.

Etapas para que se inicialize winsock:
  Call "ws2_32.dll" "WSAStartup" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winsock/nf-winsock-wsastartup
  \A função WSAStartup inicia o uso da DLL Winsock por um processo.
    2 [wVersionRequired] \ a versão do Windows Sockets
    e O endereçamento desse wsadata. [lpWSAData] \ Um ponteiro para a estrutura de dados WSADATA que deve receber detalhes da implementação do Windows Sockets.

Um input é um evento.

Etapas para que se insira um byte Para uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua o byte a uma string.
  Insira a string ao caixa de texto.

Etapas para que se insira uma localização Para um polígono after um vértice:
  Se o polígono for inexistente, cancele.
  Crie um segundo vértice usando a localização.
  Insira o segundo vértice aos vértices deste polígono after o vértice.

Etapas para que se insira uma string Para uma segunda string antes de um byte#: \ verificar esse "para" aqui. tentar trocar para a presosição "em"
  Se a quantidade de caracteres desta string for 0, cancele.
  Isole o byte#.
  Limite o byte# para 1 e a quantidade de caracteres desta segunda string mais 1.
  Lance um subtexto sobre a segunda string. \ lado esquerdo
  Atribua o caractere inicial deste subtexto mais o byte# menos 2 ao caractere final deste subtexto.
  Lance um segundo subtexto sobre a segunda string. \ lado direito
  Atribua o caractere inicial deste segundo subtexto mais o byte# menos 1 ao caractere inicial deste segundo subtexto.
  Atribua a quantidade de caracteres desta segunda string mais a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Reassign um ponteiro usando a quantidade de caracteres agrupados.
  Atribua o ponteiro ao caractere inicial desse terceiro subtexto.
  Copie bytes desde o caractere inicial deste subtexto para o caractere inicial deste terceiro subtexto pelo quantidade de caracteres deste subtexto.
  Adicione a quantidade de caracteres deste subtexto para o caractere inicial deste terceiro subtexto.
  Copie bytes desde o caractere inicial desta string para o caractere inicial deste terceiro subtexto pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o caractere inicial deste terceiro subtexto.
  Copie bytes desde o caractere inicial deste segundo subtexto para o caractere inicial deste terceiro subtexto pelo quantidade de caracteres deste segundo subtexto.
  Unassign o caractere inicial desta segunda string. \ dont use atribua uma string a uma string para prevent extra allocating e copying
  Atribua o ponteiro ao caractere inicial desta segunda string.
  Atribua o caractere inicial desta segunda string mais a quantidade de caracteres agrupados menos 1 ao caractere final desta segunda string.

Etapas para que se insira uma string Para uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Atribua a quantidade de caracteres desta string desta linha de texto menos o cursor de texto número de coluna desta caixa de texto a um número.
  Atribua a string deste linha de texto a uma segunda string.
  Insira a string ao segunda string antes de o cursor de texto número de coluna desta caixa de texto.
  Converta a segunda string para umas linhas des textos.
  Atribua o last linha de texto destas linhas des textos a uma segunda linha de texto.
  Insira as linhas des textos A as linhas des textos desta caixa de texto antes de a linha de texto.
  Remove a linha de texto desde as linhas des textos desta caixa de texto.
  Destrua a linha de texto.
  Renumere as linhas des textos desta caixa de texto.
  Atribua o número da linha desta segunda linha de texto ao número de linhas do cursor desta caixa de texto.
  Atribua a quantidade de caracteres desta string desta segunda linha de texto menos o número ao cursor de texto número de coluna desta caixa de texto.
  Desvencilhe-se de a caixa de texto.

Etapas para que se insira uma coisa para umas coisas after uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se a segunda coisa for inexistente, anteponha a coisa para as coisas; saia.
  Insira a coisa a as coisas antes de o next desta segunda coisa.

Etapas para que se insira uma coisa para umas coisas antes de uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se as coisas estiverem vazias, posponha a coisa para as coisas; saia.
  Se a segunda coisa for inexistente, posponha a coisa para as coisas; saia.
  Se a segunda coisa for a first coisa destas coisas, anteponha a coisa para as coisas; saia.
  Atribua a coisa a uma new coisa.
  Atribua a segunda coisa a uma previous coisa.
  Atribua a new coisa ao next deste previous desta previous coisa.
  Atribua a previous coisa ao next desta new coisa.
  Atribua o previous desta previous coisa ao previous desta new coisa.
  Atribua o new coisa ao previous desta previous coisa.

Etapas para que se insira umas coisas para umas outras coisas after um coisa:
  Se a coisa for inexistente, anteponha  as coisas para a outras coisas; saia.
  Insira  as coisas ao outras coisas antes de o next coisa desta coisa.

Etapas para que se insira umas coisas para umas outras coisas antes de um coisa:
  Isole a coisa.
  Comece. [a executar o código abaixo]
    Atribua a first coisa destas coisas a uma segunda coisa.
    Se a segunda coisa for inexistente, cancele.
    Remove a segunda coisa desde as coisas.
    Insira a segunda coisa ao outras coisas antes de a coisa.
  Recomece. [percorra novamente o código acima]

Etapas para que se insira um vértice para um polígono after um segundo vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono after o segundo vértice.

Etapas para que se insira um vértice para um polígono sob uma localização:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha um segundo vértice desde os vértices deste polígono.
    Se o segundo vértice for inexistente, cancele.
    Se o next deste segundo vértice for inexistente, cancele.
    Atribua a localização deste segundo vértice e a localização deste next deste segundo vértice a uma linha reta.
    Se a localização não estiver sobre a linha reta, recomece.
  Insira o vértice aos vértices deste polígono after o segundo vértice.

Etapas para que se insira um vértice para um polígono antes de um segundo vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono antes de o segundo vértice.

Etapas para que se intersect uma caixa com uma segunda caixa usando um terceiro caixa:
  \ caixas does not touch
  Limpe o terceiro caixa.
  Se a coordenada X do canto superior esquerdo desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, cancele.
  Se a coordenada Y do canto superior esquerdo desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, cancele.
  Se a coordenada X do canto inferior direito desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, cancele.
  Se a coordenada Y do canto inferior direito desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, cancele.
  \ caixas touch
  Atribua a caixa ao terceiro caixa.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, atribua a coordenada X do canto superior esquerdo desta segunda caixa à coordenada X do canto superior esquerdo desta terceiro caixa.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, atribua a coordenada Y do canto superior esquerdo desta segunda caixa à coordenada Y do canto superior esquerdo desta terceiro caixa.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, atribua a coordenada X do canto inferior direito desta segunda caixa à coordenada X do canto inferior direito desta terceiro caixa.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta terceiro caixa.

 \Etapas para que se invert um detector:
\ see "reverse um detector"
\Se o detector for yes, atribua no ao detector; saia.
 \Atribua yes ao detector.

Um Endereço IP é um conjunto com
  Um número, 
  Uma string. 

Um grupo data/hora de criação é uma string.

Um item é um conjunto com
  Uma categoria [pasta, arquivo, etc], \ 
  Um endereço completo, 
  Um endereço da pasta, 
  Um designador, 
  Uma extensão,
  Um size, 
  Um grupo data/hora de criação,
  Um WIN32FINDDATA e 
  Um número identificador.

Etapas para que se jump o cursor de texto para a esquerda em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Mova o cursor de texto para a esquerda para algum tipo de non-noise byte na caixa de texto.
  Se o cursor de texto número de coluna desta caixa de texto for 1, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Atribua o caractere inicial desta string desta linha de texto mais o cursor de texto número de coluna desta caixa de texto menos 2 a um ponteiro do byte .
  Se o conteúdo deste ponteiro do byte for alfanumérico, mova o cursor de texto para a esquerda para algum tipo de non-alfanumérico byte na caixa de texto.
  Se o conteúdo deste ponteiro do byte não for alfanumérico, mova o cursor de texto para a esquerda para algum tipo de non-symbolic byte na caixa de texto.
  Mova o cursor de texto para a esquerda para algum tipo de non-noise byte na caixa de texto.

Etapas para que se jump o cursor de texto para a direita em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Mova o cursor de texto para a direita para algum tipo de non-noise byte na caixa de texto.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Se o cursor de texto número de coluna desta caixa de texto é a quantidade de caracteres desta string desta linha de texto, cancele.
  Atribua o caractere inicial desta string desta linha de texto mais o cursor de texto número de coluna desta caixa de texto menos 1 a um ponteiro do byte .
  Se o conteúdo deste ponteiro do byte é alfanumérico, mova o cursor de texto para a direita para algum tipo de non-alfanumérico byte na caixa de texto.
  Se o conteúdo deste ponteiro do byte não for alfanumérico, mova o cursor de texto para a direita para algum tipo de non-symbolic byte na caixa de texto.
  Mova o cursor de texto para a direita para algum tipo de non-noise byte na caixa de texto.

Um key é um número.

Um kilobyte é 1024 units.

Um categoria é uma string.

Um lParam é um número.

Um folha modo paisagem é uma folha.

O tamanho de letra grande é um tamanho da letra.

O maior número é 2147483647.

Um mínimo múltiplo comum é um número.

Um clique é um input.



Uma quantidade de caracteres é uns twips.

Um tamanho da letra é uns twips. \ indicates actual altura of um typical uppercase letra

Uma letra é um byte.

O dicionário léxico é uma coisa com um catálogo.

Etapas para que se clareie uma cor por um quantia:
  Adicione o quantia para a luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se clareie uma cor por uns percentual;
Etapas para que se clareie uma cor aproximadamente uns percentual;
Etapas para que se clareie uma cor por aproximadamente uns percentual;
Etapas para que se clareie uma cor uns percentual:
  Atribua a luminosidade desta cor mais o percentual à luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se clareie o current cor aproximadamente uns percentual:
  Clareie a cor deste contexto pelo percentual.

Etapas para que se clareie um matiz por uns degrees:
  Adicione o degrees para o matiz.

Etapas para que se clareie um matiz por uns points:
  Converta o matiz para uns segunda points.
  Adicione o points para a segunda points.
  Converta a segunda points para o matiz.



Etapas para que se limite uma caixa para uma segunda caixa:
  Limite a coordenada X do canto superior esquerdo desta caixa para a coordenada X do canto superior esquerdo desta segunda caixa e a coordenada X do canto inferior direito desta segunda caixa.
  Limite a coordenada Y do canto superior esquerdo desta caixa para a coordenada Y do canto superior esquerdo desta segunda caixa e a coordenada Y do canto inferior direito desta segunda caixa.
  Limite a coordenada X do canto inferior direito desta caixa para a coordenada X do canto superior esquerdo desta segunda caixa e a coordenada X do canto inferior direito desta segunda caixa.
  Limite a coordenada Y do canto inferior direito desta caixa para a coordenada Y do canto superior esquerdo desta segunda caixa e a coordenada Y do canto inferior direito desta segunda caixa.

Etapas para que se limite o cursor de texto em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Limite o número de linhas do cursor desta caixa de texto para 1 e a contagem de linhas desta caixa de texto.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Limite o cursor de texto número de coluna desta caixa de texto para 1 e a quantidade de caracteres desta string desta linha de texto.

Etapas para que se limite um número para um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, atribua o segundo número ao número; saia.
  Se o número for maior do que o terceiro número, atribua o terceiro número ao número.

Etapas para que se limite a origem of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Limite a coordenada X desta caixa de texto para o menor número e a margem desta caixa de texto.
  Atribua a contagem de linhas desta caixa de texto menos 1 times a altura da linha desta caixa de texto a um número.
  Limite a coordenada Y desta caixa de texto para - o número e 0.

Etapas para que se limite uma localização para uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização.
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização.

Etapas para que se limite umas caixas des textos para uma contagem:
  Atribua a contagem destas caixas des textos a uma segunda contagem.
  Comece. [a executar o código abaixo]
    Se a segunda contagem for menor do que ou igual à contagem, cancele.
    Atribua o first caixa de texto destas caixas des textos a uma caixa de texto.
    Remove a caixa de texto desde as caixas des textos.
    Destrua a caixa de texto.
    Subtraia 1 desde a segunda contagem.
  Recomece. [percorra novamente o código acima]

Uma localização inicial é uma localização.
Uma localização final é uma localização.

Uma linha reta é um conjunto com \ linha, traço, risco, traçado, listra
  Uma localização inicial e 
  Uma localização final.

Etapas para que se liste umas escolhas em uma caixa;
Etapas para que se pinte umas escolhas em uma caixa:
  \Pinte really fast. ***
  Obtenha uma [first/next] escolha desde as escolhas.
  Se a escolha estiver sumido do mapa [because we have drawn them all], cancele.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais 24 pixels à coordenada X do canto superior esquerdo desta escolha.
  Atribua a coordenada X do canto inferior direito desta caixa menos 24 pixels à coordenada X do canto inferior direito desta escolha.
  Se a escolha for o first desta escolha, atribua a coordenada Y do canto superior esquerdo desta caixa mais 24 pixels à coordenada Y do canto superior esquerdo desta escolha.
  Se a escolha não for o first desta escolha, atribua a coordenada Y do canto inferior direito deste previous desta escolha à coordenada Y do canto superior esquerdo desta escolha.
  Atribua a coordenada Y do canto superior esquerdo desta escolha mais 24 pixels à coordenada Y do canto inferior direito desta escolha.
  \Pinte a caixa desta escolha com a cor púrpura. \ temp ***
  Pinte o nome desta escolha na caixa desta escolha com a cor deste contexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste umas escolhas em uma caixa com uma cor;
Etapas para que se pinte umas escolhas em uma caixa com uma cor:
  Atribua a cor à cor deste contexto.
  Pinte o escolhas na caixa.

Etapas para que se carregue o dicionário léxico:
  Se o dicionário léxico não for inexistente, cancele.
  Extraia um endereço da pasta desde o endereço completo deste module.
  Comece. [a executar o código abaixo]
    Se o endereço da pasta estiver em branco, cancele.
    Atribua o endereço da pasta seguido de "dicionário léxico\" a um endereço completo.
    Se o endereço completo estiver no sistema de arquivos, Carregue o dicionário léxico usando o endereço completo; saia.
    Extraia o endereço da pasta desde o endereço da pasta.
  Recomece. [percorra novamente o código acima]

Etapas para que se carregue o dicionário léxico usando um trecho:
  Se o dicionário léxico for inexistente, crie o dicionário léxico.
  Lance um percorredor sobre o trecho.
  Comece. [a executar o código abaixo]
    Mova o percorredor (catálogo dicionário léxico rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Catalogue o segmento inicial deste percorredor no catálogo deste dicionário léxico.
  Recomece. [percorra novamente o código acima]

Etapas para que se carregue o dicionário léxico usando um endereço completo:
  Obtenha um item desde o endereço completo.
  Se o item não for encontrado, cancele.
  Se a categoria deste item não for "arquivo", recomece.
  Read o endereço completo deste item a um trecho.
  Se o erro do fluxo de entrada/saída não estiver em branco, recomece.
  Carregue o dicionário léxico usando o trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se localize uma caixa usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a caixa usando o par de números.

Etapas para que se localize uma localização usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a localização usando o par de números.

Etapas para que se lock um gpBitmap usando um BitmapData (espaço de cor RGB de 24 bits):
  Atribua o gprect deste gpBitmap a um gprect.
  Call "gdiplus.dll" "GdipBitmapLockBits" com \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusheaders/nf-gdiplusheaders-bitmap-lockbits
  \Bloqueia uma parte retangular deste bitmap e fornece um buffer temporário que você pode usar para ler ou gravar dados de pixel em um formato especificado. 
  \Todos os dados de pixel que você grava no buffer são copiados para o objeto Bitmap quando você chama GdipBitmapUnlockBits.
   o gpBitmap [bitmap] \ Ponteiro para o objeto Bitmap.
   e o endereçamento deste gprect [*rect] \ Ponteiro para um retângulo que especifica a parte do bitmap a ser bloqueada.
   e 3 [flags = ImageLockModeRead + ImageLockModeWrite] 
   \ Conjunto de sinalizadores que especificam se a parte bloqueada do bitmap está disponível para leitura ou gravação e se o chamador já alocou um buffer. 
   \Sinalizadores individuais são definidos na enumeração ImageLockMode.
   \3 Especifica que uma parte da imagem está bloqueada para eitura e gravação.
   \https://docs.microsoft.com/pt-br/windows/desktop/api/gdiplusimaging/ne-gdiplusimaging-imagelockmode
   e 137224 [format = PixelFormat24bppRGB] \ Número inteiro que especifica o formato dos dados de pixel no buffer temporário. 
   \O formato de pixel do buffer temporário não precisa ser igual ao formato de pixel deste objeto Bitmap.
   e o endereçamento deste BitmapData. [lockedBitmapData] \Ponteiro para um objeto BitmapData.

\Um logbrush é um conjunto com \ documentar
\Um número denominado lbstyle,
\Um código da cor denominado lbcolor,
\Um número denominado lbhatch.

Etapas para que se lowercase qualquer trecho selecionado em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se a linha de texto of a caixa de texto não estiver selecionado, recomece.
    Lance um subtexto sobre qualquer trecho selecionado na linha de texto of a caixa de texto.
    Lowercase o subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se lowercase um byte:
  \Para letras não acentuadas basta que se 
  \adicione 32 para cada letra entre "A" and "Z" da string.
  Translate o byte usando o tabela de caracteres minúsculos ASCII .

Etapas para que se lowercase o character depois de um finger e atribua it para uma string:
  Se o finger for inexistente, cancele.
  Atribua o conteúdo deste finger à string.
  Lowercase a string.

Etapas para que se lowercase uma string:
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Lowercase o conteúdo deste caractere inicial deste subtexto.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se lowercase uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, pare.
    Lowercase a string deste linha de texto.
  Recomece. [percorra novamente o código acima]
  Wrap a caixa de texto.

A janela principal do programa é um janela do programa.

Etapas para que se faça uma fração com um número e um segundo número:
  Atribua o número ao numerador desta fração.
  Atribua o segundo número ao denominador desta fração.

Etapas para que se faça um par de números racionais usando uma caixa e uma segunda caixa;
Etapas para que se faça uma par de números fracionários usando uma caixa e uma segunda caixa:
  Atribua o x-extent desta caixa à numerador desta fração deste par de números fracionários.
  Atribua o x-extent desta segunda caixa ao denominador desta fração deste par de números fracionários.
  Atribua o y-extent desta caixa ao numerador desta segunda fração deste par de números fracionários.
  Atribua o y-extent desta segunda caixa ao denominador desta segunda fração deste par de números fracionários.

Um margem é um número.

Etapas para que se cubra internamente uma caixa:
  Crie um hRgn usando a caixa.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente uma elipse:
  Crie um hRgn usando a elipse.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-extselectcliprgn
  \A função ExtSelectClipRgn combina a região especificada com a região de recorte atual usando o modo especificado.
    O quadro atual [hdc] \Um identificador para o contexto do dispositivo.
    e O hRgn [hrgn] \Um identificador para a região a ser selecionada.
    e 4 [mode = RGN_DIFF]. \A operação a ser executada.
    \RGN_DIFF = A nova região de recorte combina as áreas da região de recorte atual com as áreas excluídas da região identificada por hrgn.

Etapas para que se cubra internamente um polígono:
  Crie um hRgn usando o polígono.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Um mask é um texto hexadecimal.

Etapas para que se cubra somente dentro de uma caixa:
  Exponha tudo.
  Cubra internamente a caixa.

Etapas para que se cubra somente dentro de uma elipse:
  Exponha tudo.
  Cubra internamente a elipse.

Etapas para que se cubra somente dentro de um polígono:
  Exponha tudo.
  Cubra internamente o polígono.

Etapas para que se cubra somente dentro de uma caixa arredondada:
  Exponha tudo.
  Cubra internamente a caixa arredondada.

Etapas para que se cubra somente fora de uma caixa:
  Exponha tudo.
  Cubra externamente a caixa.

Etapas para que se cubra somente fora de uma elipse:
  Exponha tudo.
  Cubra externamente a elipse.

Etapas para que se cubra somente fora de um polígono:
  Exponha tudo.
  Cubra externamente o polígono.

Etapas para que se cubra somente fora de uma caixa arredondada:
  Exponha tudo.
  Cubra externamente a caixa arredondada.

Etapas para que se cubra externamente uma caixa:
  Crie um hRgn usando a caixa.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente uma elipse:
  Crie um hRgn usando a elipse.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-extselectcliprgn
  \A função ExtSelectClipRgn combina a região especificada com a região de recorte atual usando o modo especificado.
    O quadro atual [hdc] \Um identificador para o contexto do dispositivo.
    e O hRgn [hrgn] \ Uma alça para a região a ser selecionada.
    e 1 [mode = RGN_AND]. \A operação a ser executada.
    \RGN_AND = A nova região de recorte combina as áreas sobrepostas da região de recorte atual e a região identificada por hrgn.

Etapas para que se cubra externamente um polígono:
  Crie um hRgn usando o polígono.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Cubra externamente o hRgn.
  Destrua o hRgn.

O max caixa de texto desfeitos é uma contagem igual a 32.

O tamanho de letra médio é um tamanho da letra.

O memory canvas é um canvas.

Etapas para que se minimize um janela do programa:
  Call "user32.dll" "ShowWindow" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-showwindow
  \Define o estado de exibição da janela especificada.
    A janela do programa [hWnd] \Uma maçaneta para a janela.
    e 6 [nCmdShow = SW_MINIMIZE]. \ Controla como a janela deve ser exibida.
    \SW_MINIMIZE = Minimiza a janela especificada e ativa a próxima janela de nível superior no modo de ordenação Z.

Etapas para que se mirror o gpBitmap em uma imagem:
  Se a imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Mirror o gpBitmap desta imagem.

Etapas para que se mirror um GpImage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusheaders/nf-gdiplusheaders-image-rotateflip
  \ Gira e vira a imagem.
  \A função GdipImageRotateFlip gira e/ou inverte a imagem. É a imagem que sofre a transformação e não o gráfico no qual será exibida.
   \O ângulo e a inversão são definidos por uma das constantes da enumeração RotateFlipType .
    O GpImage [*image] \Ponteiro para o objeto Imagem.
    e 4 [rotateFlipType = RotateNoneFlipX]. \Elemento da enumeração RotateFlipType que especifica o tipo de rotação e o tipo de inversão.
    \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusimaging/ne-gdiplusimaging-rotatefliptype
    \Tipo de rotação e inversão:
    \0 - Sem rotação e sem inversão (uma rotação de 180 graus, uma inversão horizontal e, em seguida, uma inversão vertical)
    \1 - Uma rotação de 90 graus sem inversão (uma rotação de 270 graus, uma inversão horizontal e depois uma inversão vertical)
    \2 - Uma rotação de 180 graus sem inversão (sem rotação, uma inversão horizontal seguida de uma inversão vertical)
    \3 - Uma rotação de 270 graus sem inversão (uma rotação de 90 graus, uma inversão horizontal e depois uma inversão vertical)
    \4 - Sem rotação e inversão horizontal (rotação de 180 graus seguida de inversão vertical)
    \5 - Uma rotação de 90 graus seguida por uma inversão horizontal (uma rotação de 270 graus seguida por uma inversão vertical)
    \6 - Uma rotação de 180 graus seguida por uma inversão horizontal (sem rotação e inversão vertical)
    \7 - Uma rotação de 270 graus seguida por uma inversão horizontal (uma rotação de 90 graus seguida por uma inversão vertical)


Etapas para que se mirror uma imagem:
  Se a imagem for inexistente, cancele.
  Atribua a coordenada X deste centro desta caixa desta imagem menos a coordenada X deste centro desta caixa intacta desta imagem ao número X desse par de números.
  Multiplique o número X deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Mirror o gpBitmap no imagem.

Etapas para que se mova o anchor para o lado esquerdo para algum tipo de non-alfanumérico byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o anchor número da linha desta caixa de texto e a caixa de texto.
  Comece. [a executar o código abaixo]
    Se o anchor número de coluna desta caixa de texto for 1, cancele.
    Atribua o caractere inicial desta string desta linha de texto mais o anchor número de coluna desta caixa de texto menos 2 a um ponteiro do byte .
    Se o conteúdo deste ponteiro do byte não for alfanumérico, cancele.
    Subtraia 1 desde o anchor número de coluna desta caixa de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova o cursor de texto para baixo em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Adicione 1 para o número de linhas do cursor desta caixa de texto.
  Limite o cursor de texto na caixa de texto.

Etapas para que se mova o cursor de texto para baixo one página em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Adicione as linhas des textos/box desta caixa de texto para o número de linhas do cursor desta caixa de texto.
  Subtraia 1 desde o número de linhas do cursor desta caixa de texto.
  Limite o cursor de texto na caixa de texto.

Etapas para que se mova o cursor de texto para o first byte of o current linha de texto of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua 1 ao cursor de texto número de coluna desta caixa de texto.

Etapas para que se mova o cursor de texto para o first byte of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua 1 e 1 ao cursor de texto desta caixa de texto.

Etapas para que se mova o cursor de texto para o last byte of o current linha de texto of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Atribua a quantidade de caracteres desta string desta linha de texto ao cursor de texto número de coluna desta caixa de texto.

Etapas para que se mova o cursor de texto para o last byte of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua a contagem de linhas desta caixa de texto ao número de linhas do cursor desta caixa de texto.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Atribua a quantidade de caracteres desta string desta linha de texto ao cursor de texto número de coluna desta caixa de texto.

Etapas para que se mova o cursor de texto para a esquerda para algum tipo de non-alfanumérico byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Comece. [a executar o código abaixo]
    Se o cursor de texto número de coluna desta caixa de texto for 1, cancele.
    Atribua o caractere inicial desta string desta linha de texto mais o cursor de texto número de coluna desta caixa de texto menos 2 a um ponteiro do byte .
    Se o conteúdo deste ponteiro do byte não for alfanumérico, cancele.
    Subtraia 1 desde o cursor de texto número de coluna desta caixa de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova o cursor de texto para a esquerda para algum tipo de non-noise byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Comece. [a executar o código abaixo]
    Se o cursor de texto número de coluna desta caixa de texto for 1, cancele.
    Atribua o caractere inicial desta string desta linha de texto mais o cursor de texto número de coluna desta caixa de texto menos 2 a um ponteiro do byte .
    Se o conteúdo deste ponteiro do byte não for irrelevante, cancele.
    Subtraia 1 desde o cursor de texto número de coluna desta caixa de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova o cursor de texto para a esquerda para algum tipo de non-symbolic byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Comece. [a executar o código abaixo]
    Se o cursor de texto número de coluna desta caixa de texto for 1, cancele.
    Atribua o caractere inicial desta string desta linha de texto mais o cursor de texto número de coluna desta caixa de texto menos 2 a um ponteiro do byte .
    Se o conteúdo deste ponteiro do byte não for symbolic, cancele.
    Subtraia 1 desde o cursor de texto número de coluna desta caixa de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova o cursor de texto para a esquerda em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Subtraia 1 desde o cursor de texto número de coluna desta caixa de texto.
  Limite o cursor de texto na caixa de texto.

Etapas para que se mova o cursor de texto para a direita para algum tipo de non-alfanumérico byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Comece. [a executar o código abaixo]
    Se o cursor de texto número de coluna desta caixa de texto é a quantidade de caracteres desta string desta linha de texto, cancele.
    Atribua o caractere inicial desta string desta linha de texto mais o cursor de texto número de coluna desta caixa de texto menos 1 a um ponteiro do byte .
    Se o conteúdo deste ponteiro do byte não for alfanumérico, cancele.
    Adicione 1 para o cursor de texto número de coluna desta caixa de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova o cursor de texto para a direita para algum tipo de non-noise byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Comece. [a executar o código abaixo]
    Se o cursor de texto número de coluna desta caixa de texto é a quantidade de caracteres desta string desta linha de texto, cancele.
    Atribua o caractere inicial desta string desta linha de texto mais o cursor de texto número de coluna desta caixa de texto menos 1 a um ponteiro do byte .
    Se o conteúdo deste ponteiro do byte não for irrelevante, cancele.
    Adicione 1 para o cursor de texto número de coluna desta caixa de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova o cursor de texto para a direita para algum tipo de non-symbolic byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Comece. [a executar o código abaixo]
    Se o cursor de texto número de coluna desta caixa de texto é a quantidade de caracteres desta string desta linha de texto, cancele.
    Atribua o caractere inicial desta string desta linha de texto mais o cursor de texto número de coluna desta caixa de texto menos 1 a um ponteiro do byte .
    Se o conteúdo deste ponteiro do byte não for symbolic, cancele.
    Adicione 1 para o cursor de texto número de coluna desta caixa de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova o cursor de texto para a direita em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Adicione 1 para o cursor de texto número de coluna desta caixa de texto.
  Limite o cursor de texto na caixa de texto.

Etapas para que se mova o cursor de texto para cima em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Subtraia 1 desde o número de linhas do cursor desta caixa de texto.
  Limite o cursor de texto na caixa de texto.

Etapas para que se mova o cursor de texto para cima one página em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Subtraia as linhas des textos/box desta caixa de texto desde o número de linhas do cursor desta caixa de texto.
  Adicione 1 para o número de linhas do cursor desta caixa de texto.
  Limite o cursor de texto na caixa de texto.

Etapas para que se mova um finger over um número:
  Se o finger for inexistente, cancele.
  Adicione 1 para o finger.

Etapas para que se mova uma imagem para baixo uns twips:
  Mova a imagem usando 0 e os twips.

Etapas para que se mova uma imagem usando um par de números:
  Mova a imagem usando o número X deste par de números e o número Y deste par de números.

Etapas para que se mova uma imagem usando uns x-twips e uns y-twips:
  Se a imagem for inexistente, cancele.
  Mova a caixa desta imagem usando o x-twips e o y-twips.
  Mova a caixa intacta desta imagem usando o x-twips e o y-twips.

Etapas para que se mova uma imagem uns twips para a esquerda;
Etapas para que se mova uma imagem para a esquerda uns twips:
  Mova a imagem usando - os twips e 0.

Etapas para que se mova uma imagem para a direita uns twips:
  Mova a imagem usando os twips e 0.

Etapas para que se mova uma imagem para uma localização:
  Se a imagem for inexistente, cancele.
  Obtenha um difference entre a localização e o canto superior esquerdo desta imagem.
  Mova a imagem usando a difference.

Etapas para que se mova uma imagem para cima uns twips:
  Mova a imagem usando 0 e - os twips.

Etapas para que se mova uns squares:
  Mova o tamanho do quadrado times o squares dividido por 1 square. \ squares são scaled para cima por precision hence o division sob o end

Etapas para que se mova uns squares diagonally;
Etapas para que se mova uns squares slantways:
  Mova o tamanho do quadrado times o squares times o raiz de dois dividido por 1 square. \ squares são scaled para cima por precision hence o division sob o end

Etapas para que se mova um subtexto usando um número:
  Adicione o número para o caractere inicial deste subtexto.
  Adicione o número para o caractere final deste subtexto.

Etapas para que se mova uma coisa desde umas coisas para umas outras coisas:
  Se a coisa for inexistente, cancele.
  Isole a coisa.
  Remove a coisa desde as coisas.
  Posponha a coisa para a outras coisas.

Etapas para que se mova umas coisas para umas outras coisas:
  Atribua a first coisa destas coisas ao first coisa destas outras coisas.
  Atribua a last coisa destas coisas ao last coisa destas outras coisas.
  Limpe as coisas.

Etapas para que se mova uma janela do programa para a esquerda:
  Call "user32.dll" "GetWindowRect" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getwindowrect
  \ Recupera as dimensões do retângulo delimitador da janela especificada.
  \ As dimensões são fornecidas em coordenadas de tela que são relativas ao canto superior esquerdo da tela.
    A janela principal do programa [hWnd] \Um identificador para a janela.
    e O endereçamento dessa caixa. [lpRect] 
    \Um ponteiro para uma estrutura RECT que recebe as coordenadas da tela dos cantos superior esquerdo e inferior direito da janela.
    \ https://docs.microsoft.com/pt-br/windows/win32/api/windef/ns-windef-rect
  Subtraia a pixel largura desta tela desde a coordenada X do canto superior esquerdo desta caixa.
  Call "user32.dll" "MoveWindow" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-movewindow
  \Altera a posição e as dimensões da janela especificada. Para uma janela de nível superior, a posição e as dimensões são relativas ao canto superior esquerdo da tela. 
  \Para uma janela-filha, eles são relativos ao canto superior esquerdo da área do cliente da janela-pai.
    A janela do programa [hWnd] \ Um identificador para a janela.
    e A coordenada X do canto superior esquerdo desta caixa [X] \ A nova posição do lado esquerdo da janela.
    e A coordenada Y do canto superior esquerdo desta caixa [Y] \ A nova posição da parte superior da janela.
    e A pixel largura desta tela [nWidth] \ A nova largura da janela.
    e A pixel altura desta tela [nHeight] \ A nova altura da janela.
    e 1. [bRepaint] \ Indica se a janela deve ser repintada. Se este parâmetro for TRUE, a janela receberá uma mensagem.

Etapas para que se mova uma janela do programa para a direita:
  Call "user32.dll" "GetWindowRect" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getwindowrect
  \ Recupera as dimensões do retângulo delimitador da janela especificada.
  \ As dimensões são fornecidas em coordenadas de tela que são relativas ao canto superior esquerdo da tela.
    A janela principal do programa [hWnd] \Um identificador para a janela.
    e O endereçamento dessa caixa. [lpRect] 
    \Um ponteiro para uma estrutura RECT que recebe as coordenadas da tela dos cantos superior esquerdo e inferior direito da janela.
    \ https://docs.microsoft.com/pt-br/windows/win32/api/windef/ns-windef-rect
  Adicione a pixel largura desta tela para a coordenada X do canto superior esquerdo desta caixa. 
  Call "user32.dll" "MoveWindow" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-movewindow
  \Altera a posição e as dimensões da janela especificada. Para uma janela de nível superior, a posição e as dimensões são relativas ao canto superior esquerdo da tela. 
  \Para uma janela-filha, eles são relativos ao canto superior esquerdo da área do cliente da janela-pai.
    A janela do programa [hWnd] \ Um identificador para a janela.
    e A coordenada X do canto superior esquerdo desta caixa [X] \ A nova posição do lado esquerdo da janela.
    e A coordenada Y do canto superior esquerdo desta caixa [Y] \ A nova posição da parte superior da janela.
    e A pixel largura desta tela [nWidth] \ A nova largura da janela.
    e A pixel altura desta tela [nHeight] \ A nova altura da janela.
    e 1. [bRepaint] \ Indica se a janela deve ser repintada. Se este parâmetro for TRUE, a janela receberá uma mensagem.

Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números racionais;
Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números fracionários:
  Se a imagem for inexistente, cancele.
  Mova a caixa intacta desta imagem usando o par de números fracionários e o canto superior esquerdo desta caixa desta imagem.
  Redimensione a caixa intacta desta imagem usando o par de números fracionários.
  Redimensione a caixa desta imagem usando o par de números fracionários.
  Se a coordenada X do canto inferior direito desta imagem for menor do que a coordenada X do canto superior esquerdo desta imagem, mirror o gpBitmap no imagem.
  Se a coordenada Y do canto inferior direito desta imagem for menor do que a coordenada Y do canto superior esquerdo desta imagem, flip o gpBitmap no imagem.

Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um twip par de números:
  Se a imagem for inexistente, cancele.
  Atribua a caixa desta imagem a uma caixa.
  Redimensione a caixa usando o twip par de números.
  Faça uma par de números fracionários usando a caixa e a caixa desta imagem.
  redimensione cuidadosamente [sem perder qualidade] a imagem usando o par de números fracionários.

Etapas para que se normalize um ângulo:
  Divida o ângulo por 3600 usando um quociente e o ângulo.

Etapas para que se normalize uma caixa:
  Se a coordenada X do canto inferior direito desta caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, permute a coordenada X do canto superior esquerdo desta caixa com a coordenada X do canto inferior direito desta caixa.
  Se a coordenada Y do canto inferior direito desta caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, permute a coordenada Y do canto superior esquerdo desta caixa com a coordenada Y do canto inferior direito desta caixa.

Etapas para que se normalize um canvas:
  Call "gdi32.dll" "SetGraphicsMode" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setgraphicsmode
  \A função SetGraphicsMode define o modo gráfico para o contexto de dispositivo especificado.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e 2. [iMode = GM_ADVANCED] \O modo gráfico. 
    \GM_ADVANCED = Define o modo gráfico avançado que permite transformações mundiais. 
    \Este valor deve ser especificado se o aplicativo irá definir ou modificar a transformação do mundo para o contexto de dispositivo especificado. 
    \Neste modo, todos os gráficos, incluindo saída de texto, estão totalmente em conformidade com a transformação de mundo para o dispositivo especificado no contexto do dispositivo.
  Call "gdi32.dll" "SetBkMode" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setbkmode
  \A função SetBkMode define o modo de mistura de plano de fundo do contexto de dispositivo especificado. 
    O canvas [hdc] \Um identificador para o contexto do dispositivo. 
    \O modo de mistura de plano de fundo é usado com texto, pincéis hachurados e estilos de caneta que não são linhas sólidas.
    e 1. [mode = TRANSPARENT] \ O modo do plano de fundo.
    \TRANSPARENT = O fundo permanece intocado.
  Call "gdi32.dll" "SetMapMode" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setmapmode
  \A função SetMapMode define o modo de mapeamento do contexto de dispositivo especificado. 
  \O modo de mapeamento define a unidade de medida usada para transformar unidades de espaço de página em unidades de espaço de dispositivo 
  \e também define a orientação dos eixos x e y do dispositivo.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e 8. [iMode = MM_ANISOTROPIC ] \O novo modo de mapeamento.
    \MM_ANISOTROPIC = As unidades lógicas são mapeadas para unidades arbitrárias com eixos escalonados arbitrariamente. 
    \Use as funções SetWindowExtEx e SetViewportExtEx para especificar as unidades, orientação e escala.
  Call "gdi32.dll" "SetViewportOrgEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setviewportorgex
  \A função SetViewportOrgEx especifica qual ponto do dispositivo mapeia para a origem da janela (0,0).
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e 0 [x] \A coordenada x, em unidades de dispositivo, da nova origem da janela de exibição.
    e 0 [y] \A coordenada y, em unidades de dispositivo, da nova origem da janela de exibição.
    e nil. [lppt] \Um ponteiro para uma estrutura POINT que recebe a origem da viewport anterior, nas coordenadas do dispositivo. 
    \Se lpPoint for NULL, este parâmetro não será usado.
    \ https://docs.microsoft.com/pt-br/previous-versions/dd162805(v=vs.85)
  Call "gdi32.dll" "SetViewportExtEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setviewportextex
  \A função SetViewportExtEx define as extensões horizontal e vertical da janela de visualização para um contexto de dispositivo usando os valores especificados.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O ppi [x] \A extensão horizontal, em unidades de dispositivo, da janela de visualização.
    e O ppi [y] \A extensão vertical, em unidades de dispositivo, da janela de visualização.
    e nil. [lpsz] \Um ponteiro para uma estrutura SIZE que recebe as extensões da janela de visualização anterior, em unidades de dispositivo. 
    \Se lpSize for NULL, este parâmetro não será usado.
    \ https://docs.microsoft.com/pt-br/previous-versions/dd145106(v=vs.85)
  Call "gdi32.dll" "SetWindowOrgEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setwindoworgex
  \A função SetWindowOrgEx especifica qual ponto da janela mapeia para a origem da janela de visualização (0,0).
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e 0 [x] \A coordenada x, em unidades lógicas, da nova origem da janela.
    e 0 [y] \A coordenada y, em unidades lógicas, da nova origem da janela.
    e nil. [lppt] \Um ponteiro para uma estrutura POINT que recebe a origem anterior da janela, em unidades lógicas. 
    \Se lpPoint for NULL, este parâmetro não será usado.
    \ https://docs.microsoft.com/pt-br/previous-versions/dd162805(v=vs.85)
  Call "gdi32.dll" "SetWindowExtEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setwindowextex
  \ A função SetWindowExtEx define as extensões horizontal e vertical da janela para um contexto de dispositivo usando os valores especificados.
    O canvas [hdc] \Um identificador para o contexto do dispositivo.
    e O tpi [x] \A extensão horizontal da janela em unidades lógicas.
    e O tpi [y] \A extensão vertical da janela em unidades lógicas.
    e nil. [lpsz] \Um ponteiro para uma estrutura SIZE que recebe as extensões da janela anterior, em unidades lógicas. 
    \Se lpSize for NULL, este parâmetro não será usado.
    \ https://docs.microsoft.com/pt-br/previous-versions/dd145106(v=vs.85)

Etapas para que se normalize uma elipse:
  Normalize a caixa desta elipse.

Etapas para que se normalize uma fração e uma segunda fração:
  Obtenha um mínimo múltiplo comum usando o denominador desta fração e o denominador desta segunda fração.
  Multiplique o numerador desta fração pelo mínimo múltiplo comum dividido pelo denominador desta fração.
  Atribua o mínimo múltiplo comum ao denominador desta fração.
  Multiplique o numerador desta segunda fração pelo mínimo múltiplo comum dividido pelo denominador desta segunda fração.
  Atribua o mínimo múltiplo comum ao denominador desta segunda fração.

Etapas para que se normalize uma orientação:
  Divida a orientação por 3840 usando um quociente e um resto.
  Atribua o resto à orientação.
  Se a orientação for menor do que 0, adicione 3840 para a orientação.

Etapas para que se normalize um linha reta horizontal:
  Se a localização final desta linha reta for menor do que a localização inicial desta linha reta, permute a localização final desta linha reta com a localização inicial desta linha reta.

Etapas para que se normalize um matiz:
  Divida o matiz por 3600 usando um quociente e um resto.
  Atribua o resto ao matiz.
  Se o matiz for menor do que 0, adicione 3600 para o matiz.

Etapas para que se normalize uma imagem:
  Se a imagem for inexistente, cancele.
  Normalize a caixa desta imagem.
  Normalize a caixa intacta desta imagem.

Etapas para que se normalize uma seleção:
  Se o anchor número da linha desta seleção for menor do que o número de linhas do cursor desta seleção, cancele.
  Se o anchor número da linha desta seleção for maior do que o número de linhas do cursor desta seleção, permute o anchor desta seleção com o cursor de texto desta seleção; saia.
  Se o anchor número de coluna desta seleção for maior do que o cursor de texto número de coluna desta seleção, permute o anchor número de coluna desta seleção com o cursor de texto número de coluna desta seleção.

Etapas para que se normalize uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Normalize a caixa desta caixa de texto.

Etapas para que se normalize um linha reta vertical:
  Se a localização final desta linha reta for menor do que a localização inicial desta linha reta, permute a localização final desta linha reta com a localização inicial desta linha reta.

O null hBrush é um hBrush.

O null hPen é um hPen.

Etapas para que se Anexe o caractere NULL uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o caractere inicial desta string usando a quantidade de caracteres armazenados mais 1.
  Atribua o caractere inicial desta string mais a quantidade de caracteres armazenados menos 1 ao caractere final desta string.
  Atribua o caractere final desta string mais 1 a um ponteiro do byte .
  Atribua o caractere null ao conteúdo deste ponteiro do byte.

Etapas para que se Anexe o caractere NULL uma string composta de caracteres amplos:
  Atribua a quantidade de caracteres deste string composta de caracteres amplos a uma quantidade de caracteres armazenados.
  Reassign o caractere inicial desta string composta de caracteres amplos usando a quantidade de caracteres armazenados mais 2.
  Atribua o caractere inicial desta string composta de caracteres amplos mais a quantidade de caracteres armazenados menos 1 ao caractere final desta string composta de caracteres amplos.

Um offset é um número.

Uma operação é uma string.

Uma origem é uma localização.

Etapas para que se outdent algum tipo de linhas des textos selecionadas em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
  Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Se a linha de texto of a caixa de texto não estiver selecionado, recomece. \selecionada
    Se o conteúdo deste caractere inicial desta string desta linha de texto for o caractere de espaço, remove o first byte desde a string deste linha de texto.
    Se o conteúdo deste caractere inicial desta string desta linha de texto for o caractere de espaço, remove o first byte desde a string deste linha de texto.
  Recomece. [percorra novamente o código acima]

Um outdent é um número.

Etapas para que se outline uma caixa com uma cor:
  Pinte a caixa com a cor e a cor preta.

  
Um x-offset é um offset.
Um y-offset é um offset.

Etapas para que se output o arco of uma elipse usando uma string: \\ interessante.
  Atribua 2761/10000 a uma fração. \ (sqrt(2) -1 ) * (2/3)   = 0,2761423749153967
  Atribua o centro desta elipse a um centro localização.
  Atribua o x-extent desta elipse dividido por 2 a um half largura.
  Atribua o y-extent desta elipse dividido por 2 a um half altura.
  Atribua o x-extent desta elipse times a fração a um x-offset.
  Atribua o y-extent desta elipse times a fração a um y-offset.
  \ control point 1
  Se a string for "canto superior esquerdo", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y deste centro menos o y-offset a um first control localização.
  Se a string for "canto superior direito", atribua a coordenada X deste centro mais o x-offset e a coordenada Y do canto superior esquerdo desta elipse ao first control localização.
  Se a string for "canto inferior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y deste centro mais o y-offset ao first control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X deste centro menos o x-offset e a coordenada Y do canto inferior direito desta elipse ao first control localização.
  \ control point 2
  Se a string for "canto superior esquerdo", atribua a coordenada X deste centro menos o x-offset e a coordenada Y do canto superior esquerdo desta elipse a um second control localização.
  Se a string for "canto superior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y deste centro menos o y-offset ao second control localização.
  Se a string for "canto inferior direito", atribua a coordenada X deste centro mais o x-offset e a coordenada Y do canto inferior direito desta elipse ao second control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y deste centro mais o y-offset ao second control localização.
  \ ending point
  Se a string for "canto superior esquerdo", atribua a coordenada X do canto superior esquerdo desta elipse mais o half largura e a coordenada Y do canto superior esquerdo desta elipse a um ending localização.
  Se a string for "canto superior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y do canto superior esquerdo desta elipse mais o half altura ao ending localização.
  Se a string for "canto inferior direito", atribua a coordenada X do canto inferior direito desta elipse menos o half largura e a coordenada Y do canto inferior direito desta elipse ao ending localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y do canto inferior direito desta elipse menos o half altura ao ending localização.
  \ spit it out
  Output o first control localização sem passar pra próxima linha.
  Output o second control localização sem passar pra próxima linha.
  Output o ending localização sem passar pra próxima linha.
  Output "c".

Etapas para que se output uma cor sem passar pra próxima linha:
  Converta a cor para um espaço de cor RGB.
  Atribua o espectro vermelho deste espaço de cor RGB / 255 a uma fração.
  Converta a fração para um red string usando 4.
  Atribua o espectro verde deste espaço de cor RGB / 255 à fração.
  Converta a fração para um green string usando 4.
  Atribua o espectro azul deste espaço de cor RGB / 255 à fração.
  Converta a fração para um blue string usando 4.
  Output o red string seguido de " " junto com o green string seguido de " " junto com o blue string sem passar pra próxima linha.

Etapas para que se output lineto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "l".

Etapas para que se output lineto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output lineto usando a localização.

Etapas para que se output moveto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "m".

Etapas para que se output moveto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output moveto usando a localização.

Etapas para que se output um número sem passar pra próxima linha:
  Converta o número para uma string.
  Output a string sem passar pra próxima linha.
  Output " " sem passar pra próxima linha.

Etapas para que se output stroke e preencha usando uma cor da borda e uma cor de preenchimento:
  Atribua "B" a uma string. \ stroke e preencha
  Se a cor de preenchimento estiver clear, atribua "S" à string. \ stroke
  Se a cor da borda estiver clear, atribua "f" à string. \ preencha
  Output a string.

\Um paintstruct é um conjunto com
\Um hDC denominado hDC,
\Um número denominado ferase,
\Uma caixa denominado rcpaint,
\Um número denominado frestore,
\Um número denominado fincupdate,
\  32 bytes.

Um número X é um número.
Um número Y é um número.

Um par de números é um conjunto com 
  Um número X e 
  Um número Y.

Um endereçamento de caractere é um ponteiro do byte.

Um pdevmode é um ponteiro para um devmode.

Etapas para que se escolha aleatoriamente um número within um quantia of um segundo número:
  Escolha aleatoriamente o número entre o segundo número menos o quantia e o segundo número mais o quantia.
  Atribua o número ao número deste contexto.

Uma imagem é uma coisa com \FIGURA?
\ as caixas estão em twits
Uma caixa [location of cropped imagem sobre a página], 
Uma caixa intacta [location of entire imagem sobre a página],
Um grayscale detector,
Um mirror detector,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal denominado data [original bytes em original format],
Um gpBitmap.

Etapas para que se toque um wave:
  Call "winmm.dll" "PlaySound" com \ https://docs.microsoft.com/pt-br/previous-versions//dd743680(v=vs.85)
  \A função PlaySound reproduz um som especificado pelo nome de arquivo, recurso ou evento do sistema fornecido.
  \(Um evento do sistema pode estar associado a um som no registro ou no arquivo WIN.INI.)
    O caractere inicial desta wave [pszSound] \ Uma string que especifica o som a ser reproduzido.
    e 0 [hmod] \ Identificador para o arquivo executável que contém o recurso a ser carregado. 
    \Este parâmetro deve ser NULL, a menos que SND_RESOURCE seja especificado em fdwSound.
    e 5. [fdwSound = SND_MEMORY+SND_ASYNC] \Opções de reprodução de som.
    \SND_MEMORY = O parâmetro pszSound aponta para um som carregado na memória.
    \SND_ASYNC = O som é reproduzido de forma assíncrona e o PlaySound retorna imediatamente após o início do som.

Etapas para que se toque um wave e wait:
  Call "winmm.dll" "PlaySound" com \ https://docs.microsoft.com/pt-br/previous-versions//dd743680(v=vs.85)
  \A função PlaySound reproduz um som especificado pelo nome de arquivo, recurso ou evento do sistema fornecido.
  \(Um evento do sistema pode estar associado a um som no registro ou no arquivo WIN.INI.)
    O caractere inicial desta wave [pszSound] \ Uma string que especifica o som a ser reproduzido.
    e 0 [hmod] \ Identificador para o arquivo executável que contém o recurso a ser carregado. 
    \Este parâmetro deve ser NULL, a menos que SND_RESOURCE seja especificado em fdwSound.
    e 4. [fdwSound = SND_MEMORY+SND_SYNC] \Opções de reprodução de som.
    \SND_MEMORY = O parâmetro pszSound aponta para um som carregado na memória.
    \SND_SYNC = O som é reproduzido de forma síncrona e o PlaySound retorna após a conclusão do evento de som. Este é o comportamento padrão.

Etapas para que se toque um wave file:
  Isole o wave file.
  Anexe o caractere NULL o wave file.
  Call "winmm.dll" "PlaySound" com \ https://docs.microsoft.com/pt-br/previous-versions//dd743680(v=vs.85)
  \A função PlaySound reproduz um som especificado pelo nome de arquivo, recurso ou evento do sistema fornecido.
  \(Um evento do sistema pode estar associado a um som no registro ou no arquivo WIN.INI.)
    O caractere inicial deste wave file [pszSound] \ Uma string que especifica o som a ser reproduzido.
    e 0 [hmod] \ Identificador para o arquivo executável que contém o recurso a ser carregado. 
    \Este parâmetro deve ser NULL, a menos que SND_RESOURCE seja especificado em fdwSound.
    e 131073. [fdwSound = SND_FILENAME+SND_ASYNC] \Opções de reprodução de som.
    \SND_FILENAME = O parâmetro pszSound é um nome de arquivo.
    \SND_ASYNC = O som é reproduzido de forma assíncrona e o PlaySound retorna imediatamente após o início do som.

Etapas para que se toque um wave file e wait:
  Isole o wave file.
  Anexe o caractere NULL o wave file.
  Call "winmm.dll" "PlaySound" com \ https://docs.microsoft.com/pt-br/previous-versions//dd743680(v=vs.85)
  \A função PlaySound reproduz um som especificado pelo nome de arquivo, recurso ou evento do sistema fornecido.
  \(Um evento do sistema pode estar associado a um som no registro ou no arquivo WIN.INI.)
    O caractere inicial deste wave file [pszSound] \ Uma string que especifica o som a ser reproduzido.
    e 0 [hmod] \ Identificador para o arquivo executável que contém o recurso a ser carregado. 
    \Este parâmetro deve ser NULL, a menos que SND_RESOURCE seja especificado em fdwSound.
    e 131072. [fdwSound = SND_FILENAME+SND_SYNC] \Opções de reprodução de som.
    \SND_FILENAME = O parâmetro pszSound é um nome de arquivo.
    \SND_SYNC = O som é reproduzido de forma síncrona e o PlaySound retorna após a conclusão do evento de som. Este é o comportamento padrão.

Etapas para que se anteponha uma coisa para umas coisas:
  Se a coisa for inexistente, cancele.
  Atribua a first coisa destas coisas ao next coisa desta coisa.
  Se  as coisas não for vazias, atribua a coisa ao previous deste first coisa destas coisas.
  Se  as coisas estiverem vazias, atribua a coisa ao last coisa destas coisas.
  Atribua a coisa ao first coisa destas coisas.

\Etapas para que se anteponha umas coisas para umas outras coisas:
\ bug encontrado por Mike Gonta - corrected version abaixo
\Obtenha uma coisa desde  as coisas (backwards).
\Se a coisa for inexistente, cancele.
\Remove a coisa desde as coisas.
\Anteponha a coisa para a outras coisas.
\Recomece. [percorra novamente o código acima]

Etapas para que se anteponha umas coisas para umas outras coisas:
  Atribua a last coisa destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Anteponha a coisa para a outras coisas.
  Recomece. [percorra novamente o código acima]

Um process é um número identificador.

Um process ponteiro é um ponteiro para um process.

Um punch linha reta é uma string.

Etapas para que se atribua o character depois de um finger para um character:
  Se o finger for inexistente, limpe o character; saia.
  Atribua o conteúdo deste finger ao character.

Etapas para que se atribua um date/time para uma segunda date/time:
  Atribua o year deste date/time ao year desta segunda date/time.
  Atribua o month deste date/time ao month desta segunda date/time.
  Atribua o week day deste date/time ao week day segunda date/time.
  Atribua o day deste date/time ao day desta segunda date/time.
  Atribua a hour deste date/time à hour desta segunda date/time.
  Atribua o minute deste date/time ao minute desta segunda date/time.
  Atribua o second deste date/time ao second desta segunda date/time.
  Atribua o millisecond deste date/time ao millisecond desta segunda date/time.

Etapas para que se atribua a string dessa date/time para uma string:
  Limpe a string.
  Posponha o year deste date/time para a string.
  Posponha "/" para a string.
  Zero preencha o month deste date/time usando 2 e posponha it para a string.
  Posponha "/" para a string.
  Zero preencha o day deste date/time usando 2 e posponha it para a string.
  Posponha " " para a string.
  Zero preencha a hour deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero preencha o minute deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero preencha o second deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero preencha o millisecond deste date/time usando 3 e posponha it para a string.

Etapas para que se atribua um finger sobre o first character of uma string:
  Atribua o caractere inicial desta string ao finger.

Etapas para que se atribua a contagem desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Comece. [a executar o código abaixo]
  Obtenha um bucket usando o catálogo.
  Se o bucket for inexistente, cancele.
  Adicione a contagem destes referências deste bucket para a contagem.
  Recomece. [percorra novamente o código acima]

Etapas para que se atribua a used contagem de buckets desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, cancele.
    Se os referências deste bucket estiverem vazios, recomece.
    Adicione 1 para a contagem.
  Recomece. [percorra novamente o código acima]

Etapas para que se atribua um número para um word big-endian unsigned:
  Atribua o número a um word.
  Atribua a word ao word big-endian unsigned.

Etapas para que se atribua um número para uma string;
Etapas para que se converta um número para uma string:
  Limpe a string.
  Isole o número.
  De-sign o número.
  Comece. [a executar o código abaixo]
    Divida o número por 10 usando um quociente e um resto.
    Adicione 48 para o resto.
    Atribua o resto a um byte.
    Anteponha o byte para a string.
    Se o quociente for 0, pare.
    Atribua o quociente ao número.
  Recomece. [percorra novamente o código acima]
  Se o original número for menor do que 0, anteponha o hífem para a string.

Etapas para que se atribua um número sobre o stack:
  Converta o número para um segmento inicial.
  Atribua o segmento inicial sobre o stack.

Etapas para que se atribua o absolute value desse número para um segundo número:
  Atribua o número ao segundo número.
  De-sign o segundo número.

Etapas para que se atribua um OutlineTextmetric para uma segunda OutlineTextmetric:
  Copie bytes desde o endereçamento deste OutlineTextmetric para o endereçamento desta segunda OutlineTextmetric pela magnitude deste OutlineTextmetric.

Etapas para que se atribua o absolute value desse par de números para um segundo par de números:
  Atribua o par de números ao segundo par de números.
  De-sign o segundo par de números.

\ unclear why this does not get called properly when I replace hoja apaisada com caja ***

Etapas para que se atribua uma imagem no middle of uma caixa;
Etapas para que se centralize uma imagem em uma caixa:
  Se a imagem for inexistente, cancele.
  Centralize a imagem na caixa (horizontalmente).
  Centralize a imagem na caixa (verticalmente).

Etapas para que se atribua uma imagem sobre uma localização;
Etapas para que se centralize uma imagem sobre uma localização:
  Se a imagem for inexistente, cancele.
  Obtenha um difference entre a localização e o centro desta caixa desta imagem.
  Arredonde a difference para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando a difference.

Etapas para que se atribua o working string dessa linha de texto para um subtexto:
  Se a linha de texto for inexistente, limpe o subtexto; saia.
  Lance o subtexto sobre a string deste linha de texto.
  Subtraia 1 desde o caractere final deste subtexto.

Etapas para que se atribua uma seleção para uma segunda seleção:
  Atribua o anchor desta seleção ao anchor desta segunda seleção.
  Atribua o cursor de texto desta seleção ao cursor de texto desta segunda seleção.

Etapas para que se atribua um sockaddr para uma segunda sockaddr:
  Copie bytes desde o endereçamento deste sockaddr para o endereçamento desta segunda sockaddr pela magnitude deste sockaddr.

Etapas para que se atribua uma string para uma letra:
  Atribua o conteúdo deste caractere inicial desta string à letra.

Etapas para que se atribua uma string para uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Destrua as linhas des textos desta caixa de texto.
  Redefina a origem of a caixa de texto.
  Redefina o cursor de texto of a caixa de texto.
  Desvencilhe-se de a caixa de texto.
  Isole a string.
  Posponha o retorno de carro para a string.
  Converta a string para as linhas des textos desta caixa de texto.
  Wrap a caixa de texto.

Etapas para que se atribua uma string sobre a área de transferência do Windows:
  Call "user32.dll" "OpenClipboard" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-openclipboard
  \Abre a área de transferência para exame e impede que outros aplicativos modifiquem o conteúdo da área de transferência.
    A janela principal do programa. [hWndNewOwner] \Um identificador para a janela a ser associada à área de transferência aberta.
    \A janela identificada pelo parâmetro hWndNewOwner não se torna o proprietário da área de transferência, a menos que a função EmptyClipboard seja chamada.
  Call "user32.dll" "EmptyClipboard". \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-emptyclipboard
  \Esvazia a área de transferência e libera identificadores para os dados da área de transferência. 
  \A função então atribui a propriedade da área de transferência à janela que está com a área de transferência aberta.
  Atribua a quantidade de caracteres desta string mais 1 a um número.
  Call "kernel32.dll" "GlobalAlloc" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globalalloc
    \Aloca o número especificado de bytes do heap.
  66 [uFlags = GHND - 0x0042 - unifica GMEM_MOVEABLE e GMEM_ZEROINIT.] \Os atributos de alocação de memória.
  \GMEM_MOVEABLE Aloca memória móvel. Os blocos de memória nunca são movidos na memória física, mas podem ser movidos dentro do heap padrão.
  \O valor de retorno de GMEM_MOVEABLE é um identificador para o objeto de memória.
  \GMEM_ZEROINIT Inicializa o conteúdo da memória para zero.
    e O número [dwBytes] \O número de bytes a serem alocados.
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno será um identificador para o objeto de memória recém-alocado.
  Call "kernel32.dll" "GlobalLock" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globallock
    O número identificador [hMem] \Um identificador para o objeto de memória global. 
    devolvendo um ponteiro. \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o primeiro byte do bloco de memória.
  Copie bytes desde o caractere inicial desta string para o ponteiro pelo quantidade de caracteres desta string.
  Call "kernel32.dll" "GlobalUnlock" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-globalunlock
  \Diminui a contagem de bloqueios associada a um objeto de memória que foi alocado com GMEM_MOVEABLE. 
  \Esta função não tem efeito em objetos de memória alocados com GMEM_FIXED.
    O número identificador. [hMem] \Um identificador para o objeto de memória global
  Call "user32.dll" "SetClipboardData" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-setclipboarddata
  \Coloca dados na área de transferência em um formato de área de transferência especificado.
  \A janela deve ser o proprietário da área de transferência atual e o aplicativo deve ter chamado a função OpenClipboard.
    1 [uFormat = CF_TEXT] \ O formato da área de transferência.
   \Este parâmetro pode ser um formato registrado ou qualquer um dos formatos padrão da área de transferência. 
    \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/dataxchg/clipboard-formats
    \e https://docs.microsoft.com/pt-br/windows/desktop/dataxchg/clipboard-formats
    e O número identificador. [hMem] \Um identificador para os dados no formato especificado. 
    \Se a função for bem-sucedida, o valor de retorno é o identificador para os dados.
  Call "user32.dll" "CloseClipboard". \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-closeclipboard
  \Fecha a área de transferência.
  

Etapas para que se atribua a largura dessa string para uma largura:
  \Consegui traduzir como:
  \Etapas para que se atribua uma largura desse string para uma segunda largura:
  Obtenha a largura usando a string e o memory canvas e a fonte padrão.

\\leave out - causes Spanish string atribuas para resolva here instead of "Atribua uma string a uma segunda string"
Etapas para que se atribua um subtexto para um segundo subtexto:
  Copie bytes desde o endereçamento deste subtexto para o endereçamento deste segundo subtexto pela magnitude deste subtexto.

Etapas para que se atribua o date/time do system para um date/time:
  Call "kernel32.dll" "GetLocalTime" com \ https://docs.microsoft.com/pt-br/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlocaltime
  \Recupera a data e hora atuais no horário local.
    o endereçamento desse SYSTEMTIME. [lpSystemTime] \Um ponteiro para uma estrutura SYSTEMTIME para receber a data e hora local atuais.
    \ https://docs.microsoft.com/pt-br/windows/win32/api/minwinbase/ns-minwinbase-systemtime
  Atribua o wYear deste SYSTEMTIME ao year deste date/time.
  Atribua o wMonth deste SYSTEMTIME ao month deste date/time.
  Atribua o wDayOfWeek deste SYSTEMTIME ao week day deste date/time.
  Atribua o wDay deste SYSTEMTIME ao day deste date/time.
  Atribua o wHour deste SYSTEMTIME à hour deste date/time.
  Atribua o wMinute deste SYSTEMTIME ao minute deste date/time.
  Atribua o wSecond deste SYSTEMTIME ao second deste date/time.
  Atribua os wMilliseconds deste SYSTEMTIME ao millisecond deste date/time.

Etapas para que se atribua o último erro do sistema para um número:
  Call "kernel32.dll" "GetLastError" devolvendo o número. \ https://docs.microsoft.com/pt-br/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror
  \Recupera o valor do código do último erro do segmento de chamada. 
  \O código do último erro é mantido por thread. 
  \Threads múltiplos não substituem o código do último erro uns dos outros.
  \O valor de retorno é o último código de erro do segmento de chamada. 
  \A maioria das funções que definem o código do último erro do encadeamento o definem quando falham. 
  \Algumas funções definem o código do último erro como 0 em caso de sucesso e outras não definem nada.

Etapas para que se atribua o último erro do windows sockets para um número:
  Call "ws2_32.dll" "WSAGetLastError" devolvendo o número.\ https://docs.microsoft.com/pt-br/windows/win32/api/winsock/nf-winsock-wsagetlasterror
  \A função WSAGetLastError retorna o status de erro da última operação do Windows Sockets que falhou.
  \O valor de retorno indica o código de erro para a última operação do Windows Sockets deste thread que falhou.

Etapas para que se atribua a contagem de intervalos do sistema para uns intervalos:
  \ reinicia a cada 24 dias, 19 horas e 12 minutos aproximadamente (32 bits)
  Call "kernel32.dll" "GetTickCount" devolvendo os intervalos. \ https://docs.microsoft.com/pt-br/windows/win32/api/sysinfoapi/nf-sysinfoapi-gettickcount
  \Recupera o número de milissegundos decorridos desde que o sistema foi iniciado, até 49 dias, 16 horas e 48 minutos
  \O valor de retorno é o número de milissegundos decorridos desde que o sistema foi iniciado.
  \O modo de contagem da função GetTickCount está limitado ao modo de contagem do cronômetro do sistema, 
  \que normalmente fica na faixa de 10 milissegundos a 16 milissegundos.
  \Se você precisar de um cronômetro de resolução mais alta, use um cronômetro de multimídia ou um cronômetro de alta resolução.
  Conjuncione logicamente os intervalos com o maior número.

Etapas para que se atribua um terminal no middle of uma caixa;
Etapas para que se centralize um terminal em uma caixa:
  Isole a caixa.
  Indent a caixa 24 px.  \ afaste a caixa 24 px pra direit seria um comando melhor
  Atribua a caixa à caixa deste terminal.

Etapas para que se atribua uma caixa de texto no middle of uma caixa;
Etapas para que se centralize uma caixa de texto em uma caixa:
  Se a caixa de texto for inexistente, cancele.
  Centralize a caixa de texto na caixa (horizontalmente).
  Centralize a caixa de texto na caixa (verticalmente).

Etapas para que se atribua uma caixa de texto sobre uma localização;
Etapas para que se centralize uma caixa de texto sobre uma localização:
  Se a caixa de texto for inexistente, cancele.
  Obtenha um difference entre a localização e o centro desta caixa desta caixa de texto.
  Arredonde a difference para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa de texto usando a difference.

Etapas para que se atribua a first linha reta desse caixa de texto para uma string:
  Se a caixa de texto for inexistente, limpe a string; saia.
  Atribua a string desta first linha de texto desta caixa de texto à string.
  Remove o last byte desde a string.

Etapas para que se atribua a first linha reta contendo texto desse caixa de texto para uma string:
  \ *** new
  Limpe a string.
  Se a caixa de texto for inexistente, cancele.
  Comece. [a executar o código abaixo]
    Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto for inexistente, cancele.
    Atribua a string deste linha de texto à string.
    Remove o last byte desde a string. \ cr ou space (see caixa de texto rules no começo do arquivo)
    Remove algum tipo de leading noise desde a string.
    Remove algum tipo de trailing noise desde a string.
  Se a string estiver em branco, recomece.
  \Se a string não estiver em branco, pare.

Etapas para que se atribua a globalized origem desse caixa de texto para uma localização:
  Se a caixa de texto for inexistente, limpe a localização; saia.
  Atribua a origem desta caixa de texto à localização.
  Globalize a localização usando o canto superior esquerdo desta caixa de texto.

Etapas para que se atribua a malha desse caixa de texto para uma malha:
  Se a caixa de texto for inexistente, limpe a malha; saia.
  Atribua a altura desta fonte desta caixa de texto times 4 ao número X desta malha.
  Atribua a altura desta fonte desta caixa de texto ao número Y desta malha.

Etapas para que se atribua a normalized seleção desse caixa de texto para uma seleção:
  Se a caixa de texto for inexistente, cancele.
  Atribua a seleção desta caixa de texto à seleção.
  Normalize a seleção.

Etapas para que se atribua a contagem de linhas desse caixa de texto para uma contagem:
  Se a caixa de texto for inexistente, atribua 0 à contagem; saia.
  Se as linhas des textos desta caixa de texto estiverem vazias, atribua 0 à contagem; saia.
  Atribua o número da linha deste last linha de texto destas linhas des textos desta caixa de texto à contagem.

Etapas para que se atribua a altura da linha desse caixa de texto para uma altura:
  Se a caixa de texto for inexistente, atribua 0 ao altura; saia.
  Atribua a altura desta fonte desta caixa de texto ao altura.

Etapas para que se atribua as linhas des textos/box desse caixa de texto para uma contagem:
  Se a caixa de texto for inexistente, atribua 0 à contagem; saia.
  Atribua a altura desta caixa desta caixa de texto dividido pela altura da linha desta caixa de texto à contagem.

Etapas para que se atribua a quantidade de caracteres selecionados desse caixa de texto para uma contagem:
  Atribua 0 à contagem.
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Comece. [a executar o código abaixo]
  Obtenha uma linha de texto desde as linhas des textos desta caixa de texto.
  Se a linha de texto for inexistente, cancele.
  Lance um subtexto sobre qualquer trecho selecionado na linha de texto of a caixa de texto.
  Adicione a quantidade de caracteres deste subtexto para a contagem.
  Recomece. [percorra novamente o código acima]

Etapas para que se atribua a selecionado contagem de linhas desse caixa de texto para uma contagem:
  Atribua 0 à contagem.
  Se a caixa de texto for inexistente, cancele.
  Atribua a normalized seleção desta caixa de texto a uma seleção.
  Se o anchor número da linha desta seleção é o número de linhas do cursor desta seleção, cancele.
  Atribua o número de linhas do cursor desta seleção à contagem.
  Subtraia o anchor número da linha desta seleção desde a contagem.
  Se o cursor de texto número de coluna desta seleção não for 1, adicione 1 para a contagem.

Etapas para que se atribua o painel de informações string desse caixa de texto para uma string:
  Se a caixa de texto for inexistente, limpe a string; saia.
  Atribua a selecionado contagem de linhas desta caixa de texto a uma contagem.
  Se a contagem não for 0, format a contagem e "linha selecionada" ou "linhas selecionadas" à string; saia.
  Atribua a quantidade de caracteres selecionados desta caixa de texto a uma segunda contagem.
  Se a segunda contagem não for 0, format a segunda contagem e "byte" ou "bytes" à string; saia.
  Converta o número de linhas do cursor desta caixa de texto para a string.
  Posponha ":" para a string.
  Posponha o cursor de texto número de coluna desta caixa de texto para a string.

Etapas para que se atribua uma coisa sob o end of umas coisas;
Etapas para que se posponha uma coisa para umas coisas:
  Se a coisa for inexistente, cancele.
  Atribua a last coisa destas coisas ao previous coisa desta coisa.
  Se as coisas não estiverem vazias, atribua a coisa ao next deste last coisa destas coisas.
  Se as coisas estiverem vazias, atribua a coisa ao first coisa destas coisas.
  Atribua a coisa ao last coisa destas coisas.

Etapas para que se atribua umas coisas para umas outras coisas:
  Atribua a first coisa destas coisas ao first destas outras coisas.
  Atribua a last coisa destas coisas ao last destas outras coisas.

Etapas para que se atribua a contagem dessas coisas  para uma contagem:
  Atribua 0 à contagem.
  Comece. [a executar o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a coisa for inexistente, cancele.
    Adicione 1 para a contagem.
  Recomece. [percorra novamente o código acima]

Etapas para que se atribua um temporizador para uma string;
Etapas para que se converta um temporizador para uma string:
  Converta os intervalos deste temporizador para a string.

Etapas para que se atribua a string desse temporizador para uma string:
  Converta os intervalos deste temporizador para a string.

Etapas para que se atribua os intervalos desse temporizador para uns intervalos:
  Atribua os intervalos totais deste temporizador aos intervalos.
  Se a contagem deste temporizador for 0, cancele.
  Atribua a contagem de intervalos do sistema a uns intervalos de temporização. 
  Subtraia os intervalos iniciais deste temporizador desde os intervalos de temporização.
  Adicione os intervalos de temporização para os intervalos.

Etapas para que se atribua um segmento inicial sobre o stack:
  Aloque memória para um stack entry.
  Atribua o segmento inicial à string desta stack entry.
  Anteponha o stack entry para o stack.

Etapas para que se quit;
Etapas para que se relinquish control:
  Desmanche a fila de eventos.
  Crie um evento.
  Atribua "fechamento do programa" à categoria deste evento.
  Enfileire o evento.

Um quora é uma coisa com \ quora é abreviação de "question or answer"
  uma string e 
  uma cor. 

Etapas para que se quote uma string:
  \ inserts leading, trailing e nested double-quotes
  Atribua as aspas duplas a uma segunda string.
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, pare.
    Posponha o conteúdo deste caractere inicial deste subtexto para a segunda string.
    Se o conteúdo deste caractere inicial deste subtexto for as aspas duplas, posponha as aspas duplas para a segunda string.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  Posponha as aspas duplas para a segunda string.
  Atribua a segunda string à string.



Etapas para que se atualize a tela usando uma caixa:
  Call "gdi32.dll" "BitBlt" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-bitblt
  \A função BitBlt executa uma transferência de bloco de bits dos dados de cor 
  \correspondentes a um retângulo de pixels do contexto de dispositivo de origem especificado 
  \para um contexto de dispositivo de destino.
  \BitBlt só faz recorte no controlador de domínio de destino.
  \Se uma rotação ou transformação de cisalhamento estiver em vigor no contexto do dispositivo de origem, BitBlt retornará um erro. 
  \Se outras transformações existirem no contexto do dispositivo de origem
   \(e uma transformação correspondente não estiver em vigor no contexto do dispositivo de destino), 
   \o retângulo no contexto do dispositivo de destino será esticado, compactado ou girado, conforme necessário.
   \Se os formatos de cor dos contextos de dispositivo de origem e destino não corresponderem, a função 
   \BitBlt converte o formato de cor de origem para corresponder ao formato de destino.
   \Quando um metarquivo avançado está sendo gravado, 
   \ocorre um erro se o contexto do dispositivo de origem identifica um contexto de dispositivo de metarquivo avançado.
    O tela canvas [hdc] \Um identificador para o contexto do dispositivo de destino.
    e A coordenada X do canto superior esquerdo desta caixa [x] \A coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.
    e A coordenada Y do canto superior esquerdo desta caixa [y] \A coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.
    e A largura desta caixa [cx] \A largura, em unidades lógicas, dos retângulos de origem e destino.
    e A altura desta caixa [cy] \A altura, em unidades lógicas, dos retângulos de origem e destino.
    e O quadro atual [hdcSrc] \Um identificador para o contexto do dispositivo de origem.
    e A coordenada X do canto superior esquerdo desta caixa [x1] \A coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.
    e A coordenada Y do canto superior esquerdo desta caixa [y1] \A coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.
   e 13369376 [rop = SRCCOPY]. \Um código de operação de varredura. 
   \Esses códigos definem como os dados de cor do retângulo de origem devem ser combinados com os dados de cor do retângulo de destino para obter a cor final.
   \SRCCOPY = Copia o retângulo de origem diretamente para o retângulo de destino.
   \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
   \Se a função falhar, o valor de retorno é zero.

Etapas para que se relembre uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Destrua os refeitos desta caixa de texto.
  Copie a caixa de texto a um segundo caixa de texto.
  Redimensione proporcionalmente o segundo caixa de texto para 1/1.
  Posponha o segundo caixa de texto para os desfeitos desta caixa de texto.
  Limite os desfeitos desta caixa de texto para o max caixa de texto desfeitos.
  Ligue o detector de alteração desta caixa de texto.

Etapas para que se relembre uma caixa de texto com um operação:
  Se a caixa de texto for inexistente, cancele.
  Se o última operação desta caixa de texto for a operação, acione o detector de alteração desta caixa de texto; saia.
  Relembre a caixa de texto.
  Atribua o operação à última operação desta caixa de texto.

Etapas para que se relembre where we are:
  Salve o contexto.

Etapas para que se remove qualquer trecho selecionado em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Atribua a seleção desta caixa de texto a uma seleção.
  Normalize a seleção.
  Obtenha uma linha de texto usando o anchor número da linha desta seleção e a caixa de texto.
  Lance um subtexto sobre a string deste linha de texto.
  Atribua o caractere inicial deste subtexto mais o anchor número de coluna desta seleção menos 2 ao caractere final deste subtexto.
  Obtenha uma segunda linha de texto usando o número de linhas do cursor desta seleção e a caixa de texto.
  Lance um segundo subtexto sobre a string desta segunda linha de texto.
  Atribua o caractere inicial deste segundo subtexto mais o cursor de texto número de coluna desta seleção menos 1 ao caractere inicial deste segundo subtexto.
  Atribua o subtexto junto com o segundo subtexto à string desta linha de texto.
  Remove as linhas des textos of a caixa de texto entre o next desta linha de texto e a segunda linha de texto.
  Atribua o anchor desta seleção ao cursor de texto desta caixa de texto.
  Desvencilhe-se de a caixa de texto.

Etapas para que se remove bytes de uma caixa de texto (backspace over um return):
  Se a caixa de texto for inexistente, cancele.
  Se o número de linhas do cursor desta caixa de texto for 1, cancele.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto menos 1 e a caixa de texto.
  Atribua a quantidade de caracteres desta string desta linha de texto e o número de linhas do cursor desta caixa de texto menos 1 ao cursor de texto desta caixa de texto.
  Remove qualquer trecho selecionado na caixa de texto.

Etapas para que se remove bytes de uma caixa de texto (backspace com jump):
  Se a caixa de texto for inexistente, cancele.
  Se something estiver selecionado na caixa de texto, remove qualquer trecho selecionado na caixa de texto; saia.
  Se o cursor de texto número de coluna desta caixa de texto for 1, remove bytes de a caixa de texto (backspace over um return); saia.
  Jump o cursor de texto para a esquerda na caixa de texto.
  Remove qualquer trecho selecionado na caixa de texto.

Etapas para que se remove bytes de uma caixa de texto (backspace):
  Se a caixa de texto for inexistente, cancele.
  Se something estiver selecionado na caixa de texto, remove qualquer trecho selecionado na caixa de texto; saia.
  Se o cursor de texto número de coluna desta caixa de texto for 1, remove bytes de a caixa de texto (backspace over um return); saia.
  Mova o cursor de texto para a esquerda na caixa de texto.
  Remove qualquer trecho selecionado na caixa de texto.

Etapas para que se remove bytes de uma caixa de texto (forward delete um return):
  Se a caixa de texto for inexistente, cancele.
  Se o número de linhas do cursor desta caixa de texto for a contagem de linhas desta caixa de texto, cancele.
  Atribua 1 e o número de linhas do cursor desta caixa de texto mais 1 ao cursor de texto desta caixa de texto.
  Remove qualquer trecho selecionado na caixa de texto.

Etapas para que se remove bytes de uma caixa de texto (forward delete com jump):
  Se a caixa de texto for inexistente, cancele.
  Se something estiver selecionado na caixa de texto, remove qualquer trecho selecionado na caixa de texto; saia.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Se o cursor de texto número de coluna desta caixa de texto é a quantidade de caracteres desta string desta linha de texto, remove bytes de a caixa de texto (forward delete um return); saia.
  Jump o cursor de texto para a direita na caixa de texto.
  Remove qualquer trecho selecionado na caixa de texto.

Etapas para que se remove bytes de uma caixa de texto (forward delete):
  Se a caixa de texto for inexistente, cancele.
  Se something estiver selecionado na caixa de texto, remove qualquer trecho selecionado na caixa de texto; saia.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Se o cursor de texto número de coluna desta caixa de texto é a quantidade de caracteres desta string desta linha de texto, remove bytes de a caixa de texto (forward delete um return); saia.
  Mova o cursor de texto para a direita na caixa de texto.
  Remove qualquer trecho selecionado na caixa de texto.

Etapas para que se remove cada byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua "" ao caixa de texto.

Etapas para que se remove o first byte desde uma string:
  Lance um subtexto sobre o first byte of a string.
  Remove bytes de a string usando o subtexto.

   
Etapas para que se remove o last byte desde uma string:
  Lance um subtexto sobre o last byte of a string.
  Remove bytes de a string usando o subtexto.

Etapas para que se remove os last dois bytes desde uma string:
  Remove trailing bytes desde a string usando 2.

Etapas para que se remove leading bytes desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; saia.
  Lance um subtexto sobre o first byte of a string.
  Atribua o caractere inicial deste subtexto mais a contagem menos 1 ao caractere final deste subtexto.
  Remove bytes de a string usando o subtexto.

Etapas para que se remove leading noise desde uma string;
Etapas para que se remove algum tipo de leading noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste caractere inicial desta string não for irrelevante, cancele.
  Remove o first byte desde a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se remove as linhas des textos of uma caixa de texto entre uma linha de texto e uma segunda linha de texto:
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto for inexistente, cancele.
  Se a segunda linha de texto for inexistente, cancele.
  Se o número da linha desta linha de texto for maior do que o número da linha desta segunda linha de texto, cancele.
  Isole a linha de texto.
  Atribua o next desta segunda linha de texto a uma stop linha de texto.
  Comece. [a executar o código abaixo]
    Se a linha de texto for a stop linha de texto, pare.
    Atribua o next desta linha de texto a uma next linha de texto.
    Remove a linha de texto desde as linhas des textos desta caixa de texto.
    Destrua a linha de texto.
    Atribua o next linha de texto à linha de texto.
  Recomece. [percorra novamente o código acima]
  Renumere as linhas des textos desta caixa de texto.

Etapas para que se remove uma coisa desde umas coisas:
  Se a coisa for inexistente, cancele.
  Se a coisa for a first coisa destas coisas, atribua o next coisa desta coisa ao first coisa destas coisas.
  Se a coisa for a last coisa destas coisas, atribua o previous coisa desta coisa ao last coisa destas coisas.
  Se o next coisa desta coisa não for inexistente, atribua o previous coisa desta coisa ao previous deste next coisa desta coisa.
  Se o previous coisa desta coisa não for inexistente, atribua o next coisa desta coisa ao next deste previous coisa desta coisa.
  Esvazie o next coisa desta coisa.
  Esvazie o previous coisa desta coisa.

Etapas para que se remove trailing bytes desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; saia.
  Lance um subtexto sobre o last byte of a string.
  Atribua o caractere final deste subtexto menos a contagem mais 1 ao caractere inicial deste subtexto.
  Remove bytes de a string usando o subtexto.

Etapas para que se remove trailing noise desde uma string;
Etapas para que se remove algum tipo de trailing noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste caractere final desta string não for irrelevante, cancele.
  Remove o last byte desde a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se rename um endereço completo para um segundo endereço completo no sistema de arquivos:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Isole o segundo endereço completo.
  Remove algum tipo de trailing barra invertida desde o segundo endereço completo.
  Anexe o caractere NULL o segundo endereço completo.
  Call "kernel32.dll" "MoveFileA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winbase/nf-winbase-movefilea
  \Move um arquivo ou um diretório existente 
    O caractere inicial deste endereço completo [lpExistingFileName] \ O nome atual do arquivo ou diretório no computador local.
    e O caractere inicial deste segundo endereço completo [lpNewFileName] \ O novo nome do arquivo ou diretório. 
    \O novo nome ainda não deve existir. 
    \Um novo arquivo pode estar em um sistema de arquivos ou unidade diferente. 
    \Um novo diretório deve estar na mesma unidade.
    \A função MoveFile moverá (renomeará) um arquivo ou diretório (incluindo seus filhos) no mesmo diretório ou entre diretórios. 
    \A única ressalva é que a função MoveFile falhará nas movimentações de diretório quando o destino estiver em um volume diferente.
    \Se um arquivo for movido entre os volumes, MoveFile não move o descritor de segurança com o arquivo. 
    \O arquivo será atribuído ao descritor de segurança padrão no diretório de destino.
    devolvendo um número. \ Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, saia.
  Atribua "Ocorreu um erro ao renomear o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se renumere umas linhas des textos:
  Obtenha uma linha de texto desde as linhas des textos.
  Se a linha de texto for inexistente, cancele.
  Adicione 1 para um número da linha.
  Atribua o número da linha ao número da linha desta linha de texto.
  Recomece. [percorra novamente o código acima]

Etapas para que se replace um byte com um segundo byte em uma string:
  Lance um subtexto sobre a string.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste caractere inicial deste subtexto não for o byte, adicione 1 para o caractere inicial deste subtexto; recomece.
    Atribua o segundo byte ao conteúdo deste caractere inicial deste subtexto.
    Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

A texto retornado é um texto retornado.

Uma texto retornado é uma string.

Etapas para que se reenfileire um evento:
  Copie o evento a um segundo evento.
  Enfileire o segundo evento.

Etapas para que se redefina o alfabeto:
  Atribua o 'A' maiúsculo ao próxima letra.

Etapas para que se redefina o cursor de texto of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua 1 e 1 ao cursor de texto desta caixa de texto.

Etapas para que se redefina o contexto:
  Restaure o contexto.
  Salve o contexto.

Etapas para que se redefina uma contagem:
  Atribua 0 à contagem.

Etapas para que se redefina o drawing origem:
  Defina o drawing origem para o zero localização.

Etapas para que se redefina um detector:
  Desative o detector.

Etapas para que se redefina a origem of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua a margem desta caixa de texto à coordenada X desta caixa de texto.
  Atribua 0 à coordenada Y desta caixa de texto.

Etapas para que se zere um temporizador;
Etapas para que se resete um temporizador;
Etapas para que se redefina um temporizador:
  Atribua 0 à contagem deste temporizador.
  Atribua 0 aos intervalos iniciais deste temporizador.
  Atribua 0 aos intervalos totais deste temporizador.

Etapas para que se redimensione uma caixa usando um par de números racionais;
Etapas para que se redimensione uma caixa usando uma par de números fracionários:
  Atribua o x-extent desta caixa a uma largura.
  Atribua o y-extent desta caixa a uma altura.
  Redimensione proporcionalmente a largura usando a fração deste par de números fracionários.
  Redimensione proporcionalmente a altura usando a segunda fração deste par de números fracionários.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais a largura à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura à coordenada Y do canto inferior direito desta caixa.

Etapas para que se redimensione uma caixa usando um twip par de números:
  Adicione o número X deste twip par de números para a coordenada X do canto inferior direito desta caixa.
  Adicione o número Y deste twip par de números para a coordenada Y do canto inferior direito desta caixa.

Etapas para que se redimensione uma elipse usando um par de números racionais;
Etapas para que se redimensione uma elipse usando uma par de números fracionários:
  Redimensione a caixa desta elipse usando o par de números fracionários.

Etapas para que se redimensione uma elipse usando um twip par de números:
  Redimensione a caixa desta elipse usando o twip par de números.

Etapas para que se redimensione uma linha reta usando um par de números racionais;
Etapas para que se redimensione uma linha reta usando uma par de números fracionários:
  Atribua a caixa desta linha reta a uma caixa.
  Subtraia o canto superior esquerdo desta caixa desde a localização inicial desta linha reta.
  Redimensione proporcionalmente a localização inicial desta linha reta usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para a localização inicial desta linha reta.
  Subtraia o canto superior esquerdo desta caixa desde a localização final desta linha reta.
  Redimensione proporcionalmente a localização final desta linha reta usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para a localização final desta linha reta.

Etapas para que se redimensione uma linha reta usando um twip par de números:
  Atribua a caixa desta linha reta a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Faça uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione a linha reta usando o par de números fracionários.

Etapas para que se redimensione uma imagem para uma largura por uma altura:
  Se a imagem for inexistente, cancele.
  Atribua a largura dividido pelo quantidade de twips/pixel a um pixel largura.
  Atribua a altura dividido pelo quantidade de twips/pixel a um pixel altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com \ 
  \Cria um objeto Bitmap com base em uma matriz de bytes junto com informações de tamanho e formato.
    A pixel largura [width] \ Número inteiro que especifica a largura, em pixels, do bitmap.
    e A pixel altura [height] \  Número inteiro que especifica a altura, em pixels, do bitmap.
    e 0 [stride] \ Número inteiro que especifica o deslocamento de byte entre o início de uma linha de varredura e a próxima. 
    \Isso é geralmente (mas não necessariamente) o número de bytes no formato de pixel (por exemplo, 2 para 16 bits por pixel) multiplicado pela largura do bitmap. 
    \O valor passado para este parâmetro deve ser um múltiplo de quatro.
    e 137224 [format = PixelFormat24bppRGB] \Número inteiro que especifica o formato de pixel do bitmap. 
    \
    \O tipo de dados PixelFormat e constantes que representam vários formatos de pixel são definidos em Gdipluspixelformats.h. 
    \Para obter mais informações sobre constantes de formato de pixel, consulte https://docs.microsoft.com/pt-br/windows/desktop/gdiplus/-gdiplus-constant-image-pixel-format-constants
    e 0 [*scan0] \ 
    e O endereçamento desse gpBitmap. [*bitmap] \ 
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
  \Cria um objeto Graphics associado a um objeto Image.
    O gpBitmap [*image] \Ponteiro para um objeto Image que será associado ao novo objeto Graphics.
    \ https://docs.microsoft.com/pt-br/windows/desktop/api/gdiplusheaders/nl-gdiplusheaders-image
    e O endereçamento desse gpGraphic. [**graphics] \Ponteiro para um vafriável que recebe um ponteiro para o novo objeto Graphics.
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com
  \Desenha uma imagem em um local especificado.
   O gpGraphic [*graphics] \ Ponteiro para o objeto Graphics.
   e O gpBitmap desta imagem [*image] \ Ponteiro para um objeto Image que especifica a imagem a ser desenhada.
   \ https://docs.microsoft.com/pt-br/windows/desktop/api/gdiplusheaders/nl-gdiplusheaders-image
   [*destPoints] \ Ponteiro para uma matriz de objetos Point que especificam a área, em um paralelogramo, na qual desenhar a imagem.
   \ https://docs.microsoft.com/pt-br/windows/desktop/api/gdiplustypes/nl-gdiplustypes-point
   e 0 [dstx] \ valor inteiro que especifica a coordenada x do canto superior esquerdo da área de desenho da imagem.
   e 0 [dsty] \ valor inteiro que especifica a coordenada y do canto superior esquerdo da área de desenho da imagem.
   [/*destPoints]
   [count] \ Número inteiro que especifica o número de elementos na matriz denominada destPoints.
   e A pixel largura [dstwidth ] \ valor inteiro que especifica a largura da área de desenho a ser desenhada.
   e A pixel altura [dstheight] \ valor inteiro que especifica a altura da área de desenho a ser desenhada.
   [/count]
   e 0 [srcx]  \ especifica a coordenada x do canto superior esquerdo da parte da imagem de origem a ser desenhada.
   e 0 [srcy]  \especifica a coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.
   e A largura deste gpBitmap desta imagem menos 1 [srcwidth] \ valor inteiro que especifica a largura da parte da imagem de origem a ser desenhada.
   e A altura deste gpBitmap desta imagem menos 1 [srcheight] \ valor inteiro que especifica a altura da parte da imagem de origem a ser desenhada.
   e 2 [srcUnit = UnitPixel] \Elemento da enumeração da unidade que especifica a unidade de medida da imagem. O valor padrão é UnitPixel.
   e nil [*imageAttributes] \ Ponteiro para uma estrutura ImageAttributes que especifica os atributos de cor e tamanho da imagem a ser desenhada. O valor padrão é NULL.
   \ https://docs.microsoft.com/pt-br/windows/desktop/api/gdiplusimageattributes/nl-gdiplusimageattributes-imageattributes
   e nil [callback] \ Método de retorno de chamada usado para cancelar o desenho em andamento. O valor padrão é NULL.
   e 0. [*callbackData] \ Ponteiro para dados adicionais usados pelo método especificado pelo parâmetro de retorno de chamada. O valor padrão é NULL.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
  \Exclui o objeto Graphics especificado.
   O gpGraphic. [*graphics] \ Ponteiro para o objeto Graphics.
  Destrua o gpBitmap desta imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).
  Limpe os data desta imagem.

Etapas para que se redimensione um polígono usando um par de números racionais;
Etapas para que se redimensione um polígono usando uma par de números fracionários:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Comece. [a executar o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia o canto superior esquerdo desta caixa desde a localização deste vértice.
    Redimensione proporcionalmente a localização deste vértice usando o par de números fracionários.
    Adicione o canto superior esquerdo desta caixa para a localização deste vértice.
  Recomece. [percorra novamente o código acima]

Etapas para que se redimensione um polígono usando um twip par de números:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Faça uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione o polígono usando o par de números fracionários.

Etapas para que se redimensione uma caixa de texto usando um par de números racionais;
Etapas para que se redimensione uma caixa de texto usando uma par de números fracionários:
  Se a caixa de texto for inexistente, cancele.
  Redimensione a caixa desta caixa de texto usando o par de números fracionários.
  Wrap a caixa de texto.

Etapas para que se redimensione uma caixa de texto usando um twip par de números:
  Se a caixa de texto for inexistente, cancele.
  Redimensione a caixa desta caixa de texto usando o twip par de números.
  Wrap a caixa de texto.

Etapas para que se reinicie um temporizador:
  Adicione 1 para a contagem deste temporizador.
  Se a contagem deste temporizador não for 1, cancele.
  Atribua a contagem de intervalos do sistema aos intervalos iniciais deste temporizador. \ a intervalo contagem deste system

Etapas para que se restaure um canvas:
  Call "gdi32.dll" "RestoreDC" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-restoredc
  \ A função RestoreDC restaura um contexto de dispositivo (DC) para o estado especificado.
    O canvas [hDC]
    e -1. [nSavedDC] \ O estado salvo a ser restaurado. 
    \Se este parâmetro for positivo, ele representa uma instância específica do estado a ser restaurado. 
    \Se este parâmetro for negativo, ele representa uma instância relativa ao estado atual. 
    \Nesse caso, o valor -1 restaura o estado salvo mais recentemente.

Etapas para que se restaure um contexto:
  Obtenha um saved contexto desde o contexto stack.
  Se o saved contexto for inexistente, cancele.
  Atribua a localização deste saved contexto à localização deste contexto.
  Atribua a orientação deste saved contexto à orientação deste contexto.
  Atribua a tamanho da letra deste saved contexto à tamanho da letra deste contexto.
  Atribua a cor deste saved contexto à cor deste contexto.
  Atribua o número deste saved contexto ao número deste contexto.
  Remove o saved contexto desde o contexto stack.
  Destrua o saved contexto.

Etapas para que se restaure uma janela do programa:
  Call "user32.dll" "ShowWindow" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-showwindow
  \ Define o estado de exibição da janela especificada.
    A janela do programa [hWnd] \ O número identificador da janela
    e 9 [nCmdShow = SW_RESTORE]. \Controla como a janela deve ser exibida.
    \SW_RESTORE (9) Ativa e exibe a janela. 
    \Se a janela for minimizada ou maximizada, o sistema a restaurará para seu tamanho e posição originais. 
    \Um aplicativo deve especificar este sinalizador ao restaurar uma janela minimizada.

Etapas para que se reverse algum tipo de linhas des textos selecionadas of uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Separe as linhas des textos of a caixa de texto a umas linhas des textos e umas linhas des textos selecionadas e uns segunda linhas des textos.
  Reverse o linhas des textos selecionadas.
  Posponha as linhas des textos para as linhas des textos desta caixa de texto.
  Posponha o linhas des textos selecionadas para as linhas des textos desta caixa de texto.
  Posponha a segunda linhas des textos para as linhas des textos desta caixa de texto.
  Renumere as linhas des textos desta caixa de texto.

Etapas para que se reverse uma cor:
  Se a cor for a cor preta, atribua a cor branca à cor; saia.
  Se a cor for a cor branca, atribua a cor preta à cor; saia.
  Atribua 1000 menos a luminosidade desta cor à luminosidade desta cor.
    \Atribua 1000 menos a saturação desta cor à saturação desta cor.
  Adicione 1800 para a matiz desta cor. Normalize a matiz desta cor.

Etapas para que se invert um detector;
Etapas para que se reverse um detector:
  Se o detector for 1, atribua 0 ao detector; saia.
  Atribua 1 ao detector.

Etapas para que se reverse uma string:
  \ podia ser more efficient
  Isole a string.
  Limpe o original string.
  Comece. [a executar o código abaixo]
    Se a string estiver em branco, pare.
    Obtenha um character desde a string (backwards).
    Posponha o character para o original string.
  Recomece. [percorra novamente o código acima]

Etapas para que se reverse umas coisas:
  Permute  as coisas com umas outras coisas.
  Comece. [a executar o código abaixo]
    Atribua a last coisa destas outras coisas a uma coisa.
    Se a coisa for inexistente, cancele.
    Mova a coisa desde a outras coisas para as coisas.
  Recomece. [percorra novamente o código acima]

Um deslocamento vertical é um número.
Um deslocamento horizontal é um número.

Etapas para que se rotate uma caixa:
  Atribua o centro desta caixa a um centro localização.
  Atribua a caixa a uma segunda caixa.
  Atribua a coordenada Y deste centro menos a coordenada Y do canto superior esquerdo desta segunda caixa mais a coordenada X deste centro à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada X do canto superior esquerdo desta segunda caixa menos a coordenada X deste centro mais a coordenada Y deste centro à coordenada Y do canto superior esquerdo desta caixa.
  Atribua a coordenada Y deste centro menos a coordenada Y do canto inferior direito desta segunda caixa mais a coordenada X deste centro à coordenada X do canto superior esquerdo desta caixa.
  Atribua a coordenada X do canto inferior direito desta segunda caixa menos a coordenada X deste centro mais a coordenada Y deste centro à coordenada Y do canto inferior direito desta caixa.

Etapas para que se rotate uma elipse:
  Rotate a caixa desta elipse.

Etapas para que se rotate um GpImage:
  Se o GpImage for inexistente, cancele.
  Call "gdiplus.dll" "GdipImageRotateFlip" com \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusheaders/nf-gdiplusheaders-image-rotateflip
  \A função GdipImageRotateFlip gira e/ou inverte a imagem. É a imagem que sofre a transformação e não o gráfico no qual será exibida.
  \O ângulo e a inversão são definidos por uma das constantes da enumeração RotateFlipType .
    O GpImage  [*image] \Ponteiro para o objeto Image .
    e 1 [Rotate90FlipNone].  \ Elemento da enumeração RotateFlipType que especifica o tipo de rotação e o tipo de inversão.
    \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusimaging/ne-gdiplusimaging-rotatefliptype
    \Tipo de rotação e inversão:
    \0 - Sem rotação e sem inversão (uma rotação de 180 graus, uma inversão horizontal e, em seguida, uma inversão vertical)
    \1 - Uma rotação de 90 graus sem inversão (uma rotação de 270 graus, uma inversão horizontal e depois uma inversão vertical)
    \2 - Uma rotação de 180 graus sem inversão (sem rotação, uma inversão horizontal seguida de uma inversão vertical)
    \3 - Uma rotação de 270 graus sem inversão (uma rotação de 90 graus, uma inversão horizontal e depois uma inversão vertical)
    \4 - Sem rotação e inversão horizontal (rotação de 180 graus seguida de inversão vertical)
    \5 - Uma rotação de 90 graus seguida por uma inversão horizontal (uma rotação de 270 graus seguida por uma inversão vertical)
    \6 - Uma rotação de 180 graus seguida por uma inversão horizontal (sem rotação e inversão vertical)
    \7 - Uma rotação de 270 graus seguida por uma inversão horizontal (uma rotação de 90 graus seguida por uma inversão vertical)

Etapas para que se rotate um GpImage usando um ângulo:
  \ o ângulo pode ser 0, 900, 1800, 2700
  Se o GpImage for inexistente, cancele.
  Atribua 0 [RotateNoneFlipNone] a um número.
  Se o ângulo for 900, atribua 1 [Rotate90FlipNone] ao número.
  Se o ângulo for 1800, atribua 2 [Rotate180FlipNone ] ao número.
  Se o ângulo for 2700, atribua 3 [Rotate270FlipNone ] ao número.
  Call "gdiplus.dll" "GdipImageRotateFlip" com \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusheaders/nf-gdiplusheaders-image-rotateflip
  \A função GdipImageRotateFlip gira e/ou inverte a imagem. É a imagem que sofre a transformação e não o gráfico no qual será exibida.
  \O ângulo e a inversão são definidos por uma das constantes da enumeração RotateFlipType .
    O GpImage  [*image] \Ponteiro para o objeto Image .
    e O número. \ Elemento da enumeração RotateFlipType que especifica o tipo de rotação e o tipo de inversão.
    \ https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusimaging/ne-gdiplusimaging-rotatefliptype
    \Tipo de rotação e inversão:
    \0 - Sem rotação e sem inversão (uma rotação de 180 graus, uma inversão horizontal e, em seguida, uma inversão vertical)
    \1 - Uma rotação de 90 graus sem inversão (uma rotação de 270 graus, uma inversão horizontal e depois uma inversão vertical)
    \2 - Uma rotação de 180 graus sem inversão (sem rotação, uma inversão horizontal seguida de uma inversão vertical)
    \3 - Uma rotação de 270 graus sem inversão (uma rotação de 90 graus, uma inversão horizontal e depois uma inversão vertical)
    \4 - Sem rotação e inversão horizontal (rotação de 180 graus seguida de inversão vertical)
    \5 - Uma rotação de 90 graus seguida por uma inversão horizontal (uma rotação de 270 graus seguida por uma inversão vertical)
    \6 - Uma rotação de 180 graus seguida por uma inversão horizontal (sem rotação e inversão vertical)
    \7 - Uma rotação de 270 graus seguida por uma inversão horizontal (uma rotação de 90 graus seguida por uma inversão vertical)

Etapas para que se rotate uma linha reta:
  Atribua o centro desta linha reta a um centro localização.
  Rotate a localização inicial desta linha reta around o centro.
  Rotate a localização final desta linha reta around o centro.

Etapas para que se rotate uma imagem:
  Se a imagem for inexistente, cancele.
  Adicione 900 para o ângulo de rotação desta imagem.
  Se o mirror detector desta imagem estiver ativo, adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Rotate a caixa desta imagem.
  Rotate a caixa intacta desta imagem.
  Atribua o centro desta caixa desta imagem a um centro localização.
  Atribua o centro desta caixa intacta desta imagem a uma segunda centro localização.
  Atribua a coordenada Y deste centro menos a coordenada Y desta segunda centro mais a coordenada X deste centro ao número X desse twip par de números.
  Subtraia a coordenada X desta segunda centro desde o número X deste twip par de números.
  Atribua a coordenada Y deste centro mais a coordenada X desta segunda centro menos a coordenada X deste centro ao número Y deste twip par de números.
  Subtraia a coordenada Y desta segunda centro desde o número Y deste twip par de números.
  Mova a caixa intacta desta imagem usando o twip par de números.
  Rotate o gpBitmap desta imagem.

Etapas para que se rotate um polígono:
  Se o polígono for inexistente, cancele.
  Atribua o centro deste polígono a um centro localização.
  Comece. [a executar o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Rotate a localização deste vértice around o centro.
  Recomece. [percorra novamente o código acima]

Etapas para que se rotate uma localização around um centro localização:
  Atribua a localização a uma segunda localização.
  Atribua a coordenada Y deste centro menos a coordenada Y desta segunda localização mais a coordenada X deste centro à coordenada X desta localização.
  Atribua a coordenada X desta segunda localização menos a coordenada X deste centro mais a coordenada Y deste centro à coordenada Y desta localização.

Etapas para que se rotate uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Rotate a caixa desta caixa de texto.
  Wrap a caixa de texto.

Etapas para que se arredonde um número para um segundo número:
  Arredonde o número para o múltiplo imediato of o segundo número.

Etapas para que se arredonde um número para baixo para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número.
  Multiplique o número pelo segundo número.

Etapas para que se arredonde um número para o múltiplo imediato of um outro número:
  Se o outro número for 0, cancele.
  Isole o outro número.
  Divida o número pelo outro número usando um quociente e um resto.
  Divida o outro número por 2.
  Se o resto for maior do que ou igual ao outro número, arredonde o número para cima para o múltiplo imediato of o original outro número; saia.
  Arredonde o número para baixo para o múltiplo imediato of o original outro número.

Etapas para que se arredonde um número para cima para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número usando um quociente e um resto.
  Se o resto for 0, cancele.
  Adicione o segundo número menos o resto para o número.

Etapas para que se arredonde um par de números para um segundo par de números:
  Arredonde o par de números para o múltiplo imediato of o segundo par de números.

Etapas para que se arredonde um par de números para o múltiplo imediato of um segundo par de números:
  Arredonde o número X deste par de números para o múltiplo imediato of o número X deste segundo par de números.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número Y deste segundo par de números.

Etapas para que se arredonde um par de números para o múltiplo imediato of um número:
  Arredonde o número X deste par de números para o múltiplo imediato of o número.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número.

Etapas para que se arredonde um par de números para um número:
  Arredonde o par de números para o múltiplo imediato of o número.

Uma caixa arredondada é uma caixa com
  Uma coordenada X do canto superior esquerdo, 
  Uma coordenada Y do canto superior esquerdo, 
  Uma coordenada X do canto inferior direito, 
  Uma coordenada Y do canto inferior direito,
  Um canto superior esquerdo localização sob a coordenada X do canto superior esquerdo , 
  Um canto inferior direito localização sob a coordenada X do canto inferior direito, e 
  Um raio.

Um número da linha é um número.

Etapas para que se salve um canvas:
  Call "gdi32.dll" "SaveDC" com \ \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-savedc
  \A função SaveDC salva o estado atual do contexto de dispositivo especificado (DC) 
  \copiando dados que descrevem objetos selecionados e modos gráficos 
  \(como bitmap, pincel, paleta, fonte, caneta, região, modo de desenho e modo de mapeamento) para um contexto pilha.
    o canvas. [hdc] \Um identificador para o DC cujo estado deve ser salvo.


Etapas para que se salve um contexto:
  Aloque memória para um saved contexto.
  Atribua a localização deste contexto à localização deste saved contexto.
  Atribua a orientação deste contexto à orientação deste saved contexto.
  Atribua a tamanho da letra deste contexto à tamanho da letra deste saved contexto.
  Atribua a cor deste contexto à cor deste saved contexto.
  Atribua o número deste contexto ao número deste saved contexto.
  Anteponha o saved contexto para o contexto stack.

A saved memory hBitMap é um hBitMap.

A saved quantidade de twips/pixel é um número.

Etapas para que se say um número:
  Atribua o número a uma string.
  Say a string.

Etapas para que se say uma string;
Etapas para que se speak uma string:
  Se o silent detector estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para uma string composta de caracteres amplos.
  Anexe o caractere NULL a string composta de caracteres amplos.
  Call o speak [o método speak] desta vtable deste talker com 
  \O método Speak inicia a fala de uma string de texto, um arquivo de texto, um arquivo XML ou um arquivo de onda pela voz.
    O talker 
    e O caractere inicial desta string composta de caracteres amplos 
    e 17 [SVSFDefault Especifica que as configurações padrão devem ser usadas.]
    [SVSFlagsAsync Especifica que a chamada de fala deve ser assíncrona. Ou seja, ele retornará imediatamente após a solicitação de fala ser colocada na fila.]
    [SVSFIsNotXML = O texto de entrada não será analisado para marcação XML.]
    [SVSFDefault+SVSFlagsAsync +SVSFIsNotXML = 17]  \ https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/ms720892(v=vs.85)
    e 0.

Etapas para que se say uma string e wait;
Etapas para que se speak uma string e wait:
  Se o silent detector estiver ativo, cancele.
  Se la bandera silenciosa estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para uma string composta de caracteres amplos.
  Anexe o caractere NULL a string composta de caracteres amplos.
  Call o speak [método speak] desta vtable deste talker com 
  \O método Speak inicia a fala de uma string de texto, um arquivo de texto, um arquivo XML ou um arquivo de onda pela voz.
    O talker 
    e O caractere inicial desta string composta de caracteres amplos 
    e 16 [ SVSFDefault Especifica que as configurações padrão devem ser usadas.]    
    [SVSFIsNotXML = O texto de entrada não será analisado para marcação XML.]
    [SVSFDefault+SVSFIsNotXML = 16]  \ https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/ms720892(v=vs.85)
    e 0.

Etapas para que se redimensione proporcionalmente uma caixa usando uma proporção;
Etapas para que se redimensione proporcionalmente uma caixa usando uma fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada X do canto superior esquerdo desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada Y do canto superior esquerdo desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada X do canto inferior direito desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada Y do canto inferior direito desta caixa usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa para um percentual:
  Atribua o percentual / 100 a uma fração.
  Redimensione proporcionalmente a caixa usando a fração.

Etapas para que se redimensione proporcionalmente uma elipse usando uma proporção;
Etapas para que se redimensione proporcionalmente uma elipse usando uma fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta elipse usando a fração.

Etapas para que se redimensione proporcionalmente uma elipse para um percentual:
  Atribua o percentual / 100 a uma fração.
  Redimensione proporcionalmente a elipse usando a fração.

Etapas para que se redimensione proporcionalmente uma fonte usando uma proporção;
Etapas para que se redimensione proporcionalmente uma fonte usando uma fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a altura desta fonte usando a fração.

Etapas para que se redimensione proporcionalmente uma fração usando uma segunda fração;
Etapas para que se multiplique uma fração por uma segunda fração:
  Multiplique o numerador desta fração pelo numerador desta segunda fração.
  Multiplique o denominador desta fração pelo denominador desta segunda fração.
  Reduza a fração.

Etapas para que se redimensione proporcionalmente uma linha reta usando uma proporção;
Etapas para que se redimensione proporcionalmente uma linha reta usando uma fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a localização inicial desta linha reta usando a fração.
  Redimensione proporcionalmente a localização final desta linha reta usando a fração.

Etapas para que se redimensione proporcionalmente uma linha reta para um percentual:
  Atribua o percentual / 100 a uma fração.
  Redimensione proporcionalmente a linha reta usando a fração.

Etapas para que se redimensione proporcionalmente um par de números usando uma proporção;
Etapas para que se redimensione proporcionalmente um par de números usando uma fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente o número X deste par de números usando a fração.
  Redimensione proporcionalmente o número Y deste par de números usando a fração.

Etapas para que se redimensione proporcionalmente um par de números usando um par de números racionais;
Etapas para que se redimensione proporcionalmente um par de números usando uma par de números fracionários:
  Redimensione proporcionalmente o número X deste par de números usando a fração deste par de números fracionários.
  Redimensione proporcionalmente o número Y deste par de números usando a segunda fração deste par de números fracionários.

Etapas para que se redimensione proporcionalmente um par de números para um percentual:
  Atribua o percentual / 100 a uma fração.
  Redimensione proporcionalmente o par de números usando a fração.

Etapas para que se redimensione proporcionalmente uma imagem usando uma proporção;
Etapas para que se redimensione proporcionalmente uma imagem usando uma fração:
  Se a imagem for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta imagem usando a fração.
  Redimensione proporcionalmente a caixa intacta desta imagem usando a fração.

Etapas para que se redimensione proporcionalmente uma imagem para um percentual:
  Se a imagem for inexistente, cancele.
  Atribua o percentual / 100 a uma fração.
  Redimensione proporcionalmente a imagem usando a fração.

Etapas para que se redimensione proporcionalmente um polígono usando uma proporção;
Etapas para que se redimensione proporcionalmente um polígono usando uma fração:
  Se o polígono for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Comece. [a executar o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Redimensione proporcionalmente o vértice usando a fração.
  Recomece. [percorra novamente o código acima]

Etapas para que se redimensione proporcionalmente um polígono para um percentual:
  Se o polígono for inexistente, cancele.
  Atribua o percentual / 100 a uma fração.
  Redimensione proporcionalmente o polígono usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa arredondada usando uma proporção;
Etapas para que se redimensione proporcionalmente uma caixa arredondada usando uma fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa arredondada como uma caixa usando a fração.
  Redimensione proporcionalmente o raio desta caixa arredondada usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa arredondada para um percentual:
  Atribua o percentual / 100 a uma fração.
  Redimensione proporcionalmente a caixa arredondada usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa de texto para uma fração:
  \ absolute
  Se a caixa de texto for inexistente, cancele.
  Atribua a scale desta caixa de texto a uma segunda fração.
  Flip a segunda fração.
  Multiplique a segunda fração pela fração.
  Redimensione proporcionalmente a caixa de texto usando a segunda fração.

Etapas para que se redimensione proporcionalmente uma caixa de texto usando uma proporção;
Etapas para que se redimensione proporcionalmente uma caixa de texto usando uma fração:
  Se a caixa de texto for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta caixa de texto usando a fração.
  Redimensione proporcionalmente a origem desta caixa de texto usando a fração.
  Redimensione proporcionalmente a fonte desta caixa de texto usando a fração.
  Redimensione proporcionalmente a scale desta caixa de texto usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa de texto para um percentual:
  Se a caixa de texto for inexistente, cancele.
  Atribua o percentual / 100 a uma fração.
  Redimensione proporcionalmente a caixa de texto usando a fração.

Etapas para que se redimensione proporcionalmente um vértice usando uma proporção;
Etapas para que se redimensione proporcionalmente um vértice usando uma fração:
  Se o vértice for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada X deste vértice usando a fração.
  Redimensione proporcionalmente a coordenada Y deste vértice usando a fração.

O tela canvas é um canvas.

A tela é um conjunto com 
  Uma caixa, 
  Uma pixel altura e 
  Uma pixel largura.

Etapas para que se role um console usando um evento:
  Se o console for inexistente, cancele.
  Encontre um sector usando a malha deste console e a localização deste evento.
  Comece. [a executar o código abaixo]
    Se o botão direito deste mouse não estiver sendo pressionado, cancele.
    Encontre uma segunda sector usando a malha deste console e a localização deste mouse.
    Obtenha um difference entre a segunda sector e o sector.
    Se a difference for 0, recomece.
    Role a caixa de texto deste console usando a difference.
    Mostre o console.
    Adicione a difference para o sector.
  Recomece. [percorra novamente o código acima]

Etapas para que se role uma caixa de texto para o base:
  Se a caixa de texto for inexistente, cancele.
  Se o detector de rolagem vertical desta caixa de texto não estiver ativo, cancele.
  Atribua a contagem de linhas desta caixa de texto menos 1 a um número.
  Atribua - o número times a altura da linha desta caixa de texto à coordenada Y desta caixa de texto.
  Limite a origem of a caixa de texto.

  Multiplique o número por -1.
  Multiplique o número pela altura da linha deste texto.
  Adicione 2 ao número.
  Atribua o número à Coordenada Y deste texto.

Etapas para que se role uma caixa de texto para o cursor de texto:
  Se a caixa de texto for inexistente, cancele.
  Se o número de coluna deste cursor de texto desta caixa de texto for 1, atribua a margem desta caixa de texto à coordenada X desta caixa de texto.
  Obtenha uma caixa pelo cursor de texto na caixa de texto.
  Ajuste a caixa usando 0 e - a quantidade de twips/pixel e 0 e a quantidade de twips/pixel . \ cursor de texto caixas do not preencha entire linha de texto
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa de texto, atribua a coordenada Y do canto superior esquerdo desta caixa de texto menos a coordenada Y do canto superior esquerdo desta caixa ao número Y dessa difference.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito desta caixa de texto, atribua a coordenada Y do canto inferior direito desta caixa de texto menos a coordenada Y do canto inferior direito desta caixa ao número Y desta difference.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo desta caixa de texto , atribua a coordenada X do canto superior esquerdo desta caixa de texto menos a coordenada X do canto superior esquerdo desta caixa ao número X desta difference.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito desta caixa de texto, atribua a coordenada X do canto inferior direito desta caixa de texto menos a coordenada X do canto inferior direito desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role a caixa de texto usando a difference.

Etapas para que se role uma caixa de texto para o cursor de texto e centralize-o:
  Se a caixa de texto for inexistente, cancele.
  Atribua a margem desta caixa de texto à coordenada X desta caixa de texto.
  Obtenha uma caixa pelo cursor de texto na caixa de texto.
  Se a caixa estiver inside a caixa desta caixa de texto, cancele.
  Ajuste a caixa usando 0 e - a quantidade de twips/pixel e 0 e a quantidade de twips/pixel . \ cursor de texto caixas don not preencha entire linha de texto
  Atribua o y-extent desta caixa desta caixa de texto dividido por 2 a uma altura.
  Arredonde a altura para baixo para o múltiplo imediato of a altura da linha desta caixa de texto.
  Atribua a coordenada Y do canto superior esquerdo desta caixa desta caixa de texto mais a altura a uma coordenada Y do canto superior esquerdo.
  Atribua a coordenada Y do canto superior esquerdo mais a altura da linha desta caixa de texto a uma coordenada Y do canto inferior direito.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo, atribua a coordenada Y do canto superior esquerdo menos a coordenada Y do canto superior esquerdo desta caixa ao número Y dessa difference.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito, atribua a coordenada Y do canto inferior direito menos a coordenada Y do canto inferior direito desta caixa ao número Y desta difference.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo desta caixa de texto , atribua a coordenada X do canto superior esquerdo desta caixa de texto menos a coordenada X do canto superior esquerdo desta caixa ao número X desta difference.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito desta caixa de texto, atribua a coordenada X do canto inferior direito desta caixa de texto menos a coordenada X do canto inferior direito desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role a caixa de texto usando a difference.

Etapas para que se role uma caixa de texto para baixo one linha reta:
  Se a caixa de texto for inexistente, cancele.
  Se o detector de rolagem vertical desta caixa de texto não estiver ativo, cancele.
  Atribua - a altura da linha desta caixa de texto ao número Y dessa difference. \ reescrever esse comando
  Role a caixa de texto usando a difference.

Etapas para que se role uma caixa de texto para baixo one página:
  Se a caixa de texto for inexistente, cancele.
  Se o detector de rolagem vertical desta caixa de texto não estiver ativo, cancele.
  Subtraia o y-extent desta caixa desta caixa de texto desde a coordenada Y desta caixa de texto.
  Adicione a altura da linha desta caixa de texto para a coordenada Y desta caixa de texto.
  Limite a origem of a caixa de texto.

Etapas para que se role uma caixa de texto usando um difference:
  Se a caixa de texto for inexistente, cancele.
  Isole a difference.
  Se o detector de rolagem horizontal desta caixa de texto não estiver ativo, atribua 0 ao número X desta difference.
  Se o detector de rolagem vertical desta caixa de texto não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, cancele.
  Mova a origem desta caixa de texto usando a difference.
  Limite a origem of a caixa de texto.

Etapas para que se role uma caixa de texto para o topo:
  Se a caixa de texto for inexistente, cancele.
  Se o detector de rolagem vertical desta caixa de texto não estiver ativo, cancele.
  Atribua 0 à coordenada Y desta caixa de texto.
  Limite a origem of a caixa de texto.

Etapas para que se role uma caixa de texto para cima one linha reta:
  Se a caixa de texto for inexistente, cancele.
  Se o detector de rolagem vertical desta caixa de texto não estiver ativo, cancele.
  Atribua a altura da linha desta caixa de texto ao número Y dessa difference.
  Role a caixa de texto usando a difference.

Etapas para que se role uma caixa de texto para cima one página:
  Se a caixa de texto for inexistente, cancele.
  Se o detector de rolagem vertical desta caixa de texto não estiver ativo, cancele.
  Adicione o y-extent desta caixa desta caixa de texto para a coordenada Y desta caixa de texto.
  Subtraia a altura da linha desta caixa de texto desde a coordenada Y desta caixa de texto.
  Limite a origem of a caixa de texto.

Um sector é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y [indicating o canto superior esquerdo of o sector].

A seed é um número.

Etapas para que se selecione cada byte em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Atribua 1 e 1 ao anchor desta caixa de texto.
  Atribua a quantidade de caracteres desta string deste last linha de texto destas linhas des textos desta caixa de texto e a contagem de linhas desta caixa de texto ao cursor de texto desta caixa de texto.

Etapas para que se selecione um número da linha usando uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Obtenha uma linha de texto usando o número da linha e a caixa de texto.
  Se a linha de texto for inexistente, cancele.
  Atribua o número da linha ao anchor número da linha desta caixa de texto .
  Atribua 1 ao anchor número de coluna desta caixa de texto.
  Atribua o número da linha ao número de linhas do cursor desta caixa de texto.
  Atribua a quantidade de caracteres desta string desta linha de texto ao cursor de texto número de coluna desta caixa de texto.

Uma caixa de seleção é uma caixa.

Uma seleção é um conjunto com 
  Um anchor número de coluna,
  Um anchor número da linha, 
  Um anchor sob o anchor número de coluna,
  Um cursor de texto número de coluna, 
  Um número de linhas do cursor, 
  Um cursor de texto sob o cursor de texto número de coluna.

Etapas para que se send um trecho para um socket:
  Limpe o erro do fluxo de entrada/saída.
  Atribua o caractere inicial deste trecho a um ponteiro.
  Atribua a quantidade de caracteres deste trecho a uma quantidade de caracteres.
  Comece. [a executar o código abaixo]
  Se a quantidade de caracteres for 0, pare.
    Call "ws2_32.dll" "send" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winsock2/nf-winsock2-send
    \ A função send envia dados em um soquete conectado.
       O socket [s] \ Um descritor que identifica um soquete conectado.
       e O ponteiro [*buf] \ Um ponteiro para um buffer que contém os dados a serem transmitidos.
       e A quantidade de caracteres [len] \ O comprimento, em bytes, dos dados no buffer apontados pelo parâmetro buf.
       e 0 [flags] \ Um conjunto de sinalizadores que especificam a maneira como a chamada é feita. Este parâmetro é construído usando o a disjunção lógica
       devolvendo um número. \ Se nenhum erro ocorrer, a função send retorna o número total de bytes enviados, que pode ser menor que o número solicitado para envio no parâmetro len. 
       \Caso contrário, o valor -1 (SOCKET_ERROR) é retornado.
    Se o número for -1 [SOCKET_ERROR ], atribua "Ocorreu um erro ao enviar os dado para o soquete." ao erro do fluxo de entrada/saída; saia.
    Subtraia o número desde a quantidade de caracteres.
    Adicione o número para o ponteiro.
  Recomece. [percorra novamente o código acima]

Etapas para que se send um data string para uma requisição WinHTTP:
  Se a requisição WinHTTP for inexistente, cancele.
  Call "WinHTTP.dll" "WinHttpSendRequest" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winhttp/nf-winhttp-winhttpsendrequest
  \ A função WinHttpSendRequest envia a solicitação especificada ao servidor HTTP.
    O número identificador de requisição desta requisição WinHTTP [hRequest] \ Um identificador HINTERNET retornado por WinHttpOpenRequest.
    \ https://docs.microsoft.com/pt-br/windows/win32/winhttp/hinternet-handles-in-winhttp
    \ https://docs.microsoft.com/pt-br/windows/win32/api/winhttp/nf-winhttp-winhttpopenrequest
    e 0 [lpszHeaders = WINHTTP_NO_ADDITIONAL_HEADERS] \Um ponteiro para uma string que contém os cabeçalhos adicionais a serem anexados à solicitação.
    \Este parâmetro pode ser WINHTTP_NO_ADDITIONAL_HEADERS se não houver cabeçalhos adicionais para anexar.
    e 0 [dwHeadersLength] \valor que contém o comprimento, em caracteres, dos cabeçalhos adicionais. 
    \Se este parâmetro for -1L e pwszHeaders não for NULL, esta função pressupõe que pwszHeaders tem terminação nula e o comprimento é calculado.
    e O caractere inicial desta data string [lpOptional] \Um ponteiro para um buffer que contém quaisquer dados opcionais para enviar imediatamente após os cabeçalhos da solicitação. 
    \Este parâmetro é geralmente usado para operações POST e PUT. Os dados opcionais podem ser o recurso ou dados postados no servidor. 
    \Este parâmetro pode ser WINHTTP_NO_REQUEST_DATA se não houver dados opcionais para enviar.
    \Se o parâmetro dwOptionalLength for 0, esse parâmetro será ignorado e definido como NULL.
    e A quantidade de caracteres destes data string [dwOptionalLength] \valor que contém o comprimento, em bytes, dos dados opcionais. 
    \Este parâmetro pode ser zero se não houver dados opcionais para enviar.
    \Este parâmetro deve conter um comprimento válido quando o parâmetro lpOptional não é NULL. 
    \Caso contrário, lpOptional é ignorado e definido como NULL.
    e A quantidade de caracteres destes data string [dwTotalLength] \valor que contém o comprimento, em bytes, do total de dados enviados. 
    \Este parâmetro especifica o cabeçalho Content-Length da solicitação. 
    \Se o valor desse parâmetro for maior que o comprimento especificado por dwOptionalLength, WinHttpWriteData pode ser usado para enviar dados adicionais.
    e 0 [dwContext] \Um ponteiro para uma variável de tamanho de ponteiro 
    \que contém um valor definido pelo aplicativo que é passado, com o identificador de solicitação, para qualquer função de retorno de chamada.
    devolvendo um número resultante. \Retorna TRUE se for bem-sucedido ou FALSE caso contrário.
  Se o número resultante for 0, atribua "Erro. Não foi possível enviar a solicitação." ao erro do fluxo de entrada/saída; saia.

Etapas para que se send um email:
  Limpe o erro do fluxo de entrada/saída.
  \ crie socket
  Crie um socket usando o smtp server deste email e 25.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  \ initial receive here por date/time stuff desde server
  Receive um response string desde o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; saia.
  Se o response string começa com "5", atribua o response string ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; saia.
  \ send HELO
  Send "HELO " junto com o nome deste module junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; saia.
  Se o response string começa com "5", atribua o response string ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; saia.
  \ send MAIL FROM: <xxx>
  Send "MAIL FROM: <" junto com o sender deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; saia.
  Se o response string começa com "5", atribua o response string ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; saia.
  \ send RCPT TO: <xxx>
  Send "RCPT TO: <" junto com o recipient deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; saia.
  Se o response string começa com "5", atribua o response string ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; saia.
  \ send DATA
  Send "DATA" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; saia.
  Se o response string começa com "5", atribua o response string ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; saia.
  \ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
  Limpe um temp string.
  Posponha "De: " junto com o sender deste email junto com o texto CRLF para o temp string.
  Posponha "Para: " junto com o recipient deste email junto com o texto CRLF para o temp string.
  Posponha "Assunto: " junto com o subject deste email junto com o texto CRLF ao temp string.
  Posponha "Reply-To: " junto com o sender deste email junto com o texto CRLF ao temp string.
  Posponha o texto CRLF para o temp string.
  Posponha a message deste email para o temp string (handling email transparency).
  Posponha o texto CRLF seguido de "." junto com o texto CRLF para o temp string.
  Send o temp string para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; saia.
  Se o response string começa com "5", atribua o response string ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; saia.
  \ send QUIT
  Send "QUIT" junto com o texto CRLF para o socket.
  \ destrua socket
  Destrua o socket.

Etapas para que se send um message desde um sender para um recipient:
  Send o message para o recipient desde o sender.

Etapas para que se send um message desde um sender para um recipient via um smtp server:
  Send o message para o recipient desde o sender via o smtp server.

Etapas para que se send um message desde um sender para um recipient com um subject:
  Send o message para o recipient desde o sender com o subject.

Etapas para que se send um message desde um sender para um recipient com um subject via um smtp server:
  Send o message para o recipient desde o sender com o subject via o smtp server.

Etapas para que se send um message para um recipient desde um sender:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender com um subject:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender com um subject via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send uma string para um socket e receive um response string:
  Limpe a response string.
  Send a string para o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Receive a response string desde o socket.

Um sender é uma string.

Etapas para que se defina o código da cor of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetTextColor" com \https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-settextcolor
  \A função SetTextColor define a cor do texto para o contexto de dispositivo especificado para a cor especificada.
  \A cor do texto é usada para desenhar a face de cada caractere escrito pelas funções TextOut e ExtTextOut. 
  \A cor do texto também é usada na conversão de bitmaps coloridos em monocromáticos e vice-versa.
    O canvas [hdc] \O número identificador do contexto do dispositivo.
    e O código da cor.\A cor do texto.
    \Se a função for bem-sucedida, o valor de retorno é uma referência de cor para a cor do texto anterior como um valor COLORREF.
    \Se a função falhar, o valor de retorno é CLR_INVALID.

Etapas para que se defina o drawing origem para uma localização:
  Call "gdi32.dll" "GetDeviceCaps" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getdevicecaps
  \ A função GetDeviceCaps recupera informações específicas do dispositivo para o dispositivo especificado.
    O quadro atual [hdc] \O número identificador do contexto do dipositivo
    e 112 [index = PhysicalOffsetX] \O item a ser devolvido.
    \PHYSICALOFFSETY = Para dispositivos de impressão: a distância da borda superior da página física até a borda superior da área imprimível, em unidades de dispositivo. 
    \Por exemplo, uma impressora configurada para imprimir a 600 dpi em papel de 8,5 por 11 polegadas, 
    \que não pode imprimir no papel de 0,5 polegada superior, tem um deslocamento físico vertical de 300 unidades de dispositivo.
    \PHYSICALOFFSETX = a mesma coisa, só que referente a distância da borda esquerda da página física até a borda esquerda da área imprimível, em unidades de dispositivo.
    devolvendo o número X desse par de números. \O valor de retorno especifica o valor do item desejado.
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 113 [PhysicalOffsetY ] 
    devolvendo o número Y deste par de números.
  Negate o par de números.
  Se o quadro atual não for a área de impressão, limpe o par de números.
  Call "gdi32.dll" "SetViewportOrgEx" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-setviewportorgex
  \ A função SetViewportOrgEx especifica qual ponto do dispositivo mapeia para a origem da janela (0,0).
    O quadro atual [hdc] \Um identificador para o contexto do dispositivo.
    e O número X deste par de números [x] \A coordenada x, em unidades de dispositivo, da nova origem da janela de exibição.
    e O número Y deste par de números  [y] \A coordenada y, em unidades de dispositivo, da nova origem da janela de visualização.
    e nil. [lppt] \Um ponteiro para uma estrutura POINT que recebe a origem da viewport anterior, nas coordenadas do dispositivo. Se lpPoint for NULL, este parâmetro não será usado.
    \ https://docs.microsoft.com/pt-br/previous-versions/dd162805(v=vs.85)
  Isole a localização.
  Call "gdi32.dll" "LPtoDP" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-lptodp
  \A função LPtoDP converte coordenadas lógicas em coordenadas de dispositivo.
  \A conversão depende do modo de mapeamento do contexto do dispositivo, das configurações das origens e extensões da janela e da janela de visualização e da transformação do mundo.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e O endereçamento desta localização [lppt] \Um ponteiro para uma matriz de estruturas POINT. 
    \As coordenadas x e as coordenadas y contidas em cada uma das estruturas POINT serão transformadas.
    \A estrutura POINT define as coordenadas X e Y de um ponto.
    e 1. [c] \O número de pontos na matriz.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    e nil.

Etapas para que se acione um detector;
Etapas para que se ative um detector;
Etapas para que se dispare um detector;
Etapas para que se toque um detector;
Etapas para que se ligue um detector:
  Atribua 1 ao detector. \ era "Atribua sim ao detector." O valor binário do termo sim era herdado do CAL-1000 de acordo com o Dan.

Etapas para que se defina um endereço completo para read-write mode:
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-getfileattributesa
  \Obtém atributos do sistema de arquivos para um arquivo ou diretório especificado.
  \Para obter mais informações sobre o atributo obtido, use a função GetFileAttributesEx.
  \Os atributos de arquivo são valores de metadados armazenados pelo sistema de arquivos em disco 
  \e são usados pelo sistema e estão disponíveis para desenvolvedores por meio de várias APIs de E/S de arquivo.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo ou diretório.
    devolvendo um número.\Se a função for bem-sucedida, o valor de retorno conterá os atributos do arquivo ou diretório especificado. 
    \Para obter uma lista de valores de atributo e suas descrições, consulte https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-attribute-constants
  Conjuncione logicamente o número com -2 [todos os atributos com exceção de FILE_ATTRIBUTE_READONLY].
  Call "kernel32.dll" "SetFileAttributesA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-setfileattributesa
  \ Define os atributos de um arquivo ou diretório.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo cujos atributos devem ser definidos.
    e O número. [dwFileAttributes] \Os atributos de arquivo a serem definidos para o arquivo.
    \Este parâmetro pode ser um ou mais valores, combinados usando a disjunção lógica (OR)

Um folha é uma caixa. \ Uma folha de papel virtual consiste de um retângulo

Etapas para que se mostre um console:
  Se o console for inexistente, cancele.
  Salve o quadro atual.
  Pinte o console.
  Atualize o tela usando a caixa deste console.
  Restaure o quadro atual.

Etapas para que se mostre um cursor:
  Call "user32.dll" "SetCursor" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-setcursor
  \ Define o formato do cursor.
    o cursor. [hCursor] \O número identificador do cursor. 
    \O cursor deve ter sido criado pela função CreateCursor ou carregado pela função LoadCursor ou LoadImage. 
    \Se este parâmetro for NULL, o cursor será removido da tela.
  Call "user32.dll" "ShowCursor" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-showcursor
  \ Exibe ou oculta o cursor.
    1 [bShow] \ Se bShow for TRUE, a contagem de exibição é incrementada em um. Se bShow for FALSE, a contagem de exibição é diminuída em um.
    devolvendo um número. \O valor de retorno especifica o novo contador de exibição.
    \Esta função define um contador interno de exibição que determina se o cursor deve ser exibido. 
    \O cursor é exibido apenas se a contagem de exibição for maior ou igual a 0. 
    \Se um mouse for instalado, a contagem de exibição inicial será 0. Se nenhum mouse estiver instalado, a contagem de exibição será -1.
  Se o número for maior do que 0, saia.
  Recomece. [percorra novamente o código acima]

Etapas para que se mostre um terminal:
  Se o terminal for inexistente, cancele.
  Salve o quadro atual.
  Pinte o terminal.
  Atualize o tela usando a caixa deste terminal.
  Restaure o quadro atual.

Etapas para que se shrink uma caixa por uns twips;
Etapas para que se indent uma caixa uns twips;
Etapas para que se indent uma caixa por uns twips;
Etapas para que se indent uma caixa uns twips sobre cada side;
Etapas para que se indent uma caixa usando uns twips:
  Adicione os twips para a coordenada X do canto superior esquerdo desta caixa.
  Adicione os twips para a coordenada Y do canto superior esquerdo desta caixa.
  Subtraia os twips desde a coordenada X do canto inferior direito desta caixa.
  Subtraia os twips desde a coordenada Y do canto inferior direito desta caixa.

Etapas para que se feche o programa;
Etapas para que se feche o nosso programa;
Etapas para que se feche nosso programa;
Etapas para que se feche tudo;
Etapas para que se shut para baixo:
  Destrua a Bíblia.
  Destrua o stack.
  Destrua o dicionário léxico.
  Destrua o console.
  Destrua o terminal.
  Finalize o contexto.
  Finalize os canvases.
  Finalize o mouse.
  Finalize os cursors.
  Finalize as fontes.
  Finalize a janela do programa.
  Finalize o tela.
  Finalize as cores.
  Finalize o module.
  Finalize o talker.
  Finalize gdi+.
  Finalize winsock.
  Finalize COM.

Etapas para que se shut para baixo o cgi:
  Finalize o cgi.
  Finalize o module.
  Finalize winsock.

O silent detector é um detector.

Etapas para que se simplify um texto retornado:
  Se o texto retornado estiver em branco, pare.
  Obtenha um byte desde o texto retornado.
  Se o byte é algum tipo de sinal de pontuação, recomece.
  Posponha o byte para uma string.
  Recomece. [percorra novamente o código acima]
  Atribua a string ao texto retornado.

Um size é uns twips.

Etapas para que se skip algum tipo de leading quebra de linha em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere inicial deste subtexto não for a quebra de linha, cancele.
  Adicione 1 para o caractere inicial deste subtexto.

Etapas para que se skip algum tipo de leading noise em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere inicial deste subtexto não for irrelevante, cancele.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se skip algum tipo de non-alfanumérico bytes em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere inicial deste subtexto for alfanumérico, cancele.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se skip uma linha reta sobre o terminal:
  Escreva "" sobre o terminal.

Etapas para que se skip palavra characters em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o subtexto está sobre alguma espécie de contração, adicione 1 para o caractere inicial deste subtexto; recomece.
  Se o conteúdo deste caractere inicial deste subtexto não for alfanumérico, cancele.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se lance um percorredor sobre um segundo percorredor:
  Lance o segmento final deste percorredor sobre o segmento final deste segundo percorredor.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas para que se lance um percorredor sobre uma string:
  Lance o subtexto original deste percorredor sobre a string.
  Lance o segmento final deste percorredor sobre a string.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas para que se lance um subtexto sobre qualquer trecho selecionado em uma linha de texto of uma caixa de texto:
  Limpe o subtexto.
  Se a caixa de texto for inexistente, cancele.
  Se a linha de texto of a caixa de texto não estiver selecionado, cancele.
  Lance o subtexto sobre a string deste linha de texto.
  Atribua a normalized seleção desta caixa de texto a uma seleção.
  Se o número da linha desta linha de texto é o número de linhas do cursor desta seleção, atribua o caractere inicial deste subtexto mais o cursor de texto número de coluna desta seleção menos 2 ao caractere final deste subtexto.
  Se o número da linha desta linha de texto é o anchor número da linha desta seleção, atribua o caractere inicial deste subtexto mais o anchor número de coluna desta seleção menos 1 ao caractere inicial deste subtexto.

Etapas para que se lance um subtexto sobre o first byte of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o caractere inicial desta string ao caractere final deste subtexto.

Etapas para que se lance um subtexto sobre o last byte of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o caractere final desta string ao caractere inicial deste subtexto.

Etapas para que se suavize um polígono:
  Se o polígono for inexistente, cancele.
  Se a contagem destes vértices deste polígono for menor do que 3, cancele.
  Se o polígono estiver closed, posponha a localização deste next deste first vértice deste polígono para o polígono; ative um detector.
  Atribua o first vértice deste polígono a um esquerdo vértice.
  Comece. [a executar o código abaixo]
    Se o next deste esquerdo vértice for inexistente, pare.
    Atribua o next deste esquerdo vértice a um direito vértice.
    Obtenha um centro localização usando a localização deste esquerdo vértice e a localização deste direito vértice.
    Insira o centro ao polígono after o esquerdo vértice.
    Atribua o next deste esquerdo vértice a um new vértice.
    Se o previous deste esquerdo vértice for inexistente, atribua o direito vértice ao esquerdo vértice; recomece.
    Obtenha uma segunda centro localização usando a localização deste previous deste esquerdo vértice e a localização deste new vértice.
    Obtenha um difference entre a segunda centro e a localização deste esquerdo vértice.
    Divida a difference por 2.
    Adicione a difference para a localização deste esquerdo vértice.
    Atribua o direito vértice ao esquerdo vértice.
  Recomece. [percorra novamente o código acima]
  Se o detector não estiver ativo, cancele.
  Destrua o first vértice deste polígono usando o polígono.
  Destrua o last vértice deste polígono usando o polígono.

Etapas para que se suavize um polígono uns times; 
Etapas para que se suavize um polígono umas vezes:
  \ this use para "times" é um fluke, I think -- see "some times é um número"
  Isole o times.
  Comece. [a executar o código abaixo]
    Se o times for 0, cancele.
    Suavize o polígono.
    Subtraia 1 desde o times.
  Recomece. [percorra novamente o código acima]

Some vezes é um número.

Um smtp server é uma string.

Um socket é um ponteiro.

Etapas para que se classifique algum tipo de linhas des textos selecionadas em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Separe as linhas des textos of a caixa de texto a umas linhas des textos e umas linhas des textos selecionadas e uns segunda linhas des textos.
  Classifique o linhas des textos selecionadas.
  Posponha as linhas des textos para as linhas des textos desta caixa de texto.
  Posponha o linhas des textos selecionadas para as linhas des textos desta caixa de texto.
  Posponha a segunda linhas des textos para as linhas des textos desta caixa de texto.
  Renumere as linhas des textos desta caixa de texto.

Etapas para que se classifique umas linhas des textos:
  Se o first linha de texto destas linhas des textos for o last linha de texto destas linhas des textos, cancele.
  Separe as linhas des textos a uns linhas des textos anteriores e umas linhas des textos posteriores.
  Classifique as linhas des textos anteriores.
  Classifique as linhas des textos posteriores.
  Comece. [a executar o código abaixo]
    Atribua o first linha de texto destas linhas des textos anteriores a uma linha de texto anterior.
    Atribua o first linha de texto destas linhas des textos posteriores a uma linha de texto posterior.
    Se a linha de texto anterior for inexistente, posponha as linhas des textos posteriores para as linhas des textos; saia.
    Se a linha de texto posterior for inexistente, posponha as linhas des textos anteriores para as linhas des textos; saia.
    Se a string desta linha de texto anterior for maior do que a string desta linha de texto posterior, mova a linha de texto posterior desde as linhas des textos posteriores para as linhas des textos; recomece.
    Mova a linha de texto anterior desde as linhas des textos anteriores para as linhas des textos.
  Recomece. [percorra novamente o código acima]

Etapas para que se separe um trecho para umas díades:
  Destrua as díades.
  Se o trecho estiver em branco, cancele.
  Lance um percorredor sobre o trecho.
  Comece. [a executar o código abaixo]
    Mova o percorredor usando o & comercial.
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Crie uma díade.
    Posponha a díade para as díades.
    Separe o segmento inicial deste percorredor a um nome subtexto e um query subtexto usando o sinal de igualdade.
    Atribua o nome subtexto ao nome deste díade.
    Converta o query subtexto como um texto de consulta ao value deste díade.
  Recomece. [percorra novamente o código acima]

Etapas para que se separe um byte para uma cifra binária e uma segunda cifra binária:
  Atribua o byte à cifra binária.
  Desloque a cifra binária 4 bits para a direita.
  Atribua o byte ao segunda cifra binária.
  Conjuncione logicamente a segunda cifra binária com 15.

Etapas para que se separe uma linha reta para uma segunda linha reta e um terceiro linha reta:
  Isole a linha reta.
  Atribua o centro desta linha reta a um centro localização.
  Atribua a localização inicial desta linha reta e o centro ao segunda linha reta.
  Atribua o centro e a localização final desta linha reta ao terceiro linha reta.

Etapas para que se separe um número para um word e uma segunda word:
  Isole o número.
  Desloque o número 16 bits para a direita.
  Atribua o número ao word.
  Atribua o original número ao segunda word.

Etapas para que se separe as linhas des textos of uma caixa de texto para umas linhas des textos e umas linhas des textos selecionadas e uns segunda linhas des textos:
  Se a caixa de texto for inexistente, limpe as linhas des textos; limpe o linhas des textos selecionadas; limpe as segunda linhas des textos; saia.
  Comece. [a executar o código abaixo]
    Atribua o first destas linhas des textos desta caixa de texto a uma linha de texto.
    Se a linha de texto for inexistente, cancele.
    Remove a linha de texto desde as linhas des textos desta caixa de texto.
    Se a linha de texto of a caixa de texto estiver selecionado, acione um detector; posponha a linha de texto para o linhas des textos selecionadas; recomece.
    Se o detector estiver ativo, posponha a linha de texto para a segunda linhas des textos; recomece.
    Posponha a linha de texto para as linhas des textos.
  Recomece. [percorra novamente o código acima]

Etapas para que se separe uma string para um subtexto anterior e um subtexto posterior usando um separator byte:
  Limpe o subtexto anterior.
  Limpe o subtexto posterior.
  Se a string estiver em branco, cancele.
  Atribua o caractere inicial desta string ao caractere inicial desse subtexto.
  Atribua o caractere inicial deste subtexto menos 1 ao caractere final deste subtexto.
  Comece. [a executar o código abaixo]
    Se o caractere final deste subtexto for maior do que o caractere final desta string, cancele.
    Adicione 1 para o caractere final deste subtexto.
    Se o conteúdo deste caractere final deste subtexto for o separator byte, pare.
  Recomece. [percorra novamente o código acima]
  Atribua o caractere inicial deste subtexto ao caractere inicial deste subtexto anterior.
  Atribua o caractere final deste subtexto menos 1 ao caractere final deste subtexto anterior.
  Atribua o caractere final deste subtexto mais 1 ao caractere inicial deste subtexto posterior.
  Atribua o caractere final desta string ao caractere final deste subtexto posterior.

Etapas para que se separe uma string para uns conjuntos des textos usando um separator byte:
  Destrua o conjuntos des textos.
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Comece. [a executar o código abaixo]
    Mova o percorredor usando o separator byte.
    Adicione o segmento inicial deste percorredor para o conjuntos des textos.
    Se o segmento final deste percorredor estiver em branco, pare.
  Recomece. [percorra novamente o código acima]
  Se o conteúdo deste caractere final desta string não for o separator byte, cancele.
  Adicione "" para o conjuntos des textos.

Etapas para que se separe umas coisas para umas coisas anteriores e umas coisas posteriores:
  Se  as coisas estiverem vazias, limpe as coisas anteriores; limpe as coisas posteriores; saia.
  Atribua a contagem destas coisas dividido por 2 a uma contagem.
  Comece. [a executar o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a contagem for 0, pare.
    Subtraia 1 desde a contagem.
    Recomece. [percorra novamente o código acima]
    Separe  as coisas ao coisas anteriores e as coisas posteriores sob a coisa.

Etapas para que se separe umas coisas para umas coisas anteriores e umas coisas posteriores sob um coisa:
  Limpe as coisas anteriores.
  Limpe as coisas posteriores.
  Se a coisa for inexistente, permute  as coisas com as coisas anteriores; saia.
  Se o previous coisa desta coisa for inexistente, permute  as coisas com as coisas anteriores; saia. 
  Atribua a first coisa destas coisas ao first coisa destas coisas anteriores.
  Atribua o previous coisa desta coisa ao last coisa destas coisas anteriores.
  Esvazie o next deste previous coisa desta coisa.  
  Atribua a coisa ao first coisa destas coisas posteriores.
  Esvazie o previous coisa desta coisa.
  Atribua a last coisa destas coisas ao last destas coisas posteriores.  
  Limpe as coisas.

Etapas para que se separe um word para um byte e um segundo byte:
  Isole a word.
  Desloque a word 8 bits para a direita.
  Atribua a word ao byte.
  Atribua o original word ao segundo byte.

Uma localização é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y e 
  Uma left sob a coordenada X e  
  Um topo sob a coordenada Y. 

Um topo é uns twips.
Um left é uns twips. \ IMPORTANTE

Uma ponteiro da localização é um ponteiro para uma localização.

Etapas para que se square para cima algum tipo de seleção em uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se nada estiver selecionado na caixa de texto, cancele.
  Normalize a seleção desta caixa de texto.
  Obtenha uma linha de texto usando o número de linhas do cursor desta caixa de texto e a caixa de texto.
  Atribua 1 ao anchor número de coluna desta caixa de texto.
  Se o cursor de texto número de coluna desta caixa de texto não for 1, adicione 1 para o número de linhas do cursor desta caixa de texto; atribua 1 ao cursor de texto número de coluna desta caixa de texto.
  Se o número de linhas do cursor desta caixa de texto for menor do que ou igual à contagem de linhas desta caixa de texto, cancele.
  Atribua a contagem de linhas desta caixa de texto ao número da linha deste cursor de texto desta caixa de texto.
  Atribua a quantidade de caracteres desta string desta linha de texto ao número de coluna deste cursor de texto desta caixa de texto.

Etapas para que se start anywhere em uma caixa:
  Escolha aleatoriamente a localização deste contexto na caixa.

Etapas para que se start anywhere sobre um linha reta horizontal:
  Escolha aleatoriamente uma localização sobre o linha reta horizontal.
  Atribua a localização à localização deste contexto.

Etapas para que se start sob o canto inferior esquerdo of uma caixa facing east:
  Atribua o canto inferior esquerdo desta caixa à localização deste contexto.
  Face east.

Etapas para que se start sob o canto inferior esquerdo of uma caixa facing north:
  Atribua o canto inferior esquerdo desta caixa à localização deste contexto.
  Vire para cima.

Etapas para que se start sob o canto inferior esquerdo of uma caixa facing south:
  Atribua o canto inferior esquerdo desta caixa à localização deste contexto.
  Face south.

Etapas para que se start sob o canto inferior esquerdo of uma caixa facing west:
  Atribua o canto inferior esquerdo desta caixa à localização deste contexto.
  Face west.

Etapas para que se start sob o base of um linha reta horizontal:
  Atribua a localização final desta linha reta vertical à localização deste contexto.

Etapas para que se start sob o canto base direito of uma caixa facing east:
  Atribua o canto inferior direito desta caixa à localização deste contexto.
  Face east.

Etapas para que se start sob o canto base direito of uma caixa facing north:
  Atribua o canto inferior direito desta caixa à localização deste contexto.
  Vire para cima.

Etapas para que se start sob o canto base direito of uma caixa facing south:
  Atribua o canto inferior direito desta caixa à localização deste contexto.
  Face south.

Etapas para que se start sob o canto base direito of uma caixa facing west:
  Atribua o canto inferior direito desta caixa à localização deste contexto.
  Face west.

Etapas para que se start sob a esquerda of um linha reta horizontal;
Etapas para que se start sob o lado esquerdo of um linha reta horizontal:
  Atribua à localização inicial desta linha reta horizontal à localização deste contexto.

Etapas para que se start sob o middle of o base of uma caixa;
Etapas para que se start no middle of o base of uma caixa;
Etapas para que se start sob o centro of o base of uma caixa;
Etapas para que se start no centro of o base of uma caixa:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste contexto.

Etapas para que se start sob o middle of o base of uma caixa facing east;
Etapas para que se start no middle of o base of uma caixa facing east;
Etapas para que se start sob o centro of o base of uma caixa facing east;
Etapas para que se start no centro of o base of uma caixa facing east:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste contexto.
  Face east.

Etapas para que se start sob o middle of o base of uma caixa facing north;
Etapas para que se start no middle of o base of uma caixa facing north;
Etapas para que se start sob o centro of o base of uma caixa facing north;
Etapas para que se start no centro of o base of uma caixa facing north:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste contexto.
  Vire para cima.

Etapas para que se start sob o middle of o base of uma caixa facing south;
Etapas para que se start no middle of o base of uma caixa facing south;
Etapas para que se start sob o centro of o base of uma caixa facing south;
Etapas para que se start no centro of o base of uma caixa facing south:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste contexto.
  Face south.

Etapas para que se start sob o middle of o base of uma caixa facing west;
Etapas para que se start no middle of o base of uma caixa facing west;
Etapas para que se start sob o centro of o base of uma caixa facing west;
Etapas para que se start no centro of o base of uma caixa facing west:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste contexto.
  Face west.

Etapas para que se start sob o middle of o lado esquerdo of uma caixa facing east;
Etapas para que se start no middle of o lado esquerdo of uma caixa facing east;
Etapas para que se start sob o centro of o lado esquerdo of uma caixa facing east;
Etapas para que se start no centro of o lado esquerdo of uma caixa facing east:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste contexto.
  Atribua o y deste centro desta caixa à coordenada Y desta localização deste contexto.
  Face east.

Etapas para que se start sob o middle of o lado esquerdo of uma caixa facing north;
Etapas para que se start no middle of o lado esquerdo of uma caixa facing north;
Etapas para que se start sob o centro of o lado esquerdo of uma caixa facing north;
Etapas para que se start no centro of o lado esquerdo of uma caixa facing north:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste contexto.
  Atribua o y deste centro desta caixa à coordenada Y desta localização deste contexto.
  Vire para cima.

Etapas para que se start sob o middle of o lado esquerdo of uma caixa facing south;
Etapas para que se start no middle of o lado esquerdo of uma caixa facing south;
Etapas para que se start sob o centro of o lado esquerdo of uma caixa facing south;
Etapas para que se start no centro of o lado esquerdo of uma caixa facing south:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste contexto.
  Atribua o y deste centro desta caixa à coordenada Y desta localização deste contexto.
  Face south.

Etapas para que se start sob o middle of o lado esquerdo of uma caixa facing west;
Etapas para que se start no middle of o lado esquerdo of uma caixa facing west;
Etapas para que se start sob o centro of o lado esquerdo of uma caixa facing west;
Etapas para que se start no centro of o lado esquerdo of uma caixa facing west:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste contexto.
  Atribua o y deste centro desta caixa à coordenada Y desta localização deste contexto.
  Face west.

Etapas para que se start sob o middle of o lado direito of uma caixa facing east;
Etapas para que se start no middle of o lado direito of uma caixa facing east;
Etapas para que se start sob o centro of o lado direito of uma caixa facing east;
Etapas para que se start no centro of o lado direito of uma caixa facing east:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste contexto.
  Atribua o y deste centro desta caixa à coordenada Y desta localização deste contexto.
  Face east.

Etapas para que se start sob o middle of o lado direito of uma caixa facing north;
Etapas para que se start no middle of o lado direito of uma caixa facing north;
Etapas para que se start sob o centro of o lado direito of uma caixa facing north;
Etapas para que se start no centro of o lado direito of uma caixa facing north:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste contexto.
  Atribua o y deste centro desta caixa à coordenada Y desta localização deste contexto.
  Vire para cima.

Etapas para que se start sob o middle of o lado direito of uma caixa facing south;
Etapas para que se start no middle of o lado direito of uma caixa facing south;
Etapas para que se start sob o centro of o lado direito of uma caixa facing south;
Etapas para que se start no centro of o lado direito of uma caixa facing south:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste contexto.
  Atribua o y deste centro desta caixa à coordenada Y desta localização deste contexto.
  Face south.

Etapas para que se start sob o middle of o lado direito of uma caixa facing west;
Etapas para que se start no middle of o lado direito of uma caixa facing west;
Etapas para que se start sob o centro of o lado direito of uma caixa facing west;
Etapas para que se start no centro of o lado direito of uma caixa facing west:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste contexto.
  Atribua o y deste centro desta caixa à coordenada Y desta localização deste contexto.
  Face west.

Etapas para que se start sob o middle of o topo of uma caixa;
Etapas para que se start no middle of o topo of uma caixa;
Etapas para que se start sob o centro of o topo of uma caixa;
Etapas para que se start no centro of o topo of uma caixa:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste contexto.

Etapas para que se start sob o middle of o topo of uma caixa facing east;
Etapas para que se start no middle of o topo of uma caixa facing east;
Etapas para que se start sob o centro of o topo of uma caixa facing east;
Etapas para que se start no centro of o topo of uma caixa facing east:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste contexto.
  Face east.

Etapas para que se start sob o middle of o topo of uma caixa facing north;
Etapas para que se start no middle of o topo of uma caixa facing north;
Etapas para que se start sob o centro of o topo of uma caixa facing north;
Etapas para que se start no centro of o topo of uma caixa facing north:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste contexto.
  Vire para cima.

Etapas para que se start sob o middle of o topo of uma caixa facing south;
Etapas para que se start no middle of o topo of uma caixa facing south;
Etapas para que se start sob o centro of o topo of uma caixa facing south;
Etapas para que se start no centro of o topo of uma caixa facing south:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste contexto.
  Face south.

Etapas para que se start sob o middle of o topo of uma caixa facing west;
Etapas para que se start no middle of o topo of uma caixa facing west;
Etapas para que se start sob o centro of o topo of uma caixa facing west;
Etapas para que se start no centro of o topo of uma caixa facing west:
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste contexto.
  Face west.

Etapas para que se start sob a direita of um linha reta horizontal;
Etapas para que se start sob o lado direito of um linha reta horizontal:
  Atribua a localização final desta linha reta horizontal à localização deste contexto.

Etapas para que se start sob uma localização:
  Atribua a localização à localização deste contexto.

Etapas para que se start sob uma localização facing east:
  Atribua a localização à localização deste contexto.
  Face east.

Etapas para que se start sob uma localização facing north:
  Atribua a localização à localização deste contexto.
  Vire para cima.

Etapas para que se start sob uma localização facing south:
  Atribua a localização à localização deste contexto.
  Face south.

Etapas para que se start sob uma localização facing west:
  Atribua a localização à localização deste contexto.
  Face west.

Etapas para que se start sob o canto superior esquerdo of uma caixa facing east:
  Atribua o canto superior esquerdo desta caixa à localização deste contexto.
  Face east.

Etapas para que se start sob o canto superior esquerdo of uma caixa facing north:
  Atribua o canto superior esquerdo desta caixa à localização deste contexto.
  Vire para cima.

Etapas para que se start sob o canto superior esquerdo of uma caixa facing south:
  Atribua o canto superior esquerdo desta caixa à localização deste contexto.
  Face south.

Etapas para que se start sob o canto superior esquerdo of uma caixa facing west:
  Atribua o canto superior esquerdo desta caixa à localização deste contexto.
  Face west.

Etapas para que se start sob o topo of um linha reta vertical:
  Atribua à localização inicial desta linha reta vertical à localização deste contexto.

Etapas para que se start sob o canto superior direito of uma caixa facing east:
  Atribua o canto superior direito desta caixa à localização deste contexto.
  Face east.

Etapas para que se start sob o canto superior direito of uma caixa facing north:
  Atribua o canto superior direito desta caixa à localização deste contexto.
  Vire para cima.

Etapas para que se start sob o canto superior direito of uma caixa facing south:
  Atribua o canto superior direito desta caixa à localização deste contexto.
  Face south.

Etapas para que se start sob o canto superior direito of uma caixa facing west:
  Atribua o canto superior direito desta caixa à localização deste contexto.
  Face west.

Etapas para que se start no middle of uma caixa facing east;
Etapas para que se start sob o middle of uma caixa facing east;
Etapas para que se mova para o middle of uma caixa facing east;
Etapas para que se mova para o middle of uma caixa e face east;
Etapas para que se start no centro of uma caixa facing east;
Etapas para que se start sob o centro of uma caixa facing east;
Etapas para que se mova para o centro of uma caixa facing east;
Etapas para que se mova para o centro of uma caixa e face east:
  Atribua o centro desta caixa à localização deste contexto.
  Face east.

Etapas para que se start no middle of uma caixa facing north;
Etapas para que se start sob o middle of uma caixa facing north;
Etapas para que se mova para o middle of uma caixa facing north;
Etapas para que se mova para o middle of uma caixa e face north;
Etapas para que se start no centro of uma caixa facing north;
Etapas para que se start sob o centro of uma caixa facing north;
Etapas para que se mova para o centro of uma caixa facing north;
Etapas para que se mova para o centro of uma caixa e face north:
  Atribua o centro desta caixa à localização deste contexto.
  Vire para cima.

Etapas para que se start no middle of uma caixa facing north menos uns points;
Etapas para que se start no centro of uma caixa facing north menos uns points:
  Atribua o centro desta caixa à localização deste contexto.
  Vire para cima.
  Vire para a esquerda o points.

Etapas para que se start no middle of uma caixa facing south;
Etapas para que se start sob o middle of uma caixa facing south;
Etapas para que se mova para o middle of uma caixa facing south;
Etapas para que se mova para o middle of uma caixa e face south;
Etapas para que se start no centro of uma caixa facing south;
Etapas para que se start sob o centro of uma caixa facing south;
Etapas para que se mova para o centro of uma caixa facing south;
Etapas para que se mova para o centro of uma caixa e face south:
  Atribua o centro desta caixa à localização deste contexto.
  Face south.

Etapas para que se start no middle of uma caixa facing west;
Etapas para que se start sob o middle of uma caixa facing west;
Etapas para que se mova para o middle of uma caixa facing west;
Etapas para que se mova para o middle of uma caixa e face west;
Etapas para que se start no centro of uma caixa facing west;
Etapas para que se start sob o centro of uma caixa facing west;
Etapas para que se mova para o centro of uma caixa facing west;
Etapas para que se mova para o centro of uma caixa e face west:
  Atribua o centro desta caixa à localização deste contexto.
  Face west.

Etapas para que se start um process usando um endereço completo:
  \ must ser chamado com um global variável
  Limpe o erro do fluxo de entrada/saída.
  Se o process não for 0, atribua "Erro. Este processo já está sendo executado." ao erro do fluxo de entrada/saída; saia.
  Atribua a magnitude dessa startupinfo ao cb desta startupinfo.
  Extraia um endereço da pasta desde o endereço completo.
  Anexe o caractere NULL o endereço da pasta.
  Isole o endereço completo. Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateProcessA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
  \ Cria um novo processo e seu thread principal. O novo processo é executado no contexto de segurança do processo de chamada.
    O caractere inicial deste endereço completo [lpApplicationName] \ O nome do módulo a ser executado. 
    \Este módulo pode ser um aplicativo baseado no Windows. 
    \Pode ser algum outro tipo de módulo (por exemplo, MS-DOS ou OS / 2) se o subsistema apropriado estiver disponível no computador local.
    \A string pode especificar o caminho completo e o nome do arquivo do módulo a ser executado ou pode especificar um nome parcial. 
    \No caso de um nome parcial, a função usa a unidade e o diretório atuais para completar a especificação. 
    \A função não usará o caminho de pesquisa. 
    \Este parâmetro deve incluir a extensão do nome do arquivo; nenhuma extensão padrão é assumida.
    \O parâmetro lpApplicationName pode ser NULL. 
    \Nesse caso, o nome do módulo deve ser o primeiro token delimitado por espaço em branco na string lpCommandLine. 
    \Se você estiver usando um nome de arquivo longo que contém um espaço, use strings entre aspas para indicar onde o nome do arquivo termina e os argumentos começam; 
    \caso contrário, o nome do arquivo é ambíguo. 
    \Por exemplo, considere a string "c:\program files\sub dir\program name". 
    \Essa string pode ser interpretada de várias maneiras. 
    \O sistema tenta interpretar as possibilidades na seguinte ordem:
    \ c:\program.exe
    \ c:\program files\sub.exe
    \ c:\program files\sub dir\program.exe
     \c:\program files\sub dir\program name.exe
    e 0 [lpCommandLine] \ A linha de comando a ser executada. 
    \O parâmetro lpCommandLine pode ser NULL. 
    \Nesse caso, a função usa a string apontada por lpApplicationName como a linha de comando.
    \Se lpApplicationName e lpCommandLine não forem NULL, a string terminada em nulo apontada por lpApplicationName especifica o módulo a ser executado 
    \e a string terminada em nulo apontada por lpCommandLine especifica a linha de comando. 
    \O novo processo pode usar GetCommandLine para recuperar a linha de comando inteira. 
    \Os processos do console escritos em C podem usar os argumentos argc e argv para analisar a linha de comando. 
    \Como argv [0] é o nome do módulo, os programadores C geralmente repetem o nome do módulo como o primeiro token na linha de comando.
    \Se lpApplicationName for NULL, o primeiro token delimitado por espaço em branco da linha de comando especifica o nome do módulo. 
    \Se você estiver usando um nome de arquivo longo que contém um espaço, use strings entre aspas para indicar onde o nome do arquivo termina e os argumentos começam
    \ (consulte a explicação do parâmetro lpApplicationName). 
    \Se o nome do arquivo não contiver uma extensão, .exe será anexado. 
    \Portanto, se a extensão do nome do arquivo for .com, este parâmetro deve incluir a extensão .com. 
    \Se o nome do arquivo terminar em um ponto (.) Sem extensão ou se o nome do arquivo contiver um caminho, .exe não será anexado. 
    \Se o nome do arquivo não contém um caminho de diretório, o sistema procura o arquivo executável na seguinte sequência:
    \O diretório de onde o aplicativo foi carregado.
    \O diretório atual do processo pai.
    \O diretório do sistema Windows de 32 bits. Use a função GetSystemDirectory para obter o caminho desse diretório.
    \O diretório do sistema Windows de 16 bits. Não existe uma função que obtenha o caminho deste diretório, mas ele é pesquisado. O nome desse diretório é System.
    \O diretório do Windows. Use a função GetWindowsDirectory para obter o caminho desse diretório.
    \Os diretórios listados na variável de ambiente PATH. 
    \Observe que essa função não pesquisa o caminho por aplicativo especificado pela chave de registro App Paths. 
    \Para incluir esse caminho por aplicativo na sequência de pesquisa, use a função ShellExecute.
    \O sistema adiciona um caractere nulo de terminação à string da linha de comando para separar o nome do arquivo dos argumentos. 
    \Isso divide a string original em duas strings para processamento interno.
    e 0 [lpProcessAttributes] \ Um ponteiro para uma estrutura SECURITY_ATTRIBUTES. 
    \ https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
    \ A estrutura SECURITY_ATTRIBUTES contém o descritor de segurança para um objeto e especifica se o identificador recuperado especificando essa estrutura é herdável.
    \ Ou seja, esse valor  determina se o identificador retornado para o novo objeto de processo pode ser herdado por processos filho. 
    \Se lpProcessAttributes for NULL, o identificador não pode ser herdado
    \https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
    e 0 [lpThreadAttributes] \Idem. Se lpThreadAttributes for NULL, o identificador não pode ser herdado.
    e 0 [bInheritHandles] \ Se este parâmetro for TRUE, cada identificador herdável no processo de chamada é herdado pelo novo processo. 
    \Se o parâmetro for FALSE, os identificadores não são herdados. 
    \Observe que os identificadores herdados têm o mesmo valor e direitos de acesso que os identificador originais.
    e 67108904 [dwCreationFlags = CREATE_DEFAULT_ERROR_MODE + NORMAL_PRIORITY_CLASS + DETACHED_PROCESS] \Os sinalizadores que controlam a classe de prioridade e a criação do processo. 
    \Para obter uma lista de valores, consulte https://docs.microsoft.com/pt-br/windows/desktop/ProcThread/process-creation-flags
    \CREATE_DEFAULT_ERROR_MODE 0x04000000 = O novo processo não herda o modo de erro do processo de chamada. 
    \Em vez disso, o novo processo obtém o modo de erro padrão.
    \Esse recurso é particularmente útil para aplicativos de shell multithread que são executados com erros físicos desabilitados.
    \O comportamento padrão é que o novo processo herde o modo de erro do chamador. Definir este sinalizador altera o comportamento padrão.
    \NORMAL_PRIORITY_CLASS = Processo sem necessidade de agendamento especial.
    \DETACHED_PROCESS = Para processos de console, o novo processo não herda o console de seu pai (o padrão). 
    \O novo processo pode chamar a função AllocConsole posteriormente para criar um console. Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/console/creation-of-a-console
    \Este parâmetro também controla a nova classe de prioridade do processo, que é usada para determinar as prioridades de escalonamento das threads do processo. 
    \Para obter uma lista de valores, consulte https://docs.microsoft.com/pt-br/windows/desktop/api/processthreadsapi/nf-processthreadsapi-getpriorityclass
    e 0 [lpEnvironment] \ Um ponteiro para o bloco de ambiente do novo processo. 
    \Se este parâmetro for NULL, o novo processo usa o ambiente do processo de chamada.
    \Um bloco de ambiente consiste em um bloco com terminação nula de strings com terminação nula. 
    \Cada string tem o seguinte formato:
    \nome=valor\0
    \Como o sinal de igual é usado como separador, ele não deve ser usado no nome de uma variável de ambiente.
    e O caractere inicial deste endereço da pasta [lpCurrentDirectory] \ O caminho completo para o diretório atual do processo. 
    \A string também pode especificar um caminho UNC.
    \Se este parâmetro for NULL, o novo processo terá a mesma unidade e diretório atuais do processo de chamada. 
    \(Este recurso é fornecido principalmente para shells que precisam iniciar um aplicativo e especificar sua unidade inicial e diretório de trabalho.)
    e O endereçamento desta startupinfo [lpStartupInfo] \ Um ponteiro para uma estrutura STARTUPINFO.
    \ https://docs.microsoft.com/pt-br/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa
    e O endereçamento dessa PROCESS_INFORMATION [lpProcessInformation] \ Um ponteiro para uma estrutura PROCESS_INFORMATION que recebe informações de identificação sobre o novo processo.
    \ https://docs.microsoft.com/pt-br/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information
    devolvendo um número.\Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Se o número for 0, atribua "Erro. Não foi possível executar o programa." ao erro do fluxo de entrada/saída; saia.
  Atribua o hprocess deste PROCESS_INFORMATION ao process.
  Call "kernel32.dll" "CloseHandle" com \ https://docs.microsoft.com/pt-br/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
  \Em geral, CloseHandle invalida o identificador do objeto especificado, diminui a contagem do identificador do objeto e executa verificações de retenção do objeto. 
  \Depois que o último identificador para um objeto é fechado, o objeto é removido do sistema. .
    O hthread deste PROCESS_INFORMATION. [hObject] \Um identificador válido para um objeto aberto.
    \Se o aplicativo estiver sendo executado em um depurador, a função lançará uma exceção se receber um valor de identificador inválido ou um valor de pseudo-identificador. 
    \Isso pode acontecer se você fechar um identificador duas vezes ou se você chamar CloseHandle em um identificador retornado pela função FindFirstFile em vez de chamar a função FindClose.
  Point um ponteiro para rotina aguarde por um process ponteiro. \redirecione
  Call "kernel32.dll" "CreateThread" com \ https://docs.microsoft.com/pt-br/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread
  \ Cria um thread a ser executado no espaço de endereço virtual do processo de chamada.
    0 [lpThreadAttributes] \ Um ponteiro para uma estrutura SECURITY_ATTRIBUTES. 
    \ https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
    \ A estrutura SECURITY_ATTRIBUTES contém o descritor de segurança para um objeto e especifica se o identificador recuperado especificando essa estrutura é herdável.
    \ Ou seja, esse valor  determina se o identificador retornado para o novo objeto de processo pode ser herdado por processos filho. 
    \Se lpThreadAttributes for NULL, o identificador não pode ser herdado
    e 0 [dwStackSize] \ O tamanho inicial da pilha, em bytes. 
    \O sistema arredonda esse valor para a página mais próxima. 
    \Se este parâmetro for zero, o novo thread usa o tamanho padrão para o executável. 
    \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/ProcThread/thread-stack-size.
    e O ponteiro [lpStartAddress] \ Um ponteiro para a função definida pelo aplicativo a ser executada pelo thread. 
    \Este ponteiro representa o endereço inicial do thread. 
    \Para obter mais informações sobre a função de thread, consulte https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/legacy/ms686736(v=vs.85)
    e O endereçamento deste process [lpParameter] \ Um ponteiro para uma variável a ser passada para o encadeamento.
    e 0 [dwCreationFlags] \ Os sinalizadores que controlam a criação do segmento.
    \Quando o valor é igual a 0, o thread é executado imediatamente após a criação.
    e O endereçamento desse segundo número [lpThreadId] \ Um ponteiro para uma variável que recebe o identificador de thread.
    devolvendo um número identificador. \ Se a função for bem-sucedida, o valor de retorno é um identificador para o novo thread.
  Call "kernel32.dll" "CloseHandle" com \ https://docs.microsoft.com/pt-br/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
  \Em geral, CloseHandle invalida o identificador do objeto especificado, diminui a contagem do identificador do objeto e executa verificações de retenção do objeto. 
  \Depois que o último identificador para um objeto é fechado, o objeto é removido do sistema. .
    O número identificador. \ does not end o thread, just dumps o handle
    [hObject] \Um identificador válido para um objeto aberto.
    \Se o aplicativo estiver sendo executado em um depurador, a função lançará uma exceção se receber um valor de identificador inválido ou um valor de pseudo-identificador. 
    \Isso pode acontecer se você fechar um identificador duas vezes ou se você chamar CloseHandle em um identificador retornado pela função FindFirstFile em vez de chamar a função FindClose.

Etapas para que se start um temporizador:
  Zere o temporizador.
  Reinicie o temporizador.

Etapas para que se start uns twips acima of o middle of o base of uma caixa:
  \ incomplete abra of these
  Atribua a coordenada X deste centro desta caixa à coordenada X desta localização deste contexto.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips à coordenada Y desta localização deste contexto.

Etapas para que se start uns twips para baixo desde uma localização;
Etapas para que se start uns twips debaixo of uma localização:
  Atribua a coordenada X desta localização ao x deste contexto.
  Atribua a coordenada Y desta localização mais os twips ao y deste contexto.

Etapas para que se start uns twips desde o centro of uma caixa:
  Atribua o centro desta caixa à localização deste contexto.
  Mova os twips.

Etapas para que se start uns twips para o lado esquerdo e uns outros twips para baixo desde uma localização;
Etapas para que se start uns twips para a esquerda e uns outros twips para baixo desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste contexto.
  Atribua a coordenada Y desta localização mais os outros twips ao y deste contexto.

Etapas para que se start uns twips para o lado esquerdo e uns outros twips para cima desde uma localização;
Etapas para que se start uns twips para a esquerda e uns outros twips para cima desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste contexto.
  Atribua a coordenada Y desta localização menos os outros twips ao y deste contexto.

Etapas para que se start uns twips para o lado esquerdo of uma localização;
Etapas para que se start uns twips para a esquerda of uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste contexto.

Etapas para que se start uns twips para o lado direito e uns outros twips para baixo desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste contexto.
  Atribua a coordenada Y desta localização mais os outros twips ao y deste contexto.

Etapas para que se start uns twips para o lado direito  e uns outros twips para cima desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste contexto.
  Atribua a coordenada Y desta localização menos os outros twips ao y deste contexto.

Etapas para que se start uns twips para cima desde uma coordenada:
  Atribua a coordenada menos os twips ao y deste contexto.

Etapas para que se start uns twips para cima desde uma localização;
Etapas para que se start uns twips acima of uma localização:
  Atribua a coordenada Y desta localização ao y deste contexto.
  Subtraia os twips desde a coordenada Y deste contexto.

Etapas para que se carregue as bibliotecas padrão do sistema;
Etapas para que se start para cima:
  inicialize o Component Object Model.
  Inicialize winsock.
  Inicialize gdi+.
  Inicialize o talker.
  Inicialize o module.
  Inicialize as cores.
  Inicialize o tela.
  Inicialize a janela do programa.
  Inicialize as fontes.
  Inicialize os cursors.
  Inicialize o mouse.
  Inicialize os canvases.
  Inicialize o contexto.
  Initalize o terminal.
  Crie o console.

Etapas para que se start para cima o cgi:
  Inicialize winsock.
  Inicialize o module.
  Inicialize o cgi.

Etapas para que se start com uma cor:
  Atribua a cor à cor deste contexto.

Etapas para que se start com nada em um ponteiro:
  Esvazie o ponteiro.

O número identificador do fluxo de entrada padrão é um número identificador.

O número identificador do fluxo de saída padrão é um número identificador.

Etapas para que se suspenda um process:
  Se o process for 0, cancele.
  Call "kernel32.dll" "TerminateProcess" com \ https://docs.microsoft.com/pt-br/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess
  \ Encerra o processo especificado e todos os seus threads.
    O process [hProcess] \ Um identificador para o processo a ser encerrado.
    \O identificador deve ter o direito de acesso PROCESS_TERMINATE. 
    \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/desktop/ProcThread/process-security-and-access-rights
    e 0. [uExitCode] \ O código de saída a ser usado pelo processo e threads encerrados como resultado desta chamada. 
    \Use a função GetExitCodeProcess para recuperar o valor de saída de um processo. 
    \Use a função GetExitCodeThread para recuperar o valor de saída de um encadeamento.
  Atribua 0 ao process.

Etapas para que se suspenda um temporizador:
  Se a contagem deste temporizador for 0, cancele.
  Subtraia 1 desde a contagem deste temporizador.
  Se a contagem deste temporizador não for 0, cancele.
  Atribua a contagem de intervalos do sistema a uns intervalos.
  Subtraia os intervalos iniciais deste temporizador desde o intervalos.
  Adicione o intervalos para os intervalos totais deste temporizador.

Etapas para que se pinte uma caixa com uma cor:
  Atribua a cor à cor deste contexto.
  Atribua o canto inferior esquerdo desta caixa à localização deste contexto.
  Vire para cima.
  Pinte a altura desta caixa.
  Vire para a direita.
  Pinte a largura desta caixa.
  Vire para a direita.
  Pinte a altura desta caixa.
  Vire para a direita.
  Pinte a largura desta caixa.

Um subject é uma string.

Etapas para que se take off all o masking tape:
  Exponha tudo.

Etapas para que se take off algum tipo de masking tape:
  Exponha tudo.

Um talker é um ponteiro para um talker object.

O talker é um talker.

Um talker object é um conjunto com um talker vtable denominado vtable.

Um talker vtable é um ponteiro para um talker vtable conjunto.

O temp endereço completo é um endereço completo.

O terminal é um terminal.

Um terminal é uma coisa com 
  Uma caixa, 
  Uns quoras, 
  Uma output cor, 
  Uma input cor, e 
  Uma texto retornado string.

O caixa de texto cutoff é um número igual a 500.

Um temporizador é um conjunto com 
  Uma contagem, 
  Uns intervalos iniciais e 
  Uns intervalos totais.

Some times é um número. \ this é um fluke, I think -- see "suavize um polígono uns times"



Etapas para que se trim uma string:
  Remove algum tipo de leading noise desde a string.
  Remove algum tipo de trailing noise desde a string.

Etapas para que se dê meia volta:
  Vire para 1/2.

Etapas para que se vire uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire a fração.

Etapas para que se vire uma fração;
Etapas para que se vire para uma fração:
  Se a fração for 1/1, cancele.
  Atribua 3840 times a fração mais a orientação deste contexto à orientação deste contexto.
  Normalize a orientação deste contexto.

Etapas para que se vire pra esquerda uma fração igual para um número over um segundo número;
Etapas para que se vire para a esquerda uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire para a esquerda a fração.

Etapas para que se vire uma fração para a esquerda;
Etapas para que se vire para a esquerda uma fração:
  Isole a fração.
  Negate a fração.
  Vire a fração.

Etapas para que se vire pra esquerda uns points;
Etapas para que se vire para a esquerda uns points;
Etapas para que se vire uns points para a esquerda:
  Atribua o points e 3840 a uma fração.
  Vire para a esquerda a fração.

Etapas para que se vire uns degrees para a direita;
Etapas para que se vire para a direita uns degrees;
Etapas para que se vire para o lado direito uns degrees;
Etapas para que se vire uns degrees para o lado direito:
  Atribua os degrees times 10 e 3600 para uma fração.
  Vire para a fração.

Etapas para que se vire uns degrees:
  Atribua o degrees times 10 e 3600 para uma fração.
  \Se o degrees forem negativo, vire para a esquerda a fração; saia.
  Vire para a fração.

Etapas para que se vire pra direita uma fração igual para um número over um segundo número;
Etapas para que se vire para a direita uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire para a fração.

Etapas para que se vire para a direita uma fração:
  Vire a fração.

Etapas para que se vire para a direita uma fração uns percentual of o time:
  Escolha aleatoriamente um número entre 1 e 100.
  Se o número for maior do que o percentual, cancele.
  Vire para a fração.

Etapas para que se vire uns points para a direita;
Etapas para que se vire para a direita uns points:
  Atribua o points e 3840 a uma fração.
  Vire para a fração.

Etapas para que se exponha tudo:
  Call "gdi32.dll" "SelectClipRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectcliprgn
  \ A função SelectClipRgn seleciona uma região como a região de recorte atual para o contexto de dispositivo especificado.
    O quadro atual [hdc] \ Um identificador para o contexto do dispositivo.
    e 0. [hrgn] \ Um identificador para a região a ser selecionada.

Etapas para que se exponha conteúdo de uma caixa:
  Crie um hRgn usando a caixa.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de uma elipse:
  Crie um hRgn usando a elipse.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-extselectcliprgn
  \ A função ExtSelectClipRgn combina a região especificada com a região de recorte atual usando o modo especificado.
    O quadro atual e [hdc] \ Um identificador para o contexto do dispositivo.
    o hRgn [hrgn] \ Um identificador para a região a ser selecionada.
    e 2 [mode = RGN_OR]. \ A operação a ser executada. 
    \ Nesse caso a nova região de recorte combina a região de recorte atual [hdc] e a região selecionada [hrgn].

Etapas para que se exponha conteúdo de um polígono:
  Crie um hRgn usando o polígono.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma caixa:
  Crie um hRgn usando a caixa.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma elipse:
  Crie um hRgn usando a elipse.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de um hRgn:
  Crie um old hRgn usando a caixa zero.
  Call "gdi32.dll" "GetClipRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-getcliprgn
  \ A função GetClipRgn recupera um identificador que identifica a região de recorte definida pelo aplicativo atual para o contexto de dispositivo especificado.
    O quadro atual e [hdc] \ O identificador do contexto do dispositivo.
    o old hRgn [hrgn] \ Um identificador para uma região existente antes que a função seja chamada. 
    \Depois que a função retorna, este parâmetro é um identificador para uma cópia da região de recorte atual.
    devolvendo um número. \Se a função for bem-sucedida e houver uma região de recorte para o contexto de dispositivo fornecido, o valor de retorno será 1.
  Se o número não for 1, limpe o old hRgn.
  Call "gdi32.dll" "SelectClipRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-selectcliprgn
  \ A função SelectClipRgn seleciona uma região como a região de recorte atual para o contexto de dispositivo especificado.
    O quadro atual [hdc] \ Um identificador para o contexto do dispositivo.
    e 0. [hrgn] \ Um identificador para a região a ser selecionada.
  Call "gdi32.dll" "ExtSelectClipRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-extselectcliprgn
  \ A função ExtSelectClipRgn combina a região especificada com a região de recorte atual usando o modo especificado.
    O quadro atual e [hdc] \ Um identificador para o contexto do dispositivo.
    e O hRgn [hrgn] \ Um identificador para a região a ser selecionada.
    e 4 [RGN_DIFF]. \ A operação a ser executada. 
    \ Nesse caso a nova região de recorte combina as áreas da região de recorte atual [hdc] com as áreas excluídas da região identificada por hrgn.
  Call "gdi32.dll" "ExtSelectClipRgn" com \ https://docs.microsoft.com/pt-br/windows/win32/api/wingdi/nf-wingdi-extselectcliprgn
  \ A função ExtSelectClipRgn combina a região especificada com a região de recorte atual usando o modo especificado.
    O quadro atual e [hdc] \ Um identificador para o contexto do dispositivo.
    e O old hRgn [hrgn] \ Um identificador para a região a ser selecionada.
    e 2 [mode = RGN_OR]. \ A operação a ser executada. 
    \ Nesse caso a nova região de recorte combina a região de recorte atual [hdc] e a região selecionada [hrgn].
  Destrua o old hRgn.

Etapas para que se exponha exterior de um polígono:
  Crie um hRgn usando o polígono.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se renove a tela;
Etapas para que se mostre;
Etapas para que se mostre tudo;
Etapas para que se mostre exponha o canvas;
Etapas para que se atualize a tela:
  Atualize a tela usando a caixa desta tela.

Um número de porta é um número.
Um nome de protocolo é uma string.
Um nome de host é uma string.
Um parâmetro de consulta é uma string.
Um endereço de recurso é uma string.

Uma URL simplificada é um conjunto com
  Um nome do protocolo,\lpszScheme? dwFlags? -> exemplo: http / ftp / https / etc
  Um nome de host, \lpszHostName ?  -> exemplo: www.google.com ou mail.stackoverflow.com
  Um endereço de recurso, \lpszUrlPath? -> exemplo: index.html ou /css/style.css ou questions/SubmitQuestion.aspx
  Um parâmetro de consulta, \lpszExtraInfo? -> exemplo: ?useLiveData=1&internal=0
  Um número de porta. \ nPort? -. números de porta ocupam (geralmente) 16 bits

Um série de vértices é um ponteiro para uma série de vértices conjunto.

Uma quantidade de vértices é um número.

Um série de vértices conjunto é um conjunto com 
  Uma quantidade de vértices e 
  Uma ponteiro da localização.

Um vértice é uma coisa com 
  Uma coordenada X, 
  Uma coordenada Y, 
  Uma localização sob a coordenada X.

Etapas para que se aguarde por um evento;
Etapas para que se desenfileire um evento:
  Yield para windows.
  Atribua o first desta fila de eventos ao evento.
  Se o evento for inexistente, recomece.
  Remove o evento desde a fila de eventos.
  Se a categoria deste evento for "fechamento do programa", destrua o evento; saia.
  Destrua o evento atual.
  Atribua o evento ao evento atual.

Etapas para que se aguarde uns milliseconds;
Etapas para que se espere uns milliseconds;
Etapas para que se aguarde por uns milliseconds:
  Se o milliseconds forem menor do que ou igual para 0, cancele.
  Call "kernel32.dll" "Sleep" com \ https://docs.microsoft.com/pt-br/windows/win32/api/synchapi/nf-synchapi-sleep
  \ Suspende a execução do thread atual até que o intervalo de tempo limite expire.
    os milliseconds. [dwMilliseconds] \ O intervalo de tempo durante o qual a execução deve ser suspensa, em milissegundos.

Etapas para que se aguarde até finalizar a narração;
Etapas para que se aguarde até que a narração esteja finalizada;
Etapas para que se aguarde até finalizarmos narração;
Etapas para que se aguarde até que narração esteja concluída:
  Se o talker for inexistente, cancele.
  Call o [método] WaitUntilDone desta vtable [SpVoice] deste talker com o talker e -1.

Etapas para que se aguarde até que pressionemos uma tecla;
Etapas para que se aguarde até pressionarmos uma tecla;
Etapas para que se aguarde por uma tecla;
Etapas para que se aguarde o pressionamento de uma tecla;
Etapas para que se aguarde pelo pressionamento de uma tecla;
Etapas para que se aguarde uma tecla ser pressionada;
Etapas para que se aguarde uma tecla:
  Aguarde pela tecla para go para baixo.
  Aguarde pela tecla para come para cima.
  Desmanche all eventos.

Um wave file é um endereço completo.

Um wave é um texto hexadecimal.

Uma largura é uns twips.

Etapas para que se wrap uma caixa de texto:
  Se a caixa de texto for inexistente, cancele.
  Se o detector de quebra de texto desta caixa de texto não estiver ativo, cancele.
  Converta o anchor desta caixa de texto para um posicionamento absoluto usando a caixa de texto.
  Converta o cursor de texto desta caixa de texto para uma segunda posicionamento absoluto usando a caixa de texto.
  Atribua a scale desta caixa de texto a uma fração.
  Redimensione proporcionalmente a caixa de texto para 1/1.
  Extraia uma string desde a caixa de texto.
  Posponha o retorno de carro para a string.
  Destrua as linhas des textos desta caixa de texto.
  Lance um percorredor sobre a string.
  Crie o número da fonte of o memory canvas usando a fonte desta caixa de texto.
  Comece. [a executar o código abaixo]
    Mova o percorredor usando a caixa desta caixa de texto (word wrapping rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma linha de texto usando o segmento inicial deste percorredor.
    Posponha a linha de texto para as linhas des textos desta caixa de texto.
  Recomece. [percorra novamente o código acima]
  Destrua o número da fonte of o memory canvas.
  Renumere as linhas des textos desta caixa de texto.
  Redimensione proporcionalmente a caixa de texto para a fração.
  Converta o posicionamento absoluto para o anchor desta caixa de texto usando a caixa de texto.
  Converta a segunda posicionamento absoluto para o cursor de texto desta caixa de texto usando a caixa de texto.
  Limite a origem of a caixa de texto.

Etapas para que se salve um trecho em um file;
Etapas para que se armazene um trecho em um file;
Etapas para que se grave um trecho em um file;
Etapas para que se escreva um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-setfilepointer
  \Move o ponteiro de arquivo do arquivo especificado.
  \Esta função armazena o ponteiro do arquivo em dois valores LONG.
  \Quando um arquivo é aberto, o Windows associa um ponteiro de arquivo com o fluxo padrão. 
  \Esse ponteiro de arquivo é um valor de deslocamento que especifica o próximo byte a ser lido ou o local para receber o próximo byte escrito.
    O file [hFile]\ O número identificador do arquivo.
    e 0 [lDistanceToMove] \ Um valor positivo para lDistanceToMove move o ponteiro do arquivo para frente no arquivo 
    \e um valor negativo move o ponteiro para trás no arquivo .
    e 0 [lpDistanceToMoveHigh] \Serve apenas para operações com 64 bits. Quando não é utilizado, esse valor deve ser 0 (NULL). 
    e 0 [dwMoveMethod = FILE_BEGIN] \ O ponto de partida para o movimento do ponteiro do arquivo. Nesse caso o ponto de partida é zero ou o início do arquivo.
    devolvendo um número resultante. \Se a função for bem-sucedida e lpDistanceToMoveHigh for NULL, o valor de retorno será o DWORD de ordem inferior do novo ponteiro de arquivo.
    \Se a função falhar, o valor de retorno é INVALID_SET_FILE_POINTER.
  Se o número resultante for -1, atribua "Ocorreu um erro ao tentar posicionar o ponteiro no início do arquivo." ao erro do fluxo de entrada/saída; saia.
  Call "kernel32.dll" "WriteFile" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-writefile
  \ Essa função serve pra gravar dados no arquivo ou dispositivo de entrada / saída (E/S) especificado.
    \ Um identificador para o arquivo ou dispositivo de E/S 
    \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    O file [hFile]\ O número identificador do arquivo.
    e O caractere inicial deste trecho [lpBuffer]  \ Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    e A quantidade de caracteres deste trecho [nNumberOfBytesToWrite] \ O número de bytes a serem gravados no arquivo ou dispositivo.
    \ Um valor zero especifica uma operação de gravação nula. 
    \O comportamento de uma operação de gravação nula depende do sistema de arquivos subjacente ou da tecnologia de comunicação.
    [Creio que seja preciso corrigir o texto abaixo]
    e O endereçamento desse número [lpNumberOfBytesWritten]  \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono. 
    \ WriteFile define esse valor como zero antes de fazer qualquer trabalho ou verificação de erro.
    \ Use NULL para este parâmetro se esta for uma operação assíncrona para evitar resultados potencialmente errôneos.
    \Este parâmetro pode ser NULL somente quando o próximo parâmetro [lpOverlapped] não for 0 (NULL).
    e 0 [lpOverlapped]  \ utilizado somente quando se deseja gravar em outro lugar do arquivo, como por exemplo, no final. 
    \ Se não for o caso, esse parâmetro pode ser 0 (NULL)
    devolvendo o número resultante. \ Se a função for bem-sucedida, o valor de retorno será diferente de 0 (VERDADEIRO).
    \ Se a função falhar ou estiver sendo concluída de forma assíncrona, o valor de retorno será 0 (FALSO). 
  Se o número resultante for 0, atribua "Ocorreu um erro ao tentar gravar o arquivo." ao erro do fluxo de entrada/saída; saia.

Etapas para que se salve um trecho em um endereço completo;
Etapas para que se armazene um trecho em um endereço completo;
Etapas para que se grave um trecho em um endereço completo;
Etapas para que se escreva um trecho para um endereço completo:
  Limpe o erro do fluxo de entrada/saída.
  Extraia um endereço da pasta desde o endereço completo.
  Se o endereço da pasta não estiver no sistema de arquivos, atribua "A pasta: " junto com o endereço da pasta seguido de " não existe." ao erro do fluxo de entrada/saída; saia.
  Defina o endereço completo para read-write mode.
  Isole o endereço completo.
  Anexe o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-createfilea
  \Cria ou abre um arquivo ou dispositivo de E/S. 
  \Os dispositivos de E / S mais comumente usados são os seguintes: 
  \arquivo, fluxo de arquivo, diretório, disco físico, volume, buffer de console, unidade de fita, recurso de comunicação, slot de correio e canal. 
  \A função retorna um identificador que pode ser usado para acessar o arquivo ou dispositivo para vários tipos de E / S, 
  \dependendo do arquivo ou dispositivo e dos sinalizadores e atributos especificados.
    O caractere inicial deste endereço completo [lpFileName] \ O nome do arquivo ou dispositivo a ser criado ou aberto. 
    \Você pode usar barras (/) ou barras invertidas (\) neste nome.
    e 1073741824 [dwDesiredAccess = GENERIC_WRITE] \O acesso solicitado ao arquivo ou dispositivo, que pode ser resumido como leitura, gravação, ambos ou nenhum zero).
    \Os valores mais comumente usados são -2147483648 (GENERIC_READ), 1073741824 (GENERIC_WRITE) ou ambos -1073741824 (GENERIC_READ | GENERIC_WRITE). 
    \Para obter mais informações, consulte os sites:
    \ https://docs.microsoft.com/pt-br/windows/desktop/SecAuthZ/generic-access-rights
    \ https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-security-and-access-rights
    \ https://docs.microsoft.com/pt-br/windows/desktop/FileIO/file-access-rights-constants
    \ https://docs.microsoft.com/pt-br/windows/desktop/SecAuthZ/access-mask
    \Se este parâmetro for zero, o aplicativo pode consultar certos metadados, como arquivo, diretório ou atributos de dispositivo sem acessar esse arquivo ou dispositivo, 
    \mesmo se o acesso GENERIC_READ tivesse sido negado.
    e 0 [dwShareMode] \O modo de compartilhamento solicitado do arquivo ou dispositivo, que pode ser lido, escrito, ambos, excluir, todos ou nenhum. 
    \Os pedidos de acesso a atributos ou atributos estendidos não são afetados por este sinalizador.
    \O valor 0 impede que outros processos abram esse arquivo ou dispositivo se solicitarem acesso de exclusão, leitura ou gravação.
  \Se este parâmetro for 0 e CreateFile for bem-sucedido, o arquivo ou dispositivo não pode ser compartilhado e não pode ser aberto novamente até que o identificador para o arquivo ou dispositivo seja fechado.   
    e 0 [lpSecurityAttributes] \Um ponteiro para uma estrutura SECURITY_ATTRIBUTES que contém dois membros de dados separados, mas relacionados: 
    \ https://docs.microsoft.com/pt-br/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
    \um descritor de segurança opcional e um valor booleano que determina se o identificador retornado pode ser herdado por processos filho.
    \Este parâmetro pode ser NULL.
    \Se este parâmetro for NULL, o identificador retornado por CreateFile não pode ser herdado por nenhum processo filho que o aplicativo possa criar 
    \e o arquivo ou dispositivo associado ao identificador retornado obtém um descritor de segurança padrão.
    e 2 [dwCreationDisposition = CREATE_ALWAYS] \ Uma ação a ser executada em um arquivo ou dispositivo existente ou não.
    \CREATE_ALWAYS 2 Cria um novo arquivo, sempre. 
    \Se o arquivo especificado existe e é gravável, a função sobrescreve o arquivo, a função é bem-sucedida e o código do último erro é definido como ERROR_ALREADY_EXISTS (183).
    \Se o arquivo especificado não existir e for um caminho válido, um novo arquivo será criado, a função será bem-sucedida e o código do último erro será definido como zero.
    e -2147483520 [dwFlagsAndAttributes = FILE_FLAG_WRITE_THROUGH +FILE_ATTRIBUTE_NORMAL] \ O arquivo ou atributos de dispositivo e sinalizadores,
    \Este parâmetro também pode conter combinações de sinalizadores para controle de arquivo ou comportamento de armazenamento em cache de dispositivo, 
    \modos de acesso e outros sinalizadores de propósito especial. 
    \FILE_FLAG_WRITE_THROUGH 0x80000000 As operações de gravação não passarão por nenhum cache intermediário, elas irão diretamente para o disco.
    \FILE_ATTRIBUTE_NORMAL 128 (0x80)  O arquivo não possui outros atributos definidos.
    e 0 [hTemplateFile] \Um identificador válido para um arquivo de modelo com o direito de acesso GENERIC_READ. 
    \O arquivo de modelo fornece atributos de arquivo e atributos estendidos para o arquivo que está sendo criado.
    \Este parâmetro pode ser NULL.
    \Ao abrir um arquivo existente, CreateFile ignora este parâmetro
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno será um identificador aberto para o arquivo, dispositivo, canal nomeado ou slot de correio especificado.
    \Se a função falhar, o valor de retorno é -1 (INVALID_HANDLE_VALUE).
  Se o número identificador for -1 [INVALID_HANDLE_VALUE], atribua "Ocorreu um erro ao tentar abrir o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; saia.
  Call "kernel32.dll" "WriteFile" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-writefile
  \ Essa função serve pra gravar dados no arquivo ou dispositivo de entrada / saída (E/S) especificado.
    \ Um identificador para o arquivo ou dispositivo de E/S 
    \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    O número identificador [hFile]  \Um identificador para o arquivo ou dispositivo de E/S
    e O caractere inicial deste trecho [lpBuffer] \Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    e A quantidade de caracteres deste trecho [nNumberOfBytesToWrite] \ representa o nº de bytes a serem gravados no arquivo ou dispositivo.
    e O endereçamento desse número [lpNumberOfBytesWritten]  \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono . 
    e 0 [lpOverlapped] \ serve pra especificar se deseja gravar em outra região, por exemplo o final do arquivo. 
    devolvendo o número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero (VERDADEIRO).
    \ verificar o nome da variável acima
  Call "kernel32.dll" "CloseHandle" com  \ https://docs.microsoft.com/pt-br/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
  \Em geral, CloseHandle invalida o identificador do objeto especificado, diminui a contagem do identificador do objeto e executa verificações de retenção do objeto. 
  \Depois que o último identificador para um objeto é fechado, o objeto é removido do sistema. .
    O número identificador. [hObject] \Um identificador válido para um objeto aberto.
    \Se o aplicativo estiver sendo executado em um depurador, a função lançará uma exceção se receber um valor de identificador inválido ou um valor de pseudo-identificador. 
    \Isso pode acontecer se você fechar um identificador duas vezes ou se você chamar CloseHandle em um identificador retornado pela função FindFirstFile em vez de chamar a função FindClose.
  Se o número não for 0, cancele.
  \ verificar o nome da variável acima
  Atribua "Ocorreu um erro ao tentar salvar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se escreva um byte:
  Atribua o byte a uma string.
  Escreva a string.

Etapas para que se escreva um byte para StdOut:
  Call "kernel32.dll" "WriteFile" com \ https://docs.microsoft.com/pt-br/windows/win32/api/fileapi/nf-fileapi-writefile
    O stdout handle [hFile] \Um identificador para o arquivo ou dispositivo de E/S
  \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    e O endereçamento deste byte [lpBuffer] \Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    e 1 [nNumberOfBytesToWrite] \ representa o nº de bytes a serem gravados no arquivo ou dispositivo.
    e O endereçamento desse número [lpNumberOfBytesWritten]  \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono. 
    e nil. [lpOverlapped] \ serve pra especificar se deseja gravar em outra região, por exemplo o final do arquivo. 

Etapas para que se escreva um byte sem passar pra próxima linha:
  Atribua o byte a uma string.
  Escreva a string sem passar pra próxima linha.

\ will translate to English because "Converta um detector" é used para externalize reams pelo caderno
Etapas para que se escreva um detector:
  Converta o detector para uma string.
  Escreva a string.

Etapas para que se escreva um detector sem passar pra próxima linha:
  Converta o detector para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva uma fração:
  Converta a fração para uma string.
  Escreva a string.

Etapas para que se escreva uma fração sem passar pra próxima linha:
  Converta a fração para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um número:
  Converta o número para uma string.
  Escreva a string.

Etapas para que se escreva um número sem passar pra próxima linha:
  Converta o número para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um número sobre um console:
  Converta o número para uma string.
  Escreva a string sobre o console.

Etapas para que se escreva uns quoras em uma caixa: \descomentar pra ver o que acontece
  \Pinte a caixa com a cor vermelha e a cor vermelha. \ temp ***
  Atribua a caixa a uma quora caixa.
  Atribua a coordenada Y do canto superior esquerdo desta quora caixa mais 24 pixels à coordenada Y do canto inferior direito desta quora caixa.
  Comece. [a executar o código abaixo]
    Obtenha um quora desde o quoras.
    Se o quora for inexistente, pare.
    \pinte really fast. ***
    \Pinte o quora caixa com a cor amarela. \ temp ***
    Escreva a string deste quora no quora caixa com a cor deste quora.
    Mova o quora caixa para baixo 24 px.
  Recomece. [percorra novamente o código acima]

Etapas para que se yield para windows:
  Se a fila de eventos não estiver vazia, cancele.
  Call "user32.dll" "GetMessageA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-getmessagea
  \A função GetMessageA obtém uma mensagem da fila de mensagens do thread de chamada. 
  \A função despacha mensagens enviadas de entrada até que uma mensagem postada esteja disponível para obtenção.
    O endereçamento dessa MSG  [lpMsg] \Um ponteiro para uma estrutura MSG que recebe informações da mensagem da fila de mensagens do segmento.
      \https://docs.microsoft.com/pt-br/windows/desktop/api/winuser/ns-winuser-MSG
      e 0 [hWnd]  \Um identificador para a janela cujas mensagens devem ser recuperadas. A janela deve pertencer ao segmento atual.
    \Se hWnd for NULL, GetMessage recuperará mensagens para qualquer janela que pertença ao segmento atual 
    \e quaisquer mensagens na fila de mensagens do segmento atual cujo valor hwnd seja NULL.
    \Portanto, se hWnd for NULL, tanto as mensagens da janela quanto as mensagens do thread serão processadas.
      e 0 [wMsgFilterMin] \O valor inteiro do menor valor da mensagem a ser recuperado. 
      e 0 [wMsgFilterMax] \O valor inteiro do maior valor da mensagem a ser recuperado. 
    \Se wMsgFilterMin e wMsgFilterMax forem 0, GetMessage retorna todas as mensagens disponíveis (ou seja, nenhuma filtragem de intervalo é executada).
    devolvendo um número. \Se a função recuperar uma mensagem diferente de WM_QUIT, o valor de retorno será diferente de zero.    
    \Se houver um erro, o valor de retorno é -1. 
    \Por exemplo, a função falhará se hWnd for um identificador de janela inválido ou lpMsg for um ponteiro inválido. 
  Se o número for 0, cancele.
  Call "user32.dll" "TranslateMessage" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-translatemessage
    \Traduz mensagens de teclas virtuais em mensagens de caracteres. 
    \As mensagens de caracteres são postadas na fila de mensagens do thread de chamada, 
    \para serem lidas na próxima vez que o thread chamar a função GetMessage ou PeekMessage.
      o endereçamento desta MSG. [*lpMsg] \Um ponteiro para uma estrutura MSG 
      \ https://docs.microsoft.com/pt-br/windows/desktop/api/winuser/ns-winuser-msg
      \que contém informações de mensagem recuperadas da fila de mensagens do thread de chamada usando a função GetMessage ou PeekMessage.
      \Se a mensagem for traduzida (ou seja, uma mensagem de caractere é postada na fila de mensagens do encadeamento), o valor de retorno é diferente de zero.
      \Se a mensagem for WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN ou WM_SYSKEYUP, o valor de retorno será diferente de zero, independentemente da tradução.
    \Se a mensagem não for traduzida (ou seja, uma mensagem de caractere não é postada na fila de mensagens do encadeamento), o valor de retorno é zero.
  Call "user32.dll" "DispatchMessageA" com \ https://docs.microsoft.com/pt-br/windows/win32/api/winuser/nf-winuser-dispatchmessagea
    \Envia uma mensagem para um procedimento de janela. Normalmente é usado para despachar uma mensagem recuperada pela função GetMessage.
      o endereçamento desta MSG.[*lpMsg]  \Um ponteiro para uma estrutura que contém a mensagem.
      \O valor de retorno especifica o valor retornado pelo procedimento de janela. E
      \mbora seu significado dependa da mensagem que está sendo despachada, o valor de retorno geralmente é ignorado.

Etapas para que se zero uma caixa:
    \ was clear uma caixa, got confounded com "clear uma caixa " (which deveria pinte a caixa all black como does "clear o tela")
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada X do canto inferior direito desta caixa.
  Atribua 0 à coordenada Y do canto inferior direito desta caixa.

A caixa zero é uma caixa.

Etapas para que se zero preencha um número usando uma contagem e posponha it para uma string:
  Converta o número para uma segunda string.
  Zero preencha a segunda string usando a contagem.
  Posponha a segunda string para a string.

O zero linha reta é uma linha reta. \ tracer

O zero localização é uma localização.

O erro do fluxo de entrada/saída é uma string.
