\ O Cérebro - A Sociedade Osmosiana de Programadores de Linguagens Naturais - desde 2006.

\ Regras:
\ No geral, cada linha deve terminar com um ponto final.
\ As exceções são quando você está declarando uma variável do tipo conjunto, 
\ (cujas linhas podem terminar com uma vírgula, exceto no último item do conjunto)
\ Ou quando você estiver declarando um cabeçalho de rotina (que termina com sinal de dois pontos)
\ Quando um campo de texto é convertido para texto puro, 
\ o caractere especial LF é adicionado depois do caractere especial CR
\ Já quando um texto é transformado em um campo de texto, o caractere LF é removido.
\ Existe sempre uma linha, no mínimo.
\ Existe sempre um caractere CR no fim da ultima linha.

Um percorredor é um conjunto com \ conserte "avance um percorredor" e "recue um percorredor" se você alterar isso aqui
  Um subtexto original,
  Um segmento final, 
  Um segmento inicial.

Um segmento inicial é um subtexto.
Um segmento final é um subtexto.

Etapas para que se avance um percorredor até encontrar o próximo espaço;
Etapas para que se avance um percorredor até o próximo espaço:
  Avance o percorredor.
  Se o conteúdo deste last endereço de memória do pedaço deste segmento inicial deste percorredor não for o caractere de espaço, repita.
    \Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for o caractere de espaço, repita.

Etapas para que se recue um percorredor até o próximo espaço;
Etapas para que se recue um percorredor até encontrar o próximo espaço:
  Recue o percorredor.
  Recue o percorredor.
  Se o conteúdo deste first endereço de memória do pedaço deste segmento final deste percorredor não for o caractere de espaço, repita.
    \Se o conteúdo deste last endereço de memória do pedaço deste segmento inicial deste percorredor não for o caractere de espaço, repita.

Etapas para que se recue um percorredor por um número:
  Subtraia o número desde o first endereço de memória do pedaço deste segmento inicial deste percorredor.
  Subtraia o número desde o last endereço de memória do pedaço deste segmento final deste percorredor.

A contagem total é um número igual a 0.

O detector de ignição é um detector igual a 1.

O sinal de desligamento é um detector igual a 0.

Um posicionamento absoluto é um número.

Etapas para que se adicione uma fração para uma segunda fração:
  Isole a fração.
  Normalize a fração e a segunda fração.
  Adicione o numerador desta fração para o numerador desta segunda fração.
  Reduce a segunda fração.

Etapas para que se adicione uns horizontal twips e uns vertical twips para o current localização:
  Adicione o horizontal twips para a coordenada X desta localização deste context.
  Adicione o vertical twips para a coordenada Y desta localização deste context.

Etapas para que se adicione uma line para uma figura:
  Se a figura for inexistente, crie a figura; posponha a figura para as figuras.
  Adicione o start desta line para a figura.
  Adicione o end desta line para a figura.

Etapas para que se adicione um nome para umas choices:
  Aloque memória para uma choice.
  Atribua o nome ao nome desta choice.
  Atribua a choice at o end of as choices.

Etapas para que se adicione um número e um segundo número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o segundo número para o número Y deste par de números.

Etapas para que se adicione um número para um segundo número e um terceiro número para um quarto número:
  Adicione o número para o segundo número.
  Adicione o terceiro número para o quarto número.



Etapas para que se adicione um número para um fração:
  Adicione o número / 1 para a fração.

Etapas para que se adicione um número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o número para o número Y deste par de números.

Etapas para que se adicione um par de números para uma segundo par de números:
  Adicione o número X deste par de números para o número X desta segundo par de números.
  Adicione o número Y deste par de números para o número Y desta segundo par de números.

Etapas para que se adicione um quora para um terminal:
  Crie o quora.
  Posponha o quora para o quora deste terminal.
  Se o terminal não estiver full, cancele.
  Atribua o first destes quoras deste terminal a um doomed quora.
  Remove o doomed quora desde os quoras deste terminal.
  Destrua o doomed quora.

Etapas para que se adicione uma localização para um figura:
  Posponha a localização para a figura.

Etapas para que se adicione uma string para uns conjunto de textos:
  Crie um conjunto de texto usando a string.
  Posponha o conjunto de texto para o conjunto de textos.

Etapas para que se ajuste uma caixa usando um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para a coordenada esquerda desta caixa.
  Adicione o segundo número para a coordenada superior desta caixa.
  Adicione o terceiro número para a coordenada direita desta caixa.
  Adicione o quarto número para a coordenada inferior desta caixa.

Etapas para que se ajuste um item:
  Atribua os dwFileAttributes deste WIN32FINDDATA deste item a um número.
  Conjuncione logicamente o número com 16 [FILE_ATTRIBUTE_DIRECTORY].
  Se o número for 0, atribua "arquivo" à categoria deste item. \; atribua "arquivo" à classe deste item.
  Se o número não for 0, atribua "endereço de pasta" à categoria deste item.\; atribua "directorio" à classe deste item.
  Converta o ftCreationTime deste WIN32FINDDATA deste item para a creation date/time string deste item . \ adicionado para classificação de e-mails.
  Atribua o endereçamento deste cFileName deste WIN32FINDDATA deste item a um pchar.
  Converta o pchar para o designador deste item.
  Se a categoria deste item for "endereço de pasta", posponha "\" para o designador deste item.
  Atribua o endereço da pasta deste item junto com o designador deste item ao endereço completo deste item.
  Extraia a extensão deste item desde o designador deste item como um endereço completo.
  Atribua o nFileSizeLow deste WIN32FINDDATA deste item ao size deste item.
  Se o conteúdo deste first deste designador deste item não for o ponto final, cancele.
  Obtenha o item (not first time).

Etapas para que se ajuste um line com um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para o x deste start desta line.
  Adicione o segundo número para o y deste start desta line.
  Adicione o terceiro número para o x deste end desta line.
  Adicione o quarto número para o y deste end desta line.

Etapas para que se ajuste um imagem (extract caixas desde gpbitmap):
  Se o imagem for inexistente, cancele.
  Atribua 0 à coordenada esquerda desta caixa desta imagem.
  Atribua 0 à coordenada superior desta caixa desta imagem.
  Atribua a largura deste gpbitmap desta imagem menos 1 times o tpp à coordenada direita desta caixa desta imagem.
  Atribua a altura deste gpbitmap desta imagem menos 1 times o tpp à coordenada inferior desta caixa desta imagem.
  Atribua a caixa desta imagem à caixa intacta desta imagem.

Etapas para que se ajuste spacing usando uma string:
  Se o quadro atual não for o printer canvas, cancele.
  Call "gdi32.dll" "SetTextCharacterExtra" com 
    O printer canvas \ Um identificador para o contexto do dispositivo.
    e 0.    \ A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
    \Se o modo de mapeamento atual não for MM_TEXT, o parâmetro nCharExtra será transformado e arredondado para o pixel mais próximo.
    \quero traduzir esse comando como: Mande o printer canvas e o código 0 para a função "SetTextCharacterExtra" da biblioteca "gdi32.dll".
  Call "gdi32.dll" "GetCurrentObject" com 
    O printer canvas \ Um identificador para o contexto do dispositivo.
    e 6 [obj_font]    \ O tipo de objeto a ser consultado. Este parâmetro pode ser vários valores.
    \ OBJ_FONT -> Retorna a fonte selecionada no momento.
    devolvendo um número identificador. \ Se a função for bem-sucedida, o valor de retorno é um identificador para o objeto especificado. Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas \ Um identificador para o contexto do dispositivo.
    e O número identificador. \ Um identificador para o objeto a ser selecionado. Nesse caso é o número do comando anterior, retornado pelo GetCurrentObject acima
  Obtenha um largura usando a string e o memory canvas.
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O null número da fonte.
  Obtenha uma segunda largura usando a string e o printer canvas.
  Atribua o largura menos a segunda largura dividido pelo quantidade de caracteres desta string a um número.
  Call "gdi32.dll" "SetTextCharacterExtra" com 
    O printer canvas e 
    O número.

Etapas para que se align um text usando um alinhamento:
  Atribua o alinhamento ao alinhamento deste text.

Um alinhamento é uma string [center, left, ou right].

Um quantia é um número.

Um anchor é um position.

Um máscara de conjunção lógica é uma mask.

Um ângulo é uns precise degrees [0 para 3599].

Etapas para que se posponha um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" \Esta função armazena o ponteiro do arquivo em dois valores LONG.
  com o file \ Um identificador para o arquivo.
    \O identificador de arquivo deve ser criado com o direito de acesso GENERIC_READ ou GENERIC_WRITE. 
    \Para obter mais informações sobre direitos de acesso, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-security-and-access-rights
    e 0 [lDistanceToMove]
    \Os 32 bits de ordem inferior de um valor com sinal que especifica o número de bytes para mover o ponteiro do arquivo.
    \Se lpDistanceToMoveHigh não for NULL, lpDistanceToMoveHigh e lDistanceToMove formam um único valor de 64 bits com sinal que especifica a distância a ser movida.
    \Se lpDistanceToMoveHigh for NULL, lDistanceToMove será um valor de 32 bits com sinal. 
    \Um valor positivo para lDistanceToMove move o ponteiro do arquivo para frente no arquivo e um valor negativo move o ponteiro para trás no arquivo .
    e 0 [lpDistanceToMoveHigh]
    \ Um ponteiro para os 32 bits de ordem superior da distância de 64 bits com sinal a ser movida.
    \Se você não precisa de 32 bits de alta ordem, este ponteiro deve ser definido como NULL.
    \ Quando não é NULL, esse parâmetro também recebe o DWORD de ordem superior do novo valor do ponteiro do arquivo.
    \ Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer
    e 2 [file_end] [dwMoveMethod]
    \ O ponto de partida para o movimento do ponteiro do arquivo.
    \ Este parâmetro pode ser um dos seguintes valores.
    \0 = FILE_BEGIN ->  O ponto de partida é zero ou o início do arquivo.
    \ 1 = FILE_CURRENT -> O ponto de partida é o valor atual do ponteiro do arquivo.
    \ 2 = FILE_END -> O ponto de partida é a posição atual de fim de arquivo.
    devolvendo um result número.
    \Se a função for bem-sucedida e lpDistanceToMoveHigh for NULL, o valor de retorno será o DWORD de ordem inferior do novo ponteiro de arquivo. 
    \Obs: Se a função retornar um valor diferente de INVALID_SET_FILE_POINTER, a chamada para SetFilePointer foi bem-sucedida.
  Se o result número for -1, atribua "Ocorreu um erro na hora de posicionar o ponteiro do arquivo." ao erro do fluxo de entrada/saída; exit.
    \ Se um novo ponteiro de arquivo for um valor negativo, a função falhará, o ponteiro de arquivo não será movido e o código retornado por GetLastError será ERROR_NEGATIVE_SEEK.
  Call "kernel32.dll" "WriteFile" com \ Grava dados no arquivo ou dispositivo de entrada / saída (E / S) especificado.
    \ Esta função foi projetada para operação síncrona e assíncrona.
    O file [hFile]
    \ Um identificador para o arquivo ou dispositivo de E / S 
    \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    \ O parâmetro hFile deve ter sido criado com o acesso de gravação. 
    \Para obter mais informações, consulte os sites
    \ https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/generic-access-rights
    \ https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-security-and-access-rights
    \ Para operações de gravação assíncrona, hFile pode ser qualquer identificador aberto com a função CreateFile usando o sinalizador FILE_FLAG_OVERLAPPED 
    \ou um identificador de soquete retornado pelo soquete ou função de aceitação.
    e O first deste trecho [lpBuffer]
    \ Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    \ Este buffer deve permanecer válido durante a operação de gravação. 
    \ O chamador não deve usar esse buffer até que a operação de gravação seja concluída.
    e A quantidade de caracteres deste trecho [nNumberOfBytesToWrite]
    \ O número de bytes a serem gravados no arquivo ou dispositivo.
    \ Um valor zero especifica uma operação de gravação nula. 
    \O comportamento de uma operação de gravação nula depende do sistema de arquivos subjacente ou da tecnologia de comunicação.
    e um endereçamento desse número [lpNumberOfBytesWritten]
    \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono. 
    \ WriteFile define esse valor como zero antes de fazer qualquer trabalho ou verificação de erro.
    \ Use NULL para este parâmetro se esta for uma operação assíncrona para evitar resultados potencialmente errôneos.
    \Este parâmetro pode ser NULL somente quando o parâmetro lpOverlapped não for NULL.
    e 0 [lpOverlapped]
    \Um ponteiro para uma estrutura OVERLAPPED é necessário se o parâmetro hFile foi aberto com FILE_FLAG_OVERLAPPED, caso contrário, este parâmetro pode ser NULL.
    \ Para um hFile que oferece suporte a deslocamentos de byte, se você usar este parâmetro, deverá especificar um deslocamento de byte no qual iniciar a gravação no arquivo ou dispositivo. 
    \Esse deslocamento é especificado definindo os membros Offset e OffsetHigh da estrutura OVERLAPPED. 
    \Para um hFile que não oferece suporte a deslocamentos de byte, Offset e OffsetHigh são ignorados.
    \Para gravar no final do arquivo, especifique os membros Offset e OffsetHigh da estrutura OVERLAPPED como 0xFFFFFFFF. 
    \Isso é funcionalmente equivalente a chamar anteriormente a função CreateFile para abrir hFile usando o acesso FILE_APPEND_DATA.
    \ Para obter mais informações sobre diferentes combinações de lpOverlapped e FILE_FLAG_OVERLAPPED, consulte:
    \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
    \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#synchronization-and-file-position
    devolvendo o result número.
    \ Se a função for bem-sucedida, o valor de retorno será diferente de zero (VERDADEIRO).
    \ Se a função falhar ou estiver sendo concluída de forma assíncrona, o valor de retorno será zero (FALSO). 
    \Para obter informações de erro estendidas, chame a função GetLastError.
    \ Nota: O código GetLastError ERROR_IO_PENDING não é uma falha; indica que a operação de gravação está com conclusão pendente de forma assíncrona. 
    \ Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
  Se o result número for 0, atribua "Ocorreu um erro na hora de salvar o arquivo." ao erro do fluxo de entrada/saída; exit.

Etapas para que se posponha um pedaço para uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres desta string mais 1.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres armazenados ao last endereço de memória do pedaço desta string.
  Atribua o pedaço para o conteúdo deste last endereço de memória do pedaço desta string.

Etapas para que se posponha um pedaço para uma string usando uma contagem:
  Isole a contagem.
  Percorra. [o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha o pedaço para a string.
    Subtraia 1 desde a contagem.
  Repita. [o código acima]

Etapas para que se posponha um detector para uma string:
  Converta o detector para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha uma fração para uma string:
  Converta a fração para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um número para uma string:
  Converta o número para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um endereço de memória para uma string:
  Converta o endereço de memória para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha uma localização para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a localização.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha uma string para uma segunda string:
  Se a string estiver em branco, cancele.
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Atribua a quantidade de caracteres desta segunda string a uma quantidade de caracteres armazenados.
  Adicione a quantidade de caracteres armazenados para a quantidade de caracteres agrupados.
  Reassign o first endereço de memória do pedaço desta segunda string usando a quantidade de caracteres agrupados.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres armazenados a um endereço de memória.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o endereço de memória pelo quantidade de caracteres desta string.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres agrupados menos 1 ao last endereço de memória do pedaço desta segunda string.

Etapas para que se posponha uma string para uma segunda string (handling email transparency):
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor (text file rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor começa com ".", posponha "." para a segunda string.
    Posponha o segmento inicial deste percorredor para a segunda string.
  Repita. [o código acima]

Etapas para que se posponha uma string para uma segunda string usando uma contagem:
  Isole a contagem.
  Percorra. [o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha a string para a segunda string.
    Subtraia 1 desde a contagem.
  Repita. [o código acima]

Etapas para que se posponha uns coisas para uns segunda coisas:
  Atribua o first destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Posponha a coisa para a segunda coisas.
  Repita. [o código acima]

Etapas para que se posponha um temporizador para uma string:
  Converta o temporizador para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um vértice para um polígono:
  Se o polígono for inexistente, cancele.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha uma coordenada X e uma coordenada Y para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a coordenada X e a coordenada Y.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha zeros para uma string until its quantidade de caracteres é um número:
  Se a quantidade de caracteres desta string for maior do que ou igual ao número, cancele.
  Posponha "0" para a string.
  Repita. [o código acima]

A seta do mouse é um cursor.

Etapas para que se assign um endereço de memória usando um quantidade de pedaços:
  Se o quantidade de pedaços for 0, esvazie o endereço de memória; exit.
  Isole o quantidade de pedaços.
  Arredonde o quantidade de pedaços para cima para o nearest power of two.
  Call "kernel32.dll" "HeapAlloc" com 
    O endereço heap 
    e 8 [HEAP_ZERO_MEMORY] 
    e A quantidade de pedaços 
    devolvendo o endereço de memória.
  Se o endereço de memória não for inexistente, adicione 1 para a contagem do heap; exit.

Etapas para que se role automaticamente um text usando uma localização e um detector:
  Se o text for inexistente, desative o detector; exit.
  Atribua a altura desta font deste text a um número.
  Limpe um difference.
  Atribua a caixa deste text a uma caixa.
  Indent a caixa usando o tpp.
  Se a coordenada Y desta localização for menor do que a coordenada superior desta caixa, atribua o número ao número Y desta difference.
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, atribua o número ao número Y desta difference; negate o número Y desta difference.
  Se a coordenada X desta localização for menor do que a coordenada esquerda desta caixa, atribua o número ao número X desta difference.
  Se a coordenada X desta localização for maior do que a coordenada direita desta caixa, atribua o número ao número X desta difference; negate o número X desta difference.
  Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número X desta difference.
  Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, desative o detector; exit.
  Ligue o detector.
  Role o text usando a difference.
  Aguarde por 50 milliseconds.

Um baseline é um número.

Etapas para que se beep:
  Call "user32.dll" "MessageBeep" com 
  0.

Etapas para que se begin um landscape sheet:
  Make o landscape sheet 1056 pixels por 816 pixels.
  Begin um sheet com o landscape sheet.

Etapas para que se begin um portrait sheet:
  Make o portrait sheet 816 pixels por 1056 pixels.
  Begin um sheet com o portrait sheet.

Etapas para que se begin printing:
  Inicialize o printer canvas.
  Atribua a magnitude desse docinfo ao cbsize deste docinfo.
  Atribua o first deste nome deste module ao lpszdocname deste docinfo.
  Call "gdi32.dll" "StartDocA" com 
    O printer canvas 
    e O endereçamento deste docinfo.

Etapas para que se begin um sheet:
  Begin o sheet como um portrait sheet.

Etapas para que se begin um sheet usando um title string:
  Begin um portrait sheet usando o title.

O Bíblia é uma coisa com uns verses.

Um verse é uma coisa com uma string.

Um big-endian unsigned word é um conjunto com 2 pedaços.

    \Um billion é 1000 millions.

Um código binário é uma string.

An bit é uma unidade.

\Um bitmapdata é um conjunto com
\Um largura,
\Um altura,
\Um número denominado stride,
\Um número denominado pixelformat,
\Um endereço de memória denominado scan0,
\Um número denominado Reserved.

Uma caixa é um conjunto com
  Uma coordenada esquerda , 
  Uma coordenada superior, 
  Uma coordenada direita, 
  Uma coordenada inferior,
  Um canto superior esquerdo localização at a coordenada esquerda , e 
  Um canto inferior direito localização at a coordenada direita, e
  Uma topo-left localização at a coordenada esquerda , e 
  Uma base-right localização at a coordenada direita. 

Um brilho é uma luminosidade.

Um contagem de buckets é uma contagem.

Um bucket é um endereço de memória para um conjunto de buckets.

Um conjunto de buckets é um conjunto com uns refers.

An bucket# é um número.

Um trecho é uma string.

Etapas para que se avance um pedaço limiting it para um segundo pedaço e um terceiro pedaço:
  Adicione 1 para o pedaço.
  Se o pedaço for maior do que o terceiro pedaço, atribua o segundo pedaço ao pedaço.

Etapas para que se avance um número:
  Adicione 1 para o número.

Etapas para que se avance um número limiting it para um segundo número e um terceiro número:
  Adicione 1 para o número.
  Se o número for maior do que o terceiro número, atribua o segundo número ao número.

Etapas para que se avance um percorredor por um número:
  Adicione o número para o last endereço de memória do pedaço deste segmento inicial deste percorredor.
  Adicione o número para o first endereço de memória do pedaço deste segmento final deste percorredor.

Etapas para que se buzz:
  Call "kernel32.dll" "Beep" com 
  220 
    e 200.

Um quantidade de pedaços é uma contagem.

Um endereço de memória do pedaço é um endereço de memória para um pedaço.

An byte# é um número.

An canvas é um hdc. \ hdc = handle device context

Etapas para que se capitalize algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Se a row estiver em branco, repita.
    Capitalize a string deste row.
  Repita. [o código acima]

Etapas para que se capitalize uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, pare.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Uppercase o conteúdo deste first endereço de memória do pedaço deste subtexto.

Etapas para que se capitalize um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde os rows deste text.
    Se a row for inexistente, pare.
    Capitalize a string deste row.
  Repita. [o código acima]
  Wrap o text.

Um caret é um position.

Etapas para que se centralize uma caixa at o base of uma segunda caixa:
  Centralize a caixa no segunda caixa (horizontalmente).
  Atribua a altura desta caixa a uma altura.
  Atribua a coordenada inferior desta segunda caixa à coordenada inferior desta caixa.
  Atribua a coordenada inferior desta caixa menos o altura à coordenada superior desta caixa.

Etapas para que se centralize uma caixa em uma segunda caixa (horizontalmente):
  Atribua a coordenada X deste center desta segunda caixa menos a coordenada X deste center desta caixa a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova a caixa usando o número e 0.

Etapas para que se centralize uma caixa em uma segunda caixa (verticalmente):
  Atribua a coordenada Y deste center desta segunda caixa menos a coordenada Y deste center desta caixa a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova a caixa usando 0 e o número.

Etapas para que se centralize um dot sobre o current localização:
    \ need Spanish palavra por "dot"
  Centralize o dot sobre a localização deste context.

Etapas para que se centralize um elipse em uma caixa (horizontalmente):
  Centralize a caixa desta elipse na caixa (horizontalmente).

Etapas para que se centralize um elipse em uma caixa (verticalmente):
  Centralize a caixa desta elipse na caixa (verticalmente).

Etapas para que se centralize um line em uma caixa (horizontalmente):
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta line a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o line usando o número e 0.

Etapas para que se centralize um line em uma caixa (verticalmente):
  Atribua o y deste center desta caixa menos o y deste center desta line a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o line usando 0 e o número.

Etapas para que se centralize um imagem em uma caixa (horizontalmente):
  Se o imagem for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o imagem usando o número e 0.

Etapas para que se centralize um imagem em uma caixa (verticalmente):
  Se o imagem for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa menos a coordenada Y deste center desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o imagem usando 0 e o número.

Etapas para que se centralize um polígono em uma caixa (horizontalmente):
  Se o polígono for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o polígono usando o número e 0.

Etapas para que se centralize um polígono em uma caixa (verticalmente):
  Se o polígono for inexistente, cancele.
  Atribua o y deste center desta caixa menos o y deste center desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o polígono usando 0 e o número.

Etapas para que se centralize uma localização em uma caixa (horizontalmente):
  Atribua a coordenada X deste center desta caixa menos a coordenada X desta localização a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova a localização usando o número e 0.

Etapas para que se centralize uma localização em uma caixa (verticalmente):
  Atribua o y deste center desta caixa menos a coordenada Y desta localização a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova a localização usando 0 e o número.

Etapas para que se centralize um text em uma caixa (horizontalmente):
  Se o text for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa deste text a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o text usando o número e 0.

Etapas para que se centralize um text em uma caixa (verticalmente):
  Se o text for inexistente, cancele.
  Atribua o y deste center desta caixa menos o y deste center desta caixa deste text a um número.
  Arredonde o número para o múltiplo imediato of o tpp.
  Mova o text usando 0 e o número.

Etapas para que se modifique o current matiz por uns points;
Etapas para que se altere o current matiz por uns points;
Etapas para que se mude o current matiz por uns points:
  Mude a matiz deste context por os points.

Etapas para que se modifique um matiz por uns points;
Etapas para que se altere um matiz por uns points;
Etapas para que se mude um matiz por uns points:
  Adicione o points para o matiz.

Etapas para que se modifique uma caixa arredondada usando um raio;
Etapas para que se altere uma caixa arredondada usando um raio;
Etapas para que se mude uma caixa arredondada usando um raio:
  Atribua o raio ao raio desta caixa arredondada.

Etapas para que se modifique um text usando uma caixa;
Etapas para que se altere um text usando uma caixa;
Etapas para que se mude um text usando uma caixa:
  Se o text for inexistente, cancele.
  Atribua a caixa à caixa deste text.
  Wrap o text.

Etapas para que se modifique um text usando uma altura da fonte;
Etapas para que se altere um text usando uma altura da fonte;
Etapas para que se mude um text usando uma altura da fonte:
  Se o text for inexistente, cancele.
  Subtraia a margin deste text desde a coordenada X deste text.
  Atribua a origin deste text dividido pela malha deste text a um par de números.
  Atribua o altura da fonte à altura desta font deste text.
  Redimensione proporcionalmente a altura desta font deste text usando a scale deste text.
  Atribua o par de números times a malha deste text à origin deste text.
  Adicione a margin deste text para a coordenada X deste text.
  Limite o origin of o text.
  Wrap o text.

Etapas para que se modifique um text usando uma nome da fonte;
Etapas para que se altere um text usando uma nome da fonte;
Etapas para que se mude um text usando uma nome da fonte:
  Se o text for inexistente, cancele.
  Atribua o nome da fonte ao nome desta font deste text.
  Wrap o text.

Um character é um pedaço.

Uma choice é uma coisa com um nome e uma caixa.

As choices são umas choices.

Etapas para que se limpe uma caixa:
  Atribua 0 e 0 e 0 e 0 ao caixa. \ caderno depends sobre this

Etapas para que se limpe um pedaço:
  Atribua o null pedaço ao pedaço.

Etapas para que se limpe uma cor:
  Atribua 0 e 0 e 0 à cor.

Etapas para que se limpe um elipse:
  Limpe a caixa desta elipse.

Etapas para que se desative um detector;
Etapas para que se desligue um detector:
  Atribua 0 ao detector. \ was "Atribua no ao detector." Value of "no" inherited desde o CAL-1000 according para Dan.

Etapas para que se limpe um font:
  Atribua "" e 0 ao font.

Etapas para que se limpe um fração:
  Atribua 0 e 1 à fração.

Etapas para que se limpe um Endereço IP:
  Limpe o número deste Endereço IP.
  Limpe a string deste Endereço IP.

Etapas para que se limpe umA line:
  Limpe o start desta line.
  Limpe o end desta line.

Etapas para que se limpe um número:
  Atribua 0 ao número.

Etapas para que se limpe um par de números:
  Atribua 0 e 0 ao par de números.

Etapas para que se limpe um percorredor:
  Limpe o subtexto original deste percorredor.
  Limpe o segmento final deste percorredor.
  Limpe o segmento inicial deste percorredor.

Etapas para que se erase a tela;
    \Etapas para que se branqueie a tela;
Etapas para que se apague a tela;
Etapas para que se limpe a tela:
  Mostre tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se pinte a tela usando uma cor;
Etapas para que se limpe a tela usando uma cor:
  Mostre tudo.
  Pinte a caixa desta tela com a cor e a cor.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se branqueie a tela;
Etapas para que se pinte a tela de branco;
Etapas para que se limpe a tela usando a cor branca:
    \ \ needs special handling
  Mostre tudo.
  Pinte a caixa desta tela com a cor branca e a cor branca.
  Atualize o tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se limpe a tela sem atualizá-la:
  Mostre tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se limpe uma seleção:
  Limpe o anchor desta seleção.
  Limpe o caret desta seleção.

Etapas para que se limpe o stack:
    \ stack needs work
  Destrua o stack.

Etapas para que se limpe uma string:
  Unassign o first endereço de memória do pedaço desta string.
  Esvazie o last endereço de memória do pedaço desta string.

Etapas para que se limpe um subtexto:
  Esvazie o first endereço de memória do pedaço deste subtexto.
  Esvazie o last endereço de memória do pedaço deste subtexto.

Etapas para que se limpe um terminal:
  Destrua os quoras deste terminal.

Etapas para que se limpe uns coisas:
  Esvazie o first destas coisas.
  Esvazie o last destas coisas.

Etapas para que se limpe um word:
  Atribua 0 ao word.

Etapas para que se close um file:
  Call "kernel32.dll" "CloseHandle" com 
    O file.

Um CLSID é um UUID. \ Class ID

Etapas para que se avise:
  Toque o som de aviso.

Um column# é um número.

Etapas para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres devolvendo um número:
  Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos ascii devolvendo o número.
    \Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos s/ acento ascii devolvendo o número.

Etapas para que se compativelmente handle algum tipo de message com um window um message número um w-param e um l-param:
  Se a message for 006, execute algum tipo de WM-ACTIVATE com o w-param; 
    \Enviado para a janela que está sendo ativada e a janela que está sendo desativada. 
    \Se as janelas usarem a mesma fila de entrada, a mensagem será enviada de forma síncrona, 
    \primeiro para o procedimento de janela da janela de nível superior que está sendo desativada e,
    \em seguida, para o procedimento de janela da janela de nível superior que está sendo ativada. 
    \Se as janelas usarem filas de entrada diferentes, a mensagem será enviada de forma assíncrona, portanto, a janela será ativada imediatamente.
     Atribua 0 para EAX; exit.
  Se a message for 258 [hex 102], execute algum tipo de WM-CHAR com o w-param e o l-param; 
    \ Essa menagem é enviada para a janela com o foco do teclado quando uma mensagem WM_KEYDOWN é traduzida pela função TranslateMessage. 
    \A mensagem WM_CHAR contém o código de caractere da tecla que foi pressionada.
  atribua 0 para EAX; exit.
  Se a message for 001, execute algum tipo de wm-create com o window; 
    \Enviado quando um aplicativo solicita que uma janela seja criada chamando a função CreateWindowEx ou CreateWindow. 
    \(A mensagem é enviada antes de a função retornar.) 
    \O procedimento de janela da nova janela recebe essa mensagem depois que a janela é criada, mas antes que a janela se torne visível.
    \Uma janela recebe essa mensagem por meio de sua função WindowProc.
  atribua 0 para EAX; exit.
  Se a message for 002, execute algum tipo de wm-destroy; atribua 0 para EAX; exit.
  Se a message for 256 [Hex 100], execute algum tipo de WM-KEYDOWN 
    \Essa menagem é enviada para a janela com o foco do teclado quando uma tecla não pertencente ao sistema é pressionada. 
    \Uma tecla que não é do sistema é aquela que é pressionada quando a tecla ALT não está pressionada.
  com o w-param \O código de tecla virtual da tecla não pertencente ao sistema. Consulte Códigos de teclas virtualis -> https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
    e O l-param; \Pode ser a contagem de repetição, um código de varredura, sinalizador de chave estendida, código de contexto, sinalizador de estado-chave anterior e sinalizador de estado de transição,
    \ veja detalhes aqui: https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown
   atribua 0 para EAX; exit.
  Se a message for 513 [Hex 201], execute algum tipo de WM-LBUTTONDOWN
    \Postado quando o usuário pressiona o botão esquerdo do mouse enquanto o cursor está na área do cliente de uma janela. 
    \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. 
    \Caso contrário, a mensagem é postada na janela que capturou o mouse.
    \Uma janela recebe essa mensagem por meio de sua função WindowProc.
    \ o w-param Indica se as teclas virtuais estão pressionadas ou não, podendo ser mais de uma
   com o l-param;    \A word de ordem inferior especifica a coordenada X do cursor. A coordenada é relativa ao canto superior esquerdo da área do cliente.
    \A word de ordem superior especifica a coordenada Y do cursor. A coordenada é relativa ao canto superior esquerdo da área do cliente.
   atribua 0 para EAX; exit.
  Se a message for 515 [Hex 203], execute algum tipo de wm-lbuttondblclk com o l-param; atribua 0 para EAX; exit.
  Se a message for 015 [Hex F], execute algum tipo de wm-paint com o window; atribua 0 para EAX; exit.
  Se a message for 516 [Hex 204], execute algum tipo de wm-rbuttondown com o l-param; atribua 0 para EAX; exit.
  Se a message for 518 [Hex 206], execute algum tipo de wm-rbuttondblclk com o l-param; atribua 0 para EAX; exit.
  Se a message for 032 [Hex 20], execute algum tipo de wm-setcursor; atribua 1 para EAX; exit.
  Se a message for 260 [Hex 104], execute algum tipo de wm-syskeydown com o w-param e o l-param; atribua 0 para EAX; exit.
  Call "user32.dll" "DefWindowProcA" com 
    A window 
    e A message 
    e 
  o w-param 
    e O l-param.

Etapas para que se compativelmente aguarde por um process endereço de memória:
  Call "kernel32.dll" "WaitForSingleObject" com 
    O conteúdo deste process endereço de memória 
    e -1 [tempo em milisegundos.  O valor -1 informa que a função retornará apenas quando o objeto for sinalizado.].
  Call "kernel32.dll" "CloseHandle" com o conteúdo deste process endereço de memória.
  Atribua 0 ao conteúdo deste process endereço de memória. \ conteúdo = conteúdo
  Call "user32.dll" "GetForegroundWindow" 
    devolvendo uma window.
  Se a window for a main window, atribua 0 para EAX; exit.
  Call "user32.dll" "ShowWindow" com 
    A main window 
    e 6 [SW_MINIMIZE].
  Call "user32.dll" "ShowWindow" com 
    A main window 
    e 9 [SW_RESTORE].
  Atribua 0 para EAX. \ abra return value of thread

    \Um console é uma coisa com 
    \a caixa,
    \a cor da borda,
    \a cor de preenchimento,
    \a text,
    \a malha,
    \a reply string.

Um console é uma coisa com 
Um caixa, 
Um cor da borda,
Um cor de preenchimento, 
Um text, 
Um malha, 
Um reply string.

O context é um context.

An context é uma coisa com 
  Uma localização, 
  Uma caixa, 
  Uma orientação, 
  Um tamanho da letra, 
  Uma cor, 
  Um número, 
  Uma grossura do pincel,\ pincel largura? ***
  e um letra size at o tamanho da letra, 
  e um pincel at a cor.
    \REMARK: O "grossura do pincel" não estava no context conjunto, but it deveria be.
    \I will be adding it para o next version of o CAL context, e now might be a good time for you para adicione it para o PAL context conjunto.

O context stack é uns contexts.

Etapas para que se converta um posicionamento absoluto para uma position usando um text:
  Se o text for inexistente, limpe o position; exit.
  Isole o posicionamento absoluto.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, limpe o position; exit.
    Atribua o número da linha desta row ao número da linha desta position.
    Atribua o posicionamento absoluto ao column# desta position.
    Subtraia a quantidade de caracteres desta string desta row desde o posicionamento absoluto.
    Se o posicionamento absoluto for menor do que 1, cancele.
  Repita. [o código acima]

Etapas para que se converta um código binário Para um número:
  Atribua 0 ao número.
  Atribua 1 a um value número.
  Percorra. [o código abaixo]
    Se o código binário estiver em branco, cancele.
    Obtenha um character desde o código binário (backwards). \ was backwards
    Se o character for "1", adicione o value para o número.
    Double o value.
  Repita. [o código acima]

Etapas para que se converta uma caixa para uma string:
  Limpe a string.
  Posponha a coordenada esquerda desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada superior desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada direita desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada inferior desta caixa para a string.

Etapas para que se converta um pedaço para uma cifra binária:
  Atribua o pedaço à cifra binária como um pedaço.
  Uppercase a cifra binária.
  Se a cifra binária for maior do que o número nove, subtraia 7 desde a cifra binária.
  Subtraia 48 desde a cifra binária.

Etapas para que se converta um pedaço para um cifra hexadecimal:
  Split o pedaço a uma cifra binária e uma segunda cifra binária.
  Converta a cifra binária para o cifra hexadecimal.
  Converta a segunda cifra binária para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Etapas para que se converta um pedaço para um query pedaço:
  Se o pedaço estiver entre 48 e 57, atribua o pedaço ao query pedaço; exit. \ 0-9
  Se o pedaço estiver entre 65 e 90, atribua o pedaço ao query pedaço; exit. \ A-Z
  Se o pedaço estiver entre 97 e 122, atribua o pedaço ao query pedaço; exit. \ a-z
  Se o pedaço for 32, atribua "+" ao query pedaço; exit. \ space
  Converta o pedaço para um cifra hexadecimal.
  Atribua "%" junto com a cifra hexadecimal ao query pedaço.

Etapas para que se converta uma cor para um código da cor:
  Se a cor estiver clear, atribua 16777215 [$00FFFFFF] ao código da cor; exit. \ a cor transparente fica branca 
  Isole a cor.
  Redimensione proporcionalmente a saturação desta cor usando 240/1000.
  Limite a saturação desta cor para 1 e 239.
  Redimensione proporcionalmente a luminosidade desta cor usando 240/1000.
  Limite a luminosidade desta cor para 1 e 239.
  Redimensione proporcionalmente a matiz desta cor usando 240/3600.
  Limite a matiz desta cor para 1 e 239.
  Call "shlwapi.dll" "ColorHLSToRGB" com 
    A matiz desta cor 
    e A luminosidade desta cor 
    e A saturação desta cor 
    devolvendo o código da cor.

Etapas para que se converta uma cor para um espaço de cor RGB:
  Converta a cor para um código da cor.
  Converta o código da cor para o espaço de cor RGB.

Etapas para que se converta um código da cor para uma cor:
  Call "shlwapi.dll" "ColorRGBToHLS" com 
    O código da cor e 
    O endereçamento desse word 
    e O endereçamento dessa segunda word 
    e O endereçamento desse terceiro word.
  Atribua o word à matiz desta cor.
  Atribua a segunda word à luminosidade desta cor.
  Atribua o terceiro word à saturação desta cor.
  Redimensione proporcionalmente a matiz desta cor usando 3600/240.
  Limite a matiz desta cor para 0 e 3600.
  Redimensione proporcionalmente a saturação desta cor usando 1000/240.
  Limite a saturação desta cor para 0 e 1000.
  Redimensione proporcionalmente a luminosidade desta cor usando 1000/240.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se converta um código da cor para um espaço de cor RGB:
  Isole o código da cor.
  Desloque o código da cor right 0 bits.
  Atribua o código da cor ao espectro vermelho deste espaço de cor RGB.
  Desloque o código da cor right 8 bits.
  Atribua o código da cor ao espectro verde deste espaço de cor RGB.
  Desloque o código da cor right 8 bits.
  Atribua o código da cor ao espectro azul deste espaço de cor RGB.

Etapas para que se converta um filetime para uma string:
  Limpe a string.
  Call "kernel32.dll" "FileTimeToSystemTime" com 
    O endereçamento deste filetime 
    e O endereçamento desse systemtime 
    devolvendo um número.
  Se o número for 0, cancele.
  Atribua o wyear deste systemtime ao year desse date/time.
  Atribua o wmonth deste systemtime ao month deste date/time.
  Atribua o wdayofweek deste systemtime ao week day deste date/time.
  Atribua o wday deste systemtime ao day deste date/time.
  Atribua o whour deste systemtime à hour deste date/time.
  Atribua o wminute deste systemtime ao minute deste date/time.
  Atribua o wsecond deste systemtime ao second deste date/time.
  Atribua os wmilliseconds deste systemtime ao millisecond deste date/time.
  Atribua a string deste date/time à string.

Etapas para que se converta um detector para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude deste detector.
  Copie pedaços desde o endereçamento deste detector para o first deste texto hexadecimal pela magnitude deste detector.
  Atribua o first deste texto hexadecimal mais a magnitude deste detector menos 1 ao last deste texto hexadecimal.

Etapas para que se converta uma font para um número da fonte:
  Isole o font.
  Modifique através do caractere NUL o nome desta font.
  Call "gdi32.dll" "CreateFontA" com
   - a altura desta font times 3 dividido por 4 
    e 0 
    e 0 
    e 0 
    e 0 
    e 0 
    e 0 
    e 0 
    e 1 [DEFAULT_CHARSET] 
    e 0 
    e 0 
    e 5 [CLEARTYPE_QUALITY] 
    e 4 [TRUETYPE_FONTTYPE] 
    e O first deste nome desta font 
    devolvendo o número da fonte.

Etapas para que se converta uma fração para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude desta fração.
  Copie pedaços desde o endereçamento desta fração para o first deste texto hexadecimal pela magnitude desta fração.
  Atribua o first deste texto hexadecimal mais a magnitude desta fração menos 1 ao last deste texto hexadecimal.

Etapas para que se converta uma fração para um mixed:
  Se o denominador desta fração for 0, atribua 0 ao whole número deste mixed; atribua 0 ao ratio deste mixed; exit.
  Divida o numerador desta fração pelo denominador desta fração usando o whole número deste mixed e um resto.
  Atribua o resto e o denominador desta fração ao fração deste mixed.

Etapas para que se converta uma fração para uma string usando um número:
    \ converts para um decimal representation com "the número" of places
  Limpe a string.
  Se o número for menor do que 1, cancele.
  Atribua 10 a um value número.
  Raise o value para o número.
  Isole a fração.
  Se a fração for negative, acione um detector; de-sign a fração.
  Multiplique o value pela fração.
  Zero fill o value usando o número e posponha it para a string.
  Atribua a quantidade de caracteres desta string menos o número mais 1 a um byte#.
  Insira "." à string antes de o byte#.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o ponto final, anteponha "0" para a string.
  Se o detector estiver ativo, anteponha "-" para a string.

Etapas para que se converta um texto hexadecimal para um fração:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude desta fração, atribua 0 e 1 ao ratio; exit.
  Copie pedaços desde o first deste texto hexadecimal para o endereçamento desta fração pela magnitude desta fração.

Etapas para que se converta um texto hexadecimal para um número:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude deste número, limpe o número; exit.
  Copie pedaços desde o first deste texto hexadecimal para o endereçamento destte número pela magnitude deste número.

Etapas para que se converta um l-param para um tecla:
    \ assumes l-param desde wm_char message
  Atribua o l-param à tecla.
  Desloque a tecla right 16 bits.
  Conjuncione logicamente a tecla com 255.
  Call "user32.dll" "MapVirtualKeyA" com 
    A tecla 
    e 1 
    devolvendo a tecla.
  Se o numlock tecla was not toggled, cancele.
  Se a tecla for a tecla Insert, atribua o numpad-tecla zero à tecla; exit.
  Se a tecla for a tecla Delete, atribua o numpad-period tecla à tecla; exit.
  Se a tecla for a tecla Home, atribua o numpad-tecla sete à tecla; exit.
  Se a tecla for a tecla End, atribua o numpad-tecla hum à tecla; exit.
  Se a tecla for a tecla PgUp, atribua o numpad-tecla nove à tecla; exit.
  Se a tecla for a tecla PgDn, atribua o numpad-tecla três à tecla; exit.
  Se a tecla for a left-arrow tecla, atribua o numpad-tecla quatro à tecla; exit.
  Se a tecla for a seta pra cima, atribua o numpad-tecla oito à tecla; exit.
  Se a tecla for a right-arrow tecla, atribua o numpad-tecla seis à tecla; exit.
  Se a tecla for a seta pra baixo, atribua o numpad-tecla dois à tecla; exit.
  Se a tecla for a tecla Clear, atribua o numpad-tecla cinco à tecla; exit.

Etapas para que se converta um l-param para uma localização:
  Split o l-param a um word e uma segunda word.
  Atribua o word à coordenada y desta localização.
  Atribua a segunda word à coordenada x desta localização.
  Multiplique a localização pelo tpp.

Etapas para que se converta um mixed para um fração:
  Atribua o fração deste mixed à fração.
  Adicione o whole número deste mixed times o denominador desta fração para o numerador desta fração.

Etapas para que se converta uma cifra binária para um cifra hexadecimal:
  Isole a cifra binária.
  Se a cifra binária for maior do que 9, adicione 7 para a cifra binária.
  Adicione 48 para a cifra binária.
  Atribua a cifra binária ao cifra hexadecimal.

Etapas para que se converta um cifra hexadecimal para um texto hexadecimal:
  Isole o cifra hexadecimal.
  Limpe o texto hexadecimal.
  Se a quantidade de caracteres deste cifra hexadecimal for ímpar, anteponha o número zero para o cifra hexadecimal.
  Lance um subtexto sobre o cifra hexadecimal.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma cifra binária.
    Desloque a cifra binária left 4 bits.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Posponha a cifra binária para o texto hexadecimal.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se converta um número para um pedaço:
  Atribua o número ao pedaço.

Etapas para que se converta um pchar para uma string:
  Limpe a string.
  Se o pchar for inexistente, cancele.
  Isole o pchar.
  Percorra. [o código abaixo]
    Se o conteúdo deste pchar for o null pedaço, cancele.
    Posponha o conteúdo deste pchar para a string.
    Adicione 1 para o pchar.
  Repita. [o código acima]

Etapas para que se converta um endereço de memória e uma quantidade de caracteres para uma string:
  Limpe a string.
  Se o endereço de memória for inexistente, cancele.
  Se a quantidade de caracteres for 0, cancele.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres.
  Copie pedaços desde o endereço de memória para o first endereço de memória do pedaço desta string pelo quantidade de caracteres.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres menos 1 ao last endereço de memória do pedaço desta string.

Etapas para que se converta um endereço de memória para um texto hexadecimal;
Etapas para que se converta um número para um texto hexadecimal:
  Reassign o first deste texto hexadecimal usando a magnitude deste número.
  Copie pedaços desde o endereçamento deste número para o first deste texto hexadecimal pela magnitude deste número.
  Atribua o first deste texto hexadecimal mais a magnitude deste número menos 1 ao last deste texto hexadecimal.

Etapas para que se converta um endereço de memória para um cifra hexadecimal;
Etapas para que se converta um número para um cifra hexadecimal:
  Split o número a um word e uma segunda word.
  Converta o word para o cifra hexadecimal.
  Converta a segunda word para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Etapas para que se converta um endereço de memória para uma string:
  Converta o endereço de memória para a string como um cifra hexadecimal.

Etapas para que se converta uns points para uns precise degrees:
  Atribua o points times 3840 dividido por 3600 ao precise degrees.

Etapas para que se converta uma position para um posicionamento absoluto usando um text:
  Se o text for inexistente, limpe o posicionamento absoluto; exit.
  Atribua 0 ao posicionamento absoluto.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha desta position, adicione a quantidade de caracteres desta string desta row para o posicionamento absoluto; repita.
  Adicione o column# desta position para o posicionamento absoluto.

Etapas para que se converta uns precise degrees para uns points:
  Atribua os precise degrees times 3600 dividido por 3840 ao points.

Etapas para que se converta um texto de consulta para uma string:
  Limpe a string.
  Se o texto de consulta estiver em branco, cancele.
  Lance um subtexto sobre o texto de consulta.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de adição, posponha " " para a string; adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o sinal de porcentagem, posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a string; adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Se a quantidade de caracteres deste subtexto for menor do que 3, cancele.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma cifra binária.
    Desloque a cifra binária left 4 bits.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Posponha a cifra binária para a string.
  Repita. [o código acima]

Etapas para que se converta uns rows para uma string:
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Posponha a string deste row para a string.
    Se o conteúdo deste last endereço de memória do pedaço desta string é o return pedaço, posponha o linefeed pedaço para a string; repita.
  Repita. [o código acima]

Etapas para que se converta uns rows para uma string (no linefeed additions):
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Posponha a string deste row para a string.
  Repita. [o código acima]

Etapas para que se converta uma string para um detector:
  Se a string for "s", acione o detector; exit.
  Se a string for "sim", acione o detector; exit.
  Se a string for "y", acione o detector; exit.
  Se a string for "yes", acione o detector; exit.
  [Se o texto informado não for nenhuma dessas opções, então:] 
  Desative o detector.

Etapas para que se converta uma string para um fração:
  Limpe a fração.
  Se a string estiver em branco, cancele.
  Se a string for algum tipo de integer, converta a string para o numerador desta fração; exit.
  Lance um subtexto sobre a string.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Split o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto estiver em branco, atribua o subtexto à fração subtexto.
  Split a fração subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
  Converta o integer subtexto para um whole número.
  Converta o numerador subtexto para um numerador número.
  Converta o denominador subtexto para um denominador número.
  Se o whole número é negative, cancele.
  Se o numerador número é negative, cancele.
  Se o denominador número é negative, cancele.
  Se o denominador número for 0, cancele.
  Se o whole número não for 0, adicione o denominador número times o whole número para o numerador número.
  Atribua o numerador número ao numerador desta fração.
  Atribua o denominador número ao denominador desta fração.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o hífem, negate a fração.

Etapas para que se converta uma string para um cifra hexadecimal:
  Limpe o cifra hexadecimal.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para uma segunda cifra hexadecimal.
    Posponha a segunda cifra hexadecimal para o cifra hexadecimal.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para um número:
  Atribua 0 ao número.
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Multiplique o número por 10.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um segundo número.
    Subtraia 48 desde o segundo número.
    Adicione o segundo número para o número.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Se o conteúdo deste first endereço de memória do pedaço desta string for o hífem, negate o número.

Etapas para que se converta uma string para um número entre um segundo número e um terceiro número:
  Converta a string para o número.
  Limite o número para o segundo número e o terceiro número.

Etapas para que se converta uma string para um endereço de memória:
    \ presume que o endereço de memória está em cifra binária format
  Converta a string como um cifra hexadecimal para um texto hexadecimal.
  Esvazie o endereço de memória.
  Lance um subtexto sobre o texto hexadecimal.
  Atribua 24 a um contagem de deslocamentos.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se a contagem de deslocamentos for menor do que 0, cancele.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um número.
    Desloque o número left o contagem de deslocamentos.
    Disjuncione logicamente o endereço de memória como um número com o número.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Subtraia 8 desde o contagem de deslocamentos.
  Repita. [o código acima]

Etapas para que se converta uma string para um texto de consulta:
  Limpe o texto de consulta.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
  Se o subtexto estiver em branco, pare.
    Converta o conteúdo deste first endereço de memória do pedaço deste subtexto para um query pedaço.
    Posponha o query pedaço para o texto de consulta.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para uns rows:
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor (text file rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma row usando o segmento inicial deste percorredor.
    Posponha a row para a rows.
    Se o conteúdo deste last endereço de memória do pedaço desta string desta row for o linefeed pedaço, atribua o return pedaço ao conteúdo deste last endereço de memória do pedaço desta string desta row. 
    \ *dahn new para handle lines terminated por just linefeed
  Repita. [o código acima]
  Renumber a rows.

Etapas para que se converta uma string para um uuid:
  Converta a string para um wide string e modifique através do caractere NUL.
  Call "ole32.dll" "CLSIDFromString" com 
    O first deste wide string 
    e O endereçamento deste uuid.

Etapas para que se converta uma string para um wide string:
  Limpe a wide string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a wide string.
    Posponha o null pedaço para a wide string.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para um wide string e modifique através do caractere NUL:
  Converta a string para a wide string.
  Modifique através do caractere NUL a wide string.

Etapas para que se converta uma URL para uma URL simplificada:
  Isole a URL.
  Modifique através do caractere NUL a URL.
  Atribua a magnitude desses URL_COMPONENTS ao dwStructSize destes URL_COMPONENTS.
  Atribua 1 ao dwSchemeLength destes URL_COMPONENTS.
  Atribua 1 ao dwHostNameLength destes URL_COMPONENTS.
  Atribua 1 ao dwUrlPathLength destes URL_COMPONENTS.
  Atribua 1 ao dwExtraInfoLength destes URL_COMPONENTS.
  Call "wininet.dll" "InternetCrackUrlA" com 
    O first desta URL 
    e 0 
    e 0 
    e O endereçamento destes URL_COMPONENTS 
    devolvendo um número.
  Converta o lpszScheme destes URL_COMPONENTS e o dwSchemeLength destes URL_COMPONENTS para o nome do protocolo desta URL simplificada.
  Converta o lpszHostName destes URL_COMPONENTS e o dwHostNameLength destes URL_COMPONENTS para o nome de host desta URL simplificada.
  Converta o lpszUrlPath destes URL_COMPONENTS e o dwUrlPathLength destes URL_COMPONENTS para o endereço de recurso desta URL simplificada.
  Converta o lpszExtraInfo destes URL_COMPONENTS e o dwExtraInfoLength destes URL_COMPONENTS para a parâmetro de consulta desta URL simplificada.
  Atribua o nPort destes URL_COMPONENTS ao número de porta desta URL simplificada.

Etapas para que se converta um word para um cifra hexadecimal:
  Split o word a um pedaço e um segundo pedaço.
  Converta o pedaço para o cifra hexadecimal.
  Converta o segundo pedaço para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para o cifra hexadecimal.

Uma coordenada é uns twips.

Etapas para que se copie um event para um segundo event: \ mudar o "segunda" aqui
  Se o event for inexistente, esvazie a segundo event; exit.
  Crie a segundo event.
  Atribua a categoria deste event à categoria deste segundo event.
  Atribua o detector de tecla Shift deste event ao detector de tecla Shift deste segundo event.
  Atribua o detector de tecla ctrl deste event ao detector de tecla Ctrl deste segundo event.
  Atribua o detector de tecla alt deste event ao detector de tecla Alt deste segundo event.
  Atribua a localização deste event à localização deste segundo event.
  Atribua a tecla deste event à tecla deste segundo event.
  Atribua o pedaço deste event ao pedaço deste segundo event.

Etapas para que se copie um gpbitmap Para uma segunda gpbitmap: \verificar
  Se o gpbitmap for inexistente, esvazie a segunda gpbitmap; exit.
  Call "gdiplus.dll" "GdipCloneBitmapAreaI" com 
  0 
    e 0 
    e A largura deste gpbitmap 
    e A altura deste gpbitmap 
    e 0 [PixelFormatDontCare] 
    e O gpbitmap 
    e O endereçamento desta segunda gpbitmap.

Etapas para que se copie o guts of um text Para uma segunda text:
  Se o text for inexistente, cancele.
  Se a segunda text for inexistente, cancele.
  Atribua a caixa deste text à caixa desta segunda text.
  Atribua a origin deste text à origin desta segunda text.
  Atribua o pincel deste text ao pincel desta segunda text.
  Atribua a font deste text à font desta segunda text.
  Atribua o alinhamento deste text ao alinhamento desta segunda text.
  Copie as rows deste text para as rows desta segunda text.
  Atribua a margin deste text à margin desta segunda text.
  Atribua a scale deste text à scale desta segunda text.
  Atribua o wrap detector deste text ao wrap detector desta segunda text.
  Atribua o horizontal scroll detector deste text ao horizontal scroll detector desta segunda text.
  Atribua o vertical scroll detector deste text ao vertical scroll detector desta segunda text.
  Atribua a seleção deste text à seleção desta segunda text.
  Atribua o detector de alteração deste text ao detector de alteração desta segunda text.
  Atribua o última operação deste text ao última operação desta segunda text.
    \ dont copie undos e redos

O número de cópias é um número.

Etapas para que se copie uma imagem Para uma segunda imagem:
  Se o imagem for inexistente, esvazie a segunda imagem; exit.
  Aloque memória para a segunda imagem.
  Atribua a caixa desta imagem à caixa desta segunda imagem.
  Atribua a caixa intacta desta imagem à caixa intacta desta segunda imagem.
  Atribua o grayscale detector desta imagem ao grayscale detector desta segunda imagem.
  Atribua o mirror detector desta imagem ao mirror detector desta segunda imagem.
  Atribua o ângulo de rotação desta imagem ao ângulo de rotação desta segunda imagem.
  Atribua os data desta imagem aos data desta segunda imagem.
  Copie o gpbitmap desta imagem ao gpbitmap desta segunda imagem.

Etapas para que se copie um polígono Para uma segunda polígono:
  Se o polígono for inexistente, esvazie a segunda polígono; exit.
  Aloque memória para o segunda polígono.
  Copie os vértices deste polígono aos vértices desta segunda polígono.

Etapas para que se copie uma row Para uma segunda row:
  Se a row for inexistente, esvazie a segunda row; exit.
  Aloque memória para o segunda row.
  Atribua a número da linha desta row ao número da linha desta segunda row.
  Atribua a string desta row à string desta segunda row.

Etapas para que se copie uns rows Para uns segunda rows:
  Destrua a segunda rows.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Copie a row a uma segunda row.
    Posponha a segunda row para a segunda rows.
  Repita. [o código acima]

Etapas para que se copie um text Para uma segunda text:
  Se o text for inexistente, esvazie a segunda text; exit.
  Aloque memória para o segunda text.
  Copie o guts of o text ao segunda text.

Etapas para que se copie um vértice Para uma segunda vértice:
  Se o vértice for inexistente, esvazie a segunda vértice; exit.
  Aloque memória para o segunda vértice.
  Atribua a coordenada X deste vértice à coordenada x desta segunda vértice.
  Atribua a coordenada Y deste vértice à coordenada y desta segunda vértice.

Etapas para que se copie uns vértices Para uns segunda vértices:
  Destrua os segunda vértices.
  Percorra. [o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Copie o vértice a uma segunda vértice.
    Posponha a segunda vértice para a segunda vértices.
  Repita. [o código acima]

Uma contagem é um número.

Um contador é um número.

Etapas para que se crie o connect handle of um winhttp request using uma URL simplificada:
  Se o winhttp request for inexistente, cancele.
  Converta o nome de host desta URL simplificada a um wide string denominado wide host nome e modifique através do caractere NUL.
  Call "winhttp.dll" "WinHttpConnect" com 
    O session número identificador desta request deste winhttp
   e o first endereço de memória do pedaço deste wide host nome 
   e o número de porta desta URL simplificada 
   e 0 
     devolvendo o connection número identificador deste winhttp request.
  Se o connection número identificador deste winhttp request for 0, atribua "Erro. Não foi possível estabelecer uma conexão." ao erro do fluxo de entrada/saída; exit.

Etapas para que se crie um console:
  Aloque memória para o console.
  Atribua a cor cinza muito claro à cor da borda deste console.
  Atribua a cor cinza muito claro à cor de preenchimento deste console.
  Atribua a caixa desta tela à caixa deste console.
  Atribua a caixa desta tela a uma caixa.
  Subtraia a altura desta fonte padrão desde a coordenada inferior desta caixa.
  Atribua a altura desta caixa dividido pela altura desta fonte padrão times a altura desta fonte padrão a uma altura.
  Atribua a coordenada superior desta caixa mais o altura à coordenada inferior desta caixa.
  Centralize a caixa na caixa desta tela (verticalmente).
  Atribua a coordenada superior desta caixa à coordenada esquerda desta caixa.
  Subtraia a coordenada superior desta caixa desde a coordenada direita desta caixa.
  Crie o text deste console.
  Atribua a caixa à caixa deste text deste console.
  Ligue o wrap detector deste text deste console.
  Desative o horizontal scroll detector deste text deste console.
  Ligue o vertical scroll detector deste text deste console.
  Atribua a altura desta fonte padrão ao malha deste console.
  Multiplique o número X deste malha deste console por 2.

Etapas para que se crie um crypt session com um passphrase string:
    \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Aloque memória para o crypt session.
    \ acquire context
  Call "advapi32.dll" "CryptAcquireContextA" com 
    O endereçamento deste HCRYPTPROV deste crypt session 
    e 0 
    e "Microsoft Enhanced Cryptographic Provider v1.0"'s first endereço de memória do pedaço 
    e 1 [PROV_RSA_FULL] 
    e -268435456 [CRYPT_VERIFYCONTEXT] 
    devolvendo um result número.
  Se o result número for 0, atribua "Erro. Não foi possível adquirir o contexto." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
    \ crie hash
  Call "advapi32.dll" "CryptCreateHash" com 
    o HCRYPTPROV deste crypt session 
    e 32771 [CALG_MD5] 
    e 0 
    e 0 
    e o endereçamento deste HCRYPTHASH deste crypt session 
    devolvendo o result número.
  Se o result número for 0, atribua "Erro. Não foi possível criar o hash." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
    \ hash passphrase
  Call "advapi32.dll" "CryptHashData" com 
    O HCRYPTHASH deste crypt session 
    e O first desta passphrase 
    e A quantidade de caracteres desta passphrase 
    e 0 
    devolvendo o result número.
  Se o result número for 0, atribua "Erro. Não foi possível fazer o hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
    \ derive session tecla
  Call "advapi32.dll" "CryptDeriveKey" com 
    O HCRYPTPROV deste crypt session 
    e 26625 [CALG_RC4  Stream Cipher] 
    e O HCRYPTHASH deste crypt session 
    e 8388608 [Key length: 128 bit] 
    e O endereçamento deste hcryptkey desta crypt session 
    devolvendo o result número.
  Se o result número for 0, atribua "Erro. Não foi possível derivar a chave da sessão." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.

Etapas para que se crie um dyad:
  Aloque memória para o dyad.

Etapas para que se crie um event:
  Aloque memória para o event.

Etapas para que se crie uma font info usando um font:
  Crie o font info usando o font (basic data).
  Crie as font larguras desta font info usando o font.

Etapas para que se crie uma font info usando uma font (basic data):
  Aloque memória para o font info.
  Atribua o font ao font desta font info.
  Obtenha um outlinetextmetric usando o font.
  Atribua 32 ao flags deste font info. \ could ser updated com um more information
  Atribua o tminternalleading destes otmtextmetrics deste outlinetextmetric ao internal leading desta font info.
  Atribua o otmemsquare deste outlinetextmetric ao emsquare desta font info.
  Atribua o tmascent deste otmtextmetrics deste outlinetextmetric ao ascent desta font info.
  Atribua - o tmdescent deste otmtextmetrics deste outlinetextmetric ao descent desta font info.
  Atribua o otmscapemheight deste outlinetextmetric ao capheight desta font info.
  Atribua o otmitalicangle deste outlinetextmetric ao italicangle desta font info.
  Atribua 0 ao stemv desta font info. \ dont know where para obtenha this desde
  Atribua o otmrcfontbox deste outlinetextmetric ao font caixa desta font info.

Etapas para que se crie uma font info usando uma font e uma string:
    \ creates larguras based sobre characters em string
  Crie o font info usando a font (basic data).
  Crie as font larguras desta font info usando o font e a string.

Etapas para que se crie uns font larguras usando um font:
  Aloque memória para o font larguras.
  Atribua o font à font destas font larguras.
  Atribua 256 à contagem destas font larguras.
  Assign o data destes font larguras usando a contagem destas font larguras times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando o font.
  Assign um original abc endereço de memória usando 256 times a magnitude desse abc.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O memory canvas \ Um identificador para o contexto do dispositivo.
    e 
  0 \ O primeiro caractere do grupo de caracteres consecutivos da fonte atual.
    e 
  255 \O último caractere no grupo de caracteres consecutivos da fonte atual.
    e 
  o original abc endereço de memória. \ Um ponteiro para uma matriz de estruturas ABC que recebe as larguras dos caracteres, em unidades lógicas. 
    \Esta matriz deve conter, no mínimo, a mesma quantidade estruturas ABC que a quantidade de caracteres no intervalo especificado pelos parâmetros uFirstChar e uLastChar.
    \ Para mais informações, veja os sistes abaixo: 
    \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-abc
    \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsa
  Destrua o número da fonte of o memory canvas.
  Atribua o original abc endereço de memória a um abc endereço de memória.
  Atribua o data destes font larguras a um endereço numérico.
  Percorra. [o código abaixo]
    Se um contador estiver past 256, pare.
    Atribua o abca deste abc endereço de memória ao conteúdo deste endereço numérico .
    Adicione o abcb deste abc endereço de memória para o conteúdo deste endereço numérico .
    Adicione o abcc deste abc endereço de memória para o conteúdo deste endereço numérico .
    Adicione a magnitude deste abc para o abc endereço de memória.
    Adicione a magnitude deste número para o endereço numérico.
  Repita. [o código acima]
  Unassign o original abc endereço de memória.

Etapas para que se crie uns font larguras usando uma font e uma string:
  Aloque memória para o font larguras.
  Atribua a font à font destas font larguras.
  Atribua a quantidade de caracteres desta string à contagem destas font larguras.
  Se a string estiver em branco, cancele.
  Atribua a magnitude desse gcpresults ao lstructsize destes gcpresults.
  Atribua a quantidade de caracteres desta string ao nglyphs destes gcpresults.
  Assign o lpdx destes gcpresults usando a quantidade de caracteres desta string times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando a font.
  Call "gdi32.dll" "GetCharacterPlacementA" com 
    O memory canvas 
    e O first endereço de memória do pedaço desta string 
    e A quantidade de caracteres desta string 
    e 0 
    e O endereçamento deste gcpresults 
    e 0.
  Destrua o número da fonte of o memory canvas.
  Atribua o lpdx destes gcpresults ao data destes font larguras.

Etapas para que se crie um gpbitmap usando um trecho:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "GlobalAlloc" com 
  2 [GMEM_MOVEABLE] 
    e A quantidade de caracteres deste trecho 
    devolvendo um número identificador.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador devolvendo um endereço de memória.
  Copie pedaços desde o first endereço de memória do pedaço deste trecho para o endereço de memória pelo quantidade de caracteres deste trecho.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "ole32.dll" "CreateStreamOnHGlobal" com 
    O número identificador 
    e 1 [TRUE] 
    e O endereçamento desse istream.
  Call "gdiplus.dll" "GdipCreateBitmapFromStream" com 
    O istream 
    e O endereçamento deste gpbitmap 
    devolvendo um número.
  Se o número não for 0, atribua "Não sei como processar este tipo de imagem." ao erro do fluxo de entrada/saída; esvazie o gpbitmap.
  Call o release deste vtable deste istream com o istream.

Etapas para que se crie um gpimageattributes (grayscale):
  Call "gdiplus.dll" "GdipCreateImageAttributes" com 
    O endereçamento destes gpimageattributes.
  Call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" com 
    O gpimageattributes
   e 0 [ColorAdjustTypeDefault ] 
   e 1 
   e o first deste grayscale cor matrix 
   e 0 
   e 0 [ColorMatrixFlagsDefault].

Etapas para que se crie o hbrush of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor estiver clear, atribua o null hbrush a um hbrush.
  Se a cor não estiver clear, call "gdi32.dll" "CreateSolidBrush" com 
    O código da cor 
    devolvendo o hbrush.
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O hbrush.

Etapas para que se crie o número da fonte of um canvas usando um font:
  Converta a font para um número da fonte.
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O número da fonte.

Etapas para que se crie o hpen of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor estiver clear, atribua o null hpen a um hpen.
  Atribua o tpp times o grossura do pincel a um número.
  Se o canvas for o printer canvas, atribua 1 pixel times o grossura do pincel ao número.
  Se a cor não estiver clear, call "gdi32.dll" "CreatePen" com 
  0 [PS_SOLID] 
    e O número 
    e O código da cor 
    devolvendo o hpen.
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O hpen.

Etapas para que se crie um hrgn usando uma caixa:
  Isole a caixa.
  Adicione o tpp para o canto inferior direito desta caixa.
  Call "gdi32.dll" "BeginPath" com 
    O quadro atual.
  Call "gdi32.dll" "Rectangle" com 
    O quadro atual 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A coordenada direita desta caixa 
    e A coordenada inferior desta caixa.
  Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual devolvendo o hrgn.

Etapas para que se crie um hrgn usando um elipse:
  Atribua a caixa desta elipse a uma caixa.
  Call "gdi32.dll" "BeginPath" com 
    O quadro atual.
  Call "gdi32.dll" "Ellipse" com 
    O quadro atual 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A coordenada direita desta caixa 
    e A coordenada inferior desta caixa.
  Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual 
    devolvendo o hrgn.

Etapas para que se crie um hrgn usando um polígono:
  Se o polígono for inexistente, atribua 0 ao hrgn; exit.
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e A localização endereço de memória deste vértice array 
    e A contagem deste vértice array.
  Call "gdi32.dll" "CreatePolygonRgn" com  \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn
    A localização endereço de memória deste vértice array 
    e A contagem deste vértice array 
    e 2 [WINDING]  \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn#parameters
    devolvendo o hrgn.
  Destrua o vértice array.

Etapas para que se crie um hrgn usando uma caixa arredondada:
  Se o raio desta caixa arredondada for 0, crie o hrgn usando a caixa arredondada como uma caixa; exit.
  Atribua a caixa arredondada a uma caixa.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "BeginPath" com 
    O quadro atual.
  Call "gdi32.dll" "RoundRect" com 
    O quadro atual 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A coordenada direita desta caixa 
    e A coordenada inferior desta caixa 
    e O diameter 
    e O diameter.
  Call "gdi32.dll" "EndPath" com 
    O quadro atual.
  Call "gdi32.dll" "PathToRegion" com 
    O quadro atual 
    devolvendo o hrgn.

Etapas para que se crie um catálogo usando uma contagem de buckets:
  Aloque memória para o catálogo.
  Atribua a contagem de buckets à contagem de buckets deste catálogo.
  Atribua o magnitude desse conjunto de buckets a um largura.
  Atribua a contagem de buckets deste catálogo times o largura a um número.
  Assign o first bucket deste catálogo usando o número.
  Atribua o first bucket deste catálogo mais o número menos o largura ao last bucket deste catálogo.

Etapas para que se crie o dicionário léxico:
  Aloque memória para o dicionário léxico.
  Crie o catálogo deste dicionário léxico usando 4027.

Etapas para que se crie o abra handle of um winhttp request:
  Se o winhttp request for inexistente, cancele.
  Converta o nome deste module para um wide string denominado wide module nome e modifique através do caractere NUL.
  Call "winhttp.dll" "WinHttpOpen" com 
    O first endereço de memória do pedaço deste wide module nome 
    e 0 [WINHTTP_ACCESS_TYPE_DEFAULT_PROXY] 
    e 0 [WINHTTP_NO_PROXY_NAME] 
    e 0 [WINHTTP_NO_PROXY_BYPASS] 
    e 0 
    devolvendo o session número identificador desta request deste winhttp.
  Se a session desta request deste winhttp for 0, atribua "Erro. Não foi possível iniciar a conexão." ao erro do fluxo de entrada/saída; exit.

Etapas para que se crie um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, crie o endereço completo no sistema de arquivos (pasta)[endereço]; exit.
  Se o endereço completo for file-format, crie o endereço completo no sistema de arquivos (arquivo); exit.

Etapas para que se crie um endereço completo no sistema de arquivos (pasta)[endereço]:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateDirectoryA" com 
    O first deste endereço completo 
    e 0 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível criar a seguinte pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se crie um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com 
    O first deste endereço completo 
    e 1073741824 [GENERIC_WRITE] 
    e 0 
    e 0 
    e 1 [CREATE_NEW] 
    e 128 [FILE_ATTRIBUTE_NORMAL] 
    e 0 
    devolvendo um número identificador.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador.
  Limpe o erro do fluxo de entrada/saída.
  Se o número identificador não for -1 [INVALID_HANDLE_VALUE], cancele.
  Atribua "Erro. Não foi possível criar o seguinte arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se crie um imagem:
  Aloque memória para o imagem.

Etapas para que se crie um imagem usando um trecho:
  Crie um gpbitmap usando o trecho.
  Se o gpbitmap for inexistente, esvazie o imagem; exit.
  Aloque memória para o imagem.
  Atribua o trecho ao data desta imagem.
  Atribua o gpbitmap ao gpbitmap desta imagem.
  Ajuste o imagem (extract caixas desde gpbitmap).

Etapas para que se crie um imagem usando um gpbitmap:
  Se o gpbitmap for inexistente, esvazie o imagem; exit.
  Aloque memória para o imagem.
  Atribua o gpbitmap ao gpbitmap desta imagem.
  Ajuste o imagem (extract caixas desde gpbitmap).

Etapas para que se crie um imagem usando um URL:
  Read o URL a um trecho.
  Crie o imagem usando o trecho.

Etapas para que se crie um polígono:
  Aloque memória para o polígono.

Etapas para que se crie um quora:
  Aloque memória para o quora.

Etapas para que se crie um refer:
  Aloque memória para o refer.

Etapas para que se crie o request handle of um winhttp request using uma URL simplificada:
  Se o winhttp request for inexistente, cancele.
  Converta o endereço de recurso desta URL simplificada a um wide string denominado wide endereço completo e modifique através do caractere NUL.
  Converta "POST" para um wide string denominado wide post string e modifique através do caractere NUL.
  Se o nome do protocolo desta URL simplificada for "https", atribua 8388608 [WINHTTP_FLAG_SECURE] a um secure número.
  Call "winhttp.dll" "WinHttpOpenRequest" com 
    O connection número identificador deste winhttp request 
    e O first deste wide post string 
    e O first deste wide endereço completo 
    e 0 [L"HTTP/1.1"] 
    e 0 [WINHTTP_NO_REFERER] 
    e 0 [WINHTTP_DEFAULT_ACCEPT_TYPES] 
    e O secure número 
    devolvendo o request número identificador deste winhttp request.
  Se o request número identificador deste winhttp request for 0, atribua "Erro ao chamar a função 'WinHttpOpenRequest' da biblioteca 'winhttp.dll'. Não foi possível abrir a requisição." ao erro do fluxo de entrada/saída; exit.

Etapas para que se crie uma row usando um pedaço:
  Aloque memória para a row.
  Atribua o pedaço à string deste row.

Etapas para que se crie uma row usando uma string:
  Aloque memória para a row.
  Atribua a string à string deste row.

Etapas para que se crie um socket usando um host string e um número de porta:
    \ this guy creates e connects, sets erro do fluxo de entrada/saída if existe um problem
  Limpe o erro do fluxo de entrada/saída.
    \ obtenha sockaddr
  Obtenha um sockaddr usando o host.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua 2 [AF_INET ] ao sin_family deste sockaddr.
  Atribua o port ao sin_port deste sockaddr.
    \ crie socket 
  Call "ws2_32.dll" "socket" com 
  2 [AF_INET ] 
    e 1 [SOCK_STREAM ] 
    e 0 [IPPROTO_IP] 
    devolvendo o socket.
  Se o socket for -1, atribua "Erro. Não foi possível criar o soquete." ao erro do fluxo de entrada/saída; exit.
    \ connect socket
  Call "ws2_32.dll" "connect" com 
    O socket 
    e O endereçamento deste sockaddr 
    e A magnitude deste sockaddr 
    devolvendo um result número.
  Se o result número não for 0, atribua "Erro. Falha na conexão com o soquete." ao erro do fluxo de entrada/saída; exit.
    \ abra send timeout 30 seconds
  Call "ws2_32.dll" "setsockopt" com 
    O socket 
    e 65535 
    e 4101 [SO_SNDTIMEO]    \O tempo limite, em milissegundos, para bloquear chamadas enviadas.
    e 30 seconds' endereçamento 
    e 4 devolvendo o result número.
  Se o result número não for 0, atribua "Erro na função 'setsockopt' da biblioteca 'Ws2_32.dll'. Valor do parâmetro optname: SO_SNDTIMEO (4101)." ao erro do fluxo de entrada/saída; exit.
    \ abra receive timeout 30 seconds
  Call "ws2_32.dll" "setsockopt" com 
    O socket 
    e 65535 
    e 4102 [SO_RCVTIMEO (optname)]    \Define o tempo limite, em milissegundos, para bloquear chamadas recebidas.
    e 30 seconds' endereçamento e 
  4 
    devolvendo o result número.
  Se o result número não for 0, atribua "Erro na função 'setsockopt' da biblioteca 'Ws2_32.dll'. Não foi possível definir o tempo limite de recepção. Valor do parâmetro optname: SO_RCVTIMEO (4102) ." ao erro do fluxo de entrada/saída; exit.

Etapas para que se crie um conjunto de texto usando uma string:
  Aloque memória para o conjunto de texto.
  Atribua a string à string deste conjunto de texto.

Etapas para que se crie um terminal em uma caixa:
  Aloque memória para o terminal.
  Atribua a caixa à caixa deste terminal.
  Atribua a cor verde ao output cor deste terminal.
  Atribua a cor verde claríssimo ao input cor deste terminal.

Etapas para que se crie um text:
  Aloque memória para o text.
  Atribua a cor preta ao pincel deste text.
  Atribua a fonte padrão ao font deste text.
  Atribua "left" ao alinhamento deste text.
  Atribua 1/1 à scale deste text.
  Garanta one row no text.
  Reset o origin of o text.
  Reset o caret of o text.
  Desvencilhe-se de o text.

Etapas para que se crie um vértice:
  Aloque memória para o vértice.

Etapas para que se crie um vértice array usando uma contagem:
  Isole a contagem.
  Aloque memória para o vértice array.
  Atribua a contagem à contagem deste vértice array.
  Multiplique a contagem pela magnitude desse localização.
  Assign a localização endereço de memória deste vértice array usando a contagem.

Etapas para que se crie um vértice array usando uns vértices:
  Crie o vértice array usando a contagem destes vértices.
  Atribua a localização endereço de memória deste vértice array a uma localização endereço de memória.
  Percorra. [o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Atribua a localização deste vértice ao conteúdo desta localização endereço de memória.
    Adicione a magnitude desta localização deste vértice para a localização endereço de memória.
  Repita. [o código acima]

Etapas para que se crie um vértice usando uma localização:
  Aloque memória para o vértice.
  Atribua a localização à localização deste vértice.

Etapas para que se crie um vértice usando uma coordenada X e uma coordenada Y:
  Aloque memória para o vértice.
  Atribua a coordenada X à coordenada x deste vértice.
  Atribua a coordenada Y à coordenada y deste vértice.

Etapas para que se crie um winhttp request por posting para um URL:
  Aloque memória para o winhttp request.
  Converta o URL para uma URL simplificada.
  Crie o abra handle of o winhttp request.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
  Crie o connect handle of o winhttp request using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.
  Crie o request handle of o winhttp request using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o winhttp request; exit.

O console é um console.

O quadro atual é um canvas.

O evento atual é um event.

O número atual da cor do arco-íris é um número [esse número vai de 1 a 6 indicando, respectivamente, vermelho, laranja, amarelo, verde, azul, roxo].

Um cursor é um número identificador.

Etapas para que se corte um número pela metade:
  Divida o número por 2.

Etapas para que se darken uma cor por um quantia:
  Subtraia o quantia desde a luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se darken uma cor por uns percentual;
Etapas para que se darken uma cor about uns percentual;
Etapas para que se darken uma cor por about uns percentual;
Etapas para que se darken uma cor uns percentual:
  Atribua a luminosidade desta cor menos o percentual à luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se darken o current cor about uns percentual:
  Darken a cor deste context pelo percentual.

Um date/time é um conjunto com
  Um year número,
  Um month número,
  Um week day número,
  Um day número,
  Um hour número,
  Um minute número,
  Um second número,
  Um millisecond número.

Etapas para que se de-sign um fração:
  De-sign o numerador desta fração.
  De-sign o denominador desta fração.

Etapas para que se de-sign um número:
  Se o número for o menor número, atribua o maior número ao número; exit.
  Se o número for menor do que 0, negate o número.

Etapas para que se de-sign um par de números:
  De-sign o número X deste par de números.
  De-sign o número Y deste par de números.

Etapas para que se de-sign uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço desta string for tipo de sinal aritmético, remove o first pedaço desde a string.

Um relatório de informações é uma string.
Um relatório de bugs é uma string.
Um relatório de erros é uma string.

Etapas para que se produza o relatório de bugs usando uma caixa;
Etapas para que se produza o relatório de erros usando uma caixa;
Etapas para que se produza o relatório de informações usando uma caixa:
  Limpe uma string.
  Posponha "Coordenada esquerda = " para a string.
  Posponha a coordenada esquerda desta caixa para a string.
  Posponha ", Coordenada superior = " para a string.
  Posponha a coordenada superior desta caixa para a string.
  Posponha ", Coordenada direita = " para a string.
  Posponha a coordenada direita desta caixa para a string.
  Posponha ", Coordenada inferior = " para a string.
  Posponha a coordenada inferior desta caixa para a string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de erros usando um pedaço;
Etapas para que se produza o relatório de bugs usando um pedaço;
Etapas para que se produza o relatório de informações usando um pedaço:
  Atribua o pedaço a um número.
  Converta o número para uma string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de erros usando uma cor;
Etapas para que se produza o relatório de bugs usando uma cor;
Etapas para que se produza o relatório de informações usando uma cor:
  Limpe uma string.
  Posponha "Matiz = " para a string.
  Posponha a matiz desta cor para a string.
  Posponha ", Saturação = " para a string.
  Posponha a saturação desta cor para a string.
  Posponha ", Luminosidade = " para a string.
  Posponha a luminosidade desta cor para a string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de erros usando um detector;
Etapas para que se produza o relatório de bugs usando um detector;
Etapas para que se produza o relatório de informações usando um detector:
  Converta o detector para uma string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de bugs usando uma font:
Etapas para que se produza o relatório de erros usando uma font;
Etapas para que se produza o relatório de informações usando uma font:
  Limpe uma string.
  Posponha " Nome da fonte = '" para a string seguido de "'".
  Posponha o nome desta font para a string.
  Posponha ", Tamanho da fonte = " para a string.
  Posponha a altura desta font para a string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de erros usando uma fração;
Etapas para que se produza o relatório de bugs usando uma fração;
Etapas para que se produza o relatório de informações usando uma fração:
  Limpe uma string.
  Posponha "Numerador = " para a string.
  Posponha o numerador desta fração para a string.
  Posponha ", Denominador = " para a string.
  Posponha o denominador desta fração para a string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de bugs usando uma line;
Etapas para que se produza o relatório de erros usando uma line;
Etapas para que se produza o relatório de informações usando uma line:
  Limpe uma string.
  Posponha " Começo da linha = " para a string.
  Posponha a coordenada X deste start desta line para a string.
  Posponha "," para a string.
  Posponha a coordenada Y deste start desta line para a string.
  Posponha " Fim da linha = " para a string.
  Posponha a coordenada X deste end desta line para a string.
  Posponha "," para a string.
  Posponha a coordenada Y deste end desta line para a string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de falhas usando um número;
Etapas para que se produza o relatório de panes usando um número;
Etapas para que se produza o relatório de erros usando um número;
Etapas para que se produza o relatório de bugs usando um número;
Etapas para que se produza o relatório de informações usando um número:
  Converta o número para uma string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de erros usando um número e um segundo número;
Etapas para que se produza o relatório de falhas usando um número e um segundo número;
Etapas para que se produza o relatório de panes usando um número e um segundo número;
Etapas para que se produza o relatório de bugs usando um número e um segundo número;
Etapas para que se produza o relatório de informações usando um número e um segundo número:
  Produza o relatório de informações usando o número seguido de ", " junto com o segundo número.

Etapas para que se produza o relatório de falhas usando um par de números;
Etapas para que se produza o relatório de panes usando um par de números;
Etapas para que se produza o relatório de erros usando um par de números;
Etapas para que se produza o relatório de bugs usando um par de números;
Etapas para que se produza o relatório de informações usando um par de números:
  Limpe uma string.
  Posponha "Coordenada X = " para a string.
  Posponha o número X deste par de números para a string.
  Posponha ", Coordenada Y = " para a string.
  Posponha o número Y deste par de números para a string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de panes usando um endereço de memória;
Etapas para que se produza o relatório de falhas usando um endereço de memória;
Etapas para que se produza o relatório de erros usando um endereço de memória;
Etapas para que se produza o relatório de bugs usando um endereço de memória;
Etapas para que se produza o relatório de informações usando um endereço de memória:
  Converta o endereço de memória para um cifra hexadecimal.
  Produza o relatório de informações usando "$" junto com o cifra hexadecimal.
  Produza o relatório de informações usando "0x" junto com o cifra hexadecimal.

Etapas para que se produza o relatório de panes usando um espaço de cor RGB;
Etapas para que se produza o relatório de falhas usando um espaço de cor RGB;
Etapas para que se produza o relatório de erros usando um espaço de cor RGB;
Etapas para que se produza o relatório de bugs usando um espaço de cor RGB;
Etapas para que se produza o relatório de informações usando um espaço de cor RGB:
  Limpe uma string.
  Posponha "Vermelho = " para a string. Atribua o espectro vermelho deste espaço de cor RGB a um número.
  Posponha o número para a string.
  Posponha ", Verde = " para a string. Atribua o espectro verde deste espaço de cor RGB ao número.
  Posponha o número para a string.
  Posponha ", Azul = " para a string. Atribua o espectro azul deste espaço de cor RGB ao número.
  Posponha o número para a string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de falhas usando uma string;
Etapas para que se produza o relatório de panes usando uma string;
Etapas para que se produza o relatório de erros usando uma string;
Etapas para que se produza o relatório de bugs usando uma string;
Etapas para que se produza o relatório de informações usando uma string:
  Isole a string.
  Modifique através do caractere NUL a string.
  Call "user32.dll" "MessageBoxA" com 
  0 
    e O first endereço de memória do pedaço desta string 
    e "debug"'s first endereço de memória do pedaço 
    e 0. 
    \\  Chame função "MessageBoxA" contida na biblioteca "user32.dll" informando os parâmetros a seguir: 0, o primeiro caractere do texto em questão, o primeiro caractere do "debug" e 0.

Etapas para que se produza o relatório de erros usando uma string (quoted);
Etapas para que se produza o relatório de bugs usando uma string (quoted);
Etapas para que se produza o relatório de informações usando uma string (quoted):
  Isole a string.
  Anteponha as aspas duplas para a string.
  Posponha as aspas duplas para a string.
  Produza o relatório de informações usando a string.

Etapas para que se produza o relatório de erros usando um word;
Etapas para que se produza o relatório de bugs usando um word;
Etapas para que se produza o relatório de informações usando um word:
  Atribua o word a um número.
  Converta o número para uma string.
  Produza o relatório de informações usando a string.

Etapas para que se determine se uma caixa é uma segunda caixa:
  Se a coordenada esquerda desta caixa não for a coordenada esquerda desta segunda caixa, diga não.
  Se a coordenada superior desta caixa não for a coordenada superior desta segunda caixa, diga não.
  Se a coordenada direita desta caixa não for a coordenada direita desta segunda caixa, diga não.
  Se a coordenada inferior desta caixa não for a coordenada inferior desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa está still em uma segunda caixa;
Etapas para que se determine se uma caixa está em uma segunda caixa;
Etapas para que se determine se uma caixa está inside uma segunda caixa:
  Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda desta segunda caixa, diga não.
  Se a coordenada superior desta caixa for menor do que a coordenada superior desta segunda caixa, diga não.
  Se a coordenada direita desta caixa for maior do que a coordenada direita desta segunda caixa, diga não.
  Se a coordenada inferior desta caixa for maior do que a coordenada inferior desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa está touching uma segunda caixa:
  Se a coordenada direita desta segunda caixa for menor do que a coordenada esquerda desta caixa, diga não.
  Se a coordenada inferior desta segunda caixa for menor do que a coordenada superior desta caixa, diga não.
  Se a coordenada esquerda desta segunda caixa for maior do que a coordenada direita desta caixa, diga não.
  Se a coordenada superior desta segunda caixa for maior do que a coordenada inferior desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é alfanumérico:
  Se o pedaço for algum tipo de letra, diga sim.
  Se o pedaço for algum tipo de digit, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é um segundo pedaço ou um terceiro pedaço:
  Se o pedaço for o segundo pedaço, diga sim.
  Se o pedaço for o terceiro pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é alguma consoante:
  Se o pedaço estiver em "bcdfghjklmnpqrstvwxyzçñ", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de digit:
  Se o pedaço for menor do que o número zero, diga não.
  Se o pedaço for maior do que o número nove, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é algum tipo de letra:
  Se o pedaço estiver entre o 'A' maiúsculo e o Z maiúsculo, diga sim.
  Se o pedaço estiver entre o 'a' minúsculo e o z minúsculo, diga sim.
  Se o pedaço for 131 ou 138, diga sim.
  Se o pedaço for 140 ou 142, diga sim.
  Se o pedaço for 154 ou 156, diga sim.
  Se o pedaço estiver entre 158 e 159, diga sim.
  Se o pedaço estiver entre 192 e 214, diga sim.
  Se o pedaço estiver entre 216 e 246, diga sim.
  Se o pedaço estiver entre 248 e 255, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de indicador numérico:
  Se o pedaço é algum tipo de digit, diga sim.
  Se o pedaço é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de sinal de pontuação:
    \ precisa ser aprimorado
  Se o pedaço for o caractere de espaço, diga não.
  Se o pedaço não for alfanumérico, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é tipo de sinal aritmético:
  Se o pedaço for o sinal de adição, diga sim.
  Se o pedaço for o sinal de subtração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de unidade de disco válida:
  Atribua o pedaço a um endereço completo.
  Posponha ":\" para o endereço completo.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Se a categoria da unidade de disco for "", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é algum tipo de vogal:
  Se o pedaço estiver em "aeiouyáéíóúýãõäëïöüÿâêîôûàèìòù", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço está entre um segundo pedaço e um terceiro pedaço:
  Se o pedaço for menor do que o segundo pedaço, diga não.
  Se o pedaço for maior do que o terceiro pedaço, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço está entre um número e um segundo número:
  Se o pedaço for menor do que o número, diga não.
  Se o pedaço for maior do que o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço estiver em uma string:
  Isole o pedaço.
  Lowercase o pedaço.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga não.
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um segundo pedaço.
    Lowercase o segundo pedaço.
    Se o segundo pedaço for o pedaço, diga sim.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se um pedaço é like um segundo pedaço:
    \ used internally por palavra wrap
  Se o pedaço for whitespace, acione um detector.
  Se o segundo pedaço for whitespace, acione uma segundo detector.
  Se o detector for a segundo detector, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é irrelevante:
  Se o pedaço for menor do que ou igual ao caractere de espaço, diga sim.
  Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga sim.
  Se o pedaço for o espaço rígido, diga sim.
  Se o pedaço for 129, diga sim.
  Se o pedaço for 141, diga sim.
  Se o pedaço for 143, diga sim.
  Se o pedaço for 144, diga sim.
  Se o pedaço for 157, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é um número ou um segundo número:
  Se o pedaço for o número, diga sim.
  Se o pedaço for o segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é printable:
  Se o pedaço for menor do que o caractere de espaço, diga não.
  Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga não.
  Se o pedaço for 129, diga não.
  Se o pedaço for 141, diga não.
  Se o pedaço for 143, diga não.
  Se o pedaço for 144, diga não.
  Se o pedaço for 157, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é uma string:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Isole o pedaço.
  Lowercase o pedaço.
  Atribua o conteúdo deste first endereço de memória do pedaço desta string a um segundo pedaço.
  Lowercase o segundo pedaço.
  Se o pedaço for o segundo pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é symbolic:
  Se o pedaço estiver entre o ponto de exclamação e o slash pedaço, diga sim.
  Se o pedaço estiver entre o sinal de dois pontos e o sinal de arroba, diga sim.
  Se o pedaço estiver entre o colchete esquerdo e o acento grave, diga sim.
  Se o pedaço estiver entre o chave esquerda e o acento til, diga sim.
  Se o pedaço for 128, diga sim.
  Se o pedaço for 130, diga sim.
  Se o pedaço estiver entre 132 e 137, diga sim.
  Se o pedaço for 139, diga sim.
  Se o pedaço estiver entre 145 e 153, diga sim.
  Se o pedaço for 155, diga sim.
  Se o pedaço estiver entre 161 e 180, diga sim.
  Se o pedaço estiver entre 183 e 191, diga sim.
  Se o pedaço for 215, diga sim.
  Se o pedaço for 247, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é whitespace:
  Se o pedaço for o caractere de espaço, diga sim.
  Se o pedaço for o tabulação horizontal, diga sim.
  Se o pedaço for o return pedaço, diga sim.
  Se o pedaço for o linefeed pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o caret of um text é at o beginning:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for 1, diga não.
  Se o caret column# deste text não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o caret of um text é at o end:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for a contagem destas rows deste text, diga não.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text não for a quantidade de caracteres desta string desta row, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o caret of um text está sobre o first line:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o caret of um text está sobre o last line:
  Se o text for inexistente, diga não.
  Se as rows deste text estiverem vazio, diga não.
  Se o número de linhas do cursor deste text não for o número da linha desta last row deste text, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma choice é uma string:
  Se a choice for inexistente, diga não.
  Se o nome desta choice for a string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor e uma segunda cor estão clear:
  Se a cor não for clear, diga não.
  Se a segunda cor não for clear, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma cor é uma segunda cor:
  Se a matiz desta cor não for a matiz desta segunda cor, diga não.
  Se a saturação desta cor não for a saturação desta segunda cor, diga não.
  Se a luminosidade desta cor não for a luminosidade desta segunda cor, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma cor está clear:
  Se a matiz desta cor for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é escura:
  Se a luminosidade desta cor estiver entre 250 e 374, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é clara:
  Se a luminosidade desta cor estiver entre 625 e 749, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é normal:
  Se a luminosidade desta cor estiver entre 375 e 624, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muito escura:
  Se a luminosidade desta cor estiver entre 125 e 249, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muito clara:
  Se a luminosidade desta cor estiver entre 750 e 874, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muitíssimo escura:
  Se a luminosidade desta cor for menor do que ou igual para 124, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muitíssimo clara:
  Se a luminosidade desta cor for maior do que ou igual para 875, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um contador é past um número:
  Adicione 1 para o contador.
  Se o contador for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o current localização está above ou below uma caixa:
  Se a localização deste context é above ou below a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o current localização está left ou right of uma caixa:
  Se a localização deste context é left ou right of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o current localização está para o right of uma caixa:
  Se a coordenada X desta localização deste context for maior do que a coordenada direita desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o current localização está within uns twips of uma caixa:
  Se a localização deste context estiver within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um difference está within um malha:
  Isole a difference.
  De-sign a difference.
  Se o número X desta difference for maior do que ou igual ao número X desta malha, diga não.
  Se o número Y desta difference for maior do que ou igual ao número Y desta malha, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um event é algum tipo de atalho de tecla:
  Se o event for inexistente, diga não.
  Se a categoria deste event não for "pressionamento de tecla", diga não.
  Se o event não foi alterado, diga não.
  Se a tecla deste event estiver entre a tecla A/a e a tecla Z/z, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um event foi alterado:
  Se o detector de tecla ctrl deste event estiver ativo, diga sim.
  Se o detector de tecla alt deste event estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um finger é past o end of uma string:
  Se o finger for inexistente, diga sim.
  Se o finger for maior do que o last endereço de memória do pedaço desta string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

    \Etapas para que se determine se um detector está on:
    \ switch como uma segunda nome por detector also ? ***
    \Se o detector estiver ativo, diga sim.
    \[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um detector está presente;
Etapas para que se determine se um detector está em vigor;
Etapas para que se determine se um detector está levantada;
Etapas para que se determine se um detector está ligado; \foi ligado também funciona
Etapas para que se determine se um detector está ativo;
Etapas para que se determine se um detector está ativado; \foi ativado
    \Etapas para que se determine se um detector já está ativado;
Etapas para que se determine se um detector já foi ativado anteriomente;
    \Etapas para que se determine se um detector foi ativado anteriomente;
Etapas para que se determine se um detector está tocando;
Etapas para que se determine se um detector está soando;
Etapas para que se determine se um detector soou;
    \Etapas para que se determine se um detector já soou;
Etapas para que se determine se um detector está disparando;
    \Etapas para que se determine se um detector disparou;
Etapas para que se determine se um detector está alarmando;
    \Etapas para que se determine se um detector disparou;
Etapas para que se determine se um detector está sendo mostrada;
Etapas para que se determine se um detector está sendo exibida;
Etapas para que se determine se um detector está verde:
  Se o detector for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um detector está dormente;
Etapas para que se determine se um detector está suspenso;
Etapas para que se determine se um detector está inativo;
Etapas para que se determine se um detector está desligado;
Etapas para que se determine se um detector está desativado;
Etapas para que se determine se um detector está vermelho:
  Se o detector for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração é o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é maior que uma segunda fração;
Etapas para que se determine se uma fração é maior do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é maior do que ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é menor que uma segunda fração;
Etapas para que se determine se uma fração é menor do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração for menor do que ou igual para uma segunda fração;
Etapas para que se determine se uma fração for menor que ou igual para uma segunda fração;
Etapas para que se determine se uma fração for menor ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é negative:
  Se o numerador desta fração for menor do que 0, reverse um detector.
  Se o denominador desta fração for menor do que 0, reverse o detector.
    \ Say o detector. \ does not work em SAL; no detector literals anymore
  Se o detector estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é um número:
  Se a fração é o número / 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um catálogo está vazia;
Etapas para que se determine se um catálogo estão vazias;
Etapas para que se determine se um catálogo estão vazios;
Etapas para que se determine se um catálogo está vazio:
  Se o catálogo for inexistente, diga sim.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, diga sim.
    Se os refers deste bucket não estiverem vazio, diga não.
  Repita. [o código acima]

Etapas para que se determine se um input é um clique:
  Esvazie o clique.
  Se a categoria deste input não for "clique", diga não.
  Atribua o input ao clique.

Etapas para que se determine se um item é found:
  Se a categoria deste item não estiver em branco, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de digit tecla:
  Se a tecla estiver entre 48 e 57, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de letra tecla:
  Se a tecla estiver entre 65 e 90, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de modifier tecla:
  Se a tecla for a tecla Alt, diga sim.
  Se a tecla for a tecla Ctrl, diga sim.
  Se a tecla for a tecla Shift ,say yes.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de pad tecla:
  Se a tecla estiver entre 96 e 111, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de printable tecla:
  Se a tecla for o barra de espaço, diga sim.
  Se a tecla for algum tipo de digit tecla, diga sim.
  Se a tecla for algum tipo de letra tecla, diga sim.
  Se a tecla for algum tipo de pad tecla, diga sim.
  Se a tecla for algum tipo de symbol tecla, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de symbol tecla:
  Se a tecla estiver entre 186 e 192, diga sim.
  Se a tecla estiver entre 219 e 222, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de wm-char tecla:
  Se a tecla não for algum tipo de printable tecla , diga não.
  Se a tecla Alt was para baixo, diga não.
  Se a tecla Ctrl was para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma tecla está sendo pressionada:
  Call "user32.dll" "GetAsyncKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla está sendo pressionado:
  Call "user32.dll" "GetAsyncKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla was para baixo:
  Call "user32.dll" "GetKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla was toggled:
  Call "user32.dll" "GetKeyState" com 
    A tecla 
    devolvendo um word.
  Atribua o word a um número.
  Conjuncione logicamente o número com 1.
  Se o número for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla was para cima:
  Se a tecla was para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma tecla com um l-param é algum tipo de comando de repetiçãoed escape ou modifier tecla:
  Atribua o l-param a um número.
  Conjuncione logicamente o número com 1073741824 [$40000000].
  Se o número for 0, diga não.
  Se a tecla for a tecla Esc, diga sim.
  Se a tecla for algum tipo de modifier tecla, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o left mouse botão está para baixo:
  Se o botão esquerdo deste mouse estiver sendo pressionado, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um line está above uma caixa:
  Se o y deste start desta line for maior do que ou igual à coordenada superior desta caixa, diga não.
  Se o y deste end desta line for maior do que ou igual à coordenada superior desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um line está above uma coordenada:
  Se o y deste start desta line for maior do que ou igual à coordenada, diga não.
  Se o y deste end desta line for maior do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um line está below uma caixa:
  Se o y deste start desta line for menor do que ou igual à coordenada inferior desta caixa, diga não.
  Se o y deste end desta line for menor do que ou igual à coordenada inferior desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um line está below uma coordenada:
  Se o y deste start desta line for menor do que ou igual à coordenada, diga não.
  Se o y deste end desta line for menor do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um line está still em uma caixa;
Etapas para que se determine se um line estiver em uma caixa:
  Se o start desta line não estiver na caixa, diga não.
  Se o end desta line não estiver na caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um mixed é um número:
  Converta o mixed para um fração.
  Se a fração for o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o mouse has been dragged desde uma localização usando um malha:
  Se o botão esquerdo deste mouse não estiver sendo pressionado, diga não.
  Atribua a localização deste mouse a uma segunda localização.
  Obtenha um difference entre a segunda localização e a localização.
  Se a difference estiver within a malha, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o mouse estiver em uma caixa:
  Se a localização deste mouse estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é um segundo número e uma string é uma segunda string:
  Se o número não for o segundo número, diga não.
  Se a string não for a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número está entre um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, diga não.
  Se o número for maior do que o terceiro número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é par:
  Se o número é ímpar, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é uniformemente divisível por um segundo número:
  Isole o número.
  Divida o número pelo segundo número usando um quociente e um resto.
  Se o resto for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é um múltiplo of um segundo número:
  Se o número for uniformemente divisível pelo segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é negative:
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é ímpar:
  Isole o número.
  Conjuncione logicamente o número com 1.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é positive:
  Se o número for menor do que 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é prime:
  Se o número for menor do que 2, diga não.
  Se o número for 2, diga sim.
  Atribua o número menos 1 a um segundo número.
  Percorra. [o código abaixo]
    Se o número é uniformemente divisível pelo segundo número, diga não.
    Subtraia 1 desde o segundo número.
    Se o segundo número for maior do que 1, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é uma segundo par de números:
  Se o número X deste par de números não for o número X desta segundo par de números, diga não.
  Se o número Y deste par de números não for o número Y desta segundo par de números, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um número e um segundo número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo é endereço da pasta-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste last deste endereço completo for a barra invertida, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo é drive-format:
  Se o endereço completo começa com "\\", diga sim.
  Se a quantidade de caracteres deste endereço completo não for 3, diga não.
  Se o endereço completo termina com ":\", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo está vazia no sistema de arquivos;
Etapas para que se determine se um endereço completo estão vazias no sistema de arquivos;
Etapas para que se determine se um endereço completo estão vazios no sistema de arquivos;
Etapas para que se determine se um endereço completo está vazio no sistema de arquivos:
  Se o endereço completo não estiver no sistema de arquivos, diga sim.
  Obtenha uma contagem of items no endereço completo no sistema de arquivos.
  Se a contagem for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo é file-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste last deste endereço completo for o sinal de dois pontos, diga não.
  Se o conteúdo deste last deste endereço completo for a barra invertida, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo está no sistema de arquivos:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Se o número for menor do que 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo é read-only:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Conjuncione logicamente o número com 1 [FILE_ATTRIBUTE_READONLY].
  Se o número não for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço de memória pode ser found;
Etapas para que se determine se um endereço de memória está coming;
    \Etapas para que se determine se um endereço de memória é found;
Etapas para que se determine se um endereço de memória foi found;
Etapas para que se determine se um endereço de memória existe;
Etapas para que se determine se um endereço de memória does exist:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.





Etapas para que se determine se um endereço de memória é missing;
Etapas para que se determine se um endereço de memória é null e esvazie:
  Se o endereço de memória for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um polígono está closed:
  Se o polígono for inexistente, diga não.
  Se a contagem destes vértices deste polígono for menor do que 3, diga não.
  Se a localização deste first vértice deste polígono for a localização deste last vértice deste polígono, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um reply é something like uma segunda reply:
  Isole o reply.
  Isole a segunda reply.
  Simplify o reply.
  Simplify a segunda reply.
  Se o reply é a segunda reply, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma row está em branco:
  Se a row for inexistente, diga sim.
  Lance um subtexto sobre a string deste row.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se uma row of um text está selecionado:
  Se o text for inexistente, diga não.
  Se a row for inexistente, diga não.
  Se nada estiver selecionado no text, diga não.
  Atribua a normalized seleção deste text a uma seleção.
  Se o número da linha desta row for menor do que o anchor número da linha desta seleção, diga não.
  Se o número da linha desta row for maior do que o número de linhas do cursor desta seleção, diga não.
  Se o número da linha desta row não for o número de linhas do cursor desta seleção, diga sim.
  Se o caret column# desta seleção for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma row of um text é visível:
  Se o text for inexistente, diga não.
  Se a row for inexistente, diga não.
  Obtenha uma caixa usando a row e o text.
  Atribua a caixa deste text a uma segunda caixa.
  Ajuste a segunda caixa usando 0 e o tpp e 0 e - o tpp.
  Se a caixa estiver touching a segunda caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma seleção é uma segunda seleção:
  Se o anchor desta seleção não for o anchor desta segunda seleção, diga não.
  Se o caret desta seleção não for o caret desta segunda seleção, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se something está selecionado em um text:
  Se o anchor deste text for o caret deste text, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é above uma caixa:
  Se a coordenada Y desta localização for menor do que a coordenada superior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é above um horizontal line:
  Se a coordenada Y desta localização for menor do que o horizontal y deste start desta line, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é above ou below uma caixa:
  Se a localização é above a caixa, diga sim.
  Se a localização é below a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é below uma caixa:
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é below um horizontal line:
  Se a coordenada Y desta localização for maior do que o horizontal y deste start desta line, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está em um elipse:
  Crie um hrgn usando a elipse.
  Isole a localização.
  Divida a localização pelo tpp.
  Call "gdi32.dll" "PtInRegion" com 
    O hrgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Destrua o hrgn.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em um imagem:
  Se o imagem for inexistente, diga não.
  Se a localização estiver na caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está em um polígono:
  Se o polígono for inexistente, diga não.
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "CreatePolygonRgn" com 
    A localização endereço de memória deste vértice array 
    e A contagem deste vértice array 
    e 2 [WINDING] devolvendo um hrgn.
  Call "gdi32.dll" "PtInRegion" com 
    O hrgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Call "gdi32.dll" "DeleteObject" com 
    O hrgn.
  Destrua o vértice array.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em uns polígonos:
  Obtenha um polígono desde o polígonos.
  Se o polígono for inexistente, diga não.
  Se a localização estiver no polígono, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma localização está em uma caixa arredondada:
  Isole a caixa arredondada.
  Adicione o tpp para a canto inferior direito desta caixa arredondada.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "CreateRoundRectRgn" com 
    A coordenada esquerda desta caixa arredondada 
    e A coordenada superior desta caixa arredondada 
    e A coordenada direita desta caixa arredondada 
    e A coordenada inferior desta caixa arredondada 
    e O diameter 
    e O diameter 
    devolvendo um hrgn.
  Call "gdi32.dll" "PtInRegion" com 
    O hrgn 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um número.
  Call "gdi32.dll" "DeleteObject" com 
    O hrgn.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em um text:
  Se o text for inexistente, diga não.
  Se a localização estiver na caixa deste text, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está inside uma caixa;
Etapas para que se determine se uma localização está within uma caixa;
Etapas para que se determine se uma localização está em uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada esquerda desta caixa, diga não.
  Se a coordenada Y desta localização for menor do que a coordenada superior desta caixa, diga não.
  Se a coordenada X desta localização for maior do que a coordenada direita desta caixa, diga não.
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está para o left of uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada esquerda desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está left ou right of uma caixa:
  Se a localização é para o left of a caixa, diga sim.
  Se a localização é para o right of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está sobre uma caixa:
  Atribua a caixa a uma segunda caixa.
  Atribua 2 times o tpp a um número.
  Outdent a segunda caixa usando o número.
  Se a localização não estiver no segunda caixa, diga não.
  Atribua a caixa a um terceiro caixa.
  Atribua 3 times o tpp a um segundo número.
  Indent o terceiro caixa usando o segundo número.
  Se a localização estiver no terceiro caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está sobre uma elipse:
  Atribua a elipse a uma segunda elipse.
  Atribua 2 times o tpp a um número.
  Outdent a caixa desta segunda elipse usando o número.
  Se a localização não estiver na segunda elipse, diga não.
  Atribua a elipse a uma terceiro elipse.
  Atribua 3 times o tpp a um segundo número.
  Indent a caixa desta terceiro elipse usando o segundo número.
  Se a localização estiver na terceiro elipse, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está sobre uma line:
  Isole a line.
  Atribua 3 times o tpp a um número.
  Percorra. [o código abaixo]
    Obtenha uma distance entre a localização e o center desta line (chessboard).
    Se a distance for menor do que ou igual ao número, diga sim.
    Obtenha a distance entre a start desta line e o end desta line (chessboard).
    Se a distance for menor do que ou igual ao tpp, diga não.
    Split a line à line e uma segunda line.
    Obtenha a distance entre a localização e o center desta line (chessboard).
    Obtenha uma segunda distance entre a localização e o center desta segunda line (chessboard).
    Se a distance for maior do que a segunda distance, atribua a segunda line ao line.
  Repita. [o código acima]

Etapas para que se determine se uma localização está sobre um imagem:
  Se o imagem for inexistente, diga não.
  Se a localização estiver sobre a caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está sobre um polígono:
  Se o polígono for inexistente, diga não.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, diga não.
    Se o next deste vértice for inexistente, diga não.
    Atribua a localização deste vértice e a localização deste next deste vértice a um line.
    Se a localização estiver sobre o line, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma localização está sobre uma caixa arredondada:
  Atribua a caixa arredondada a uma segunda caixa arredondada.
  Atribua 2 times o tpp a um número.
  Outdent a segunda caixa arredondada usando o número.
  Se a localização não estiver no segunda caixa arredondada, diga não.
  Atribua a caixa arredondada a um terceiro caixa arredondada.
  Atribua 3 times o tpp a um segundo número.
  Indent o terceiro caixa arredondada usando o segundo número.
  Se a localização estiver no terceiro caixa arredondada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é outside uma caixa:
  Se a localização é inside a caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é para o right of uma caixa:
  Se a coordenada X desta localização for maior do que a coordenada direita desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é touching uma caixa:
  Se a localização estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within um malha of uma segunda localização:
  Obtenha um difference entre a segunda localização e a localização.
  Se a difference está within a malha, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uns twips of uma segunda localização:
  Atribua os twips e os twips a um malha.
  Se a localização estiver within a malha of a segunda localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uns twips of uma caixa:
  Isole a caixa.
  Outdent a caixa usando os twips.
  Se a localização estiver within a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o stack has just one coisa sobre it:
  Se a contagem deste stack for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

    \Etapas para que se determine se uma string does end com uma segunda string;
Etapas para que se determine se uma string termina com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o last endereço de memória do pedaço deste subtexto menos a quantidade de caracteres desta segunda string mais 1 ao first endereço de memória do pedaço deste subtexto.
  Se o subtexto for a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does start com uma segunda string;
Etapas para que se determine se uma string começa com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Se o subtexto é a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does start com um pedaço;
Etapas para que se determine se uma string começa com um pedaço:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string for o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does end com um pedaço; \ adicionado por Mike Gonta
Etapas para que se determine se uma string termina com um pedaço:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste last endereço de memória do pedaço desta string for o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é uma segunda string (accent-free compare):
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos s/ acento ascii (equal only).

Etapas para que se determine se uma string é uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos ascii (equal only).

Etapas para que se determine se uma string é uma segunda string ou um terceiro string:
  Se a string é a segunda string, diga sim.
  Se a string é o terceiro string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de fração literal;
Etapas para que se determine se uma string é algum tipo de ratio literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Split o subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
  Se o numerador subtexto não for algum tipo de integer literal, diga não.
  Se o denominador subtexto não for algum tipo de integer literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

    \Etapas para que se determine se uma string é algum tipo de inteiro:
    \ parece ser uma duplicata da rotina abaixo
    \Lance um subtexto sobre a string.
    \Se o subtexto estiver em branco, diga não.
    \Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
    \Se o subtexto estiver em branco, diga não.
    \Percorra. [o código abaixo]
      \Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de digit, diga não.
      \Adicione 1 para o first endereço de memória do pedaço deste subtexto.
      \Se o subtexto estiver em branco, diga sim.
    \Repita. [o código acima]

Etapas para que se determine se uma string é algum tipo de integer;
Etapas para que se determine se uma string é algum tipo de integer literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Percorra. [o código abaixo]
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de digit, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma string é algum tipo de mixed literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for tipo de sinal aritmético, adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Split o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto não for algum tipo de integer literal, diga não.
  Se a fração subtexto não for algum tipo de fração literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum tipo de numeric literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string não for algum tipo de indicador numérico, diga não.
  Se a string é algum tipo de integer literal, diga sim.
  Se a string é algum tipo de fração literal, diga sim.
  Se a string é algum tipo de mixed literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é tipo de sinal aritmético:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de palavra:
  Se a quantidade de caracteres desta string for menor do que 2, diga não.
  Lance um subtexto sobre a string.
  Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for algum tipo de letra, repita.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o single-quote pedaço, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.



Etapas para que se determine se uma string é um pedaço:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é dos-compatible:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste first endereço de memória do pedaço desta string é o ponto final, diga não.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o slash pedaço, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de dois pontos, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o asterisco, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o ponto de interrogação, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for as aspas duplas, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o símbolo menor do que, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o símbolo maior do que, diga não.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o barra vertical, diga não.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se uma string é maior que uma segunda string;
Etapas para que se determine se uma string é maior do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é maior do que ou igual para uma segunda string;
Etapas para que se determine se uma string é maior que ou igual para uma segunda string;
Etapas para que se determine se uma string é maior ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string estiver em uma segunda string:
  Lance um subtexto sobre a segunda string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta segunda string, diga não.
    Se o subtexto é a string, diga sim.
    Mova o subtexto usando 1.
  Repita. [o código acima]

Etapas para que se determine se uma string estiver em um catálogo:
  Se o catálogo for inexistente, diga não.
  Se a string estiver em branco, diga não.
  Encontre um refer usando a string e o catálogo.
  Se o refer for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é menor que uma segunda string;
Etapas para que se determine se uma string é menor do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é menor do que ou igual para uma segunda string;
Etapas para que se determine se uma string é menor que ou igual para uma segunda string;
Etapas para que se determine se uma string é menor ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

     \ needs work por Spanish
Etapas para que se determine se uma string está escrito incorretamente:
  Se o dicionário léxico for inexistente, diga não.
  Se a string não for algum tipo de palavra, diga não.
  Isole a string.
  Se a string termina com "'s", remove os last dois pedaços desde a string.
  Se a string estiver no catálogo deste dicionário léxico, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é wider do que uma caixa:
    \ assumes font estiver selecionado sobre memory canvas
  Obtenha um abca e um abcc usando a string e o memory canvas.
  Obtenha um largura usando a string e o memory canvas.
  Subtraia o abca desde o largura.
  Subtraia o abcc desde o largura.
  Se o largura for maior do que a largura desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um subtexto está sobre alguma espécie de contração:
  Atribua o first endereço de memória do pedaço deste subtexto mais 1 a um endereço de memória do pedaço .
  Se o endereço de memória do pedaço for maior do que o last endereço de memória do pedaço deste subtexto, diga não.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o single-quote pedaço, diga não.
  Se o conteúdo deste endereço de memória do pedaço não for algum tipo de letra, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um terminal está full:
  Atribua a altura deste terminal dividido por 24 pixels a um número.
  Se a contagem destes quoras deste terminal for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um text pode ser refeito:
  Se o text for inexistente, diga não.
  Se o last destes redos deste text for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um text pode ser desfeito:
  Se o text for inexistente, diga não.
  Se o last destes undos deste text for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um text foi alterado:
  Se o text for inexistente, diga não.
  Se o detector de alteração deste text estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe something para backspace em um text:
  Se o text for inexistente, diga não.
  Se something estiver selecionado no text, diga sim.
  Se o número de linhas do cursor deste text não for 1, diga sim.
  Se o caret column# deste text não for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe something para remove em um text:
  Se o text for inexistente, diga não.
  Se something estiver selecionado no text, diga sim.
  Se o número de linhas do cursor deste text não for a contagem de linhas deste text, diga sim.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text não for a quantidade de caracteres desta string desta row, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe text sobre o área de transferência do Windows:
  Call "user32.dll" "IsClipboardFormatAvailable" com 
  1 [CF_TEXT] 
    devolvendo um número.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uns coisas estão vazio:
  Se o first destas coisas for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um segmento inicial é numeric:
  Isole o segmento inicial.
  Remove algum tipo de leading noise desde o segmento inicial.
  Se o segmento inicial estiver em branco, diga não.
  Percorra. [o código abaixo]
    Obtenha um pedaço desde o segmento inicial.
    Se o pedaço não for algum tipo de digit, diga não.
    Se o segmento inicial estiver em branco, diga sim.
  Repita. [o código acima]

Etapas para que se determine se o usuário está clicking em umas choices;
Etapas para que se determine se o usuário has clicked em umas choices;
Etapas para que se determine se o usuário clicked em umas choices;
Etapas para que se determine se o usuário clicks em umas choices;
Etapas para que se determine se o usuário está clicking sobre umas choices;
Etapas para que se determine se o usuário has clicked sobre umas choices;
Etapas para que se determine se o usuário clicked sobre umas choices;
Etapas para que se determine se o usuário clicks sobre umas choices:
Etapas para que se determine se o usuário clickou sobre umas choices:
Etapas para que se determine se o usuário clicou sobre umas choices:
Etapas para que se determine se o usuário clickou em umas choices:
Etapas para que se determine se o usuário clicou em umas choices:
  Percorra. [o código abaixo]
  Se o botão esquerdo deste mouse não estiver para baixo, diga não.
  Encontre uma choice usando a localização deste mouse.
  Se a choice can't ser found, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

  

Etapas para que se determine se we pode encontre um endereço de memória:
    \ deveria ser "can" not "ca", compilador bug
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we could encontre um endereço de memória:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we did encontre um endereço de memória:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we're above uma caixa:
  Se a coordenada Y deste context for menor do que a coordenada superior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're above uma coordenada:
  Se a coordenada Y deste context for menor do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're above um horizontal line:
  Se a localização deste context é above o horizontal line, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're above ou below uma caixa:
  Se a coordenada Y deste context for menor do que a coordenada superior desta caixa, diga sim.
  Se a coordenada Y deste context for maior do que a coordenada inferior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're above uma localização:
  Se a coordenada Y deste context for menor do que o y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're below uma caixa:
  Se a coordenada Y deste context for maior do que a coordenada inferior desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're below uma coordenada:
  Se a coordenada Y deste context for maior do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're below um horizontal line:
  Se a localização deste context é below o horizontal line, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're below uma localização:
  Se a coordenada Y deste context for maior do que o y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're facing north:
    \ *** need east, south, west
  Normalize a orientação deste context.
  Se a orientação deste context for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're left of uma caixa:
  Se a coordenada X deste context for menor do que a coordenada esquerda desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're left ou right of uma caixa:
  Se a coordenada X deste context for menor do que a coordenada esquerda desta caixa, diga sim.
  Se a coordenada X deste context for maior do que a coordenada direita desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're outside uma caixa:
  Se a localização deste context é outside a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're right of uma caixa:
  Se a coordenada X deste context for maior do que a coordenada direita desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're still em uma caixa;
Etapas para que se determine se we're em uma caixa:
  Se a localização deste context estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're within uns twips of uma caixa:
  Se a localização deste context está within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se you feel like it:
  Escolha aleatoriamente um número entre 1 e 100.
  Se o número for menor do que 51, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se decrypt um trecho usando um passphrase string:
    \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie um crypt session usando o passphrase.
  Se o crypt session for inexistente, cancele.
  Converta o trecho como um cifra hexadecimal para um texto hexadecimal.
  Atribua a quantidade de caracteres deste texto hexadecimal a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptDecrypt" com 
    A hcryptkey desta crypt session 
    e 0 
    e 1 
    e 0 
    e O first deste texto hexadecimal 
    e O endereçamento deste quantidade de caracteres 
    devolvendo um result número.
  Se o result número for 0, atribua "Ocorreu um erro na hora de tentar decifrar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
  Destrua o crypt session.
  Atribua o texto hexadecimal ao trecho.

O fonte padrão é uma font.

O default smtp server é "localhost".

Um degree é um número [cujos valores variam entre 0 até 359].

Um depth é uns twips.

Um description é uma string.

Etapas para que se desvencilhe-se de um text:
  Se o text for inexistente, cancele.
  Atribua o caret deste text ao anchor deste text.

Etapas para que se destrua um crypt session:
  Se o crypt session for inexistente, cancele.
  Call "advapi32.dll" "CryptDestroyKey" com 
    A hcryptkey desta crypt session.
  Call "advapi32.dll" "CryptDestroyHash" com 
    O hcrypthash desta crypt session.
  Call "advapi32.dll" "CryptReleaseContext" com 
    O hcryptprov desta crypt session 
    e 0.
  Desaloque o crypt session.

Etapas para que se destrua um gpimage:
  Se o gpimage for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImage" com o gpimage.
  Esvazie o gpimage.

Etapas para que se destrua um gpimageattributes:
  Se o gpimageattributes for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImageAttributes" com o gpimageattributes.
  Esvazie o gpimageattributes.

Etapas para que se destrua o hbrush of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null hbrush 
    devolvendo um hbrush.
  Call "gdi32.dll" "DeleteObject" com 
    O hbrush.

Etapas para que se destrua o número da fonte of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null número da fonte 
    devolvendo um número da fonte.
  Call "gdi32.dll" "DeleteObject" com 
    O número da fonte.

Etapas para que se destrua o hpen of um canvas:
  Call "gdi32.dll" "SelectObject" com 
    O canvas 
    e O null hpen 
    devolvendo um hpen.
  Call "gdi32.dll" "DeleteObject" com 
    O hpen.

Etapas para que se destrua um hrgn:
  Call "gdi32.dll" "DeleteObject" com 
    O hrgn.

Etapas para que se destrua um catálogo:
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, pare.
    Destrua os refers deste bucket.
  Repita. [o código acima]
  Unassign o first bucket deste catálogo.
  Desaloque o catálogo.

Etapas para que se destrua um endereço completo no sistema de arquivos:
  Defina o endereço completo para read-write mode.
  Se o endereço completo é endereço da pasta-format, destrua o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, destrua o endereço completo no sistema de arquivos (arquivo).

Etapas para que se destrua um endereço completo no sistema de arquivos (pasta)[endereço]:
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, pare.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Destrua a segunda endereço completo no sistema de arquivos.
    Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Repita. [o código acima]
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "RemoveDirectoryA" com 
    O first deste endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível apagar a pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se destrua uma endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "DeleteFileA" com 
    O first deste endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Erro. Não foi possível apagar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se destrua uma imagem:
  Se o imagem for inexistente, cancele.
  Destrua o gpbitmap desta imagem.
  Desaloque o imagem.

Etapas para que se destrua um socket:
  Call "ws2_32.dll" "closesocket" com 
    O socket.

Etapas para que se destrua um vértice usando um polígono:
  Se o vértice for inexistente, cancele.
  Se o polígono for inexistente, cancele.
  Isole o vértice.
  Remove o vértice desde os vértices deste polígono.
  Destrua o vértice.

Etapas para que se destrua um winhttp request:
  Se o winhttp request for inexistente, cancele.
  Call "winhttp.dll" "WinHttpCloseHandle" com 
    O request número identificador deste winhttp request.
  Call "winhttp.dll" "WinHttpCloseHandle" com 
    O connection número identificador deste winhttp request.
  Call "winhttp.dll" "WinHttpCloseHandle" com 
    O session número identificador desta request deste winhttp.
  Deallocate o winhttp request.

Um difference é um par de números.

Um file é um número identificador.

Um nome do arquivo é uma string. \ after o last slash para end of endereço completo = file.ext
Um nome do arquivo s/ extensão é uma string. \ after o last slash para last dot ou end of endereço completo = file
Um extensão é uma string. \ last dot para end of endereço completo = .ext
Um endereço da pasta é um endereço completo. \ start of endereço completo para last slash inclusive = c:\folder1\folder2\
Um endereço completo é uma string. \ complete nome = c:\folder1\folder2\file.ext
Um nome do diretório é uma string. \ rightmost endereço da pasta com slash = folder2\
Um designador é uma string. \ rightmost endereço da pasta com slash = folder2\ ou after o last slash para end of endereço completo = file.ext
Um nome da pasta é uma string. \ rightmost endereço da pasta sem slash = folder2
Um unidade de disco é uma string. \ start of endereço completo para first slash = c:\ ou start of endereço completo para quarto slash = \\computer\share\
Um unidade de rede é uma string. \ é basicamente o número de cópias da variável anterior.
Um categoria da unidade de disco é uma string.
Um nome da unidade de disco é uma string.

Um distance é uns twips.

Etapas para que se divida uma fração por uma segunda fração:
  Isole a segunda fração.
  Flip a segunda fração.
  Multiplique a fração pela segunda fração.

Etapas para que se divida uma fração por um número:
  Multiplique o denominador desta fração pelo número.
  Reduce a fração.

Etapas para que se divida um número por um fração:
  Isole a fração.
  Flip a fração.
  Multiplique o número pela fração.

Etapas para que se divida um par de números por uma segundo par de números:
  Divida o número X deste par de números pelo número X desta segundo par de números.
  Divida o número Y deste par de números pelo número Y desta segundo par de números.

Etapas para que se divida um par de números por um número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo número.

Etapas para que se divida um par de números por um número e um segundo número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo segundo número.

\Um docinfo é um conjunto com
\Um número denominado cbsize,
\Um endereço de memória denominado lpszdocname,
\Um endereço de memória denominado lpszoutput,
\Um endereço de memória denominado lpszdatadtype,
\Um número denominado fwtype.

Um dot é um elipse.

Etapas para que se double um número:
  Adicione o número para o número.

Etapas para que se pinte e fill uma caixa com uma cor:
  Pinte a caixa com a cor e a cor.

Etapas para que se pinte algum tipo de visível rows of um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver visível, repita.
    Pinte a row of o text.
  Repita. [o código acima]

Etapas para que se pinte algum tipo de visível rows of um text (editing):
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não for visível, repita.
    Pinte a row of o text (editing).
  Repita. [o código acima]

Etapas para que se pinte uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas para que se pinte uma caixa (focus style):
  Isole a caixa.
  Adicione o tpp para o canto inferior direito desta caixa.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e O endereçamento desta caixa e 2.
  Converta a cor branca para um código da cor. \código de pigmento/tonalidade?
  Call "gdi32.dll" "SetBkColor" com 
    O quadro atual 
    e O código da cor.
  Converta a cor preta para um segundo código da cor.
  Call "gdi32.dll" "SetTextColor" com 
    O quadro atual 
    e O segundo código da cor.
  Call "gdi32.dll" "SetMapMode" com 
    O quadro atual 
    e 1 [MM_TEXT].
  Call "user32.dll" "DrawFocusRect" com 
    O quadro atual 
    e O endereçamento desta caixa.
  Normalize o quadro atual.

Etapas para que se pinte uma caixa em uma cor:
    \Etapas para que se pinte uma caixa com uma cor:
  Pinte a caixa com a cor e a cor preta.

Etapas para que se pinte o caret em um text:
  Se o text for inexistente, cancele.
  Obtenha uma caixa pelo caret no text.
  Se a caixa não for touching a caixa deste text, cancele.
  Atribua o canto superior esquerdo desta caixa e o canto inferior direito desta caixa a um line.
  Pinte o line com a cor preta.

Etapas para que se pinte um circle about uns twips wide;
Etapas para que se pinte um circle usando um largura;
Etapas para que se pinte um circle uns twips em largura;
Etapas para que se pinte um circle uns twips wide:
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o way.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Repita. [o código acima]

Etapas para que se pinte um circle uns twips wide (backwards);
Etapas para que se pinte um circle uns twips wide (counterclockwise):
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o way.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Repita. [o código acima]

Etapas para que se pinte um console:
  Se o console for inexistente, cancele.
  Save o quadro atual.
  Cubra somente fora de a caixa deste console .
  Pinte a caixa deste console com a cor da borda deste console e a cor de preenchimento deste console.
  Pinte o text deste console.
  Restore o quadro atual.

Etapas para que se pinte um dot uns twips wide sobre o current localização com uma cor:
  Make o dot os twips wide.
  Centralize o dot sobre a localização deste context.
  Pinte o dot com a cor.

Etapas para que se pinte um dot uns twips wide sobre uma localização com uma cor:
  Make o dot os twips wide.
  Centralize o dot sobre a localização.
  Pinte o dot com a cor.

Etapas para que se pinte um elipse:
  Pinte a elipse com a cor preta e a cor branca.

Etapas para que se pinte um elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor e a cor preta.

Etapas para que se pinte uma elipse com uma cor:
  Pinte a elipse com a cor e a cor.

Etapas para que se pinte uma fancy arrow uns twips long com uma cor:
  Atribua a cor à cor deste context.
  Save o context.
  Pinte os twips.
  Vire around.
  Mova os twips dividido por 8.
  Save o context.
  Vire left 1/8 of o way.
  Pinte um spiral starting com os twips dividido por 4.
  Restore o context.
  Vire right 1/8 of o way.
  Pinte uma segunda spiral backwards starting com os twips dividido por 4.
  Restore o context.

Etapas para que se pinte um figura com uma cor:
  Pinte a figura com a cor e a cor preta.

Etapas para que se pinte um figura com uns sides about uns twips wide:
  Atribua 1 e o side contagem a um fração.
  Atribua os twips times o número pi dividido pelo sides a uma quantidade de caracteres do segmento.
  Se o sides são 4, atribua os twips times 7/8 ao quantidade de caracteres do segmento. \ what é this? ***
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire a fração.
    Adicione 1 para uma contagem. 
    Se a contagem for os sides, pare.
  Repita. [o código acima]

Etapas para que se pinte um figura com uns sides uns twips long;
Etapas para que se pinte um figura com uns sides e uns twips:
  Atribua 1 e o sides a um fração.
  Percorra. [o código abaixo]
    Pinte os twips.
    Vire a fração.
    Adicione 1 para uma contagem. Se a contagem é o sides, pare.
  Repita. [o código acima]

Etapas para que se pinte um figura com uns sides uns twips long using uma cor;
Etapas para que se pinte um figura com uns sides e uns twips using uma cor:
  Atribua a cor à cor deste context.
  Pinte a figura com o sides e os twips.

Etapas para que se pinte um half circle about uns twips wide;
Etapas para que se pinte um half circle usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o way.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Repita. [o código acima]

Etapas para que se pinte um half circle usando um size (backwards);
Etapas para que se pinte um half circle usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o way.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Repita. [o código acima]

Etapas para que se pinte um hexagon usando um side quantidade de caracteres:
  Pinte o side quantidade de caracteres.
  Vire right 1/6 of o way.
  Adicione 1 para uma contagem. Se a contagem for 6, pare.
  Repita. [o código acima]

Etapas para que se pinte um line:
  Pinte o line com a cor deste context.

Etapas para que se pinte um line around uns twips long; \ "around" é significante here
Etapas para que se pinte um line about uns twips long: \ "about" é significante here
    \ "about" é significant here
  Atribua os twips dividido por 2 a uns segunda twips.
  Escolha aleatoriamente uns terceiro twips entre os twips menos a segunda twips e os twips mais a segunda twips.
  Pinte o line o terceiro twips long.

Etapas para que se pinte um line como tall como uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte a altura desta caixa.

Etapas para que se pinte um line como wide como uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte a largura desta caixa.

Etapas para que se pinte um line entre uns twips e uns segunda twips long;
Etapas para que se pinte um line entre uns twips para uns segunda twips long;
Etapas para que se pinte um line uns twips para uns segunda twips long:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte o line o terceiro twips long.

Etapas para que se pinte um line uns twips long:
    \Aguarde pelo delay. ***
  Atribua a localização deste context ao start desta line.
  Atribua a localização deste context ao end desta line.
  Obtenha um deslocamento vertical e um deslocamento horizontal usando a orientação deste context.
  Adicione o deslocamento horizontal times os twips dividido por 10000 para a coordenada X deste end desta line.
  Adicione o deslocamento vertical times os twips dividido por 10000 para a coordenada Y deste end desta line.
  Atribua o end desta line à localização deste context.
  Pinte o line com a cor deste context.
    \Se o delay é positive, atualize o tela.

Etapas para que se pinte um line using uns twips como a quantidade de caracteres;
Etapas para que se pinte um line using uns twips pelo quantidade de caracteres:
  Pinte os twips.

Etapas para que se pinte um line com uma cor around uns twips long; \ "around" é significant here
Etapas para que se pinte um line com uma cor about uns twips long:\ "about" é significant here
    \ "about" é significant here
  Atribua os twips dividido por 2 a uns segunda twips.
  Escolha aleatoriamente uns terceiro twips entre os twips menos a segunda twips e os twips mais a segunda twips.
  Pinte o line com a cor o terceiro twips long.

Etapas para que se pinte um line com uma cor uns twips long:
  Atribua a cor à cor deste context.
  Atribua a localização deste context ao start desta line.
  Pinte os twips.
  Atribua a localização deste context ao end desta line.

Etapas para que se pinte um line com uma cor uns twips para uns segunda twips long:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte o line com a cor o terceiro twips long.

Etapas para que se pinte um número em uma caixa com uma cor:
  Atribua o número a uma string.
  Pinte a string na caixa com a cor e "center".

Etapas para que se pinte only within uma caixa;
Etapas para que se pinte only inside uma caixa;
Etapas para que se pinte only em uma caixa;
Etapas para que se pinte only within uma caixa desde now on;
Etapas para que se pinte only inside uma caixa desde now on;
Etapas para que se pinte only em uma caixa desde now on;
Etapas para que se only pinte within uma caixa desde now on;
Etapas para que se only pinte inside uma caixa desde now on;
Etapas para que se only pinte em uma caixa desde now on;
Etapas para que se only pinte within uma caixa;
Etapas para que se only pinte inside uma caixa;
Etapas para que se only pinte em uma caixa;
Etapas para que se pinte within uma caixa only;
Etapas para que se pinte inside uma caixa only;
Etapas para que se pinte em uma caixa only;
Etapas para que se atribua masking tape all around uma caixa;
Etapas para que se atribua masking tape around uma caixa:
    \ note that this masks a cor da borda da caixa as well
  Isole a caixa.
  Indent a caixa 1 pixel.
  Cubra externamente a caixa.
  Atribua a original caixa à caixa deste context. \ *** original caixa ? ou indented one?

Etapas para que se pinte uma imagem sobre um gpgraphic at uma coordenada X e uma coordenada Y:
  Se o imagem for inexistente, cancele.
  Se o grayscale detector desta imagem estiver ativo, crie um gpimageattributes (grayscale).
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com 
    O gpgraphic 
    e O gpbitmap desta imagem 
    e A coordenada X 
    e A coordenada Y 
    e A largura desta caixa intacta desta imagem 
    e A altura desta caixa intacta desta imagem 
    e 0 
    e 0 
    e A largura deste gpbitmap desta imagem 
    e A altura deste gpbitmap desta imagem 
    e 2 [unitpixel] 
    e O gpimageattributes 
    e nil e 0.
  Se o gpimageattributes não for inexistente, destrua o gpimageattributes.

Etapas para que se pinte um polígono:
  Pinte o polígono com a cor preta e a cor branca.

Etapas para que se pinte um polígono com uma cor:
  Pinte o polígono com a cor e a cor.

Etapas para que se pinte um polígono com uma cor (border only):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hpen of o quadro atual usando a cor.
  Obtenha um vértice desde os vértices deste polígono.
  Se o vértice for inexistente, cancele.
  Call "gdi32.dll" "MoveToEx" com 
    O quadro atual 
    e A coordenada X deste vértice 
    e A coordenada Y deste vértice 
    e nil.
  Percorra. [o código abaixo]
    Obtenha o vértice desde os vértices deste polígono.
    Se o vértice for inexistente, pare.
    Call "gdi32.dll" "LineTo" com 
      O quadro atual 
      e A coordenada X deste vértice 
      e A coordenada Y deste vértice.
  Repita. [o código acima]
  Destrua o hpen of o quadro atual.
  Se a localização deste first destes vértices deste polígono for a localização deste last destes vértices deste polígono, cancele.
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com 
    O quadro atual 
    e A coordenada X deste last destes vértices deste polígono 
    e A coordenada Y deste last destes vértices deste polígono 
    e O código da cor.

Etapas para que se pinte um polígono com uma cor (fill only):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hpen of o quadro atual usando a cor preta.
  Crie o hbrush of o quadro atual usando a cor.
  Call "gdi32.dll" "SetPolyFillMode" com 
    O quadro atual 
    e 2 [WINDING].
  Crie um vértice array usando os vértices deste polígono.
  Call "gdi32.dll" "Polygon" com 
    O quadro atual 
    e A localização endereço de memória deste vértice array 
    e A contagem deste vértice array.
  Destrua o vértice array.
  Destrua o hbrush of o quadro atual.
  Destrua o hpen of o quadro atual.

Etapas para que se pinte um quarter circle about uns twips wide;
Etapas para que se pinte um quarter circle usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o way.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Repita. [o código acima]

Etapas para que se pinte um quarter circle entre uns twips e uns segunda twips wide:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte um quarter circle usando o terceiro twips.

Etapas para que se pinte um quarter circle usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o way.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Repita. [o código acima]

Etapas para que se pinte um retângulo uns twips por uns segunda twips;
Etapas para que se pinte um retângulo uns twips wide por uns segunda twips high:
  Pinte a segunda twips.
  Vire right.
  Pinte os twips.
  Vire right.
  Pinte a segunda twips.
  Vire right.
  Pinte os twips.
  Vire right.

Etapas para que se pinte uma caixa arredondada:
  Pinte a caixa arredondada com a cor preta e a cor branca.

Etapas para que se pinte uma caixa arredondada com uma cor:
  Pinte a caixa arredondada com a cor e a cor.

Etapas para que se pinte uma row of um text:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas para que se pinte uma row of um text (editing):
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Pinte a caixa de seleção pela row of o text.
  Obtenha uma caixa usando a row e o text.
  Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas para que se pinte a caixa de seleção por uma row of um text:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Se a row of o text não estiver selecionado, cancele.
  Obtenha uma caixa de seleção usando a row e o text.
  Pinte a caixa de seleção com o hilite cor e o hilite cor.

Etapas para que se pinte um spiral backward usando uns twips;
Etapas para que se pinte um spiral backward starting com uns twips;
Etapas para que se pinte um spiral usando um size (backwards):
  Isole o size.
  Percorra. [o código abaixo]
    Pinte um half circle usando o size (backwards).
    Divida o size por 2.
    Adicione 1 para uma contagem.
    Se a contagem for 5, pare.
  Repita. [o código acima]

Etapas para que se pinte um spiral starting com uns twips;
Etapas para que se pinte um spiral usando um size:
  Isole o size.
  Percorra. [o código abaixo]
    Pinte um half circle usando o size.
    Divida o size por 2.
    Adicione 1 para uma contagem. 
    Se a contagem for 5, pare.
  Repita. [o código acima]

Etapas para que se pinte uma localização:
  Pinte a localização com a cor preta.

Etapas para que se pinte uma localização com uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    e O código da cor.

Etapas para que se pinte um star usando uma point contagem e um size:
  Atribua 1 e a point contagem a um fração.
  Percorra. [o código abaixo]
    Vire right 1/48 of o way.
    Pinte o size.
    Vire around.
    Vire left 1/24 of o way.
    Pinte o size.
    Vire around.
    Vire right 1/48 of o way.
    Vire right a fração of o way.
    Adicione 1 para uma contagem. 
    Se a contagem for o point contagem, pare.
  Repita. [o código acima]

Etapas para que se pinte uma string at o left of uma caixa:
  Pinte a string at o left of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string at o left of uma caixa com uma cor:
  Pinte a string at o left of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string at o left of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e o font e "left".

Etapas para que se pinte uma string at o left of uma caixa com um font:
  Pinte a string at o left of a caixa com a cor preta e o font.

Etapas para que se pinte uma string at o right of uma caixa:
  Pinte a string at o right of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string at o right of uma caixa com uma cor:
  Pinte a string at o right of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string at o right of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e o font e "right".

Etapas para que se pinte uma string at o right of uma caixa com um font:
  Pinte a string at o right of a caixa com a cor preta e o font.

Etapas para que se pinte uma string at uma localização com uma cor:
  Pinte a string at a localização com a cor e a fonte padrão.

Etapas para que se pinte uma string em uma caixa:
  Pinte a string na caixa com a cor preta e a fonte padrão e "left".

Etapas para que se pinte uma string em uma caixa over um número com uma cor e uma font e um alinhamento:
  Isole a caixa.
  Se o alinhamento for "left", adicione o número para a coordenada esquerda desta caixa.
  Se o alinhamento for "zquierda", adicione o número para a coordenada esquerda desta caixa.
  Se o alinhamento for "derecho", subtraia o número desde a coordenada direita desta caixa.
  Pinte a string na caixa com a cor e o font e o alinhamento.

Etapas para que se pinte uma string em uma caixa com um alinhamento:
  Pinte a string na caixa com a cor preta e a fonte padrão e o alinhamento.

Etapas para que se pinte uma string em uma caixa com uma cor:
  Pinte a string na caixa com a cor e a fonte padrão e "left".

Etapas para que se pinte uma string em uma caixa com uma cor e um alinhamento:
  Pinte a string na caixa com a cor e a fonte padrão e o alinhamento.

Etapas para que se pinte uma string em uma caixa com uma cor e uma font e um alinhamento:
  Obtenha um offset par de números usando a string e a caixa e o font e o alinhamento.
  Pinte a string at o canto superior esquerdo desta caixa mais o offset par de números com a cor e o font.

Etapas para que se pinte uma string em uma caixa com uma font e um alinhamento:
  Pinte a string na caixa com a cor preta e o font e o alinhamento.

Etapas para que se pinte uma string no center of uma caixa:
  Pinte a string no center of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string no center of uma caixa com uma cor:
  Pinte a string no center of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string no center of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e o font e "center".

Etapas para que se pinte uma string no center of uma caixa com um font:
  Pinte a string no center of a caixa com a cor preta e o font.

Etapas para que se pinte um terminal:
  Se o terminal for inexistente, cancele.
  Save o quadro atual.
  Cubra somente fora de a caixa deste terminal.
  Pinte e fill a caixa deste terminal com a cor preta.
  Escreva os quoras deste terminal na caixa deste terminal.
  Restore o quadro atual.

Etapas para que se pinte um text:
  Se o text for inexistente, cancele.
  Save o quadro atual.
  Cubra externamente a caixa deste text.
  Pinte algum tipo de visível rows of o text.
  Restore o quadro atual.

Etapas para que se pinte um text (editing):
  Se o text for inexistente, cancele.
  Save o quadro atual.
  Cubra externamente a caixa deste text.
  Pinte algum tipo de visível rows of o text (editing).
  Pinte o caret no text.
  Restore o quadro atual.

Etapas para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos:
  Se o endereço completo é endereço da pasta-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (arquivo).

Etapas para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (pasta)[endereço]:
  Se o endereço completo estiver no segunda endereço completo, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de ". - erro de recursão inválida." ao erro do fluxo de entrada/saída; exit.
  Se o endereço completo não estiver no sistema de arquivos, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.
  Se a segunda endereço completo não estiver no sistema de arquivos, crie a segunda endereço completo no sistema de arquivos.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Atribua o endereço completo a um terceiro endereço completo.
    Posponha o designador deste item para o terceiro endereço completo.
    Atribua a segunda endereço completo a um quarto endereço completo.
    Posponha o designador deste item para o quarto endereço completo.
    Duplicate o terceiro endereço completo para o quarto endereço completo no sistema de arquivos.
  Repita. [o código acima]

Etapas para que se duplicate um endereço completo para um segundo endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Isole o segundo endereço completo.
  Modifique através do caractere NUL o segundo endereço completo.
  Call "kernel32.dll" "CopyFileA" com 
    O first deste endereço completo 
    e O first deste segundo endereço completo 
    e 0 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, defina o endereço completo para read-write mode; exit.
  Atribua "Ocorreu um erro na hora de duplicar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

An dyad é uma coisa com
  Um nome,
  Uma value string.

Uma elipse é um conjunto com uma caixa.

Um email é um conjunto com
  Um smtp server,
  Um sender,
  Um recipient,
  Um subject,
  Uma message.

Etapas para que se encrypt um trecho usando um passphrase string:
    \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie um crypt session usando o passphrase.
  Se o crypt session for inexistente, cancele.
  Atribua o trecho a um temp trecho.
  Atribua a quantidade de caracteres deste temp trecho a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptEncrypt" com 
    A hcryptkey desta crypt session 
    e 0 
    e 1 
    e 0 
    e O first endereço de memória do pedaço deste temp trecho 
    e O endereçamento deste quantidade de caracteres 
    e A quantidade de caracteres 
    devolvendo um result número.
  Se o result número for 0, atribua "Ocorreu um erro na hora de criptografar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; exit.
  Destrua o crypt session.
  Converta o temp trecho para um cifra hexadecimal.
  Atribua a cifra hexadecimal ao trecho.

Etapas para que se enlarge uma caixa por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta caixa.
  Adicione os twips para o canto inferior direito desta caixa.

Etapas para que se enlarge um elipse por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta elipse.
  Adicione os twips para o canto inferior direito desta elipse.

Etapas para que se enfileire um event:
  Posponha o event para a fila de eventos.

Etapas para que se erase o insides of uma caixa;
Etapas para que se erase inside uma caixa;
Etapas para que se limpe inside uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas para que se estime um deslocamento vertical e um deslocamento horizontal usando uma orientação:
  Atribua a orientação a um low orientação.
  Arredonde o low orientação para baixo para o múltiplo imediato of 20.
  Obtenha um low deslocamento vertical e um low deslocamento horizontal usando o low orientação.
  Atribua a orientação a um high orientação.
  Arredonde o high orientação para cima para o múltiplo imediato of 20.
  Obtenha um high deslocamento vertical e um high deslocamento horizontal usando o high orientação.
  Atribua o low deslocamento vertical mais o high deslocamento vertical dividido por 2 ao deslocamento vertical.
  Atribua o low deslocamento horizontal mais o high deslocamento horizontal dividido por 2 ao deslocamento horizontal.

    \Um event é uma coisa com
    \a categoria,
    \a detector de tecla Shift,
    \a detector de tecla ctrl,
    \um detector de tecla alt,
    \a localização,
    \a tecla, um pedaço.

An event é uma coisa com
Uma categoria [atualização de tela, mostrar seta, pressionamento de tecla, clique, clique duplo, clique direito, clique direito duplo, deactivate, activate, done], \ English
Um detector de tecla Shift, 
Um detector de tecla ctrl, 
Um detector de tecla alt, 
Um localização, 
Uma tecla, 
Um pedaço.

A fila de eventos é uma fila de eventos.

Uma fila de eventos é uns events.

Etapas para que se extend algum tipo de seleção em um text usando uma localização:
  Se o text for inexistente, cancele.
  Obtenha o caret deste text usando a localização e o text.
  Limpe a última operação deste text.

Etapas para que se extend uma caixa para include uma segunda caixa:
  Se a coordenada esquerda desta segunda caixa for menor do que a coordenada esquerda desta caixa, atribua a coordenada esquerda desta segunda caixa à coordenada esquerda desta caixa.
  Se a coordenada superior desta segunda caixa for menor do que a coordenada superior desta caixa, atribua a coordenada superior desta segunda caixa à coordenada superior desta caixa.
  Se a coordenada direita desta segunda caixa for maior do que a coordenada direita desta caixa, atribua a coordenada direita desta segunda caixa à coordenada direita desta caixa.
  Se a coordenada inferior desta segunda caixa for maior do que a coordenada inferior desta caixa, atribua a coordenada inferior desta segunda caixa à coordenada inferior desta caixa.

Some  extra points são uns points.

Etapas para que se extraia um designador desde um endereço completo:
  Limpe o designador.
  Extraia um unidade de disco desde o endereço completo.
  Lance um endereço completo subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o first deste endereço completo subtexto.
  Se o endereço completo subtexto estiver em branco, atribua o unidade de disco ao designador; exit.
  Lance um subtexto sobre o last pedaço of o endereço completo subtexto.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o first endereço de memória do pedaço deste subtexto for menor do que o first deste endereço completo subtexto, pare.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Atribua o subtexto ao designador.

Etapas para que se extraia um endereço da pasta desde um endereço completo:
  Limpe o endereço da pasta.
  Extraia um unidade de disco desde o endereço completo.
  Se o unidade de disco estiver em branco, cancele.
  Lance um subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o first endereço de memória do pedaço deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, subtraia 1 desde o last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua a unidade de disco junto com o subtexto ao endereço da pasta.

Etapas para que se extraia um nome do diretório desde um endereço completo:
  Limpe o nome do diretório.
  Se o endereço completo não for endereço da pasta-format, cancele.
  Extraia o nome do diretório como um designador desde o endereço completo.

Etapas para que se extraia um nome da pasta desde um endereço completo:
  Extraia o nome da pasta como um nome do diretório desde o endereço completo.
  Se o nome da pasta estiver em branco, cancele.
  Remove o last pedaço desde o nome da pasta.

Etapas para que se extraia um unidade de disco desde um endereço completo:
  Limpe o unidade de disco.
  Se a quantidade de caracteres deste endereço completo for menor do que 3, cancele.
  Lance um subtexto sobre o first pedaço of o endereço completo.
  Adicione 2 para o last endereço de memória do pedaço deste subtexto.
  Se o subtexto termina com ":\", atribua o subtexto ao unidade de disco; exit.
  Se o subtexto não começa com "\\", cancele.
  Lance o subtexto sobre o first pedaço of o endereço completo.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last deste endereço completo, cancele.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for a barra invertida, adicione 1 para uma contagem.
    Se a contagem for 4, pare. \ "\\computer\share\"
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o subtexto ao unidade de disco.

Etapas para que se extraia um extensão desde um endereço completo:
  Limpe o extensão.
  Se o endereço completo estiver em branco, cancele.
  Lance um subtexto sobre o last pedaço of o endereço completo.
  Percorra. [o código abaixo]
    Se o first endereço de memória do pedaço deste subtexto for menor do que o first deste endereço completo, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o sinal de dois pontos, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for a barra invertida, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o ponto final, pare.
    Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o subtexto ao extensão.

Etapas para que se extraia um nome do arquivo desde um endereço completo:
  Limpe o nome do arquivo.
  Se o endereço completo não for file-format, cancele.
  Extraia o nome do arquivo como um designador desde o endereço completo.

Etapas para que se extraia um nome do arquivo s/ extensão desde um endereço completo:
  Extraia o nome do arquivo s/ extensão como um nome do arquivo desde o endereço completo.
  Extraia um extensão desde o endereço completo.
  Remove trailing pedaços desde o nome do arquivo s/ extensão usando a quantidade de caracteres desta extensão.

Etapas para que se extraia um imagem usando uma caixa:
  Atribua a largura desta caixa dividido pelo tpp a um largura.
  Atribua a altura desta caixa dividido pelo tpp a uma altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
    A largura 
    e A altura 
    e 0 
    e 137224 [pixelformat24bpprgb] 
    e 0 
    e O endereçamento desse gpbitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
    O gpbitmap 
    e O endereçamento desse gpgraphic.
  Call "gdiplus.dll" "GdipGetDC" com 
    O gpgraphic 
    e O endereçamento desse bitmap canvas.
  Normalize o bitmap canvas.
  Call "gdi32.dll" "BitBlt" com 
    O bitmap canvas 
    e 0 
    e 0 
    e A largura desta caixa 
    e A altura desta caixa 
  And o quadro atual e a coordenada esquerda desta caixa e a coordenada superior desta caixa e 13369376 [srccopy].
  Call "gdiplus.dll" "GdipReleaseDC" com 
    O gpgraphic 
    e O bitmap canvas.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
    O gpgraphic.
  Crie o imagem usando o gpbitmap.
  Atribua a caixa à caixa desta imagem.
  Atribua a caixa à caixa intacta desta imagem.

Etapas para que se extraia uma string desde um text:
  Se o text for inexistente, limpe a string; exit.
  Converta as rows deste text para a string.
  Remove algum tipo de trailing linefeed pedaço desde a string.
  Remove algum tipo de trailing return pedaço desde a string.

Etapas para que se extraia uma string desde um text (no linefeed additions):
  Se o text for inexistente, limpe a string; exit.
  Converta as rows deste text para a string (no linefeed additions).
  Remove algum tipo de trailing return pedaço desde a string.

Etapas para que se extraia uma string desde um text (pedaços selecionados):
  Limpe a string.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
    Se o subtexto estiver em branco, repita.
    Posponha o subtexto para a string.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for o return pedaço, posponha o linefeed pedaço para a string.
  Repita. [o código acima]

Etapas para que se face algum tipo de way you want;
Etapas para que se face algum tipo de which way:
  Escolha aleatoriamente uma orientação.

Etapas para que se face east:
  Atribua 960 à orientação deste context.

Etapas para que se face north:
  Atribua 0 à orientação deste context.

Etapas para que se face south:
  Atribua 1920 à orientação deste context.

Etapas para que se face west:
  Atribua 2880 à orientação deste context.

Um fancy arrow é um figura.

Um figura é um polígono.

As figuras são uns polígonos.

\Um filetime é um conjunto com
\  Um número denominado dwlowdatetime,
\  Um número denominado dwhighdatetime.

Etapas para que se fill uma caixa com uma cor:
  Pinte a caixa com a cor preta e a cor.

Etapas para que se fill um elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor preta e a cor.

Etapas para que se fill uma string com um pedaço usando uma contagem:
  Reassign o first endereço de memória do pedaço desta string usando a contagem.
  Fill pedaços com o pedaço starting at o first endereço de memória do pedaço desta string pela contagem.
  Atribua o first endereço de memória do pedaço desta string mais a contagem menos 1 ao last endereço de memória do pedaço desta string.

Etapas para que se finalize after run:
  Se a contagem do heap for 0, cancele.
  Atribua a contagem do heap a uma contagem.
  Atribua "Você esqueceu de destruir " junto com a contagem seguido de " elemento(s) no heap." a uma string.
  Produza o relatório de informações usando a string.

Etapas para que se finalize o canvases:
  Finalize o memory canvas.
  Finalize o tela canvas.

Etapas para que se finalize o cgi:
  Call "kernel32.dll" "FreeConsole".

Etapas para que se finalize a cors:

Etapas para que se finalize COM:
  Call "ole32.dll" "CoUninitialize".

Etapas para que se finalize um context:
  Destrua o choices.
  Destrua as figuras.
  Destrua o context stack.
  Destrua o context.

Etapas para que se finalize os cursors:
  \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroycursor
  Call "user32.dll" "DestroyCursor" com 
    O i-beam cursor. 
  Call "user32.dll" "DestroyCursor" com 
    O hand cursor.
  Call "user32.dll" "DestroyCursor" com 
    A seta do mouse.

Etapas para que se finalize as fonts:
    \Call "gdi32.dll" "RemoveFontMemResourceEx" com o osmosian font resource.
    \Call "gdi32.dll" "RemoveFontMemResourceEx" com o Segoe UI resource.
  Call "gdi32.dll" "RemoveFontMemResourceEx" com 
    O recurso de fonte Tahoma. \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-RemoveFontMemResourceEx

Etapas para que se finalize gdi+:
  Call "gdiplus.dll" "GdiplusShutdown" com 
    O gptoken. \https://docs.microsoft.com/en-us/windows/win32/api/gdiplusinit/nf-gdiplusinit-gdiplusshutdown

Etapas para que se finalize o memory canvas:
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O saved memory hbitmap 
    devolvendo um hbitmap. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  Call "gdi32.dll" "DeleteObject" com 
    O hbitmap. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  Call "gdi32.dll" "DeleteDC" com 
    O memory canvas. \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deletedc

Etapas para que se finalize o module:

Etapas para que se finalize o mouse:

Etapas para que se finalize o printer canvas:
  Call "kernel32.dll" "GlobalFree" com \https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalfree
    o número identificador do modo de dispositivo da impressora.
    \ Um identificador para o objeto de memória global. 
    \Esse identificador é retornado pela função GlobalAlloc ou GlobalReAlloc. 
    \Não é seguro liberar memória alocada com LocalAlloc.
  Atribua 0 ao printer canvas.

Etapas para que se finalize a tela:

Etapas para que se finalize o tela canvas:

Etapas para que se finalize um talker:
  Se o talker for inexistente, cancele.
  Call a release desta vtable deste talker com o talker.
  Atribua nil ao talker.

Etapas para que se finalize o window:
  Call "user32.dll" "DestroyWindow" com 
    A main window. \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow
  Percorra. [o código abaixo]
  Call "user32.dll" "GetMessageA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea
      o endereçamento dessa msg \Um ponteiro para uma estrutura MSG que recebe informações da mensagem da fila de mensagens do segmento.
      e 0 \Um identificador para a janela cujas mensagens devem ser recuperadas. A janela deve pertencer ao segmento atual.
    \Se hWnd for NULL, GetMessage recuperará mensagens para qualquer janela que pertença ao segmento atual 
    \e quaisquer mensagens na fila de mensagens do segmento atual cujo valor hwnd seja NULL (consulte a estrutura MSG). https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-msg
    \Portanto, se hWnd for NULL, as mensagens da janela e as mensagens do thread serão processadas.
      e 0 \O valor inteiro do menor valor da mensagem a ser recuperado. 
    \Use WM_KEYFIRST (0x0100) para especificar a primeira mensagem do teclado ou WM_MOUSEFIRST (0x0200) para especificar a primeira mensagem do mouse.
      e 0 \O valor inteiro do maior valor da mensagem a ser recuperado. 
    \Use WM_KEYLAST para especificar a última mensagem do teclado ou WM_MOUSELAST para especificar a última mensagem do mouse.
    \Se wMsgFilterMin e wMsgFilterMax forem 0, GetMessage retorna todas as mensagens disponíveis (ou seja, nenhuma filtragem de intervalo é executada).
      devolvendo um número. \Se a função recuperar uma mensagem diferente de WM_QUIT, o valor de retorno será diferente de zero.
    \Se a função recuperar a mensagem WM_QUIT, o valor de retorno será zero.
    \Se houver um erro, o valor de retorno é -1. 
    \Por exemplo, a função falhará se hWnd for um identificador de janela inválido ou lpMsg for um ponteiro inválido. 
    \Para obter informações de erro estendidas, use a função GetLastError. https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror
    \\ Execute a função "GetMessageA" da biblioteca "user32.dll" usando como argumentos os seguintes parâmetros: 
    \\ o endereçamento dessa msg e os valores 0, 0 e 0, esperando um número como resultado.
    Se o número for menor do que 1, pare.
    Call "user32.dll" "TranslateMessage" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage
      o endereçamento desta msg. \Um ponteiro para uma estrutura MSG que contém informações de mensagem recuperadas da fila de mensagens do thread de chamada usando a função GetMessage ou PeekMessage.
    Call "user32.dll" "DispatchMessageA" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagea
      o endereçamento desta msg. \Um ponteiro para uma estrutura que contém a mensagem.
  Repita. [o código acima]
  Desmanche a fila de eventos.
  Destrua o evento atual.

Etapas para que se finalize winsock:
  Call "ws2_32.dll" "WSACleanup".\https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsacleanup

A find anchor é uma anchor.

Etapas para que se encontre uma choice usando uma localização:
  Start com nada no choice.
  Percorra. [o código abaixo]
    Obtenha o [first/next] choice desde as choices.
    Se o choice for missing, cancele.
    Se a localização estiver na caixa desta choice, pare.
  Repita. [o código acima]

Etapas para que se encontre um dyad usando uns dyads e um nome:
  Esvazie o dyad.
  Percorra. [o código abaixo]
    Obtenha o dyad desde o dyads.
    Se o dyad for inexistente, cancele.
    Se o nome deste dyad for o nome, cancele.
  Repita. [o código acima]

Etapas para que se encontre next usando uma row e um text e um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Lance um subtexto sobre a string deste row.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres deste find string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Se o número da linha desta row for o número da linha deste find anchor, mova o subtexto usando o column# deste find anchor menos 1.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que ou igual ao last endereço de memória do pedaço desta string desta row, cancele.
    Se o subtexto for o find string (accent-free compare), pare. \ for spanish incremental find
    Mova o subtexto usando 1.
  Repita. [o código acima]
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 1 ao anchor column# deste text.
  Atribua o número da linha desta row ao anchor número da linha deste text .
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 2 ao caret column# deste text.
  Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas para que se encontre next usando um text e um detector:
  Se o wrap detector deste text estiver ativo, encontre next usando o text e o detector (wrapped text); exit.
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a quantidade de caracteres deste find string for 0, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
    Encontre next usando a row e o text e o detector.
    Se o detector estiver ativo, cancele.
  Repita. [o código acima]

Etapas para que se encontre next usando um text e um detector (wrapped text):
  Desative o detector.
  Se o text for inexistente, cancele.
  Converta o find anchor para um posicionamento absoluto denominado offset usando o text.
  Extraia uma string desde o text (no linefeed additions).
  Atribua o first endereço de memória do pedaço desta string mais o offset menos 1 ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres deste find string menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta string, cancele.
    Se o subtexto for a find string (accent-free compare), pare. \ para o spanish incremental find
    Mova o subtexto usando 1.
  Repita. [o código acima]
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string mais 1 a um anchor posicionamento absoluto.
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string mais 2 a um caret posicionamento absoluto.
  Converta o anchor posicionamento absoluto para o anchor deste text usando o text.
  Converta o caret posicionamento absoluto para o caret deste text usando o text.

Etapas para que se encontre o next misspelling usando uma row e um text e um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Lance um percorredor sobre a string deste row.
  Se o número da linha desta row for o número da linha deste find anchor, adicione o column# deste find anchor menos 1 para o first endereço de memória do pedaço deste segmento final deste percorredor.
  Se o first endereço de memória do pedaço deste segmento final deste percorredor não for o first endereço de memória do pedaço desta string desta row, skip palavra characters no segmento final deste percorredor.
  Percorra. [o código abaixo]
    Mova o percorredor (spell checking rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor não estiver escrito incorretamente, repita.
  Ligue o detector.
  Atribua o first endereço de memória do pedaço deste segmento inicial deste percorredor menos o first endereço de memória do pedaço desta string desta row mais 1 ao anchor column# deste text.
  Atribua o número da linha desta row ao anchor número da linha deste text .
  Atribua o last endereço de memória do pedaço deste segmento inicial deste percorredor menos o first endereço de memória do pedaço desta string desta row mais 2 ao caret column# deste text.
  Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas para que se encontre o next misspelling em um text usando um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
    Encontre o next misspelling usando a row e o text e o detector.
    Se o detector estiver ativo, cancele.
  Repita. [o código acima]



Etapas para que se encontre um endereço de memória usando uma string e um catálogo:
  Encontre um refer usando a string e o catálogo.
  Se o refer não for inexistente, atribua o endereço de memória deste refer ao endereço de memória; exit.
  Esvazie o endereço de memória.

Etapas para que se encontre um refer usando uma string e um catálogo:
  Se o catálogo for inexistente, cancele.
  Se a string estiver em branco, esvazie o refer; exit.
  Obtenha um bucket usando a string e o catálogo.
  Encontre o refer usando a string e os refers deste bucket.

Etapas para que se encontre um refer usando uma string e uns refers:
  Esvazie o refer.
  Percorra. [o código abaixo]
    Obtenha o refer desde o refers.
    Se o refer for inexistente, cancele.
    Se a string for a string deste refer, cancele.
  Repita. [o código acima]

Etapas para que se encontre um sector usando um malha e uma localização:
  Atribua a coordenada X desta localização dividido pelo número X desta malha times o número X desta malha à coordenada x deste sector.
  Atribua a coordenada Y desta localização dividido pelo número Y desta malha times o número Y desta malha à coordenada y deste sector.

Etapas para que se encontre um square root of um número:
    \ rounds para baixo
  Isole o número.
  De-sign o número.
  Se o número for 0, atribua 0 ao square root; exit.
  Se o número for 1, atribua 1 ao square root; exit.
  Atribua 1 a um square número.
  Atribua 3 a um delta número.
  Percorra. [o código abaixo]
    Se o square for maior do que o número, pare.
    Adicione o delta para o square.
    Adicione 2 para o delta.
  Repita. [o código acima]
  Atribua o delta dividido por 2 menos 1 ao square root.

Etapas para que se encontre uma string usando uns conjunto de textos e uma string#:
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha um conjunto de texto desde o conjunto de textos.
    Se o conjunto de texto for inexistente, cancele.
    Adicione 1 para uma contagem.
    Se a contagem não for a string#, repita.
  Atribua a string deste conjunto de texto à string.

O find string é uma string.

Etapas para que se encontre um conjunto de texto usando uma string e uns conjunto de textos:
  Esvazie o conjunto de texto.
  Percorra. [o código abaixo]
    Obtenha o conjunto de texto usando o conjunto de textos.
    Se o conjunto de texto for inexistente, pare.
    Se a string deste conjunto de texto é a string, pare.
  Repita. [o código acima]

Etapas para que se encontre um subtexto em uma string usando uma segunda string:
  Lance o subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o subtexto começa com a segunda string, pare.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao last endereço de memória do pedaço deste subtexto.

Etapas para que se encontre um value string usando uns dyads e um nome:
  Encontre um dyad usando o dyads e o nome.
  Se o dyad for inexistente, limpe o value; exit.
  Atribua o value deste dyad ao value.

Etapas para que se encontre um value string usando o environment variáveis e um nome:
  Isole o nome.
  Modifique através do caractere NUL o nome.
  Atribua 32767 a uma quantidade de caracteres. \ max size por environment variável
  Reassign o first deste value usando a quantidade de caracteres.
  Call "kernel32.dll" "GetEnvironmentVariableA" com 
    O first deste nome 
    e O first deste value 
    e A quantidade de caracteres 
    devolvendo a quantidade de caracteres.
  Atribua o first deste value mais a quantidade de caracteres menos 1 ao last deste value.

Um finger é um endereço de memória do pedaço .

    \Um flag has 4 pedaços.
Um detector é uma coisa com 4 pedaços. \é um conjunto com

Etapas para que se flip um fração:
  Permute o numerador desta fração com o denominador desta fração.

Etapas para que se flip o gpbitmap em um imagem:
  Se o imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Flip o gpbitmap desta imagem.

Etapas para que se flip um gpimage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O gpimage 
    e 6 [RotateNoneFlipY aka Rotate180FlipX].

Etapas para que se flip um imagem:
  Se o imagem for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa desta imagem menos a coordenada Y deste center desta caixa intacta desta imagem ao número Y desse par de números.
  Multiplique o número Y deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Flip o gpbitmap no imagem.

Etapas para que se flip um polígono:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia a coordenada superior desta caixa desde a coordenada Y deste vértice.
    Atribua a coordenada inferior desta caixa menos a coordenada Y deste vértice à coordenada y deste vértice.
  Repita. [o código acima]

Etapas para que se desmanche all input;
Etapas para que se desmanche all inputs;
Etapas para que se desmanche all events:
  Desmanche algum tipo de messages.
  Desmanche a fila de eventos.

Etapas para que se desmanche algum tipo de messages:
  Call "user32.dll" "PeekMessageA" com 
    O endereçamento dessa msg 
    e 0 
    e 0 
    e 0 
    e 1 [PM_REMOVE] devolvendo um número.
  Se o número for 0, cancele.
  Se a message desta msg for 15 [WM_PAINT], call "user32.dll" "ValidateRect" com a main window e 0. \ que tal ter uma rotina específica para isso?
  Repita. [o código acima]

Etapas para que se desmanche um fila de eventos:
  Obtenha um event desde a fila de eventos.
  Se o event for inexistente, cancele.
  Remove o event desde a fila de eventos.
  Destrua o event.
  Repita. [o código acima]

Uma font é um conjunto com 
  Um nome e 
  Uma altura.

Um altura da fonte é uns twips. \ indicates line altura - o letras will fit nicely em uma caixa of this altura

Um font resource é um número identificador.

Um pé são 12 polegadas.

Etapas para que se format um número e um singular string ou um plural string Para uma string: \verificar
  Converta o número para a string.
  Posponha o caractere de espaço para a string.
  Se o número for 1, posponha o singular para a string.
  Se o número não for 1, posponha o plural para a string.

Um fração é um conjunto com 
  Um numerador número e 
  Um denominador número, e 
  Um topo número at o numerador e 
  Um base número at o denominador.

Um par de números fracionários é um conjunto com 
  Uma fração e 
  Uma segunda fração.

Um máximo divisor comum é um número.

Um figura geométrica é um figura.

Etapas para que se obtenha um abca e um abcc usando uma string e um canvas:
  Atribua 0 ao abca.
  Atribua 0 ao abcc.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O endereçamento desse abc.
  Atribua o abca deste abc ao abca.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste last endereço de memória do pedaço desta string 
    e O conteúdo deste last endereço de memória do pedaço desta string 
    e O endereçamento desse segunda abc.
  Atribua o abcc desta segunda abc ao abcc.

Etapas para que se obtenha um abca usando uma string e um canvas:
  Atribua 0 ao abca.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O conteúdo deste first endereço de memória do pedaço desta string 
    e O endereçamento desse abc.
  Atribua o abca deste abc ao abca.

Etapas para que se obtenha uns addrinfo routines:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "LoadLibraryA" com "ws2_32.dll"'s first endereço de memória do pedaço devolvendo um número identificador.
  Se o número identificador for 0, atribua "Não foi possível obter o valor do endereço de memória da biblioteca ws2_32.dll." ao erro do fluxo de entrada/saída; exit.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador \Um identificador para o módulo DLL que contém a função ou variável. 
    \A função LoadLibrary, LoadLibraryEx, LoadPackagedLibrary ou GetModuleHandle retorna esse identificador.
    e "getaddrinfo"'s first endereço de memória do pedaço [ponteiro para uma string constante]    \ O nome da função ou variável, ou o valor ordinal da função. 
    \Se este parâmetro for um valor ordinal, ele deve estar contido na word de ordem inferior; a word de ordem superior deve ser zero.
    devolvendo um endereço de memória. \ obtendo/recebendo/aguardando como resultado
  Se o endereço de memória for inexistente, atribua "Infelizmente essa rotinas só funciona no Windows XP ou superior." ao erro do fluxo de entrada/saída; exit.
  Atribua o endereço de memória ao getaddrinfo endereço de memória destas addrinfo routines.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador 
    e "freeaddrinfo"'s first endereço de memória do pedaço [ponteiro para uma string constante] 
    devolvendo o endereço de memória.
  Se o endereço de memória for inexistente, atribua "Infelizmente essas rotinas só funcionam no Windows XP ou numa versão superior do Windows." ao erro do fluxo de entrada/saída; exit.
  Atribua o endereço de memória ao freeaddrinfo endereço de memória destas addrinfo routines.

Etapas para que se obtenha uma caixa pelo caret em um text:
  Se o text for inexistente, zero a caixa; exit.
  Obtenha uma localização usando o caret deste text e o text.
  Atribua a localização e a localização ao caixa.
  Adicione a altura da linha deste text para a coordenada inferior desta caixa.
  Ajuste a caixa usando 0 e o tpp e 0 e - o tpp.
  Atribua a globalized origin deste text a um origin.
  Se a coordenada esquerda desta caixa for menor do que a coordenada X desta origin, atribua a coordenada X desta origin à coordenada esquerda desta caixa; atribua a coordenada X desta origin à coordenada direita desta caixa.
  Se o wrap detector deste text não estiver ativo, cancele.
  Limite a coordenada esquerda desta caixa para a coordenada esquerda deste text e a coordenada direita deste text.
  Limite a coordenada direita desta caixa para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas para que se obtenha uma caixa por um line:
  Atribua o start desta line ao canto superior esquerdo desta caixa.
  Atribua o end desta line ao canto inferior direito desta caixa.
  Normalize a caixa.

Etapas para que se obtenha uma caixa usando uma row e um text:
  Se o text for inexistente, zero a caixa; exit.
  Se a row for inexistente, zero a caixa; exit.
  Atribua a globalized origin deste text ao canto superior esquerdo desta caixa.
  Adicione o número da linha desta row menos 1 times a altura da linha deste text para a coordenada superior desta caixa.
  Atribua a coordenada direita deste text à coordenada direita desta caixa.
  Atribua a coordenada superior desta caixa mais a altura da linha deste text à coordenada inferior desta caixa.

Etapas para que se obtenha um bucket usando um bucket# e um catálogo:
    \ if o catálogo for inexistente, esvazie o bucket; exit. \ para make compilador faster
  Atribua o first bucket deste catálogo ao bucket.
  Adicione o bucket# times a magnitude desse conjunto de buckets para o bucket.

Etapas para que se obtenha um bucket usando um catálogo:
    \Se o catálogo for inexistente, esvazie o bucket; exit. \ para fazer o compilador mais rápido
  Se o bucket for inexistente, atribua o first bucket deste catálogo ao bucket; exit.
  Se o bucket for o last bucket deste catálogo, esvazie o bucket; exit.
  Adicione a magnitude desse conjunto de buckets para o bucket.

Etapas para que se obtenha um bucket usando uma string e um catálogo:
    \ if o catálogo for inexistente, esvazie o bucket; exit. \ para make compilador faster
  Obtenha um bucket# usando a string e o catálogo.
  Obtenha o bucket usando o bucket# e o catálogo.

Etapas para que se obtenha um bucket# usando uma string e um catálogo:
    \ based sobre o djb2 algorithm
    \ if o catálogo for inexistente, atribua 0 ao bucket#; exit. \ para make compilador faster
  Atribua a quantidade de caracteres desta string ao bucket#.
  Se o bucket# for 0, cancele.
  Adicione 5381 para o bucket#.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um pedaço.
    Lowercase o pedaço.
    Atribua o bucket# a um número.
    Desloque o bucket# left 5 bits.
    Adicione o número para o bucket#.
    Adicione o pedaço para o bucket#.
    Adicione 3 para o first endereço de memória do pedaço deste subtexto.
    Se o subtexto estiver em branco, pare.
  Repita. [o código acima]
  Conjuncione logicamente o bucket# com o maior número.
  Divida o bucket# pela contagem de buckets deste catálogo usando um quociente e o bucket#.

Etapas para que se obtenha um pedaço desde uma string:
  Se a string estiver em branco, atribua o null pedaço ao pedaço; exit.
  Atribua o conteúdo deste first endereço de memória do pedaço desta string ao pedaço.
  Remove o first pedaço desde a string.

Etapas para que se obtenha um pedaço desde uma string (backwards):
  Se a string estiver em branco, atribua o null pedaço ao pedaço; exit.
  Atribua o conteúdo deste last endereço de memória do pedaço desta string ao pedaço.
  Remove o last pedaço desde a string.

Etapas para que se obtenha um center localização usando uma localização e uma segunda localização:
  Atribua a localização e a segunda localização a um line.
  Atribua o center desta line ao center.

Etapas para que se obtenha uma cor usando uma localização:
  Call "gdi32.dll" "GetPixel" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um código da cor.
  Converta o código da cor para a cor.

Etapas para que se obtenha um column# usando uma row e uma localização e um text:
  Atribua 0 ao column#.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, atribua a quantidade de caracteres desta string desta row ao column#; exit. \ only happens sobre last row of text
  Crie o número da fonte of o memory canvas usando o font deste text.
  Obtenha um start largura e um subtexto usando a row e a localização e o text (for "get um column# usando uma row...").
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto é o last endereço de memória do pedaço desta string desta row, pare.
    Obtenha um largura usando o subtexto e o memory canvas.
    Adicione o start largura para o largura.
    Obtenha uma segunda largura usando o conteúdo deste last endereço de memória do pedaço deste subtexto e o memory canvas.
    Divida a segunda largura por 2.
    Subtraia a segunda largura desde o largura.
    Se a coordenada X desta localização for menor do que o largura, pare.
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Atribua o last endereço de memória do pedaço deste subtexto menos o first endereço de memória do pedaço desta string desta row mais 1 ao column#.
  Destrua o número da fonte of o memory canvas.

Etapas para que se obtenha uma contagem of items em um endereço completo no sistema de arquivos:
  Atribua 0 à contagem.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se obtenha um description por um endereço completo:
  Limpe o description.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Atribua o categoria da unidade de disco ao description.
  Obtenha um nome da unidade de disco pelo endereço completo.
  Se o nome da unidade de disco não estiver em branco, atribua o nome da unidade de disco ao description.
  Lowercase o description.

Etapas para que se obtenha um difference entre um par de números e uma segundo par de números:
  Atribua o par de números à difference.
  Subtraia a segundo par de números desde a difference.

Etapas para que se obtenha um difference entre um par de números e uma segundo par de números usando um malha par de números:
  Obtenha a difference entre o par de números e a segundo par de números.
  Arredonde a difference para a malha.

Etapas para que se obtenha um distance entre uma localização e uma segunda localização (approximate):
  Atribua a coordenada X desta localização menos o x desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos o y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número times o número ao distance.
  Adicione o segundo número times o segundo número para o distance.
  Encontre um square root of o distance.
  Atribua o square root ao distance.
  Se a tecla D/d estiver sendo pressionada, produza o relatório de informações usando o distance.

Etapas para que se obtenha um distance entre uma localização e uma segunda localização (chessboard):
  Atribua a coordenada X desta localização menos a coordenada X desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos a coordenada Y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número ao distance.
  Se o segundo número for maior do que o número, atribua o segundo número ao distance.

Etapas para que se obtenha um categoria da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetDriveTypeA" com 
    O first deste endereço completo 
    devolvendo um número.
  Se o número for 2 [DRIVE_REMOVABLE], atribua "Disco removível" à categoria da unidade de disco; exit. \ removable drive
  Se o número for 3 [DRIVE_FIXED], atribua "Disco Rígido / Pendrive" à categoria da unidade de disco; exit.\ hard disk / flash drive
  Se o número for 4 [DRIVE_REMOTE], atribua "Unidade de rede" à categoria da unidade de disco; exit. \ network drive
  Se o número for 5 [DRIVE_CDROM], atribua "Unidade de CD/DVD" à categoria da unidade de disco; exit. \ cd-rom / dvd drive
  Se o número for 6 [DRIVE_RAMDISK], atribua "Unidade de disco RAM" à categoria da unidade de disco; exit. \ unidade virtual de disco criada a partir da RAM
  Atribua "" à categoria da unidade de disco.

Etapas para que se obtenha um nome da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Atribua 512 a uma quantidade de caracteres.
  Reassign o first endereço de memória do pedaço desse trecho usando a quantidade de caracteres.
  Call "kernel32.dll" "GetVolumeInformationA" com 
    O first deste endereço completo 
    e O first endereço de memória do pedaço deste trecho
   e a quantidade de caracteres 
   e 0 
   e 0 
   e 0 
   e 0 
   e 0 devolvendo um número.
  Se o número for 0, limpe o nome da unidade de disco; exit.
  Converta o first deste trecho como um pchar para o nome da unidade de disco.

Etapas para que se obtenha o first-eighth equivalent of uma orientação:
  Obtenha o first-quarter equivalent of a orientação.
  Se a orientação for menor do que 480, cancele.
  Subtraia 960 desde a orientação.
  De-sign a orientação.

Etapas para que se obtenha o first-quarter equivalent of uma orientação:
  Se a orientação for menor do que 960, cancele.
  Subtraia 960 desde a orientação.
  Repita. [o código acima]

Etapas para que se obtenha fresh random números;
Etapas para que se obtenha new random números;
Etapas para que se seed o número aleatório generator:
  Atribua a contagem de ticks do sistema à seed.

Etapas para que se obtenha um máximo divisor comum usando um número e um segundo número:
  Atribua o número a um dividend número.
  Atribua o segundo número ao máximo divisor comum.
  De-sign o dividend número.
  De-sign o máximo divisor comum.
  Se o dividend for menor do que o máximo divisor comum, permute o dividend com o máximo divisor comum.
  Se o máximo divisor comum for 0, atribua 1 ao máximo divisor comum; exit.
  Percorra. [o código abaixo]
    Divida o dividend pelo máximo divisor comum usando um quociente e um resto.
    Se o resto for 0, cancele.
    Atribua o máximo divisor comum ao dividend.
    Atribua o resto ao máximo divisor comum.
  Repita. [o código acima]

Etapas para que se obtenha um Endereço IP usando um host string:
  Limpe o Endereço IP.
  Obtenha um sockaddr usando o host string.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua o s_addr deste sin_addr deste sockaddr ao número deste Endereço IP.
  Call "ws2_32.dll" "inet_ntoa" com 
    O número deste Endereço IP 
    devolvendo um pchar.
  Converta o pchar para a string deste Endereço IP.

Etapas para que se obtenha um item (not first time):
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "FindNextFileA" com 
    O número identificador deste item 
    e O endereçamento deste WIN32FINDDATA deste item 
    devolvendo um número.
  Se o número não for 0, ajuste o item; exit.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindClose" com 
    O número identificador deste item.

Etapas para que se obtenha um item desde um endereço completo:
  Se o endereço completo não for endereço da pasta-format, cancele.
  Atribua o endereço completo ao endereço da pasta deste item.
  Se a categoria deste item estiver em branco, obtenha o item desde o endereço completo (first time); exit.
  Obtenha o item (not first time).

Etapas para que se obtenha um item desde um endereço completo (first time):
  Limpe o erro do fluxo de entrada/saída.
  Isole o endereço completo.
  Posponha "*.*" para o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindFirstFileA" com 
    O first deste endereço completo 
    e O endereçamento deste WIN32FINDDATA deste item 
    devolvendo o número identificador deste item.
  Se o número identificador deste item for -1 [INVALID_HANDLE_VALUE], cancele.
  Ajuste o item.

Etapas para que se obtenha um mínimo múltiplo comum usando um número e um segundo número:
  Obtenha um máximo divisor comum usando o número e o segundo número.
  Call "kernel32.dll" "MulDiv" com 
    O número 
    e O segundo número 
    e O máximo divisor comum 
    devolvendo o mínimo múltiplo comum.

Etapas para que se obtenha um letra desde o alphabet:
  Atribua o next letra ao letra.
  Avance o next letra limiting it para o 'A' maiúsculo e o Z maiúsculo.
  Adicione 1 para o next letra.
  Se o next letra for maior do que o Z maiúsculo, atribua o 'A' maiúsculo à next letra.

Etapas para que se obtenha um número desde a stack:
  Atribua 0 ao número.
  Obtenha um stack entry desde o stack.
  Se a stack entry for inexistente, cancele.
  Converta a string desta stack entry para o número.
  Remove a stack entry desde o stack.
  Destrua a stack entry.

Etapas para que se obtenha um offset par de números usando uma string e uma caixa e uma font e um alinhamento:
  Crie o número da fonte of o memory canvas usando o font.
  Obtenha o offset par de números usando a string e a caixa e o font e o alinhamento (fast).
  Destrua o número da fonte of o memory canvas.

Etapas para que se obtenha um offset par de números usando uma string e uma caixa e uma font e um alinhamento (fast):
  Se o alinhamento for "left", obtenha o número X deste offset par de números usando a string e a caixa (fast - left).
  Se o alinhamento for "right", obtenha o número X deste offset par de números usando a string e a caixa (fast - right).
  Se o alinhamento for "center", obtenha o número X deste offset par de números usando a string e a caixa (fast - center).
  Call "gdi32.dll" "GetTextMetricsA" com 
    O memory canvas 
    e O endereçamento desse textmetric.
  Adicione a altura desta caixa menos a tmheight deste textmetric dividido por 2 para o número Y deste offset par de números.

Etapas para que se obtenha uma position usando uma localização e um text:
  Se o text for inexistente, limpe o position; exit.
  Obtenha uma row usando a localização e o text.
  Atribua o número da linha desta row ao número da linha desta position.
  Obtenha o column# desta position usando a row e a localização e o text.

Etapas para que se obtenha um endereço de memória RGB desde um bitmapdata at um número da linha e um column#:
    \ 1 based
  Atribua o scan0 deste bitmapdata ao endereço de memória RGB.
  Adicione o número da linha menos 1 times o stride deste bitmapdata para o endereço de memória RGB.
  Adicione o column# menos 1 times a magnitude desse espaço de cor RGB para o endereço de memória RGB.

Etapas para que se obtenha um deslocamento vertical e um deslocamento horizontal usando uma orientação: \deslocamento horizontal e vertical?
    \ veja https://pt.wikipedia.org/wiki/Trigonometria_racional
    \ https://pt.wikipedia.org/wiki/Física_digital
    \ A trigonometria racional evita o uso direto de funções transcendentes, como seno e cosseno, substituindo-as por seus equivalentes quadráticos.
  Isole a orientação.
  Normalize a orientação.
  Normalize o original orientação.
  Se a orientação não for uniformemente divisível por 20, estime o deslocamento vertical e o deslocamento horizontal usando a orientação; exit.
    \ special cases
  Se a orientação for 0, atribua -10000 ao deslocamento vertical; atribua -0 ao deslocamento horizontal; exit. \ 0 graus
  Se a orientação for 960, atribua 10000 ao deslocamento horizontal; atribua -0 ao deslocamento vertical; exit. \ 90 graus
  Se a orientação for 1920, atribua 10000 ao deslocamento vertical; atribua 0 ao deslocamento horizontal; exit. \ 180 graus
  Se a orientação for 2880, atribua -10000 ao deslocamento horizontal; atribua 0 ao deslocamento vertical; exit. \ 270 graus
  Se a orientação for 3840, produza o relatório de informações usando "orientação inválida"; produza o relatório de informações usando a orientação; produza o relatório de informações usando o original orientação.
    \ force it ao first eighth of o circle
  Obtenha o first-eighth equivalent of a orientação.
    \ encontre o first eighth of o circle unsigned values
  Se a orientação for 20, atribua 0327 ao deslocamento horizontal; atribua 9995 ao deslocamento vertical; break. \ 1.875 degrees
  Se a orientação for 40, atribua 0654 ao deslocamento horizontal; atribua 9979 ao deslocamento vertical; break. \ 3.75 degrees
  Se a orientação for 60, atribua 0980 ao deslocamento horizontal; atribua 9952 ao deslocamento vertical; break. \ 5.625 degrees = 1/64 of o way
  Se a orientação for 80, atribua 1305 ao deslocamento horizontal; atribua 9914 ao deslocamento vertical; break. \7.5 degrees
  Se a orientação for 100, atribua 1629 ao deslocamento horizontal; atribua 9866 ao deslocamento vertical; break. \ 9.375 degrees
  Se a orientação for 120, atribua 1951 ao deslocamento horizontal; atribua 9808 ao deslocamento vertical; break. \ 11.25 degrees = 2/64 of o way
  Se a orientação for 140, atribua 2271 ao deslocamento horizontal; atribua 9739 ao deslocamento vertical; break. \ 13.125 degrees
  Se a orientação for 160, atribua 2588 ao deslocamento horizontal; atribua 9659 ao deslocamento vertical; break. \ 15 degrees
  Se a orientação for 180, atribua 2903 ao deslocamento horizontal; atribua 9569 ao deslocamento vertical; break. \ 16.875 degrees = 3/64 of o way
  Se a orientação for 200, atribua 3214 ao deslocamento horizontal; atribua 9469 ao deslocamento vertical; break. \ 18.75 degrees
  Se a orientação for 220, atribua 3523 ao deslocamento horizontal; atribua 9359 ao deslocamento vertical; break. \ 20.625 degrees
  Se a orientação for 240, atribua 3827 ao deslocamento horizontal; atribua 9239 ao deslocamento vertical; break. \ 22.5 degrees = 4/64 of o way
  Se a orientação for 260, atribua 4127 ao deslocamento horizontal; atribua 9109 ao deslocamento vertical; break. \ 24.375 degrees
  Se a orientação for 280, atribua 4423 ao deslocamento horizontal; atribua 8969 ao deslocamento vertical; break. \ 26.25 degrees
  Se a orientação for 300, atribua 4714 ao deslocamento horizontal; atribua 8819 ao deslocamento vertical; break. \ 28.125 degrees = 5/64 of o way
  Se a orientação for 320, atribua 5000 ao deslocamento horizontal; atribua 8660 ao deslocamento vertical; break. \ 30 degrees
  Se a orientação for 340, atribua 5281 ao deslocamento horizontal; atribua 8492 ao deslocamento vertical; break. \ 31.875 degrees
  Se a orientação for 360, atribua 5556 ao deslocamento horizontal; atribua 8315 ao deslocamento vertical; break. \ 33.75 degrees = 6/64 of o way
  Se a orientação for 380, atribua 5825 ao deslocamento horizontal; atribua 8128 ao deslocamento vertical; break. \ 35.625 degrees
  Se a orientação for 400, atribua 6088 ao deslocamento horizontal; atribua 7934 ao deslocamento vertical; break. \ 37.5 degrees
  Se a orientação for 420, atribua 6344 ao deslocamento horizontal; atribua 7730 ao deslocamento vertical; break. \ 39.375 degrees = 7/64 of o way
  Se a orientação for 440, atribua 6593 ao deslocamento horizontal; atribua 7518 ao deslocamento vertical; break. \ 41.25 degrees
  Se a orientação for 460, atribua 6836 ao deslocamento horizontal; atribua 7299 ao deslocamento vertical; break. \ 43.125 degrees
  Se a orientação for 480, atribua 7071 ao deslocamento horizontal; atribua 7071 ao deslocamento vertical; break. \ 45 degrees = 8/64 of o way
  Repita. [o código acima] \ não é realmente um comando de repetição, é apenas um marcador para as "breaks" aí de cima.
    \ ajuste por segunda eighths of o circle
  Se o original orientação estiver entre 0 e 480, negate o deslocamento vertical; exit. \ 1st eighth (12:00 para 1:30)
  Se o original orientação estiver entre 480 e 960, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento vertical; exit. \ 2nd eighth (1:30 para 3:00)
  Se o original orientação estiver entre 960 e 1440, permute o deslocamento horizontal com o deslocamento vertical; exit. \ 3rd eighth (3:00 para 4:30)
  Se o original orientação estiver entre 1440 e 1920, cancele. \ 4th eighth (4:30 para 6:00)
  Se o original orientação estiver entre 1920 e 2400, negate o deslocamento horizontal; exit. \ 5th eighth (6:00 para 7:30)
  Se o original orientação estiver entre 2400 e 2880, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; exit. \ 6th eighth (7:30 para 9:00)
  Se o original orientação estiver entre 2880 e 3360, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; negate o deslocamento vertical; exit. \ 7th eighth (9:00 para 10:30)
  Se o original orientação estiver entre 3360 e 3840, negate o deslocamento horizontal; negate o deslocamento vertical; exit. \ 8th eighth (10:30 para 12:00)

Etapas para que se obtenha uma row usando um número da linha e um text:
  Esvazie a row.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha a row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for o número da linha, cancele.
  Repita. [o código acima]

Etapas para que se obtenha uma row usando uma localização e um text:
  Se o text for inexistente, esvazie a row; exit.
  Atribua a coordenada Y desta localização a uma coordenada Y.
  Limite a coordenada Y para a coordenada superior deste text e a coordenada inferior deste text.
  Atribua a coordenada Y menos a coordenada Y desta globalized origin deste text dividido pela altura da linha deste text mais 1 a um número da linha.
  Limite o número da linha para 1 e a contagem de linhas deste text.
  Obtenha a row usando o número da linha e o text.

Etapas para que se obtenha uma caixa de seleção usando uma row e um text:
  Limpe a caixa de seleção.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Atribua a caixa ao caixa de seleção.
  Obtenha a caixa de seleção usando a row e o text (lado esquerdo).
  Obtenha a caixa de seleção usando a row e o text (lado direito).

Etapas para que se obtenha uma caixa de seleção usando uma row e um text (lado esquerdo):
  Atribua a normalized seleção deste text a uma seleção.
  Atribua a coordenada X desta globalized origin deste text à coordenada esquerda desta caixa de seleção.
  Se o anchor número da linha desta seleção for o número da linha desta row, obtenha uma localização usando o anchor desta seleção e o text; atribua a coordenada X desta localização à coordenada esquerda desta caixa de seleção.
  Limite a coordenada esquerda desta caixa de seleção para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas para que se obtenha uma caixa de seleção usando uma row e um text (lado direito):
  Atribua a normalized seleção deste text a uma seleção.
  Atribua a coordenada direita deste text à coordenada direita desta caixa de seleção.
  Se o número de linhas do cursor desta seleção for o número da linha desta row, obtenha uma localização usando o caret desta seleção e o text; atribua a coordenada X desta localização à coordenada direita desta caixa de seleção.
  Limite a coordenada direita desta caixa de seleção para a coordenada esquerda deste text e a coordenada direita deste text.

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, obtenha o size usando o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo for file-format, obtenha o size usando o endereço completo no sistema de arquivos (arquivo).

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos (pasta)[endereço]:
  Atribua 0 ao size.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for found, cancele.
    Se a categoria deste item for "arquivo", adicione o size deste item para o size; repita.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Obtenha uma segunda size usando a segunda endereço completo no sistema de arquivos.
    Adicione a segunda size para o size.
  Repita. [o código acima]

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesExA" com 
    O first deste endereço completo 
    e 0 
    e O endereçamento desse WIN32FINDDATA.
  Atribua o nFileSizeLow deste WIN32FINDDATA ao size.

Etapas para que se obtenha um sockaddr usando um host string:
  Limpe o erro do fluxo de entrada/saída.
    \ prepare strings
  Isole o host string.
  Modifique através do caractere NUL o host string.
    \ obtenha o function addresses
  Obtenha uns addrinfo routines.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
    \ obtenha o sockaddr
  Atribua 2 [AF_INET] ao ai_family desse addrinfo.
  Atribua 1 [SOCK_STREAM] ao ai_sockettype deste addrinfo.
  Atribua 6 [IPPROTO_TCP] ao ai_protocol deste addrinfo.
  Call o getaddrinfo destas addrinfo routines com 
    O first endereço de memória do pedaço desta host string 
    e 0 e o endereçamento deste addrinfo
   e o endereçamento desse addrinfoptr 
     devolvendo um result número.
  Se o result número não for 0, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; exit.
  Se o addrinfoptr for inexistente, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; exit.
  Atribua o conteúdo deste ai_addr deste addrinfoptr ao sockaddr.
  Call o freeaddrinfo destas addrinfo routines com o addrinfoptr.

Etapas para que se obtenha uma localização usando uma position e um text:
  Limpe a localização.
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número da linha desta position e o text.
  Obtenha uma caixa usando a row e o text.
  Atribua a coordenada superior desta caixa à coordenada y desta localização.
  Atribua o first endereço de memória do pedaço desta string desta row ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto mais o column# desta position menos 2 ao last endereço de memória do pedaço deste subtexto.
  Obtenha um largura usando o subtexto e o memory canvas e o font deste text.
  Atribua a coordenada esquerda desta caixa mais o largura à coordenada x desta localização.
  Obtenha um offset par de números usando o working string desta row e a caixa e a font deste text e o alinhamento deste text.
  Adicione o número X deste offset par de números para a coordenada X desta localização.

Etapas para que se obtenha um start largura e um subtexto usando uma row e uma localização e um text (for "get um column# usando uma row..."):
  Limpe o start largura.
  Limpe o subtexto.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Lance o subtexto sobre o working string desta row.
  Obtenha um offset par de números usando o subtexto e a caixa e a font deste text e o alinhamento deste text (fast).
  Atribua a coordenada X desta globalized origin deste text mais o número X deste offset par de números ao start largura.
  Atribua o first endereço de memória do pedaço deste subtexto mais o text cutoff menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que ou igual ao last endereço de memória do pedaço desta string desta row, pare.
    Obtenha um largura usando o subtexto e o memory canvas.
    Atribua o start largura mais o largura a uma segunda largura.
    Se a coordenada X desta localização for menor do que ou igual ao segunda largura, pare.
    Adicione o largura para o start largura.
    Mova o subtexto usando o text cutoff.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto ao last endereço de memória do pedaço deste subtexto.

Etapas para que se obtenha uma string desde o stack:
  Limpe a string.
  Obtenha um stack entry desde o stack.
  Se o stack entry for inexistente, atribua "ERRO" à string; exit.
  Atribua a string desta stack entry para a string.
  Remove o stack entry desde o stack.
  Destrua o stack entry.

Etapas para que se obtenha uma string desde a área de transferência do Windows:
  Limpe a string.
  Call "user32.dll" "OpenClipboard" com 
    A main window.
  Call "user32.dll" "GetClipboardData" com 
  1 [CF_TEXT] 
    devolvendo um número identificador.
  Se o número identificador for 0, call "user32.dll" "CloseClipboard"; exit.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador 
    devolvendo um pchar.
  Converta o pchar para a string.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "user32.dll" "CloseClipboard".

Etapas para que se obtenha uma coisa desde umas coisas:
  Se  as coisas estiverem vazio, esvazie a coisa; exit.
  Se a coisa for inexistente, atribua o first destas coisas à coisa; exit.
  Atribua o next desta coisa à coisa.

Etapas para que se obtenha uma coisa desde umas coisas (backwards):
  Se  as coisas estiverem vazio, esvazie a coisa; exit.
  Se a coisa for inexistente, atribua o last destas coisas à coisa; exit.
  Atribua o previous desta coisa à coisa.

Etapas para que se obtenha um segmento inicial desde um reply:
  Remove algum tipo de leading noise desde o reply.
  Limpe o segmento inicial.
  Percorra. [o código abaixo]
    Se o reply estiver em branco, cancele.
    Obtenha um pedaço desde o reply.
    Se o pedaço for o caractere de espaço, cancele.
    Posponha o pedaço para o segmento inicial.
  Repita. [o código acima]

Etapas para que se obtenha um largura usando um pedaço e um canvas:
  Call "gdi32.dll" "GetTextExtentPoint32A" com 
    O canvas 
    e O endereçamento deste pedaço 
    e 1 
    e O endereçamento desse par de números.
  Atribua o número X deste par de números à largura.

Etapas para que se obtenha um largura usando um pedaço e uns font larguras:
  Atribua o pedaço a um número.
  Obtenha o largura usando o número e o font larguras.

Etapas para que se obtenha um largura usando um número e uns font larguras:
    \ indexes são 0 based
  Se o font larguras são nil, limpe o largura; exit.
  Atribua o data destes font larguras a um endereço numérico.
  Adicione o número times a magnitude deste número para o endereço numérico.
  Atribua o conteúdo deste endereço numérico ao largura.

Etapas para que se obtenha um largura usando uma string e um canvas:
    \ assumes font é already selecionado em canvas
  Call "gdi32.dll" "GetTextExtentPoint32A" com 
    O canvas 
    e O first endereço de memória do pedaço desta string 
    e A quantidade de caracteres desta string 
    e O endereçamento desse par de números.
  Atribua o número X deste par de números ao largura.

Etapas para que se obtenha um largura usando uma string e um canvas e um font:
  Crie o número da fonte of o canvas usando o font.
  Obtenha o largura usando a string e o canvas.
  Destrua o número da fonte of o canvas.

Etapas para que se obtenha um largura usando uma string e um font:
    \ assumes memory canvas
  Obtenha o largura usando a string e o memory canvas e o font.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - center):
  Obtenha um largura usando a string e o memory canvas.
  Obtenha um abca e um abcc usando a string e o memory canvas.
  Atribua o largura menos o abca menos o abcc ao largura.
  Atribua a largura desta caixa menos o largura dividido por 2 menos o abca à coordenada x.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - left):
  Obtenha um abca usando a string e o memory canvas.
  Atribua - o abca à coordenada x.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - right):
  Obtenha um abca e um abcc usando a string e o memory canvas.
  Obtenha um largura usando a string e o memory canvas.
  Atribua o largura menos o abca menos o abcc ao largura.
  Atribua a largura desta caixa menos o largura menos o abca à coordenada x.

Um gigabyte é 1024 megabytes.

Etapas para que se globalize uma caixa usando um par de números:
  Mova a caixa usando o par de números.

Etapas para que se globalize uma localização usando um par de números:
  Mova a localização usando o par de números.

Etapas para que se go back para where we were:
  Restore o context.

Um GpBitmap é um GpImage.

Um GpGraphic é um endereço de memória.

Um GpImage é um endereço de memória.

An GpImageAttributes é um endereço de memória.

Um GpRect é um conjunto com
  Um número denominado x,
  Um número denominado y,
  Um número denominado largura,
  Um número denominado altura.

O gptoken é um gptoken.

Um gptoken é um número.

An grain é 10 milliseconds.

Um malha é um par de números.

Etapas para que se garanta one row em um text:
  Se o text for inexistente, cancele.
  Se as rows deste text não estiverem vazio, cancele.
  Crie uma row usando o return pedaço.
  Posponha a row para as rows deste text.
  Renumber as rows deste text.

Um guid é um UUID. \ identificador único global

O hand cursor é um cursor.

Etapas para que se mude alinhamento usando um text e um alinhamento:
  Se o text for inexistente, cancele.
  Relembre o text com "alinhamento".
  Align o text usando o alinhamento.

Etapas para que se execute algum tipo de wm-activate com um w-param:
  Split o w-param a um word e uma segunda word.
  Atribua a segunda word a um número.
  Se o número for 0, execute algum tipo de wm-activate com o w-param (deactivate); exit.
  Execute algum tipo de wm-activate com o w-param (activate).

Etapas para que se execute algum tipo de wm-activate com um w-param (activate):
  Call "user32.dll" "SetFocus" com 
    A main window.
  Call "user32.dll" "ClipCursor" com 
  0.
    \ seterrormode(sem_failcriticalerrors) \ keeps certain disk erros desde appearing
  Crie um event.
  Atribua "activate" à categoria deste event.
    \Atribua "activar" à categoria deste event.
  Enfileire o event.
  Call "user32.dll" "PostMessageA" com 
    A main window 
    e 0 [wm_null] 
    e 0 
    e 0.

Etapas para que se execute algum tipo de wm-activate com um w-param (deactivate):
  Crie um event.
  Atribua "deactivate" à categoria deste event.
    \Atribua "desactivar" à categoria deste event.
  Enfileire o event.
  Call "user32.dll" "PostMessageA" com 
    A main window 
    e 0 [wn_null] 
    e 0 
    e 0.

Etapas para que se execute algum tipo de wm-char com um w-param e um l-param:
    \Se a tecla Alt was para baixo, cancele. \ removed por Spanish teclaboard AltGr e ctrl+alt characters
    \Se a tecla Ctrl was para baixo, cancele. \ removed por Spanish teclaboard AltGr e ctrl+alt characters
  Atribua o w-param a um pedaço.
  Se o pedaço não for printable, cancele.
  Crie um event.
  Atribua "pressionamento de tecla" à categoria deste event.
    \Atribua "tecla abajo" à categoria deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Atribua o pedaço ao pedaço deste event.
  Converta o l-param para a tecla deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de wm-create com um window:
  Atribua a window à main window.

Etapas para que se execute algum tipo de wm-destroy:
  Call "user32.dll" "PostQuitMessage" com 
  0.

Etapas para que se execute algum tipo de wm-lbuttondblclk com um l-param:
  Crie um event.
  Atribua "clique duplo" à categoria deste event.
    \Atribua "clic izquierdo doble" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o l-param para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de wm-lbuttondown com um l-param:
  Crie um event.
  Atribua "clique" à categoria deste event.
    \Atribua "clic izquierdo" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o l-param para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de wm-paint com um window:
  Call "user32.dll" "BeginPaint" com 
    A window 
    e O endereçamento desse paintstruct.
  Call "user32.dll" "EndPaint" com 
    A window 
    e O endereçamento desta paintstruct.
  Crie um event.
  Atribua "atualização de tela" à categoria deste event.
    \Atribua "refrescar" à categoria deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de wm-rbuttondblclk com um l-param:
  Crie um event.
  Atribua "clique direito duplo" à categoria deste event.
    \Atribua "clic derecho doble" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o l-param para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de wm-rbuttondown com um l-param:
  Crie um event.
  Atribua "clique direito" à categoria deste event.
    \Atribua "clic derecho" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Converta o l-param para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de wm-setcursor:
  Atualize o cursor.

Etapas para que se execute algum tipo de wm-syskeydown com um w-param e um l-param;
Etapas para que se execute algum tipo de wm-keydown com um w-param e um l-param:
  Atribua o w-param a um tecla.
  Se a tecla com o l-param é algum tipo de comando de repetiçãoed escape ou modifier tecla, cancele.
  Se a tecla for algum tipo de wm-char tecla, cancele.
  Crie um event.
  Atribua "pressionamento de tecla" à categoria deste event.
    \Atribua "tecla abajo" à categoria deste event.
  Se a tecla Alt was para baixo, acione o detector de tecla alt deste event.
  Se a tecla Ctrl was para baixo, acione o detector de tecla ctrl deste event.
  Se a tecla Shift was para baixo, acione o detector de tecla Shift deste event.
  Atribua a tecla à tecla deste event.
  Enfileire o event.

Etapas para que se execute capitalize usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "capitalize".
  Capitalize algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se efetue cópias usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Extraia uma string desde o text (pedaços selecionados).
  Atribua a string sobre o área de transferência do Windows.

Etapas para que se execute cut usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text.
  Extraia uma string desde o text (pedaços selecionados).
  Atribua a string sobre o área de transferência do Windows.
  Remove algum tipo de pedaços selecionados no text.
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um console:
  Se o console for inexistente, cancele.
  Se a categoria deste event for "pressionamento de tecla", execute o event usando o console (pressionamento de tecla); exit.
  Se a categoria deste event for "atualização de tela", execute o event usando o console (atualização de tela); exit.
  Se a categoria deste event for "clique direito", execute o event usando o console (clique direito); exit.
  Se a categoria deste event for "mostrar seta", execute o event usando o console (mostrar seta do mouse); exit.

Etapas para que se execute um event usando um console (tecla backspace):
  Se o reply deste console estiver em branco, cancele.
  Se o event foi alterado, cancele.
  Execute o event usando o text deste console (tecla backspace).
  Remove o last pedaço desde o reply deste console.
  Mostre o console.

Etapas para que se execute um event usando um console (seta pra baixo):
  Role o text deste console para baixo one line.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla End):
  Role o text deste console para o base.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Enter):
  Execute o event usando o text deste console (tecla Enter).
  Relinquish control.

Etapas para que se execute um event usando um console (tecla Home):
  Role o text deste console para o topo.
  Mostre o console.

Etapas para que se execute um event usando um console (pressionamento de tecla):
  Se a tecla deste event for a tecla backspace, execute o event usando o console (tecla backspace); exit.
  Se a tecla deste event for a seta pra baixo, execute o event usando o console (seta pra baixo); exit.
  Se a tecla deste event for a tecla End, execute o event usando o console (tecla End); exit.
  Se a tecla deste event for a tecla Enter, execute o event usando o console (tecla Enter); exit.
  Se a tecla deste event for a tecla Home, execute o event usando o console (tecla Home); exit.
  Se a tecla deste event for a tecla PgDn, execute o event usando o console (tecla Page Down); exit.
  Se a tecla deste event for a tecla PgUp, execute o event usando o console (tecla Page Up); exit.
  Se a tecla deste event for a seta pra cima, execute o event usando o console (seta pra cima); exit.
  Se o pedaço deste event não for printable, cancele.
  Posponha o pedaço deste event para o reply deste console.
  Execute o event usando o text deste console (caracteres gráficos).
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Page Down):
  Role o text deste console para baixo one página.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Page Up):
  Role o text deste console para cima one página.
  Mostre o console.

Etapas para que se execute um event usando um console (atualização de tela):
  Mostre o console.

Etapas para que se execute um event usando um console (clique direito):
  Mostre o hand cursor.
  Role o console usando o event.
  Atualize o cursor.

Etapas para que se execute um event usando um console (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas para que se execute um event usando um console (seta pra cima):
  Role o text deste console para cima one line.
  Mostre o console.

Etapas para que se execute um event usando um terminal:
  Se o terminal for inexistente, cancele.
  Se a categoria deste event for "pressionamento de tecla", execute o event usando o terminal (pressionamento de tecla); exit.
  Se a categoria deste event for "atualização de tela", execute o event usando o terminal (atualização de tela); exit.
  Se a categoria deste event for "mostrar seta", execute o event usando o terminal (mostrar seta do mouse); exit.
  Se a categoria deste event for "clique", relinquish control. \ *** added por invisível turtle book questionable

Etapas para que se execute um event usando um terminal (tecla backspace):
  Se o reply deste terminal estiver em branco, cancele.
  Se o event foi alterado, cancele.
  Remove o last pedaço desde o reply deste terminal.
  Remove o last pedaço desde a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (tecla Enter):
  Relinquish control. \Abdique

Etapas para que se execute um event usando um terminal (pressionamento de tecla):
  Se a tecla deste event for a tecla backspace, execute o event usando o terminal (tecla backspace); exit.
  Se a tecla deste event for a tecla Enter, execute o event usando o terminal (tecla Enter); exit.
  Se o pedaço deste event não for printable, cancele.
  Posponha o pedaço deste event para o reply deste terminal.
  Posponha o pedaço deste event para a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (atualização de tela):
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas para que se execute um event usando um text (tecla backspace):
  Se o text for inexistente, cancele.
  Se não existir something para backspace no text, cancele.
  Relembre o text com "backspace".
  Se o event foi alterado, remova pedaços de o text (backspace com jump).
  Se o event não foi alterado, remova pedaços de o text (backspace).
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Delete):
  Se o text for inexistente, cancele.
  Se não existir something para remove no text, cancele.
  Relembre o text com "delete".
  Se o event foi alterado, remova pedaços de o text (forward delete com jump).
  Se o event não foi alterado, remova pedaços de o text (forward delete).
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (seta pra baixo):
  Se o text for inexistente, cancele.
  Se o caret of o text é sobre o last line, acione um detector.
  Se o detector estiver ativo, mova o caret para o last pedaço of o text.
  Se o detector não estiver ativo, mova o caret para baixo no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla End):
  Se o text for inexistente, cancele.
  Se o event foi alterado, mova o caret para o last pedaço of o text.
  Se o event não foi alterado, mova o caret para o last pedaço of o current row of o text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Enter):
  Se o text for inexistente, cancele.
  Relembre o text com "insert return".
  Remove algum tipo de pedaços selecionados no text.
  Insira o return pedaço ao text.
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Esc):
  Se o text for inexistente, cancele.
  Desvencilhe-se de o text.

Etapas para que se execute um event usando um text (tecla Home):
  Se o text for inexistente, cancele.
  Se o event foi alterado, mova o caret para o first pedaço of o text.
  Se o event não foi alterado, mova o caret para o first pedaço of o current row of o text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (clique duplo):
  Se o text for inexistente, cancele.
  Desvencilhe-se de o text.
  Mova o caret right para algum tipo de non-alfanumérico pedaço no text.
  Mova o anchor left para algum tipo de non-alfanumérico pedaço no text.

Etapas para que se execute um event usando um text (seta esquerda):
  Se o text for inexistente, cancele.
  Se o event foi alterado, jump o caret left no text.
  Se o event não foi alterado, mova o caret left no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Page Down):
  Se o text for inexistente, cancele.
  Role o text para baixo one página.
  Mova o caret para baixo one página no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.

Etapas para que se execute um event usando um text (tecla Page Up):
  Se o text for inexistente, cancele.
  Role o text para cima one página.
  Mova o caret para cima one página no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.

Etapas para que se execute um event usando um text (caracteres gráficos):
  Relembre o text com "insert".
  Remove algum tipo de pedaços selecionados no text.
  Insira o pedaço deste event ao text.
  Wrap o text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (seta direita):
  Se o text for inexistente, cancele.
  Se o event foi alterado, jump o caret right no text.
  Se o event não foi alterado, mova o caret right no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (tecla Tab):
  Se o text for inexistente, cancele.
  Relembre o text com "insert".
  Remove algum tipo de pedaços selecionados no text.
  Insira o caractere de espaço ao text.
  Divida o caret column# deste text por 2 usando um quociente e um resto.
  Se o resto for 0, insira o caractere de espaço ao text.
  Role o text para o caret.

Etapas para que se execute um event usando um text (seta pra cima):
  Se o text for inexistente, cancele.
  Mova o caret para cima no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o caret.

Etapas para que se execute events usando um console:
  Se o console for inexistente, cancele.
  Percorra. [o código abaixo]
    Desenfileire um event.
    Se o event for inexistente, cancele.
    Execute o event usando o console.
  Repita. [o código acima]

Etapas para que se execute events usando um terminal:
  Se o terminal for inexistente, cancele.
  Percorra. [o código abaixo]
    Desenfileire um event.
    Se o event for inexistente, cancele.
    Execute o event usando o terminal.
  Repita. [o código acima]

Etapas para que se mude tamanho usando um text e uma caixa e uma altura da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "altura da fonte".
  Mude o text usando a caixa.
  Mude o text usando o altura da fonte.

Etapas para que se mude tamanho usando um text e uma altura da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "altura da fonte".
  Mude o text usando o altura da fonte.

Etapas para que se mude nome da fonte usando um text e uma nome da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "nome da fonte".
  Mude o text usando o nome da fonte.

Etapas para que se execute indent usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "dent".
  Indent algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Um número identificador é um número.

Etapas para que se execute lowercase usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "case".
  Lowercase algum tipo de pedaços selecionados no text.
  Wrap o text.

Etapas para que se execute outdent usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "dent".
  Outdent algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute paste usando um text:
  Se o text for inexistente, cancele.
  Se não existir text sobre o área de transferência do Windows, cancele.
  Relembre o text.
  Remove algum tipo de pedaços selecionados no text.
  Obtenha uma string desde o área de transferência do Windows.
  Insira a string ao text.
  Wrap o text.
  Role o text para o caret.

Etapas para que se efetue alteração de cor usando um text e uma cor:
  Se o text for inexistente, cancele.
  Relembre o text com "pincel".
  Atribua a cor ao pincel deste text.

Etapas para que se execute redo usando um text:
  Se o text for inexistente, cancele.
  Se o last destes redos deste text for inexistente, cancele.
  Copie o text a uma segunda text.
  Posponha a segunda text para os undos deste text.
  Atribua o last destes redos deste text a um terceiro text.
  Remove o terceiro text desde os redos deste text.
  Copie o guts of o terceiro text ao text.
  Destrua o terceiro text.
  Ligue o detector de alteração deste text.

Etapas para que se execute reverse usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "reverse".
  Reverse algum tipo de rows selecionadas of o text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute select all usando um text:
  Se o text for inexistente, cancele.
  Selecione cada pedaço no text.

Etapas para que se execute classifique algum tipo de rows selecionadas usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "classifique rows selecionadas".
  Classifique algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute undo usando um text:
  Se o text for inexistente, cancele.
  Se o last destes undos deste text for inexistente, cancele.
  Copie o text a uma segunda text.
  Posponha a segunda text para os redos deste text.
  Atribua o last destes undos deste text a um terceiro text.
  Remove o terceiro text desde os undos deste text.
  Copie o guts of o terceiro text ao text.
  Destrua o terceiro text.
  Ligue o detector de alteração deste text.

Etapas para que se execute uppercase usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "case".
  Uppercase algum tipo de pedaços selecionados no text.
  Wrap o text.

Um hbitmap é um número identificador.

Um hbrush é um número identificador.

Um hdc é um número identificador.

Um orientação é uns points.

O contagem do heap é um número.

O endereço heap é um endereço de memória.

Um altura é uns twips.

Um texto hexadecimal é uma string.

Um número da fonte é um número identificador.

Um hicon é um número identificador.

Etapas para que se hide o cursor:
  Call "user32.dll" "ShowCursor" com 
  0 
    devolvendo um número.
  Se o número for menor do que 0, cancele.
  Repita. [o código acima]

Um horizontal line é um line.

Um hour é 60 minutes.

Um hpen é um número identificador.

Um hrgn é um número identificador.

Um matiz é uns precise degrees [0 para 3599].

  

O i-beam cursor é um cursor.

    \the erro do fluxo de entrada/saída é uma string.

Um iid é um UUID. \ Um interface identifier é um Identificador único universal

Etapas para que se imagine uma caixa uns twips por uns segunda twips;
Etapas para que se make uma caixa uns twips por uns segunda twips:
  Atribua 0 à coordenada esquerda desta caixa.
  Atribua 0 à coordenada superior desta caixa.
  Atribua os twips à coordenada direita desta caixa.
  Atribua a segunda twips à coordenada inferior desta caixa.

Etapas para que se imagine uma caixa uns twips high por uns segunda twips wide;
Etapas para que se make uma caixa uns twips high por uns segunda twips wide:
  Atribua 0 e 0 e a segunda twips e os twips ao caixa.

Etapas para que se imagine uma caixa uns twips smaller do que uma segunda caixa;
Etapas para que se make uma caixa uns twips smaller do que uma segunda caixa:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips dividido por 2.

Etapas para que se imagine uma caixa uns twips smaller do que uma segunda caixa sobre cada side:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips.

Etapas para que se imagine uma caixa uns twips wide por uns segunda twips high;
Etapas para que se make uma caixa uns twips wide por uns segunda twips high:
  Atribua 0 e 0 e os twips e a segunda twips ao caixa.

Etapas para que se imagine uma caixa com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior;
Etapas para que se make uma caixa com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior:
  Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior ao caixa.

Etapas para que se imagine uma caixa com uma localização e uma segunda localização;
Etapas para que se make uma caixa com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao caixa.

Etapas para que se imagine uma cor desde um matiz e um saturação e um luminosidade;
Etapas para que se make uma cor desde um matiz e um saturação e um luminosidade:
  Atribua o matiz e o saturação e o luminosidade à cor.

Etapas para que se imagine um dot about uns twips wide;
Etapas para que se make um dot about uns twips wide;
Etapas para que se make um dot uns twips wide:
  Make o dot os twips pelo twips.

Etapas para que se imagine um dot entre uns twips e uns segunda twips wide;
Etapas para que se make um dot entre uns twips e uns segunda twips wide:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Make o dot o terceiro twips wide.

Etapas para que se imagine um elipse usando uma caixa;
Etapas para que se make um elipse usando uma caixa:
  Atribua a caixa à caixa desta elipse.

Etapas para que se imagine um elipse uns twips por uns segunda twips;
Etapas para que se make um elipse uns twips por uns segunda twips:
  Atribua 0 à coordenada esquerda desta elipse.
  Atribua 0 à coordenada superior desta elipse.
  Atribua os twips à coordenada direita desta elipse.
  Atribua a segunda twips à coordenada inferior desta elipse.

Etapas para que se imagine um elipse com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior;
Etapas para que se make um elipse com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior:
  Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior ao elipse.

Etapas para que se imagine um elipse com uma localização e uma segunda localização;
Etapas para que se make um elipse com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao elipse.

Etapas para que se imagine uma figura using uma string e uma localização;
Etapas para que se make uma figura using uma string e uma localização;
Etapas para que se crie uma figura using uma string e um center localização:
  Crie a figura.
  Posponha a figura para as figuras.
  Isole a string.
  Lowercase a string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
  Skip algum tipo de leading noise no subtexto.
  Se a quantidade de caracteres deste subtexto for menor do que 2, cancele.
  Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto a um pedaço.
  Atribua o pedaço menos o 'a' minúsculo ao y desse localização.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Atribua o conteúdo deste first endereço de memória do pedaço deste subtexto ao pedaço.
  Atribua o pedaço menos o 'a' minúsculo ao x desta localização.
  Multiplique a localização por 24 px.
  Adicione o x deste center localização menos 299 pixels para o x desta localização.
  Adicione o y deste center localização menos 299 pixels para o y desta localização.
  Posponha a localização para a figura.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se imagine um horizontal line uma fração of o way para cima desde o base of uma caixa;
Etapas para que se make um horizontal line uma fração of o way para cima desde o base of uma caixa:
  Imagine o horizontal line across a caixa a fração of o way para cima desde o base.

Etapas para que se imagine um line across o base of uma caixa;
Etapas para que se make um line across o base of uma caixa;
Etapas para que se imagine um line along o base of uma caixa;
Etapas para que se make um line along o base of uma caixa:
  Atribua a coordenada inferior desta caixa line ao line.

Etapas para que se imagine um line across uma caixa uma fração of o way para cima desde o base;
Etapas para que se make um line across uma caixa uma fração of o way para cima desde o base:
  Atribua a coordenada esquerda desta caixa ao x deste start desta line.
  Atribua a coordenada direita desta caixa ao x deste end desta line.
  Atribua a coordenada inferior desta caixa times a fração a uns twips.
  Atribua a coordenada inferior desta caixa menos os twips ao y deste start desta line.
  Atribua a coordenada inferior desta caixa menos os twips ao y deste end desta line.

Etapas para que se imagine um line across o topo of uma caixa;
Etapas para que se make um line across o topo of uma caixa;
Etapas para que se imagine um line along o topo of uma caixa;
Etapas para que se make um line along o topo of uma caixa:
  Atribua a coordenada superior desta caixa line ao line.

Etapas para que se imagine um line no middle of uma caixa;
Etapas para que se make um line no middle of uma caixa;
Etapas para que se imagine um line across o middle of uma caixa;
Etapas para que se make um line across o middle of uma caixa;
Etapas para que se imagine um line no center of uma caixa;
Etapas para que se make um line no center of uma caixa;
Etapas para que se imagine um line across o center of uma caixa;
Etapas para que se make um line across o center of uma caixa:
  Atribua a coordenada esquerda desta caixa ao x deste start desta line.
  Atribua a coordenada direita desta caixa ao x deste end desta line.
  Atribua o y deste center desta caixa ao y deste start desta line.
  Atribua o y deste center desta caixa ao y deste end desta line.

Etapas para que se imagine um line uns twips para cima desde o base of uma caixa;
Etapas para que se make um line uns twips para cima desde o base of uma caixa:
  Atribua a coordenada esquerda desta caixa ao x deste start desta line.
  Atribua a coordenada direita desta caixa ao x deste end desta line.
  Atribua a coordenada inferior desta caixa menos os twips ao y deste start desta line.
  Atribua a coordenada inferior desta caixa menos os twips ao y deste end desta line.

Etapas para que se imagine um line com uma localização e uma segunda localização;
Etapas para que se make um line com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao line.

Etapas para que se imagine um line com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y;
Etapas para que se make um line com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y:
  Atribua a coordenada X e a coordenada Y e a segunda coordenada X e a segunda coordenada Y ao line.

Etapas para que se imagine uma caixa arredondada desde uma caixa e um raio;
Etapas para que se make uma caixa arredondada desde uma caixa e um raio:
  Atribua a caixa e o raio ao caixa arredondada.

Etapas para que se imagine uma caixa arredondada uns twips por uns segunda twips;
Etapas para que se make uma caixa arredondada uns twips por uns segunda twips com um raio:
  Atribua 0 à coordenada esquerda desta caixa arredondada.
  Atribua 0 à coordenada superior desta caixa arredondada.
  Atribua os twips à coordenada direita desta caixa arredondada.
  Atribua a segunda twips à coordenada inferior desta caixa arredondada.
  Atribua o raio ao raio desta caixa arredondada.

Etapas para que se imagine uma caixa arredondada com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior e um raio;
Etapas para que se make uma caixa arredondada com uma coordenada esquerda e uma coordenada superior e uma coordenada direita e uma coordenada inferior e um raio:
  Atribua a coordenada esquerda e a coordenada superior e a coordenada direita e a coordenada inferior e o raio ao caixa arredondada.

Etapas para que se imagine uma caixa arredondada com uma localização e uma segunda localização e um raio;
Etapas para que se make uma caixa arredondada com uma localização e uma segunda localização e um raio:
  Atribua a localização e a segunda localização e o raio ao caixa arredondada.

Etapas para que se imagine uma localização com uma coordenada X e uma coordenada Y;
Etapas para que se make uma localização com uma coordenada X e uma coordenada Y:
  Atribua a coordenada X e a coordenada Y à localização.

Etapas para que se indent algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
  Se a row for inexistente, cancele.
  Se a row of o text não estiver selecionado, repita.
  Se a row estiver em branco, repita.
  Anteponha o caractere de espaço para a string deste row.
  Anteponha o caractere de espaço para a string deste row.
  Repita. [o código acima]

Um indent é uma contagem.

Um catálogo é uma coisa com
Um contagem de buckets,
Um first bucket e um last bucket.

Etapas para que se catalogue um endereço de memória usando uma string e um catálogo:
    \ if o catálogo for inexistente, cancele. \ para make compilador faster
  Se a quantidade de caracteres desta string for 0, cancele.
  Obtenha um bucket usando a string e o catálogo.
  Crie um refer.
  Posponha o refer para os refers deste bucket.
  Atribua a string à string deste refer.
  Atribua o endereço de memória ao endereço de memória deste refer.

Etapas para que se catalogue uma string em um catálogo:
    \ if o catálogo for inexistente, cancele. \ para make compilador faster
  Catalogue nil usando a string e o catálogo.

Etapas para que se initalize o terminal:
  Crie o terminal na caixa desta tela.

Etapas para que se initialize before run:
  Call "user32.dll" "DisableProcessWindowsGhosting".
  Call "kernel32.dll" "GetProcessHeap" 
    devolvendo o endereço heap.
  Call "kernel32.dll" "LoadLibraryA" com 
  "kernel32.dll"'s first endereço de memória do pedaço 
    devolvendo um número identificador.
  Se o número identificador não for 0, call "kernel32.dll" "GetProcAddress" com 
    O número identificador 
    e "HeapSetInformation"'s first endereço de memória do pedaço 
    devolvendo um endereço de memória.
  Se o endereço de memória não for inexistente, call o endereço de memória com o endereço heap e 0 e 2's endereçamento e 4.

Etapas para que se inicialize o canvases:
  Inicialize o tela canvas.
  Inicialize o memory canvas.
  Atribua o memory canvas ao quadro atual.

Etapas para que se inicialize o cgi:
  Call "kernel32.dll" "AllocConsole".
  Call "kernel32.dll" "GetStdHandle" com 
  -10 [STD_INPUT_HANDLE] 
    devolvendo o número identificador do fluxo de entrada padrão.
  Call "kernel32.dll" "GetStdHandle" com 
  -11 [STD_OUTPUT_HANDLE] 
    devolvendo o número identificador do fluxo de saída padrão.

  \Etapas para que se inicialize o Component Object Model:
  \Mande os códigos 0 e 2 para a função "CoInitializeEx" da biblioteca "ole32.dll" [COINIT_APARTMENTTHREADED].

Etapas para que se inicialize o Component Object Model:
  Call "ole32.dll" "CoInitializeEx" com 
  0 
    e 2 [COINIT_APARTMENTTHREADED].

Etapas para que se inicialize um context:
  Aloque memória para o context.
  Atribua o center desta tela à localização deste context.
  Atribua 0 à orientação deste context.
  Atribua a cor verde à cor deste context.
  Atribua o tamanho de letra pequena à tamanho da letra deste context.
    \Atribua 1/60 second ao delay. ***
  Seed o número aleatório generator.

Etapas para que se inicialize os cursors:
  Inicialize os cursors (seta do mouse).
  Inicialize os cursors (hand cursor).
  Inicialize os cursors (i-beam cursor).
    \Atribua a seta do mouse ao cursor flecha.
    \Atribua o hand cursor ao cursor mano.
    \Atribua o i-beam cursor ao cursor rayo-i.
  Hide o cursor.

Etapas para que se inicialize os cursors (seta do mouse):
  Posponha $00000000000000004000000060000000 para uma máscara de disjunção exclusiva.
  Posponha $70000000780000007C0000007E000000 para a máscara de disjunção exclusiva.
  Posponha $7F0000007F8000007C0000006C000000 para a máscara de disjunção exclusiva.
  Posponha $46000000060000000300000003000000 para a máscara de disjunção exclusiva.
  Posponha $01800000018000000000000000000000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 48.
  Posponha $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF para uma máscara de conjunção lógica.
  Posponha $07FFFFFF03FFFFFF01FFFFFF00FFFFFF para a máscara de conjunção lógica.
  Posponha $007FFFFF003FFFFF001FFFFF01FFFFFF para a máscara de conjunção lógica.
  Posponha $10FFFFFF30FFFFFF787FFFFFF87FFFFF para a máscara de conjunção lógica.
  Posponha $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 48.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 0 
    e 0 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo a seta do mouse.

Etapas para que se inicialize o cursors (hand cursor):
  Posponha $000000000180000019B0000019B00000 para uma máscara de disjunção exclusiva.
  Posponha $0DB200000DB6000007F6000067FE0000 para a máscara de disjunção exclusiva.
  Posponha $7FFC00003FFC00001FFC00001FF80000 para a máscara de disjunção exclusiva.
  Posponha $0FF8000007F0000003F0000003F00000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 64.
  Posponha $FE7FFFFFE40FFFFFC007FFFFC005FFFF para uma máscara de conjunção lógica.
  Posponha $E000FFFFE000FFFF9000FFFF0000FFFF para a máscara de conjunção lógica.
  Posponha $0001FFFF8001FFFFC001FFFFC003FFFF para a máscara de conjunção lógica.
  Posponha $E003FFFFF007FFFFF807FFFFF807FFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 64.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 2 
    e 1 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo o hand cursor.

Etapas para que se inicialize o cursors (i-beam cursor):
  Posponha $EE000000100000001000000010000000 para um máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $100000001000000010000000EE000000 para o máscara de disjunção exclusiva.
  Posponha $00 para o máscara de disjunção exclusiva usando 64.
  Posponha $FF para um máscara de conjunção lógica usando 128.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 3 
    e 7 
    e 32 
    e 32 
    e O first desta máscara de conjunção lógica 
    e O first desta máscara de disjunção exclusiva 
    devolvendo o i-beam cursor.

Etapas para que se inicialize as fonts:
  Call "gdi32.dll" "GetStockObject" com 
  11 [ANSI_FIXED_FONT] 
    devolvendo o null número da fonte.
    \Call "gdi32.dll" "AddFontMemResourceEx" com o first desta osmosian font source e a quantidade de caracteres desta osmosian font source e 0 e o endereçamento desse número devolvendo o osmosian font resource.
    \Call "gdi32.dll" "AddFontMemResourceEx" com o first desta fonte Segoe UI e a quantidade de caracteres desta fonte Segoe UI e 0 e o endereçamento desse número devolvendo o Segoe UI resource.
  Call "gdi32.dll" "AddFontMemResourceEx" com 
    O first desta fonte Tahoma 
    e A quantidade de caracteres desta fonte Tahoma 
    e 0 
    e O endereçamento desse número 
    devolvendo o recurso de fonte Tahoma.
    \Atribua "Segoe UI" e 1/6 polegada à fonte padrão.
    \Atribua "osmosian" e 24 pixels à fonte padrão.
  Atribua "Tahoma" e 20 pixels à fonte padrão.
    \ stroked fonts below
  Atribua 12 pixels ao tamanho de letra pequena.
  Atribua 24 pixels ao tamanho de letra médio.
  Atribua 48 pixels ao tamanho de letra grande.

Etapas para que se inicialize gdi+:
  Atribua 1 ao GdiplusVersion desse GdiplusStartupInput.
  Call "gdiplus.dll" "GdiplusStartup" com 
    O endereçamento deste gptoken 
    e O endereçamento deste GdiplusStartupInput 
    e 0.
    \Windows GDI+ é uma API baseada em classe para programadores C/C++. 
    \Ela permite que os aplicativos usem elementos gráficos e texto formatado na exibição de vídeo e na impressora. 
    \Aplicativos baseados na API do Microsoft Win32 não acessam diretamente o hardware gráfico. 
    \Em vez disso, GDI+ interage com drivers de dispositivo em nome de aplicativos. 
    \GDI+ também é suportado pelo Microsoft Win64.

Etapas para que se inicialize o memory canvas:
  Call "gdi32.dll" "CreateCompatibleDC" com 
    O tela canvas 
    devolvendo o memory canvas.
  Call "gdi32.dll" "GetCurrentObject" com 
    O memory canvas 
    e 7 [OBJ_BITMAP] 
    devolvendo o saved memory hbitmap.
  Call "gdi32.dll" "CreateCompatibleBitmap" com 
    O tela canvas 
    e A pixel largura desta tela 
    e A pixel altura desta tela devolvendo um hbitmap.
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O hbitmap.
  Normalize o memory canvas.

Etapas para que se inicialize o module:
    \ temp endereço completo
  Atribua 512 a uma quantidade de caracteres.
  Reassign o first deste temp endereço completo usando a quantidade de caracteres.
  Call "kernel32.dll" "GetTempPathA" com 
    A quantidade de caracteres 
    e O first deste temp endereço completo 
    devolvendo a quantidade de caracteres.
  Atribua o first deste temp endereço completo mais a quantidade de caracteres menos 1 ao last deste temp endereço completo.
  Modifique através do caractere NUL o temp endereço completo.
    \ module handle
  Call "kernel32.dll" "GetModuleHandleA" com 
  0 
    devolvendo o número identificador deste module.
    \ module nome
  Atribua 512 à quantidade de caracteres.
  Reassign o first deste endereço completo deste module usando a quantidade de caracteres.
  Call "kernel32.dll" "GetModuleFileNameA" com 
    O número identificador deste module 
    e O first deste endereço completo deste module 
    e A quantidade de caracteres 
    devolvendo a quantidade de caracteres.
  Atribua o first deste endereço completo deste module mais a quantidade de caracteres menos 1 ao last deste endereço completo deste module.
  Se o endereço completo deste module começa com "\\?\", remove leading pedaços desde o endereço completo deste module usando 4.
  Lowercase o endereço completo deste module.
  Modifique através do caractere NUL o endereço completo deste module. \ segunda endereço completo pieces deste module
  Extraia o nome deste module desde o endereço completo deste module.
  Modifique através do caractere NUL o nome deste module.
  Extraia o endereço da pasta deste module desde o endereço completo deste module.
  Modifique através do caractere NUL o endereço da pasta deste module.
  Extraia o root endereço da pasta deste module desde o endereço da pasta deste module.
  Modifique através do caractere NUL o root endereço da pasta deste module.

Etapas para que se inicialize o mouse:
  Atribua 1 ao botão esquerdo deste mouse.
  Atribua 2 ao botão direito deste mouse.
  Call "user32.dll" "GetSystemMetrics" com 
  23 [SM_SWAPBUTTON] 
    devolvendo um número.
  Se o número for 0, cancele.
  Permute o botão esquerdo deste mouse com o botão direito deste mouse.

Etapas para que se inicialize o printer canvas:
  Atribua a magnitude [quantidade de bytes] desse printdlgex ao lstructsize deste printdlgex.
  Atribua a main window ao hwndowner deste printdlgex.
  Atribua 1288 [PD_RETURNDC + PD_RETURNDEFAULT + PD_NOPAGENUMS] ao flags deste printdlgex.
  Atribua -1 [START_PAGE_GENERAL] ao nstartpage deste printdlgex.
  Call "comdlg32.dll" "PrintDlgExA" com 
    O endereçamento deste printdlgex.
  Call "kernel32.dll" "GlobalFree" com 
    O hdevnames deste printdlgex.
  Atribua o hdevmode deste printdlgex ao número identificador do modo de dispositivo da impressora.
  Atribua o hdc deste printdlgex ao printer canvas.

Etapas para que se inicialize o tela:
  Call "user32.dll" "GetSystemMetrics" com 
  0 [sm_cxscreen] 
    devolvendo a pixel largura desta tela.
  Call "user32.dll" "GetSystemMetrics" com 
  1 [sm_cyscreen] 
    devolvendo a pixel altura desta tela.
  Atribua 96 ao ppi.
  Atribua o tpi dividido pelo ppi ao tpp.
  Atribua a pixel largura desta tela times o tpp a um largura.
  Atribua a pixel altura desta tela times o tpp a uma altura.
  Atribua 0 e 0 e o largura e o altura à caixa desta tela.
  Subtraia o tpp desde o canto inferior direito desta tela.

Etapas para que se inicialize o tela canvas:
  Call "user32.dll" "GetDC" com 
    A main window 
    devolvendo o tela canvas.
  Normalize o tela canvas.

Etapas para que se inicialize um talker:
  Converta "{96749377-3391-11D2-9EE3-00C04F797396}" [CLSID_SpVoice] para um clsid.
  Converta "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [IID_ISpVoice] para um iid.
  Call "ole32.dll" "CoCreateInstance" com 
    O endereçamento deste clsid 
    e 0 
    e 7 [CLSCTX_ALL] 
    e O endereçamento deste iid 
    e O endereçamento deste talker.

Etapas para que se inicialize a window: \\ para inicializar a janela
  Atribua a magnitude [tamanho em bytes] dessa window class [estrutura] ao cbsize deste window class.
  Atribua 40 [CS_OWNDC + CS_DBLCLKS] ao style deste window class.
    \o valor cs_owndc Aloca um contexto de dispositivo exclusivo para cada janela da classe.
    \ o valor cs_dblclks permite que o windows informe ao programa que aquele é um clique duplo (ao invés de dois cliques)
  Point o lpfnWndProc deste window class para rotina handle algum tipo de message com um window um message número um W-Param e um L-Param.
    \ Isso define o procedimento da classe dessa janela como sendo WndProc
    \LPARAM é um typedef para um LONG_PTR que é um número inteiro (32 bits com sinal) em win32 e __int64 (64 bits com sinal) em x86_64.
    \WPARAM é um typedef para um UINT_PTR que é um número sem sinal (32 bits sem sinal) em win32 e __int64 sem sinal (64 bits sem sinal) em x86_64.
  Atribua o número identificador deste module ao hInstance desta window class.
  Atribua o first deste nome deste module ao lpszClassName desta window class.
  Call "user32.dll" "RegisterClassExA" \ Antes de criar uma janela, você deve registrar uma classe pra essa janela chamando a função RegisterClass.
  com o endereçamento deste window class. \Esta função requer um único parâmetro, que é um ponteiro para uma estrutura do tipo WNDCLASS.
  Call "user32.dll" "CreateWindowExA" com 
  0    \\  o estilo opcional da janela, como transparências por exemplo. veja mais detalhes em  https://docs.microsoft.com/en-us/windows/desktop/winmsg/extended-window-styles
    e O first deste nome deste module    \\ O nome da classe da janela
    e O first deste nome deste module    \\ O texto da janela
    e 2147483648 [13565952  WS_OVERLAPPEDWINDOW]  [-2147483648 = WS_POPUP]     \\  aqui define o tipo da janela. Use valores em decimal;  
    \\para isso Converta os valores hexadecimais da lista  https://www.autoitscript.com/autoit3/docs/appendix/GUIStyles.htm para decimal;
    \\ O valor na documentação do windows está em hexadecimal (ou em string), mas esse compilador usa números inteiros (longint). 
    \\ Para colocar a barra padrão, use o valor 13565952
    e 0    \\ posição horizontal inicial da janela
    e 0    \\ // posição vertical inicial da janela
    e A pixel largura desta tela    \\ A largura da janela em pixels;
    e A pixel altura desta tela    \\ A altura da janela em pixels
    e 0    \\ opcional. Informa o número identificador do controle pai da janela (se existir) ou da janela em si
    e 0 \\ a mesma coisa, só que identifica o número do menu da janela.
    e O número identificador deste module    \\ descrição auto explicável
    e 0. \\ aqui é um ponteiro que passa a informação pra janela. Usamos um valor nulo pq não precisamos dele.
  Call "user32.dll" "ShowWindow" com 
    A main window 
    e 1 [SW_SHOWNORMAL].

Etapas para que se inicialize winsock:
  Call "ws2_32.dll" "WSAStartup" com 
  2 
    e O endereçamento desse wsadata.

Um input é um event.

Etapas para que se insira um pedaço Para um text:
  Se o text for inexistente, cancele.
  Atribua o pedaço a uma string.
  Insira a string ao text.

Etapas para que se insira uma localização Para um polígono after um vértice:
  Se o polígono for inexistente, cancele.
  Crie uma segunda vértice usando a localização.
  Insira a segunda vértice aos vértices deste polígono after o vértice.

Etapas para que se insira uma string Para uma segunda string antes de um byte#:
  Se a quantidade de caracteres desta string for 0, cancele.
  Isole o byte#.
  Limite o byte# para 1 e a quantidade de caracteres desta segunda string mais 1.
  Lance um subtexto sobre a segunda string. \ left side
  Atribua o first endereço de memória do pedaço deste subtexto mais o byte# menos 2 ao last endereço de memória do pedaço deste subtexto.
  Lance uma segundo subtexto sobre a segunda string. \ right side
  Atribua o first endereço de memória do pedaço deste segundo subtexto mais o byte# menos 1 ao first endereço de memória do pedaço deste segundo subtexto.
  Atribua a quantidade de caracteres desta segunda string mais a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Reassign um endereço de memória usando a quantidade de caracteres agrupados.
  Atribua o endereço de memória ao first endereço de memória do pedaço desse terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço deste subtexto para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres deste subtexto.
  Adicione a quantidade de caracteres deste subtexto para o first endereço de memória do pedaço deste terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o first endereço de memória do pedaço deste terceiro subtexto.
  Copie pedaços desde o first endereço de memória do pedaço deste segundo subtexto para o first endereço de memória do pedaço deste terceiro subtexto pelo quantidade de caracteres deste segundo subtexto.
  Unassign o first endereço de memória do pedaço desta segunda string. \ dont use atribua uma string a uma string para prevent extra allocating e copying
  Atribua o endereço de memória ao first endereço de memória do pedaço desta segunda string.
  Atribua o first endereço de memória do pedaço desta segunda string mais a quantidade de caracteres agrupados menos 1 ao last endereço de memória do pedaço desta segunda string.

Etapas para que se insira uma string Para um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row menos o caret column# deste text a um número.
  Atribua a string deste row a uma segunda string.
  Insira a string ao segunda string antes de o caret column# deste text.
  Converta a segunda string para uns rows.
  Atribua o last destas rows a uma segunda row.
  Insira a rows A as rows deste text antes de a row.
  Remove a row desde as rows deste text.
  Destrua a row.
  Renumber as rows deste text.
  Atribua o número da linha desta segunda row ao número de linhas do cursor deste text.
  Atribua a quantidade de caracteres desta string desta segunda row menos o número ao caret column# deste text.
  Desvencilhe-se de o text.

Etapas para que se insira uma coisa para uns coisas after uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se a segunda coisa for inexistente, anteponha a coisa para as coisas; exit.
  Insira a coisa a as coisas antes de o next desta segunda coisa.

Etapas para que se insira uma coisa para uns coisas antes de uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se as coisas estiverem vazio, posponha a coisa para as coisas; exit.
  Se a segunda coisa for inexistente, posponha a coisa para as coisas; exit.
  Se a segunda coisa for o first destas coisas, anteponha a coisa para as coisas; exit.
  Atribua a coisa a uma new coisa.
  Atribua a segunda coisa a uma previous coisa.
  Atribua a new coisa ao next deste previous desta previous coisa.
  Atribua a previous coisa ao next desta new coisa.
  Atribua o previous desta previous coisa ao previous desta new coisa.
  Atribua o new coisa ao previous desta previous coisa.

Etapas para que se insira uns coisas para uns segunda coisas after um coisa:
  Se a coisa for inexistente, anteponha  as coisas para a segunda coisas; exit.
  Insira  as coisas ao segunda coisas antes de o next desta coisa.

Etapas para que se insira uns coisas para uns segunda coisas antes de um coisa:
  Isole o coisa.
  Percorra. [o código abaixo]
    Atribua o first destas coisas a uma segunda coisa.
    Se a segunda coisa for inexistente, cancele.
    Remove a segunda coisa desde as coisas.
    Insira a segunda coisa ao segunda coisas antes de o coisa.
  Repita. [o código acima]

Etapas para que se insira um vértice para um polígono after uma segunda vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono after a segunda vértice.

Etapas para que se insira um vértice para um polígono at uma localização:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma segunda vértice desde os vértices deste polígono.
    Se a segunda vértice for inexistente, cancele.
    Se o next desta segunda vértice for inexistente, cancele.
    Atribua a localização desta segunda vértice e a localização deste next desta segunda vértice a uma line.
    Se a localização não estiver sobre a line, repita.
  Insira o vértice aos vértices deste polígono after a segunda vértice.

Etapas para que se insira um vértice para um polígono antes de uma segunda vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono antes de a segunda vértice.

Etapas para que se intersect uma caixa com uma segunda caixa usando um terceiro caixa:
    \ caixas does not touch
  Limpe o terceiro caixa.
  Se a coordenada esquerda desta caixa for maior do que a coordenada direita desta segunda caixa, cancele.
  Se a coordenada superior desta caixa for maior do que a coordenada inferior desta segunda caixa, cancele.
  Se a coordenada direita desta caixa for menor do que a coordenada esquerda desta segunda caixa, cancele.
  Se a coordenada inferior desta caixa for menor do que a coordenada superior desta segunda caixa, cancele.
    \ caixas touch
  Atribua a caixa ao terceiro caixa.
  Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda desta segunda caixa, atribua a coordenada esquerda desta segunda caixa à coordenada esquerda desta terceiro caixa.
  Se a coordenada superior desta caixa for menor do que a coordenada superior desta segunda caixa, atribua a coordenada superior desta segunda caixa à coordenada superior desta terceiro caixa.
  Se a coordenada direita desta caixa for maior do que a coordenada direita desta segunda caixa, atribua a coordenada direita desta segunda caixa à coordenada direita desta terceiro caixa.
  Se a coordenada inferior desta caixa for maior do que a coordenada inferior desta segunda caixa, atribua a coordenada inferior desta segunda caixa à coordenada inferior desta terceiro caixa.

    \Etapas para que se invert um detector:
    \ see "reverse um detector"
    \Se o detector for yes, atribua no ao detector; exit.
    \Atribua yes ao detector.

Um Endereço IP é um conjunto com
  Um número, 
  Uma string. 

Um item é um conjunto com
  Uma categoria [directory, file], \ English
  Um endereço completo, 
  Um endereço da pasta, 
  Um designador, 
  Uma extensão,
  Um size, 
  Um creation date/time string,
  Um WIN32FINDDATA e 
  Um número identificador.

Etapas para que se jump o caret left em um text:
  Se o text for inexistente, cancele.
  Mova o caret left para algum tipo de non-noise pedaço no text.
  Se o caret column# deste text for 1, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
  Se o conteúdo deste endereço de memória do pedaço for alfanumérico, mova o caret left para algum tipo de non-alfanumérico pedaço no text.
  Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, mova o caret left para algum tipo de non-symbolic pedaço no text.
  Mova o caret left para algum tipo de non-noise pedaço no text.

Etapas para que se jump o caret right em um text:
  Se o text for inexistente, cancele.
  Mova o caret right para algum tipo de non-noise pedaço no text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text é a quantidade de caracteres desta string desta row, cancele.
  Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
  Se o conteúdo deste endereço de memória do pedaço é alfanumérico, mova o caret right para algum tipo de non-alfanumérico pedaço no text.
  Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, mova o caret right para algum tipo de non-symbolic pedaço no text.
  Mova o caret right para algum tipo de non-noise pedaço no text.

Um key é um número.

Um kilobyte é 1024 units.

Um categoria é uma string.

Um l-param é um número.

Um landscape sheet é um sheet.

O tamanho de letra grande é um tamanho da letra.

O maior número é 2147483647.

Um mínimo múltiplo comum é um número.

Um clique é um input.

Um left é uns twips.

Uma quantidade de caracteres é uns twips.

Um tamanho da letra é uns twips. \ indicates actual altura of um typical uppercase letra

Uma letra é um pedaço.

O dicionário léxico é uma coisa com um catálogo.

Etapas para que se clareie uma cor por um quantia:
  Adicione o quantia para a luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se clareie uma cor por uns percentual;
Etapas para que se clareie uma cor about uns percentual;
Etapas para que se clareie uma cor por about uns percentual;
Etapas para que se clareie uma cor uns percentual:
  Atribua a luminosidade desta cor mais o percentual à luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se clareie o current cor about uns percentual:
  Clareie a cor deste context pelo percentual.

Etapas para que se clareie um matiz por uns degrees:
  Adicione o degrees para o matiz.

Etapas para que se clareie um matiz por uns points:
  Converta o matiz para uns segunda points.
  Adicione o points para a segunda points.
  Converta a segunda points para o matiz.

Um luminosidade é um número [que vai desde o número 0 até o número 1000].

Etapas para que se limite uma caixa para uma segunda caixa:
  Limite a coordenada esquerda desta caixa para a coordenada esquerda desta segunda caixa e a coordenada direita desta segunda caixa.
  Limite a coordenada superior desta caixa para a coordenada superior desta segunda caixa e a coordenada inferior desta segunda caixa.
  Limite a coordenada direita desta caixa para a coordenada esquerda desta segunda caixa e a coordenada direita desta segunda caixa.
  Limite a coordenada inferior desta caixa para a coordenada superior desta segunda caixa e a coordenada inferior desta segunda caixa.

Etapas para que se limite o caret em um text:
  Se o text for inexistente, cancele.
  Limite o número de linhas do cursor deste text para 1 e a contagem de linhas deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Limite o caret column# deste text para 1 e a quantidade de caracteres desta string desta row.

Etapas para que se limite um número para um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, atribua o segundo número ao número; exit.
  Se o número for maior do que o terceiro número, atribua o terceiro número ao número.

Etapas para que se limite o origin of um text:
  Se o text for inexistente, cancele.
  Limite a coordenada X deste text para o menor número e a margin deste text.
  Atribua a contagem de linhas deste text menos 1 times a altura da linha deste text a um número.
  Limite a coordenada Y deste text para - o número e 0.

Etapas para que se limite uma localização para uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada esquerda desta caixa, atribua a coordenada esquerda desta caixa à coordenada x desta localização.
  Se a coordenada Y desta localização for menor do que a coordenada superior desta caixa, atribua a coordenada superior desta caixa à coordenada y desta localização.
  Se a coordenada X desta localização for maior do que a coordenada direita desta caixa, atribua a coordenada direita desta caixa à coordenada x desta localização.
  Se a coordenada Y desta localização for maior do que a coordenada inferior desta caixa, atribua a coordenada inferior desta caixa à coordenada y desta localização.

Etapas para que se limite uns texts para uma contagem:
  Atribua a contagem destes texts a uma segunda contagem.
  Percorra. [o código abaixo]
    Se a segunda contagem for menor do que ou igual à contagem, cancele.
    Atribua o first destes texts a um text.
    Remove o text desde o texts.
    Destrua o text.
    Subtraia 1 desde a segunda contagem.
  Repita. [o código acima]

Uma line é um conjunto com 
  Uma start localização e 
  Uma end localização.

Etapas para que se liste umas choices em uma caixa;
Etapas para que se pinte umas choices em uma caixa:
    \Pinte really fast. ***
  Obtenha um [first/next] choice desde as choices.
  Se a choice estiver missing [because we have drawn them all], cancele.
  Atribua a coordenada esquerda desta caixa mais 24 pixels à coordenada esquerda desta choice.
  Atribua a coordenada direita desta caixa menos 24 pixels à coordenada direita desta choice.
  Se a choice for o first desta choice, atribua a coordenada superior desta caixa mais 24 pixels à coordenada superior desta choice.
  Se a choice não for o first desta choice, atribua a coordenada inferior deste previous desta choice à coordenada superior desta choice.
  Atribua a coordenada superior desta choice mais 24 pixels à coordenada inferior desta choice.
    \Pinte a caixa desta choice com a cor púrpura. \ temp ***
  Pinte o nome desta choice na caixa desta choice com a cor deste context.
  Repita. [o código acima]

Etapas para que se liste uns choices em uma caixa com uma cor;
Etapas para que se pinte uns choices em uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte o choices na caixa.

Etapas para que se carregue o dicionário léxico:
  Se o dicionário léxico não for inexistente, cancele.
  Extraia um endereço da pasta desde o endereço completo deste module.
  Percorra. [o código abaixo]
    Se o endereço da pasta estiver em branco, cancele.
    Atribua o endereço da pasta seguido de "dicionário léxico\" a um endereço completo.
    Se o endereço completo estiver no sistema de arquivos, Carregue o dicionário léxico usando o endereço completo; exit.
    Extraia o endereço da pasta desde o endereço da pasta.
  Repita. [o código acima]

Etapas para que se carregue o dicionário léxico usando um trecho:
  Se o dicionário léxico for inexistente, crie o dicionário léxico.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Mova o percorredor (catálogo dicionário léxico rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Catalogue o segmento inicial deste percorredor no catálogo deste dicionário léxico.
  Repita. [o código acima]

Etapas para que se carregue o dicionário léxico usando um endereço completo:
  Obtenha um item desde o endereço completo.
  Se o item não for found, cancele.
  Se a categoria deste item não for "arquivo", repita.
  Read o endereço completo deste item a um trecho.
  Se o erro do fluxo de entrada/saída não estiver em branco, repita.
  Carregue o dicionário léxico usando o trecho.
  Repita. [o código acima]

Etapas para que se localize uma caixa usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a caixa usando o par de números.

Etapas para que se localize uma localização usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a localização usando o par de números.

Etapas para que se lock um gpbitmap usando um bitmapdata (24-bit espaço de cor RGB):
  Atribua o gprect deste gpbitmap a um gprect.
  Call "gdiplus.dll" "GdipBitmapLockBits" com
   o gpbitmap 
   e o endereçamento deste gprect 
   e 3 [ImageLockModeRead ou ImageLockModeWrite] 
   e 137224 [PixelFormat24bppRGB] 
   e o endereçamento deste bitmapdata.

\Um logbrush é um conjunto com \ documentar
\Um número denominado lbstyle,
\Um código da cor denominado lbcolor,
\Um número denominado lbhatch.

Etapas para que se lowercase algum tipo de pedaços selecionados em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
    Lowercase o subtexto.
  Repita. [o código acima]

Etapas para que se lowercase um pedaço:
    \Add 32 to each letter in the string entre "A" and "Z".
  Translate o pedaço usando o tabela de caracteres minúsculos ascii .

Etapas para que se lowercase o character depois de um finger e atribua it para uma string:
  Se o finger for inexistente, cancele.
  Atribua o conteúdo deste finger à string.
  Lowercase a string.

Etapas para que se lowercase uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Lowercase o conteúdo deste first endereço de memória do pedaço deste subtexto.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se lowercase um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, pare.
    Lowercase a string deste row.
  Repita. [o código acima]
  Wrap o text.

A main window é um window.

Etapas para que se make uma fração com um número e um segundo número:
  Atribua o número ao numerador desta fração.
  Atribua o segundo número ao denominador desta fração.

Etapas para que se make um par de números racionais usando uma caixa e uma segunda caixa;
Etapas para que se make uma par de números fracionários usando uma caixa e uma segunda caixa:
  Atribua o x-extent desta caixa à numerador desta fração deste par de números fracionários.
  Atribua o x-extent desta segunda caixa ao denominador desta fração deste par de números fracionários.
  Atribua o y-extent desta caixa ao numerador desta segunda fração deste par de números fracionários.
  Atribua o y-extent desta segunda caixa ao denominador desta segunda fração deste par de números fracionários.

Um margin é um número.

Etapas para que se cubra internamente uma caixa:
  Crie um hrgn usando a caixa.
  Cubra internamente o hrgn.
  Destrua o hrgn.

Etapas para que se cubra internamente um elipse:
  Crie um hrgn usando a elipse.
  Cubra internamente o hrgn.
  Destrua o hrgn.

Etapas para que se cubra internamente um hrgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hrgn e 4 [RGN_DIFF].

Etapas para que se cubra internamente um polígono:
  Crie um hrgn usando o polígono.
  Cubra internamente o hrgn.
  Destrua o hrgn.

Etapas para que se cubra internamente uma caixa arredondada:
  Crie um hrgn usando a caixa arredondada.
  Cubra internamente o hrgn.
  Destrua o hrgn.

Um mask é um texto hexadecimal.

Etapas para que se cubra somente dentro de uma caixa:
  Mostre tudo.
  Cubra internamente a caixa.

Etapas para que se cubra somente dentro de um elipse:
  Mostre tudo.
  Cubra internamente a elipse.

Etapas para que se cubra somente dentro de um polígono:
  Mostre tudo.
  Cubra internamente o polígono.

Etapas para que se cubra somente dentro de uma caixa arredondada:
  Mostre tudo.
  Cubra internamente a caixa arredondada.

Etapas para que se cubra somente fora de uma caixa:
  Mostre tudo.
  Cubra externamente a caixa.

Etapas para que se cubra somente fora de um elipse:
  Mostre tudo.
  Cubra externamente a elipse.

Etapas para que se cubra somente fora de um polígono:
  Mostre tudo.
  Cubra externamente o polígono.

Etapas para que se cubra somente fora de uma caixa arredondada:
  Mostre tudo.
  Cubra externamente a caixa arredondada.

Etapas para que se cubra externamente uma caixa:
  Crie um hrgn usando a caixa.
  Cubra externamente o hrgn.
  Destrua o hrgn.

Etapas para que se cubra externamente um elipse:
  Crie um hrgn usando a elipse.
  Cubra externamente o hrgn.
  Destrua o hrgn.

Etapas para que se cubra externamente um hrgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hrgn e 1 [RGN_AND].

Etapas para que se cubra externamente um polígono:
  Crie um hrgn usando o polígono.
  Cubra externamente o hrgn.
  Destrua o hrgn.

Etapas para que se cubra externamente uma caixa arredondada:
  Crie um hrgn usando a caixa arredondada.
  Cubra externamente o hrgn.
  Destrua o hrgn.

O max text undos é uma contagem igual a 32.

O tamanho de letra médio é um tamanho da letra.

O memory canvas é um canvas.

Etapas para que se minimize um window:
  Call "user32.dll" "ShowWindow" com 
    A window 
    e 6 [SW_MINIMIZE].

Etapas para que se mirror o gpbitmap em um imagem:
  Se o imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Mirror o gpbitmap desta imagem.

Etapas para que se mirror um gpimage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O gpimage 
    e 4 [RotateNoneFlipX].

Etapas para que se mirror um imagem:
  Se o imagem for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa desta imagem menos a coordenada X deste center desta caixa intacta desta imagem ao número X desse par de números.
  Multiplique o número X deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Mirror o gpbitmap no imagem.

Etapas para que se mova o anchor left para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o anchor número da linha deste text e o text.
  Percorra. [o código abaixo]
    Se o anchor column# deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o anchor column# deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Subtraia 1 desde o anchor column# deste text.
  Repita. [o código acima]

Etapas para que se mova o caret para baixo em um text:
  Se o text for inexistente, cancele.
  Adicione 1 para o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas para que se mova o caret para baixo one página em um text:
  Se o text for inexistente, cancele.
  Adicione as rows/box deste text para o número de linhas do cursor deste text.
  Subtraia 1 desde o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas para que se mova o caret para o first pedaço of o current row of um text:
  Se o text for inexistente, cancele.
  Atribua 1 ao caret column# deste text.

Etapas para que se mova o caret para o first pedaço of um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao caret deste text.

Etapas para que se mova o caret para o last pedaço of o current row of um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row ao caret column# deste text.

Etapas para que se mova o caret para o last pedaço of um text:
  Se o text for inexistente, cancele.
  Atribua a contagem de linhas deste text ao número de linhas do cursor deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row ao caret column# deste text.

Etapas para que se mova o caret left para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Subtraia 1 desde o caret column# deste text.
  Repita. [o código acima]

Etapas para que se mova o caret left para algum tipo de non-noise pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for irrelevante, cancele.
    Subtraia 1 desde o caret column# deste text.
  Repita. [o código acima]

Etapas para que se mova o caret left para algum tipo de non-symbolic pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text for 1, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for symbolic, cancele.
    Subtraia 1 desde o caret column# deste text.
  Repita. [o código acima]

Etapas para que se mova o caret left em um text:
  Se o text for inexistente, cancele.
  Subtraia 1 desde o caret column# deste text.
  Limite o caret no text.

Etapas para que se mova o caret right para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Adicione 1 para o caret column# deste text.
  Repita. [o código acima]

Etapas para que se mova o caret right para algum tipo de non-noise pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for irrelevante, cancele.
    Adicione 1 para o caret column# deste text.
  Repita. [o código acima]

Etapas para que se mova o caret right para algum tipo de non-symbolic pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o caret column# deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o first endereço de memória do pedaço desta string desta row mais o caret column# deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for symbolic, cancele.
    Adicione 1 para o caret column# deste text.
  Repita. [o código acima]

Etapas para que se mova o caret right em um text:
  Se o text for inexistente, cancele.
  Adicione 1 para o caret column# deste text.
  Limite o caret no text.

Etapas para que se mova o caret para cima em um text:
  Se o text for inexistente, cancele.
  Subtraia 1 desde o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas para que se mova o caret para cima one página em um text:
  Se o text for inexistente, cancele.
  Subtraia as rows/box deste text desde o número de linhas do cursor deste text.
  Adicione 1 para o número de linhas do cursor deste text.
  Limite o caret no text.

Etapas para que se mova um finger over um número:
  Se o finger for inexistente, cancele.
  Adicione 1 para o finger.

Etapas para que se mova um imagem para baixo uns twips:
  Mova o imagem usando 0 e os twips.

Etapas para que se mova um imagem usando um par de números:
  Mova o imagem usando o número X deste par de números e o número Y deste par de números.

Etapas para que se mova um imagem usando uns x-twips e uns y-twips:
  Se o imagem for inexistente, cancele.
  Mova a caixa desta imagem usando o x-twips e o y-twips.
  Mova a caixa intacta desta imagem usando o x-twips e o y-twips.

Etapas para que se mova um imagem left uns twips:
  Mova o imagem usando - os twips e 0.

Etapas para que se mova um imagem right uns twips:
  Mova o imagem usando os twips e 0.

Etapas para que se mova um imagem para uma localização:
  Se o imagem for inexistente, cancele.
  Obtenha um difference entre a localização e o canto superior esquerdo desta imagem.
  Mova o imagem usando a difference.

Etapas para que se mova um imagem para cima uns twips:
  Mova o imagem usando 0 e - os twips.

Etapas para que se mova uns squares:
  Mova o square size times o squares dividido por 1 square. \ squares são scaled para cima por precision hence o division at o end

Etapas para que se mova uns squares diagonally;
Etapas para que se mova uns squares slantways:
  Mova o square size times o squares times o raiz de dois dividido por 1 square. \ squares são scaled para cima por precision hence o division at o end

Etapas para que se mova um subtexto usando um número:
  Adicione o número para o first endereço de memória do pedaço deste subtexto.
  Adicione o número para o last endereço de memória do pedaço deste subtexto.

Etapas para que se mova uma coisa desde uns coisas para uns segunda coisas:
  Se a coisa for inexistente, cancele.
  Isole o coisa.
  Remove a coisa desde as coisas.
  Posponha a coisa para a segunda coisas.

Etapas para que se mova uns coisas para uns segunda coisas:
  Atribua o first destas coisas ao first destas segunda coisas.
  Atribua o last destas coisas ao last destas segunda coisas.
  Limpe as coisas.

Etapas para que se mova uma window left:
  Call "user32.dll" "GetWindowRect" com 
    A main window 
    e O endereçamento dessa caixa.
  Subtraia a pixel largura desta tela desde a coordenada esquerda desta caixa.
  Call "user32.dll" "MoveWindow" com 
    A window 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A pixel largura desta tela 
    e A pixel altura desta tela 
    e 1.

Etapas para que se mova uma window right:
  Call "user32.dll" "GetWindowRect" com 
    A main window 
    e O endereçamento dessa caixa.
  Adicione a pixel largura desta tela para a coordenada esquerda desta caixa.
  Call "user32.dll" "MoveWindow" com 
    A window 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A pixel largura desta tela 
    e A pixel altura desta tela 
    e 1.

Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números racionais;
Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números fracionários:
  Se a imagem for inexistente, cancele.
  Mova a caixa intacta desta imagem usando o par de números fracionários e o canto superior esquerdo desta caixa desta imagem.
  Redimensione a caixa intacta desta imagem usando o par de números fracionários.
  Redimensione a caixa desta imagem usando o par de números fracionários.
  Se a coordenada direita desta imagem for menor do que a coordenada esquerda desta imagem, mirror o gpbitmap no imagem.
  Se a coordenada inferior desta imagem for menor do que a coordenada superior desta imagem, flip o gpbitmap no imagem.

Etapas para que se redimensione cuidadosamente [sem perder qualidade] um imagem usando um twip par de números:
  Se o imagem for inexistente, cancele.
  Atribua a caixa desta imagem a uma caixa.
  Redimensione a caixa usando o twip par de números.
  Make uma par de números fracionários usando a caixa e a caixa desta imagem.
  redimensione cuidadosamente [sem perder qualidade] o imagem usando o par de números fracionários.

Etapas para que se normalize um ângulo:
  Divida o ângulo por 3600 usando um quociente e o ângulo.

Etapas para que se normalize uma caixa:
  Se a coordenada direita desta caixa for menor do que a coordenada esquerda desta caixa, permute a coordenada esquerda desta caixa com a coordenada direita desta caixa.
  Se a coordenada inferior desta caixa for menor do que a coordenada superior desta caixa, permute a coordenada superior desta caixa com a coordenada inferior desta caixa.

Etapas para que se normalize um canvas:
  Call "gdi32.dll" "SetGraphicsMode" com 
    O canvas 
    e 2 [GM_ADVANCED].
  Call "gdi32.dll" "SetBkMode" com 
    O canvas 
    e 1 [TRANSPARENT].
  Call "gdi32.dll" "SetMapMode" com 
    O canvas 
    e 8 [MM_ANISOTROPIC ].
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O canvas 
    e 0 
    e 0 
    e nil.
  Call "gdi32.dll" "SetViewportExtEx" com 
    O canvas 
    e O ppi 
    e O ppi 
    e nil.
  Call "gdi32.dll" "SetWindowOrgEx" com 
    O canvas 
    e 0 
    e 0 
    e nil.
  Call "gdi32.dll" "SetWindowExtEx" com 
    O canvas 
    e O tpi 
    e O tpi 
    e nil.

Etapas para que se normalize um elipse:
  Normalize a caixa desta elipse.

Etapas para que se normalize uma fração e uma segunda fração:
  Obtenha um mínimo múltiplo comum usando o denominador desta fração e o denominador desta segunda fração.
  Multiplique o numerador desta fração pelo mínimo múltiplo comum dividido pelo denominador desta fração.
  Atribua o mínimo múltiplo comum ao denominador desta fração.
  Multiplique o numerador desta segunda fração pelo mínimo múltiplo comum dividido pelo denominador desta segunda fração.
  Atribua o mínimo múltiplo comum ao denominador desta segunda fração.

Etapas para que se normalize uma orientação:
  Divida a orientação por 3840 usando um quociente e um resto.
  Atribua o resto à orientação.
  Se a orientação for menor do que 0, adicione 3840 para a orientação.

Etapas para que se normalize um horizontal line:
  Se o end desta line for menor do que o start desta line, permute o end desta line com o start desta line.

Etapas para que se normalize um matiz:
  Divida o matiz por 3600 usando um quociente e um resto.
  Atribua o resto ao matiz.
  Se o matiz for menor do que 0, adicione 3600 para o matiz.

Etapas para que se normalize um imagem:
  Se o imagem for inexistente, cancele.
  Normalize a caixa desta imagem.
  Normalize a caixa intacta desta imagem.

Etapas para que se normalize uma seleção:
  Se o anchor número da linha desta seleção for menor do que o número de linhas do cursor desta seleção, cancele.
  Se o anchor número da linha desta seleção for maior do que o número de linhas do cursor desta seleção, permute o anchor desta seleção com o caret desta seleção; exit.
  Se o anchor column# desta seleção for maior do que o caret column# desta seleção, permute o anchor column# desta seleção com o caret column# desta seleção.

Etapas para que se normalize um text:
  Se o text for inexistente, cancele.
  Normalize a caixa deste text.

Etapas para que se normalize um vertical line:
  Se o end desta line for menor do que o start desta line, permute o end desta line com o start desta line.

O null hbrush é um hbrush.

O null hpen é um hpen.

Etapas para que se modifique através do caractere NUL uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o first endereço de memória do pedaço desta string usando a quantidade de caracteres armazenados mais 1.
  Atribua o first endereço de memória do pedaço desta string mais a quantidade de caracteres armazenados menos 1 ao last endereço de memória do pedaço desta string.
  Atribua o last endereço de memória do pedaço desta string mais 1 a um endereço de memória do pedaço .
  Atribua o null pedaço ao conteúdo deste endereço de memória do pedaço.

Etapas para que se modifique através do caractere NUL um wide string:
  Atribua a quantidade de caracteres deste wide string a uma quantidade de caracteres armazenados.
  Reassign o first desta wide string usando a quantidade de caracteres armazenados mais 2.
  Atribua o first desta wide string mais a quantidade de caracteres armazenados menos 1 ao last deste wide string.

Um offset é um número.

Uma operação é uma string.

Uma origin é uma localização.

Etapas para que se outdent algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita. \selecionada
    Se o conteúdo deste first endereço de memória do pedaço desta string desta row for o caractere de espaço, remove o first pedaço desde a string deste row.
    Se o conteúdo deste first endereço de memória do pedaço desta string desta row for o caractere de espaço, remove o first pedaço desde a string deste row.
  Repita. [o código acima]

Um outdent é um número.

Etapas para que se outline uma caixa com uma cor:
  Pinte a caixa com a cor e a cor preta.

  
Um x-offset é um offset.
Um y-offset é um offset.

Etapas para que se output o arco of uma elipse usando uma string: \\ interessante.
  Atribua 2761/10000 a um fração. \ 2/3*(sqrt(2)-1)
  Atribua o center desta elipse a um center localização.
  Atribua o x-extent desta elipse dividido por 2 a um half largura.
  Atribua o y-extent desta elipse dividido por 2 a um half altura.
  Atribua o x-extent desta elipse times a fração a um x-offset.
  Atribua o y-extent desta elipse times a fração a um y-offset.
    \ control point 1
  Se a string for "canto superior esquerdo", atribua a coordenada esquerda desta elipse e a coordenada Y deste center menos o y-offset a um first control localização.
  Se a string for "canto superior direito", atribua a coordenada X deste center mais o x-offset e a coordenada superior desta elipse ao first control localização.
  Se a string for "canto inferior direito", atribua a coordenada direita desta elipse e a coordenada Y deste center mais o y-offset ao first control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X deste center menos o x-offset e a coordenada inferior desta elipse ao first control localização.
    \ control point 2
  Se a string for "canto superior esquerdo", atribua a coordenada X deste center menos o x-offset e a coordenada superior desta elipse a um second control localização.
  Se a string for "canto superior direito", atribua a coordenada direita desta elipse e a coordenada Y deste center menos o y-offset ao second control localização.
  Se a string for "canto inferior direito", atribua a coordenada X deste center mais o x-offset e a coordenada inferior desta elipse ao second control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada esquerda desta elipse e a coordenada Y deste center mais o y-offset ao second control localização.
    \ ending point
  Se a string for "canto superior esquerdo", atribua a coordenada esquerda desta elipse mais o half largura e a coordenada superior desta elipse a um ending localização.
  Se a string for "canto superior direito", atribua a coordenada direita desta elipse e a coordenada superior desta elipse mais o half altura ao ending localização.
  Se a string for "canto inferior direito", atribua a coordenada direita desta elipse menos o half largura e a coordenada inferior desta elipse ao ending localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada esquerda desta elipse e a coordenada inferior desta elipse menos o half altura ao ending localização.
    \ spit it out
  Output o first control localização sem passar pra próxima linha.
  Output o second control localização sem passar pra próxima linha.
  Output o ending localização sem passar pra próxima linha.
  Output "c".

Etapas para que se output uma cor sem passar pra próxima linha:
  Converta a cor para um espaço de cor RGB.
  Atribua o espectro vermelho deste espaço de cor RGB / 255 a um fração.
  Converta a fração para um red string usando 4.
  Atribua o espectro verde deste espaço de cor RGB / 255 à fração.
  Converta a fração para um green string usando 4.
  Atribua o espectro azul deste espaço de cor RGB / 255 à fração.
  Converta a fração para um blue string usando 4.
  Output o red string seguido de " " junto com o green string seguido de " " junto com o blue string sem passar pra próxima linha.

Etapas para que se output lineto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "l".

Etapas para que se output lineto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output lineto usando a localização.

Etapas para que se output moveto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "m".

Etapas para que se output moveto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output moveto usando a localização.

Etapas para que se output um número sem passar pra próxima linha:
  Converta o número para uma string.
  Output a string sem passar pra próxima linha.
  Output " " sem passar pra próxima linha.

Etapas para que se output stroke e fill usando uma cor da borda e uma cor de preenchimento:
  Atribua "B" a uma string. \ stroke e fill
  Se a cor de preenchimento estiver clear, atribua "S" à string. \ stroke
  Se a cor da borda estiver clear, atribua "f" à string. \ fill
  Output a string.

\Um paintstruct é um conjunto com
\Um hdc denominado hdc,
\Um número denominado ferase,
\Um caixa denominado rcpaint,
\Um número denominado frestore,
\Um número denominado fincupdate,
\  32 pedaços.

Um número X é um número.
Um número Y é um número.

Um par de números é um conjunto com 
  Um número X e 
  Um número Y.

Um pchar é um endereço de memória do pedaço.

Um pdevmode é um endereço de memória para um devmode.

Etapas para que se escolha aleatoriamente um número within um quantia of um segundo número:
  Escolha aleatoriamente o número entre o segundo número menos o quantia e o segundo número mais o quantia.
  Atribua o número ao número deste context.

Uma imagem é uma coisa com
\ as caixas estão em twits
Um caixa [location of cropped imagem sobre a página], 
Um caixa intacta [location of entire imagem sobre a página],
Um grayscale detector,
Um mirror detector,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal denominado data [original pedaços em original format],
Um gpbitmap.

    \Um imagem é uma coisa com
    \ as caixas estão em twits
    \Um caixa [location of cropped imagem sobre a página], 
    \Um caixa intacta [location of entire imagem sobre a página],
    \Um grayscale detector,
    \Um mirror detector,
    \Um ângulo de rotação, \ rotation é clockwise
    \Um texto hexadecimal denominado data [original pedaços em original format],
    \Um gpbitmap.

    \Um figura é uma coisa com
    \ all caixas são em twits
    \Um caixa [location of cropped imagem sobre a página], 
    \Um caixa intacta [location of entire imagem sobre a página],
    \Um grayscale detector,
    \Um mirror detector,
    \Um ângulo de rotação, \ rotation é clockwise
    \Um texto hexadecimal denominado data [original pedaços em original format],
    \Um gpbitmap.

Etapas para que se toque um wave:
  Call "winmm.dll" "PlaySound" com 
    O first desta wave 
    e 0 
    e 5 [SND_MEMORY+SND_ASYNC].

Etapas para que se toque um wave e wait:
  Call "winmm.dll" "PlaySound" com 
    O first desta wave 
    e 0 
    e 4 [SND_MEMORY+SND_SYNC].

Etapas para que se toque um wave file:
  Isole o wave file.
  Modifique através do caractere NUL o wave file.
  Call "winmm.dll" "PlaySound" com 
    O first deste wave file 
    e 0 
    e 131073 [snd_filename+snd_async].

Etapas para que se toque um wave file e wait:
  Isole o wave file.
  Modifique através do caractere NUL o wave file.
  Call "winmm.dll" "PlaySound" com 
    O first deste wave file 
    e 0 
    e 131072 [snd_filename+snd_sync].

Etapas para que se anteponha uma coisa para uns coisas:
  Se a coisa for inexistente, cancele.
  Atribua o first destas coisas ao next desta coisa.
  Se  as coisas não for vazio, atribua a coisa ao previous deste first destas coisas.
  Se  as coisas estiverem vazio, atribua a coisa ao last destas coisas.
  Atribua a coisa ao first destas coisas.

    \Etapas para que se anteponha uns coisas para umas segunda coisas:
    \ bug found por Mike Gonta - corrected version below
    \Obtenha uma coisa desde  as coisas (backwards).
    \Se a coisa for inexistente, cancele.
    \Remove a coisa desde as coisas.
    \Anteponha a coisa para a segunda coisas.
    \Repita. [o código acima]

Etapas para que se anteponha uns coisas para umas segunda coisas:
  Atribua o last destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Anteponha a coisa para a segunda coisas.
  Repita. [o código acima]

Um process é um número identificador.

Um process endereço de memória é um endereço de memória para um process.

Um punch line é uma string.

Etapas para que se atribua o character depois de um finger para um character:
  Se o finger for inexistente, limpe o character; exit.
  Atribua o conteúdo deste finger ao character.

Etapas para que se atribua um date/time para uma segunda date/time:
  Atribua o year deste date/time ao year desta segunda date/time.
  Atribua o month deste date/time ao month desta segunda date/time.
  Atribua o week day deste date/time ao week day segunda date/time.
  Atribua o day deste date/time ao day desta segunda date/time.
  Atribua a hour deste date/time à hour desta segunda date/time.
  Atribua o minute deste date/time ao minute desta segunda date/time.
  Atribua o second deste date/time ao second desta segunda date/time.
  Atribua o millisecond deste date/time ao millisecond desta segunda date/time.

Etapas para que se atribua a string dessa date/time para uma string:
  Limpe a string.
  Posponha o year deste date/time para a string.
  Posponha "/" para a string.
  Zero fill o month deste date/time usando 2 e posponha it para a string.
  Posponha "/" para a string.
  Zero fill o day deste date/time usando 2 e posponha it para a string.
  Posponha " " para a string.
  Zero fill a hour deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o minute deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o second deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero fill o millisecond deste date/time usando 3 e posponha it para a string.

Etapas para que se atribua um finger sobre o first character of uma string:
  Atribua o first endereço de memória do pedaço desta string ao finger.

Etapas para que se atribua a contagem desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha um bucket usando o catálogo.
  Se o bucket for inexistente, cancele.
  Adicione a contagem destes refers deste bucket para a contagem.
  Repita. [o código acima]

Etapas para que se atribua a used contagem de buckets desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, cancele.
    Se os refers deste bucket estiverem vazio, repita.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se atribua um número para um big-endian unsigned word:
  Atribua o número a um word.
  Atribua o word ao big-endian unsigned word.

Etapas para que se atribua um número para uma string;
Etapas para que se converta um número para uma string:
  Limpe a string.
  Isole o número.
  De-sign o número.
  Percorra. [o código abaixo]
    Divida o número por 10 usando um quociente e um resto.
    Adicione 48 para o resto.
    Atribua o resto a um pedaço.
    Anteponha o pedaço para a string.
    Se o quociente for 0, pare.
    Atribua o quociente ao número.
  Repita. [o código acima]
  Se o original número for menor do que 0, anteponha o hífem para a string.

Etapas para que se atribua um número sobre o stack:
  Converta o número para um segmento inicial.
  Atribua o segmento inicial sobre o stack.

Etapas para que se atribua o absolute value desse número para um segundo número:
  Atribua o número ao segundo número.
  De-sign o segundo número.

Etapas para que se atribua um outlinetextmetric para uma segunda outlinetextmetric:
  Copie pedaços desde o endereçamento deste outlinetextmetric para o endereçamento desta segunda outlinetextmetric pela magnitude deste outlinetextmetric.

Etapas para que se atribua o absolute value desse par de números para uma segundo par de números:
  Atribua o par de números ao segundo par de números.
  De-sign a segundo par de números.

\ unclear why this does not get called properly when I replace hoja apaisada com caja ***

Etapas para que se atribua um imagem no middle of uma caixa;
Etapas para que se centralize um imagem em uma caixa:
  Se o imagem for inexistente, cancele.
  Centralize o imagem na caixa (horizontalmente).
  Centralize o imagem na caixa (verticalmente).

Etapas para que se atribua um imagem sobre uma localização;
Etapas para que se centralize um imagem sobre uma localização:
  Se o imagem for inexistente, cancele.
  Obtenha um difference entre a localização e o center desta caixa desta imagem.
  Arredonde a difference para o múltiplo imediato of o tpp.
  Mova o imagem usando a difference.

Etapas para que se atribua o working string dessa row para um subtexto:
  Se a row for inexistente, limpe o subtexto; exit.
  Lance o subtexto sobre a string deste row.
  Subtraia 1 desde o last endereço de memória do pedaço deste subtexto.

Etapas para que se atribua uma seleção para uma segunda seleção:
  Atribua o anchor desta seleção ao anchor desta segunda seleção.
  Atribua o caret desta seleção ao caret desta segunda seleção.

Etapas para que se atribua um sockaddr para uma segunda sockaddr:
  Copie pedaços desde o endereçamento deste sockaddr para o endereçamento desta segunda sockaddr pela magnitude deste sockaddr.

Etapas para que se atribua uma string para uma letra:
  Atribua o conteúdo deste first endereço de memória do pedaço desta string à letra.

Etapas para que se atribua uma string para um text:
  Se o text for inexistente, cancele.
  Destrua as rows deste text.
  Reset o origin of o text.
  Reset o caret of o text.
  Desvencilhe-se de o text.
  Isole a string.
  Posponha o return pedaço para a string.
  Converta a string para as rows deste text.
  Wrap o text.

Etapas para que se atribua uma string sobre o área de transferência do Windows:
  Call "user32.dll" "OpenClipboard" com 
    A main window.
  Call "user32.dll" "EmptyClipboard".
  Atribua a quantidade de caracteres desta string mais 1 a um número.
  Call "kernel32.dll" "GlobalAlloc" com 
  66 [GHND - 0x0042 - unifica GMEM_MOVEABLE e GMEM_ZEROINIT.] 
    e O número 
    devolvendo um número identificador.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador 
    devolvendo um endereço de memória.
  Copie pedaços desde o first endereço de memória do pedaço desta string para o endereço de memória pelo quantidade de caracteres desta string.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "user32.dll" "SetClipboardData" com 
  1 [CF_TEXT] 
    e O número identificador.
  Call "user32.dll" "CloseClipboard".

Etapas para que se atribua a largura dessa string para uma largura:
  \Consegui traduzir como:
  \Etapas para que se atribua uma largura desse string para uma segunda largura:
  Obtenha o largura usando a string e o memory canvas e a fonte padrão.

    \ \ leave out - causes Spanish string atribuas para resolva here instead of "Atribua uma string a uma segunda string"
Etapas para que se atribua um subtexto para um segundo subtexto:
  Copie pedaços desde o endereçamento deste subtexto para o endereçamento deste segundo subtexto pela magnitude deste subtexto.

Etapas para que se atribua o date/time do system para um date/time:
  Call "kernel32.dll" "GetLocalTime" com o endereçamento desse systemtime.
  Atribua o wyear deste systemtime ao year deste date/time.
  Atribua o wmonth deste systemtime ao month deste date/time.
  Atribua o wdayofweek deste systemtime ao week day deste date/time.
  Atribua o wday deste systemtime ao day deste date/time.
  Atribua o whour deste systemtime à hour deste date/time.
  Atribua o wminute deste systemtime ao minute deste date/time.
  Atribua o wsecond deste systemtime ao second deste date/time.
  Atribua os wmilliseconds deste systemtime ao millisecond deste date/time.

Etapas para que se atribua o last erro do system para um número:
  Call "kernel32.dll" "GetLastError" devolvendo o número.

Etapas para que se atribua o last winsock erro do system para um número:
  Call "ws2_32.dll" "WSAGetLastError" devolvendo o número.

Etapas para que se atribua a contagem de ticks do sistema para uns ticks:
    \ wraps cada 24.8 days ou so
  Call "kernel32.dll" "GetTickCount" devolvendo os ticks.
  Conjuncione logicamente os ticks com o maior número.

Etapas para que se atribua um terminal no middle of uma caixa;
Etapas para que se centralize um terminal em uma caixa:
  Isole a caixa.
  Indent a caixa 24 px.
  Atribua a caixa à caixa deste terminal.

Etapas para que se atribua um text no middle of uma caixa;
Etapas para que se centralize um text em uma caixa:
  Se o text for inexistente, cancele.
  Centralize o text na caixa (horizontalmente).
  Centralize o text na caixa (verticalmente).

Etapas para que se atribua um text sobre uma localização;
Etapas para que se centralize um text sobre uma localização:
  Se o text for inexistente, cancele.
  Obtenha um difference entre a localização e o center desta caixa deste text.
  Arredonde a difference para o múltiplo imediato of o tpp.
  Mova o text usando a difference.

Etapas para que se atribua a first line desse text para uma string:
  Se o text for inexistente, limpe a string; exit.
  Atribua a string desta first row deste text à string.
  Remove o last pedaço desde a string.

Etapas para que se atribua a first non-em branco line desse text para uma string:
    \ *** new
  Limpe a string.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Atribua a string deste row à string.
    Remove o last pedaço desde a string. \ cr ou space (see text rules)
    Remove algum tipo de leading noise desde a string.
    Remove algum tipo de trailing noise desde a string.
  Se a string estiver em branco, repita.
  \Se a string não estiver em branco, pare.

Etapas para que se atribua a globalized origin desse text para uma localização:
  Se o text for inexistente, limpe a localização; exit.
  Atribua a origin deste text à localização.
  Globalize a localização usando o canto superior esquerdo deste text.

Etapas para que se atribua a malha desse text para um malha:
  Se o text for inexistente, limpe a malha; exit.
  Atribua a altura desta font deste text times 4 ao número X desta malha.
  Atribua a altura desta font deste text ao número Y desta malha.

Etapas para que se atribua a normalized seleção desse text para uma seleção:
  Se o text for inexistente, cancele.
  Atribua a seleção deste text à seleção.
  Normalize a seleção.

Etapas para que se atribua a contagem de linhas desse text para uma contagem:
  Se o text for inexistente, atribua 0 à contagem; exit.
  Se as rows deste text estiverem vazio, atribua 0 à contagem; exit.
  Atribua o número da linha deste last destas rows deste text à contagem.

Etapas para que se atribua a altura da linha desse text para uma altura:
  Se o text for inexistente, atribua 0 ao altura; exit.
  Atribua a altura desta font deste text ao altura.

Etapas para que se atribua a rows/box desse text para uma contagem:
  Se o text for inexistente, atribua 0 à contagem; exit.
  Atribua a altura desta caixa deste text dividido pela altura da linha deste text à contagem.

Etapas para que se atribua a quantidade de caracteres selecionados desse text para uma contagem:
  Atribua 0 à contagem.
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
  Se a row for inexistente, cancele.
  Lance um subtexto sobre algum tipo de pedaços selecionados na row of o text.
  Adicione a quantidade de caracteres deste subtexto para a contagem.
  Repita. [o código acima]

Etapas para que se atribua a selecionado contagem de linhas desse text para uma contagem:
  Atribua 0 à contagem.
  Se o text for inexistente, cancele.
  Atribua a normalized seleção deste text a uma seleção.
  Se o anchor número da linha desta seleção é o número de linhas do cursor desta seleção, cancele.
  Atribua o número de linhas do cursor desta seleção à contagem.
  Subtraia o anchor número da linha desta seleção desde a contagem.
  Se o caret column# desta seleção não for 1, adicione 1 para a contagem.

Etapas para que se atribua o painel de informações string desse text para uma string:
  Se o text for inexistente, limpe a string; exit.
  Atribua a selecionado contagem de linhas deste text a uma contagem.
  Se a contagem não for 0, format a contagem e "linha selecionada" ou "linhas selecionadas" à string; exit.
  Atribua a quantidade de caracteres selecionados deste text a uma segunda contagem.
  Se a segunda contagem não for 0, format a segunda contagem e "pedaço" ou "pedaços" à string; exit.
  Converta o número de linhas do cursor deste text para a string.
  Posponha ":" para a string.
  Posponha o caret column# deste text para a string.

Etapas para que se atribua uma coisa at o end of uns coisas;
Etapas para que se posponha uma coisa para uns coisas:
  Se a coisa for inexistente, cancele.
  Atribua o last destas coisas ao previous desta coisa.
  Se as coisas não estiverem vazio, atribua a coisa ao next deste last destas coisas.
  Se as coisas estiverem vazio, atribua a coisa ao first destas coisas.
  Atribua a coisa ao last destas coisas.

Etapas para que se atribua umas coisas para umas segunda coisas:
  Atribua o first destas coisas ao first destas segunda coisas.
  Atribua o last destas coisas ao last destas segunda coisas.

Etapas para que se atribua a contagem dessas coisas  para uma contagem:
  Atribua 0 à contagem.
  Percorra. [o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a coisa for inexistente, cancele.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se atribua um temporizador para uma string;
Etapas para que se converta um temporizador para uma string:
  Converta os ticks deste temporizador para a string.

Etapas para que se atribua a string desse temporizador para uma string:
  Converta os ticks deste temporizador para a string.

Etapas para que se atribua os ticks desse temporizador para uns ticks:
  Atribua os total ticks deste temporizador aos ticks.
  Se a contagem deste temporizador for 0, cancele.
  Atribua a contagem de ticks do sistema a uns segunda ticks. 
  Subtraia os start ticks deste temporizador desde os segunda ticks.
  Adicione os segunda ticks para os ticks.

Etapas para que se atribua um segmento inicial sobre o stack:
  Aloque memória para um stack entry.
  Atribua o segmento inicial à string desta stack entry.
  Anteponha o stack entry para o stack.

Etapas para que se quit;
Etapas para que se relinquish control:
  Desmanche a fila de eventos.
  Crie um event.
  Atribua "fechamento do programa" à categoria deste event.
  Enfileire o event.

Um quora é uma coisa com \ quora é abreviação de "question or answer"
  uma string e 
  uma cor. 

Etapas para que se quote uma string:
    \ inserts leading, trailing e nested double-quotes
  Atribua as aspas duplas a uma segunda string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Posponha o conteúdo deste first endereço de memória do pedaço deste subtexto para a segunda string.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto for as aspas duplas, posponha as aspas duplas para a segunda string.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]
  Posponha as aspas duplas para a segunda string.
  Atribua a segunda string à string.

An refer é uma coisa com 
  Uma string e 
  Um endereço de memória (reference).

Etapas para que se atualize a tela usando uma caixa:
  Call "gdi32.dll" "BitBlt" com 
    O tela canvas 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e A largura desta caixa 
    e A altura desta caixa 
    e O quadro atual 
    e A coordenada esquerda desta caixa 
    e A coordenada superior desta caixa 
    e 13369376 [SRCCOPY].

Etapas para que se relembre um text:
  Se o text for inexistente, cancele.
  Destrua os redos deste text.
  Copie o text a uma segunda text.
  Redimensione proporcionalmente a segunda text para 1/1.
  Posponha a segunda text para os undos deste text.
  Limite os undos deste text para o max text undos.
  Ligue o detector de alteração deste text.

Etapas para que se relembre um text com um operação:
  Se o text for inexistente, cancele.
  Se o última operação deste text for a operação, acione o detector de alteração deste text; exit.
  Relembre o text.
  Atribua o operação à última operação deste text.

Etapas para que se relembre where we are:
  Save o context.

Etapas para que se remove algum tipo de pedaços selecionados em um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Atribua a seleção deste text a uma seleção.
  Normalize a seleção.
  Obtenha uma row usando o anchor número da linha desta seleção e o text.
  Lance um subtexto sobre a string deste row.
  Atribua o first endereço de memória do pedaço deste subtexto mais o anchor column# desta seleção menos 2 ao last endereço de memória do pedaço deste subtexto.
  Obtenha uma segunda row usando o número de linhas do cursor desta seleção e o text.
  Lance um segundo subtexto sobre a string desta segunda row.
  Atribua o first endereço de memória do pedaço deste segundo subtexto mais o caret column# desta seleção menos 1 ao first endereço de memória do pedaço deste segundo subtexto.
  Atribua o subtexto junto com o segundo subtexto à string desta row.
  Remove as rows of o text entre o next desta row e a segunda row.
  Atribua o anchor desta seleção ao caret deste text.
  Desvencilhe-se de o text.

Etapas para que se remova pedaços de um text (backspace over um return):
  Se o text for inexistente, cancele.
  Se o número de linhas do cursor deste text for 1, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text menos 1 e o text.
  Atribua a quantidade de caracteres desta string desta row e o número de linhas do cursor deste text menos 1 ao caret deste text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (backspace com jump):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
  Se o caret column# deste text for 1, remova pedaços de o text (backspace over um return); exit.
  Jump o caret left no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (backspace):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
  Se o caret column# deste text for 1, remova pedaços de o text (backspace over um return); exit.
  Mova o caret left no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (forward delete um return):
  Se o text for inexistente, cancele.
  Se o número de linhas do cursor deste text for a contagem de linhas deste text, cancele.
  Atribua 1 e o número de linhas do cursor deste text mais 1 ao caret deste text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (forward delete com jump):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text é a quantidade de caracteres desta string desta row, remova pedaços de o text (forward delete um return); exit.
  Jump o caret right no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remova pedaços de um text (forward delete):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove algum tipo de pedaços selecionados no text; exit.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o caret column# deste text é a quantidade de caracteres desta string desta row, remova pedaços de o text (forward delete um return); exit.
  Mova o caret right no text.
  Remove algum tipo de pedaços selecionados no text.

Etapas para que se remove cada pedaço em um text:
  Se o text for inexistente, cancele.
  Atribua "" ao text.

Etapas para que se remove o first pedaço desde uma string:
  Lance um subtexto sobre o first pedaço of a string.
  Remova pedaços de a string usando o subtexto.

   
Etapas para que se remove o last pedaço desde uma string:
  Lance um subtexto sobre o last pedaço of a string.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove os last dois pedaços desde uma string:
  Remove trailing pedaços desde a string usando 2.

Etapas para que se remove leading pedaços desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; exit.
  Lance um subtexto sobre o first pedaço of a string.
  Atribua o first endereço de memória do pedaço deste subtexto mais a contagem menos 1 ao last endereço de memória do pedaço deste subtexto.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove leading noise desde uma string;
Etapas para que se remove algum tipo de leading noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço desta string não for irrelevante, cancele.
  Remove o first pedaço desde a string.
  Repita. [o código acima]

Etapas para que se remove a rows of um text entre uma row e uma segunda row:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Se a segunda row for inexistente, cancele.
  Se o número da linha desta row for maior do que o número da linha desta segunda row, cancele.
  Isole a row.
  Atribua o next desta segunda row a uma stop row.
  Percorra. [o código abaixo]
    Se a row for a stop row, pare.
    Atribua o next desta row a uma next row.
    Remove a row desde as rows deste text.
    Destrua a row.
    Atribua o next row à row.
  Repita. [o código acima]
  Renumber as rows deste text.

Etapas para que se remove uma coisa desde uns coisas:
  Se a coisa for inexistente, cancele.
  Se a coisa for o first destas coisas, atribua o next desta coisa ao first destas coisas.
  Se a coisa for o last destas coisas, atribua o previous desta coisa ao last destas coisas.
  Se o next desta coisa não for inexistente, atribua o previous desta coisa ao previous deste next desta coisa.
  Se o previous desta coisa não for inexistente, atribua o next desta coisa ao next deste previous desta coisa.
  Esvazie o next desta coisa.
  Esvazie o previous desta coisa.

Etapas para que se remove trailing pedaços desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; exit.
  Lance um subtexto sobre o last pedaço of a string.
  Atribua o last endereço de memória do pedaço deste subtexto menos a contagem mais 1 ao first endereço de memória do pedaço deste subtexto.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove trailing noise desde uma string;
Etapas para que se remove algum tipo de trailing noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste last endereço de memória do pedaço desta string não for irrelevante, cancele.
  Remove o last pedaço desde a string.
  Repita. [o código acima]

Etapas para que se rename um endereço completo para um segundo endereço completo no sistema de arquivos:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Isole o segundo endereço completo.
  Remove algum tipo de trailing barra invertida desde o segundo endereço completo.
  Modifique através do caractere NUL o segundo endereço completo.
  Call "kernel32.dll" "MoveFileA" com 
    O first deste endereço completo 
    e O first deste segundo endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro ao renomear o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se renumber uns rows:
  Obtenha uma row desde a rows.
  Se a row for inexistente, cancele.
  Adicione 1 para um número da linha.
  Atribua o número da linha ao número da linha desta row.
  Repita. [o código acima]

Etapas para que se replace um pedaço com um segundo pedaço em uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o pedaço, adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
    Atribua o segundo pedaço ao conteúdo deste first endereço de memória do pedaço deste subtexto.
    Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

A reply é uma reply.

Uma reply é uma string.

Etapas para que se reenfileire um event:
  Copie o event a uma segundo event.
  Enfileire a segundo event.

Etapas para que se reset o alphabet:
  Atribua o 'A' maiúsculo ao next letra.

Etapas para que se reset o caret of um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao caret deste text.

Etapas para que se reset o context:
  Restore o context.
  Save o context.

Etapas para que se reset uma contagem:
  Atribua 0 à contagem.

Etapas para que se reset o drawing origin:
  Defina o drawing origin para o zero localização.

Etapas para que se reset um detector:
  Desative o detector.

Etapas para que se reset o origin of um text:
  Se o text for inexistente, cancele.
  Atribua a margin deste text à coordenada x deste text.
  Atribua 0 à coordenada y deste text.

Etapas para que se reset as rainbow cors:
  Atribua 0 ao número atual da cor do arco-íris.

Etapas para que se reset um temporizador:
  Atribua 0 à contagem deste temporizador.
  Atribua 0 aos start ticks deste temporizador.
  Atribua 0 aos total ticks deste temporizador.

Etapas para que se redimensione uma caixa usando um par de números racionais;
Etapas para que se redimensione uma caixa usando uma par de números fracionários:
  Atribua o x-extent desta caixa a um largura.
  Atribua o y-extent desta caixa a uma altura.
  Redimensione proporcionalmente o largura usando a fração deste par de números fracionários.
  Redimensione proporcionalmente o altura usando a segunda fração deste par de números fracionários.
  Atribua a coordenada esquerda desta caixa mais o largura à coordenada direita desta caixa.
  Atribua a coordenada superior desta caixa mais o altura à coordenada inferior desta caixa.

Etapas para que se redimensione uma caixa usando um twip par de números:
  Adicione o número X deste twip par de números para a coordenada direita desta caixa.
  Adicione o número Y deste twip par de números para a coordenada inferior desta caixa.

Etapas para que se redimensione um elipse usando um par de números racionais;
Etapas para que se redimensione um elipse usando uma par de números fracionários:
  Redimensione a caixa desta elipse usando o par de números fracionários.

Etapas para que se redimensione um elipse usando um twip par de números:
  Redimensione a caixa desta elipse usando o twip par de números.

Etapas para que se redimensione um line usando um par de números racionais;
Etapas para que se redimensione um line usando uma par de números fracionários:
  Atribua a caixa desta line a uma caixa.
  Subtraia o canto superior esquerdo desta caixa desde o start desta line.
  Redimensione proporcionalmente o start desta line usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para o start desta line.
  Subtraia o canto superior esquerdo desta caixa desde o end desta line.
  Redimensione proporcionalmente o end desta line usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para o end desta line.

Etapas para que se redimensione um line usando um twip par de números:
  Atribua a caixa desta line a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Make uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione o line usando o par de números fracionários.

Etapas para que se redimensione um imagem para um largura por uma altura:
  Se o imagem for inexistente, cancele.
  Atribua o largura dividido pelo tpp a um pixel largura.
  Atribua o altura dividido pelo tpp a um pixel altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
    A pixel largura 
    e A pixel altura 
    e 0 
    e 137224 [pixelformat24bpprgb] 
    e 0 
    e O endereçamento desse gpbitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
    O gpbitmap 
    e O endereçamento desse gpgraphic.
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com
   O gpgraphic 
   e O gpbitmap desta imagem
   e 0 
   e 0 
   e A pixel largura 
   e A pixel altura
   e 0 
   e 0 
   e A largura deste gpbitmap desta imagem menos 1 
   e A altura deste gpbitmap desta imagem menos 1
   e 2 [unitpixel] 
   e nil 
   e nil 
   e 0.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
   O gpgraphic.
  Destrua o gpbitmap desta imagem.
  Atribua o gpbitmap ao gpbitmap desta imagem.
  Ajuste o imagem (extract caixas desde gpbitmap).
  Limpe os data desta imagem.

Etapas para que se redimensione um polígono usando um par de números racionais;
Etapas para que se redimensione um polígono usando uma par de números fracionários:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia o canto superior esquerdo desta caixa desde a localização deste vértice.
    Redimensione proporcionalmente a localização deste vértice usando o par de números fracionários.
    Adicione o canto superior esquerdo desta caixa para a localização deste vértice.
  Repita. [o código acima]

Etapas para que se redimensione um polígono usando um twip par de números:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Make uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione o polígono usando o par de números fracionários.

Etapas para que se redimensione um text usando um par de números racionais;
Etapas para que se redimensione um text usando uma par de números fracionários:
  Se o text for inexistente, cancele.
  Redimensione a caixa deste text usando o par de números fracionários.
  Wrap o text.

Etapas para que se redimensione um text usando um twip par de números:
  Se o text for inexistente, cancele.
  Redimensione a caixa deste text usando o twip par de números.
  Wrap o text.

Etapas para que se restart um temporizador:
  Adicione 1 para a contagem deste temporizador.
  Se a contagem deste temporizador não for 1, cancele.
  Atribua a contagem de ticks do sistema aos start ticks deste temporizador. \ a tick contagem deste system

Etapas para que se restore um canvas:
  Call "gdi32.dll" "RestoreDC" com 
    O canvas [HDC]
    e -1. \ nSavedDC - O estado salvo a ser restaurado. 
    \Se este parâmetro for positivo, ele representa uma instância específica do estado a ser restaurado. 
    \Se este parâmetro for negativo, ele representa uma instância relativa ao estado atual. 
    \Nesse caso, o valor -1 restaura o estado salvo mais recentemente.

Etapas para que se restore um context:
  Obtenha um saved context desde o context stack.
  Se o saved context for inexistente, cancele.
  Atribua a localização deste saved context à localização deste context.
  Atribua a orientação deste saved context à orientação deste context.
  Atribua a tamanho da letra deste saved context à tamanho da letra deste context.
  Atribua a cor deste saved context à cor deste context.
  Atribua o número deste saved context ao número deste context.
  Remove o saved context desde o context stack.
  Destrua o saved context.

Etapas para que se restore uma window:
  Call "user32.dll" "ShowWindow" com 
    A window 
    e 9 [SW_RESTORE].

Etapas para que se reverse algum tipo de rows selecionadas of um text:
  Se o text for inexistente, cancele.
  Split a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
  Reverse o rows selecionadas.
  Posponha a rows para as rows deste text.
  Posponha o rows selecionadas para as rows deste text.
  Posponha a segunda rows para as rows deste text.
  Renumber as rows deste text.

Etapas para que se reverse uma cor:
  Se a cor for a cor preta, atribua a cor branca à cor; exit.
  Se a cor for a cor branca, atribua a cor preta à cor; exit.
  Atribua 1000 menos a luminosidade desta cor à luminosidade desta cor.
    \Atribua 1000 menos a saturação desta cor à saturação desta cor.
  Adicione 1800 para a matiz desta cor. Normalize a matiz desta cor.

Etapas para que se invert um detector;
Etapas para que se reverse um detector:
  Se o detector for 1, atribua 0 ao detector; exit.
  Atribua 1 ao detector.

Etapas para que se reverse uma string:
    \ could ser more efficient
  Isole a string.
  Limpe o original string.
  Percorra. [o código abaixo]
    Se a string estiver em branco, pare.
    Obtenha um character desde a string (backwards).
    Posponha o character para o original string.
  Repita. [o código acima]

Etapas para que se reverse uns coisas:
  Permute  as coisas com uns segunda coisas.
  Percorra. [o código abaixo]
    Atribua o last destas segunda coisas a uma coisa.
    Se a coisa for inexistente, cancele.
    Mova a coisa desde a segunda coisas para as coisas.
  Repita. [o código acima]

Um deslocamento vertical é um número.
Um deslocamento horizontal é um número.

Etapas para que se rotate uma caixa:
  Atribua o center desta caixa a um center localização.
  Atribua a caixa a uma segunda caixa.
  Atribua a coordenada Y deste center menos a coordenada superior desta segunda caixa mais a coordenada X deste center à coordenada direita desta caixa.
  Atribua a coordenada esquerda desta segunda caixa menos a coordenada X deste center mais a coordenada Y deste center à coordenada superior desta caixa.
  Atribua a coordenada Y deste center menos a coordenada inferior desta segunda caixa mais a coordenada X deste center à coordenada esquerda desta caixa.
  Atribua a coordenada direita desta segunda caixa menos a coordenada X deste center mais a coordenada Y deste center à coordenada inferior desta caixa.

Etapas para que se rotate um elipse:
  Rotate a caixa desta elipse.

Etapas para que se rotate um gpimage:
  Se o gpimage for inexistente, cancele.
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O gpimage 
    e 1 [Rotate90FlipNone].

Etapas para que se rotate um gpimage usando um ângulo:
    \ ângulo pode ser 0, 900, 1800, 2700
  Se o gpimage for inexistente, cancele.
  Atribua 0 [RotateNoneFlipNone] a um número.
  Se o ângulo for 900, atribua 1 [Rotate90FlipNone] ao número.
  Se o ângulo for 1800, atribua 2 [Rotate180FlipNone ] ao número.
  Se o ângulo for 2700, atribua 3 [Rotate270FlipNone ] ao número.
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O gpimage 
    e O número.

Etapas para que se rotate um line:
  Atribua o center desta line a um center localização.
  Rotate o start desta line around o center.
  Rotate o end desta line around o center.

Etapas para que se rotate um imagem:
  Se o imagem for inexistente, cancele.
  Adicione 900 para o ângulo de rotação desta imagem.
  Se o mirror detector desta imagem estiver ativo, adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Rotate a caixa desta imagem.
  Rotate a caixa intacta desta imagem.
  Atribua o center desta caixa desta imagem a um center localização.
  Atribua o center desta caixa intacta desta imagem a uma segunda center localização.
  Atribua a coordenada Y deste center menos a coordenada Y desta segunda center mais a coordenada X deste center ao número X desse twip par de números.
  Subtraia a coordenada X desta segunda center desde o número X deste twip par de números.
  Atribua a coordenada Y deste center mais a coordenada X desta segunda center menos a coordenada X deste center ao número Y deste twip par de números.
  Subtraia a coordenada Y desta segunda center desde o número Y deste twip par de números.
  Mova a caixa intacta desta imagem usando o twip par de números.
  Rotate o gpbitmap desta imagem.

Etapas para que se rotate um polígono:
  Se o polígono for inexistente, cancele.
  Atribua o center deste polígono a um center localização.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Rotate a localização deste vértice around o center.
  Repita. [o código acima]

Etapas para que se rotate uma localização around um center localização:
  Atribua a localização a uma segunda localização.
  Atribua a coordenada Y deste center menos a coordenada Y desta segunda localização mais a coordenada X deste center à coordenada x desta localização.
  Atribua a coordenada X desta segunda localização menos a coordenada X deste center mais a coordenada Y deste center à coordenada y desta localização.

Etapas para que se rotate um text:
  Se o text for inexistente, cancele.
  Rotate a caixa deste text.
  Wrap o text.

Etapas para que se arredonde um número para um segundo número:
  Arredonde o número para o múltiplo imediato of o segundo número.

Etapas para que se arredonde um número para baixo para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número.
  Multiplique o número pelo segundo número.

Etapas para que se arredonde um número para o múltiplo imediato of um outro número:
  Se o outro número for 0, cancele.
  Isole o outro número.
  Divida o número pelo outro número usando um quociente e um resto.
  Divida o outro número por 2.
  Se o resto for maior do que ou igual ao outro número, arredonde o número para cima para o múltiplo imediato of o original outro número; exit.
  Arredonde o número para baixo para o múltiplo imediato of o original outro número.

Etapas para que se arredonde um número para cima para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número usando um quociente e um resto.
  Se o resto for 0, cancele.
  Adicione o segundo número menos o resto para o número.

Etapas para que se arredonde um par de números para uma segundo par de números:
  Arredonde o par de números para o múltiplo imediato of a segundo par de números.

Etapas para que se arredonde um par de números para o múltiplo imediato of uma segundo par de números:
  Arredonde o número X deste par de números para o múltiplo imediato of o número X desta segundo par de números.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número Y desta segundo par de números.

Etapas para que se arredonde um par de números para o múltiplo imediato of um número:
  Arredonde o número X deste par de números para o múltiplo imediato of o número.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número.

Etapas para que se arredonde um par de números para um número:
  Arredonde o par de números para o múltiplo imediato of o número.

Um caixa arredondada é uma caixa com
  Uma coordenada esquerda, 
  Uma coordenada superior, 
  Uma coordenada direita, 
  Uma coordenada inferior,
  Um canto superior esquerdo localização at a coordenada esquerda , 
  Um canto inferior direito localização at a coordenada direita, e 
  Um raio.

An row é uma coisa com 
  Um número da linha e 
  Uma string.

Um número da linha é um número.

Etapas para que se save um canvas:
  Call "gdi32.dll" "SaveDC" com o canvas.

Etapas para que se save um context:
  Aloque memória para um saved context.
  Atribua a localização deste context à localização deste saved context.
  Atribua a orientação deste context à orientação deste saved context.
  Atribua a tamanho da letra deste context à tamanho da letra deste saved context.
  Atribua a cor deste context à cor deste saved context.
  Atribua o número deste context ao número deste saved context.
  Anteponha o saved context para o context stack.

O saved memory hbitmap é um hbitmap.

O saved tpp é um número.

Etapas para que se say um número:
  Atribua o número a uma string.
  Say a string.

Etapas para que se say uma string;
Etapas para que se speak uma string:
  Se o silent detector estiver ativo, cancele.
    \Se la bandera silenciosa estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para um wide string.
  Modifique através do caractere NUL a wide string.
  Call o speak desta vtable deste talker com 
    O talker 
    e O first deste wide string 
    e 17 [SVSFDefault+SVSFlagsAsync +SVSFIsNotXML] 
    e 0.

Etapas para que se say uma string e wait;
Etapas para que se speak uma string e wait:
  Se o silent detector estiver ativo, cancele.
  Se la bandera silenciosa estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para um wide string.
  Modifique através do caractere NUL a wide string.
  Call o speak desta vtable deste talker com 
    O talker 
    e O first deste wide string 
    e 16 [SVSFDefault+SVSFIsNotXML] 
    e 0.

Etapas para que se redimensione proporcionalmente uma caixa usando um ratio;
Etapas para que se redimensione proporcionalmente uma caixa usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada esquerda desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada superior desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada direita desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada inferior desta caixa usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a caixa usando a fração.

Etapas para que se redimensione proporcionalmente um elipse usando um ratio;
Etapas para que se redimensione proporcionalmente um elipse usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta elipse usando a fração.

Etapas para que se redimensione proporcionalmente um elipse para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a elipse usando a fração.

Etapas para que se redimensione proporcionalmente uma font usando um ratio;
Etapas para que se redimensione proporcionalmente uma font usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a altura desta font usando a fração.

Etapas para que se redimensione proporcionalmente uma fração usando uma segunda fração;
Etapas para que se multiplique uma fração por uma segunda fração:
  Multiplique o numerador desta fração pelo numerador desta segunda fração.
  Multiplique o denominador desta fração pelo denominador desta segunda fração.
  Reduce a fração.

Etapas para que se redimensione proporcionalmente um line usando um ratio;
Etapas para que se redimensione proporcionalmente um line usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente o start desta line usando a fração.
  Redimensione proporcionalmente o end desta line usando a fração.

Etapas para que se redimensione proporcionalmente um line para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o line usando a fração.

Etapas para que se redimensione proporcionalmente um par de números usando um ratio;
Etapas para que se redimensione proporcionalmente um par de números usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente o número X deste par de números usando a fração.
  Redimensione proporcionalmente o número Y deste par de números usando a fração.

Etapas para que se redimensione proporcionalmente um par de números usando um par de números racionais;
Etapas para que se redimensione proporcionalmente um par de números usando uma par de números fracionários:
  Redimensione proporcionalmente o número X deste par de números usando a fração deste par de números fracionários.
  Redimensione proporcionalmente o número Y deste par de números usando a segunda fração deste par de números fracionários.

Etapas para que se redimensione proporcionalmente um par de números para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o par de números usando a fração.

Etapas para que se redimensione proporcionalmente um imagem usando um ratio;
Etapas para que se redimensione proporcionalmente um imagem usando um fração:
  Se a imagem for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta imagem usando a fração.
  Redimensione proporcionalmente a caixa intacta desta imagem usando a fração.

Etapas para que se redimensione proporcionalmente um imagem para um percentual:
  Se a imagem for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o imagem usando a fração.

Etapas para que se redimensione proporcionalmente um polígono usando um ratio;
Etapas para que se redimensione proporcionalmente um polígono usando um fração:
  Se o polígono for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Redimensione proporcionalmente o vértice usando a fração.
  Repita. [o código acima]

Etapas para que se redimensione proporcionalmente um polígono para um percentual:
  Se o polígono for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o polígono usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa arredondada usando um ratio;
Etapas para que se redimensione proporcionalmente uma caixa arredondada usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa arredondada como uma caixa usando a fração.
  Redimensione proporcionalmente o raio desta caixa arredondada usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa arredondada para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a caixa arredondada usando a fração.

Etapas para que se redimensione proporcionalmente um text para um fração:
  \ absolute
  Se o text for inexistente, cancele.
  Atribua a scale deste text a uma segunda fração.
  Flip a segunda fração.
  Multiplique a segunda fração pela fração.
  Redimensione proporcionalmente o text usando a segunda fração.

Etapas para que se redimensione proporcionalmente um text usando um ratio;
Etapas para que se redimensione proporcionalmente um text usando um fração:
  Se o text for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa deste text usando a fração.
  Redimensione proporcionalmente a origin deste text usando a fração.
  Redimensione proporcionalmente a font deste text usando a fração.
  Redimensione proporcionalmente a scale deste text usando a fração.

Etapas para que se redimensione proporcionalmente um text para um percentual:
  Se o text for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o text usando a fração.

Etapas para que se redimensione proporcionalmente um vértice usando um ratio;
Etapas para que se redimensione proporcionalmente um vértice usando um fração:
  Se o vértice for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada X deste vértice usando a fração.
  Redimensione proporcionalmente a coordenada Y deste vértice usando a fração.

O tela canvas é um canvas.

A tela é um conjunto com 
  Uma caixa, 
  Uma pixel altura e 
  Uma pixel largura.

Etapas para que se role um console usando um event:
  Se o console for inexistente, cancele.
  Encontre um sector usando a malha deste console e a localização deste event.
  Percorra. [o código abaixo]
    Se o botão direito deste mouse não estiver sendo pressionado, cancele.
    Encontre uma segunda sector usando a malha deste console e a localização deste mouse.
    Obtenha um difference entre a segunda sector e o sector.
    Se a difference for 0, repita.
    Role o text deste console usando a difference.
    Mostre o console.
    Adicione a difference para o sector.
  Repita. [o código acima]

Etapas para que se role um text para o base:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua a contagem de linhas deste text menos 1 a um número.
  Atribua - o número times a altura da linha deste text à coordenada y deste text.
  Limite o origin of o text.

  Multiplique o número por -1.
  Multiplique o número pela altura da linha deste texto.
  Adicione 2 ao número.
  Atribua o número à Coordenada Y deste texto.

Etapas para que se role um text para o caret:
  Se o text for inexistente, cancele.
  Se o column# deste caret deste text for 1, atribua a margin deste text à coordenada x deste text.
  Obtenha uma caixa pelo caret no text.
  Ajuste a caixa usando 0 e - o tpp e 0 e o tpp. \ caret caixas do not fill entire row
  Se a coordenada superior desta caixa for menor do que a coordenada superior deste text, atribua a coordenada superior deste text menos a coordenada superior desta caixa ao número Y dessa difference.
  Se a coordenada inferior desta caixa for maior do que a coordenada inferior deste text, atribua a coordenada inferior deste text menos a coordenada inferior desta caixa ao número Y desta difference.
  Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda deste text , atribua a coordenada esquerda deste text menos a coordenada esquerda desta caixa ao número X desta difference.
  Se a coordenada direita desta caixa for maior do que a coordenada direita deste text, atribua a coordenada direita deste text menos a coordenada direita desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role o text usando a difference.

Etapas para que se role um text para o caret e center it:
  Se o text for inexistente, cancele.
  Atribua a margin deste text à coordenada x deste text.
  Obtenha uma caixa pelo caret no text.
  Se a caixa estiver inside a caixa deste text, cancele.
  Ajuste a caixa usando 0 e - o tpp e 0 e o tpp. \ caret caixas don not fill entire row
  Atribua o y-extent desta caixa deste text dividido por 2 a uma altura.
  Arredonde o altura para baixo para o múltiplo imediato of a altura da linha deste text.
  Atribua a coordenada superior desta caixa deste text mais o altura a uma coordenada superior.
  Atribua a coordenada superior mais a altura da linha deste text a uma coordenada inferior.
  Se a coordenada superior desta caixa for menor do que a coordenada superior, atribua a coordenada superior menos a coordenada superior desta caixa ao número Y dessa difference.
  Se a coordenada inferior desta caixa for maior do que a coordenada inferior, atribua a coordenada inferior menos a coordenada inferior desta caixa ao número Y desta difference.
  Se a coordenada esquerda desta caixa for menor do que a coordenada esquerda deste text , atribua a coordenada esquerda deste text menos a coordenada esquerda desta caixa ao número X desta difference.
  Se a coordenada direita desta caixa for maior do que a coordenada direita deste text, atribua a coordenada direita deste text menos a coordenada direita desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role o text usando a difference.

Etapas para que se role um text para baixo one line:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua - a altura da linha deste text ao número Y dessa difference. \ reescrever esse comando
  Role o text usando a difference.

Etapas para que se role um text para baixo one página:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Subtraia o y-extent desta caixa deste text desde a coordenada Y deste text.
  Adicione a altura da linha deste text para a coordenada Y deste text.
  Limite o origin of o text.

Etapas para que se role um text usando um difference:
  Se o text for inexistente, cancele.
  Isole a difference.
  Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número X desta difference.
  Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, cancele.
  Mova a origin deste text usando a difference.
  Limite a origin of o text.

Etapas para que se role um text para o topo:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua 0 à coordenada y deste text.
  Limite o origin of o text.

Etapas para que se role um text para cima one line:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua a altura da linha deste text ao número Y dessa difference.
  Role o text usando a difference.

Etapas para que se role um text para cima one página:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Adicione o y-extent desta caixa deste text para a coordenada Y deste text.
  Subtraia a altura da linha deste text desde a coordenada Y deste text.
  Limite o origin of o text.

Um sector é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y [indicating o canto superior esquerdo of o sector].

A seed é um número.

Etapas para que se selecione cada pedaço em um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao anchor deste text.
  Atribua a quantidade de caracteres desta string deste last destas rows deste text e a contagem de linhas deste text ao caret deste text.

Etapas para que se selecione um número da linha usando um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número da linha e o text.
  Se a row for inexistente, cancele.
  Atribua o número da linha ao anchor número da linha deste text .
  Atribua 1 ao anchor column# deste text.
  Atribua o número da linha ao número de linhas do cursor deste text.
  Atribua a quantidade de caracteres desta string desta row ao caret column# deste text.

Um caixa de seleção é uma caixa.

Uma seleção é um conjunto com 
  Um anchor column#,
  Um anchor número da linha, 
  Um anchor at o anchor column#,
  Um caret column#, 
  Um número de linhas do cursor, 
  Um caret at o caret column#.

Etapas para que se send um trecho para um socket:
  Limpe o erro do fluxo de entrada/saída.
  Atribua o first endereço de memória do pedaço deste trecho a um endereço de memória.
  Atribua a quantidade de caracteres deste trecho a uma quantidade de caracteres.
  Percorra. [o código abaixo]
  Se a quantidade de caracteres for 0, pare.
    Call "ws2_32.dll" "send" com 
       O socket 
       e O endereço de memória 
       e A quantidade de caracteres 
       e 0 
       devolvendo um número.
    Se o número for -1 [SOCKET_ERROR ], atribua "Ocorreu um erro na hora de enviar dados." ao erro do fluxo de entrada/saída; exit.
    Subtraia o número desde a quantidade de caracteres.
    Adicione o número para o endereço de memória.
  Repita. [o código acima]

Etapas para que se send um data string para um winhttp request:
  Se o winhttp request for inexistente, cancele.
  Call "winhttp.dll" "WinHttpSendRequest" com 
    O request número identificador deste winhttp request 
    e 0 [WINHTTP_NO_ADDITIONAL_HEADERS] 
    e 0 e o first destes data 
    e A quantidade de caracteres destes data 
    e A quantidade de caracteres destes data 
    e 0 
    devolvendo um result número.
  Se o result for 0, atribua "Erro. Não foi possível enviar a solicitação." ao erro do fluxo de entrada/saída; exit.

Etapas para que se send um email:
  Limpe o erro do fluxo de entrada/saída.
  \ crie socket
  Crie um socket usando o smtp server deste email e 25.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
    \ initial receive here por date/time stuff desde server
  Receive um response string desde o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send HELO
  Send "HELO " junto com o nome deste module junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send MAIL FROM: <xxx>
  Send "MAIL FROM: <" junto com o sender deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send RCPT TO: <xxx>
  Send "RCPT TO: <" junto com o recipient deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send DATA
  Send "DATA" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
  Limpe um temp string.
  Posponha "De: " junto com o sender deste email junto com o texto CRLF para o temp string.
  Posponha "Para: " junto com o recipient deste email junto com o texto CRLF para o temp string.
  Posponha "Assunto: " junto com o subject deste email junto com o texto CRLF ao temp string.
  Posponha "Reply-To: " junto com o sender deste email junto com o texto CRLF ao temp string.
  Posponha o texto CRLF para o temp string.
  Posponha a message deste email para o temp string (handling email transparency).
  Posponha o texto CRLF seguido de "." junto com o texto CRLF para o temp string.
  Send o temp string para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; exit.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; exit.
  \ send QUIT
  Send "QUIT" junto com o texto CRLF para o socket.
  \ destrua socket
  Destrua o socket.

Etapas para que se send um message desde um sender para um recipient:
  Send o message para o recipient desde o sender.

Etapas para que se send um message desde um sender para um recipient via um smtp server:
  Send o message para o recipient desde o sender via o smtp server.

Etapas para que se send um message desde um sender para um recipient com um subject:
  Send o message para o recipient desde o sender com o subject.

Etapas para que se send um message desde um sender para um recipient com um subject via um smtp server:
  Send o message para o recipient desde o sender com o subject via o smtp server.

Etapas para que se send um message para um recipient desde um sender:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender com um subject:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender com um subject via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send uma string para um socket e receive um response string:
  Limpe a response string.
  Send a string para o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Receive a response string desde o socket.

Um sender é uma string.

Etapas para que se defina o código da cor of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetTextColor" com 
    O canvas e o código da cor.

Etapas para que se defina o drawing origin para uma localização:
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 112 [PhysicalOffsetYX] 
    devolvendo o número X desse par de números.
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 113 [PhysicalOffsetY ] 
    devolvendo o número Y deste par de números.
  Negate o par de números.
  Se o quadro atual não for o printer canvas, limpe o par de números.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e O número X deste par de números 
    e O número Y deste par de números 
    e nil.
  Isole a localização.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e O endereçamento desta localização 
    e 1.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    e nil.

Etapas para que se acione um detector;
Etapas para que se ative um detector;
Etapas para que se dispare um detector;
Etapas para que se toque um detector;
Etapas para que se ligue um detector:
  Atribua 1 ao detector. \ era "Atribua sim ao detector." O valor binário do termo sim era herdado do CAL-1000 de acordo com o Dan.

Etapas para que se defina um endereço completo para read-write mode:
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O first deste endereço completo 
    devolvendo um número.
  Conjuncione logicamente o número com -2 [everything except FILE_ATTRIBUTE_READONLY].
  Call "kernel32.dll" "SetFileAttributesA" com 
    O first deste endereço completo 
    e O número.

Um sheet é uma caixa.

Etapas para que se mostre um console:
  Se o console for inexistente, cancele.
  Save o quadro atual.
  Pinte o console.
  Atualize o tela usando a caixa deste console.
  Restore o quadro atual.

Etapas para que se mostre um cursor:
  Call "user32.dll" "SetCursor" com o cursor.
  Call "user32.dll" "ShowCursor" com 1 
    devolvendo um número.
  Se o número for maior do que 0, cancele.
  Repita. [o código acima]

Etapas para que se mostre um terminal:
  Se o terminal for inexistente, cancele.
  Save o quadro atual.
  Pinte o terminal.
  Atualize o tela usando a caixa deste terminal.
  Restore o quadro atual.

Etapas para que se shrink uma caixa por uns twips;
Etapas para que se indent uma caixa uns twips;
Etapas para que se indent uma caixa por uns twips;
Etapas para que se indent uma caixa uns twips sobre cada side;
Etapas para que se indent uma caixa usando uns twips:
  Adicione os twips para a coordenada esquerda desta caixa.
  Adicione os twips para a coordenada superior desta caixa.
  Subtraia os twips desde a coordenada direita desta caixa.
  Subtraia os twips desde a coordenada inferior desta caixa.

Etapas para que se feche o programa;
Etapas para que se feche o nosso programa;
Etapas para que se feche nosso programa;
Etapas para que se feche tudo;
Etapas para que se shut para baixo:
  Destrua o Bíblia.
  Destrua o stack.
  Destrua o dicionário léxico.
  Destrua o console.
  Destrua o terminal.
  Finalize o context.
  Finalize os canvases.
  Finalize o mouse.
  Finalize os cursors.
  Finalize as fonts.
  Finalize a window.
  Finalize o tela.
  Finalize as cors.
  Finalize o module.
  Finalize o talker.
  Finalize gdi+.
  Finalize winsock.
  Finalize COM.

Etapas para que se shut para baixo o cgi:
  Finalize o cgi.
  Finalize o module.
  Finalize winsock.

O silent detector é um detector.

Etapas para que se simplify um reply:
  Se o reply estiver em branco, pare.
  Obtenha um pedaço desde o reply.
  Se o pedaço é algum tipo de sinal de pontuação, repita.
  Posponha o pedaço para uma string.
  Repita. [o código acima]
  Atribua a string ao reply.

Um size é uns twips.

Etapas para que se skip algum tipo de leading linefeed pedaço em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for o linefeed pedaço, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.

Etapas para que se skip algum tipo de leading noise em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for irrelevante, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se skip algum tipo de non-alfanumérico pedaços em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto for alfanumérico, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se skip um line sobre o terminal:
  Escreva "" sobre o terminal.

Etapas para que se skip palavra characters em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o subtexto está sobre alguma espécie de contração, adicione 1 para o first endereço de memória do pedaço deste subtexto; repita.
  Se o conteúdo deste first endereço de memória do pedaço deste subtexto não for alfanumérico, cancele.
  Adicione 1 para o first endereço de memória do pedaço deste subtexto.
  Repita. [o código acima]

Etapas para que se lance um percorredor sobre um segundo percorredor:
  Lance o segmento final deste percorredor sobre o segmento final deste segundo percorredor.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas para que se lance um percorredor sobre uma string:
  Lance o subtexto original deste percorredor sobre a string.
  Lance o segmento final deste percorredor sobre a string.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas para que se lance um subtexto sobre algum tipo de pedaços selecionados em uma row of um text:
  Limpe o subtexto.
  Se o text for inexistente, cancele.
  Se a row of o text não estiver selecionado, cancele.
  Lance o subtexto sobre a string deste row.
  Atribua a normalized seleção deste text a uma seleção.
  Se o número da linha desta row é o número de linhas do cursor desta seleção, atribua o first endereço de memória do pedaço deste subtexto mais o caret column# desta seleção menos 2 ao last endereço de memória do pedaço deste subtexto.
  Se o número da linha desta row é o anchor número da linha desta seleção, atribua o first endereço de memória do pedaço deste subtexto mais o anchor column# desta seleção menos 1 ao first endereço de memória do pedaço deste subtexto.

Etapas para que se lance um subtexto sobre o first pedaço of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o first endereço de memória do pedaço desta string ao last endereço de memória do pedaço deste subtexto.

Etapas para que se lance um subtexto sobre o last pedaço of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o last endereço de memória do pedaço desta string ao first endereço de memória do pedaço deste subtexto.

Etapas para que se suavize um polígono:
  Se o polígono for inexistente, cancele.
  Se a contagem destes vértices deste polígono for menor do que 3, cancele.
  Se o polígono estiver closed, posponha a localização deste next deste first vértice deste polígono para o polígono; ative um detector.
  Atribua o first vértice deste polígono a um left vértice.
  Percorra. [o código abaixo]
    Se o next deste left vértice for inexistente, pare.
    Atribua o next deste left vértice a um right vértice.
    Obtenha um center localização usando a localização deste left vértice e a localização deste right vértice.
    Insira o center ao polígono after o left vértice.
    Atribua o next deste left vértice a um new vértice.
    Se o previous deste left vértice for inexistente, atribua o right vértice ao left vértice; repita.
    Obtenha uma segunda center localização usando a localização deste previous deste left vértice e a localização deste new vértice.
    Obtenha um difference entre a segunda center e a localização deste left vértice.
    Divida a difference por 2.
    Adicione a difference para a localização deste left vértice.
    Atribua o right vértice ao left vértice.
  Repita. [o código acima]
  Se o detector não estiver ativo, cancele.
  Destrua o first vértice deste polígono usando o polígono.
  Destrua o last vértice deste polígono usando o polígono.

Etapas para que se suavize um polígono uns times; 
Etapas para que se suavize um polígono uns vezes:
    \ this use para "times" é um fluke, I think -- see "some times é um número"
  Isole o times.
  Percorra. [o código abaixo]
    Se o times for 0, cancele.
    Suavize o polígono.
    Subtraia 1 desde o times.
  Repita. [o código acima]

Some vezes é um número.

Um smtp server é uma string.

Um socket é um endereço de memória.

Etapas para que se classifique algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Split a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
  Classifique o rows selecionadas.
  Posponha a rows para as rows deste text.
  Posponha o rows selecionadas para as rows deste text.
  Posponha a segunda rows para as rows deste text.
  Renumber as rows deste text.

Etapas para que se classifique uns rows:
  Se o first destas rows for o last destas rows, cancele.
  Split a rows a uns left rows e umas right rows.
  Classifique as left rows.
  Classifique as right rows.
  Percorra. [o código abaixo]
    Atribua o first destas left rows a uma left row.
    Atribua o first destas right rows a uma right row.
    Se a left row for inexistente, posponha as right rows para as rows; exit.
    Se a right row for inexistente, posponha as left rows para as rows; exit.
    Se a string desta left row for maior do que a string desta right row, mova a right row desde as right rows para as rows; repita.
    Mova a left row desde as left rows para as rows.
  Repita. [o código acima]

Etapas para que se split um trecho para uns dyads:
  Destrua o dyads.
  Se o trecho estiver em branco, cancele.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Mova o percorredor usando o & comercial.
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Crie um dyad.
    Posponha o dyad para o dyads.
    Split o segmento inicial deste percorredor a um nome subtexto e um query subtexto usando o sinal de igualdade.
    Atribua o nome subtexto ao nome deste dyad.
    Converta o query subtexto como um texto de consulta ao value deste dyad.
  Repita. [o código acima]

Etapas para que se split um pedaço para uma cifra binária e uma segunda cifra binária:
  Atribua o pedaço à cifra binária.
  Desloque a cifra binária right 4 bits.
  Atribua o pedaço ao segunda cifra binária.
  Conjuncione logicamente a segunda cifra binária com 15.

Etapas para que se split um line para uma segunda line e um terceiro line:
  Isole o line.
  Atribua o center desta line a um center localização.
  Atribua o start desta line e o center ao segunda line.
  Atribua o center e o end desta line ao terceiro line.

Etapas para que se split um número para um word e uma segunda word:
  Isole o número.
  Desloque o número right 16 bits.
  Atribua o número ao word.
  Atribua o original número ao segunda word.

Etapas para que se split a rows of um text para uns rows e uns rows selecionadas e uns segunda rows:
  Se o text for inexistente, limpe as rows; limpe o rows selecionadas; limpe as segunda rows; exit.
  Percorra. [o código abaixo]
    Atribua o first destas rows deste text a uma row.
    Se a row for inexistente, cancele.
    Remove a row desde as rows deste text.
    Se a row of o text estiver selecionado, acione um detector; posponha a row para o rows selecionadas; repita.
    Se o detector estiver ativo, posponha a row para a segunda rows; repita.
    Posponha a row para a rows.
  Repita. [o código acima]

Etapas para que se split uma string para um left subtexto e um right subtexto usando um separator pedaço:
  Limpe o left .
  Limpe o right subtexto.
  Se a string estiver em branco, cancele.
  Atribua o first endereço de memória do pedaço desta string ao first endereço de memória do pedaço desse subtexto.
  Atribua o first endereço de memória do pedaço deste subtexto menos 1 ao last endereço de memória do pedaço deste subtexto.
  Percorra. [o código abaixo]
    Se o last endereço de memória do pedaço deste subtexto for maior do que o last endereço de memória do pedaço desta string, cancele.
    Adicione 1 para o last endereço de memória do pedaço deste subtexto.
    Se o conteúdo deste last endereço de memória do pedaço deste subtexto for o separator pedaço, pare.
  Repita. [o código acima]
  Atribua o first endereço de memória do pedaço deste subtexto ao first endereço de memória do pedaço deste left subtexto.
  Atribua o last endereço de memória do pedaço deste subtexto menos 1 ao last endereço de memória do pedaço deste left subtexto.
  Atribua o last endereço de memória do pedaço deste subtexto mais 1 ao first endereço de memória do pedaço deste right subtexto.
  Atribua o last endereço de memória do pedaço desta string ao last endereço de memória do pedaço deste right subtexto.

Etapas para que se split uma string para uns conjunto de textos usando um separator pedaço:
  Destrua o conjunto de textos.
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor usando o separator pedaço.
    Adicione o segmento inicial deste percorredor para o conjunto de textos.
    Se o segmento final deste percorredor estiver em branco, pare.
  Repita. [o código acima]
  Se o conteúdo deste last endereço de memória do pedaço desta string não for o separator pedaço, cancele.
  Adicione "" para o conjunto de textos.

Etapas para que se split uns coisas para uns left coisas e uns right coisas:
  Se  as coisas estiverem vazio, limpe o left coisas; limpe o right coisas; exit.
  Atribua a contagem destas coisas dividido por 2 a uma contagem.
  Percorra. [o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a contagem for 0, pare.
    Subtraia 1 desde a contagem.
    Repita. [o código acima]
    Split  as coisas ao left coisas e o right coisas at o coisa.

Etapas para que se split uns coisas para uns left coisas e uns right coisas at um coisa:
  Limpe o left coisas.
  Limpe o right coisas.
  Se a coisa for inexistente, permute  as coisas com o left coisas; exit.
  Se o previous desta coisa for inexistente, permute  as coisas com o left coisas; exit.
    \ abra para cima o left chain
  Atribua o first destas coisas ao first destas left coisas.
  Atribua o previous desta coisa ao last destas left coisas.
  Esvazie o next deste previous desta coisa.
    \ abra para cima o right chain
  Atribua a coisa ao first destas right coisas.
  Esvazie o previous desta coisa.
  Atribua o last destas coisas ao last destas right coisas.
    \ fix o original chain
  Limpe as coisas.

Etapas para que se split um word para um pedaço e um segundo pedaço:
  Isole o word.
  Desloque o word right 8 bits.
  Atribua o word ao pedaço.
  Atribua o original word ao segundo pedaço.

Um localização é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y e 
  Uma left at a coordenada X e 
  Um topo at a coordenada Y.

Um localização endereço de memória é um endereço de memória para uma localização.

Etapas para que se square para cima algum tipo de seleção em um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Normalize a seleção deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua 1 ao anchor column# deste text.
  Se o caret column# deste text não for 1, adicione 1 para o número de linhas do cursor deste text; atribua 1 ao caret column# deste text.
  Se o número de linhas do cursor deste text for menor do que ou igual à contagem de linhas deste text, cancele.
  Atribua a contagem de linhas deste text ao número da linha deste caret deste text.
  Atribua a quantidade de caracteres desta string desta row ao column# deste caret deste text.

An stack entry é uma coisa com uma string.

O stack é uns stack entries.

Etapas para que se start anywhere em uma caixa:
  Escolha aleatoriamente a localização deste context na caixa.

Etapas para que se start anywhere sobre um horizontal line:
  Escolha aleatoriamente uma localização sobre o horizontal line.
  Atribua a localização à localização deste context.

Etapas para que se start at o base left corner of uma caixa facing east:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face east.

Etapas para que se start at o base left corner of uma caixa facing north:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face north.

Etapas para que se start at o base left corner of uma caixa facing south:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face south.

Etapas para que se start at o base left corner of uma caixa facing west:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face west.

Etapas para que se start at o base of um horizontal line:
  Atribua o end desta vertical line à localização deste context.

Etapas para que se start at o base right corner of uma caixa facing east:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face east.

Etapas para que se start at o base right corner of uma caixa facing north:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face north.

Etapas para que se start at o base right corner of uma caixa facing south:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face south.

Etapas para que se start at o base right corner of uma caixa facing west:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face west.

Etapas para que se start at o left of um horizontal line:
  Atribua o start desta horizontal line à localização deste context.

Etapas para que se start at o middle of o base of uma caixa;
Etapas para que se start no middle of o base of uma caixa;
Etapas para que se start at o center of o base of uma caixa;
Etapas para que se start no center of o base of uma caixa:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.

Etapas para que se start at o middle of o base of uma caixa facing east;
Etapas para que se start no middle of o base of uma caixa facing east;
Etapas para que se start at o center of o base of uma caixa facing east;
Etapas para que se start no center of o base of uma caixa facing east:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.
  Face east.

Etapas para que se start at o middle of o base of uma caixa facing north;
Etapas para que se start no middle of o base of uma caixa facing north;
Etapas para que se start at o center of o base of uma caixa facing north;
Etapas para que se start no center of o base of uma caixa facing north:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.
  Face north.

Etapas para que se start at o middle of o base of uma caixa facing south;
Etapas para que se start no middle of o base of uma caixa facing south;
Etapas para que se start at o center of o base of uma caixa facing south;
Etapas para que se start no center of o base of uma caixa facing south:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.
  Face south.

Etapas para que se start at o middle of o base of uma caixa facing west;
Etapas para que se start no middle of o base of uma caixa facing west;
Etapas para que se start at o center of o base of uma caixa facing west;
Etapas para que se start no center of o base of uma caixa facing west:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa à coordenada y desta localização deste context.
  Face west.

Etapas para que se start at o middle of o left of uma caixa facing east;
Etapas para que se start no middle of o left of uma caixa facing east;
Etapas para que se start at o center of o left of uma caixa facing east;
Etapas para que se start no center of o left of uma caixa facing east:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face east.

Etapas para que se start at o middle of o left of uma caixa facing north;
Etapas para que se start no middle of o left of uma caixa facing north;
Etapas para que se start at o center of o left of uma caixa facing north;
Etapas para que se start no center of o left of uma caixa facing north:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face north.

Etapas para que se start at o middle of o left of uma caixa facing south;
Etapas para que se start no middle of o left of uma caixa facing south;
Etapas para que se start at o center of o left of uma caixa facing south;
Etapas para que se start no center of o left of uma caixa facing south:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face south.

Etapas para que se start at o middle of o left of uma caixa facing west;
Etapas para que se start no middle of o left of uma caixa facing west;
Etapas para que se start at o center of o left of uma caixa facing west;
Etapas para que se start no center of o left of uma caixa facing west:
  Atribua a coordenada esquerda desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face west.

Etapas para que se start at o middle of o right of uma caixa facing east;
Etapas para que se start no middle of o right of uma caixa facing east;
Etapas para que se start at o center of o right of uma caixa facing east;
Etapas para que se start no center of o right of uma caixa facing east:
  Atribua a coordenada direita desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face east.

Etapas para que se start at o middle of o right of uma caixa facing north;
Etapas para que se start no middle of o right of uma caixa facing north;
Etapas para que se start at o center of o right of uma caixa facing north;
Etapas para que se start no center of o right of uma caixa facing north:
  Atribua a coordenada direita desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face north.

Etapas para que se start at o middle of o right of uma caixa facing south;
Etapas para que se start no middle of o right of uma caixa facing south;
Etapas para que se start at o center of o right of uma caixa facing south;
Etapas para que se start no center of o right of uma caixa facing south:
  Atribua a coordenada direita desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face south.

Etapas para que se start at o middle of o right of uma caixa facing west;
Etapas para que se start no middle of o right of uma caixa facing west;
Etapas para que se start at o center of o right of uma caixa facing west;
Etapas para que se start no center of o right of uma caixa facing west:
  Atribua a coordenada direita desta caixa à coordenada x desta localização deste context.
  Atribua o y deste center desta caixa à coordenada y desta localização deste context.
  Face west.

Etapas para que se start at o middle of o topo of uma caixa;
Etapas para que se start no middle of o topo of uma caixa;
Etapas para que se start at o center of o topo of uma caixa;
Etapas para que se start no center of o topo of uma caixa:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.

Etapas para que se start at o middle of o topo of uma caixa facing east;
Etapas para que se start no middle of o topo of uma caixa facing east;
Etapas para que se start at o center of o topo of uma caixa facing east;
Etapas para que se start no center of o topo of uma caixa facing east:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.
  Face east.

Etapas para que se start at o middle of o topo of uma caixa facing north;
Etapas para que se start no middle of o topo of uma caixa facing north;
Etapas para que se start at o center of o topo of uma caixa facing north;
Etapas para que se start no center of o topo of uma caixa facing north:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.
  Face north.

Etapas para que se start at o middle of o topo of uma caixa facing south;
Etapas para que se start no middle of o topo of uma caixa facing south;
Etapas para que se start at o center of o topo of uma caixa facing south;
Etapas para que se start no center of o topo of uma caixa facing south:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.
  Face south.

Etapas para que se start at o middle of o topo of uma caixa facing west;
Etapas para que se start no middle of o topo of uma caixa facing west;
Etapas para que se start at o center of o topo of uma caixa facing west;
Etapas para que se start no center of o topo of uma caixa facing west:
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada superior desta caixa à coordenada y desta localização deste context.
  Face west.

Etapas para que se start at o right of um horizontal line:
  Atribua o end desta horizontal line à localização deste context.

Etapas para que se start at uma localização:
  Atribua a localização à localização deste context.

Etapas para que se start at uma localização facing east:
  Atribua a localização à localização deste context.
  Face east.

Etapas para que se start at uma localização facing north:
  Atribua a localização à localização deste context.
  Face north.

Etapas para que se start at uma localização facing south:
  Atribua a localização à localização deste context.
  Face south.

Etapas para que se start at uma localização facing west:
  Atribua a localização à localização deste context.
  Face west.

Etapas para que se start at o topo left corner of uma caixa facing east:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face east.

Etapas para que se start at o topo left corner of uma caixa facing north:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face north.

Etapas para que se start at o topo left corner of uma caixa facing south:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face south.

Etapas para que se start at o topo left corner of uma caixa facing west:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face west.

Etapas para que se start at o topo of um vertical line:
  Atribua o start desta vertical line à localização deste context.

Etapas para que se start at o topo right corner of uma caixa facing east:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face east.

Etapas para que se start at o topo right corner of uma caixa facing north:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face north.

Etapas para que se start at o topo right corner of uma caixa facing south:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face south.

Etapas para que se start at o topo right corner of uma caixa facing west:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face west.

Etapas para que se start no middle of uma caixa facing east;
Etapas para que se start at o middle of uma caixa facing east;
Etapas para que se mova para o middle of uma caixa facing east;
Etapas para que se mova para o middle of uma caixa e face east;
Etapas para que se start no center of uma caixa facing east;
Etapas para que se start at o center of uma caixa facing east;
Etapas para que se mova para o center of uma caixa facing east;
Etapas para que se mova para o center of uma caixa e face east:
  Atribua o center desta caixa à localização deste context.
  Face east.

Etapas para que se start no middle of uma caixa facing north;
Etapas para que se start at o middle of uma caixa facing north;
Etapas para que se mova para o middle of uma caixa facing north;
Etapas para que se mova para o middle of uma caixa e face north;
Etapas para que se start no center of uma caixa facing north;
Etapas para que se start at o center of uma caixa facing north;
Etapas para que se mova para o center of uma caixa facing north;
Etapas para que se mova para o center of uma caixa e face north:
  Atribua o center desta caixa à localização deste context.
  Face north.

Etapas para que se start no middle of uma caixa facing north menos uns points;
Etapas para que se start no center of uma caixa facing north menos uns points:
  Atribua o center desta caixa à localização deste context.
  Face north.
  Vire left o points.

Etapas para que se start no middle of uma caixa facing south;
Etapas para que se start at o middle of uma caixa facing south;
Etapas para que se mova para o middle of uma caixa facing south;
Etapas para que se mova para o middle of uma caixa e face south;
Etapas para que se start no center of uma caixa facing south;
Etapas para que se start at o center of uma caixa facing south;
Etapas para que se mova para o center of uma caixa facing south;
Etapas para que se mova para o center of uma caixa e face south:
  Atribua o center desta caixa à localização deste context.
  Face south.

Etapas para que se start no middle of uma caixa facing west;
Etapas para que se start at o middle of uma caixa facing west;
Etapas para que se mova para o middle of uma caixa facing west;
Etapas para que se mova para o middle of uma caixa e face west;
Etapas para que se start no center of uma caixa facing west;
Etapas para que se start at o center of uma caixa facing west;
Etapas para que se mova para o center of uma caixa facing west;
Etapas para que se mova para o center of uma caixa e face west:
  Atribua o center desta caixa à localização deste context.
  Face west.

Etapas para que se start um process usando um endereço completo:
  \ must ser chamado com um global variável
  Limpe o erro do fluxo de entrada/saída.
  Se o process não for 0, atribua "Erro. Este processo já está sendo executado." ao erro do fluxo de entrada/saída; exit.
  Atribua a magnitude dessa startupinfo ao cb desta startupinfo.
  Extraia um endereço da pasta desde o endereço completo.
  Modifique através do caractere NUL o endereço da pasta.
  Isole o endereço completo. modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateProcessA" com 
    O first deste endereço completo 
    e 0 
    e 0 
    e 0 
    e 0 
    e 67108904 [CREATE_DEFAULT_ERROR_MODE + NORMAL_PRIORITY_CLASS + DETACHED_PROCESS] 
    e 0 
    e O first deste endereço da pasta 
    e O endereçamento desta startupinfo 
    e O endereçamento dessa PROCESS_INFORMATION 
    devolvendo um número.
  Se o número for 0, atribua "Erro. Não foi possível executar o programa." ao erro do fluxo de entrada/saída; exit.
  Atribua o hprocess deste PROCESS_INFORMATION ao process.
  Call "kernel32.dll" "CloseHandle" com 
    O hthread deste PROCESS_INFORMATION.
  Point um endereço de memória para rotina aguarde por um process endereço de memória. \redirecione
  Call "kernel32.dll" "CreateThread" com 0 
    e 0 
    e O endereço de memória 
    e O endereçamento deste process 
    e 0 
    e O endereçamento desse segundo número
    devolvendo um número identificador.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador. \ does not end o thread, just dumps o handle

Etapas para que se start um temporizador:
  Reset o temporizador.
  Restart o temporizador.

Etapas para que se start uns twips above o middle of o base of uma caixa:
    \ incomplete abra of these
  Atribua a coordenada X deste center desta caixa à coordenada x desta localização deste context.
  Atribua a coordenada inferior desta caixa menos os twips à coordenada y desta localização deste context.

Etapas para que se start uns twips para baixo desde uma localização;
Etapas para que se start uns twips below uma localização:
  Atribua a coordenada X desta localização ao x deste context.
  Atribua a coordenada Y desta localização mais os twips ao y deste context.

Etapas para que se start uns twips desde o center of uma caixa:
  Atribua o center desta caixa à localização deste context.
  Mova os twips.

Etapas para que se start uns twips para o left e uns segunda twips para baixo desde uma localização;
Etapas para que se start uns twips left e uns segunda twips para baixo desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.
  Atribua a coordenada Y desta localização mais a segunda twips ao y deste context.

Etapas para que se start uns twips left e uns segunda twips para cima desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.
  Atribua a coordenada Y desta localização menos a segunda twips ao y deste context.

Etapas para que se start uns twips para o left e uns segunda twips para cima desde uma localização;
Etapas para que se start uns twips para o left of uma localização;
Etapas para que se start uns twips left of uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.

Etapas para que se start uns twips para o right e uns segunda twips para baixo desde uma localização;
Etapas para que se start uns twips right e uns segunda twips para baixo desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste context.
  Atribua a coordenada Y desta localização mais a segunda twips ao y deste context.

Etapas para que se start uns twips para o right e uns segunda twips para cima desde uma localização;
Etapas para que se start uns twips right e uns segunda twips para cima desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste context.
  Atribua a coordenada Y desta localização menos a segunda twips ao y deste context.

Etapas para que se start uns twips para cima desde uma coordenada:
  Atribua a coordenada menos os twips ao y deste context.

Etapas para que se start uns twips para cima desde uma localização;
Etapas para que se start uns twips above uma localização:
  Atribua a coordenada Y desta localização ao y deste context.
  Subtraia os twips desde a coordenada Y deste context.

Etapas para que se carregue as bibliotecas padrão do sistema;
Etapas para que se start para cima:
  inicialize o Component Object Model.
  Inicialize winsock.
  Inicialize gdi+.
  Inicialize o talker.
  Inicialize o module.
  Inicialize as cors.
  Inicialize o tela.
  Inicialize a window.
  Inicialize as fonts.
  Inicialize os cursors.
  Inicialize o mouse.
  Inicialize os canvases.
  Inicialize o context.
  Initalize o terminal.
  Crie o console.

Etapas para que se start para cima o cgi:
  Inicialize winsock.
  Inicialize o module.
  Inicialize o cgi.

Etapas para que se start com uma cor:
  Atribua a cor à cor deste context.

Etapas para que se start com nada em um endereço de memória:
  Esvazie o endereço de memória.

O número identificador do fluxo de entrada padrão é um número identificador.

O número identificador do fluxo de saída padrão é um número identificador.

Etapas para que se suspenda um process:
  Se o process for 0, cancele.
  Call "kernel32.dll" "TerminateProcess" com 
    O process 
    e 0.
  Atribua 0 ao process.

Etapas para que se suspenda um temporizador:
  Se a contagem deste temporizador for 0, cancele.
  Subtraia 1 desde a contagem deste temporizador.
  Se a contagem deste temporizador não for 0, cancele.
  Atribua a contagem de ticks do sistema a uns ticks.
  Subtraia os start ticks deste temporizador desde o ticks.
  Adicione o ticks para os total ticks deste temporizador.

Uma string é um conjunto com 
  Um first endereço de memória do pedaço e 
  Um last endereço de memória do pedaço.

An string# é um número.

Etapas para que se pinte uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face north.
  Pinte a altura desta caixa.
  Vire right.
  Pinte a largura desta caixa.
  Vire right.
  Pinte a altura desta caixa.
  Vire right.
  Pinte a largura desta caixa.

Um subject é uma string.

Etapas para que se take off all o masking tape:
  Mostre tudo.

Etapas para que se take off algum tipo de masking tape:
  Mostre tudo.

Um talker é um endereço de memória para um talker object.

O talker é um talker.

Um talker object é um conjunto com um talker vtable denominado vtable.

Um talker vtable é um endereço de memória para um talker vtable conjunto.

O temp endereço completo é um endereço completo.

O terminal é um terminal.

Um terminal é uma coisa com 
  Uma caixa, 
  Uns quoras, 
  Uma output cor, 
  Uma input cor, e 
  Uma reply string.

O text cutoff é um número igual a 500.

An text é uma coisa com 
  Uma caixa,
  Uma origin,
  Um pincel cor,
  Uma font,
  Um alinhamento,
  Some  rows,
  Uma margin,
  Uma scale fração,
  Um wrap detector,
  Um horizontal scroll detector,
  Um vertical scroll detector,
  Uma seleção,
  Um detector de alteração,
  Uma última operação,
  Some texts denominado undos,
  Some texts denominado redos.

An tick é um número.

Um temporizador é um conjunto com 
  Uma contagem, 
  Uns start ticks e 
  Uns total ticks.

Some times é um número. \ this é um fluke, I think -- see "suavize um polígono uns times"

Um topo é uns twips.

Etapas para que se trim uma string:
  Remove algum tipo de leading noise desde a string.
  Remove algum tipo de trailing noise desde a string.

Etapas para que se dê meia volta:
Etapas para que se vire around:
  Vire right 1/2.

Etapas para que se vire uma fração igual para um número over um segundo número:
  Atribua o número à coordenada superior desta fração.
  Atribua o segundo número à coordenada inferior desta fração.
  Vire a fração.

    \Etapas para que se vire uma fração do caminho;
Etapas para que se vire uma fração of o way;
Etapas para que se vire uma fração of o way around;
Etapas para que se vire uma fração:
  Se a fração for 1/1, cancele.
  Atribua 3840 times a fração mais a orientação deste context à orientação deste context.
  Normalize a orientação deste context.

Etapas para que se vire pra left;
Etapas para que se vire para a left;
    \Etapas para que se vire à left;
Etapas para que se vire left:
  Vire -1/4.

    \Etapas para que se vire à left uma fração igual para um número over um segundo número;
Etapas para que se vire pra left uma fração igual para um número over um segundo número;
Etapas para que se vire para a left uma fração igual para um número over um segundo número;
Etapas para que se vire left uma fração igual para um número over um segundo número:
  Atribua o número à coordenada superior desta fração.
  Atribua o segundo número à coordenada inferior desta fração.
  Vire left a fração.

    \Etapas para que se vire uma fração à left do caminho;
    \Etapas para que se vire uma fração pra left do caminho;
Etapas para que se vire uma fração para a left do caminho;
Etapas para que se vire left uma fração of o way;
Etapas para que se vire left uma fração of o way around;
Etapas para que se vire left um fração:
  Isole a fração.
  Negate a fração.
  Vire a fração.

    \Etapas para que se vire à left uns points;
Etapas para que se vire pra left uns points;
Etapas para que se vire para a left uns points;
Etapas para que se vire left uns points:
  Atribua o points e 3840 a um fração.
  Vire left a fração.

    \Etapas para que se vire à right;
Etapas para que se vire pra right;
Etapas para que se vire para a right;
Etapas para que se vire right:
  Vire 1/4.

    \Etapas para que se vire uns degrees à right;
    \Etapas para que se vire uns degrees pra right;
Etapas para que se vire uns degrees para a right;
Etapas para que se vire right uns degrees:
  Atribua o degrees times 10 e 3600 a um fração.
  Vire right a fração.

Etapas para que se vire uns degrees:
  Atribua o degrees times 10 e 3600 a um fração.
    \Se o degrees forem negative, vire left o fração; exit.
  Vire right a fração.

    \Etapas para que se vire à right uma fração igual para um número over um segundo número;
Etapas para que se vire pra right uma fração igual para um número over um segundo número;
Etapas para que se vire para a right uma fração igual para um número over um segundo número;
Etapas para que se vire right uma fração igual para um número over um segundo número:
  Atribua o número à coordenada superior desta fração.
  Atribua o segundo número à coordenada inferior desta fração.
  Vire right a fração.

    \Etapas para que se vire à right uma fração of o way;
Etapas para que se vire pra right uma fração of o way;
Etapas para que se vire para a right uma fração of o way;
Etapas para que se vire right uma fração of o way;
Etapas para que se vire right uma fração of o way around;
Etapas para que se vire right um fração:
  Vire a fração.

Etapas para que se vire right uma fração of o way uns percentual of o time;
Etapas para que se vire right uma fração about uns percentual of o time;
Etapas para que se vire right uma fração of o way about uns percentual of o time;
Etapas para que se vire right uma fração uns percentual of o time:
  Escolha aleatoriamente um número entre 1 e 100.
  Se o número for maior do que o percentual, cancele.
  Vire right a fração.

    \Etapas para que se vire uns points à right;
    \Etapas para que se vire uns points pra right;
Etapas para que se vire uns points para a right;
Etapas para que se vire right uns points:
  Atribua o points e 3840 a um fração.
  Vire right a fração.

Etapas para que se unlock um gpbitmap usando um bitmapdata:
  Call "gdiplus.dll" "GdipBitmapUnlockBits" com 
    O gpbitmap e 
  o endereçamento deste bitmapdata.

Etapas para que se mostre tudo:
  Call "gdi32.dll" "SelectClipRgn" com 
    O quadro atual 
    e 0.

Etapas para que se mostre dentro de uma caixa:
  Crie um hrgn usando a caixa.
  Mostre dentro de o hrgn.
  Destrua o hrgn.

Etapas para que se mostre dentro de um elipse:
  Crie um hrgn usando a elipse.
  Mostre dentro de o hrgn.
  Destrua o hrgn.

Etapas para que se mostre dentro de um hrgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual e 
  o hrgn e 2 [RGN_OR].

Etapas para que se mostre dentro de um polígono:
  Crie um hrgn usando o polígono.
  Mostre dentro de o hrgn.
  Destrua o hrgn.

Etapas para que se mostre dentro de uma caixa arredondada:
  Crie um hrgn usando a caixa arredondada.
  Mostre dentro de o hrgn.
  Destrua o hrgn.

Etapas para que se mostre fora de uma caixa:
  Crie um hrgn usando a caixa.
  Mostre fora de o hrgn.
  Destrua o hrgn.

Etapas para que se mostre fora de um elipse:
  Crie um hrgn usando a elipse.
  Mostre fora de o hrgn.
  Destrua o hrgn.

Etapas para que se mostre fora de um hrgn:
  Crie um old hrgn usando o zero caixa.
  Call "gdi32.dll" "GetClipRgn" com 
    O quadro atual e 
  o old hrgn 
    devolvendo um número.
  Se o número não for 1, limpe o old hrgn.
  Call "gdi32.dll" "SelectClipRgn" com 
    O quadro atual 
    e 0.
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hrgn 
    e 4 [RGN_DIFF].
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O old hrgn 
    e 2 [RGN_OR].
  Destrua o old hrgn.

Etapas para que se mostre fora de um polígono:
  Crie um hrgn usando o polígono.
  Mostre fora de o hrgn.
  Destrua o hrgn.

Etapas para que se mostre fora de uma caixa arredondada:
  Crie um hrgn usando a caixa arredondada.
  Mostre fora de o hrgn.
  Destrua o hrgn.

Etapas para que se update o tela;
Etapas para que se mostre it;
Etapas para que se mostre it all;
Etapas para que se mostre reveal o canvas;
Etapas para que se atualize o tela:
  Atualize o tela usando a caixa desta tela.

An URL é uma string.

Um número de porta é um número.
Um nome de protocolo é uma string.
Um nome de host é uma string.
Um parâmetro de consulta é uma string.
Um endereço de recurso é uma string.

Um URL simplificada é um conjunto com
  Um nome do protocolo,\lpszScheme? dwFlags? -> exemplo: http / ftp / https / etc
  Um nome de host, \lpszHostName ?  -> exemplo: www.google.com ou mail.stackoverflow.com
  Um endereço de recurso, \lpszUrlPath? -> exemplo: index.html ou /css/style.css ou questions/SubmitQuestion.aspx
  Um parâmetro de consulta, \lpszExtraInfo? -> exemplo: ?useLiveData=1&internal=0
  Um número de porta. \ nPort? -. números de porta ocupam (geralmente) 16 bits

Um vértice array é um endereço de memória para um vértice array conjunto.

Um vértice array conjunto é um conjunto com 
  Uma contagem e 
  Uma localização endereço de memória.

Um vértice é uma coisa com 
  Uma coordenada X, 
  Uma coordenada Y, 
  Uma localização at a coordenada X.

Um w-param é um número.

Etapas para que se aguarde por um event;
Etapas para que se desenfileire um event:
  Yield para windows.
  Atribua o first desta fila de eventos ao event.
  Se o event for inexistente, repita.
  Remove o event desde a fila de eventos.
  Se a categoria deste event for "fechamento do programa", destrua o event; exit.
  Destrua o evento atual.
  Atribua o event ao evento atual.

Etapas para que se aguarde uns milliseconds;
Etapas para que se espere uns milliseconds;
Etapas para que se aguarde por uns milliseconds:
  Se o milliseconds forem menor do que ou igual para 0, cancele.
  Call "kernel32.dll" "Sleep" com os milliseconds. \ https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep

Etapas para que se aguarde until speaking é done:
  Se o talker for inexistente, cancele.
  Call o WaitUntilDone  desta vtable [SpVoice] deste talker com o talker e -1.

Etapas para que se aguarde until we hit um tecla;
Etapas para que se aguarde por uma tecla;
Etapas para que se aguarde uma tecla ser pressionada;
Etapas para que se aguarde uma tecla:
  Aguarde pela tecla para go para baixo.
  Aguarde pela tecla para come para cima.
  Desmanche all events.

Um wave file é um endereço completo.

Um wave é um texto hexadecimal.

Uma largura é uns twips.

Etapas para que se wrap um text:
  Se o text for inexistente, cancele.
  Se o wrap detector deste text não estiver ativo, cancele.
  Converta o anchor deste text para um posicionamento absoluto usando o text.
  Converta o caret deste text para uma segunda posicionamento absoluto usando o text.
  Atribua a scale deste text a um fração.
  Redimensione proporcionalmente o text para 1/1.
  Extraia uma string desde o text.
  Posponha o return pedaço para a string.
  Destrua as rows deste text.
  Lance um percorredor sobre a string.
  Crie o número da fonte of o memory canvas usando o font deste text.
  Percorra. [o código abaixo]
    Mova o percorredor usando a caixa deste text (word wrapping rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma row usando o segmento inicial deste percorredor.
    Posponha a row para as rows deste text.
  Repita. [o código acima]
  Destrua o número da fonte of o memory canvas.
  Renumber as rows deste text.
  Redimensione proporcionalmente o text para a fração.
  Converta o posicionamento absoluto para o anchor deste text usando o text.
  Converta a segunda posicionamento absoluto para o caret deste text usando o text.
  Limite o origin of o text.

Etapas para que se store um trecho em um file;
Etapas para que se escreva um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" com 
    O file 
    e 0 
    e 0 
    e 0 [FILE_BEGIN] 
    devolvendo um result número.
  Se o result número for -1, atribua "Ocorreu um erro durante o posicionamento do ponteiro do arquivo." ao erro do fluxo de entrada/saída; exit.
  Call "kernel32.dll" "WriteFile" com 
    O file e 
  o first endereço de memória do pedaço deste trecho 
    e A quantidade de caracteres deste trecho 
    e O endereçamento desse número 
    e 0 
    devolvendo o result número.
  Se o result número for 0, atribua "Ocorreu um erro durante a gravação do arquivo." ao erro do fluxo de entrada/saída; exit.

Etapas para que se store um trecho em um endereço completo;
Etapas para que se escreva um trecho para um endereço completo:
  Limpe o erro do fluxo de entrada/saída.
  Extraia um endereço da pasta desde o endereço completo.
  Se o endereço da pasta não estiver no sistema de arquivos, atribua "A pasta: " junto com o endereço da pasta seguido de " não existe." ao erro do fluxo de entrada/saída; exit.
  Defina o endereço completo para read-write mode.
  Isole o endereço completo.
  Modifique através do caractere NUL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com 
    O first deste endereço completo 
    e 1073741824 [GENERIC_WRITE] 
  And 0 e 0 e 2 [CREATE_ALWAYS] 
    e -2147483520 [FILE_FLAG_WRITE_THROUGH ou FILE_ATTRIBUTE_NORMAL] 
    e 0 
    devolvendo um número identificador.
  Se o número identificador for -1 [INVALID_HANDLE_VALUE], atribua "Ocorreu um erro ao tentar abrir o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; exit.
  Call "kernel32.dll" "WriteFile" com 
    O número identificador 
    e O first endereço de memória do pedaço deste trecho 
    e A quantidade de caracteres deste trecho 
    e O endereçamento desse número 
    e 0 
    devolvendo o número.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro ao tentar salvar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se escreva um pedaço:
  Atribua o pedaço a uma string.
  Escreva a string.

Etapas para que se escreva um pedaço para stdout:
  Call "kernel32.dll" "WriteFile" com 
    O stdout handle 
    e O endereçamento deste pedaço 
    e 1 
    e O endereçamento desse número 
    e nil.

Etapas para que se escreva um pedaço sem passar pra próxima linha:
  Atribua o pedaço a uma string.
  Escreva a string sem passar pra próxima linha.

     \ will translate para English because "Converta um detector" é used para externalize reams pelo caderno
Etapas para que se escreva um detector:
  Converta o detector para uma string.
  Escreva a string.

Etapas para que se escreva um detector sem passar pra próxima linha:
  Converta o detector para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um fração:
  Converta a fração para uma string.
  Escreva a string.

Etapas para que se escreva uma fração sem passar pra próxima linha:
  Converta a fração para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um número:
  Converta o número para uma string.
  Escreva a string.

Etapas para que se escreva um número sem passar pra próxima linha:
  Converta o número para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um número sobre um console:
  Converta o número para uma string.
  Escreva a string sobre o console.

Etapas para que se escreva uns quoras em uma caixa: \descomentar pra ver o que acontece
    \Pinte a caixa com a cor vermelha e a cor preta. \ temp ***
  Atribua a caixa a um quora caixa.
  Atribua a coordenada superior desta quora caixa mais 24 pixels à coordenada inferior desta quora caixa.
  Percorra. [o código abaixo]
    Obtenha um quora desde o quoras.
    Se o quora for inexistente, pare.
    \pinte really fast. ***
    \ Pinte o quora caixa com a cor amarela. \ temp ***
    Escreva a string deste quora no quora caixa com a cor deste quora.
    Mova o quora caixa para baixo 24 px.
  Repita. [o código acima]

Etapas para que se yield para windows:
  Se a fila de eventos não for vazio, cancele.
  Call "user32.dll" "GetMessageA" com 
    O endereçamento dessa msg 
    e 0 
    e 0 
    e 0 
    devolvendo um número.
  Se o número for 0, cancele.
  Call "user32.dll" "TranslateMessage" com 
    O endereçamento desta msg.
  Call "user32.dll" "DispatchMessageA" com 
    O endereçamento desta msg.

Etapas para que se zero uma caixa:
    \ was clear uma caixa, got confounded com "clear uma caixa " (which deveria pinte a caixa all black como does "clear o tela")
  Atribua 0 à coordenada esquerda desta caixa.
  Atribua 0 à coordenada superior desta caixa.
  Atribua 0 à coordenada direita desta caixa.
  Atribua 0 à coordenada inferior desta caixa.

O zero caixa é uma caixa.

Etapas para que se zero fill um número usando uma contagem e posponha it para uma string:
  Converta o número para uma segunda string.
  Zero fill a segunda string usando a contagem.
  Posponha a segunda string para a string.

O zero line é um line. \ tracer

O zero localização é uma localização.

O erro do fluxo de entrada/saída é uma string.

