\ O Cérebro - A Sociedade Osmosiana de Programadores de Linguagens Naturais - desde 2006.

\ Regras:
\ No geral, cada linha deve terminar com um ponto final.
\ As exceções são quando você está declarando uma variável do tipo conjunto, 
\ (cujas linhas podem terminar com uma vírgula, exceto no último item do conjunto)
\ Ou quando você estiver declarando um cabeçalho de rotina (que termina com sinal de dois pontos)
\ Quando um campo de texto é convertido para texto puro, 
\ o caractere especial LF é adicionado depois do caractere especial CR
\ Já quando um texto é transformado em um campo de texto, o caractere LF é removido.
\ Existe sempre uma linha, no mínimo.
\ Existe sempre um caractere CR no fim da ultima linha.
\Assim, row pode ser traduzido como linha.

\o verbo "criar" envolve alocação de memória
\o verbo fazer usa a memória já alocada

An URL é uma string.

Um intervalo é um número.
\Um intervalo inicial é um intervalo.
\Um intervalo total é um intervalo.

An text é uma coisa com 
  Uma caixa,
  Uma origem,
  Uma pincel cor,
  Uma font,
  Um alinhamento,
  Some rows,
  Uma margem,
  Uma scale fração,
  Um wrap detector,
  Um horizontal scroll detector,
  Um vertical scroll detector,
  Uma seleção,
  Um detector de alteração,
  Uma última operação,
  Some texts denominado undos,
  Some texts denominado redos.

Um campo de texto é uma coisa com
  Uma caixa,
  Uma origem,
  Uma pincel cor,
  Uma font,
  Um alinhamento,
  Some rows,
  Uma margem,
  Uma scale fração,
  Um wrap detector,
  Um horizontal scroll detector,
  Um vertical scroll detector,
  Uma seleção,
  Um detector de alteração,
  Uma última operação,
  Some texts denominado undos,
  Some texts denominado redos.

Os campos de textos são uns campos des textos. \preciso consertar esse plural bugado

An string# é um número.

An stack entry é uma coisa com uma string.

O stack é uns stack entries.

An row é uma coisa com 
  Um número da linha e 
  Uma string.

An refer é uma coisa com 
  Uma string e 
  Um endereço de memória (reference).

An grain é 10 milliseconds.

An GpImageAttributes é um endereço de memória.

An event é uma coisa com
Uma categoria [atualização de tela, mostrar seta, pressionamento de tecla, clique, clique duplo, clique direito, clique direito duplo, deactivate, activate, done], \ 
Um detector de tecla Shift, 
Um detector de tecla Ctrl, 
Um detector de tecla Alt, 
Uma localização, 
Uma tecla, 
Um pedaço.

An dyad é uma coisa com
  Um nome,
  Uma value string.

An context é uma coisa com 
  Uma localização, 
  Uma caixa, 
  Uma orientação, 
  Um tamanho da letra, 
  Uma cor, 
  Um número, 
  Uma grossura do pincel,\ pincel largura? ***
  e um letra size sob o tamanho da letra, 
  e um pincel sob a cor.
  \REMARK: A "grossura do pincel" não estava no context conjunto, but it deveria be.
  \I will be adding it para o next version of o CAL context, e now might be a good time for you para adicione it para o PAL context conjunto.

An byte# é um número.

An canvas é um hDC. \ hDC = handle device context

An bucket# é um número.

An bit é uma unidade.

Um percorredor é um conjunto com \ conserte "avance um percorredor" e "recue um percorredor" se você alterar isso aqui
  Um subtexto original,
  Um segmento final, 
  Um segmento inicial.

Um segmento inicial é um subtexto.
Um segmento final é um subtexto.

Uma string é um conjunto com 
  Um caractere inicial e 
  Um caractere final e 
  Um first endereço de memória do pedaço sob o caractere inicial e
  Um last endereço de memória do pedaço sob o caractere final.

Um caractere inicial é um endereço de memória para um pedaço.
Um caractere final é um endereço de memória para um pedaço.
Um endereço de memória do pedaço é um endereço de memória para um pedaço.

Etapas para que se avance um percorredor até encontrar o próximo espaço;
Etapas para que se avance um percorredor até o próximo espaço:
  Avance o percorredor.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o caractere de espaço, repita.
  \Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o caractere de espaço, repita.

Etapas para que se recue um percorredor até o próximo espaço;
Etapas para que se recue um percorredor até encontrar o próximo espaço:
  Recue o percorredor.
  Recue o percorredor.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o caractere de espaço, repita.
  \Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o caractere de espaço, repita.

Etapas para que se recue um percorredor por um número:
  Subtraia o número desde o caractere inicial deste segmento inicial deste percorredor.
  Subtraia o número desde o caractere final deste segmento final deste percorredor.

A contagem total é um número igual a 0.

O detector de ignição é um detector igual a 1.

O sinal de desligamento é um detector igual a 0.

Um posicionamento absoluto é um número.

Etapas para que se adicione uma fração para uma segunda fração:
  Isole a fração.
  Normalize a fração e a segunda fração.
  Adicione o numerador desta fração para o numerador desta segunda fração.
  Reduza a segunda fração.

Uns twips horizontais são uns twips.
Uns twips verticais são uns twips.
Uma localização atual é uma localização.

Etapas para que se adicione uns twips horizontais e uns twips verticais para a localização atual:
  Adicione os twips horizontais para a coordenada X desta localização deste context.
  Adicione os twips verticais para a coordenada Y desta localização deste context.

\ linha, traço, risco, traçado, listra
Etapas para que se adicione uma linha reta para uma figura:
  Se a figura for inexistente, crie a figura; posponha a figura para as figuras.
  Adicione a localização inicial desta linha reta para a figura.
  Adicione a localização final desta linha reta para a figura.

Etapas para que se adicione um nome para umas choices:
  Aloque memória para uma choice.
  Atribua o nome ao nome desta choice.
  Atribua a choice sob o end of as choices.

Etapas para que se adicione um número e um segundo número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o segundo número para o número Y deste par de números.

Etapas para que se adicione um número para um segundo número e um terceiro número para um quarto número:
  Adicione o número para o segundo número.
  Adicione o terceiro número para o quarto número.

Etapas para que se adicione um número para uma fração:
  Adicione o número / 1 para a fração. \ não seria o caso de apenas adicionar o número para a fração?
  \ Eu faria assim:
  \ Converta o número para uma nova fração.
  \ Adicione a nova fração à primeira fração.

Etapas para que se adicione um número para um par de números:
  Adicione o número para o número X deste par de números.
  Adicione o número para o número Y deste par de números.

Etapas para que se adicione um par de números para um segundo par de números:
  Adicione o número X deste par de números para o número X deste segundo par de números.
  Adicione o número Y deste par de números para o número Y deste segundo par de números.

Etapas para que se adicione um quora para um terminal:
  Crie o quora.
  Posponha o quora para o quora deste terminal.
  Se o terminal não estiver totalmente prenchido, cancele.
  Atribua o first destes quoras deste terminal a um doomed quora.
  Remove o doomed quora desde os quoras deste terminal.
  Destrua o doomed quora.

Etapas para que se adicione uma localização para um figura:
  Posponha a localização para a figura.

Etapas para que se adicione uma string para uns conjunto de textos:
  Crie um conjunto de texto usando a string.
  Posponha o conjunto de texto para o conjunto de textos. \plural bacana aqui

\O título ideal seria algo como: Etapas para que se ajuse o posicionamento de uma caixa a partir de 4 diferentes números:
Etapas para que se ajuste uma caixa usando um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para a coordenada X do canto superior esquerdo desta caixa.
  Adicione o segundo número para a coordenada Y do canto superior esquerdo desta caixa.
  Adicione o terceiro número para a coordenada X do canto inferior direito desta caixa.
  Adicione o quarto número para a coordenada Y do canto inferior direito desta caixa.

Etapas para que se ajuste um item:
  Atribua os dwFileAttributes deste WIN32FINDDATA deste item a um número.
  Conjuncione logicamente o número com 16 [FILE_ATTRIBUTE_DIRECTORY].
  Se o número for 0, atribua "arquivo" à categoria deste item. \
  Se o número não for 0, atribua "endereço de pasta" à categoria deste item.\
  Converta o ftCreationTime deste WIN32FINDDATA deste item para a grupo data/hora de criação deste item . \ adicionado para classificação de e-mails.
  Atribua o endereçamento deste cFileName deste WIN32FINDDATA deste item a um endereçamento de caractere.
  Converta o endereçamento de caractere para o designador deste item.
  Se a categoria deste item for "endereço de pasta", posponha "\" para o designador deste item.
  Atribua o endereço da pasta deste item junto com o designador deste item ao endereço completo deste item.
  Extraia a extensão deste item desde o designador deste item como um endereço completo.
  Atribua o nFileSizeLow deste WIN32FINDDATA deste item ao size deste item.
  Se o conteúdo deste caractere inicial deste designador deste item não for o ponto final, cancele.
  Obtenha o item (novamente).

Etapas para que se ajuste uma linha reta com um número e um segundo número e um terceiro número e um quarto número:
  Adicione o número para a coordenada X desta localização inicial desta linha reta.
  Adicione o segundo número para a coordenada Y desta localização inicial desta linha reta.
  Adicione o terceiro número para a coordenada X desta localização final desta linha reta.
  Adicione o quarto número para a coordenada Y desta localização final desta linha reta.

Etapas para que se ajuste uma imagem (extraindo as caixas do gpBitmap):
  Se a imagem for inexistente, cancele.
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa desta imagem.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa desta imagem.
  Atribua a largura deste gpBitmap desta imagem menos 1 times a quantidade de twips/pixel à coordenada X do canto inferior direito desta caixa desta imagem.
  Atribua a altura deste gpBitmap desta imagem menos 1 times a quantidade de twips/pixel à coordenada Y do canto inferior direito desta caixa desta imagem.
  Atribua a caixa desta imagem à caixa intacta desta imagem.

Etapas para que se ajuste espaçamento da fonte usando uma string:
  Se o quadro atual não for a área de impressão, cancele.
  Call "gdi32.dll" "SetTextCharacterExtra" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-settextcharacterextra
  \A função SetTextCharacterExtra define o espaçamento entre caracteres e adiciona espaço extra para cada célula de caractere na fonte selecionada, 
  \incluindo o caractere de quebra,  quando o sistema grava uma linha de texto.
    A área de impressão  [hDC]\ Um identificador para o contexto do dispositivo.
    e 0. [extra]   \ A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
    \quero traduzir esse comando como: Mande a área de impressão e o código 0 para a função "SetTextCharacterExtra" da biblioteca "gdi32.dll".
  Call "gdi32.dll" "GetCurrentObject" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcurrentobject
  \A função GetCurrentObject retorna um identificador que identifica a caneta, pincel, paleta, bitmap ou fonte atual e a função GetObject inicializa uma estrutura contendo os atributos desse objeto. 
  \Algumas impressoras fornecem canetas, pincéis e fontes residentes que podem ser usados para melhorar a velocidade de desenho em um aplicativo.
    A área de impressão [hDC] \ Um identificador para o contexto do dispositivo.
    e 6 [type OBJ_FONT]    \ O tipo de objeto a ser consultado. Este parâmetro pode ser vários valores.
    \ OBJ_FONT -> Retorna a fonte selecionada no momento.
    devolvendo um número identificador. [h] \ Se a função for bem-sucedida, o valor de retorno é um identificador para o objeto especificado. Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hDC] \ Um identificador para o contexto do dispositivo.
    e O número identificador. [h] \ Um identificador para o objeto a ser selecionado. Nesse caso é o número do comando anterior (a fonte selecionada no momento), retornado pelo GetCurrentObject acima
  Obtenha uma largura usando a string e o memory canvas.
  Call "gdi32.dll" "SelectObject" com 
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hDC] \ Um identificador para o contexto do dispositivo.
    e O null número da fonte.  [h] \ Um identificador para o objeto a ser selecionado. 
    \Nesse caso é também é um número identificador de fonte, mas  este valor é o da função GetStockObject 
    \O sistema oferece seis fontes de estoque. Uma fonte de estoque é uma fonte lógica que um aplicativo pode obter chamando a função GetStockObject e especificando a fonte solicitada. 
    \Esse valor corresponde à ANSI_FIXED_FONT que especifica uma fonte monoespaçada baseada no conjunto de caracteres ANSI do Windows. Uma fonte Courier é normalmente usada.
  Obtenha uma segunda largura usando a string e a área de impressão.
  Atribua a largura menos a segunda largura dividido pelo quantidade de caracteres desta string a um número.
  Call "gdi32.dll" "SetTextCharacterExtra" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-settextcharacterextra
    \A função SetTextCharacterExtra define o espaçamento entre caracteres. 
    \O espaçamento entre caracteres é adicionado a cada caractere, incluindo caracteres de quebra, quando o sistema grava uma linha de texto.
    A área de impressão [hDC] \Um identificador para o contexto do dispositivo.
    e O número. [extra] \A quantidade de espaço extra, em unidades lógicas, a ser adicionada a cada caractere. 
    \Se o modo de mapeamento atual não for MM_TEXT, o parâmetro nCharExtra é transformado e arredondado para o pixel mais próximo.

Etapas para que se alinhe um text usando um alinhamento:
  Atribua o alinhamento ao alinhamento deste text.

Um alinhamento é uma string [centro, esquerda ou direita].

Uma quantia é um número.

Uma anchor é um position.

Uma máscara de conjunção lógica é uma mask.

Um ângulo é uns precise degrees. [cujos valores variam ente 0 e 3599]

Etapas para que se posponha um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" com \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer
  \Esta função armazena o ponteiro do arquivo em dois valores LONG.
  \Quando um arquivo é aberto, o Windows associa um ponteiro de arquivo com o fluxo padrão. 
  \Esse ponteiro de arquivo é um valor de deslocamento que especifica o próximo byte a ser lido ou o local para receber o próximo byte escrito.
    O file [hFile]\ O número identificador do arquivo.
    e 0 [lDistanceToMove] \ Um valor positivo para lDistanceToMove move o ponteiro do arquivo para frente no arquivo 
    \e um valor negativo move o ponteiro para trás no arquivo .
    e 0 [lpDistanceToMoveHigh] \Serve apenas para operações com 64 bits. Quando não é utilizado, esse valor deve ser 0 (NULL).        
    e 2 [file_end] [dwMoveMethod] \ O ponto de partida para o movimento do ponteiro do arquivo.
    \ Este parâmetro pode ser um dos seguintes valores.
    \0 = FILE_BEGIN ->  O ponto de partida é zero ou o início do arquivo.
    \ 1 = FILE_CURRENT -> O ponto de partida é o valor atual do ponteiro do arquivo.
    \ 2 = FILE_END -> O ponto de partida é a posição atual de fim de arquivo.
    devolvendo um número resultante.
    \Se a função for bem-sucedida e lpDistanceToMoveHigh for NULL, o valor de retorno será o DWORD de ordem inferior do novo ponteiro de arquivo. 
    \Obs: Se a função retornar qualquer valor que não seja -1 (INVALID_SET_FILE_POINTER), isso significa que a chamada para SetFilePointer foi bem-sucedida.
  Se o número resultante for -1, atribua "Ocorreu um erro na hora de posicionar o ponteiro do arquivo." ao erro do fluxo de entrada/saída; volte.
    \ Se o ponteiro de arquivo for um valor negativo, a função falhará, o ponteiro de arquivo não será movido e o código retornado por GetLastError será ERROR_NEGATIVE_SEEK.
    \Observação: Como o valor -1 (INVALID_SET_FILE_POINTER) é um valor válido para o DWORD de ordem inferior do novo ponteiro de arquivo, 
   \O certo seria verificar o valor de retorno da função e o código de erro retornado por GetLastError para determinar se um erro ocorreu ou não. 
    \Se ocorreu um erro, o valor de retorno de SetFilePointer será -1 (INVALID_SET_FILE_POINTER) e a função GetLastError retornará um valor diferente de 0 (NO_ERROR ).  
  Call "kernel32.dll" "WriteFile" com \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile
  \ Essa função serve pra gravar dados no arquivo ou dispositivo de entrada / saída (E/S) especificado.
    O file [hFile]  \ Um identificador para o arquivo ou dispositivo de E/S 
    \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    e O caractere inicial deste trecho [lpBuffer]  \ Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    e A quantidade de caracteres deste trecho [nNumberOfBytesToWrite] \ O número de bytes a serem gravados no arquivo ou dispositivo.
    \ Um valor zero especifica uma operação de gravação nula. 
    \O comportamento de uma operação de gravação nula depende do sistema de arquivos subjacente ou da tecnologia de comunicação.
    [Creio que seja preciso corrigir o texto abaixo]
    e um [o] endereçamento desse número [lpNumberOfBytesWritten]  \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono. 
    \ WriteFile define esse valor como zero antes de fazer qualquer trabalho ou verificação de erro.
    \ Use NULL para este parâmetro se esta for uma operação assíncrona para evitar resultados potencialmente errôneos.
    \Este parâmetro pode ser NULL somente quando o próximo parâmetro [lpOverlapped] não for 0 (NULL).
    e 0 [lpOverlapped]  \ utilizado somente quando se deseja gravar em outro lugar do arquivo, como por exemplo, no final. 
    \ Se não for o caso, esse parâmetro pode ser 0 (NULL)
    devolvendo o número resultante. \ Se a função for bem-sucedida, o valor de retorno será diferente de 0 (VERDADEIRO).
    \ Se a função falhar ou estiver sendo concluída de forma assíncrona, o valor de retorno será 0 (FALSO). 
    \Para obter informações de erro estendidas, chame a função GetLastError.
    \ Nota: Se GetLastError fornecer um valor igual a 997 ou -2147023899 (ERROR_IO_PENDING), isso não indica uma falha na gravação do arquivo; 
    \indica apenas que a operação de gravação ainda está com conclusão pendente devido ser uma operação de gravação de forma assíncrona. 
    \ Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile#remarks
  Se o número resultante for 0, atribua "Ocorreu um erro na hora de salvar o arquivo." ao erro do fluxo de entrada/saída; volte.

Etapas para que se posponha um pedaço para uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o caractere inicial desta string usando a quantidade de caracteres desta string mais 1.
  Atribua o caractere inicial desta string mais a quantidade de caracteres armazenados ao caractere final desta string.
  Atribua o pedaço para o conteúdo deste caractere final desta string.

Etapas para que se posponha um pedaço para uma string usando uma contagem:
  Isole a contagem.
  Percorra. [o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha o pedaço para a string.
    Subtraia 1 desde a contagem.
  Repita. [o código acima]

Etapas para que se posponha um detector para uma string:
  Converta o detector para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha uma fração para uma string:
  Converta a fração para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um número para uma string:
  Converta o número para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um endereço de memória para uma string:
  Converta o endereço de memória para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha uma localização para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a localização.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha uma string para uma segunda string:
  Se a string estiver em branco, cancele.
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Atribua a quantidade de caracteres desta segunda string a uma quantidade de caracteres armazenados.
  Adicione a quantidade de caracteres armazenados para a quantidade de caracteres agrupados.
  Reassign o caractere inicial desta segunda string usando a quantidade de caracteres agrupados.
  Atribua o caractere inicial desta segunda string mais a quantidade de caracteres armazenados a um endereço de memória.
  Copie pedaços desde o caractere inicial desta string para o endereço de memória pelo quantidade de caracteres desta string.
  Atribua o caractere inicial desta segunda string mais a quantidade de caracteres agrupados menos 1 ao caractere final desta segunda string.

Etapas para que se posponha uma string para uma segunda string (handling email transparency):
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor (text file rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor começa com ".", posponha "." para a segunda string.
    Posponha o segmento inicial deste percorredor para a segunda string.
  Repita. [o código acima]

Etapas para que se posponha uma string para uma segunda string usando uma contagem:
  Isole a contagem.
  Percorra. [o código abaixo]
    Se a contagem for menor do que 1, cancele.
    Posponha a string para a segunda string.
    Subtraia 1 desde a contagem.
  Repita. [o código acima]

Etapas para que se posponha uns coisas para uns segunda coisas:
  Atribua o first destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Posponha a coisa para a segunda coisas.
  Repita. [o código acima]

Etapas para que se posponha um temporizador para uma string:
  Converta o temporizador para uma segunda string.
  Posponha a segunda string para a string.

Etapas para que se posponha um vértice para um polígono:
  Se o polígono for inexistente, cancele.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha uma coordenada X e uma coordenada Y para um polígono:
  Se o polígono for inexistente, cancele.
  Crie um vértice usando a coordenada X e a coordenada Y.
  Posponha o vértice para os vértices deste polígono.

Etapas para que se posponha zeros para uma string até que its quantidade de caracteres é um número:
  Se a quantidade de caracteres desta string for maior do que ou igual ao número, cancele.
  Posponha "0" para a string.
  Repita. [o código acima]

Etapas para que se assign um endereço de memória usando um quantidade de pedaços:  \Assinale? Institua? Instale? Instaure? Crie? Inaugure? Monte? Componha? Constitua? Designe? Declare?
  Se o quantidade de pedaços for 0, esvazie o endereço de memória; volte.
  Isole o quantidade de pedaços.
  Arredonde o quantidade de pedaços para cima para o nearest power of two.
  Call "kernel32.dll" "HeapAlloc" com \ https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc
  \Aloca um bloco de memória de um heap. A memória alocada não é móvel.
    O endereço heap [hHeap] \ Um identificador para o heap do qual a memória será alocada. Esse identificador é retornado pela função HeapCreate ou GetProcessHeap .
    e 8 [dwFlags ] \As opções de alocação de heap. A especificação de qualquer um desses valores substituirá o valor correspondente especificado quando o heap foi criado com HeapCreate . 
    [8 = HEAP_ZERO_MEMORY]  \A memória alocada será inicializada em zero. Caso contrário, a memória não é inicializada para zero.
    e A quantidade de pedaços [dwBytes] \O número de bytes a serem alocados.
    devolvendo o endereço de memória. [LPVOID ] \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o bloco de memória alocado.
  Se o endereço de memória não for inexistente, adicione 1 para a contagem do heap; volte.

Etapas para que se role automaticamente um text usando uma localização e um detector:
  Se o text for inexistente, desative o detector; volte.
  Atribua a altura desta font deste text a um número.
  Limpe um difference.
  Atribua a caixa deste text a uma caixa.
  Indent a caixa usando a quantidade de twips/pixel .
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua o número ao número Y desta difference.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua o número ao número Y desta difference; negate o número Y desta difference.
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua o número ao número X desta difference.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, atribua o número ao número X desta difference; negate o número X desta difference.
  Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número X desta difference.
  Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, desative o detector; volte.
  Ligue o detector.
  Role o text usando a difference.
  Aguarde por 50 milliseconds.

\Um baseline é um número. \ variável não utilizada


Etapas para que se faça bi-bi:
  Call "user32.dll" "MessageBeep" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messagebeep
  \Reproduz um som waveform. O som waveform para cada tipo de som é identificado por uma entrada no registro.
  0. [uType] \O som a ser reproduzido. Os sons são definidos pelo usuário por meio do aplicativo de painel de controle de Som e, a seguir, armazenados no registro.
  \O valor 0 é o som especificado como o som Beep padrão do Windows.
  Call "user32.dll" "MessageBeep" com 
  0.

Etapas para que se inicie uma folha modo paisagem:
  Faça a folha modo paisagem 1056 pixels por 816 pixels.
  Inicie uma folha com a folha modo paisagem.

Etapas para que se inicie uma folha modo retrato:
  Faça a folha modo retrato 816 pixels por 1056 pixels.
  \para referência, uma folha A4 possui 3508 x 2480 px, praticamente 10x maio
  Inicie uma folha com a folha modo retrato.

Etapas para que se inicie a impressão:
  Inicialize a área de impressão.
  Atribua a magnitude desse DOCINFO ao cbSize deste DOCINFO.
  Atribua o caractere inicial deste nome deste module ao lpszDocName deste DOCINFO.
  Call "gdi32.dll" "StartDocA" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-startdoca
  \A função StartDoc inicia um trabalho de impressão.
    A área de impressão [hDC] \Um identificador para o contexto do dispositivo para o trabalho de impressão.
    e O endereçamento deste DOCINFO. [*lpdi] \Um ponteiro para uma estrutura DOCINFO contendo o nome do arquivo de documento e o nome do arquivo de saída.

Etapas para que se inicie uma folha:
  Inicie a folha como uma folha modo retrato.

Um título de índice remissivo é uma string.

Etapas para que se inicie uma folha usando um título de índice remissivo:
  Inicie uma folha modo retrato usando o título de índice remissivo.

A Bíblia é uma coisa com uns versos.

Um verso é uma coisa com uma string.

Uma word big-endian unsigned é um conjunto com 2 pedaços.

Um código binário é uma string.

Uma caixa é um conjunto com
  Uma coordenada X do canto superior esquerdo , 
  Uma coordenada Y do canto superior esquerdo, 
  Uma coordenada X do canto inferior direito, 
  Uma coordenada Y do canto inferior direito,  \verificar a possibilidade de remover o conteúdo abaixo
  Um canto superior esquerdo localização sob a coordenada X do canto superior esquerdo , e 
  Um canto inferior direito localização sob a coordenada X do canto inferior direito, e
  Uma topo-left localização sob a coordenada X do canto superior esquerdo , e 
  Uma base-right localização sob a coordenada X do canto inferior direito. 

Um brilho é uma luminosidade.

Um contagem de buckets é uma contagem.
Um conjunto de buckets é um conjunto com uns refers.
Um bucket é um endereço de memória para um conjunto de buckets.

Um trecho é uma string.

\Etapas para que se avance um pedaço limitando-a para um segundo pedaço e um terceiro pedaço;
Etapas para que se avance um pedaço limitando-o para um segundo pedaço e um terceiro pedaço:
  Adicione 1 para o pedaço.
  Se o pedaço for maior do que o terceiro pedaço, atribua o segundo pedaço ao pedaço.

Etapas para que se avance um número:
  Adicione 1 para o número.

\Etapas para que se avance um número limitando-a para um segundo número e um terceiro número;
Etapas para que se avance um número limitando-o para um segundo número e um terceiro número:
  Adicione 1 para o número.
  Se o número for maior do que o terceiro número, atribua o segundo número ao número.

Etapas para que se avance um percorredor por um número:
  Adicione o número para o caractere final deste segmento inicial deste percorredor.
  Adicione o número para o caractere inicial deste segmento final deste percorredor.

Etapas para que se assobie:
  Call "kernel32.dll" "Beep" com \ https://docs.microsoft.com/en-us/windows/win32/api/utilapiset/nf-utilapiset-beep
    \Gera tons simples no alto-falante. A função é síncrona; ele executa uma espera alertável e não retorna o controle para seu chamador até que o som termine.
    220 [dwFreq] \A frequência do som, em hertz. Este parâmetro deve estar no intervalo de 37 a 32.767 (0x25 a 0x7FFF).
    e 200. [dwDuration] \A duração do som, em milissegundos

Uma quantidade de pedaços é uma contagem.



Etapas para que se capitalize algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Se a row estiver em branco, repita.
    Capitalize a string deste row.
  Repita. [o código acima]

Etapas para que se capitalize uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste caractere inicial deste subtexto não for irrelevante, pare.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]
  Uppercase o conteúdo deste caractere inicial deste subtexto.

Etapas para que se capitalize um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde os rows deste text.
    Se a row for inexistente, pare.
    Capitalize a string deste row.
  Repita. [o código acima]
  Wrap o text.

Um cursor de texto é um position.

Etapas para que se centralize uma caixa sob o base of uma segunda caixa:
  Centralize a caixa no segunda caixa (horizontalmente).
  Atribua a altura desta caixa a uma altura.
  Atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto inferior direito desta caixa menos a altura à coordenada Y do canto superior esquerdo desta caixa.

Etapas para que se centralize uma caixa em uma segunda caixa (horizontalmente):
  Atribua a coordenada X deste center desta segunda caixa menos a coordenada X deste center desta caixa a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa usando o número e 0.

Etapas para que se centralize uma caixa em uma segunda caixa (verticalmente):
  Atribua a coordenada Y deste center desta segunda caixa menos a coordenada Y deste center desta caixa a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a caixa usando 0 e o número.

Etapas para que se centralize um dot sobre a localização atual:
  Centralize o dot sobre a localização deste context.

Etapas para que se centralize uma elipse em uma caixa (horizontalmente):
  Centralize a caixa desta elipse na caixa (horizontalmente).

Etapas para que se centralize uma elipse em uma caixa (verticalmente):
  Centralize a caixa desta elipse na caixa (verticalmente).

Etapas para que se centralize uma linha reta em uma caixa (horizontalmente):
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta linha reta a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a linha reta usando o número e 0.

Etapas para que se centralize uma linha reta em uma caixa (verticalmente):
  Atribua a coordenada Y deste center desta caixa menos a coordenada Y deste center desta linha reta a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a linha reta usando 0 e o número.

Etapas para que se centralize uma imagem em uma caixa (horizontalmente):
  Se a imagem for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando o número e 0.

Etapas para que se centralize uma imagem em uma caixa (verticalmente):
  Se a imagem for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa menos a coordenada Y deste center desta caixa desta imagem a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando 0 e o número.

Etapas para que se centralize um polígono em uma caixa (horizontalmente):
  Se o polígono for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o polígono usando o número e 0.

Etapas para que se centralize um polígono em uma caixa (verticalmente):
  Se o polígono for inexistente, cancele.
  Atribua o y deste center desta caixa menos o y deste center desta caixa deste polígono a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o polígono usando 0 e o número.

Etapas para que se centralize uma localização em uma caixa (horizontalmente):
  Atribua a coordenada X deste center desta caixa menos a coordenada X desta localização a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a localização usando o número e 0.

Etapas para que se centralize uma localização em uma caixa (verticalmente):
  Atribua o y deste center desta caixa menos a coordenada Y desta localização a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a localização usando 0 e o número.

Etapas para que se centralize um text em uma caixa (horizontalmente):
  Se o text for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa menos a coordenada X deste center desta caixa deste text a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o text usando o número e 0.

Etapas para que se centralize um text em uma caixa (verticalmente):
  Se o text for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa menos a coordenada Y deste center desta caixa deste text a um número.
  Arredonde o número para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o text usando 0 e o número.

Etapas para que se modifique o current matiz por uns points;
Etapas para que se altere o current matiz por uns points;
Etapas para que se mude o current matiz por uns points:
  Mude a matiz deste context por os points.

Etapas para que se modifique um matiz por uns points;
Etapas para que se altere um matiz por uns points;
Etapas para que se mude um matiz por uns points:
  Adicione o points para o matiz.

Etapas para que se modifique uma caixa arredondada usando um raio;
Etapas para que se altere uma caixa arredondada usando um raio;
Etapas para que se mude uma caixa arredondada usando um raio:
  Atribua o raio ao raio desta caixa arredondada.

Etapas para que se modifique um text usando uma caixa;
Etapas para que se altere um text usando uma caixa;
Etapas para que se mude um text usando uma caixa:
  Se o text for inexistente, cancele.
  Atribua a caixa à caixa deste text.
  Wrap o text.

Etapas para que se modifique um text usando uma altura da fonte;
Etapas para que se altere um text usando uma altura da fonte;
Etapas para que se mude um text usando uma altura da fonte:
  Se o text for inexistente, cancele.
  Subtraia a margem deste text desde a coordenada X deste text.
  Atribua a origem deste text dividido pela malha deste text a um par de números.
  Atribua a altura da fonte à altura desta font deste text.
  Redimensione proporcionalmente a altura desta font deste text usando a scale deste text.
  Atribua o par de números times a malha deste text à origem deste text.
  Adicione a margem deste text para a coordenada X deste text.
  Limite a origem of o text.
  Wrap o text.

Etapas para que se modifique um text usando uma nome da fonte;
Etapas para que se altere um text usando uma nome da fonte;
Etapas para que se mude um text usando uma nome da fonte:
  Se o text for inexistente, cancele.
  Atribua o nome da fonte ao nome desta font deste text.
  Wrap o text.

Um character é um pedaço.

Uma choice é uma coisa com um nome e uma caixa.

As choices são umas choices.

Etapas para que se limpe uma caixa:
  Atribua 0 e 0 e 0 e 0 ao caixa. \ caderno depends disso

Etapas para que se limpe um pedaço:
  Atribua o caractere null ao pedaço.

Etapas para que se limpe uma cor:
  Atribua 0 e 0 e 0 à cor.

Etapas para que se limpe uma elipse:
  Limpe a caixa desta elipse.

Etapas para que se desative um detector;
Etapas para que se desligue um detector:
  Atribua 0 ao detector. \ era "Atribua no ao detector." O valor da keyword "no" estava no executável do CAL-1000, de acordo com o  Dahn.

Etapas para que se limpe uma font:
  Atribua "" e 0 à font.

Etapas para que se limpe um fração:
  Atribua 0 e 1 à fração.

Etapas para que se limpe um Endereço IP:
  Limpe o número deste Endereço IP.
  Limpe a string deste Endereço IP.

Etapas para que se limpe uma linha reta:
  Limpe a localização inicial desta linha reta.
  Limpe a localização final desta linha reta.

Etapas para que se limpe um número:
  Atribua 0 ao número.

Etapas para que se limpe um par de números:
  Atribua 0 e 0 ao par de números.

Etapas para que se limpe um percorredor:
  Limpe o subtexto original deste percorredor.
  Limpe o segmento final deste percorredor.
  Limpe o segmento inicial deste percorredor.

Etapas para que se erase a tela;
Etapas para que se escureça a tela;
Etapas para que se apague a tela;
Etapas para que se limpe a tela:
  Exponha tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se pinte a tela com uma cor; \ pinte a tela de uma só cor [ou] pinte a tela com uma só cor, etc
Etapas para que se limpe a tela usando uma cor:
  Exponha tudo.
  Pinte a caixa desta tela com a cor e a cor.
  Atualize a tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se branqueie a tela;
Etapas para que se pinte a tela de branco;
Etapas para que se limpe a tela usando a cor branca:
  \ \ needs special handling
  Exponha tudo.
  Pinte a caixa desta tela com a cor branca e a cor branca.
  Atualize o tela.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se limpe a tela sem atualizá-la:
  Exponha tudo.
  Pinte a caixa desta tela com a cor preta e a cor preta.
  Atribua a caixa desta tela à caixa deste context.

Etapas para que se limpe uma seleção:
  Limpe o anchor desta seleção.
  Limpe o cursor de texto desta seleção.

Etapas para que se limpe o stack:
  \ necessário aprimoramentos
  Destrua o stack.

Etapas para que se limpe uma string:
  Unassign o caractere inicial desta string.
  Esvazie o caractere final desta string.

Etapas para que se limpe um subtexto:
  Esvazie o caractere inicial deste subtexto.
  Esvazie o caractere final deste subtexto.

Etapas para que se limpe um terminal:
  Destrua os quoras deste terminal.

Etapas para que se limpe umas coisas:
  Esvazie o first destas coisas.
  Esvazie o last destas coisas.

Etapas para que se limpe uma word:
  Atribua 0 ao word.

Etapas para que se close um file:
  Call "kernel32.dll" "CloseHandle" com \ https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
  \Em geral, CloseHandle invalida o identificador do objeto especificado, diminui a contagem do identificador do objeto e executa verificações de retenção do objeto. 
  \Depois que o último identificador para um objeto é fechado, o objeto é removido do sistema. .
    O file. [hObject] \Um identificador válido para um objeto aberto.

Etapas para que se avise:
  Toque o som de aviso.

Um número de coluna é um número.

Etapas para que se compare uma string para uma segunda string usando uma quantidade de caracteres e uma segunda quantidade de caracteres devolvendo um número:
  Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos ascii devolvendo o número.
  \Compare a string para a segunda string usando a quantidade de caracteres e a segunda quantidade de caracteres e o tabela de caracteres minúsculos s/ acento ascii devolvendo o número.

Etapas para que se compativelmente handle algum tipo de message com um janela do programa um message número um wParam e um lParam:
  Se a message for 006 [WM_ACTIVATE], execute algum tipo de WM_ACTIVATE com o wParam; [especifica se a janela está sendo ativada ou desativada]
   Atribua 0 para EAX; volte.
  Se a message for 258 [WM_CHAR hex 102], execute algum tipo de WM_CHAR com o wParam [O código do caractere da tecla.] e o lParam;  
  [lParam é a contagem de repetição, código de varredura, sinalizador de chave estendida, código de contexto, sinalizador de estado da chave anterior ou sinalizador de estado de transição]
  \ Essa mensagem é enviada para a janela com o foco do teclado quando uma mensagem WM_KEYDOWN é traduzida pela função TranslateMessage. 
  \A mensagem WM_CHAR contém o código de caractere da tecla que foi pressionada.
  atribua 0 para EAX; volte.
  Se a message for 001 [WM_CREATE], execute algum tipo de WM_CREATE com a janela do programa; 
  \Enviado quando um aplicativo solicita que uma janela seja criada chamando a função CreateWindowEx ou CreateWindow.   
  \O procedimento de janela da nova janela recebe essa mensagem depois que a janela é criada, mas antes que a janela se torne visível.
  \Uma janela recebe essa mensagem por meio de sua função WindowProc.
  atribua 0 para EAX; volte.
  Se a message for 002 [WM_DESTROY], execute algum tipo de WM_DESTROY; atribua 0 para EAX; volte.
  \ Enviado quando uma janela está sendo destruída. 
  \É enviado para o procedimento de janela da janela sendo destruída após a janela ser removida da tela. 
  \Essa mensagem é enviada primeiro para a janela que está sendo destruída e, em seguida, para as janelas filhas (se houver) à medida que são destruídas. 
  \Durante o processamento da mensagem, pode-se supor que todas as janelas filho ainda existam.
  Se a message for 256 [WM_KEYDOWN Hex 100], execute algum tipo de WM_KEYDOWN 
  \Essa mensagem é enviada para a janela com o foco do teclado quando uma tecla não pertencente ao sistema é pressionada. 
  \Uma tecla que não é do sistema é aquela que é pressionada quando a tecla ALT não está pressionada.
  com O wParam [O código de tecla virtual da tecla não pertencente ao sistema. Consulte Códigos de teclas virtuals ]\-> https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
    e O lParam; [Pode ser a contagem de repetição, um código de varredura, sinalizador de chave estendida, código de contexto, sinalizador de estado-chave anterior e sinalizador de estado de transição,]
  \ veja detalhes aqui: https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown
   atribua 0 para EAX; volte.
  Se a message for 513 [WM_LBUTTONDOWN Hex 201], execute algum tipo de WM_LBUTTONDOWN
  \Postado quando o usuário pressiona o botão esquerdo do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. 
  \Caso contrário, a mensagem é postada na janela que capturou o mouse.
  \Uma janela recebe essa mensagem por meio de sua função WindowProc.
  \ o wParam Indica se as teclas virtuais estão pressionadas ou não, podendo ser mais de uma
   com o lParam;  \ especifica a coordenada do cursor. A coordenada é relativa ao canto superior esquerdo da área do cliente.
   atribua 0 para EAX; volte.
  Se a message for 515 [WM_LBUTTONDBLCLK Hex 203], execute algum tipo de WM_LBUTTONDBLCLK com o lParam; atribua 0 para EAX; volte.
  \Postado quando o usuário clica duas vezes com o botão esquerdo do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 015 [WM_PAINT Hex 0000000F], execute algum tipo de WM_PAINT com o janela do programa; atribua 0 para EAX; volte.
  \A mensagem WM_PAINT é enviada quando o sistema ou outro aplicativo faz uma solicitação para pintar uma parte da janela de um aplicativo. 
  \A mensagem é enviada quando a função UpdateWindow ou RedrawWindow é chamada 
  \ou pela função DispatchMessage quando o aplicativo obtém uma mensagem WM_PAINT usando a função GetMessage ou PeekMessage .
  Se a message for 516 [WM_RBUTTONDOWN Hex 204], execute algum tipo de WM_RBUTTONDOWN com o lParam; atribua 0 para EAX; volte.
  \Postado quando o usuário pressiona o botão direito do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 518 [WM_RBUTTONDBLCLK Hex 206], execute algum tipo de WM_RBUTTONDBLCLK com o lParam; atribua 0 para EAX; volte.
  \Postado quando o usuário clica duas vezes com o botão direito do mouse enquanto o cursor está na área do cliente de uma janela. 
  \Se o mouse não for capturado, a mensagem será postada na janela abaixo do cursor. Caso contrário, a mensagem é postada na janela que capturou o mouse.
  Se a message for 032 [WM_SETCURSOR Hex 20], execute algum tipo de WM_SETCURSOR; atribua 1 para EAX; volte.
  \Enviado para uma janela se o mouse fizer com que o cursor se mova dentro de uma janela e a entrada do mouse não for capturada.
  Se a message for 260 [WM_SYSKEYDOWN Hex 104], execute algum tipo de WM_SYSKEYDOWN com o wParam e o lParam; atribua 0 para EAX; volte.
  \Postado na janela com o foco do teclado quando o usuário pressiona a tecla F10 (que ativa a barra de menus) ou mantém pressionada a tecla ALT e pressiona outra tecla. 
  \Também ocorre quando nenhuma janela tem o foco do teclado; neste caso, a mensagem WM_SYSKEYDOWN é enviada para a janela ativa. 
  \A janela que recebe a mensagem pode distinguir entre esses dois contextos, verificando o código de contexto no parâmetro lParam .
  Call "user32.dll" "DefWindowProcA" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-defwindowproca
  \Chama o procedimento de janela padrão para fornecer processamento padrão para todas as mensagens de janela que um aplicativo não processa. 
  \Esta função garante que todas as mensagens sejam processadas. DefWindowProc é chamado com os mesmos parâmetros recebidos pelo procedimento de janela.
    A janela do programa [hWnd] \Um identificador para o procedimento de janela que recebeu a mensagem.
    e A message [Msg] \A mensagem em si.
    e O wParam [wParam] \Informações adicionais da mensagem. O conteúdo deste parâmetro depende do valor do parâmetro Msg.
    e O lParam. [lParam] \Informações adicionais da mensagem. O conteúdo deste parâmetro depende do valor do parâmetro Msg.

Etapas para que se compativelmente aguarde por um process endereço de memória:
  Call "kernel32.dll" "WaitForSingleObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject
  \Espera até que o objeto especificado esteja no estado sinalizado ou o intervalo de tempo limite expire.
    O conteúdo deste process endereço de memória [hHandle]  \o número identificador do objeto
    e -1. [dwMilliseconds]  \intervalo de tempo limite, em milisegundos.  O valor -1 informa que a função retornará apenas quando o objeto for sinalizado.]
  Call "kernel32.dll" "CloseHandle" com  \ https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
    O conteúdo deste process endereço de memória. [hObject]  \Um identificador válido para um objeto aberto.
  Atribua 0 ao conteúdo deste process endereço de memória. \  
  Call "user32.dll" "GetForegroundWindow" \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getforegroundwindow
  \Recupera um identificador para a janela do primeiro plano (a janela com a qual o usuário está trabalhando atualmente). 
  \O sistema atribui uma prioridade um pouco mais alta ao encadeamento que cria a janela de primeiro plano do que aos outros encadeamentos.
    devolvendo uma janela do programa. \O valor de retorno é um identificador para a janela do primeiro plano. 
   \A janela de primeiro plano pode ser NULL em certas circunstâncias, como quando uma janela está perdendo a ativação.
  Se a janela do programa for a janela principal do programa, atribua 0 para EAX; volte.
  Call "user32.dll" "ShowWindow" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-showwindow
 \Define o estado de exibição da janela especificada.
    A janela principal do programa [hWnd] \Um número identificador para a janela.
    e 6 [nCmdShow SW_MINIMIZE]. \Controla como a janela deve ser exibida. 
    \SW_MINIMIZE Minimiza a janela especificada e ativa a próxima janela de nível superior na ordem Z.
  Call "user32.dll" "ShowWindow" com 
    A janela principal do programa [hWnd]  \Um número identificador para a janela.
    e 9 [nCmdShow SW_RESTORE]. \Ativa e exibe a janela. 
    \Se a janela for minimizada ou maximizada, o sistema a restaurará para seu tamanho e posição originais. 
    \Um aplicativo deve especificar este sinalizador ao restaurar uma janela minimizada.
  Atribua 0 para EAX. \ abra return value of thread

Um console é uma coisa com 
  Uma caixa, 
  Uma cor da borda,
  Uma cor de preenchimento, 
  Um text, 
  Uma malha, 
  Um reply string.

O context é um context.



O context stack é uns contexts.

Etapas para que se converta um posicionamento absoluto para uma position usando um text:
  Se o text for inexistente, limpe o position; volte.
  Isole o posicionamento absoluto.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, limpe o position; volte.
    Atribua o número da linha desta row ao número da linha desta position.
    Atribua o posicionamento absoluto ao número de coluna desta position.
    Subtraia a quantidade de caracteres desta string desta row desde o posicionamento absoluto.
    Se o posicionamento absoluto for menor do que 1, cancele.
  Repita. [o código acima]

Etapas para que se converta um código binário Para um número:
  Atribua 0 ao número.
  Atribua 1 a um value número.
  Percorra. [o código abaixo]
    Se o código binário estiver em branco, cancele.
    Obtenha um character desde o código binário (backwards). \ was backwards
    Se o character for "1", adicione o value para o número.
    Double o value.
  Repita. [o código acima]

Etapas para que se converta uma caixa para uma string:
  Limpe a string.
  Posponha a coordenada X do canto superior esquerdo desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada Y do canto superior esquerdo desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada X do canto inferior direito desta caixa para a string.
  Posponha " " para a string.
  Posponha a coordenada Y do canto inferior direito desta caixa para a string.

Etapas para que se converta um pedaço para uma cifra binária:
  Atribua o pedaço à cifra binária como um pedaço.
  Uppercase a cifra binária.
  Se a cifra binária for maior do que o número nove, subtraia 7 desde a cifra binária.
  Subtraia 48 desde a cifra binária.

Etapas para que se converta um pedaço para uma cifra hexadecimal:
  Separe o pedaço a uma cifra binária e uma segunda cifra binária.
  Converta a cifra binária para a cifra hexadecimal.
  Converta a segunda cifra binária para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para a cifra hexadecimal.

Etapas para que se converta um pedaço para um query pedaço:
  Se o pedaço estiver entre 48 e 57, atribua o pedaço ao query pedaço; volte. \ 0-9
  Se o pedaço estiver entre 65 e 90, atribua o pedaço ao query pedaço; volte. \ A-Z
  Se o pedaço estiver entre 97 e 122, atribua o pedaço ao query pedaço; volte. \ a-z
  Se o pedaço for 32, atribua "+" ao query pedaço; volte. \ space
  Converta o pedaço para uma cifra hexadecimal.
  Atribua "%" junto com a cifra hexadecimal ao query pedaço.

Etapas para que se converta uma cor para um código da cor:
  Se a cor estiver clear, atribua 16777215 [$00FFFFFF] ao código da cor; volte. \ a cor transparente fica branca 
  Isole a cor.
  Redimensione proporcionalmente a saturação desta cor usando 240/1000.
  Limite a saturação desta cor para 1 e 239.
  Redimensione proporcionalmente a luminosidade desta cor usando 240/1000.
  Limite a luminosidade desta cor para 1 e 239.
  Redimensione proporcionalmente a matiz desta cor usando 240/3600.
  Limite a matiz desta cor para 1 e 239.
  Call "shlwapi.dll" "ColorHLSToRGB" com \ https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-colorhlstorgb
  \ Converte cores de matiz-luminância-saturação (HLS) para o formato RGB.
    A matiz desta cor [wHue] \O valor de matiz HLS original.
    e A luminosidade desta cor  [wLuminance] \O valor de luminância HLS original.
    e A saturação desta cor [wSaturation] \O valor de saturação HLS original.
    devolvendo o código da cor. [COLORREF] \Retorna o valor RGB.

Etapas para que se converta uma cor para um espaço de cor RGB:
  Converta a cor para um código da cor.
  Converta o código da cor para o espaço de cor RGB.

Etapas para que se converta um código da cor para uma cor:
  Call "shlwapi.dll" "ColorRGBToHLS" com \ https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-colorrgbtohls
    O código da cor e [clrRGB] \ A cor RGB original.
    O endereçamento desse word [*pwHue] \ Um ponteiro para um valor que, quando esse método retorna com êxito, recebe o valor de matiz HLS.
    e O endereçamento dessa segunda word [*pwLuminance] \ Um ponteiro para um valor que, quando este método retorna com sucesso, recebe o valor de luminância HLS.
    e O endereçamento desse terceiro word.[*pwSaturation] \ Um ponteiro para um valor que, quando este método retorna com sucesso, recebe o valor de saturação HLS.
  Atribua a word à matiz desta cor.
  Atribua a segunda word à luminosidade desta cor.
  Atribua o terceiro word à saturação desta cor.
  Redimensione proporcionalmente a matiz desta cor usando 3600/240.
  Limite a matiz desta cor para 0 e 3600.
  Redimensione proporcionalmente a saturação desta cor usando 1000/240.
  Limite a saturação desta cor para 0 e 1000.
  Redimensione proporcionalmente a luminosidade desta cor usando 1000/240.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se converta um código da cor para um espaço de cor RGB:
  Isole o código da cor.
  Desloque o código da cor right 0 bits.
  Atribua o código da cor ao espectro vermelho deste espaço de cor RGB.
  Desloque o código da cor right 8 bits.
  Atribua o código da cor ao espectro verde deste espaço de cor RGB.
  Desloque o código da cor right 8 bits.
  Atribua o código da cor ao espectro azul deste espaço de cor RGB.

Etapas para que se converta um filetime para uma string:
  Limpe a string.
  Call "kernel32.dll" "FileTimeToSystemTime" com \ https://docs.microsoft.com/en-us/windows/win32/api/timezoneapi/nf-timezoneapi-filetimetosystemtime
  \ Converte a hora do arquivo em formato de hora do sistema. A hora do sistema é baseada na hora universal coordenada (UTC).
    O endereçamento deste filetime [*lpFileTime] \ Um ponteiro para uma estrutura FILETIME contendo a hora do arquivo a ser convertida para o formato de data e hora do sistema (UTC).
    e O endereçamento desse SYSTEMTIME [lpSystemTime] \ Um ponteiro para uma estrutura SYSTEMTIME para receber a hora do arquivo convertido.
    devolvendo um número. \ Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Se o número for 0, cancele. \Se a função falhar, o valor de retorno é zero.
  Atribua o wYear deste SYSTEMTIME ao year desse date/time.
  Atribua o wMonth deste SYSTEMTIME ao month deste date/time.
  Atribua o wDayOfWeek deste SYSTEMTIME ao week day deste date/time.
  Atribua o wDay deste SYSTEMTIME ao day deste date/time.
  Atribua o wHour deste SYSTEMTIME à hour deste date/time.
  Atribua o wMinute deste SYSTEMTIME ao minute deste date/time.
  Atribua o wSecond deste SYSTEMTIME ao second deste date/time.
  Atribua os wMilliseconds deste SYSTEMTIME ao millisecond deste date/time.
  Atribua a string deste date/time à string.

Etapas para que se converta um detector para um texto hexadecimal:
  Reassign o caractere inicial deste texto hexadecimal usando a magnitude deste detector.
  Copie pedaços desde o endereçamento deste detector para o caractere inicial deste texto hexadecimal pela magnitude deste detector.
  Atribua o caractere inicial deste texto hexadecimal mais a magnitude deste detector menos 1 ao caractere final deste texto hexadecimal.

Etapas para que se converta uma font para um número da fonte:
  Isole a font.
  Termine com o caractere NULL o nome desta font.
  Call "gdi32.dll" "CreateFontA" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createfonta
  \A função CreateFont cria uma fonte lógica com as características especificadas. A fonte lógica pode ser posteriormente selecionada como a fonte para qualquer dispositivo.
   - a altura desta font times 3 [e depois] dividido por 4 [cHeight] \A altura, em unidades lógicas, da célula ou caractere da fonte. 
   \O valor da altura do caractere (também conhecido como altura EM) é o valor da altura da célula do caractere menos o principal valor interno.
   \Para todas as comparações de altura, o mapeador de fonte procura a maior fonte que não exceda o tamanho solicitado.
    \Esse mapeamento ocorre quando a fonte é usada pela primeira vez.
    e 0 [cWidth] \A largura média, em unidades lógicas, de caracteres na fonte solicitada. 
   \Se este valor for zero, o mapeador de fonte escolhe um valor de correspondência mais próximo. 
   \O valor de correspondência mais próximo é determinado 
   \comparando os valores absolutos da diferença entre a proporção de aspecto do dispositivo atual e a proporção de aspecto digitalizado das fontes disponíveis.
    e 0 [cEscapement] \O ângulo, em décimos de graus, entre o vetor de escape e o eixo x do dispositivo. 
    \O vetor de escape é paralelo à linha de base de uma linha de texto.
    e 0 [cOrientation] \O ângulo, em décimos de graus, entre a linha de base de cada personagem e o eixo x do dispositivo.
    e 0 [cWeight] \A espessura da fonte no intervalo de 0 a 1000. Por exemplo, 400 é normal e 700 é negrito. Se este valor for zero, um peso padrão é usado.
    e 0 [bItalic] \Especifica uma fonte em itálico se definida como TRUE.
    e 0 [bUnderline] \Especifica uma fonte sublinhada se definida como TRUE.
    e 0 [bStrikeOut] \Especifica uma fonte riscada se definida como TRUE.
    e 1 [iCharSet = DEFAULT_CHARSET]  \O conjunto de caracteres. 
    \DEFAULT_CHARSET é definido com um valor baseado na localidade do sistema atual. 
    \Por exemplo, quando a localidade do sistema é inglês (Estados Unidos), ela é definida como ANSI_CHARSET.
    e 0 [iOutPrecision] \A precisão de saída. 
    \A precisão da saída define o quanto a saída deve corresponder à altura, largura, orientação do caractere, escape, densidade e tipo de fonte da fonte solicitada.
    e 0 [iClipPrecision] \A precisão do recorte. A precisão de recorte define como recortar caracteres que estão parcialmente fora da região de recorte.
    e 5 [iQuality = CLEARTYPE_QUALITY]  \A qualidade da saída. 
    \A qualidade de saída define com que cuidado o GDI deve tentar corresponder os atributos de fonte lógica aos de uma fonte física real.
    \Se CLEARTYPE_QUALITY for definido, o texto é renderizado (quando possível) usando o método de suavização ClearType.
    e 4 [iPitchAndFamily = TRUETYPE_FONTTYPE]  \O pitch e a família da fonte.
    e O caractere inicial deste nome desta font [pszFaceName] \Um ponteiro para uma string terminada em nulo que especifica o nome do tipo da fonte. 
    \O comprimento desta string não deve exceder 32 caracteres, incluindo o caractere nulo de terminação.
    devolvendo o número da fonte. \Se a função for bem-sucedida, o valor de retorno é um identificador para uma fonte lógica.
    \Se a função falhar, o valor de retorno será NULL.

Etapas para que se converta uma fração para um texto hexadecimal:
  Reassign o caractere inicial deste texto hexadecimal usando a magnitude desta fração.
  Copie pedaços desde o endereçamento desta fração para o caractere inicial deste texto hexadecimal pela magnitude desta fração.
  Atribua o caractere inicial deste texto hexadecimal mais a magnitude desta fração menos 1 ao caractere final deste texto hexadecimal.

Etapas para que se converta uma fração para um mixed:
  Se o denominador desta fração for 0, atribua 0 ao whole número deste mixed; atribua 0 ao ratio deste mixed; volte.
  Divida o numerador desta fração pelo denominador desta fração usando o whole número deste mixed e um resto.
  Atribua o resto e o denominador desta fração ao fração deste mixed.

Etapas para que se converta uma fração para uma string usando um número:
  \ converts para um decimal representation com "the número" of places
  Limpe a string.
  Se o número for menor do que 1, cancele.
  Atribua 10 a um value número.
  Raise o value para o número.
  Isole a fração.
  Se a fração for negativa, acione um detector; de-sign a fração.
  Multiplique o value pela fração.
  Zero preencha o value usando o número e posponha it para a string.
  Atribua a quantidade de caracteres desta string menos o número mais 1 a um byte#.
  Insira "." à string antes de o byte#.
  Se o conteúdo deste caractere inicial desta string for o ponto final, anteponha "0" para a string.
  Se o detector estiver ativo, anteponha "-" para a string.

Etapas para que se converta um texto hexadecimal para um fração:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude desta fração, atribua 0 e 1 ao ratio; volte.
  Copie pedaços desde o caractere inicial deste texto hexadecimal para o endereçamento desta fração pela magnitude desta fração.

Etapas para que se converta um texto hexadecimal para um número:
  Se a quantidade de caracteres deste texto hexadecimal não for a magnitude deste número, limpe o número; volte.
  Copie pedaços desde o caractere inicial deste texto hexadecimal para o endereçamento destte número pela magnitude deste número.

Etapas para que se converta um lParam para um tecla:
  \ assumes lParam desde wm_char message
  Atribua o lParam à tecla.
  Desloque a tecla right 16 bits.
  \ https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
  Conjuncione logicamente a tecla com 255. \11111111 ou FF
  Call "user32.dll" "MapVirtualKeyA" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-mapvirtualkeya
  \Traduz (mapeia) um código de tecla virtual em um código de varredura ou valor de caractere, ou traduz um código de varredura em um código de tecla virtual.
    A tecla [uCode] \O código de chave virtual ou código de leitura de uma chave. 
    \Como esse valor é interpretado depende do valor do parâmetro uMapType.
    \A partir do Windows Vista, o byte alto do valor uCode pode conter 0xe0 ou 0xe1 para especificar o código de verificação estendida.
    e 1 [uMapType MAPVK_VSC_TO_VK]  \A tradução a ser executada. O valor deste parâmetro depende do valor do parâmetro uCode.
    \ Usando MAPVK_VSC_TO_VK, O parâmetro uCode é um código de varredura e é traduzido em um código de tecla virtual que não distingue entre as teclas esquerda e direita. Se não houver tradução, a função retorna 0.
    devolvendo a tecla. \O valor de retorno é um código de varredura, um código de chave virtual ou um valor de caractere, dependendo do valor de uCode e uMapType. 
    \Se não houver tradução, o valor de retorno é zero.
  Se a tecla NumLock não estiver ativada, cancele.
  Se a tecla for a tecla Insert, atribua a tecla zero do teclado numérico à tecla; volte.
  Se a tecla for a tecla Delete, atribua a numpad-period tecla à tecla; volte.
  Se a tecla for a tecla Home, atribua a tecla sete do teclado numérico à tecla; volte.
  Se a tecla for a tecla End, atribua a tecla End do teclado numérico à tecla; volte.
  Se a tecla for a tecla PgUp, atribua a tecla nove do teclado numérico à tecla; volte.
  Se a tecla for a tecla PgDn, atribua a tecla três do teclado numérico à tecla; volte.
  Se a tecla for a left-arrow tecla, atribua a tecla quatro do teclado numérico à tecla; volte.
  Se a tecla for a seta pra cima, atribua a tecla oito do teclado numérico à tecla; volte.
  Se a tecla for a right-arrow tecla, atribua a tecla seis do teclado numérico à tecla; volte.
  Se a tecla for a seta pra baixo, atribua a tecla dois do teclado numérico à tecla; volte.
  Se a tecla for a tecla Clear, atribua a tecla cinco do teclado numérico à tecla; volte.

Etapas para que se converta um lParam para uma localização:
  Separe o lParam a um word e uma segunda word.
  Atribua a word à coordenada Y desta localização.
  Atribua a segunda word à coordenada X desta localização.
  Multiplique a localização pelo quantidade de twips/pixel .

Etapas para que se converta um mixed para um fração:
  Atribua o fração deste mixed à fração.
  Adicione o whole número deste mixed times o denominador desta fração para o numerador desta fração.

Etapas para que se converta uma cifra binária para uma cifra hexadecimal:
  Isole a cifra binária.
  Se a cifra binária for maior do que 9, adicione 7 para a cifra binária.
  Adicione 48 para a cifra binária.
  Atribua a cifra binária ao cifra hexadecimal.

Etapas para que se converta uma cifra hexadecimal para um texto hexadecimal:
  Isole a cifra hexadecimal.
  Limpe o texto hexadecimal.
  Se a quantidade de caracteres deste cifra hexadecimal for ímpar, anteponha o número zero para a cifra hexadecimal.
  Lance um subtexto sobre a cifra hexadecimal.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste caractere inicial deste subtexto para uma cifra binária.
    Desloque a cifra binária left 4 bits.
    Adicione 1 para o caractere inicial deste subtexto.
    Converta o conteúdo deste caractere inicial deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Posponha a cifra binária para o texto hexadecimal.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se converta um número para um pedaço:
  Atribua o número ao pedaço.

Etapas para que se converta um endereçamento de caractere para uma string:
  Limpe a string.
  Se o endereçamento de caractere for inexistente, cancele.
  Isole o endereçamento de caractere.
  Percorra. [o código abaixo]
    Se o conteúdo deste endereçamento de caractere for o caractere null, cancele.
    Posponha o conteúdo deste endereçamento de caractere para a string.
    Adicione 1 para o endereçamento de caractere.
  Repita. [o código acima]

Etapas para que se converta um endereço de memória e uma quantidade de caracteres para uma string:
  Limpe a string.
  Se o endereço de memória for inexistente, cancele.
  Se a quantidade de caracteres for 0, cancele.
  Reassign o caractere inicial desta string usando a quantidade de caracteres.
  Copie pedaços desde o endereço de memória para o caractere inicial desta string pelo quantidade de caracteres.
  Atribua o caractere inicial desta string mais a quantidade de caracteres menos 1 ao caractere final desta string.

Etapas para que se converta um endereço de memória para um texto hexadecimal;
Etapas para que se converta um número para um texto hexadecimal:
  Reassign o caractere inicial deste texto hexadecimal usando a magnitude deste número.
  Copie pedaços desde o endereçamento deste número para o caractere inicial deste texto hexadecimal pela magnitude deste número.
  Atribua o caractere inicial deste texto hexadecimal mais a magnitude deste número menos 1 ao caractere final deste texto hexadecimal.

Etapas para que se converta um endereço de memória para uma cifra hexadecimal;
Etapas para que se converta um número para uma cifra hexadecimal:
  Separe o número a um word e uma segunda word.
  Converta a word para a cifra hexadecimal.
  Converta a segunda word para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para a cifra hexadecimal.

Etapas para que se converta um endereço de memória para uma string:
  Converta o endereço de memória para a string como uma cifra hexadecimal.

Etapas para que se converta uns points para uns precise degrees:
  Atribua o points times 3840 dividido por 3600 ao precise degrees.

Etapas para que se converta uma position para um posicionamento absoluto usando um text:
  Se o text for inexistente, limpe o posicionamento absoluto; volte.
  Atribua 0 ao posicionamento absoluto.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha desta position, adicione a quantidade de caracteres desta string desta row para o posicionamento absoluto; repita.
  Adicione o número de coluna desta position para o posicionamento absoluto.

Etapas para que se converta uns precise degrees para uns points:
  Atribua os precise degrees times 3600 dividido por 3840 ao points.

Etapas para que se converta um texto de consulta para uma string:
  Limpe a string.
  Se o texto de consulta estiver em branco, cancele.
  Lance um subtexto sobre o texto de consulta.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste caractere inicial deste subtexto for o sinal de adição, posponha " " para a string; adicione 1 para o caractere inicial deste subtexto; repita.
    Se o conteúdo deste caractere inicial deste subtexto não for o sinal de porcentagem, posponha o conteúdo deste caractere inicial deste subtexto para a string; adicione 1 para o caractere inicial deste subtexto; repita.
    Se a quantidade de caracteres deste subtexto for menor do que 3, cancele.
    Adicione 1 para o caractere inicial deste subtexto.
    Converta o conteúdo deste caractere inicial deste subtexto para uma cifra binária.
    Desloque a cifra binária left 4 bits.
    Adicione 1 para o caractere inicial deste subtexto.
    Converta o conteúdo deste caractere inicial deste subtexto para uma segunda cifra binária.
    Disjuncione logicamente a cifra binária com a segunda cifra binária.
    Adicione 1 para o caractere inicial deste subtexto.
    Posponha a cifra binária para a string.
  Repita. [o código acima]

Etapas para que se converta uns rows para uma string:
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Posponha a string deste row para a string.
    Se o conteúdo deste caractere final desta string é o retorno de carro, posponha a quebra de linha para a string; repita.
  Repita. [o código acima]

Etapas para que se converta uns rows para uma string (sem adicionar quebras de linha):
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Posponha a string deste row para a string.
  Repita. [o código acima]

Etapas para que se converta uma string para um detector:
  Se a string for "s", acione o detector; volte.
  Se a string for "sim", acione o detector; volte.
  Se a string for "y", acione o detector; volte.
  Se a string for "yes", acione o detector; volte.
  [Se o texto informado não for nenhuma dessas opções, então:] 
  Desative o detector.

Etapas para que se converta uma string para um fração:
  Limpe a fração.
  Se a string estiver em branco, cancele.
  Se a string for algum tipo de integer, converta a string para o numerador desta fração; volte.
  Lance um subtexto sobre a string.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Separe o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto estiver em branco, atribua o subtexto à fração subtexto.
  Separe a fração subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
  Converta o integer subtexto para um whole número.
  Converta o numerador subtexto para um numerador número.
  Converta o denominador subtexto para um denominador número.
  Se o whole número for negativo, cancele.
  Se o numerador número for negativo, cancele.
  Se o denominador número for negativo, cancele.
  Se o denominador número for 0, cancele.
  Se o whole número não for 0, adicione o denominador número times o whole número para o numerador número.
  Atribua o numerador número ao numerador desta fração.
  Atribua o denominador número ao denominador desta fração.
  Se o conteúdo deste caractere inicial desta string for o hífem, negate a fração.

Etapas para que se converta uma string para uma cifra hexadecimal:
  Limpe a cifra hexadecimal.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Converta o conteúdo deste caractere inicial deste subtexto para uma segunda cifra hexadecimal.
    Posponha a segunda cifra hexadecimal para a cifra hexadecimal.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para um número:
  Atribua 0 ao número.
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Multiplique o número por 10.
    Atribua o conteúdo deste caractere inicial deste subtexto a um segundo número.
    Subtraia 48 desde o segundo número.
    Adicione o segundo número para o número.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]
  Se o conteúdo deste caractere inicial desta string for o hífem, negate o número.

Etapas para que se converta uma string para um número entre um segundo número e um terceiro número:
  Converta a string para o número.
  Limite o número para o segundo número e o terceiro número.

Etapas para que se converta uma string para um endereço de memória:
  \ presume que o endereço de memória está em cifra binária format
  Converta a string como uma cifra hexadecimal para um texto hexadecimal.
  Esvazie o endereço de memória.
  Lance um subtexto sobre o texto hexadecimal.
  Atribua 24 a um contagem de deslocamentos.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se a contagem de deslocamentos for menor do que 0, cancele.
    Atribua o conteúdo deste caractere inicial deste subtexto a um número.
    Desloque o número left o contagem de deslocamentos.
    Disjuncione logicamente o endereço de memória como um número com o número.
    Adicione 1 para o caractere inicial deste subtexto.
    Subtraia 8 desde o contagem de deslocamentos.
  Repita. [o código acima]

Etapas para que se converta uma string para um texto de consulta:
  Limpe o texto de consulta.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
  Se o subtexto estiver em branco, pare.
    Converta o conteúdo deste caractere inicial deste subtexto para um query pedaço.
    Posponha o query pedaço para o texto de consulta.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para uns rows:
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor (text file rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma row usando o segmento inicial deste percorredor.
    Posponha a row para a rows.
    Se o conteúdo deste caractere final desta string desta row for a quebra de linha [LF], atribua o retorno de carro [CR] ao conteúdo deste caractere final desta string desta row. 
    \ *Rotina nova criada pelo Dahn para abranger linhas que terminam apenas com um LF
  Repita. [o código acima]
  Renumere a rows.

Etapas para que se converta uma string para um UUID:
  Converta a string para uma string composta de caracteres amplos e termine com o caractere NULL.
  Call "ole32.dll" "CLSIDFromString" com \ https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-clsidfromstring
  \Converte uma seqüência de caracteres gerada pela função StringFromCLSID de volta pro CLSID original.
    O caractere inicial desta string composta de caracteres amplos [lpsz] \A representação da seqüência de caracteres do CLSID.
    e O endereçamento deste UUID. [pclsid] \Um ponteiro para o CLSID.
    \Esta função pode retornar o valor de retorno padrão -2147024809 (E_INVALIDARG), bem como os seguintes valores.
    \0 (NOERROR) -> O CLSID foi obtido com sucesso.
    \-2147221005 (CO_E_CLASSSTRING) -> A string da classe foi formatada incorretamente.
    \-2147221164 (REGDB_E_CLASSNOTREG) -> O CLSID correspondente à seqüência de classe não foi encontrado no registro.
    \-2147221168 (REGDB_E_READREGDB) -> Não foi possível abrir o registro para leitura.
    
Etapas para que se converta uma string para uma string composta de caracteres amplos:
  Limpe a string composta de caracteres amplos.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Posponha o conteúdo deste caractere inicial deste subtexto para a string composta de caracteres amplos.
    Posponha o caractere null para a string composta de caracteres amplos.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se converta uma string para uma string composta de caracteres amplos e termine com o caractere NULL:
  Converta a string para a string composta de caracteres amplos.
  Termine com o caractere NULL a string composta de caracteres amplos.

Etapas para que se converta uma URL para uma URL simplificada:
  Isole a URL.
  Termine com o caractere NULL a URL.
  Atribua a magnitude desses URL_COMPONENTS ao dwStructSize destes URL_COMPONENTS.
  Atribua 1 ao dwSchemeLength destes URL_COMPONENTS.
  Atribua 1 ao dwHostNameLength destes URL_COMPONENTS.
  Atribua 1 ao dwUrlPathLength destes URL_COMPONENTS.
  Atribua 1 ao dwExtraInfoLength destes URL_COMPONENTS.
  Call "wininet.dll" "InternetCrackUrlA" com \ https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetcrackurla
  \"Racha" uma URL em suas partes componentes.
    O caractere inicial desta URL [lpszUrl] \ Ponteiro para uma string que contém a URL canônica a ser quebrada.
    e 0 [dwUrlLength] \ Tamanho da string lpszUrl, em TCHARs, ou zero se lpszUrl for uma string ASCIIZ.
    e 0 [dwFlags] \ Controla a operação.
    e O endereçamento destes URL_COMPONENTS [lpUrlComponents] \Pointer to a URL_COMPONENTS structure that receives the URL components.
    devolvendo um número. \Retorna TRUE se a função for bem-sucedida ou FALSE caso contrário.
  Converta o lpszScheme destes URL_COMPONENTS e o dwSchemeLength destes URL_COMPONENTS para o nome do protocolo desta URL simplificada.
  Converta o lpszHostName destes URL_COMPONENTS e o dwHostNameLength destes URL_COMPONENTS para o nome de host desta URL simplificada.
  Converta o lpszUrlPath destes URL_COMPONENTS e o dwUrlPathLength destes URL_COMPONENTS para o endereço de recurso desta URL simplificada.
  Converta o lpszExtraInfo destes URL_COMPONENTS e o dwExtraInfoLength destes URL_COMPONENTS para a parâmetro de consulta desta URL simplificada.
  Atribua o nPort destes URL_COMPONENTS ao número de porta desta URL simplificada.

Etapas para que se converta um word para uma cifra hexadecimal:
  Separe a word a um pedaço e um segundo pedaço.
  Converta o pedaço para a cifra hexadecimal.
  Converta o segundo pedaço para uma segunda cifra hexadecimal.
  Posponha a segunda cifra hexadecimal para a cifra hexadecimal.

Uma coordenada é uns twips.

Etapas para que se copie um event para um segundo event: \ mudar o "segunda" aqui
  Se o event for inexistente, esvazie o segundo event; volte.
  Crie o segundo event.
  Atribua a categoria deste event à categoria deste segundo event.
  Atribua o detector de tecla Shift deste event ao detector de tecla Shift deste segundo event.
  Atribua o detector de tecla Ctrl deste event ao detector de tecla Ctrl deste segundo event.
  Atribua o detector de tecla Alt deste event ao detector de tecla Alt deste segundo event.
  Atribua a localização deste event à localização deste segundo event.
  Atribua a tecla deste event à tecla deste segundo event.
  Atribua o pedaço deste event ao pedaço deste segundo event.

Etapas para que se copie um gpBitmap Para um segundo gpBitmap: \verificar
  Se o gpBitmap for inexistente, esvazie o segundo gpBitmap; volte.
  Call "gdiplus.dll" "GdipCloneBitmapAreaI" com 
    0 [x] \Valor longo que especifica a coordenada x do canto superior esquerdo do retângulo que especifica a parte deste bitmap a ser copiada.
    e 0 [y] \Valor longo que especifica a coordenada y do canto superior esquerdo do retângulo que especifica a parte deste bitmap a ser copiada.
    e A largura deste gpBitmap [width] \Valor longo que especifica a largura do retângulo que especifica a parte deste bitmap a ser copiada.
    e A altura deste gpBitmap [height] \Valor longo que especifica a altura do retângulo que especifica a parte da imagem a ser copiada.
    e 0 [format = PixelFormatDontCare]  \Valor inteiro longo que especifica o formato de pixel do novo bitmap.
    \O valor 0 não especifica o formato do pixel.
    e O gpBitmap [*srcBitmap] \Ponteiro para o objeto Bitmap de origem.
    e O endereçamento deste segundo gpBitmap. [**dstBitmap] \Ponteiro para uma variável DWORD que recebeu um ponteiro para o objeto Bitmap clonado.

Etapas para que se copie as propriedades of um text Para um segundo text:
  Se o text for inexistente, cancele.
  Se o segundo text for inexistente, cancele.
  Atribua a caixa deste text à caixa deste segundo text.
  Atribua a origem deste text à origem deste segundo text.
  Atribua o pincel deste text ao pincel deste segundo text.
  Atribua a font deste text à font deste segundo text.
  Atribua o alinhamento deste text ao alinhamento deste segundo text.
  Copie as rows deste text para as rows deste segundo text.
  Atribua a margem deste text à margem deste segundo text.
  Atribua a scale deste text à scale deste segundo text.
  Atribua o wrap detector deste text ao wrap detector deste segundo text.
  Atribua o horizontal scroll detector deste text ao horizontal scroll detector deste segundo text.
  Atribua o vertical scroll detector deste text ao vertical scroll detector deste segundo text.
  Atribua a seleção deste text à seleção deste segundo text.
  Atribua o detector de alteração deste text ao detector de alteração deste segundo text.
  Atribua o última operação deste text ao última operação deste segundo text.
  \ dont copie undos e redos

O número de cópias é um número.

Etapas para que se copie uma imagem Para uma segunda imagem:
  Se a imagem for inexistente, esvazie a segunda imagem; volte.
  Aloque memória para a segunda imagem.
  Atribua a caixa desta imagem à caixa desta segunda imagem.
  Atribua a caixa intacta desta imagem à caixa intacta desta segunda imagem.
  Atribua o grayscale detector desta imagem ao grayscale detector desta segunda imagem.
  Atribua o mirror detector desta imagem ao mirror detector desta segunda imagem.
  Atribua o ângulo de rotação desta imagem ao ângulo de rotação desta segunda imagem.
  Atribua os data desta imagem aos data desta segunda imagem.
  Copie o gpBitmap desta imagem ao gpBitmap desta segunda imagem.

Etapas para que se copie um polígono Para um segundo polígono:
  Se o polígono for inexistente, esvazie o segundo polígono; volte.
  Aloque memória para o segundo polígono.
  Copie os vértices deste polígono aos vértices deste segundo polígono.

Etapas para que se copie uma row Para uma segunda row:
  Se a row for inexistente, esvazie a segunda row; volte.
  Aloque memória para o segunda row.
  Atribua a número da linha desta row ao número da linha desta segunda row.
  Atribua a string desta row à string desta segunda row.

Etapas para que se copie uns rows Para uns segunda rows:
  Destrua a segunda rows.
  Percorra. [o código abaixo]
    Obtenha uma row desde a rows.
    Se a row for inexistente, cancele.
    Copie a row a uma segunda row.
    Posponha a segunda row para a segunda rows.
  Repita. [o código acima]

Etapas para que se copie um text Para um segundo text:
  Se o text for inexistente, esvazie o segundo text; volte.
  Aloque memória para o segundo text.
  Copie as propriedades of o text para o segundo text.

Etapas para que se copie um vértice Para um segundo vértice:
  Se o vértice for inexistente, esvazie o segundo vértice; volte.
  Aloque memória para o segundo vértice.
  Atribua a coordenada X deste vértice à coordenada X deste segundo vértice.
  Atribua a coordenada Y deste vértice à coordenada Y deste segundo vértice.

Etapas para que se copie uns vértices Para uns segundo vértices:
  Destrua os segundo vértices.
  Percorra. [o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Copie o vértice a um segundo vértice.
    Posponha o segundo vértice para o segundo vértices.
  Repita. [o código acima]

Uma contagem é um número.

Um contador é um número.

Etapas para que se crie o connect handle of uma requisição WinHTTP using uma URL simplificada:
  Se a requisição WinHTTP for inexistente, cancele.
  Converta o nome de host desta URL simplificada a uma string composta de caracteres amplos denominado wide host nome e termine com o caractere NULL.
  Call "WinHTTP.dll" "WinHttpConnect" com \ https://docs.microsoft.com/en-us/windows/win32/api/WinHTTP/nf-WinHTTP-winhttpconnect
    \A função WinHttpConnect faz 2 coisas:
    \1. Especifica o servidor de destino inicial de uma solicitação HTTP e;
    \2. Retorna um identificador de conexão HINTERNET de uma sessão HTTP para esse destino inicial.
    O número identificador de sessão deste número identificador de requisição desta requisição WinHTTP [hSession] 
    \Um identificador de sessão WinHTTP HINTERNET válido retornado por uma chamada anterior para WinHttpOpen.
    e o caractere inicial deste wide host nome [pswzServerName] 
    \Ponteiro para uma string terminada em nulo que contém o nome do host de um servidor HTTP. 
    \Como alternativa, a string pode conter o endereço IP do site em ASCII, por exemplo, 10.0.1.45. 
    \Observe que WinHttp não aceita nomes de host internacionais sem convertê-los primeiro para Punycode.
    e o número de porta desta URL simplificada [nServerPort] \ 80 = http / 443 = https
    \Inteiro não assinado que especifica a porta TCP / IP no servidor ao qual a conexão é feita. Este parâmetro pode ser qualquer número de porta TCP / IP válido
    e 0 [dwReserved] \Este parâmetro é reservado e seu valor deve ser igual 0.
    devolvendo o número identificador de conexão desta requisição WinHTTP.
    \Retorna um identificador de conexão válido para a sessão HTTP se a conexão for bem-sucedida ou NULL caso contrário.
  Se o número identificador de conexão desta requisição WinHTTP for 0, atribua "Erro. Não foi possível estabelecer uma conexão." ao erro do fluxo de entrada/saída; volte.

Etapas para que se crie um console:
  Aloque memória para o console.
  Atribua a cor de borda de janela à cor da borda deste console.
  Atribua a cor preta à cor de preenchimento deste console.
  Atribua a caixa desta tela à caixa deste console.
  Atribua a caixa desta tela a uma caixa.
  Subtraia a altura desta fonte padrão desde a coordenada Y do canto inferior direito desta caixa.
  Atribua a altura desta caixa dividido pela altura desta fonte padrão times a altura desta fonte padrão a uma altura.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura à coordenada Y do canto inferior direito desta caixa.
  Centralize a caixa na caixa desta tela (verticalmente).
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada X do canto superior esquerdo desta caixa.
  Subtraia a coordenada Y do canto superior esquerdo desta caixa desde a coordenada X do canto inferior direito desta caixa.
  Crie o text deste console.
  Atribua a caixa à caixa deste text deste console.
  Ligue o wrap detector deste text deste console.
  Desative o horizontal scroll detector deste text deste console.
  Ligue o vertical scroll detector deste text deste console.
  Atribua a altura desta fonte padrão ao malha deste console.
  Multiplique o número X deste malha deste console por 2.

O nome do provedor criptográfico é uma string.
  
Etapas para que se crie um crypt session com uma passphrase string:
  \ define o erro do fluxo de entrada/saída em caso de falha
  Limpe o erro do fluxo de entrada/saída.
  Aloque memória para o crypt session.
  Atribua "Microsoft Enhanced Cryptographic Provider v1.0" ao nome do provedor criptográfico. [MS_ENHANCED_PROV] \ https://docs.microsoft.com/en-us/windows/win32/seccertenroll/cryptoapi-cryptographic-service-providers
  \ aquisição do contexto
  Call "advapi32.dll" "CryptAcquireContextA" com \ https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta
    \A função CryptAcquireContext é usada para adquirir um identificador para um contêiner de chave específico em um determinado provedor de serviços criptográficos (CSP). 
    \Este identificador retornado é usado em chamadas para funções CryptoAPI que usam o CSP selecionado.
    O endereçamento deste hCryptProv deste crypt session [*phProv] \Um ponteiro para um identificador de um provedor de serviços criptográficos (CSP). 
    e 0 [szContainer] \O nome do contêiner de chave. Esta é uma string terminada em nulo que identifica o contêiner de chave para o CSP.
    \Na maioria dos casos, quando dwFlags é definido como -268435456 (CRYPT_VERIFYCONTEXT), pszContainer deve ser definido como NULL.
    e o caractere inicial deste nome do provedor criptográfico [szProvider]  
    \Uma string terminada em nulo que contém o nome do CSP a ser usado.
    \Se este parâmetro for NULL, o provedor padrão do usuário será usado. 
    \Para obter mais informações, consulte Contextos do provedor de serviços criptográficos.
    \Para obter uma lista de provedores criptográficos disponíveis, consulte Nomes de provedores criptográficos.
    e 1 [dwProvType PROV_RSA_FULL]  \Especifica o tipo de provedor a ser adquirido. 
    \Os tipos de provedor definidos são discutidos em Tipos de provedor criptográfico.
    \O tipo de provedor PROV_RSA_FULL oferece suporte a assinaturas digitais e criptografia de dados. 
    \É considerado um CSP de propósito geral. O algoritmo de chave pública RSA é usado para todas as operações de chave pública.
    e -268435456 [dwFlags CRYPT_VERIFYCONTEXT]  \Valores de sinalização. 
    \Este parâmetro geralmente é definido como zero, mas existe uma gama de valores possíveis.
    \CRYPT_VERIFYCONTEXT
    \Esta opção se destina a aplicativos que usam chaves efêmeras ou aplicativos que não requerem acesso a chaves privadas persistentes, 
    \como aplicativos que executam apenas hash, criptografia e verificação de assinatura digital. 
    \Apenas os aplicativos que criam assinaturas ou decriptografam mensagens precisam de acesso a uma chave privada. 
   \Na maioria dos casos, é esse sinalizador deve ser escolhido.
    devolvendo um número resultante. \Se a função for bem-sucedida, ela retornará um valor diferente de zero (VERDADEIRO).
    \Se a função falhar, ele retorna zero (FALSO).
  Se o número resultante for 0, atribua "Erro. Não foi possível adquirir o identificador do contêiner de chave do provedor de serviços criptográficos ." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
  \ criação do hash
  Call "advapi32.dll" "CryptCreateHash" com \ https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptcreatehash
    \A função CryptCreateHash inicializa o hash de um fluxo de dados. 
    \Ele cria e retorna ao aplicativo de chamada um identificador para um objeto hash do provedor de serviços de criptografia (CSP).
    o hCryptProv deste crypt session [hProv] \Um identificador para um CSP criado por uma chamada feita para a função CryptAcquireContext acima.
    e 32771 [Algid CALG_MD5]  \Um valor ALG_ID que identifica o algoritmo de hash a ser usado. 
    \O tipo de dados ALG_ID especifica um identificador de algoritmo. Os parâmetros desse tipo de dados são passados para a maioria das funções na CryptoAPI.
    \Os valores válidos para este parâmetro variam, dependendo do CSP usado.
    \CALG_MD5 é um Algoritmo de hash MD5. Este algoritmo é suportado pelo Microsoft Base Cryptographic Provider.
    e 0 [hKey] \A chave para o hash é passada neste parâmetro. Para algoritmos não chaveados, este parâmetro deve ser definido como zero.
    e 0 [dwFlags] \O seguinte valor de sinalizador é definido:
    \Valor CRYPT_SECRETDIGEST (0x00000001)  Significado: Este sinalizador não é usado.
    e o endereçamento deste HCRYPTHASH deste crypt session [*phHash] \O endereço para o qual a função copia um identificador para o novo objeto hash.
    devolvendo o número resultante. \Se a função for bem-sucedida, ela retornará TRUE.
    \Se a função falhar, ele retornará FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível criar o hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
  \ hash passphrase
  Call "advapi32.dll" "CryptHashData" com \ https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-crypthashdata
    \A função CryptHashData adiciona dados a um objeto hash especificado. 
    \ Esta função e CryptHashSessionKey podem ser chamadas várias vezes para calcular o hash de fluxos de dados longos ou descontínuos.
    O HCRYPTHASH deste crypt session [hHash] \O número dentificador do objeto hash.
    e O caractere inicial desta passphrase [*pbData] \Um ponteiro para um buffer que contém os dados a serem adicionados ao objeto hash.
    e A quantidade de caracteres desta passphrase [dwDataLen] \Número de bytes de dados a serem adicionados. 
    \Deve ser zero se o sinalizador CRYPT_USERDATA estiver definido.
    e 0 [dwFlags] \Todos os provedores criptográficos da Microsoft ignoram esse parâmetro. 
    \Para qualquer CSP que não ignore este parâmetro, se este sinalizador for definido, o CSP solicita que o usuário insira os dados diretamente. 
   \Esses dados são adicionados ao hash. O aplicativo não tem permissão para acessar os dados. 
    \Este sinalizador pode ser usado para permitir que o usuário insira um PIN no sistema.
    devolvendo o número resultante. \Se a função for bem-sucedida, o valor de retorno será TRUE.
    \Se a função falhar, o valor de retorno será FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível adicionar dados ao hash da senha." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
 \ gera a chave da sessão criptográfica
  Call "advapi32.dll" "CryptDeriveKey" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey
  \A função CryptDeriveKey gera chaves de sessão criptográficas derivadas de um valor de dados base. 
  \Esta função garante que quando o mesmo provedor de serviços criptográficos (CSP) e algoritmos são usados, as chaves geradas a partir da mesma base de dados são idênticas. 
  \Os dados da base podem ser uma senha ou quaisquer outros dados do usuário.
    O hCryptProv deste crypt session [hProv] \Um identificador hCryptProv de um CSP criado por uma chamada para CryptAcquireContext.
    e 26625 [CALG_RC4  Stream Cipher Algid] \Uma estrutura ALG_ID que identifica o algoritmo de criptografia simétrica para o qual a chave deve ser gerada. 
    \Os algoritmos disponíveis provavelmente serão diferentes para cada CSP. 
    \Para obter mais informações sobre qual identificador de algoritmo é usado pelos diferentes provedores para as especificações de chave AT_KEYEXCHANGE e AT_SIGNATURE, consulte ALG_ID. 
    e O HCRYPTHASH deste crypt session [hBaseData] \Um identificador para um objeto hash que foi alimentado com os dados de base exatos.
    e 8388608 [dwFlags Key length: 128 bit]  \Especifica o tipo de chave gerada. Os tamanhos de uma chave de sessão podem ser definidos quando a chave é gerada. O tamanho da chave, representando o comprimento do módulo da chave em bits, é definido com os 16 bits superiores deste parâmetro. Assim, se uma chave de sessão RC4 de 128 bits deve ser gerada, o valor 0x00800000 é combinado com qualquer outro valor predefinido dwFlags com um operati bit a bit OR
    e O endereçamento deste hCryptKey desta crypt session  [phKey] \Um ponteiro para uma variável HCRYPTKEY para receber o endereço do identificador da chave recém-gerada.
    devolvendo o número resultante. \Se a função for bem-sucedida, o valor de retorno será TRUE.
    \Se a função falhar, o valor de retorno será FALSE.
  Se o número resultante for 0, atribua "Erro. Não foi possível derivar a chave da sessão." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.

Etapas para que se crie um dyad:
  Aloque memória para o dyad.

Etapas para que se crie um event:
  Aloque memória para o event.

Etapas para que se crie uma font info usando um font:
  Crie a font info usando a font (basic data).
  Crie as font larguras desta font info usando a font.

Etapas para que se crie uma font info usando uma font (basic data):
  Aloque memória para a font info.
  Atribua a font ao font desta font info.
  Obtenha um OutlineTextmetric usando a font.
  Atribua 32 aos flags deste font info. \ poderia ser atualizado com mais uma informação
  Atribua o tmInternalLeading destes otmTextMetrics deste OutlineTextmetric ao internal leading desta font info.
  Atribua o otmEMSquare deste OutlineTextmetric ao emsquare desta font info.
  Atribua o tmAscent deste otmTextMetrics deste OutlineTextmetric ao ascent desta font info.
  Atribua - o tmDescent deste otmTextMetrics deste OutlineTextmetric ao descent desta font info.
  Atribua o otmsCapEmHeight deste OutlineTextmetric ao capheight desta font info.
  Atribua o otmItalicAngle deste OutlineTextmetric ao italicangle desta font info.
  Atribua 0 ao StemV desta font info. \ dont know where para obtenha this desde
  Atribua o otmrcFontBox deste OutlineTextmetric ao font caixa desta font info.

Etapas para que se crie uma font info usando uma font e uma string:
  \ cria larguras baseadas nos caracteres da string
  Crie a font info usando a font (basic data).
  Crie as font larguras desta font info usando a font e a string.

Etapas para que se crie umas font larguras usando um font:
  Aloque memória para a font larguras.
  Atribua a font à font destas font larguras.
  Atribua 256 à contagem destas font larguras.
  Assign o data destes font larguras usando a contagem destas font larguras times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando a font.
  Assign um original ABC endereço de memória usando 256 times a magnitude desse ABC.
  Call "gdi32.dll" "GetCharABCWidthsA" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcharabcwidthsa
    \ A função GetCharABCWidths recupera as larguras, em unidades lógicas, de caracteres consecutivos em um intervalo especificado da fonte TrueType atual. 
    \ Esta função é só funciona com fontes TrueType.
    O memory canvas [hDC] \ Um identificador para o contexto do dispositivo.
    e 0 [wFirst] \ O primeiro caractere do grupo de caracteres consecutivos da fonte atual.
    e 255 [wLast] \O último caractere no grupo de caracteres consecutivos da fonte atual.
    e o original ABC endereço de memória. [lpABC] \ Um ponteiro para uma matriz de estruturas ABC que recebe as larguras dos caracteres, em unidades lógicas. 
    \Esta matriz deve conter, no mínimo, a mesma quantidade estruturas ABC que a quantidade de caracteres no intervalo especificado pelos parâmetros uFirstChar e uLastChar.
    \ Para obter mais informações, veja o site abaixo: 
    \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-ABC
  Destrua o número da fonte of o memory canvas.
  Atribua o original ABC endereço de memória a um ABC endereço de memória.
  Atribua o data destes font larguras a um endereço numérico.
  Percorra. [o código abaixo]
    Se um contador estiver past 256, pare.
    Atribua o abcA deste ABC endereço de memória ao conteúdo deste endereço numérico .
    Adicione o abcB deste ABC endereço de memória para o conteúdo deste endereço numérico .
    Adicione o abcC deste ABC endereço de memória para o conteúdo deste endereço numérico .
    Adicione a magnitude deste ABC para o ABC endereço de memória.
    Adicione a magnitude deste número para o endereço numérico.
  Repita. [o código acima]
  Unassign o original ABC endereço de memória.

Etapas para que se crie uns font larguras usando uma font e uma string:
  Aloque memória para a font larguras.
  Atribua a font à font destas font larguras.
  Atribua a quantidade de caracteres desta string à contagem destas font larguras.
  Se a string estiver em branco, cancele.
  Atribua a magnitude desse GcpResults ao lstructsize destes GcpResults.
  Atribua a quantidade de caracteres desta string ao nglyphs destes GcpResults.
  Assign o lpDX destes GcpResults usando a quantidade de caracteres desta string times a magnitude desse número.
  Crie o número da fonte of o memory canvas usando a font.
  Call "gdi32.dll" "GetCharacterPlacementA" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getcharacterplacementa
    \A função GetCharacterPlacement recupera informações sobre uma string de caracteres, tais como larguras de caracteres, posicionamento de circunflexo, ordenação dentro da string e renderização de glifo.
    \A função copia as informações para a estrutura GCP_RESULTS especificada ou para uma ou mais matrizes especificadas pela estrutura.
    \Embora essa função já tenha sido adequada para trabalhar com cadeias de caracteres, 
    \ a necessidade de trabalhar com um número crescente de linguagens e sistemas de escrita a tornou obsoleta. 
    \Ela foi substituído pela funcionalidade do módulo Uniscribe. Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/Intl/uniscribe
    O memory canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O caractere inicial desta string [lpString] \Um ponteiro para a sequência de caracteres a ser processada. 
    \A string acima não precisa ser terminada em zero, pois nCount especifica o comprimento da string.
    e A quantidade de caracteres desta string [nCount] \O comprimento da string apontada por lpString.
    e 0 [nMexExtent] \A extensão máxima (em unidades lógicas) na qual a string é processada. 
    \Os caracteres que, se processados, excederiam essa extensão são ignorados. 
     \Os cálculos para qualquer pedido obrigatório ou matrizes de glifos aplicam-se apenas aos caracteres incluídos. 
     \ Este parâmetro é usado apenas se o valor GCP_MAXEXTENT for especificado no parâmetro dwFlags.
     \ Conforme a função processa a string de entrada, cada caractere e sua extensão são adicionados à saída, à extensão e à outras matrizes
     \  apenas se a extensão total ainda não tiver excedido o máximo. Assim que o limite for atingido, o processamento será interrompido.
    e O endereçamento deste GcpResults [lpResults] \Um ponteiro para uma estrutura GCP_RESULTS que recebe os resultados da função.
    e 0. [dwFlags] \ serve para especificar como processar a string nas matrizes necessárias. nesse caso não foi especificado (valor nulo/ inválido)
  Destrua o número da fonte of o memory canvas.
  Atribua o lpDX destes GcpResults ao data destes font larguras.

Etapas para que se crie um gpBitmap usando um trecho:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "GlobalAlloc" com \ https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalalloc
    \Aloca o número especificado de bytes do heap.
  2 [uFlags GMEM_MOVEABLE] \Os atributos de alocação de memória. Se zero for especificado, o padrão é GMEM_FIXED.
  \GMEM_MOVEABLE = 0x0002
   \Aloca memória móvel. Os blocos de memória nunca são movidos na memória física, mas podem ser movidos dentro do heap padrão.
    \O valor de retorno é um identificador para o objeto de memória. Para converter o identificador em um ponteiro, use a função GlobalLock.
    \Este valor não pode ser combinado com GMEM_FIXED.
    e A quantidade de caracteres deste trecho [dwBytes] \O número de bytes a serem alocados. 
    \Se este parâmetro for zero e o parâmetro uFlags especificar GMEM_MOVEABLE, 
    \a função retornará um identificador para um objeto de memória que está marcado como descartado.
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno será um identificador para o objeto de memória recém-alocado.
    \Se a função falhar, o valor de retorno será NULL. 
\A função GlobalLock bloqueia um objeto de memória global e aumenta a contagem de bloqueios em um. 
\A função GlobalUnlock o desbloqueia e diminui a contagem de bloqueios em um. 
\Para obter a contagem de bloqueios de um objeto de memória global, use a função GlobalFlags.
  Call "kernel32.dll" "GlobalLock" com \ https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globallock
    \Bloqueia um objeto de memória global e retorna um ponteiro para o primeiro byte do bloco de memória do objeto.
    \Observação: As funções globais têm maior sobrecarga e fornecem menos recursos do que outras funções de gerenciamento de memória. 
    \Novos aplicativos devem usar as funções de heap, a menos que a documentação indique que uma função global deve ser usada.
    O número identificador [hMem] \Um identificador para o objeto de memória global. Nese caso o identificador é número identificador retornado pela função GlobalAlloc .
    devolvendo um endereço de memória. \Se a função for bem-sucedida, o valor de retorno é um ponteiro para o primeiro byte do bloco de memória.
    \Se a função falhar, o valor de retorno será NULL.
\Observações
\As estruturas de dados internas para cada objeto de memória incluem uma contagem de bloqueio que é inicialmente zero. 
\Para objetos de memória móvel, GlobalLock aumenta a contagem em um e a função GlobalUnlock diminui a contagem em um. 
\Cada chamada bem-sucedida que um processo faz ao GlobalLock para um objeto deve ser correspondida por uma chamada correspondente ao GlobalUnlock. 
\A memória bloqueada não será movida ou descartada, a menos que o objeto de memória seja realocado usando a função GlobalReAlloc. 
\O bloco de memória de um objeto de memória bloqueado permanece bloqueado até que sua contagem de bloqueios diminua para zero, momento em que pode ser movido ou descartado.
  Copie pedaços desde o caractere inicial deste trecho para o endereço de memória pelo quantidade de caracteres deste trecho.
  Call "kernel32.dll" "GlobalUnlock" com \ https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalunlock
    \Diminui a contagem de bloqueios associada a um objeto de memória que foi alocado com GMEM_MOVEABLE. Esta função não tem efeito em objetos de memória alocados com GMEM_FIXED.
    O número identificador. [hMem] \Um identificador para o objeto de memória global. Nese caso o identificador é número identificador retornado pela função GlobalAlloc .
    \Se o objeto de memória ainda estiver bloqueado após diminuir a contagem de bloqueios, o valor de retorno será um valor diferente de zero. 
    \Se o objeto de memória for desbloqueado após diminuir a contagem de bloqueios, a função retornará zero e GetLastError retornará 0 (NO_ERROR).
    \Um processo não deve depender do valor de retorno para determinar o número de vezes que ele deve subsequentemente chamar GlobalUnlock para um objeto de memória.
  Call "ole32.dll" "CreateStreamOnHGlobal" com \ https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-createstreamonhglobal
    \A função CreateStreamOnHGlobal cria um objeto de fluxo que usa um identificador de memória HGLOBAL para armazenar o conteúdo do fluxo. 
    \Este objeto é a implementação da interface IStream fornecida por OLE.
    \O objeto de fluxo retornado oferece suporte para leitura e gravação, não é transacionado e não oferece suporte para bloqueio de região. 
    \O objeto chama a função GlobalReAlloc para aumentar o bloco de memória conforme necessário.
    \Dica: Considere o uso da função SHCreateMemStream, que produz melhor desempenho,
    O número identificador [hGlobal] \Um identificador de memória alocado pela função GlobalAlloc ou, se NULL, um novo identificador deve ser alocado. 
    \O identificador deve ser alocado como móvel e não descartável.
    e 1 [fDeleteOnRelease = TRUE] \Um valor que indica se o identificador subjacente para este objeto de fluxo deve ser liberado automaticamente quando o objeto de fluxo é liberado. 
    \Se definido como FALSE, o chamador deve liberar o hGlobal após a versão final. 
    \Se definido como TRUE, a versão final irá liberar automaticamente o identificador subjacente.
    e O endereçamento desse istream. [*ppstm] \O endereço da variável de ponteiro IStream*  (LPSTREAM) que recebe o ponteiro de interface para o novo objeto de fluxo. Seu valor não pode ser NULL.
    \Observações
    \Se hGlobal for NULL, a função aloca um novo identificador de memória e o fluxo está inicialmente vazio.
    \Se hGlobal não for NULL, o conteúdo inicial do fluxo será o conteúdo atual do bloco de memória. 
    \Portanto, CreateStreamOnHGlobal pode ser usado para abrir um fluxo existente na memória. 
    \O identificador de memória e seu conteúdo não são perturbados pela criação do novo objeto de fluxo.
    \O tamanho inicial do fluxo é o tamanho de hGlobal conforme retornado pela função GlobalSize. 
    \Por causa do arredondamento, este não é necessariamente o mesmo tamanho que foi originalmente alocado para o identificador.
  Call "gdiplus.dll" "GdipCreateBitmapFromStream" com 
    O istream [stream] \Ponteiro para uma interface IStream COM.
    e O endereçamento deste gpBitmap [**bitmap] \Ponteiro para uma variável DWORD (endereçamento) que recebe um ponteiro para um objeto Bitmap (o gpBitmap).
    devolvendo um número.
  Se o número não for 0, atribua "Não sei como processar este tipo de imagem." ao erro do fluxo de entrada/saída; esvazie o gpBitmap.
  Call o release deste vtable deste istream com o istream. \verificar isso com calma

Etapas para que se crie um GpImageAttributes (escala de cinza):
  Call "gdiplus.dll" "GdipCreateImageAttributes" com 
    \Um objeto ImageAttributes contém informações sobre como as cores de bitmap e metarquivo são manipuladas durante a renderização.
    O endereçamento destes GpImageAttributes. [**imageattr] \Ponteiro para uma variável (GpImageAttributes).
    \Essa variável contém um ponteiro para o objeto ImageAttributes. 
    \( ou seja, o número identificador do objeto ImageAttributes)
  Call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" com 
    O GpImageAttributes [ imageattr] \Ponteiro para o objeto ImageAttributes.
   e 0 [type = ColorAdjustTypeDefault ] \Elemento da enumeração ColorAdjustType que especifica a categoria para a qual a matriz de ajuste de cor é definida. O valor padrão é ColorAdjustTypeDefault.
   e 1 [enableFlag] \Valor booleano que especifica se um ajuste de cor separado está habilitado para a categoria especificada pelo parâmetro type (ColorAdjustTypeDefault).
   e o caractere inicial desta matriz de tons de cinza [colorMatrix] \Ponteiro para uma matriz 5x5 de ajuste de cor .
   e 0 [grayMatrix] \Especifica uma matriz a ser usada para ajustar os tons de cinza quando o valor do parâmetro flags é igual ColorMatrixFlagsAltGray.
   e 0 [flags = ColorMatrixFlagsDefault]. \Elemento da enumeração ColorMatrixFlags que especifica o tipo de imagem e a cor que serão afetados pela matriz de ajuste de cor.

Etapas para que se crie o hBrush of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor for clear, atribua o null hBrush a um hBrush.
  Se a cor não for clear, Call "gdi32.dll" "CreateSolidBrush" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createsolidbrush
    \A função CreateSolidBrush cria um pincel lógico que possui a cor sólida especificada.
    O código da cor [color] \A cor do pincel. Para criar um valor de cor COLORREF, use a macro RGB.
    devolvendo o hBrush. \Se a função for bem-sucedida, o valor de retorno identifica um pincel lógico.
    \Se a função falhar, o valor de retorno será NULL.
    \Um pincel sólido é um bitmap que o sistema usa para pintar o interior de formas preenchidas.
     \Depois que um aplicativo cria um pincel chamando CreateSolidBrush, ele pode selecionar esse pincel em qualquer contexto de dispositivo chamando a função SelecionarObjeto
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O hBrush. [h] \Um identificador para o objeto a ser selecionado.

Etapas para que se crie o número da fonte of um canvas usando um font:
  Converta a font para um número da fonte.
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O número da fonte. [h] \Um número identificador para o objeto a ser selecionado.

Etapas para que se crie o hPen of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Se a cor estiver clear, atribua o null hPen a um hPen.
  Atribua a quantidade de twips/pixel times o grossura do pincel a um número.
  Se o canvas for a área de impressão, atribua 1 pixel times o grossura do pincel ao número.
  Se a cor não estiver clear, Call "gdi32.dll" "CreatePen" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpen
  \A função CreatePen cria uma caneta lógica que possui o estilo, largura e cor especificados. 
  \A caneta pode ser posteriormente selecionada em um contexto de dispositivo e usada para desenhar linhas e curvas.
    0 [iStyle = PS_SOLID]  \O estilo da caneta. PS_SOLID = A linha da caneta é "sólida" (sem traços ou pontilhados).
    e O número [cWidth] \A largura da caneta, em unidades lógicas. Se nWidth é zero, a caneta tem um único pixel de largura, independentemente da transformação atual.
    e O código da cor [color]  \Uma referência de cor para a cor da caneta. Para gerar uma estrutura COLORREF, use a macro RGB.
    devolvendo o hPen. \Se a função for bem-sucedida, o valor de retorno é um identificador que identifica uma caneta lógica.
    \Se a função falhar, o valor de retorno será NULL.
     \Depois que um aplicativo cria uma caneta lógica, ele pode selecionar essa caneta em um contexto de dispositivo chamando a função SelecionarObjeto. 
      \Depois que uma caneta é selecionada em um contexto de dispositivo, ela pode ser usada para desenhar linhas e curvas.
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O hPen. [h] \Um número identificador para o objeto a ser selecionado.

Etapas para que se crie um hRgn usando uma caixa: 
  \ hRgn = número identificador da região que será desenhada na tela
  Isole a caixa.
  Adicione a quantidade de twips/pixel para o canto inferior direito desta caixa.
  Call "gdi32.dll" "BeginPath" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-beginpath
    \A função BeginPath abre um suporte de caminho no contexto de dispositivo especificado.
    O quadro atual.[hDC] \Um identificador para o contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "Rectangle" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-rectangle
    \A função Retângulo desenha um retângulo. O retângulo é delineado com a caneta (pincel) atual e preenchido com o pincel (brush) atual.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e A coordenada X do canto superior esquerdo desta caixa [left] \A coordenada X, em coordenadas lógicas, do canto superior esquerdo do retângulo.
    e A coordenada Y do canto superior esquerdo desta caixa [top] \A coordenada Y, em coordenadas lógicas, do canto superior esquerdo do retângulo.
    e A coordenada X do canto inferior direito desta caixa [right] \A coordenada X, em coordenadas lógicas, do canto inferior direito do retângulo.
    e A coordenada Y do canto inferior direito desta caixa.[bottom] \A coordenada Y, em coordenadas lógicas, do canto inferior direito do retângulo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "EndPath" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-endpath
    \A função EndPath fecha um suporte de caminho e seleciona o caminho definido pelo suporte no contexto de dispositivo especificado.
    O quadro atual. [hDC] \Um identificador para o contexto de dispositivo no qual o novo caminho é selecionado.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "PathToRegion" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-pathtoregion
  \A função PathToRegion cria uma região do caminho que é selecionado no contexto de dispositivo especificado. A região resultante usa coordenadas do dispositivo.
    O quadro atual [hDC] \Identificador para um contexto de dispositivo que contém um caminho fechado.
   devolvendo o hRgn. \Se a função for bem-sucedida, o valor de retorno é um identificador válido para a região.
    \ Se a função falhar, o valor de retorno é zero.

Etapas para que se crie um hRgn usando uma elipse:
  \ hRgn = número identificador da região que será desenhada na tela
  Atribua a caixa desta elipse a uma caixa. \ No windows, toda elipse é desenhada dentro de uma caixa
  Call "gdi32.dll" "BeginPath" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-beginpath
    \A função BeginPath abre um suporte de caminho no contexto de dispositivo especificado.
    O quadro atual.[hDC] \Um identificador para o contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "Ellipse" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-ellipse
  \A função Ellipse desenha uma elipse. O centro da elipse é o centro do retângulo delimitador especificado. A elipse é delineada com a caneta atual e preenchida com o pincel atual.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e A coordenada X do canto superior esquerdo desta caixa [left] \A coordenada X, em coordenadas lógicas, do canto superior esquerdo do retângulo.
    e A coordenada Y do canto superior esquerdo desta caixa [top] \A coordenada Y, em coordenadas lógicas, do canto superior esquerdo do retângulo.
    e A coordenada X do canto inferior direito desta caixa [right] \A coordenada X, em coordenadas lógicas, do canto inferior direito do retângulo.
    e A coordenada Y do canto inferior direito desta caixa.[bottom] \A coordenada Y, em coordenadas lógicas, do canto inferior direito do retângulo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "EndPath" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-endpath
    \A função EndPath fecha um suporte de caminho e seleciona o caminho definido pelo suporte no contexto de dispositivo especificado.
    O quadro atual. [hDC] \Um identificador para o contexto de dispositivo no qual o novo caminho é selecionado.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "PathToRegion" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-pathtoregion
  \A função PathToRegion cria uma região do caminho que é selecionado no contexto de dispositivo especificado. A região resultante usa coordenadas do dispositivo.
    O quadro atual [hDC] \Identificador para um contexto de dispositivo que contém um caminho fechado.
   devolvendo o hRgn. \Se a função for bem-sucedida, o valor de retorno é um identificador válido para a região.
    \ Se a função falhar, o valor de retorno é zero.

Etapas para que se crie um hRgn usando um polígono:
  \ hRgn = número identificador da região que será desenhada na tela
  Se o polígono for inexistente, atribua 0 ao hRgn; volte.
  [caso o polígono exista, então:] Crie uma série de vértices usando os vértices deste polígono.
  Call "gdi32.dll" "LPtoDP" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-lptodp
  \A função LPtoDP converte coordenadas lógicas em coordenadas de dispositivo.
  \A conversão depende do modo de mapeamento do contexto do dispositivo, das configurações das origens e extensões da janela e da janela de visualização e da transformação do mundo.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e O endereço de memória da localização desta série de vértices [lppt] \Um ponteiro para uma matriz de estruturas POINT. 
    \As coordenadas x e as coordenadas y contidas em cada uma das estruturas POINT serão transformadas.
    \A estrutura POINT define as coordenadas X e Y de um ponto.
    e A quantidade de vértices desta série de vértices. [c] \O número de pontos na matriz/série de vértices.
  \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "CreatePolygonRgn" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn
  \A função CreatePolygonRgn cria uma região poligonal.
    O endereço de memória da localização desta série de vértices  [*pptl] \Um ponteiro para uma matriz de estruturas POINT que definem os vértices do polígono em unidades lógicas. 
   \O polígono é presumido como sendo um polígono fechado. Cada vértice pode ser especificado apenas uma vez.
    e A quantidade de vértices desta série de vértices [cPoint] \O número de pontos na matriz.
    e 2 [iMode = WINDING] \O modo de preenchimento usado para determinar quais pixels estão na região.  -> exemplo: https://docs.microsoft.com/en-us/windows/win32/gdi/images/csrgn-03.png
    \Este parâmetro pode ser um dos seguintes valores.
    \ ALTERNATE ou Seleciona o modo alternativo (preenche a área entre os lados ímpares e pares do polígono em cada linha de varredura).
    \WINDING = Seleciona o modo de enrolamento (preenche qualquer região com um valor de enrolamento diferente de zero).
    \Para obter mais informações sobre esses modos, consulte a função SetPolyFillMode, ou leia mais abaixo:    
    \Um aplicativo preenche o interior de uma região chamando a função FillRgn e fornecendo um identificador que identifica um pincel específico. 
    \Quando um aplicativo chama FillRgn, o sistema preenche a região com o pincel usando o modo de preenchimento atual para o contexto de dispositivo especificado. 
    \Existem dois modos de preenchimento: alternado e enrolamento. 
    \O aplicativo pode definir o modo de preenchimento para um contexto de dispositivo chamando a função SetPolyFillMode. 
    \O aplicativo pode recuperar o modo de preenchimento atual para um contexto de dispositivo chamando a função GetPolyFillMode.    
    \Modo Alternativo
    \Para determinar quais pixels o sistema destaca quando o modo alternativo é especificado, execute o seguinte teste:
    \Selecione um pixel no interior da região.
    \Desenhe um raio imaginário, na direção x positiva, desse pixel em direção ao infinito.
    \Cada vez que o raio cruza uma linha limite, aumente um valor de contagem.
    \O sistema destaca o pixel se o valor da contagem for um número ímpar.    
    \Modo de enrolamento
    \Para determinar quais pixels o sistema destaca quando o modo de enrolamento é especificado, execute o seguinte teste:
    \Determine a direção em que cada linha de limite é desenhada.
    \Selecione um pixel no interior da região.
    \Desenhe um raio imaginário, na direção x positiva, do pixel em direção ao infinito.
    \Cada vez que o raio intercepta uma linha limite com um componente y positivo, aumente um valor de contagem. 
    \Cada vez que o raio cruza uma linha limite com um componente y negativo, diminua o valor de contagem.
    \O sistema destaca o pixel se o valor da contagem for diferente de zero.
    devolvendo o hRgn. \Se a função for bem-sucedida, o valor de retorno será o número identificador da região.
    \Se a função falhar, o valor de retorno será NULL.
  Destrua a série de vértices.

Etapas para que se crie um hRgn usando uma caixa arredondada:
  Se o raio desta caixa arredondada for 0, crie o hRgn usando a caixa arredondada como [se fosse] uma caixa [normal]; volte.
  Atribua a caixa arredondada a uma caixa.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "BeginPath" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-beginpath
    \A função BeginPath abre um suporte de caminho no contexto de dispositivo especificado.
    O quadro atual.[hDC] \Um identificador para o contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "RoundRect" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-roundrect
  \A função RoundRect desenha um retângulo com cantos arredondados. O retângulo é delineado com a caneta atual e preenchido com o pincel atual.
    O quadro atual [hDC] \Um identificador para o contexto do dispositivo.
    e A coordenada X do canto superior esquerdo desta caixa [left] \A coordenada X, em coordenadas lógicas, do canto superior esquerdo do retângulo.
    e A coordenada Y do canto superior esquerdo desta caixa [top] \A coordenada Y, em coordenadas lógicas, do canto superior esquerdo do retângulo.
    e A coordenada X do canto inferior direito desta caixa [right] \A coordenada X, em coordenadas lógicas, do canto inferior direito do retângulo.
    e A coordenada Y do canto inferior direito desta caixa [bottom] \A coordenada Y, em coordenadas lógicas, do canto inferior direito do retângulo.
    e O diameter [width] \A largura, em coordenadas lógicas, da elipse usada para desenhar os cantos arredondados.
    e O diameter. [height] \A altura, em coordenadas lógicas, da elipse usada para desenhar os cantos arredondados.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
    \Observação: A posição atual não é usada nem atualizada por esta função.
    \Para obter um exemplo, consulte https://docs.microsoft.com/en-us/windows/desktop/gdi/using-filled-shapes
  Call "gdi32.dll" "EndPath" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-endpath
    \A função EndPath fecha um suporte de caminho e seleciona o caminho definido pelo suporte no contexto de dispositivo especificado.
    O quadro atual. [hDC] \Um identificador para o contexto de dispositivo no qual o novo caminho é selecionado.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "gdi32.dll" "PathToRegion" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-pathtoregion
  \A função PathToRegion cria uma região do caminho que é selecionado no contexto de dispositivo especificado. A região resultante usa coordenadas do dispositivo.
    O quadro atual [hDC] \Identificador para um contexto de dispositivo que contém um caminho fechado.
   devolvendo o hRgn. \Se a função for bem-sucedida, o valor de retorno é um identificador válido para a região.
    \ Se a função falhar, o valor de retorno é zero.

Etapas para que se crie um catálogo usando uma contagem de buckets:
  Aloque memória para o catálogo.
  Atribua a contagem de buckets à contagem de buckets deste catálogo.
  Atribua o magnitude desse conjunto de buckets a uma largura.
  Atribua a contagem de buckets deste catálogo times a largura a um número.
  Assign o first bucket deste catálogo usando o número.
  Atribua o first bucket deste catálogo mais o número menos a largura ao last bucket deste catálogo.

Etapas para que se crie o dicionário léxico:
  Aloque memória para o dicionário léxico.
  Crie o catálogo deste dicionário léxico usando 4027.

Etapas para que se crie o número identificador de abertura of uma requisição WinHTTP:
  Se a requisição WinHTTP for inexistente, cancele.
  Converta o nome deste module para uma string composta de caracteres amplos denominado wide module nome e termine com o caractere NULL.
  Call "WinHTTP.dll" "WinHttpOpen" com \ https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpopen
  \A função WinHttpOpen inicializa, para um aplicativo, o uso de funções WinHTTP e retorna um identificador de sessão WinHTTP.
  \A função WinHttpOpen é a primeira das funções WinHTTP chamadas por um aplicativo. 
  \Ela inicializa estruturas de dados WinHTTP internas e prepara-as para chamadas futuras do aplicativo.
    O caractere inicial deste wide module nome [pszAgentW] \Opcional. 
    \Trata-se de um ponteiro para uma variável de string que contém o nome do aplicativo ou entidade que chama as funções WinHTTP. 
    \Este nome é usado como o agente do usuário no protocolo HTTP.
    e 0 [dwAccessType = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY] \Tipo de acesso requerido
    \A Opção WINHTTP_ACCESS_TYPE_DEFAULT_PROXY recupera o proxy estático ou a configuração direta do registro. 
    \WINHTTP_ACCESS_TYPE_DEFAULT_PROXY não herda as configurações de proxy do navegador.
    \A configuração do proxy WinHTTP é definida por um desses mecanismos.
    \pelo utilitário proxycfg.exe no Windows XP e Windows Server 2003 ou anterior.
    \pelo utilitário netsh.exe no Windows Vista e Windows Server 2008 ou posterior.
    \pela função WinHttpSetDefaultProxyConfiguration em todas as plataformas.
    \Importante O uso desta opção está obsoleto no Windows 8.1 e nas versões mais recentes do Windows.
    \Em vez disso, use o valor 4 que representa a opção WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXY.
    \Obs: só é possível usa a opção WINHTTP_ACCESS_TYPE_AUTOMATIC_PROXYno Windows 8.1 e nas versões mais recentes do Windows.
    e 0 [pszProxyW = WINHTTP_NO_PROXY_NAME] 
    \Um ponteiro para uma variável de seqüência de caracteres que contém o nome do servidor proxy a ser usado 
    \quando o acesso do proxy é especificado, definindo dwAccessType como 3 (WINHTTP_ACCESS_TYPE_NAMED_PROXY).
    \Se dwAccessType não estiver definido como WINHTTP_ACCESS_TYPE_NAMED_PROXY, este parâmetro deve ser definido como 0 (WINHTTP_NO_PROXY_NAME).
    e 0 [pszProxyBypassW = WINHTTP_NO_PROXY_BYPASS] 
    \Um ponteiro para uma variável de seqüência de caracteres que contém uma lista opcional delimitada por ponto-e-vírgula de nomes de host ou endereços IP,
    \ou ambos, que não deve ser roteado por meio do proxy quando dwAccessType é definido como WINHTTP_ACCESS_TYPE_NAMED_PROXY. 
    \A lista pode conter caracteres curinga. Não use uma string vazia, porque a função WinHttpOpen a usa como a lista de ignorar proxy. 
    \Se este parâmetro especificar a macro "<local>" na lista como a única entrada, esta função ignora qualquer nome de host que não contenha um ponto. 
    \Se dwAccessType não estiver definido como WINHTTP_ACCESS_TYPE_NAMED_PROXY, este parâmetro deve ser definido como WINHTTP_NO_PROXY_BYPASS.
    e 0 [dwFlags] \Valor inteiro longo sem sinal que contém os sinalizadores que indicam várias opções que afetam o comportamento desta função.
    \ Em tese, os únicos valores disponíveis seriam 268435456 (WINHTTP_FLAG_ASYNC) e 805306368 (WINHTTP_FLAG_SECURE_DEFAULTS)
    devolvendo o número identificador de sessão deste número identificador de requisição desta requisição WinHTTP.
    \Retorna um identificador de sessão válido se for bem-sucedido ou NULL caso contrário.
  Se o número identificador de sessão deste número identificador de requisição desta requisição WinHTTP for 0, atribua "Erro. Não foi possível iniciar a conexão." ao erro do fluxo de entrada/saída; volte.

Etapas para que se crie um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, crie o endereço completo no sistema de arquivos (pasta)[endereço]; volte.
  Se o endereço completo for file-format, crie o endereço completo no sistema de arquivos (arquivo); volte.

Etapas para que se crie um endereço completo no sistema de arquivos (pasta)[endereço]:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateDirectoryA" com \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createdirectorya
  \Cria um novo diretório. Se o sistema de arquivos subjacente oferecer suporte à segurança em arquivos e diretórios, a função aplicará um descritor de segurança especificado ao novo diretório.
  \Para especificar um diretório de modelo, use a função CreateDirectoryEx.
    O caractere inicial deste endereço completo [lpPathName] \O caminho do diretório a ser criado.
  \Para a versão ANSI desta função, há um limite de tamanho de string padrão para caminhos de 248 caracteres (MAX_PATH - espaço suficiente para um nome de arquivo 8.3). 
  \Para estender esse limite para 32.767 caracteres largos, chame a versão Unicode da função e acrescente "\\? \" ao caminho. 
  \Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file
  \Dica A partir do Windows 10, versão 1607, para a versão unicode desta função (CreateDirectoryW), você pode optar por remover a limitação de 248 caracteres sem incluir "\\? \" no início. 
  \O limite de 255 caracteres por segmento de caminho ainda se aplica. 
    \Consulte a seção "Limitação de comprimento máximo do caminho" do site acima para obter detalhes.
    e 0 [lpSecurityAttributes] \Um ponteiro para uma estrutura SECURITY_ATTRIBUTES. https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
    \O membro lpSecurityDescriptor da estrutura especifica um descritor de segurança para o novo diretório. 
    \Se lpSecurityAttributes for NULL, o diretório obterá um descritor de segurança padrão. 
    \As ACLs no descritor de segurança padrão para um diretório são herdadas de seu diretório pai.
    \O sistema de arquivos de destino deve suportar segurança em arquivos e diretórios para que este parâmetro tenha efeito. 
    \(Isso é indicado quando GetVolumeInformation retorna FS_PERSISTENT_ACLS.) https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  \Se a função falhar, o valor de retorno é zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, volte. \Se o número for 0, então faça o seguinte:
  Atribua "Erro. Não foi possível criar a pasta '" junto com o endereço completo seguido de "'. Provavelmente a pasta já existe no sistema de arquivos ou você não tem permissão de escrita" ao erro do fluxo de entrada/saída.

Etapas para que se crie um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
  \Cria ou abre um arquivo ou dispositivo de E/S. 
  \Os dispositivos de E / S mais comumente usados são os seguintes: 
  \arquivo, fluxo de arquivo, diretório, disco físico, volume, buffer de console, unidade de fita, recurso de comunicação, slot de correio e canal. 
  \A função retorna um identificador que pode ser usado para acessar o arquivo ou dispositivo para vários tipos de E / S, 
  \dependendo do arquivo ou dispositivo e dos sinalizadores e atributos especificados.
    O caractere inicial deste endereço completo [lpFileName] \ O nome do arquivo ou dispositivo a ser criado ou aberto. 
    \Você pode usar barras (/) ou barras invertidas (\) neste nome.
  \Na versão ANSI desta função, o nome é limitado a MAX_PATH caracteres.
  \Para estender esse limite para 32.767 caracteres largos, chame a versão Unicode da função e acrescente "\\? \" ao caminho. 
  \Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file
  \Para obter informações sobre nomes de dispositivos especiais, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/defining-an-ms-dos-device-name
  \Para criar um fluxo de arquivo, especifique o nome do arquivo, dois pontos e o nome do fluxo. 
  \Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-streams
  \Dica A partir do Windows 10, versão 1607, para a versão Unicode desta função (CreateFileW), você pode optar por remover a limitação MAX_PATH sem acrescentar "\\? \". 
  \Consulte a seção "Limitação de comprimento máximo do caminho" do site https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file  para detalhes
    e 1073741824 [dwDesiredAccess = GENERIC_WRITE] \O acesso solicitado ao arquivo ou dispositivo, que pode ser resumido como leitura, gravação, ambos ou nenhum zero).
    \Os valores mais comumente usados são -2147483648 (GENERIC_READ), 1073741824 (GENERIC_WRITE) ou ambos -1073741824 (GENERIC_READ | GENERIC_WRITE). 
    \Para obter mais informações, consulte os sites:
    \ https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/generic-access-rights
    \ https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-security-and-access-rights
    \ https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-access-rights-constants
    \ https://docs.microsoft.com/en-us/windows/desktop/SecAuthZ/access-mask
    \Se este parâmetro for zero, o aplicativo pode consultar certos metadados, como arquivo, diretório ou atributos de dispositivo sem acessar esse arquivo ou dispositivo, 
    \mesmo se o acesso GENERIC_READ tivesse sido negado.
    e 0 [dwShareMode] \O modo de compartilhamento solicitado do arquivo ou dispositivo, que pode ser lido, escrito, ambos, excluir, todos ou nenhum. 
    \Os pedidos de acesso a atributos ou atributos estendidos não são afetados por este sinalizador.
    \O valor 0 impede que outros processos abram esse arquivo ou dispositivo se solicitarem acesso de exclusão, leitura ou gravação.
  \Se este parâmetro for 0 e CreateFile for bem-sucedido, o arquivo ou dispositivo não pode ser compartilhado e não pode ser aberto novamente até que o identificador para o arquivo ou dispositivo seja fechado.   
    e 0 [lpSecurityAttributes] \Um ponteiro para uma estrutura SECURITY_ATTRIBUTES que contém dois membros de dados separados, mas relacionados: 
    \ https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)
    \um descritor de segurança opcional e um valor booleano que determina se o identificador retornado pode ser herdado por processos filho.
    \Este parâmetro pode ser NULL.
    \Se este parâmetro for NULL, o identificador retornado por CreateFile não pode ser herdado por nenhum processo filho que o aplicativo possa criar 
    \e o arquivo ou dispositivo associado ao identificador retornado obtém um descritor de segurança padrão.
    e 1 [dwCreationDisposition = CREATE_NEW] \Uma ação a ser executada em um arquivo ou dispositivo existente ou não.
    \Para dispositivos diferentes de arquivos, este parâmetro geralmente é definido como OPEN_EXISTING.
    \O valor 1 (CREATE_NEW) cria um novo arquivo, apenas se ainda não existir.
    \Se o arquivo especificado existir, a função falhará e o código do último erro será definido como ERROR_FILE_EXISTS (80).
    \Se o arquivo especificado não existir e for um caminho válido para um local gravável, um novo arquivo será criado.
    e 128 [dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL] \Os atributos e sinalizadores de arquivo ou dispositivo, sendo que FILE_ATTRIBUTE_NORMAL é o valor padrão mais comum para arquivos.
  \Quando o valor é 128 (FILE_ATTRIBUTE_NORMAL) o arquivo não possui outros atributos definidos. Este atributo é válido apenas se usado sozinho.
  \Este parâmetro pode incluir qualquer combinação dos atributos de arquivo disponíveis (FILE_ATTRIBUTE_ *). 
  \Todos os outros atributos de arquivo substituem FILE_ATTRIBUTE_NORMAL.
  \Para obter acesso mais avançado aos atributos de arquivo, consulte https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa
  \Para obter uma lista completa de todos os atributos de arquivo com seus valores e descrições, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-attribute-constants
    e 0 [hTemplateFile] \Um identificador válido para um arquivo de modelo com o direito de acesso GENERIC_READ. 
    \O arquivo de modelo fornece atributos de arquivo e atributos estendidos para o arquivo que está sendo criado.
    \Este parâmetro pode ser NULL.
    \Ao abrir um arquivo existente, CreateFile ignora este parâmetro
    devolvendo um número identificador. \Se a função for bem-sucedida, o valor de retorno será um identificador aberto para o arquivo, dispositivo, canal nomeado ou slot de correio especificado.
    \Se a função falhar, o valor de retorno é -1 (INVALID_HANDLE_VALUE).
  Call "kernel32.dll" "CloseHandle" com \ https://docs.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle
  \Fecha um identificador de objeto aberto.
  \CloseHandle deve ser usado quando você terminar com o objeto. 
  \Em geral, CloseHandle invalida o identificador do objeto especificado, diminui a contagem do identificador do objeto e executa verificações de retenção do objeto. 
  \Depois que o último identificador para um objeto é fechado, o objeto é removido do sistema.
    O número identificador. [hObject] \Um identificador válido para um objeto aberto.
    \Se o aplicativo estiver sendo executado em um depurador, a função lançará uma exceção se receber um valor de identificador inválido ou um valor de pseudo-identificador. 
    \Isso pode acontecer se você fechar um identificador duas vezes ou se você chamar CloseHandle em um identificador retornado pela função FindFirstFile em vez de chamar a função FindClose.
  Limpe o erro do fluxo de entrada/saída.
  \Geralmente, um aplicativo deve chamar CloseHandle uma vez para cada identificador que abre. 
  \Geralmente não é necessário chamar CloseHandle se uma função que usa um identificador falhar com ERROR_INVALID_HANDLE, 
  \porque esse erro geralmente indica que o identificador já está invalidado. 
  \No entanto, algumas funções usam ERROR_INVALID_HANDLE para indicar que o próprio objeto não é mais válido. 
  \Por exemplo, uma função que tenta usar um identificador para um arquivo em uma rede pode falhar com ERROR_INVALID_HANDLE se a conexão de rede for interrompida, 
  \porque o objeto de arquivo não está mais disponível. 
  \Nesse caso, o aplicativo deve fechar o identificador.
  \Se a função CloseHandle for bem-sucedida, o valor de retorno será diferente de zero.
  \Se a função CloseHandle  falhar, o valor de retorno será zero.
  Se o número identificador [da função CreateFileA] não for -1 [INVALID_HANDLE_VALUE], cancele. \ Se a função CreateFileA falhar, o valor de retorno é -1 (INVALID_HANDLE_VALUE).
  Atribua "Erro. Não foi possível criar o arquivo '" junto com o endereço completo seguido de "'." ao erro do fluxo de entrada/saída.

Etapas para que se crie uma imagem:
  Aloque memória para a imagem.

Etapas para que se crie uma imagem usando um trecho:
  Crie um gpBitmap usando o trecho.
  Se o gpBitmap for inexistente, esvazie a imagem; volte.
  Aloque memória para a imagem.
  Atribua o trecho ao data desta imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).

Etapas para que se crie uma imagem usando um gpBitmap:
  Se o gpBitmap for inexistente, esvazie a imagem; volte.
  Aloque memória para a imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).

Etapas para que se crie uma imagem usando uma URL:
  Read o URL a um trecho.
  Crie a imagem usando o trecho.

Etapas para que se crie um polígono:
  Aloque memória para o polígono.

Etapas para que se crie um quora:
  Aloque memória para o quora.

Etapas para que se crie um refer:
  Aloque memória para o refer.

\socket = encaixe
Etapas para que se crie o número identificador da requisição of uma requisição WinHTTP using uma URL simplificada:
  Se a requisição WinHTTP for inexistente, cancele.
  Converta o endereço de recurso desta URL simplificada para uma string composta de caracteres amplos denominada endereço composto de caracteres amplos e termine com o caractere NULL.
  Converta "POST" para uma string composta de caracteres amplos denominado POST composto de caracteres amplos e termine com o caractere NULL.
  Se o nome do protocolo desta URL simplificada for "https", atribua 8388608 [WINHTTP_FLAG_SECURE] a um secure número.
  Call "WinHTTP.dll" "WinHttpOpenRequest" com \ https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpopenrequest
  \A função WinHttpOpenRequest cria um identificador de solicitação HTTP.
    O número identificador de conexão desta requisição WinHTTP [hConnect] \Número identificador de conexão HINTERNET de uma sessão HTTP retornada pela função WinHttpConnect.
    \Para detalhes consulte HINTERNET: https://docs.microsoft.com/en-us/windows/desktop/WinHttp/hinternet-handles-in-winhttp
    \e também a função WinHttpConnect https://docs.microsoft.com/en-us/windows/desktop/api/winhttp/nf-winhttp-winhttpconnect
    e O caractere inicial deste POST composto de caracteres amplos [pwszVerb] \Ponteiro para uma string que contém o verbo HTTP a ser usado na solicitação. 
    \Se este parâmetro for NULL, a função usará GET como o verbo HTTP. 
    \Observação: Esta string deve estar toda em maiúsculas. 
    \Muitos servidores tratam os verbos HTTP com distinção entre maiúsculas e minúsculas, e
    \as Solicitações de Comentários (RFCs) da Internet Engineering Task Force (IETF) soletram esses verbos usando apenas caracteres maiúsculos.
    e O caractere inicial deste endereço composto de caracteres amplos [pwszObjectName] 
    \Ponteiro para uma string que contém o nome do recurso de destino do verbo HTTP especificado. 
    \Geralmente é um nome de arquivo, um módulo executável ou um especificador de pesquisa.
    e 0 [pwszVersion = L"HTTP/1.1"] \Ponteiro para uma string que contém a versão HTTP. Se este parâmetro for NULL, a função usará HTTP / 1.1.
    e 0 [pwszReferrer = WINHTTP_NO_REFERER]  \Ponteiro para uma string que especifica a URL do documento a partir do qual a URL na solicitação pwszObjectName foi obtida. 
    \Se este parâmetro for definido como WINHTTP_NO_REFERER, nenhum documento de referência será especificado.
    e 0 [*ppwszAcceptTypes = WINHTTP_DEFAULT_ACCEPT_TYPES]  \Ponteiro para uma matriz terminada em nulo de ponteiros de string que especifica os tipos de mídia aceitos pelo cliente. 
    \Se este parâmetro for definido como WINHTTP_DEFAULT_ACCEPT_TYPES, nenhum tipo será aceito pelo cliente. 
    \Normalmente, os servidores lidam com a falta de tipos aceitos como indicação de que o cliente aceita apenas documentos do tipo "text / *"; 
    \ou seja, apenas documentos de texto - sem imagens ou outros arquivos binários. 
    \Para obter uma lista de tipos de mídia válidos, consulte Tipos de mídia definidos pela IANA em http://www.iana.org/assignments/media-types/
    e O secure número [dwFlags] \Valor inteiro longo sem sinal que contém os valores dos sinalizadores da Internet
    devolvendo o número identificador de requisição desta requisição WinHTTP. \Retorna um identificador de solicitação HTTP válido se for bem-sucedido ou NULL se não for.
  Se o número identificador de requisição desta requisição WinHTTP for 0, atribua "Erro ao chamar a função 'WinHttpOpenRequest' da biblioteca 'WinHTTP.dll'. Não foi possível obter o número identificador da requisição." ao erro do fluxo de entrada/saída; volte.

Etapas para que se crie uma row usando um pedaço:
  Aloque memória para a row.
  Atribua o pedaço à string deste row.

Etapas para que se crie uma row usando uma string:
  Aloque memória para a row.
  Atribua a string à string deste row.

Etapas para que se crie um socket usando um host string e um número de porta:
  \ esta rotina cria, conecta e define o erro se houver um problema
  Limpe o erro do fluxo de entrada/saída.
  \ obtém o sockaddr
  Obtenha um sockaddr usando o host.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua 2 [AF_INET ] ao sin_family deste sockaddr.
  Atribua o port ao sin_port deste sockaddr.
  \ cria o socket 
  Call "ws2_32.dll" "socket" com \ https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket
  \A função de soquete cria um soquete (encaixe/tomada) que está vinculado a um provedor de serviços de transporte específico.
    2 [af = AF_INET ] \ Valor da família de endereços do endereço de transporte. 
    \O valor AF_INET é usado para endereços IPV4
    e 1 [type = SOCK_STREAM ]  \O tipo do novo soquete.
    \SOCK_STREAM é um tipo de soquete que fornece fluxos de bytes sequenciados, confiáveis, bidirecionais e baseados em conexão com um mecanismo de transmissão de dados OOB. 
    \Este tipo de soquete usa o TCP para a família de endereços da Internet (ipv4 e ipv6)
    e 0 [protocol = IPPROTO_IP] \O protocolo a ser usado. 
   \Se um valor de 0 for especificado, o chamador não deseja especificar um protocolo e o provedor de serviços escolherá o protocolo a ser usado.
   \Normalmente, existe apenas um único protocolo para oferecer suporte a um determinado tipo de soquete dentro de uma determinada família de protocolos; nesse caso, o protocolo pode ser especificado como 0.
    devolvendo o socket. \Se nenhum erro ocorrer, o socket retorna um descritor referenciando o novo socket. WSAAPI 
  \Caso contrário, um valor de INVALID_SOCKET é retornado
  Se o socket for -1 [INVALID_SOCKET ], atribua "Erro. O soquete informado não é um soquete válido." ao erro do fluxo de entrada/saída; volte.
  \ connect socket
  Call "ws2_32.dll" "connect" com \ https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect
  \A função connect estabelece uma conexão com um soquete especificado.
    O socket [s] \Um descritor que identifica um soquete não conectado.
    e O endereçamento deste sockaddr [*name] \Um ponteiro para a estrutura sockaddr com a qual a conexão deve ser estabelecida.
    \ https://docs.microsoft.com/en-us/windows/desktop/WinSock/sockaddr-2
    e A magnitude deste sockaddr [namelen] \O comprimento, em bytes, da estrutura sockaddr apontada pelo parâmetro name.
    devolvendo um número resultante.\Se nenhum erro ocorrer, a conexão retorna zero. Caso contrário, retorna SOCKET_ERROR
  Se o número resultante não for 0 [SOCKET_ERROR], atribua "Erro. Não foi possível estabelecer uma conexão com o soquete informado." ao erro do fluxo de entrada/saída; volte.
  \ abra send timeout 30 seconds
  Call "ws2_32.dll" "setsockopt" com \ https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-setsockopt
  \A função setsockopt define uma opção de socket.
    O socket [s] \Um descritor que identifica um soquete.
    e 65535 [level] \O nível em que a opção é definida (por exemplo, SOL_SOCKET).
    e 4101 [optname SO_SNDTIMEO 0x00001005]  \A opção de soquete para a qual o valor deve ser definido (por exemplo, SO_BROADCAST). 
    \O parâmetro optname deve ser uma opção de soquete definida dentro do nível especificado, ou o comportamento é indefinido.
    \O tempo limite, em milissegundos, para bloquear chamadas enviadas.
    e 30 seconds' endereçamento [*optval] \Um ponteiro para o buffer no qual o valor da opção solicitada é especificado.
    e 4 [optlen] \O tamanho, em bytes, do buffer apontado pelo parâmetro optval.
    devolvendo o número resultante. \Se nenhum erro ocorrer, setsockopt retorna zero. Caso contrário, um valor de SOCKET_ERROR é retornado
  Se o número resultante não for 0 [SOCKET_ERROR ], atribua "Erro na função 'setsockopt' da biblioteca 'ws2_32.dll'. Não foi possível definiro tempo limite de envio SO_SNDTIMEO (4101) do soquete. " ao erro do fluxo de entrada/saída; volte.
  \ abra receive timeout 30 seconds
  Call "ws2_32.dll" "setsockopt" com \ https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-setsockopt
  \A função setsockopt define uma opção de socket.
    O socket [s] \Um descritor que identifica um soquete.
    e 65535 [level] \O nível em que a opção é definida (por exemplo, SOL_SOCKET).
    e 4102 [optname SO_RCVTIMEO  0x00001006]    \Define o tempo limite, em milissegundos, para bloquear chamadas recebidas.
    \A opção de soquete para a qual o valor deve ser definido (por exemplo, SO_BROADCAST). 
    \O parâmetro optname deve ser uma opção de soquete definida dentro do nível especificado, ou o comportamento é indefinido.
    \O tempo limite, em milissegundos, para bloquear chamadas enviadas.
    e 30 seconds' endereçamento [*optval] \Um ponteiro para o buffer no qual o valor da opção solicitada é especificado.
    e 4 [optlen] \O tamanho, em bytes, do buffer apontado pelo parâmetro optval.
    devolvendo o número resultante. \Se nenhum erro ocorrer, setsockopt retorna zero. Caso contrário, um valor de SOCKET_ERROR é retornado
  Se o número resultante não for 0, atribua "Erro na função 'setsockopt' da biblioteca 'ws2_32.dll'. Não foi possível definir o tempo limite de recepção  SO_RCVTIMEO (4102)  do soquete." ao erro do fluxo de entrada/saída; volte.

Etapas para que se crie um conjunto de texto usando uma string:
  Aloque memória para o conjunto de texto.
  Atribua a string à string deste conjunto de texto.

Etapas para que se crie um terminal em uma caixa:
  Aloque memória para o terminal.
  Atribua a caixa à caixa deste terminal.
  Atribua a cor verde ao output cor deste terminal.
  Atribua a cor verde claríssimo ao input cor deste terminal.

Etapas para que se crie um text:
  Aloque memória para o text.
  Atribua a cor preta ao pincel deste text.
  Atribua a fonte padrão ao font deste text.
  Atribua "left" ao alinhamento deste text.
  Atribua 1/1 à scale deste text.
  Garanta one row no text.
  Reset a origem of o text.
  Reset o cursor de texto of o text.
  Desvencilhe-se de o text.

Etapas para que se crie um vértice:
  Aloque memória para o vértice.

Etapas para que se crie uma série de vértices usando uma contagem:
  Isole a contagem.
  Aloque memória para a série de vértices.
  Atribua a contagem à quantidade de vértices desta série de vértices.
  Multiplique a contagem pela magnitude desse localização.
  Assign o endereço de memória da localização desta série de vértices usando a contagem.

Etapas para que se crie uma série de vértices usando uns vértices:
  Crie a série de vértices usando a contagem destes vértices.
  Atribua o endereço de memória da localização desta série de vértices a um endereço de memória da localização.
  Percorra. [o código abaixo]
    Obtenha um vértice desde o vértices.
    Se o vértice for inexistente, cancele.
    Atribua a localização deste vértice ao conteúdo deste endereço de memória da localização.
    Adicione a magnitude desta localização deste vértice para o endereço de memória da localização.
  Repita. [o código acima]

Etapas para que se crie um vértice usando uma localização:
  Aloque memória para o vértice.
  Atribua a localização à localização deste vértice.

Etapas para que se crie um vértice usando uma coordenada X e uma coordenada Y:
  Aloque memória para o vértice.
  Atribua a coordenada X à coordenada X deste vértice.
  Atribua a coordenada Y à coordenada Y deste vértice.

Etapas para que se crie uma requisição WinHTTP por posting para uma URL:
  Aloque memória para a requisição WinHTTP.
  Converta o URL para uma URL simplificada.
  Crie o número identificador de abertura of a requisição WinHTTP.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua a requisição WinHTTP; volte.
  Crie o connect handle of a requisição WinHTTP using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua a requisição WinHTTP; volte.
  Crie o número identificador da requisição of a requisição WinHTTP using o URL simplificada.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua a requisição WinHTTP; volte.

O console é um console.

O quadro atual é um canvas.

O evento atual é um event.

Um cursor é um número identificador.

Etapas para que se corte um número pela metade:
  Divida o número por 2.

Um date/time é um conjunto com
  Um year número,
  Um month número,
  Um week day número,
  Um day número,
  Um hour número,
  Um minute número,
  Um second número,
  Um millisecond número.

Etapas para que se de-sign um fração:
  De-sign o numerador desta fração.
  De-sign o denominador desta fração.

Etapas para que se de-sign um número:
  Se o número for o menor número, atribua o maior número ao número; volte.
  Se o número for menor do que 0, negate o número.

Etapas para que se de-sign um par de números:
  De-sign o número X deste par de números.
  De-sign o número Y deste par de números.

Etapas para que se de-sign uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste caractere inicial desta string for tipo de sinal aritmético, remove o first pedaço desde a string.

Um relatório é uma string.
Um relatório de informações é uma string.
Um relatório de bugs é uma string.
Um relatório de erros é uma string.
Um relatório de falhas é uma string.
Um relatório de panes é uma string.

Etapas para que se produza o relatório de bugs usando uma caixa;
Etapas para que se produza o relatório de falhas usando uma caixa;
Etapas para que se produza o relatório de panes usando uma caixa;
Etapas para que se produza o relatório de erros usando uma caixa;
Etapas para que se produza o relatório de informações usando uma caixa:
  Limpe um relatório.
  Posponha "Coordenada esquerda = " para o relatório.
  Posponha a coordenada X do canto superior esquerdo desta caixa para o relatório.
  Posponha ", Coordenada superior = " para o relatório.
  Posponha a coordenada Y do canto superior esquerdo desta caixa para o relatório.
  Posponha ", Coordenada direita = " para o relatório.
  Posponha a coordenada X do canto inferior direito desta caixa para o relatório.
  Posponha ", Coordenada inferior = " para o relatório.
  Posponha a coordenada Y do canto inferior direito desta caixa para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um pedaço;
Etapas para que se produza o relatório de falhas usando um pedaço;
Etapas para que se produza o relatório de panes usando um pedaço;
Etapas para que se produza o relatório de bugs usando um pedaço;
Etapas para que se produza o relatório de informações usando um pedaço:
  Atribua o pedaço a um número.
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma cor;
Etapas para que se produza o relatório de falhas usando uma cor;
Etapas para que se produza o relatório de panes usando uma cor;
Etapas para que se produza o relatório de bugs usando uma cor;
Etapas para que se produza o relatório de informações usando uma cor:
  Limpe um relatório.
  Posponha "Matiz = " para o relatório.
  Posponha a matiz desta cor para o relatório.
  Posponha ", Saturação = " para o relatório.
  Posponha a saturação desta cor para o relatório.
  Posponha ", Luminosidade = " para o relatório.
  Posponha a luminosidade desta cor para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um detector;
Etapas para que se produza o relatório de falhas usando um detector;
Etapas para que se produza o relatório de panes usando um detector;
Etapas para que se produza o relatório de bugs usando um detector;
Etapas para que se produza o relatório de informações usando um detector:
  Converta o detector para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de bugs usando uma font;
Etapas para que se produza o relatório de erros usando uma font;
Etapas para que se produza o relatório de falhas usando uma font;
Etapas para que se produza o relatório de panes usando uma font;
Etapas para que se produza o relatório de informações usando uma font:
  Limpe um relatório.
  Posponha " Nome da fonte = '" para o relatório seguido de "'".
  Posponha o nome desta font para o relatório.
  Posponha ", Tamanho da fonte = " para o relatório.
  Posponha a altura desta font para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma fração;
Etapas para que se produza o relatório de falhas usando uma fração;
Etapas para que se produza o relatório de panes usando uma fração;
Etapas para que se produza o relatório de bugs usando uma fração;
Etapas para que se produza o relatório de informações usando uma fração:
  Limpe um relatório.
  Posponha "Numerador = " para o relatório.
  Posponha o numerador desta fração para o relatório.
  Posponha ", Denominador = " para o relatório.
  Posponha o denominador desta fração para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de bugs usando uma linha reta;
Etapas para que se produza o relatório de falhas usando uma linha reta;
Etapas para que se produza o relatório de panes usando uma linha reta;
Etapas para que se produza o relatório de erros usando uma linha reta;
Etapas para que se produza o relatório de informações usando uma linha reta:
  Limpe um relatório.
  Posponha " Começo da linha = " para o relatório.
  Posponha a coordenada X desta localização inicial desta linha reta para o relatório.
  Posponha "," para o relatório.
  Posponha a coordenada Y desta localização inicial desta linha reta para o relatório.
  Posponha " Fim da linha = " para o relatório.
  Posponha a coordenada X desta localização final desta linha reta para o relatório.
  Posponha "," para o relatório.
  Posponha a coordenada Y desta localização final desta linha reta para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de falhas usando um número;
Etapas para que se produza o relatório de panes usando um número;
Etapas para que se produza o relatório de erros usando um número;
Etapas para que se produza o relatório de bugs usando um número;
Etapas para que se produza o relatório de informações usando um número:
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando um número e um segundo número;
Etapas para que se produza o relatório de falhas usando um número e um segundo número;
Etapas para que se produza o relatório de panes usando um número e um segundo número;
Etapas para que se produza o relatório de bugs usando um número e um segundo número;
Etapas para que se produza o relatório de informações usando um número e um segundo número:
  Produza o relatório de informações usando o número seguido de ", " junto com o segundo número.

Etapas para que se produza o relatório de falhas usando um par de números;
Etapas para que se produza o relatório de panes usando um par de números;
Etapas para que se produza o relatório de erros usando um par de números;
Etapas para que se produza o relatório de bugs usando um par de números;
Etapas para que se produza o relatório de informações usando um par de números:
  Limpe um relatório.
  Posponha "Coordenada X = " para o relatório.
  Posponha o número X deste par de números para o relatório.
  Posponha ", Coordenada Y = " para o relatório.
  Posponha o número Y deste par de números para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de panes usando um endereço de memória;
Etapas para que se produza o relatório de falhas usando um endereço de memória;
Etapas para que se produza o relatório de erros usando um endereço de memória;
Etapas para que se produza o relatório de bugs usando um endereço de memória;
Etapas para que se produza o relatório de informações usando um endereço de memória:
  Converta o endereço de memória para uma cifra hexadecimal.
  Produza o relatório de informações usando "$" junto com a cifra hexadecimal.
  Produza o relatório de informações usando "0x" junto com a cifra hexadecimal.

Etapas para que se produza o relatório de panes usando um espaço de cor RGB;
Etapas para que se produza o relatório de falhas usando um espaço de cor RGB;
Etapas para que se produza o relatório de erros usando um espaço de cor RGB;
Etapas para que se produza o relatório de bugs usando um espaço de cor RGB;
Etapas para que se produza o relatório de informações usando um espaço de cor RGB:
  Limpe um relatório.
  Posponha "Vermelho = " para o relatório. Atribua o espectro vermelho deste espaço de cor RGB a um número.
  Posponha o número para o relatório.
  Posponha ", Verde = " para o relatório. Atribua o espectro verde deste espaço de cor RGB ao número.
  Posponha o número para o relatório.
  Posponha ", Azul = " para o relatório. Atribua o espectro azul deste espaço de cor RGB ao número.
  Posponha o número para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de falhas usando um relatório;
Etapas para que se produza o relatório de panes usando um relatório;
Etapas para que se produza o relatório de erros usando um relatório;
Etapas para que se produza o relatório de bugs usando um relatório;
Etapas para que se produza o relatório de informações usando um relatório:
  Isole o relatório.
  Termine com o caractere NULL o relatório.
  Atribua "Detalhes: " a um relatório de erros.
  \Chame função "MessageBoxA" contida na biblioteca "user32.dll" informando os parâmetros a seguir: 0, o primeiro caractere do texto em questão, o primeiro caractere de "debug" e 0.
  Call "user32.dll" "MessageBoxA" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-messageboxa
  \Exibe uma caixa de diálogo modal que contém um ícone do sistema, um conjunto de botões e uma breve mensagem específica do aplicativo, como status ou informações de erro. 
  \A caixa de mensagem retorna um valor inteiro que indica em qual botão o usuário clicou.
    0 [hWnd] \Um identificador para a janela do proprietário da caixa de mensagem a ser criada. 
    \Se este parâmetro for 0 [NULL], a caixa de mensagem não terá janela do proprietário.
    e O caractere inicial deste relatório [lpText] \A mensagem a ser exibida. 
    \Se a string consistir em mais de uma linha, você pode separar as linhas usando um retorno de carro e / ou um caractere de avanço de linha entre cada linha.
    e O caractere inicial deste relatório de erros [lpCaption] \ O título da caixa de diálogo. Se este parâmetro for NULL, o título padrão é Erro.
    e 0. [uType] \O conteúdo e o comportamento da caixa de diálogo. Quando o valor é igual a 0 a caixa de mensagem contém apenas um botão: OK. Este é o  valor padrão.
    \Se a caixa de mensagem tiver um botão Cancelar, a função retornará o valor IDCANCEL se a tecla ESC for pressionada ou o botão Cancelar for selecionado. 
    \Se a caixa de mensagem não tiver o botão Cancelar, pressionar ESC não terá efeito - a menos que um botão MB_OK esteja presente. 
    \Se um botão MB_OK for exibido e o usuário pressionar ESC, o valor de retorno será IDOK.
    \Se a função falhar, o valor de retorno é zero.

Etapas para que se produza o relatório de erros usando um relatório (com aspas);
Etapas para que se produza o relatório de panes usando um relatório (com aspas);
Etapas para que se produza o relatório de falhas usando um relatório (com aspas);
Etapas para que se produza o relatório de bugs usando um relatório (com aspas);
Etapas para que se produza o relatório de informações usando um relatório (com aspas):
  Isole o relatório.
  Anteponha as aspas duplas para o relatório.
  Posponha as aspas duplas para o relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se produza o relatório de erros usando uma word;
Etapas para que se produza o relatório de panes usando uma word;
Etapas para que se produza o relatório de falhas usando uma word;
Etapas para que se produza o relatório de bugs usando uma word;
Etapas para que se produza o relatório de informações usando uma word:
  Atribua a word a um número.
  Converta o número para um relatório.
  Produza o relatório de informações usando o relatório.

Etapas para que se determine se uma caixa é uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta caixa não for a coordenada X do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta caixa não for a coordenada Y do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada X do canto inferior direito desta caixa não for a coordenada X do canto inferior direito desta segunda caixa, diga não.
  Se a coordenada Y do canto inferior direito desta caixa não for a coordenada Y do canto inferior direito desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa está still em uma segunda caixa;
Etapas para que se determine se uma caixa está em uma segunda caixa;
Etapas para que se determine se uma caixa está inside uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, diga não.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, diga não.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma caixa está tocando uma segunda caixa:
  Se a coordenada X do canto inferior direito desta segunda caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y do canto inferior direito desta segunda caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada X do canto superior esquerdo desta segunda caixa for maior do que a coordenada X do canto inferior direito desta caixa, diga não.
  Se a coordenada Y do canto superior esquerdo desta segunda caixa for maior do que a coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é alfanumérico:
  Se o pedaço for algum tipo de letra, diga sim.
  Se o pedaço for algum tipo de digit, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é um segundo pedaço ou um terceiro pedaço:
  Se o pedaço for o segundo pedaço, diga sim.
  Se o pedaço for o terceiro pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é alguma consoante:
  Se o pedaço estiver em "bcdfghjklmnpqrstvwxyzçñ", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de digit:
  Se o pedaço for menor do que o número zero, diga não.
  Se o pedaço for maior do que o número nove, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é algum tipo de letra:
  Se o pedaço estiver entre o 'A' maiúsculo e o Z maiúsculo, diga sim.
  Se o pedaço estiver entre o 'a' minúsculo e o z minúsculo, diga sim.
  Se o pedaço for 131 ou 138, diga sim.
  Se o pedaço for 140 ou 142, diga sim.
  Se o pedaço for 154 ou 156, diga sim.
  Se o pedaço estiver entre 158 e 159, diga sim.
  Se o pedaço estiver entre 192 e 214, diga sim.
  Se o pedaço estiver entre 216 e 246, diga sim.
  Se o pedaço estiver entre 248 e 255, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de indicador numérico:
  Se o pedaço é algum tipo de digit, diga sim.
  Se o pedaço é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de sinal de pontuação:
  \ precisa ser aprimorado
  Se o pedaço for o caractere de espaço, diga não.
  Se o pedaço não for alfanumérico, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é tipo de sinal aritmético:
  Se o pedaço for o sinal de adição, diga sim.
  Se o pedaço for o sinal de subtração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é algum tipo de unidade de disco válida:
  Atribua o pedaço a um endereço completo.
  Posponha ":\" para o endereço completo.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Se a categoria da unidade de disco for "", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é algum tipo de vogal:
  Se o pedaço estiver em "aeiouyáéíóúýãõäëïöüÿâêîôûàèìòù", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço está entre um segundo pedaço e um terceiro pedaço:
  Se o pedaço for menor do que o segundo pedaço, diga não.
  Se o pedaço for maior do que o terceiro pedaço, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço está entre um número e um segundo número:
  Se o pedaço for menor do que o número, diga não.
  Se o pedaço for maior do que o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço estiver em uma string:
  Isole o pedaço.
  Lowercase o pedaço.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga não.
    Atribua o conteúdo deste caractere inicial deste subtexto a um segundo pedaço.
    Lowercase o segundo pedaço.
    Se o segundo pedaço for o pedaço, diga sim.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se um pedaço é like um segundo pedaço:
  \ used internally para palavra wrap
  Se o pedaço for whitespace, acione um detector.
  Se o segundo pedaço for whitespace, acione um segundo detector.
  Se o detector for o segundo detector, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é irrelevante:
  Se o pedaço for menor do que ou igual ao caractere de espaço, diga sim.
  Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga sim.
  Se o pedaço for o espaço rígido, diga sim.
  Se o pedaço for 129, diga sim.
  Se o pedaço for 141, diga sim.
  Se o pedaço for 143, diga sim.
  Se o pedaço for 144, diga sim.
  Se o pedaço for 157, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é um número ou um segundo número:
  Se o pedaço for o número, diga sim.
  Se o pedaço for o segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é imprimível:
  Se o pedaço for menor do que o caractere de espaço, diga não.
  Se o pedaço for o antigo símbolo de delete [que agora está descontinuado], diga não.
  Se o pedaço for 129, diga não.
  Se o pedaço for 141, diga não.
  Se o pedaço for 143, diga não.
  Se o pedaço for 144, diga não.
  Se o pedaço for 157, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um pedaço é uma string:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Isole o pedaço.
  Lowercase o pedaço.
  Atribua o conteúdo deste caractere inicial desta string a um segundo pedaço.
  Lowercase o segundo pedaço.
  Se o pedaço for o segundo pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é symbolic:
  Se o pedaço estiver entre o ponto de exclamação e o slash pedaço, diga sim.
  Se o pedaço estiver entre o sinal de dois pontos e o sinal de arroba, diga sim.
  Se o pedaço estiver entre o colchete esquerdo e o acento grave, diga sim.
  Se o pedaço estiver entre o chave esquerda e o acento til, diga sim.
  Se o pedaço for 128, diga sim.
  Se o pedaço for 130, diga sim.
  Se o pedaço estiver entre 132 e 137, diga sim.
  Se o pedaço for 139, diga sim.
  Se o pedaço estiver entre 145 e 153, diga sim.
  Se o pedaço for 155, diga sim.
  Se o pedaço estiver entre 161 e 180, diga sim.
  Se o pedaço estiver entre 183 e 191, diga sim.
  Se o pedaço for 215, diga sim.
  Se o pedaço for 247, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um pedaço é whitespace:
  Se o pedaço for o caractere de espaço, diga sim.
  Se o pedaço for o tabulação horizontal, diga sim.
  Se o pedaço for o retorno de carro, diga sim.
  Se o pedaço for a quebra de linha, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o cursor de texto of um text é sob o beginning:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for 1, diga não.
  Se o cursor de texto número de coluna deste text não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o cursor de texto of um text é sob o end:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for a contagem destas rows deste text, diga não.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o cursor de texto número de coluna deste text não for a quantidade de caracteres desta string desta row, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o cursor de texto of um text está sobre o first linha reta:
  Se o text for inexistente, diga não.
  Se o número de linhas do cursor deste text não for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o cursor de texto of um text está sobre o last linha reta:
  Se o text for inexistente, diga não.
  Se as rows deste text estiverem vazio, diga não.
  Se o número de linhas do cursor deste text não for o número da linha desta last row deste text, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma choice é uma string:
  Se a choice for inexistente, diga não.
  Se o nome desta choice for a string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor e uma segunda cor estão clear:
  Se a cor não for clear, diga não.
  Se a segunda cor não for clear, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma cor é uma segunda cor:
  Se a matiz desta cor não for a matiz desta segunda cor, diga não.
  Se a saturação desta cor não for a saturação desta segunda cor, diga não.
  Se a luminosidade desta cor não for a luminosidade desta segunda cor, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma cor está clear:
  Se a matiz desta cor for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é escura:
  Se a luminosidade desta cor estiver entre 250 e 374, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é clara:
  Se a luminosidade desta cor estiver entre 625 e 749, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é normal:
  Se a luminosidade desta cor estiver entre 375 e 624, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muito escura:
  Se a luminosidade desta cor estiver entre 125 e 249, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muito clara:
  Se a luminosidade desta cor estiver entre 750 e 874, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muitíssimo escura:
  Se a luminosidade desta cor for menor do que ou igual para 124, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma cor é muitíssimo clara:
  Se a luminosidade desta cor for maior do que ou igual para 875, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um contador é past um número:
  Adicione 1 para o contador.
  Se o contador for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está acima of ou debaixo of uma caixa:
  Se a localização deste context está acima of ou debaixo of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está left ou right of uma caixa:
  Se a localização deste context é left ou right of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está para o right of uma caixa:
  Se a coordenada X desta localização deste context for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se a localização atual está within uns twips of uma caixa:
  Se a localização deste context estiver within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um difference está within uma malha:
  Isole a difference.
  De-sign a difference.
  Se o número X desta difference for maior do que ou igual ao número X desta malha, diga não.
  Se o número Y desta difference for maior do que ou igual ao número Y desta malha, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um event é algum tipo de atalho de tecla:
  Se o event for inexistente, diga não.
  Se a categoria deste event não for "pressionamento de tecla", diga não.
  Se o event não foi alterado, diga não.
  Se a tecla deste event estiver entre a tecla A/a e a tecla Z/z, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um event foi alterado:
  Se o detector de tecla Ctrl deste event estiver ativo, diga sim.
  Se o detector de tecla Alt deste event estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um finger é past o end of uma string:
  Se o finger for inexistente, diga sim.
  Se o finger for maior do que o caractere final desta string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se um detector está on:
\ alterne como uma segunda nome por detector also ? ***
\Se o detector estiver ativo, diga sim.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um detector está presente;
Etapas para que se determine se um detector está em vigor;
Etapas para que se determine se um detector está levantada;
Etapas para que se determine se um detector está ligado; \foi ligado também funciona
Etapas para que se determine se um detector está ativo;
Etapas para que se determine se um detector está ativado; \foi ativado
\Etapas para que se determine se um detector já está ativado;
Etapas para que se determine se um detector já foi ativado anteriomente;
\Etapas para que se determine se um detector foi ativado anteriomente;
Etapas para que se determine se um detector está tocando;
Etapas para que se determine se um detector está soando;
Etapas para que se determine se um detector soou;
\Etapas para que se determine se um detector já soou;
Etapas para que se determine se um detector está disparando;
\Etapas para que se determine se um detector disparou;
Etapas para que se determine se um detector está alarmando;
\Etapas para que se determine se um detector disparou;
Etapas para que se determine se um detector está sendo mostrada;
Etapas para que se determine se um detector está sendo exibida;
Etapas para que se determine se um detector está verde:
  Se o detector for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um detector está dormente;
Etapas para que se determine se um detector está suspenso;
Etapas para que se determine se um detector está inativo;
Etapas para que se determine se um detector está desligado;
Etapas para que se determine se um detector está desativado;
Etapas para que se determine se um detector está vermelho:
  Se o detector for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração é o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é maior que uma segunda fração;
Etapas para que se determine se uma fração é maior do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é maior do que ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for maior do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é menor que uma segunda fração;
Etapas para que se determine se uma fração é menor do que uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que o numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração for menor do que ou igual para uma segunda fração;
Etapas para que se determine se uma fração for menor que ou igual para uma segunda fração;
Etapas para que se determine se uma fração for menor ou igual para uma segunda fração:
  Isole a fração.
  Isole a segunda fração.
  Normalize a fração e a segunda fração.
  Se o numerador desta fração for menor do que ou igual ao numerador desta segunda fração, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é negativa:
  Se o numerador desta fração for menor do que 0, reverse um detector.
  Se o denominador desta fração for menor do que 0, reverse o detector.
  \ Say o detector. \ does not work em SAL; no detector literals anymore
  Se o detector estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma fração é um número:
  Se a fração é o número / 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um catálogo está vazia;
Etapas para que se determine se um catálogo estão vazias;
Etapas para que se determine se um catálogo estão vazios;
Etapas para que se determine se um catálogo está vazio:
  Se o catálogo for inexistente, diga sim.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, diga sim.
    Se os refers deste bucket não estiverem vazio, diga não.
  Repita. [o código acima]

Etapas para que se determine se um input é um clique:
  Esvazie o clique.
  Se a categoria deste input não for "clique", diga não.
  Atribua o input ao clique.

Etapas para que se determine se um item é encontrado:
  Se a categoria deste item não estiver em branco, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de digit tecla:
  Se a tecla estiver entre 48 e 57, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de letra tecla:
  Se a tecla estiver entre 65 e 90, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de tecla modificadora:
  Se a tecla for a tecla Alt, diga sim.
  Se a tecla for a tecla Ctrl, diga sim.
  Se a tecla for a tecla Shift, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de pad tecla:
  Se a tecla estiver entre 96 e 111, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de tecla imprimível:
  Se a tecla for o barra de espaço, diga sim.
  Se a tecla for algum tipo de digit tecla, diga sim.
  Se a tecla for algum tipo de letra tecla, diga sim.
  Se a tecla for algum tipo de pad tecla, diga sim.
  Se a tecla for algum tipo de symbol tecla, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de symbol tecla:
  Se a tecla estiver entre 186 e 192, diga sim.
  Se a tecla estiver entre 219 e 222, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla é algum tipo de WM_CHAR tecla:
  Se a tecla não for algum tipo de tecla imprimível , diga não.
  Se a tecla Alt está para baixo, diga não.
  Se a tecla Ctrl está para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma tecla [ou botão do mouse] está sendo pressionado;
Etapas para que se determine se uma [determinada] tecla [específica] está sendo pressionada:
  Call "user32.dll" "GetAsyncKeyState" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getasynckeystate
  \GetAsyncKeyState Determina se uma tecla está ativada ou desativada no momento em que a função é chamada e se a tecla foi pressionada após uma chamada anterior para GetAsyncKeyState.
    A tecla [vKey] \O código de tecla virtual. Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/inputdev/virtual-key-codes
    \Você pode diferenciar as teclas iguais do teclado se precisar saber se uma tecla específica está sendo pressionada . 
    devolvendo um word. \Se a função for bem-sucedida, o valor de retorno especifica se a tecla foi pressionada desde a última chamada para GetAsyncKeyState e se a tecla está ativada ou desativada. 
    \Se o bit mais significativo estiver definido, a tecla está sendo pressionada e, 
    \se o bit menos significativo estiver definido, a tecla foi pressionada após a chamada anterior para GetAsyncKeyState. 
    \No entanto, você não deve confiar neste último comportamento;
    \Embora o bit menos significativo do valor de retorno indique se a tecla foi pressionada desde a última consulta, devido à natureza multitarefa preemptiva do Windows, 
    \outro aplicativo pode chamar GetAsyncKeyState e receber o bit "pressionado recentemente" em vez de seu aplicativo. 
    \O comportamento do bit menos significativo do valor de retorno é retido estritamente para compatibilidade com aplicativos do Windows de 16 bits (que não são preemptivos) e não deve ser considerado.
    \A função GetAsyncKeyState também funciona com botões do mouse. 
    \No entanto, ela verifica o estado dos botões físicos do mouse, não os botões lógicos do mouse para os quais os botões físicos estão mapeados. 
    \Por exemplo, a chamada GetAsyncKeyState (VK_LBUTTON) sempre retorna o estado do botão físico esquerdo do mouse, 
    \independentemente de estar mapeado para o botão lógico esquerdo ou direito do mouse. 
    \Você pode determinar o mapeamento atual do sistema de botões físicos do mouse para botões lógicos do mouse chamando GetSystemMetrics (SM_SWAPBUTTON).
    \que retorna TRUE se os botões do mouse foram trocados.
  Atribua a word a um número.
  \O valor de retorno é zero para os seguintes casos:
  \A área de trabalho atual não é a área de trabalho ativa
  \O segmento de primeiro plano pertence a outro processo e a área de trabalho não permite que a operação seja realizada
  Se o número for menor do que 0, diga sim. \Se o bit mais significativo estiver definido (ou seja, se o número for negativo), a tecla está sendo pressionada
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla está para baixo:
  Call "user32.dll" "GetKeyState" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getkeystate
  \Recupera o status da tecla virtual especificada. 
  \O status especifica se a tecla está para cima, para baixo ou alternada (ligada, desligada - alternando cada vez que a tecla é pressionada).
    A tecla [nVirtKey] \Uma chave virtual. Se a chave virtual desejada for uma letra ou dígito (A-Z, a-z ou 0-9), nVirtKey deve ser definido com o valor ASCII desse caractere. 
    \Para as demais teclas, deve ser um código de tecla virtual.
    \Se um layout de teclado diferente do inglês for usado, as teclas virtuais com valores no intervalo ASCII A a Z e 0 a 9 serão usadas para especificar a maioria das teclas de caracteres. 
    \Por exemplo, para o layout de teclado alemão, a tecla virtual de valor ASCII O (0x4F) se refere à tecla "o", enquanto VK_OEM_1 se refere à tecla "ö (o com trema)".
    devolvendo um word. \O valor de retorno especifica o status da tecla virtual especificada, da seguinte maneira:
    \Se o bit de ordem superior for 1, a tecla está para baixo; caso contrário, está para cima.
    \Se o bit de ordem inferior for 1, a chave está alternada. 
    \Uma tecla, como a tecla CAPS LOCK, está alternada se estiver ativada. 
    \A tecla está desligada e não alternada se o bit de ordem inferior for 0. 
    \Uma luz indicadora da tecla de alternância (se houver) no teclado ficará acesa quando a tecla for alternada e desligada quando a tecla for desativada.
  Atribua a word a um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.
\O status da tecla retornada por esta função muda conforme um thread lê as mensagens principais de sua fila de mensagens. 
\O status não reflete o estado do nível de interrupção associado ao hardware. Use a função GetAsyncKeyState da rotina acima para recuperar essas informações.
\Um aplicativo chama GetKeyState em resposta a uma mensagem de entrada do teclado. Esta função recupera o estado da tecla quando a mensagem de entrada foi gerada.
\Para recuperar informações de estado para todas as chaves virtuais, use a função GetKeyboardState.

\GetAsyncKeyState () obtém o estado da chave de forma assíncrona, ou seja, sem esperar por nada, ou seja, AGORA.
\GetKeyState () obtém o estado da chave de forma síncrona, é o estado da chave que você está prestes a ler. 
\Ele é enfileirado no buffer do teclado junto com os pressionamentos de tecla propriamente ditos.

\A entrada do teclado no Windows é armazenada em buffer. 
\Isso garante que o usuário possa continuar digitando, mesmo se o programa estiver temporariamente sem resposta. 
\Sempre ocorre, até certo ponto, nenhuma perda de digitação dessa maneira. 
\As teclas são adicionadas à fila de mensagens, o loop de mensagens do programa os recupera com GetMessage () posteriormente.
\Junto com o pressionamento de tecla, o windows também armazena o estado de todas as outras teclas. 
\Para garantir que, quando a mensagem for finalmente recuperada, você possa dizer com segurança quais outras chaves estavam desativadas. 
\Muito importante para as teclas modificadoras, por exemplo. 
\Um pressionamento de tecla de atalho como Ctrl + A não funcionaria de forma confiável de outra forma.
\Portanto, geralmente você sempre usa GetKeyState(), obtém o estado das chaves conforme foram gravadas originalmente. 
\Ou GetKeyboardState (), você obtém a lista inteira. 
\Usar GetAsyncKeyState () é muito menos comum, não depende do estado de buffer, necessário apenas se o aplicativo tiver um tratamento de mensagens muito incomum. 
\Pode ser apropriado em um jogo, talvez.

\GetKeyState retorna o estado da tecla virtual. 
\Em outras palavras, GetKeyState relata o estado do teclado com base nas mensagens que você recuperou de sua fila de entrada. 
\Este não é o mesmo que o estado físico do teclado:
\Se o usuário digitou anteriormente, GetKeyState não relata essas alterações até que você use a função PeekMessage ou a função GetMessage para recuperar a mensagem de sua fila de entrada.
\Se o usuário mudou para outro programa, a função GetKeyState não verá a entrada que o usuário digitou naquele outro programa, uma vez que essa entrada não foi enviada para a fila de entrada.
\Quando você deve usar GetKeyState e quando deve usar GetAsyncKeyState?
\Para o trabalho de interface do usuário, quase sempre você deseja GetKeyState.

\Se você está respondendo a uma mensagem de entrada e deseja saber quais teclas foram pressionadas no momento em que a entrada foi gerada, você deseja usar GetKeyState. 
\Por exemplo, se você deseja distinguir um clique esquerdo do mouse de Alt + LeftClick, você deve usar GetKeyState para consultar o estado da tecla Alt (conhecido como VK_MENU por razões históricas). 
\Isso porque você deseja saber se a tecla Alt estava pressionada quando o usuário clicou com o mouse, não se a tecla está pressionada neste exato instante. 
\Se o usuário liberou a tecla Alt entre o momento em que clicou e o momento em que você processou a mensagem, é irrelevante. 
\Você se preocupa se a tecla Alt estava pressionada no momento do clique.

Etapas para que se determine se uma tecla está ligada;
Etapas para que se determine se uma tecla está alternada;
Etapas para que se determine se uma tecla está ativada:
  Call "user32.dll" "GetKeyState" com  \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getkeystate
  \Recupera o status da tecla virtual especificada. 
  \O status especifica se a tecla está para cima, para baixo ou alternada (ligada, desligada - alternando cada vez que a tecla é pressionada).
    A tecla [nVirtKey] \Uma chave virtual. Se a chave virtual desejada for uma letra ou dígito (A-Z, a-z ou 0-9), nVirtKey deve ser definido com o valor ASCII desse caractere. 
    \Para as demais teclas, deve ser um código de tecla virtual.
    \Se um layout de teclado diferente do inglês for usado, as teclas virtuais com valores no intervalo ASCII A a Z e 0 a 9 serão usadas para especificar a maioria das teclas de caracteres. 
    \Por exemplo, para o layout de teclado alemão, a tecla virtual de valor ASCII O (0x4F) se refere à tecla "o", enquanto VK_OEM_1 se refere à tecla "ö (o com trema)".
    devolvendo um word. \O valor de retorno especifica o status da tecla virtual especificada, da seguinte maneira:
    \Se o bit de ordem superior for 1, a tecla está para baixo; caso contrário, está para cima.
    \Se o bit de ordem inferior for 1, a chave está alternada. 
    \Uma tecla, como a tecla CAPS LOCK, está alternada se estiver ativada. 
    \A tecla está desligada e não alternada se o bit de ordem inferior for 0. 
    \Uma luz indicadora da tecla de alternância (se houver) no teclado ficará acesa quando a tecla for alternada e desligada quando a tecla for desativada.
  Atribua a word a um número.
  Conjuncione logicamente o número com 1.
  Se o número for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma tecla está para cima:
  Se a tecla está para baixo, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma tecla com um lParam é alguma tecla de cancelamento ou tecla modificadora:
  Atribua o lParam a um número.
  Conjuncione logicamente o número com 1073741824 [$40000000].
  Se o número for 0, diga não.
  Se a tecla for a tecla Esc, diga sim.
  Se a tecla for algum tipo de tecla modificadora, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o botão esquerdo do mouse está para baixo:
  Se o botão esquerdo deste mouse estiver sendo pressionado, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma linha reta está acima of uma caixa:
  Se a coordenada Y desta localização inicial desta linha reta for maior do que ou igual à coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y desta localização final desta linha reta for maior do que ou igual à coordenada Y do canto superior esquerdo desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha reta está acima of uma coordenada:
  Se a coordenada Y desta localização inicial desta linha reta for maior do que ou igual à coordenada, diga não.
  Se a coordenada Y desta localização final desta linha reta for maior do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha reta está debaixo of uma caixa:
  Se a coordenada Y desta localização inicial desta linha reta for menor do que ou igual à coordenada Y do canto inferior direito desta caixa, diga não.
  Se a coordenada Y desta localização final desta linha reta for menor do que ou igual à coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha reta está debaixo of uma coordenada:
  Se a coordenada Y desta localização inicial desta linha reta for menor do que ou igual à coordenada, diga não.
  Se a coordenada Y desta localização final desta linha reta for menor do que ou igual à coordenada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma linha reta está still em uma caixa;
Etapas para que se determine se uma linha reta está em uma caixa:
  Se a localização inicial desta linha reta não estiver na caixa, diga não.
  Se a localização final desta linha reta não estiver na caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um mixed é um número:
  Converta o mixed para um fração.
  Se a fração for o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o mouse foi arrastado desde uma localização usando uma malha:
  Se o botão esquerdo deste mouse não estiver sendo pressionado, diga não.
  Atribua a localização deste mouse a uma segunda localização.
  Obtenha um difference entre a segunda localização e a localização.
  Se a difference estiver within a malha, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se o mouse está em uma caixa:
  Se a localização deste mouse estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é um segundo número e uma string é uma segunda string:
  Se o número não for o segundo número, diga não.
  Se a string não for a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número está entre um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, diga não.
  Se o número for maior do que o terceiro número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é par:
  Se o número for ímpar, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é uniformemente divisível por um segundo número:
  Isole o número.
  Divida o número pelo segundo número usando um quociente e um resto.
  Se o resto for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é um múltiplo of um segundo número:
  Se o número for uniformemente divisível pelo segundo número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é negativo:
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um número é ímpar:
  Isole o número.
  Conjuncione logicamente o número com 1.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é positive:
  Se o número for menor do que 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um número é prime:
  Se o número for menor do que 2, diga não.
  Se o número for 2, diga sim.
  Atribua o número menos 1 a um segundo número.
  Percorra. [o código abaixo]
    Se o número é uniformemente divisível pelo segundo número, diga não.
    Subtraia 1 desde o segundo número.
    Se o segundo número for maior do que 1, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um segundo par de números:
  Se o número X deste par de números não for o número X deste segundo par de números, diga não.
  Se o número Y deste par de números não for o número Y deste segundo par de números, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um par de números é um número e um segundo número:
  Se o número X deste par de números não for o número, diga não.
  Se o número Y deste par de números não for o segundo número, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo é endereço da pasta-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste caractere final deste endereço completo for a barra invertida, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo é drive-format:
  Se o endereço completo começa com "\\", diga sim.
  Se a quantidade de caracteres deste endereço completo não for 3, diga não.
  Se o endereço completo termina com ":\", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo está vazia no sistema de arquivos;
Etapas para que se determine se um endereço completo estão vazias no sistema de arquivos;
Etapas para que se determine se um endereço completo estão vazios no sistema de arquivos;
Etapas para que se determine se um endereço completo está vazio no sistema de arquivos:
  Se o endereço completo não estiver no sistema de arquivos, diga sim.
  Obtenha uma contagem of items no endereço completo no sistema de arquivos.
  Se a contagem for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço completo é file-format:
  Se o endereço completo estiver em branco, diga não.
  Se o conteúdo deste caractere final deste endereço completo for o sinal de dois pontos, diga não.
  Se o conteúdo deste caractere final deste endereço completo for a barra invertida, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo está no sistema de arquivos:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesa
  \Obtém atributos do sistema de arquivos para um arquivo ou diretório especificado.
  \Para obter mais informações sobre o atributo obtido, use a função GetFileAttributesEx.
  \Os atributos de arquivo são valores de metadados armazenados pelo sistema de arquivos em disco 
  \e são usados pelo sistema e estão disponíveis para desenvolvedores por meio de várias APIs de E/S de arquivo.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo ou diretório.
    \Na versão ANSI desta função, o nome é limitado a MAX_PATH caracteres. 
    \Para estender esse limite para 32.767 caracteres largos, chame a versão Unicode da função (GetFileAttributesW) e acrescente "\\? \" Ao caminho. 
    \Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file
    \A partir do Windows 10, versão 1607, para a versão Unicode desta função (GetFileAttributesW), 
    \você pode optar por remover a limitação de caracteres MAX_PATH sem incluir "\\? \" No início.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno conterá os atributos do arquivo ou diretório especificado. 
    \Para obter uma lista de valores de atributo e suas descrições, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-attribute-constants
    \Se a função falhar, o valor de retorno é -1 (INVALID_FILE_ATTRIBUTES).
  Se o número for menor do que 0, diga não. \Acho que pode melhorar isso aqui
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço completo é somente leitura:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com  \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesa
  \Obtém atributos do sistema de arquivos para um arquivo ou diretório especificado.
  \Para obter mais informações sobre o atributo obtido, use a função GetFileAttributesEx.
  \Os atributos de arquivo são valores de metadados armazenados pelo sistema de arquivos em disco 
  \e são usados pelo sistema e estão disponíveis para desenvolvedores por meio de várias APIs de E/S de arquivo.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo ou diretório.
    \Na versão ANSI desta função, o nome é limitado a MAX_PATH caracteres. 
    \Para estender esse limite para 32.767 caracteres largos, chame a versão Unicode da função (GetFileAttributesW) e acrescente "\\? \" Ao caminho. 
    \Para obter mais informações, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file
    \A partir do Windows 10, versão 1607, para a versão Unicode desta função (GetFileAttributesW), 
    \você pode optar por remover a limitação de caracteres MAX_PATH sem incluir "\\? \" No início.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno conterá os atributos do arquivo ou diretório especificado. 
    \Para obter uma lista de valores de atributo e suas descrições, consulte https://docs.microsoft.com/en-us/windows/desktop/FileIO/file-attribute-constants
    \Se a função falhar, o valor de retorno é -1 (INVALID_FILE_ATTRIBUTES).
  Conjuncione logicamente o número com 1 [FILE_ATTRIBUTE_READONLY]. \Um arquivo que é somente leitura. 
  \Os aplicativos podem ler o arquivo, mas não podem gravá-lo ou excluí-lo. Este regra não é respeitada em diretórios, a não ser que sejam diretórios de sistema
  Se o número não for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um endereço de memória pode ser encontrado;
\Etapas para que se determine se um endereço de memória é encontrado;
Etapas para que se determine se um endereço de memória foi encontrado;
Etapas para que se determine se um endereço de memória existe:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um endereço de memória está sumido do mapa;
Etapas para que se determine se um endereço de memória é null e vazio:
  Se o endereço de memória for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um polígono está closed:
  Se o polígono for inexistente, diga não.
  Se a contagem destes vértices deste polígono for menor do que 3, diga não.
  Se a localização deste first vértice deste polígono for a localização deste last vértice deste polígono, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um reply é something like uma segunda reply:
  Isole o reply.
  Isole a segunda reply.
  Simplify o reply.
  Simplify a segunda reply.
  Se o reply é a segunda reply, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma row está em branco:
  Se a row for inexistente, diga sim.
  Lance um subtexto sobre a string deste row.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste caractere inicial deste subtexto não for irrelevante, diga não.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se uma row of um text está selecionado:
  Se o text for inexistente, diga não.
  Se a row for inexistente, diga não.
  Se nada estiver selecionado no text, diga não.
  Atribua a normalized seleção deste text a uma seleção.
  Se o número da linha desta row for menor do que o anchor número da linha desta seleção, diga não.
  Se o número da linha desta row for maior do que o número de linhas do cursor desta seleção, diga não.
  Se o número da linha desta row não for o número de linhas do cursor desta seleção, diga sim.
  Se o cursor de texto número de coluna desta seleção for 1, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma row of um text é visível:
  Se o text for inexistente, diga não.
  Se a row for inexistente, diga não.
  Obtenha uma caixa usando a row e o text.
  Atribua a caixa deste text a uma segunda caixa.
  Ajuste a segunda caixa usando 0 e a quantidade de twips/pixel e 0 e - a quantidade de twips/pixel .
  Se a caixa estiver tocando a segunda caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma seleção é uma segunda seleção:
  Se o anchor desta seleção não for o anchor desta segunda seleção, diga não.
  Se o cursor de texto desta seleção não for o cursor de texto desta segunda seleção, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se something está selecionado em um text:
  Se o anchor deste text for o cursor de texto deste text, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está acima of uma caixa:
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está acima of um horizontal linha reta:
  Se a coordenada Y desta localização for menor do que o horizontal y desta localização inicial desta linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está acima of ou debaixo of uma caixa:
  Se a localização está acima of a caixa, diga sim.
  Se a localização é debaixo of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é debaixo of uma caixa:
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é debaixo of um horizontal linha reta:
  Se a coordenada Y desta localização for maior do que o horizontal y desta localização inicial desta linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está em uma elipse:
  Crie um hRgn usando a elipse.
  Isole a localização.
  Divida a localização pelo quantidade de twips/pixel .
  Call "gdi32.dll" "PtInRegion" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-ptinregion
  \A função PtInRegion determina se o ponto especificado está dentro da região especificada.
    O hRgn [hrgn] \O número identificador da região a ser examinada.
    e A coordenada X desta localização [x] \Especifica a coordenada x do ponto em unidades lógicas.
    e A coordenada Y desta localização [y] \Especifica a coordenada y do ponto em unidades lógicas.
    devolvendo um número. \Se o ponto especificado estiver na região, o valor de retorno será diferente de zero.
  Destrua o hRgn.
  \Se o ponto especificado não estiver na região, o valor de retorno é zero.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em uma imagem:
  Se a imagem for inexistente, diga não.
  Se a localização estiver na caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está em um polígono:
  Se o polígono for inexistente, diga não.
  Crie uma série de vértices usando os vértices deste polígono.
  Call "gdi32.dll" "CreatePolygonRgn" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createpolypolygonrgn
  \A função CreatePolygonRgn cria uma região poligonal.
    O endereço de memória da localização desta série de vértices  [*pptl] \Um ponteiro para uma matriz de estruturas POINT que definem os vértices do polígono em unidades lógicas. 
   \O polígono é presumido como sendo um polígono fechado. Cada vértice pode ser especificado apenas uma vez.
    e A quantidade de vértices desta série de vértices [cPoint] \O número de pontos na matriz.
    e 2 [iMode = WINDING] \O modo de preenchimento usado para determinar quais pixels estão na região.  -> exemplo: https://docs.microsoft.com/en-us/windows/win32/gdi/images/csrgn-03.png
    \Este parâmetro pode ser um dos seguintes valores.
    \ ALTERNATE ou Seleciona o modo alternativo (preenche a área entre os lados ímpares e pares do polígono em cada linha de varredura).
    \WINDING = Seleciona o modo de enrolamento (preenche qualquer região com um valor de enrolamento diferente de zero).
    \Para obter mais informações sobre esses modos, consulte a função SetPolyFillMode, ou leia mais abaixo:    
    \Um aplicativo preenche o interior de uma região chamando a função FillRgn e fornecendo um identificador que identifica um pincel específico. 
    \Quando um aplicativo chama FillRgn, o sistema preenche a região com o pincel usando o modo de preenchimento atual para o contexto de dispositivo especificado. 
    \Existem dois modos de preenchimento: alternado e enrolamento. 
    \O aplicativo pode definir o modo de preenchimento para um contexto de dispositivo chamando a função SetPolyFillMode. 
    \O aplicativo pode recuperar o modo de preenchimento atual para um contexto de dispositivo chamando a função GetPolyFillMode.    
    \Modo Alternativo
    \Para determinar quais pixels o sistema destaca quando o modo alternativo é especificado, execute o seguinte teste:
    \Selecione um pixel no interior da região.
    \Desenhe um raio imaginário, na direção x positiva, desse pixel em direção ao infinito.
    \Cada vez que o raio cruza uma linha limite, aumente um valor de contagem.
    \O sistema destaca o pixel se o valor da contagem for um número ímpar.    
    \Modo de enrolamento
    \Para determinar quais pixels o sistema destaca quando o modo de enrolamento é especificado, execute o seguinte teste:
    \Determine a direção em que cada linha de limite é desenhada.
    \Selecione um pixel no interior da região.
    \Desenhe um raio imaginário, na direção x positiva, do pixel em direção ao infinito.
    \Cada vez que o raio intercepta uma linha limite com um componente y positivo, aumente um valor de contagem. 
    \Cada vez que o raio cruza uma linha limite com um componente y negativo, diminua o valor de contagem.
    \O sistema destaca o pixel se o valor da contagem for diferente de zero.
    devolvendo um hRgn. \Se a função for bem-sucedida, o valor de retorno será o número identificador da região.
    \Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "PtInRegion" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-ptinregion
  \A função PtInRegion determina se o ponto especificado está dentro da região especificada.
    O hRgn [hrgn] \O número identificador da região a ser examinada.
    e A coordenada X desta localização [x] \Especifica a coordenada x do ponto em unidades lógicas.
    e A coordenada Y desta localização [y] \Especifica a coordenada y do ponto em unidades lógicas.
    devolvendo um número. \Se o ponto especificado estiver na região, o valor de retorno será diferente de zero.
    \Se o ponto especificado não estiver na região, o valor de retorno é zero.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hRgn. [ho] \Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Destrua a série de vértices.
  \Se o identificador especificado não é válido ou está atualmente selecionado em um DC, o valor de retorno é zero.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em uns polígonos:
  Obtenha um polígono desde o polígonos.
  Se o polígono for inexistente, diga não.
  Se a localização estiver no polígono, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma localização está em uma caixa arredondada:
  Isole a caixa arredondada.
  Adicione a quantidade de twips/pixel para a canto inferior direito desta caixa arredondada.
  Atribua o raio desta caixa arredondada times 2 a um diameter número.
  Call "gdi32.dll" "CreateRoundRectRgn" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-createroundrectrgn
  \A função CreateRoundRectRgn cria uma região retangular com cantos arredondados.
    A coordenada X do canto superior esquerdo desta caixa arredondada [x1] \todas as coordenadas estão em unidades de dispositivo
    e A coordenada Y do canto superior esquerdo desta caixa arredondada [y2]
    e A coordenada X do canto inferior direito desta caixa arredondada [x2]
    e A coordenada Y do canto inferior direito desta caixa arredondada [y2]
    e O diameter [w] \Especifica a largura da elipse (em unidades de dispositivo) usada para criar os cantos arredondados .
    e O diameter [h] \Especifica a altura da elipse (em unidades de dispositivo) usada para criar os cantos arredondados .
    devolvendo um hRgn. \Se a função for bem-sucedida, o valor de retorno será o identificador para a região.
    \Se a função falhar, o valor de retorno será NULL.
  Call "gdi32.dll" "PtInRegion" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-ptinregion
  \A função PtInRegion determina se o ponto especificado está dentro da região especificada.
    O hRgn [hrgn] \O número identificador da região a ser examinada.
    e A coordenada X desta localização [x] \Especifica a coordenada x do ponto em unidades lógicas.
    e A coordenada Y desta localização [y] \Especifica a coordenada y do ponto em unidades lógicas.
    devolvendo um número. \Se o ponto especificado estiver na região, o valor de retorno será diferente de zero.
    \Se o ponto especificado estiver na região, o valor de retorno será diferente de zero.
    \Se o ponto especificado não estiver na região, o valor de retorno é zero.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hRgn. [ho] \Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está em um text:
  Se o text for inexistente, diga não.
  Se a localização estiver na caixa deste text, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está inside uma caixa;
Etapas para que se determine se uma localização está within uma caixa;
Etapas para que se determine se uma localização está em uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, diga não.
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga não.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, diga não.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está para o left of uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está left ou right of uma caixa:
  Se a localização é para o left of a caixa, diga sim.
  Se a localização é para o right of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está sobre uma caixa:
  Atribua a caixa a uma segunda caixa.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a segunda caixa usando o número.
  Se a localização não estiver no segunda caixa, diga não.
  Atribua a caixa a um terceiro caixa.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent o terceiro caixa usando o segundo número.
  Se a localização estiver no terceiro caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está sobre uma elipse:
  Atribua a elipse a uma segunda elipse.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a caixa desta segunda elipse usando o número.
  Se a localização não estiver na segunda elipse, diga não.
  Atribua a elipse a uma terceiro elipse.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent a caixa desta terceiro elipse usando o segundo número.
  Se a localização estiver na terceiro elipse, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização está sobre uma linha reta:
  Isole a linha reta.
  Atribua 3 times a quantidade de twips/pixel a um número.
  Percorra. [o código abaixo]
    Obtenha uma distance entre a localização e o center desta linha reta (chessboard).
    Se a distance for menor do que ou igual ao número, diga sim.
    Obtenha a distance entre a localização inicial desta linha reta e a localização final desta linha reta (chessboard).
    Se a distance for menor do que ou igual ao quantidade de twips/pixel , diga não.
    Separe a linha reta à linha reta e uma segunda linha reta.
    Obtenha a distance entre a localização e o center desta linha reta (chessboard).
    Obtenha uma segunda distance entre a localização e o center desta segunda linha reta (chessboard).
    Se a distance for maior do que a segunda distance, atribua a segunda linha reta ao linha reta.
  Repita. [o código acima]

Etapas para que se determine se uma localização está sobre uma imagem:
  Se a imagem for inexistente, diga não.
  Se a localização estiver sobre a caixa desta imagem, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está sobre um polígono:
  Se o polígono for inexistente, diga não.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, diga não.
    Se o next deste vértice for inexistente, diga não.
    Atribua a localização deste vértice e a localização deste next deste vértice a uma linha reta.
    Se a localização estiver sobre a linha reta, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma localização está sobre uma caixa arredondada:
  Atribua a caixa arredondada a uma segunda caixa arredondada.
  Atribua 2 times a quantidade de twips/pixel a um número.
  Outdent a segunda caixa arredondada usando o número.
  Se a localização não estiver no segunda caixa arredondada, diga não.
  Atribua a caixa arredondada a um terceiro caixa arredondada.
  Atribua 3 times a quantidade de twips/pixel a um segundo número.
  Indent o terceiro caixa arredondada usando o segundo número.
  Se a localização estiver no terceiro caixa arredondada, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é outside uma caixa:
  Se a localização é inside a caixa, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma localização é para o right of uma caixa:
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização é tocando uma caixa:
  Se a localização estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uma malha of uma segunda localização:
  Obtenha um difference entre a segunda localização e a localização.
  Se a difference está within a malha, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uns twips of uma segunda localização:
  Atribua os twips e os twips a uma malha.
  Se a localização estiver within a malha of a segunda localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma localização está within uns twips of uma caixa:
  Isole a caixa.
  Outdent a caixa usando os twips.
  Se a localização estiver within a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se o stack has just one coisa sobre it:
  Se a contagem deste stack for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se uma string does end com uma segunda string;
Etapas para que se determine se uma string termina com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o caractere final deste subtexto menos a quantidade de caracteres desta segunda string mais 1 ao caractere inicial deste subtexto.
  Se o subtexto for a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does start com uma segunda string;
Etapas para que se determine se uma string começa com uma segunda string:
  Se a quantidade de caracteres desta segunda string for maior do que a quantidade de caracteres desta string, diga não.
  Lance um subtexto sobre a string.
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao caractere final deste subtexto.
  Se o subtexto é a segunda string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does start com um pedaço;
Etapas para que se determine se uma string começa com um pedaço:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string does end com um pedaço; \ adicionado por Mike Gonta
Etapas para que se determine se uma string termina com um pedaço:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string for o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é uma segunda string (comparação de caracteres acentuados):
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos s/ acento ascii (equal only).

Etapas para que se determine se uma string é uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string e o tabela de caracteres minúsculos ascii (equal only).

Etapas para que se determine se uma string é uma segunda string ou um terceiro string:
  Se a string é a segunda string, diga sim.
  Se a string é o terceiro string, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de fração literal;
Etapas para que se determine se uma string é algum tipo de ratio literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Separe o subtexto a um numerador subtexto e um denominador subtexto usando o slash pedaço.
  Se o numerador subtexto não for algum tipo de integer literal, diga não.
  Se o denominador subtexto não for algum tipo de integer literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

\Etapas para que se determine se uma string é algum tipo de inteiro:
\ parece ser uma duplicata da rotina abaixo
\Lance um subtexto sobre a string.
\Se o subtexto estiver em branco, diga não.
\Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
\Se o subtexto estiver em branco, diga não.
\Percorra. [o código abaixo]
 \Se o conteúdo deste caractere inicial deste subtexto não for algum tipo de digit, diga não.
 \Adicione 1 para o caractere inicial deste subtexto.
\Se o subtexto estiver em branco, diga sim.
\Repita. [o código acima]

Etapas para que se determine se uma string é algum tipo de integer;
Etapas para que se determine se uma string é algum tipo de integer literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Percorra. [o código abaixo]
    Se o conteúdo deste caractere inicial deste subtexto não for algum tipo de digit, diga não.
    Adicione 1 para o caractere inicial deste subtexto.
    Se o subtexto estiver em branco, diga sim.
  Repita. [o código acima]

Etapas para que se determine se uma string é algum tipo de mixed literal:
  Lance um subtexto sobre a string.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste subtexto não for algum tipo de indicador numérico, diga não.
  Se o conteúdo deste caractere inicial deste subtexto for tipo de sinal aritmético, adicione 1 para o caractere inicial deste subtexto.
  Separe o subtexto a um integer subtexto e uma fração subtexto usando o hífem.
  Se o integer subtexto não for algum tipo de integer literal, diga não.
  Se a fração subtexto não for algum tipo de fração literal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum tipo de numeric literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string não for algum tipo de indicador numérico, diga não.
  Se a string é algum tipo de integer literal, diga sim.
  Se a string é algum tipo de fração literal, diga sim.
  Se a string é algum tipo de mixed literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é tipo de sinal aritmético:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string é tipo de sinal aritmético, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de palavra:
  Se a quantidade de caracteres desta string for menor do que 2, diga não.
  Lance um subtexto sobre a string.
  Subtraia 1 desde o caractere inicial deste subtexto.
  Percorra. [o código abaixo]
    Adicione 1 para o caractere inicial deste subtexto.
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste caractere inicial deste subtexto for algum tipo de letra, repita.
    Se o conteúdo deste caractere inicial deste subtexto for o single-quote pedaço, repita.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.



Etapas para que se determine se uma string é um pedaço:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string é o pedaço, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é dos-compatible:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string é o ponto final, diga não.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, diga sim.
    Se o conteúdo deste caractere inicial deste subtexto for o slash pedaço, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for a barra invertida, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o sinal de dois pontos, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o asterisco, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o ponto de interrogação, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for as aspas duplas, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o símbolo menor do que, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o símbolo maior do que, diga não.
    Se o conteúdo deste caractere inicial deste subtexto for o barra vertical, diga não.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se determine se uma string é maior que uma segunda string;
Etapas para que se determine se uma string é maior do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é maior do que ou igual para uma segunda string;
Etapas para que se determine se uma string é maior que ou igual para uma segunda string;
Etapas para que se determine se uma string é maior ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for maior do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string estiver em uma segunda string:
  Lance um subtexto sobre a segunda string.
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres desta string menos 1 ao caractere final deste subtexto.
  Percorra. [o código abaixo]
    Se o caractere final deste subtexto for maior do que o caractere final desta segunda string, diga não.
    Se o subtexto é a string, diga sim.
    Mova o subtexto usando 1.
  Repita. [o código acima]

Etapas para que se determine se uma string estiver em um catálogo:
  Se o catálogo for inexistente, diga não.
  Se a string estiver em branco, diga não.
  Encontre um refer usando a string e o catálogo.
  Se o refer for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é menor que uma segunda string;
Etapas para que se determine se uma string é menor do que uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é menor do que ou igual para uma segunda string;
Etapas para que se determine se uma string é menor que ou igual para uma segunda string;
Etapas para que se determine se uma string é menor ou igual para uma segunda string:
  Compare a string para a segunda string usando a quantidade de caracteres desta string e a quantidade de caracteres desta segunda string devolvendo um número.
  Se o número for menor do que ou igual para 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\ needs work por Spanish
Etapas para que se determine se uma string está escrito incorretamente:
  Se o dicionário léxico for inexistente, diga não.
  Se a string não for algum tipo de palavra, diga não.
  Isole a string.
  Se a string termina com "'s", remove os last dois pedaços desde a string.
  Se a string estiver no catálogo deste dicionário léxico, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é wider do que uma caixa:
  \ presume que a font esteja selecionada no memory canvas
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Obtenha uma largura usando a string e o memory canvas.
  Subtraia o abcA desde a largura.
  Subtraia o abcC desde a largura.
  Se a largura for maior do que a largura desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um subtexto está sobre alguma espécie de contração:
  Atribua o caractere inicial deste subtexto mais 1 a um endereço de memória do pedaço .
  Se o endereço de memória do pedaço for maior do que o caractere final deste subtexto, diga não.
  Se o conteúdo deste caractere inicial deste subtexto não for o single-quote pedaço, diga não.
  Se o conteúdo deste endereço de memória do pedaço não for algum tipo de letra, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um terminal está totalmente prenchido:
  Atribua a altura deste terminal dividido por 24 pixels a um número.
  Se a contagem destes quoras deste terminal for maior do que o número, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um text pode ser refeito:
  Se o text for inexistente, diga não.
  Se o last destes redos deste text for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um text pode ser desfeito:
  Se o text for inexistente, diga não.
  Se o last destes undos deste text for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um text foi alterado:
  Se o text for inexistente, diga não.
  Se o detector de alteração deste text estiver ativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe something para backspace em um text:
  Se o text for inexistente, diga não.
  Se something estiver selecionado no text, diga sim.
  Se o número de linhas do cursor deste text não for 1, diga sim.
  Se o cursor de texto número de coluna deste text não for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se existe something para remove em um text:
  Se o text for inexistente, diga não.
  Se something estiver selecionado no text, diga sim.
  Se o número de linhas do cursor deste text não for a contagem de linhas deste text, diga sim.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o cursor de texto número de coluna deste text não for a quantidade de caracteres desta string desta row, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se há text na área de transferência do Windows;
Etapas para que se determine se existe text sobre o área de transferência do Windows:
  Call "user32.dll" "IsClipboardFormatAvailable" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-isclipboardformatavailable
  \Determina se a área de transferência contém dados no formato especificado.
  1 [format = CF_TEXT]  \Um formato de área de transferência padrão ou registrado. 
  \Para obter uma descrição dos formatos padrão da área de transferência, consulte https://docs.microsoft.com/en-us/windows/win32/dataxchg/standard-clipboard-formats
  \CF_TEXT = Formato de texto. 
  \Cada linha termina com uma combinação de retorno de carro / avanço de linha (CR-LF). 
  \Um caractere nulo sinaliza o fim dos dados. 
  \Use este formato para texto ANSI.
    devolvendo um número.
    \Se o formato da área de transferência estiver disponível, o valor de retorno será diferente de zero.
    \Se o formato da área de transferência não estiver disponível, o valor de retorno será zero.
  Se o número for 0, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se umas coisas estão vazios;
Etapas para que se determine se umas coisas estão vazias;
Etapas para que se determine se umas coisas estão vazia;
Etapas para que se determine se uns coisas estão vazio:
  Se o first destas coisas for inexistente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um segmento inicial é numeric:
  Isole o segmento inicial.
  Remove algum tipo de leading noise desde o segmento inicial.
  Se o segmento inicial estiver em branco, diga não.
  Percorra. [o código abaixo]
    Obtenha um pedaço desde o segmento inicial.
    Se o pedaço não for algum tipo de digit, diga não.
    Se o segmento inicial estiver em branco, diga sim.
  Repita. [o código acima]

Etapas para que se determine se o usuário está clicking em umas choices;
Etapas para que se determine se o usuário has clicked em umas choices;
Etapas para que se determine se o usuário clicked em umas choices;
Etapas para que se determine se o usuário clicks em umas choices;
Etapas para que se determine se o usuário está clicking sobre umas choices;
Etapas para que se determine se o usuário has clicked sobre umas choices;
Etapas para que se determine se o usuário clicked sobre umas choices;
Etapas para que se determine se o usuário clicks sobre umas choices:
Etapas para que se determine se o usuário clickou sobre umas choices:
Etapas para que se determine se o usuário clicou sobre umas choices:
Etapas para que se determine se o usuário clickou em umas choices:
Etapas para que se determine se o usuário clicou em umas choices:
  Percorra. [o código abaixo]
  Se o botão esquerdo deste mouse não estiver para baixo, diga não.
  Encontre uma choice usando a localização deste mouse.
  Se a choice can't ser encontrado, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

  

Etapas para que se determine se we pode encontre um endereço de memória:
  \ deveria ser "can" not "ca", compilador bug
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we could encontre um endereço de memória:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we did encontre um endereço de memória:
  Se o endereço de memória for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se we're acima of uma caixa:
  Se a coordenada Y deste context for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're acima of uma coordenada:
  Se a coordenada Y deste context for menor do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're acima of um horizontal linha reta:
  Se a localização deste context está acima of o horizontal linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're acima of ou debaixo of uma caixa:
  Se a coordenada Y deste context for menor do que a coordenada Y do canto superior esquerdo desta caixa, diga sim.
  Se a coordenada Y deste context for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're acima of uma localização:
  Se a coordenada Y deste context for menor do que a coordenada Y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're debaixo of uma caixa:
  Se a coordenada Y deste context for maior do que a coordenada Y do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're debaixo of uma coordenada:
  Se a coordenada Y deste context for maior do que a coordenada, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're debaixo of um horizontal linha reta:
  Se a localização deste context é debaixo of o horizontal linha reta, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're debaixo of uma localização:
  Se a coordenada Y deste context for maior do que a coordenada Y desta localização, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're facing north:
  \ *** need east, south, west
  Normalize a orientação deste context.
  Se a orientação deste context for 0, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're left of uma caixa:
  Se a coordenada X deste context for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're left ou right of uma caixa:
  Se a coordenada X deste context for menor do que a coordenada X do canto superior esquerdo desta caixa, diga sim.
  Se a coordenada X deste context for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're outside uma caixa:
  Se a localização deste context é outside a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're right of uma caixa:
  Se a coordenada X deste context for maior do que a coordenada X do canto inferior direito desta caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're still em uma caixa;
Etapas para que se determine se we're em uma caixa:
  Se a localização deste context estiver na caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se we're within uns twips of uma caixa:
  Se a localização deste context está within os twips of a caixa, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se you feel like it:
  Escolha aleatoriamente um número entre 1 e 100.
  Se o número for menor do que 51, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se decifre um trecho usando uma passphrase string:
  \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie uma crypt session usando o passphrase.
  Se a crypt session for inexistente, cancele.
  Converta o trecho como uma cifra hexadecimal para um texto hexadecimal.
  Atribua a quantidade de caracteres deste texto hexadecimal a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptDecrypt" com \ https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptdecrypt
  \A função CryptDecrypt descriptografa os dados criptografados anteriormente usando a função CryptEncrypt.
  \Importante: Esta API está obsoleta. 
  \Softwares deveriam começar a usar APIs de criptografia de última geração. 
  \A Microsoft pode remover esta API em versões futuras.
    A hCryptKey desta crypt session [hKey] \Um identificador para a chave a ser usada para a descriptografia. 
    \Um aplicativo pode obter esse identificador usando a função CryptGenKey ou CryptImportKey.
    \ https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptgenkey
    \ https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey
    \Esta chave especifica o algoritmo de descriptografia a ser usado.
    e 0 [hHash] \Um identificador para um objeto hash. 
    \Se os dados devem ser descriptografados e hasheadps simultaneamente, um identificador para um objeto hash é passado neste parâmetro. 
    \O valor do hash é atualizado com o texto simples descriptografado. 
    \Esta opção é útil ao descriptografar e verificar uma assinatura simultaneamente.
    \Antes de chamar CryptDecrypt, o aplicativo deve obter um identificador para o objeto hash chamando a função CryptCreateHash. 
    \ https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptcreatehash
    \Depois que a descriptografia for concluída, o valor de hash pode ser obtido usando a função CryptGetHashParam, 
    \ https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptgethashparam
    \ele também pode ser assinado usando a função CryptSignHash 
    \ https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptsignhasha
    \ou pode ser usado para verificar uma assinatura digital usando a função CryptVerifySignature.
    \ https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptverifysignaturea
    \Se nenhum hash for feito, este parâmetro deve ser zero.
    e 1 [Final] \Um valor booleano que especifica se esta é a última seção de uma série que está sendo descriptografada. 
    \Este valor é TRUE se este for o último ou único bloco. Se este não for o último bloco, o valor é FALSE.
    e 0 [dwFlags] \ não define nenhuma opção
    e O caractere inicial deste texto hexadecimal [*pbData] \Um ponteiro para um buffer que contém os dados a serem descriptografados. 
    \Depois que a descriptografia foi executada, o texto simples é colocado de volta neste mesmo buffer.
    \O número de bytes criptografados neste buffer é especificado por pdwDataLen abaixo
    e O endereçamento deste quantidade de caracteres [*pdwDataLen] \Um ponteiro para um valor DWORD que indica o comprimento do buffer pbData. 
    \Antes de chamar essa função, o aplicativo de chamada define o valor DWORD como o número de bytes a serem descriptografados. 
    \Ao retornar, o valor DWORD contém o número de bytes do texto simples descriptografado.
    \Quando uma cifra de bloco é usada, esse comprimento de dados deve ser um múltiplo do tamanho do bloco, a menos que esta seja a seção final dos dados a ser descriptografada e o parâmetro Final seja TRUE.
    devolvendo um número resultante. \Se a função for bem-sucedida, ela retornará um valor diferente de zero (VERDADEIRO).
    \Se a função falhar, ele retornará zero (FALSO).
  Se o número resultante for 0, atribua "Ocorreu um erro ao tentar decifrar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
  Destrua o crypt session.
  Atribua o texto hexadecimal ao trecho.

O fonte padrão é uma font.

O default smtp server é "localhost".

Um degree é um número [cujos valores variam entre 0 até 359].

Um depth é uns twips.

Um description é uma string.

Etapas para que se desvencilhe-se de um text:
  Se o text for inexistente, cancele.
  Atribua o cursor de texto deste text ao anchor deste text.

Etapas para que se destrua um crypt session:
  Se o crypt session for inexistente, cancele.
  Call "advapi32.dll" "CryptDestroyKey" com \ https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptdestroykey
  \A função CryptDestroyKey libera o identificador referenciado pelo parâmetro hKey.
  \Se o identificador se referir a uma chave de sessão ou a uma chave pública que foi importada para o provedor de serviços de criptografia (CSP) por meio de CryptImportKey, 
  \essa função destrói a chave e libera a memória que a chave usou. 
  \Muitos CSPs sobrescrevem a memória onde a chave estava armazenada antes de liberá-la. 
  \No entanto, o par de chaves pública / privada subjacente não é destruído por esta função. Apenas o identificador é destruído.
    A hCryptKey desta crypt session.[hKey] \O número identificador da chave a ser destruída.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "advapi32.dll" "CryptDestroyHash" com \ https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptdestroyhash
  \A função CryptDestroyHash destrói o objeto hash referenciado pelo parâmetro hHash. 
  \Depois que um objeto hash é destruído, ele não pode mais ser usado.
 \Para ajudar a garantir a segurança, recomendamos que os objetos hash sejam destruídos depois de usados.
  \Importante: Esta API está obsoleta. O softwares deveriam começar a usar APIs de criptografia de última geração. A Microsoft pode remover esta API em versões futuras.
  \Quando um objeto hash é destruído, muitos CSPs sobrescrevem a memória no CSP onde o objeto hash foi mantido. A memória CSP é então liberada.
  \Deve haver uma correspondência um para um entre as chamadas para CryptCreateHash e CryptDestroyHash.
  \Todos os objetos hash que foram criados usando um CSP específico devem ser destruídos antes que o identificador CSP seja liberado com a função CryptReleaseContext.
    O hcrypthash desta crypt session. [hHash] \O identificador do objeto hash a ser destruído.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "advapi32.dll" "CryptReleaseContext" com \https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptreleasecontext
  \A função CryptReleaseContext libera o identificador de um provedor de serviços criptográficos (CSP) e um contêiner de chave. 
  \A cada chamada para esta função, a contagem de referência no CSP é reduzida em um. 
  \Quando a contagem de referência chega a zero, o contexto é totalmente liberado e não pode mais ser usado por nenhuma função no aplicativo.
  \Um aplicativo chama essa função após terminar o uso do CSP. 
  \Depois que essa função é chamada, o identificador CSP liberado não é mais válido. 
  \Esta função não destrói contêineres de chaves ou pares de chaves.
  \Importante: Esta API está obsoleta. O softwares deveriam começar a usar APIs de criptografia de última geração. A Microsoft pode remover esta API em versões futuras.
  \Depois que essa função for chamada, a sessão CSP é concluída e todas as chaves de sessão existentes e objetos hash criados usando o identificador hProv não são mais válidos. 
  \Na prática, todos esses objetos devem ser destruídos com chamadas para CryptDestroyKey e CryptDestroyHash antes de CryptReleaseContext ser chamado.
    O hCryptProv desta crypt session [hProv] \Identificador de um provedor de serviços criptográficos (CSP) criado por uma chamada para CryptAcquireContext.
    e 0. [dwFlags] \Reservado para uso futuro e deve ser zero. 
    \Se dwFlags não estiver definido como zero, esta função retornará FALSE, mas o CSP será liberado
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero (VERDADEIRO).
    \Se a função falhar, o valor de retorno é zero (FALSO)..
  Desaloque o crypt session.

Etapas para que se destrua um GpImage:
  Se o GpImage for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImage" com o GpImage. [*image]
  \GpImage é um ponteiro para o objeto Imagem que será descartado.
  \Geralmente refere-se a uma imagem criada pelas funções GdipLoadImageFromFile, GdipLoadImageFromStream e outras funções construtoras de imagem.
  \Obs: A função retorna o valor GpStatus, sendo que o valor 0 significa que função foi bem-sucedida.
  Esvazie o GpImage.

Etapas para que se destrua um GpImageAttributes:
  Se o GpImageAttributes for inexistente, cancele.
  Call "gdiplus.dll" "GdipDisposeImageAttributes" com o GpImageAttributes. [*imageattr]
  \GpImageAttributes é um ponteiro para o objeto ImageAttributes a ser descartado.
  \O Objeto ImageAttributes é retornado por uma das duas funções para criar objetos ImageAttributes .
  \Esta função destrói o objeto ImageAttributes e libera os recursos associados.
  \Cada chamada bem-sucedida para uma das duas funções para criar objetos ImageAttributes deve corresponder a uma chamada para essa função.
  \As funções para criar um ImageAttributes são as seguintes:
  \GdipCloneImageAttributes
  \GdipCreateImageAttributes
  \Obs: A função retorna o valor GpStatus, sendo que o valor 0 significa que função foi bem-sucedida.
  \Ou seja, se a função for bem-sucedida, ela retornará 0, que é uma constante da enumeração de status .
   \Se a função falhar, ela retornará um dos outros valores da enumeração de status .
  Esvazie o GpImageAttributes.

Etapas para que se destrua o hBrush of um canvas:
  Call "gdi32.dll" "SelectObject" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O null hBrush  [h] \O número identificador do objeto a ser selecionado.
    devolvendo um hBrush. \Se o objeto selecionado não for uma região e a função for bem-sucedida, o valor de retorno é um identificador para o objeto que está sendo substituído.
    \Se o objeto selecionado for uma região e a função for bem-sucedida, o valor de retorno será
    \1 (NULLREGION quando a região estiver vazia.)
    \2 (SIMPLEREGION - quando a região consistir em um único retângulo.)
    \3 (COMPLEXREGION - quando a região consistir em mais de um retângulo.)
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hBrush. \Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.

Etapas para que se destrua o número da fonte of um canvas:
  Call "gdi32.dll" "SelectObject" com  \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O null número da fonte [h] \O número identificador do objeto a ser selecionado.
    devolvendo um número da fonte.\Se o objeto selecionado não for uma região e a função for bem-sucedida, o valor de retorno é um identificador para o objeto que está sendo substituído.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O número da fonte.\Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.

Etapas para que se destrua o hPen of um canvas:
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O canvas [hDC] \Um identificador para o contexto do dispositivo.
    e O null hPen  [h] \O número identificador do objeto a ser selecionado.
    devolvendo um hPen.\Se o objeto selecionado não for uma região e a função for bem-sucedida, o valor de retorno é um identificador para o objeto que está sendo substituído.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hPen.\Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.

Etapas para que se destrua um hRgn:
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógica, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hRgn. [ho] \Um identificador para uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.

Etapas para que se destrua um catálogo:
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, pare.
    Destrua os refers deste bucket.
  Repita. [o código acima]
  Unassign o first bucket deste catálogo.
  Desaloque o catálogo.

Etapas para que se destrua um endereço completo no sistema de arquivos:
  Defina o endereço completo para read-write mode.
  Se o endereço completo é endereço da pasta-format, destrua o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, destrua o endereço completo no sistema de arquivos (arquivo).

Etapas para que se destrua um endereço completo no sistema de arquivos (pasta)[endereço]:
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for encontrado, pare.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Destrua a segunda endereço completo no sistema de arquivos.
    Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Repita. [o código acima]
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "RemoveDirectoryA" com \https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-removedirectorya
  \A função RemoveDirectoryA exclui um diretório vazio existente.
    O caractere inicial deste endereço completo [lpPathName] \O caminho do diretório a ser removido. 
    \Este caminho deve especificar um diretório vazio e o processo de chamada deve ter acesso de exclusão ao diretório.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, volte. \Se a função falhar, o valor de retorno é zero.
  Atribua "Erro. Não foi possível apagar a pasta '" junto com o endereço completo seguido de "'." ao erro do fluxo de entrada/saída.

Etapas para que se destrua uma endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "DeleteFileA" com \https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-deletefilea
  \A função DeleteFileA exclui um arquivo existente.
    O caractere inicial deste endereço completo [lpFileName] \O nome do arquivo a ser excluído.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, volte. \Se a função falhar, o valor de retorno é zero (0).
  Atribua "Erro. Não foi possível apagar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se destrua uma imagem:
  Se a imagem for inexistente, cancele.
  Destrua o gpBitmap desta imagem.
  Desaloque a imagem.

Etapas para que se destrua um socket: 
  Call "ws2_32.dll" "closesocket" com \https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-closesocket
  \A função closesocket fecha um socket existente.
    O socket.[s] \Um descritor que identifica o soquete a ser fechado.
  \Se nenhum erro ocorrer, closesocket retorna zero. 
  \Caso contrário, um valor de SOCKET_ERROR é retornado e um código de erro específico pode ser recuperado chamando WSAGetLastError.
  \A função closesocket fecha um socket. 
  \Use-o para liberar o descritor de soquete passado no parâmetro s. 
  \Observe que o descritor de socket passado no parâmetro s pode ser imediatamente reutilizado pelo sistema assim que a função closesocket for emitida. 
  \Como resultado, não é confiável esperar que referências adicionais ao descritor de soquete passado no parâmetro s falhem com o erro WSAENOTSOCK. 
  \Um cliente Winsock nunca deve emitir closesocket em s simultaneamente com outra chamada de função Winsock

Etapas para que se destrua um vértice usando um polígono:
  Se o vértice for inexistente, cancele.
  Se o polígono for inexistente, cancele.
  Isole o vértice.
  Remove o vértice desde os vértices deste polígono.
  Destrua o vértice.

Etapas para que se destrua uma requisição WinHTTP:
  Se a requisição WinHTTP for inexistente, cancele.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com \https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpclosehandle
  \A função WinHttpCloseHandle fecha um único identificador HINTERNET. 
  \O Microsoft Windows HTTP Services (WinHTTP) usa identificadores para controlar as configurações e as informações necessárias ao usar o protocolo HTTP. 
  \Cada identificador mantém informações pertinentes a uma sessão HTTP, uma conexão com um servidor HTTP ou um recurso específico.
  \Os identificadores criados e usados pelo WinHTTP são chamados de identificadores HINTERNET.
  \Para mais detalhes, consulte https://docs.microsoft.com/en-us/windows/win32/winhttp/hinternet-handles-in-winhttp
    O número identificador de requisição [hInternet] desta requisição WinHTTP. 
    \Um identificador HINTERNET válido a ser fechado.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com 
    O número identificador de conexão [hInternet] desta requisição WinHTTP.
  Call "WinHTTP.dll" "WinHttpCloseHandle" com 
    O número identificador de sessão [hInternet] deste número identificador de requisição desta requisição WinHTTP.
    \O valor de retorno da função WinHttpCloseHandle é TRUE se o identificador for fechado com sucesso, caso contrário é FALSE.
  Deallocate a requisição WinHTTP.

Uma difference é um par de números.

Um file é um número identificador.
Um nome do arquivo é uma string. \ é o nome que vem depois da barra / até o final da extensão. Exemplo: arquivo.txt
Um nome do arquivo s/ extensão é uma string. \ Auto explicativo. 
Um extensão é uma string. \ Contém o ponto. Exemplo: .txt
Um endereço da pasta é um endereço completo. \ Exemplo: c:\pasta1\pasta2\
Um endereço completo é uma string. \Endereço completo do arquivo. Exemplo: c:\pasta1\pasta2\arquivo.txt
Um nome do diretório é uma string. \ nome da pasta com a barra no final. Exemplo = pasta2\
Um designador é uma string. \  pode ser igual ao nome do diretório ou igual ao nome do arquivo, se houver
Um nome da pasta é uma string. \ nome da pasta sem a barra no final. Exemplo = pasta2
Um unidade de disco é uma string. \ Exemplo: c:\ ou  \\NomeDoPC\DiretórioCompartilhado\
Um unidade de rede é uma string. \ é basicamente a cópia da variável anterior. Nome diferente pra evitar confusão.
Um categoria da unidade de disco é uma string. \HD, Pen-drive, Disquete, DVD, etc
Um nome da unidade de disco é uma string.

Um distance é uns twips.

Etapas para que se divida uma fração por uma segunda fração:
  Isole a segunda fração.
  Flip a segunda fração.
  Multiplique a fração pela segunda fração.

Etapas para que se divida uma fração por um número:
  Multiplique o denominador desta fração pelo número.
  Reduza a fração.

Etapas para que se divida um número por um fração:
  Isole a fração.
  Flip a fração.
  Multiplique o número pela fração.

Etapas para que se divida um par de números por um segundo par de números:
  Divida o número X deste par de números pelo número X deste segundo par de números.
  Divida o número Y deste par de números pelo número Y deste segundo par de números.

Etapas para que se divida um par de números por um número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo número.

Etapas para que se divida um par de números por um número e um segundo número:
  Divida o número X deste par de números pelo número.
  Divida o número Y deste par de números pelo segundo número.

\Um DOCINFO é um conjunto com
\Um número denominado cbSize,
\Um endereço de memória denominado lpszDocName,
\Um endereço de memória denominado lpszoutput,
\Um endereço de memória denominado lpszdatadtype,
\Um número denominado fwtype.

Um dot é uma elipse.

Etapas para que se double um número:
  Adicione o número para o número.

Etapas para que se pinte e preencha uma caixa com uma cor:
  Pinte a caixa com a cor e a cor.

Etapas para que se pinte algum tipo de visível rows of um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver visível, repita.
    Pinte a row of o text.
  Repita. [o código acima]

Etapas para que se pinte algum tipo de visível rows of um text (editing):
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não for visível, repita.
    Pinte a row of o text (editing).
  Repita. [o código acima]

Etapas para que se pinte uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas para que se pinte uma caixa (focus style):
  Isole a caixa.
  Adicione a quantidade de twips/pixel para o canto inferior direito desta caixa.
  Call "gdi32.dll" "LPtoDP" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-lptodp
  \A função LPtoDP converte coordenadas lógicas em coordenadas de dispositivo. 
  \A conversão depende do modo de mapeamento do contexto do dispositivo, 
  \das configurações das origens e extensões da janela e da janela de visualização e da transformação do mundo.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e O endereçamento desta caixa [lppt] \Um ponteiro para uma matriz de estruturas POINT. 
    \ https://docs.microsoft.com/en-us/previous-versions/dd162805(v=vs.85)
    \As coordenadas x e y contidas em cada uma das estruturas POINT serão transformadas.
    e 2. [c] \O número de pontos na matriz.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
  Converta a cor branca para um código da cor. \ sugestões de termo: código de pigmento/tonalidade
  Call "gdi32.dll" "SetBkColor" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setbkcolor
  \A função SetBkColor define a cor de fundo atual para o valor da cor especificada 
  \ou para a cor física mais próxima se o dispositivo não puder representar o valor da cor especificada.
  \Esta função preenche as lacunas entre as linhas estilizadas desenhadas com uma caneta criada pela função CreatePen; 
  \ela não preenche as lacunas entre as linhas estilizadas desenhadas com uma caneta criada pela função ExtCreatePen. 
  \A função SetBkColor também define as cores de fundo para TextOut e ExtTextOut.
  \Se o modo de fundo for OPACO, a cor de fundo será usada para preencher as lacunas 
  \entre as linhas estilizadas, lacunas entre as linhas hachuradas em pincéis e células de caracteres. 
  \A cor de fundo também é usada ao converter bitmaps coloridos em monocromáticos e vice-versa.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e O código da cor. [color] \A nova cor de fundo. Para criar um valor COLORREF, use a macro RGB.
    \Se a função for bem-sucedida, o valor de retorno especifica a cor de fundo anterior como um valor COLORREF.
    \Se a função falhar, o valor de retorno é CLR_INVALID.
  Converta a cor preta para um segundo código da cor.
  Call "gdi32.dll" "SetTextColor" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-settextcolor
  \A função SetTextColor define a cor do texto para o contexto de dispositivo especificado para a cor especificada.
  \A cor do texto é usada para desenhar a face de cada caractere escrito pelas funções TextOut e ExtTextOut. 
  \A cor do texto também é usada na conversão de bitmaps coloridos em monocromáticos e vice-versa.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e O segundo código da cor. [color] \A cor do texto.
    \Se a função for bem-sucedida, o valor de retorno é uma referência de cor para a cor do texto anterior como um valor COLORREF.
    \Se a função falhar, o valor de retorno é CLR_INVALID.
  Call "gdi32.dll" "SetMapMode" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setmapmode
  \A função SetMapMode define o modo de mapeamento do contexto de dispositivo especificado. 
  \O modo de mapeamento define a unidade de medida usada para transformar unidades de espaço de página em unidades de espaço de dispositivo 
  \e também define a orientação dos eixos x e y do dispositivo.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e 1 [iMode = MM_TEXT]. \iMode refere-se ao novo modo de mapeamento. / o modo de mapeamento para o contexto de dispositivo do seu aplicativo
    \Com o valor MM_TEXT, cada unidade lógica é mapeada para um pixel de dispositivo. 
    \O modo MM_TEXT permite que os aplicativos funcionem em pixels de dispositivo, cujo tamanho varia de acordo com a resolução da tela/monitor
    \ x (positivo) fica à direita; y (positivo) fica embaixo.
    \Se a função for bem-sucedida, o valor de retorno identifica o modo de mapeamento anterior.
    \Se a função falhar, o valor de retorno é zero.
  Call "user32.dll" "DrawFocusRect" com \https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-drawfocusrect
  \A função DrawFocusRect desenha um retângulo estilizado. 
  \A estilização é utilizada para indicar que o retângulo está sob o foco atual.
    O quadro atual [hdc] \O número identificador do contexto do dispositivo.
    e O endereçamento desta caixa.[*lprc] \Um ponteiro para uma estrutura RECT que especifica as coordenadas lógicas do retângulo.
    \https://docs.microsoft.com/en-us/windows/win32/api/windef/ns-windef-rect
  Normalize o quadro atual.

\Etapas para que se pinte uma caixa de uma cor;
Etapas para que se pinte uma caixa em uma cor:
  Pinte a caixa com a cor [preenchimento] e a cor preta [borda].

Etapas para que se pinte o cursor de texto em um text:
\refere-se ao cursor de texto dos arquivos de texto
  Se o text for inexistente, cancele.
  Obtenha uma caixa por [para] o cursor de texto no text.
  Se a caixa não estiver tocando a caixa deste text, cancele.
  Atribua o canto superior esquerdo desta caixa e o canto inferior direito desta caixa a uma linha reta.
  Pinte a linha reta com a cor azul.

Etapas para que se pinte um círculo about uns twips wide;
Etapas para que se pinte um círculo usando uma largura;
Etapas para que se pinte um círculo uns twips em largura;
Etapas para que se pinte um círculo uns twips wide:
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o caminho.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Repita. [o código acima]

Etapas para que se pinte um círculo uns twips wide (backwards);
Etapas para que se pinte um círculo uns twips wide (counterclockwise):
  Atribua os twips times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o caminho.
    Adicione 1 para uma contagem. Se a contagem for 48, pare.
  Repita. [o código acima]

Etapas para que se pinte um console:
  Se o console for inexistente, cancele.
  Salve o quadro atual.
  Cubra somente fora de a caixa deste console .
  Pinte a caixa deste console com a cor da borda deste console e a cor de preenchimento deste console.
  Atribua a cor branca ao pincel cor deste text deste console.
  Pinte o text deste console.
  Restaure o quadro atual.

Etapas para que se pinte um dot uns twips wide sobre a localização atual com uma cor:
  Faça o dot os twips wide.
  Centralize o dot sobre a localização deste context.
  Pinte o dot com a cor.

Etapas para que se pinte um dot uns twips wide sobre uma localização com uma cor:
  Faça o dot os twips wide.
  Centralize o dot sobre a localização.
  Pinte o dot com a cor.

Etapas para que se pinte uma elipse:
  Pinte a elipse com a cor preta e a cor branca.

Etapas para que se pinte uma elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor e a cor preta.

Etapas para que se pinte uma elipse com uma cor:
  Pinte a elipse com a cor e a cor.

Etapas para que se pinte uma flecha estilizada uns twips long com uma cor:
  Atribua a cor à cor deste context.
  Salve o context.
  Pinte os twips.
  Dê meia volta.
  Mova os twips dividido por 8.
  Salve o context.
  Vire left 1/8 of o caminho.
  Pinte um spiral starting com os twips dividido por 4.
  Restaure o context.
  Vire right 1/8 of o caminho.
  Pinte uma segunda spiral backwards starting com os twips dividido por 4.
  Restaure o context.

Etapas para que se pinte um figura com uma cor:
  Pinte a figura com a cor e a cor preta.

Etapas para que se pinte um figura com uns sides about uns twips wide:
  Atribua 1 e o side contagem a um fração.
  Atribua os twips times o número pi dividido pelo sides a uma quantidade de caracteres do segmento.
  Se o sides são 4, atribua os twips times 7/8 ao quantidade de caracteres do segmento. \ what é this? ***
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire a fração.
    Adicione 1 para uma contagem. 
    Se a contagem for os sides, pare.
  Repita. [o código acima]

Etapas para que se pinte um figura com uns sides uns twips long;
Etapas para que se pinte um figura com uns sides e uns twips:
  Atribua 1 e o sides a um fração.
  Percorra. [o código abaixo]
    Pinte os twips.
    Vire a fração.
    Adicione 1 para uma contagem. Se a contagem é o sides, pare.
  Repita. [o código acima]

Etapas para que se pinte um figura com uns sides uns twips long using uma cor;
Etapas para que se pinte um figura com uns sides e uns twips using uma cor:
  Atribua a cor à cor deste context.
  Pinte a figura com o sides e os twips.

Etapas para que se pinte um half círculo about uns twips wide;
Etapas para que se pinte um half círculo usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o caminho.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Repita. [o código acima]

Etapas para que se pinte um half círculo usando um size (backwards);
Etapas para que se pinte um half círculo usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o caminho.
    Adicione 1 para uma contagem.
    Se a contagem for 24, cancele.
  Repita. [o código acima]

Etapas para que se pinte um hexagon usando um side quantidade de caracteres:
  Pinte o side quantidade de caracteres.
  Vire right 1/6 of o caminho.
  Adicione 1 para uma contagem. Se a contagem for 6, pare.
  Repita. [o código acima]

Etapas para que se pinte uma linha reta:
  Pinte a linha reta com a cor deste context.

Etapas para que se pinte uma linha reta around uns twips long; \ "around" é significante here
Etapas para que se pinte uma linha reta about uns twips long: \ "about" é significante here
  \ "about" é significant here
  Atribua os twips dividido por 2 a uns segunda twips.
  Escolha aleatoriamente uns terceiro twips entre os twips menos a segunda twips e os twips mais a segunda twips.
  Pinte a linha reta o terceiro twips long.

Etapas para que se pinte uma linha reta como tall como uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte a altura desta caixa.

Etapas para que se pinte uma linha reta como wide como uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte a largura desta caixa.

Etapas para que se pinte uma linha reta entre uns twips e uns segunda twips long;
Etapas para que se pinte uma linha reta entre uns twips para uns segunda twips long;
Etapas para que se pinte uma linha reta uns twips para uns segunda twips long:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte a linha reta o terceiro twips long.

Etapas para que se pinte uma linha reta uns twips long:
  \Aguarde pelo delay. ***
  Atribua a localização deste context ao localização inicial desta linha reta.
  Atribua a localização deste context ao localização final desta linha reta.
  Obtenha um deslocamento vertical e um deslocamento horizontal usando a orientação deste context.
  Adicione o deslocamento horizontal times os twips dividido por 10000 para a coordenada X desta localização final desta linha reta.
  Adicione o deslocamento vertical times os twips dividido por 10000 para a coordenada Y desta localização final desta linha reta.
  Atribua a localização final desta linha reta à localização deste context.
  Pinte a linha reta com a cor deste context.
  \Se o delay for positive, atualize o tela.

Etapas para que se pinte uma linha reta using uns twips como a quantidade de caracteres;
Etapas para que se pinte uma linha reta using uns twips pelo quantidade de caracteres:
  Pinte os twips.

Etapas para que se pinte uma linha reta com uma cor around uns twips long; \ "around" é significant here
Etapas para que se pinte uma linha reta com uma cor about uns twips long:\ "about" é significant here
  Atribua os twips dividido por 2 a uns segunda twips.
  Escolha aleatoriamente uns terceiro twips entre os twips menos a segunda twips e os twips mais a segunda twips.
  Pinte a linha reta com a cor o terceiro twips long.

Etapas para que se pinte uma linha reta com uma cor uns twips long:
  Atribua a cor à cor deste context.
  Atribua a localização deste context ao localização inicial desta linha reta.
  Pinte os twips.
  Atribua a localização deste context ao localização final desta linha reta.

Etapas para que se pinte uma linha reta com uma cor uns twips para uns segunda twips long:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte a linha reta com a cor o terceiro twips long.

Etapas para que se pinte um número em uma caixa com uma cor:
  Atribua o número a uma string.
  Pinte a string na caixa com a cor e "center".

Etapas para que se pinte only within uma caixa;
Etapas para que se pinte only inside uma caixa;
Etapas para que se pinte only em uma caixa;
Etapas para que se pinte only within uma caixa desde now on;
Etapas para que se pinte only inside uma caixa desde now on;
Etapas para que se pinte only em uma caixa desde now on;
Etapas para que se only pinte within uma caixa desde now on;
Etapas para que se only pinte inside uma caixa desde now on;
Etapas para que se only pinte em uma caixa desde now on;
Etapas para que se only pinte within uma caixa;
Etapas para que se only pinte inside uma caixa;
Etapas para que se only pinte em uma caixa;
Etapas para que se pinte within uma caixa only;
Etapas para que se pinte inside uma caixa only;
Etapas para que se pinte em uma caixa only;
Etapas para que se atribua masking tape all around uma caixa;
Etapas para que se atribua masking tape around uma caixa:
  \ note that this masks a cor da borda da caixa as well
  Isole a caixa.
  Indent a caixa 1 pixel.
  Cubra externamente a caixa.
  Atribua a original caixa à caixa deste context. \ *** original caixa ? ou indented one?

Etapas para que se pinte uma imagem sobre um gpGraphic sob uma coordenada X e uma coordenada Y:
  Se a imagem for inexistente, cancele.
  Se o grayscale detector desta imagem estiver ativo, crie um GpImageAttributes (escala de cinza).
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com 
  \Esta função pode ser usada para desenhar imagens com cores ou faixas de cores transparentes.
  \Observações: a parte da imagem de origem a ser desenhada é redimensionada para caber no retângulo.
    O gpGraphic [*graphics] \Identificador/Ponteiro para o objeto Graphics.
    e O gpBitmap desta imagem [*image] \Identificador/Ponteiro para um objeto Image que especifica a imagem de origem a ser desenhada.
    e A coordenada X [dstx] \especifica a coordenada x do canto superior esquerdo da área de desenho da imagem.
    e A coordenada Y [dsty] \especifica a coordenada y do canto superior esquerdo da área de desenho da imagem.
    e A largura desta caixa intacta desta imagem [dstwidth] \especifica a largura da área de desenho a ser desenhada.
    e A altura desta caixa intacta desta imagem [dstwidth] \especifica a altura da área de desenho
    e 0 [srcx] \Especifica a coordenada x do canto superior esquerdo da parte da imagem de origem a ser desenhada.
    e 0 [srcy] \Especifica a coordenada y do canto superior esquerdo da parte da imagem de origem a ser desenhada.
    e A largura deste gpBitmap desta imagem [srcwidth] \Especifica a largura da parte da imagem de origem a ser desenhada.
    e A altura deste gpBitmap desta imagem [srcheight] \Especifica a altura da parte da imagem de origem a ser desenhada.
    e 2 [srcUnit = UnitPixel] \Elemento da enumeração Unit que especifica a unidade de medida da imagem. O valor padrão é UnitPixel.
    \https://docs.microsoft.com/pt-br/windows/win32/api/gdiplusenums/ne-gdiplusenums-unit
    \A enumeração Unit especifica a unidade de medida para um determinado tipo de dados.
    \UnitPixel especifica que uma unidade tem 1 pixel.
    e O GpImageAttributes [imageAttributes] \Ponteiro para uma estrutura ImageAttributes que especifica os atributos de cor e tamanho da imagem a ser desenhada. 
    \O valor padrão é NULL.
    e nil [callback] \Método de retorno de chamada usado para cancelar o desenho em andamento. 
    \O valor padrão é NULL.
    e 0. [callbackData] \Ponteiro para dados adicionais usados pelo método especificado pelo parâmetro de retorno de chamada. 
    \O valor padrão é NULL.
    \Valor de retorno da função: retorna o valor GpStatus, sendo que o valor 0 significa que a função foi bem-sucedida.
  Se o GpImageAttributes não for inexistente, destrua o GpImageAttributes.

Etapas para que se pinte um polígono:
  Pinte o polígono com a cor preta e a cor branca.

Etapas para que se pinte um polígono com uma cor:
  Pinte o polígono com a cor e a cor.

Etapas para que se pinte um polígono com uma cor (border only):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hPen of o quadro atual usando a cor.
  Obtenha um vértice desde os vértices deste polígono.
  Se o vértice for inexistente, cancele.
  Call "gdi32.dll" "MoveToEx" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-movetoex
  \A função MoveToEx atualiza a posição atual para o ponto especificado e, opcionalmente, retorna a posição anterior.
    O quadro atual [hdc] \o número identificador do contexto do dispositivo.
    e A coordenada X deste vértice [x] \Especifica a coordenada x da nova posição, em unidades lógicas.
    e A coordenada Y deste vértice [y] \Especifica a coordenada y da nova posição, em unidades lógicas.
    e nil. [lppt] \Ponteiro para uma estrutura POINT que recebe a posição atual anterior. 
    \Se este parâmetro for um ponteiro NULL, a posição anterior não será retornada.
    \https://docs.microsoft.com/en-us/previous-versions/dd162805(v=vs.85)
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Percorra. [o código abaixo]
    Obtenha o vértice desde os vértices deste polígono.
    Se o vértice for inexistente, pare.
    Call "gdi32.dll" "LineTo" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-lineto
    \A função LineTo desenha uma linha da posição atual até, mas não incluindo, o ponto especificado.
    \A linha é desenhada usando a caneta atual e, se a caneta for uma caneta geométrica, o pincel atual.
    \Se LineTo for bem-sucedido, a posição atual será definida como o ponto final especificado.
      O quadro atual [hdc] \o número identificador do contexto do dispositivo.
      e A coordenada X deste vértice [x] \Especifica a coordenada x, em unidades lógicas, do ponto final da linha.
      e A coordenada Y deste vértice.[y] \Especifica a coordenada y, em unidades lógicas, do ponto final da linha.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Repita. [o código acima]
  Destrua o hPen of o quadro atual.
  Se a localização deste first destes vértices deste polígono for a localização deste last destes vértices deste polígono, cancele.
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setpixelv
  \A função SetPixelV define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada. 
  \O ponto deve estar na região de recorte e na parte visível da superfície do dispositivo.
  \Observação: Nem todos os dispositivos suportam a função SetPixelV. 
  \Para obter mais informações, consulte a descrição do recurso RC_BITBLT na função GetDeviceCaps.
  \SetPixelV é mais rápido do que SetPixel porque não precisa retornar o valor da cor do ponto realmente pintado.
    O quadro atual [hdc] \O identificador do contexto do dispositivo.
    e A coordenada X deste last destes vértices deste polígono [x] \A coordenada x, em unidades lógicas, do ponto a ser definido.
    e A coordenada Y deste last destes vértices deste polígono [y] \A coordenada y, em unidades lógicas, do ponto a ser definido.
    e O código da cor.[color] \A cor a ser usada para pintar o ponto. Para criar um valor de cor COLORREF, use a macro RGB.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.

Etapas para que se pinte um polígono com uma cor (apenas a cor de preenchimento):
  Se o polígono for inexistente, cancele.
  Se a cor estiver clear, cancele.
  Crie o hPen of o quadro atual usando a cor preta.
  Crie o hBrush of o quadro atual usando a cor.
  Call "gdi32.dll" "SetPolyFillMode" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setpolyfillmode
  \A função SetPolyFillMode define o modo de preenchimento do polígono para funções que preenchem polígonos.
    O quadro atual [hdc] \O identificador do contexto do dispositivo.
    e 2 [mode = WINDING].\O novo modo de preenchimento.
    \WINDING seleciona o modo de enrolamento (preenche qualquer região com um valor de enrolamento diferente de zero).
    \Em geral, os modos diferem apenas nos casos em que um polígono complexo e sobreposto deve ser preenchido
    \(por exemplo, um polígono de cinco lados que forma uma estrela de cinco pontas com um pentágono no centro). 
    \Nesses casos, o modo ALTERNATE preenche todas as outras regiões fechadas dentro do polígono (ou seja, as pontas da estrela), 
    \enquanto o modo WINDING preenche todas as regiões (ou seja, as pontas e o pentágono).
    \Quando o modo de preenchimento é ALTERNATIVO, o GDI preenche a área entre os lados ímpares e pares do polígono em cada linha de varredura. 
    \Ou seja, o GDI preenche a área entre o primeiro e o segundo lado, entre o terceiro e o quarto lado e assim por diante.
    \Quando o modo de preenchimento é WINDING, GDI preenche qualquer região que tenha um valor de enrolamento diferente de zero. 
    \Este valor é definido como o número de vezes que uma caneta usada para desenhar o polígono contornaria a região. 
    \A direção de cada aresta do polígono é importante.
    \O valor de retorno especifica o modo de preenchimento anterior. Se ocorrer um erro, o valor de retorno é zero.
  Crie uma série de vértices usando os vértices deste polígono.
  Call "gdi32.dll" "Polygon" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-polygon
  \A função Polygon desenha um polígono que consiste em dois ou mais vértices conectados por linhas retas. 
  \O polígono é delineado usando a caneta atual e preenchido usando o pincel atual e o modo de preenchimento de polígono.
    O quadro atual [hdc] \O identificador do contexto do dispositivo.
    e O endereço de memória da localização desta série de vértices [*apt] \Um ponteiro para uma matriz de estruturas POINT que especificam os vértices do polígono, em coordenadas lógicas.
    \https://docs.microsoft.com/en-us/previous-versions/dd162805(v=vs.85)
    e A quantidade de vértices desta série de vértices. [cpt] \O número de vértices na matriz. Este valor deve ser maior ou igual a 2.
  Destrua a série de vértices.
  Destrua o hBrush of o quadro atual.
  Destrua o hPen of o quadro atual.

Etapas para que se pinte um quadrante circular about uns twips wide;
Etapas para que se pinte um quadrante circular usando um size:
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire right 1/48 of o caminho.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Repita. [o código acima]

Etapas para que se pinte um quadrante circular entre uns twips e uns segunda twips wide:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Pinte um quadrante circular usando o terceiro twips.

Etapas para que se pinte um quadrante circular usando um size (counterclockwise):
  Atribua o size times o número pi dividido por 48 a uma quantidade de caracteres do segmento.
  Adicione 1 para a quantidade de caracteres do segmento.
  Percorra. [o código abaixo]
    Pinte a quantidade de caracteres do segmento.
    Vire left 1/48 of o caminho.
    Adicione 1 para uma contagem.
    Se a contagem for 12, cancele.
  Repita. [o código acima]

Etapas para que se pinte um retângulo uns twips por uns segunda twips;
Etapas para que se pinte um retângulo uns twips wide por uns segunda twips high:
  Pinte a segunda twips.
  Vire right.
  Pinte os twips.
  Vire right.
  Pinte a segunda twips.
  Vire right.
  Pinte os twips.
  Vire right.

Etapas para que se pinte uma caixa arredondada:
  Pinte a caixa arredondada com a cor preta e a cor branca.

Etapas para que se pinte uma caixa arredondada com uma cor:
  Pinte a caixa arredondada com a cor e a cor.

Etapas para que se pinte uma row of um text:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas para que se pinte uma row of um text (editing):
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Pinte a caixa de seleção pela row of o text.
  Obtenha uma caixa usando a row e o text.
  Pinte o working string desta row na caixa com o pincel deste text e a font deste text e o alinhamento deste text.

Etapas para que se pinte a caixa de seleção por uma row of um text:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Se a row of o text não estiver selecionado, cancele.
  Obtenha uma caixa de seleção usando a row e o text.
  Pinte a caixa de seleção com o cor hilite e o cor hilite.

Etapas para que se pinte um spiral backward usando uns twips;
Etapas para que se pinte um spiral backward starting com uns twips;
Etapas para que se pinte um spiral usando um size (backwards):
  Isole o size.
  Percorra. [o código abaixo]
    Pinte um half círculo usando o size (backwards).
    Divida o size por 2.
    Adicione 1 para uma contagem.
    Se a contagem for 5, pare.
  Repita. [o código acima]

Etapas para que se pinte um spiral starting com uns twips;
Etapas para que se pinte um spiral usando um size:
  Isole o size.
  Percorra. [o código abaixo]
    Pinte um half círculo usando o size.
    Divida o size por 2.
    Adicione 1 para uma contagem. 
    Se a contagem for 5, pare.
  Repita. [o código acima]

Etapas para que se pinte uma localização:
  Pinte a localização com a cor preta.

Etapas para que se pinte uma localização com uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetPixelV" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-setpixelv
  \A função SetPixelV define o pixel nas coordenadas especificadas para a aproximação mais próxima da cor especificada. 
  \O ponto deve estar na região de recorte e na parte visível da superfície do dispositivo.
  \Observação: Nem todos os dispositivos suportam a função SetPixelV. 
  \Para obter mais informações, consulte a descrição do recurso RC_BITBLT na função GetDeviceCaps.
  \SetPixelV é mais rápido do que SetPixel porque não precisa retornar o valor da cor do ponto realmente pintado.
    O quadro atual [hdc] \O identificador do contexto do dispositivo.
    e A coordenada X desta localização [x] \A coordenada x, em unidades lógicas, do ponto a ser definido.
    e A coordenada Y desta localização [y] \A coordenada y, em unidades lógicas, do ponto a ser definido.
    e O código da cor.\A cor a ser usada para pintar o ponto. Para criar um valor de cor COLORREF, use a macro RGB.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.

Etapas para que se pinte uma estrela usando uma point contagem e um size:
  Atribua 1 e a point contagem a um fração.
  Percorra. [o código abaixo]
    Vire right 1/48 of o caminho.
    Pinte o size.
    Dê meia volta.
    Vire left 1/24 of o caminho.
    Pinte o size.
    Dê meia volta.
    Vire right 1/48 of o caminho.
    Vire right a fração of o caminho.
    Adicione 1 para uma contagem. 
    Se a contagem for o point contagem, pare.
  Repita. [o código acima]

Etapas para que se pinte uma string sob o left of uma caixa:
  Pinte a string sob o left of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string sob o left of uma caixa com uma cor:
  Pinte a string sob o left of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string sob o left of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e a font e "left".

Etapas para que se pinte uma string sob o left of uma caixa com um font:
  Pinte a string sob o left of a caixa com a cor preta e a font.

Etapas para que se pinte uma string sob o right of uma caixa:
  Pinte a string sob o right of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string sob o right of uma caixa com uma cor:
  Pinte a string sob o right of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string sob o right of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e a font e "right".

Etapas para que se pinte uma string sob o right of uma caixa com um font:
  Pinte a string sob o right of a caixa com a cor preta e a font.

Etapas para que se pinte uma string sob uma localização com uma cor:
  Pinte a string sob a localização com a cor e a fonte padrão.

Etapas para que se pinte uma string em uma caixa:
  Pinte a string na caixa com a cor preta e a fonte padrão e "left".

Etapas para que se pinte uma string em uma caixa over um número com uma cor e uma font e um alinhamento:
  Isole a caixa.
  Se o alinhamento for "left", adicione o número para a coordenada X do canto superior esquerdo desta caixa.
  Se o alinhamento for "zquierda", adicione o número para a coordenada X do canto superior esquerdo desta caixa.
  Se o alinhamento for "derecho", subtraia o número desde a coordenada X do canto inferior direito desta caixa.
  Pinte a string na caixa com a cor e a font e o alinhamento.

Etapas para que se pinte uma string em uma caixa com um alinhamento:
  Pinte a string na caixa com a cor preta e a fonte padrão e o alinhamento.

Etapas para que se pinte uma string em uma caixa com uma cor:
  Pinte a string na caixa com a cor e a fonte padrão e "left".

Etapas para que se pinte uma string em uma caixa com uma cor e um alinhamento:
  Pinte a string na caixa com a cor e a fonte padrão e o alinhamento.

Etapas para que se pinte uma string em uma caixa com uma cor e uma font e um alinhamento:
  Obtenha um offset par de números usando a string e a caixa e a font e o alinhamento.
  Pinte a string sob o canto superior esquerdo desta caixa mais o offset par de números com a cor e a font.

Etapas para que se pinte uma string em uma caixa com uma font e um alinhamento:
  Pinte a string na caixa com a cor preta e a font e o alinhamento.

Etapas para que se pinte uma string no center of uma caixa:
  Pinte a string no center of a caixa com a cor preta e a fonte padrão.

Etapas para que se pinte uma string no center of uma caixa com uma cor:
  Pinte a string no center of a caixa com a cor e a fonte padrão.

Etapas para que se pinte uma string no center of uma caixa com uma cor e um font:
  Pinte a string na caixa com a cor e a font e "center".

Etapas para que se pinte uma string no center of uma caixa com um font:
  Pinte a string no center of a caixa com a cor preta e a font.

Etapas para que se pinte um terminal:
  Se o terminal for inexistente, cancele.
  Salve o quadro atual.
  Cubra somente fora de a caixa deste terminal.
  Pinte e preencha a caixa deste terminal com a cor preta.
  Escreva os quoras deste terminal na caixa deste terminal.
  Restaure o quadro atual.

Etapas para que se pinte um text:
  Se o text for inexistente, cancele.
  Salve o quadro atual.
  Cubra externamente a caixa deste text.
  Pinte algum tipo de visível rows of o text.
  Restaure o quadro atual.

Etapas para que se pinte um text (editing):
  Se o text for inexistente, cancele.
  Salve o quadro atual.
  Cubra externamente a caixa deste text.
  Pinte algum tipo de visível rows of o text (editing).
  Pinte o cursor de texto no text.
  Restaure o quadro atual.

Etapas para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos:
  Se o endereço completo é endereço da pasta-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo é file-format, duplicate o endereço completo para a segunda endereço completo no sistema de arquivos (arquivo).

Etapas para que se duplicate um endereço completo para uma segunda endereço completo no sistema de arquivos (pasta)[endereço]:
  Se o endereço completo estiver no segunda endereço completo, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de ". - erro de recursão inválida." ao erro do fluxo de entrada/saída; volte.
  Se o endereço completo não estiver no sistema de arquivos, atribua "Ocorreu um erro na hora de duplicar a pasta: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; volte.
  Se a segunda endereço completo não estiver no sistema de arquivos, crie a segunda endereço completo no sistema de arquivos.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for encontrado, cancele.
    Atribua o endereço completo a um terceiro endereço completo.
    Posponha o designador deste item para o terceiro endereço completo.
    Atribua a segunda endereço completo a um quarto endereço completo.
    Posponha o designador deste item para o quarto endereço completo.
    Duplicate o terceiro endereço completo para o quarto endereço completo no sistema de arquivos.
  Repita. [o código acima]

Etapas para que se duplicate um endereço completo para um segundo endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Isole o segundo endereço completo.
  Termine com o caractere NULL o segundo endereço completo.
  Call "kernel32.dll" "CopyFileA" com \https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-copyfilea
  \A função CopyFileA copia um arquivo existente para um novo arquivo.
    O caractere inicial deste endereço completo [lpExistingFileName] \ O nome de um arquivo existente.
    e O caractere inicial deste segundo endereço completo [lpNewFileName] \ O nome do novo arquivo.
    e 0 [bFailIfExists] \Se este parâmetro for TRUE e o novo arquivo especificado por lpNewFileName já existir, a função falhará. 
    \Se este parâmetro for FALSE e o novo arquivo já existir, a função sobrescreve o arquivo existente e é bem-sucedida.
    devolvendo um número. \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, defina o endereço completo para read-write mode; volte. \Se a função falhar, o valor de retorno é zero.
  Atribua "Ocorreu um erro na hora de duplicar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Uma elipse é um conjunto com uma caixa.

Um email é um conjunto com
  Um smtp server,
  Um sender,
  Um recipient,
  Um subject,
  Uma message.

Etapas para que se encrypt um trecho usando um passphrase string:
  \ sets erro do fluxo de entrada/saída if failure
  Limpe o erro do fluxo de entrada/saída.
  Crie um crypt session usando o passphrase.
  Se o crypt session for inexistente, cancele.
  Atribua o trecho a um temp trecho.
  Atribua a quantidade de caracteres deste temp trecho a uma quantidade de caracteres.
  Call "advapi32.dll" "CryptEncrypt" com \https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptencrypt
  \A função CryptEncrypt criptografa os dados. 
  \O algoritmo usado para criptografar os dados é designado pela chave mantida pelo módulo CSP e é referenciado pelo parâmetro hKey
  \Importante Esta API está obsoleta. 
  \O software novo e o existente devem começar a usar APIs de criptografia de última geração. 
  \A Microsoft pode remover esta API em versões futuras.
    A hCryptKey desta crypt session [hKey] \o número identificador da chave de criptografia. 
    \Um aplicativo obtém esse identificador usando a função CryptGenKey ou CryptImportKey.
    \A chave especifica o algoritmo de criptografia usado.
    e 0 [hHash] \Um identificador para um objeto hash. 
    \Se os dados tiverem que ser criptografados e criptografados simultaneamente, um identificador para um objeto hash pode ser passado no parâmetro hHash. 
    \O valor hash é atualizado com o texto simples passado. Esta opção é útil ao gerar texto assinado e criptografado.
    \Antes de chamar CryptEncrypt, o aplicativo deve obter um identificador para o objeto hash chamando a função CryptCreateHash. 
    \Depois que a criptografia for concluída, o valor do hash pode ser obtido usando a função CryptGetHashParam 
    \ou o hash pode ser assinado usando a função CryptSignHash.
    \Se nenhum hash deve ser feito, este parâmetro deve ser NULL.
    e 1 [Final] \Um valor booleano que especifica se esta é a última seção de uma série que está sendo criptografada. 
    \Final é definido como TRUE para o último ou único bloco e como FALSE se houver mais blocos a serem criptografados.
    e 0 [dwFlags] \reservado para uso futuro
    e O caractere inicial deste temp trecho [*pbData] \Um ponteiro para um buffer que contém o texto simples a ser criptografado. 
    \O texto simples neste buffer é substituído pelo texto cifrado criado por esta função.
    \O parâmetro pdwDataLen aponta para uma variável que contém o comprimento, em bytes, do texto simples. 
    \O parâmetro dwBufLen contém o tamanho total, em bytes, desse buffer.
    \Se este parâmetro contiver NULL, esta função calculará o tamanho necessário para o texto cifrado e o colocará no valor apontado pelo parâmetro pdwDataLen.
    e O endereçamento deste quantidade de caracteres [*pdwDataLen] \Um ponteiro para um valor DWORD que, na entrada, contém o comprimento, em bytes, do texto sem formatação no buffer pbData. 
    \Na saída, este DWORD contém o comprimento, em bytes, do texto cifrado gravado no buffer pbData.
    \Se o buffer alocado para pbData não for grande o suficiente para conter os dados criptografados, 
    \GetLastError retorna ERROR_MORE_DATA e armazena o tamanho do buffer necessário, em bytes, no valor DWORD apontado por pdwDataLen.
    \Se pbData for NULL, nenhum erro será retornado e a função armazenará o tamanho dos dados criptografados, em bytes, no valor DWORD apontado por pdwDataLen. 
    \Isso permite que um aplicativo determine o tamanho correto do buffer.
    \Quando uma cifra de bloco é usada, esse comprimento de dados deve ser um múltiplo do tamanho do bloco, 
    \a menos que esta seja a seção final dos dados a serem criptografados e o parâmetro Final seja TRUE.
    e A quantidade de caracteres [dwBufLen] \Especifica o tamanho total, em bytes, do buffer pbData de entrada.
    \Observe que, dependendo do algoritmo usado, o texto criptografado pode ser maior do que o texto simples original. 
    \Nesse caso, o buffer pbData precisa ser grande o suficiente para conter o texto criptografado e qualquer preenchimento.
    \Como regra, se uma cifra de fluxo for usada, o texto cifrado terá o mesmo tamanho do texto simples. 
    \Se uma cifra de bloco for usada, o texto cifrado terá um comprimento de bloco maior do que o texto simples.
    devolvendo um número resultante. \Se a função for bem-sucedida, ela retornará um valor diferente de zero (VERDADEIRO).
    \Se a função falhar, ele retornará zero (FALSO).
  Se o número resultante for 0, atribua "Ocorreu um erro ao criptografar os dados." ao erro do fluxo de entrada/saída; destrua o crypt session; volte.
  \Se uma grande quantidade de dados deve ser criptografada, isso pode ser feito em seções chamando CryptEncrypt repetidamente. 
  \O parâmetro Final deve ser definido como TRUE na última chamada para CryptEncrypt, 
  \para que o mecanismo de criptografia possa terminar corretamente o processo de criptografia.
  Destrua o crypt session.
  Converta o temp trecho para uma cifra hexadecimal.
  Atribua a cifra hexadecimal ao trecho.

Etapas para que se enlarge uma caixa por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta caixa.
  Adicione os twips para o canto inferior direito desta caixa.

Etapas para que se enlarge uma elipse por uns twips:
  Subtraia os twips desde o canto superior esquerdo desta elipse.
  Adicione os twips para o canto inferior direito desta elipse.

Etapas para que se enfileire um event:
  Posponha o event para a fila de eventos.

Etapas para que se erase o insides of uma caixa;
Etapas para que se erase inside uma caixa;
Etapas para que se limpe inside uma caixa:
  Pinte a caixa com a cor preta e a cor branca.

Etapas para que se estime um deslocamento vertical e um deslocamento horizontal usando uma orientação:
  Atribua a orientação a uma low orientação.
  Arredonde a low orientação para baixo para o múltiplo imediato of 20.
  Obtenha um low deslocamento vertical e um low deslocamento horizontal usando a low orientação.
  Atribua a orientação a um high orientação.
  Arredonde o high orientação para cima para o múltiplo imediato of 20.
  Obtenha um high deslocamento vertical e um high deslocamento horizontal usando o high orientação.
  Atribua o low deslocamento vertical mais o high deslocamento vertical dividido por 2 ao deslocamento vertical.
  Atribua o low deslocamento horizontal mais o high deslocamento horizontal dividido por 2 ao deslocamento horizontal.

A fila de eventos é uma fila de eventos.

Uma fila de eventos é uns events.

Etapas para que se extend algum tipo de seleção em um text usando uma localização:
  Se o text for inexistente, cancele.
  Obtenha o cursor de texto deste text usando a localização e o text.
  Limpe a última operação deste text.

Etapas para que se extend uma caixa para include uma segunda caixa:
  Se a coordenada X do canto superior esquerdo desta segunda caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua a coordenada X do canto superior esquerdo desta segunda caixa à coordenada X do canto superior esquerdo desta caixa.
  Se a coordenada Y do canto superior esquerdo desta segunda caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua a coordenada Y do canto superior esquerdo desta segunda caixa à coordenada Y do canto superior esquerdo desta caixa.
  Se a coordenada X do canto inferior direito desta segunda caixa for maior do que a coordenada X do canto inferior direito desta caixa, atribua a coordenada X do canto inferior direito desta segunda caixa à coordenada X do canto inferior direito desta caixa.
  Se a coordenada Y do canto inferior direito desta segunda caixa for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta caixa.

Some extra points são uns points.

Etapas para que se extraia um designador desde um endereço completo:
  Limpe o designador.
  Extraia um unidade de disco desde o endereço completo.
  Lance um endereço completo subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o caractere inicial deste endereço completo subtexto.
  Se o endereço completo subtexto estiver em branco, atribua o unidade de disco ao designador; volte.
  Lance um subtexto sobre o last pedaço of o endereço completo subtexto.
  Se o conteúdo deste caractere inicial deste subtexto for a barra invertida, subtraia 1 desde o caractere inicial deste subtexto.
  Percorra. [o código abaixo]
    Se o caractere inicial deste subtexto for menor do que o caractere inicial deste endereço completo subtexto, pare.
    Se o conteúdo deste caractere inicial deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o caractere inicial deste subtexto.
  Repita. [o código acima]
  Adicione 1 para o caractere inicial deste subtexto.
  Atribua o subtexto ao designador.

Etapas para que se extraia um endereço da pasta desde um endereço completo:
  Limpe o endereço da pasta.
  Extraia um unidade de disco desde o endereço completo.
  Se o unidade de disco estiver em branco, cancele.
  Lance um subtexto sobre o endereço completo.
  Adicione a quantidade de caracteres desta unidade de disco para o caractere inicial deste subtexto.
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere final deste subtexto for a barra invertida, subtraia 1 desde o caractere final deste subtexto.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Se o conteúdo deste caractere final deste subtexto for a barra invertida, pare.
    Subtraia 1 desde o caractere final deste subtexto.
  Repita. [o código acima]
  Atribua a unidade de disco junto com o subtexto ao endereço da pasta.

Etapas para que se extraia um nome do diretório desde um endereço completo:
  Limpe o nome do diretório.
  Se o endereço completo não for endereço da pasta-format, cancele.
  Extraia o nome do diretório como um designador desde o endereço completo.

Etapas para que se extraia um nome da pasta desde um endereço completo:
  Extraia o nome da pasta como um nome do diretório desde o endereço completo.
  Se o nome da pasta estiver em branco, cancele.
  Remove o last pedaço desde o nome da pasta.

Etapas para que se extraia um unidade de disco desde um endereço completo:
  Limpe o unidade de disco.
  Se a quantidade de caracteres deste endereço completo for menor do que 3, cancele.
  Lance um subtexto sobre o first pedaço of o endereço completo.
  Adicione 2 para o caractere final deste subtexto.
  Se o subtexto termina com ":\", atribua o subtexto ao unidade de disco; volte.
  Se o subtexto não começa com "\\", cancele.
  Lance o subtexto sobre o first pedaço of o endereço completo.
  Percorra. [o código abaixo]
    Se o caractere final deste subtexto for maior do que o caractere final deste endereço completo, cancele.
    Se o conteúdo deste caractere final deste subtexto for a barra invertida, adicione 1 para uma contagem.
    Se a contagem for 4, pare. \ "\\computer\share\"
    Adicione 1 para o caractere final deste subtexto.
  Repita. [o código acima]
  Atribua o subtexto ao unidade de disco.

Etapas para que se extraia um extensão desde um endereço completo:
  Limpe o extensão.
  Se o endereço completo estiver em branco, cancele.
  Lance um subtexto sobre o last pedaço of o endereço completo.
  Percorra. [o código abaixo]
    Se o caractere inicial deste subtexto for menor do que o caractere inicial deste endereço completo, cancele.
    Se o conteúdo deste caractere inicial deste subtexto for o sinal de dois pontos, cancele.
    Se o conteúdo deste caractere inicial deste subtexto for a barra invertida, cancele.
    Se o conteúdo deste caractere inicial deste subtexto for o ponto final, pare.
    Subtraia 1 desde o caractere inicial deste subtexto.
  Repita. [o código acima]
  Atribua o subtexto ao extensão.

Etapas para que se extraia um nome do arquivo desde um endereço completo:
  Limpe o nome do arquivo.
  Se o endereço completo não for file-format, cancele.
  Extraia o nome do arquivo como um designador desde o endereço completo.

Etapas para que se extraia um nome do arquivo s/ extensão desde um endereço completo:
  Extraia o nome do arquivo s/ extensão como um nome do arquivo desde o endereço completo.
  Extraia um extensão desde o endereço completo.
  Remove trailing pedaços desde o nome do arquivo s/ extensão usando a quantidade de caracteres desta extensão.

Etapas para que se extraia uma imagem usando uma caixa:
  Atribua a largura desta caixa dividido pelo quantidade de twips/pixel a uma largura.
  Atribua a altura desta caixa dividido pelo quantidade de twips/pixel a uma altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
    A largura [width] \Valor inteiro longo que especifica a largura, em pixels, do bitmap.
    e A altura [height] \ especifica a altura, em pixels, do bitmap.
    e 0 [stride] \especifica o deslocamento de byte entre o início de uma linha de varredura e a próxima. 
    \Isso é geralmente (mas não necessariamente) o número de bytes no formato de pixel (por exemplo, 2 para 16 bits por pixel) multiplicado pela largura do bitmap. 
    \O valor passado para este parâmetro deve ser um múltiplo de quatro.
    e 137224 [format = PixelFormat24bppRGB] \Especifica o formato de pixel do bitmap. 
    \PixelFormat24bppRGB Especifica que o formato é de 24 bits por pixel; 8 bits cada são usados para os componentes vermelho, verde e azul.
    e 0 [scan0] \O parâmetro scan0 é tratado como uma matriz de bytes. Ponteiro para uma matriz de bytes que contém os dados de pixel. 
    \O chamador é responsável por alocar e liberar o bloco de memória apontado por este parâmetro.
    e O endereçamento desse gpBitmap. [*bitmap] \Ponteiro para uma variável DWORD que recives um ponteiro para um objeto Bitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
  \Esta função é usada para criar um objeto Graphics associado a um objeto de imagem.
  \A função falhará se a imagem for baseada em um metarquivo que foi aberto para leitura
  \(com as funções GdipLoadImageFromFile, GdipLoadImageFromFileICM, GdipCreateMetafileFromFile, GdipCreateMetafileFromWmfFile). 
  \Para abrir um metarquivo para escrita, use funções em metarquivos que usam um identificador de contexto de dispositivo (hdc).
  \A função também falhará se a imagem usar um dos seguintes formatos de pixel:
    \#PixelFormatUndefined
    \# PixelFormatDontCare
    \# PixelFormat1bppIndexed
    \# PixelFormat4bppIndexed
    \# PixelFormat8bppIndexed
    \# PixelFormat16bppGrayScale
    \# PixelFormat16bppARGB1555
    O gpBitmap [*image] \Ponteiro para um objeto de imagem que será associado ao novo objeto *graphics.
    e O endereçamento desse gpGraphic. [**graphics] \Ponteiro para uma variável que recebe um ponteiro para o novo objeto Graphics.
    \*graphics receberá um ponteiro para um objeto Graphics associado à imagem.
    \Se a função for bem-sucedida, ela retornará #Ok, que é uma constante da enumeração de status.
    \Se a função falhar, ela retornará um dos outros valores da enumeração de status.
  Call "gdiplus.dll" "GdipGetDC" com 
  \Esta função é usada para encontrar o identificador do contexto do dispositivo associado ao gráfico.
    O gpGraphic [graphics] \Identificador para um objeto Graphics criado pelas funções GdipCreateFromHDC, 
    \GdipCreateFromHDC2, GdipCreateFromHWND ou GdipGetImageGraphicsContext.
    e O endereçamento desse bitmap canvas.[hdc] \Identificador do contexto de dispositivo associado a este objeto Graphics
    \Cada chamada para a função GdipGetDC deve ser emparelhada com uma chamada para a função GdipReleaseDC. 
    \Não chame nenhuma função Graphics entre as chamadas para GdipGetDC e GdipReleaseDC. 
    \Se você tentar chamar uma função Graphics entre GdipGetDC e GdipReleaseDC, o método falhará e retornará ObjectBusy.
    \Quaisquer alterações de estado feitas no contexto do dispositivo entre GdipGetDC e GdipReleaseDC serão ignoradas pelo GDI + 
    \e não serão refletidas na renderização feita pelo GDI +.
    \Se a função for bem-sucedida, ela retornará 0, que é uma constante da enumeração de status.
    \Se a função falhar, ela retornará um dos outros valores da enumeração de status.
  Normalize o bitmap canvas.
  Call "gdi32.dll" "BitBlt" com \https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt
  \A função BitBlt executa uma transferência de bloco de bits dos dados de cor 
  \correspondentes a um retângulo de pixels do contexto de dispositivo de origem especificado 
  \para um contexto de dispositivo de destino.
  \BitBlt só faz recorte no controlador de domínio de destino.
  \Se uma rotação ou transformação de cisalhamento estiver em vigor no contexto do dispositivo de origem, BitBlt retornará um erro. 
  \Se outras transformações existirem no contexto do dispositivo de origem
   \(e uma transformação correspondente não estiver em vigor no contexto do dispositivo de destino), 
   \o retângulo no contexto do dispositivo de destino será esticado, compactado ou girado, conforme necessário.
   \Se os formatos de cor dos contextos de dispositivo de origem e destino não corresponderem, a função 
   \BitBlt converte o formato de cor de origem para corresponder ao formato de destino.
   \Quando um metarquivo avançado está sendo gravado, 
   \ocorre um erro se o contexto do dispositivo de origem identifica um contexto de dispositivo de metarquivo avançado.
    O bitmap canvas [hdc] \Um identificador para o contexto do dispositivo de destino.
    e 0 [x] \A coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de destino.
    e 0 [y] \A coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de destino.
    e A largura desta caixa [cx] \A largura, em unidades lógicas, dos retângulos de origem e destino.
    e A altura desta caixa [cy] \A altura, em unidades lógicas, dos retângulos de origem e destino.
   e o quadro atual  [hdcSrc] \Um identificador para o contexto do dispositivo de origem.
   e a coordenada X do canto superior esquerdo desta caixa [x1] \A coordenada x, em unidades lógicas, do canto superior esquerdo do retângulo de origem.
   e a coordenada Y do canto superior esquerdo desta caixa [y1] \A coordenada y, em unidades lógicas, do canto superior esquerdo do retângulo de origem.
   e 13369376 [rop = SRCCOPY]. \Um código de operação de varredura. 
   \Esses códigos definem como os dados de cor do retângulo de origem devem ser combinados com os dados de cor do retângulo de destino para obter a cor final.
   \SRCCOPY = Copia o retângulo de origem diretamente para o retângulo de destino.
   \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
   \Se a função falhar, o valor de retorno é zero.
  Call "gdiplus.dll" "GdipReleaseDC" com 
    O gpGraphic [graphics] \Identificador de um objeto Graphics 
    \criado a partir das funções GdipCreateFromHDC, GdipCreateFromHDC2, GdipCreateFromHWND ou GdipGetImageGraphicsContext.
    e O bitmap canvas. [hdc] \Identificador para o contexto de dispositivo
   \ que foi criado por uma chamada anterior para o método GdipGetHDC usando o identificador Graphics acima.
   \Valor de retorno: não retorna um valor.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
    O gpGraphic. [*graphics] \ponteito do número identificador dobjeto Graphics.
   \Valor de retorno da funlção: Retorna o valor GpStatus, sendo que o valor 0 significa que a função foi bem sucedida.
  Crie a imagem usando o gpBitmap.
  Atribua a caixa à caixa desta imagem.
  Atribua a caixa à caixa intacta desta imagem.

Etapas para que se extraia uma string desde um text:
  Se o text for inexistente, limpe a string; volte.
  Converta as rows deste text para a string.
  Remove algum tipo de trailing quebra de linha desde a string.
  Remove algum tipo de trailing retorno de carro desde a string.

Etapas para que se extraia uma string desde um text (sem adicionar quebras de linha):
  Se o text for inexistente, limpe a string; volte.
  Converta as rows deste text para a string (sem adicionar quebras de linha).
  Remove algum tipo de trailing retorno de carro desde a string.

Etapas para que se extraia uma string desde um text (trecho selecionado):
  Limpe a string.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Lance um subtexto sobre qualquer trecho selecionado na row of o text.
    Se o subtexto estiver em branco, repita.
    Posponha o subtexto para a string.
    Se o conteúdo deste caractere final deste subtexto for o retorno de carro, posponha a quebra de linha para a string.
  Repita. [o código acima]

Etapas para que se escolha uma orientação aleatória:
  Escolha aleatoriamente uma orientação.

Etapas para que se face east:
  Atribua 960 à orientação deste context.

Etapas para que se face north:
  Atribua 0 à orientação deste context.

Etapas para que se face south:
  Atribua 1920 à orientação deste context.

Etapas para que se face west:
  Atribua 2880 à orientação deste context.

Etapas para que se preencha uma caixa com uma cor:
  Pinte a caixa com a cor preta e a cor.

Etapas para que se preencha uma elipse sobre uma localização com uma cor:
  Centralize a elipse sobre a localização.
  Pinte a elipse com a cor preta e a cor.

Etapas para que se preencha uma string com um pedaço usando uma contagem:
  Reassign o caractere inicial desta string usando a contagem.
  Preencha pedaços com o pedaço starting sob o caractere inicial desta string pela contagem.
  Atribua o caractere inicial desta string mais a contagem menos 1 ao caractere final desta string.

Etapas para que se finalize after run:
  Se a contagem do heap for 0, cancele.
  Atribua a contagem do heap a uma contagem.
  Atribua "Você esqueceu de destruir " junto com a contagem seguido de " elemento(s) no heap." a uma string.
  Produza o relatório de informações usando a string.

Etapas para que se finalize os canvases:
  Finalize o memory canvas.
  Finalize o tela canvas.

Etapas para que se finalize o cgi:
  Call "kernel32.dll" "FreeConsole". \https://docs.microsoft.com/pt-br/windows/console/freeconsole
  \Desanexa o processo de chamada de seu console.
  \Essa função não tem parâmetros.
  \Se a função for bem-sucedida, o valor retornado será diferente de zero.
  \Se a função falhar, o valor retornado será zero.
  \Um processo pode ser anexado a no máximo um console. 
  \Se o processo de chamada ainda não estiver anexado a um console, o código de erro retornado será ERROR_INVALID_PARAMETER (87).
  \Um processo pode usar a função FreeConsole para desconectar-se de seu console. 
  \Se outros processos compartilharem o console, o console não será destruído, mas o processo chamado FreeConsole não poderá se referir a ele. 
  \Um console é fechado quando o último processo anexado a ele termina ou chama FreeConsole. 
  \Depois que um processo chama FreeConsole, ele pode chamar a função AllocConsole para criar um novo console ou AttachConsole para anexar a outro console.

Etapas para que se finalize as cors:

Etapas para que se finalize COM:
  Call "ole32.dll" "CoUninitialize".

Etapas para que se finalize um context:
  Destrua as choices.
  Destrua as figuras.
  Destrua o context stack.
  Destrua o context.

Etapas para que se finalize os cursors:  
  Call "user32.dll" "DestroyCursor" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroycursor
  \A função DestroyCursor destrói um cursor e libera qualquer memória ocupada por ele. 
    O i-beam cursor. [hCursor] \O identificador do cursor a ser destruída. 
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se a função falhar, o valor de retorno é zero.
  Call "user32.dll" "DestroyCursor" com \A função DestroyCursor destrói um cursor não compartilhado. 
  \Não use esta função para destruir um cursor compartilhado. 
  \Um cursor compartilhado é válido enquanto o módulo do qual foi carregado permanecer na memória.
    O hand cursor. [hCursor] \As seguintes funções obtêm um cursor compartilhado:
    \LoadCursor \LoadImage (se você usar o sinalizador LR_SHARED)
    \LoadCursorFromFile \CopyImage (se você usar a sinalização LR_COPYRETURNORG e o parâmetro hImage for um cursor compartilhado)
  Call "user32.dll" "DestroyCursor" com 
    A seta do mouse. [hCursor] 

Etapas para que se finalize as fonts:
  \Call "gdi32.dll" "RemoveFontMemResourceEx" com o osmosian font resource.
  \Call "gdi32.dll" "RemoveFontMemResourceEx" com o Segoe UI resource.
  Call "gdi32.dll" "RemoveFontMemResourceEx" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-RemoveFontMemResourceEx
  \A função RemoveFontMemResourceEx remove as fontes que foram adicionadas a partir de um arquivo de imagem de memória.
    O recurso de fonte Tahoma. [h] \Um identificador para o recurso de fonte. Esse identificador é retornado pela função AddFontMemResourceEx.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
    \Esta função remove uma fonte que foi adicionada pela função AddFontMemResourceEx. 
    \Para remover a fonte, especifique o mesmo caminho e sinalizadores que foram usados em AddFontMemResourceEx. 
    \Esta função removerá apenas a fonte especificada por fh.

Etapas para que se finalize gdi+:
  Call "gdiplus.dll" "GdiplusShutdown" com \https://docs.microsoft.com/en-us/windows/win32/api/gdiplusinit/nf-gdiplusinit-gdiplusshutdown
  \A função GdiplusShutdown limpa os recursos usados pelo Windows GDI +. 
  \Cada chamada para GdiplusStartup deve ser emparelhada com uma chamada para GdiplusShutdown.
    O gpToken. [token] \ O Token retornado por uma chamada anterior para GdiplusStartup.
    \Você deve chamar GdiplusStartup antes de criar quaisquer objetos GDI + 
    \e deve excluir todos os seus objetos GDI + (ou fazer com que saiam do escopo) antes de chamar GdiplusShutdown.
    \Observação: Para o Windows 7 e anteriores, se GDI + não puder criar uma família de fontes, 
    \ele substitui a família Sans Serif genérica e armazena em cache do lado do cliente o ponteiro para a família genérica. 
    \Como as chamadas para GdiplusStartup e GdiplusShutdown não estão cientes desse armazenamento em cache, 
    \o sistema operacional retém o ponteiro para o objeto de família genérica após o tempo de vida do objeto, o que faz com que o sistema operacional trave por completo. 
    \Para o Windows 8 e posterior, GDI + retorna um valor sentinela para o objeto da família genérica que permanece constante nas chamadas para GdiplusStartup 
    \e GdiplusShutdown para que o sistema operacional não retenha o ponteiro para o objeto da família genérica após a vida útil do objeto.

Etapas para que se finalize o memory canvas:
  Call "gdi32.dll" "SelectObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-selectobject
  \A função SelectObject seleciona um objeto no contexto de dispositivo (DC) especificado. O novo objeto substitui o objeto anterior do mesmo tipo.
    O memory canvas [hdc] \identificador do contexto de dispositivo
    e O saved memory hBitMap [h] \O identificador do objeto a ser selecionado.
    \ Neste caso, O objeto especificado deve ter sido criado usando uma das seguintes funções:
    \CreateBitmap, CreateBitmapIndirect, CreateCompatibleBitmap, CreateDIBitmap, CreateDIBSection
    \Os bitmaps só podem ser selecionados em DCs de memória. Um único bitmap não pode ser selecionado em mais de um DC ao mesmo tempo.
    devolvendo um hBitMap. [] \Se o objeto selecionado não for uma região e a função for bem-sucedida, o valor de retorno é um identificador para o objeto que está sendo substituído. 
    \Se o objeto selecionado for uma região e a função for bem-sucedida, o valor de retorno será um dos seguintes valores.
    \A região SIMPLEREGION consiste em um único retângulo. A região COMPLEXREGION consiste em mais de um retângulo.
    \A região NULLREGION é uma região vazia.
    \Se ocorrer um erro e o objeto selecionado não for uma região, o valor de retorno será NULL. Caso contrário, é HGDI_ERROR.
    \Observações: Esta função retorna o objeto selecionado anteriormente do tipo especificado. 
    \Um aplicativo deve sempre substituir um novo objeto pelo objeto padrão original depois de terminar de desenhar com o novo objeto.
    \Um aplicativo não pode selecionar um único bitmap em mais de um DC de cada vez.
    \ICM: Se o objeto selecionado for um pincel ou uma caneta, o gerenciamento de cores é executado.
  Call "gdi32.dll" "DeleteObject" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deleteobject
  \A função DeleteObject exclui uma caneta, pincel, fonte, bitmap, região ou paleta lógico, liberando todos os recursos do sistema associados ao objeto. 
  \Depois que o objeto é excluído, o identificador especificado não é mais válido.
    O hBitMap. [ho] \O indentificador de uma caneta, pincel, fonte, bitmap, região ou paleta lógica.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero.
    \Se o identificador especificado não é válido ou está atualmente selecionado em um DC, o valor de retorno é zero.
    \Não exclua um objeto de desenho (caneta ou pincel) enquanto ele ainda estiver selecionado em um DC.
    \Quando um pincel de padrão é excluído, o bitmap associado ao pincel não é excluído. O bitmap deve ser excluído independentemente.
  Call "gdi32.dll" "DeleteDC" com \ https://docs.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-deletedc
  \A função DeleteDC exclui o contexto de dispositivo especificado (DC).
    O memory canvas. [hdc] \O identificador do contexto do dispositivo.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
    \Um aplicativo não deve excluir um controlador de domínio cujo identificador foi obtido chamando a função GetDC. 
    \Em vez disso, ele deve chamar a função ReleaseDC para liberar o DC.

Etapas para que se finalize o module:

Etapas para que se finalize o mouse:

Etapas para que se finalize a área de impressão:
  Call "kernel32.dll" "GlobalFree" com \ https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalfree
  \A função GlobalFree libera o objeto de memória global especificado e invalida seu identificador.
    O número identificador do modo de dispositivo da impressora.[hMem] \ O número identificador do objeto de memória global. 
    \Esse identificador é retornado pela função GlobalAlloc ou GlobalReAlloc. 
    \Não é seguro liberar memória alocada com LocalAlloc.
    \As funções globais têm maior sobrecarga e fornecem menos recursos do que outras funções de gerenciamento de memória. 
    \Novos aplicativos devem usar as funções de heap, a menos que a documentação indique que uma função global deve ser usada. 
    \Para obter mais informações, consulte Funções globais e locais.
    \Se o processo examinar ou modificar a memória depois de liberada, 
    \pode ocorrer corrupção de heap ou pode ser gerada uma exceção de violação de acesso (EXCEPTION_ACCESS_VIOLATION).
    \A função GlobalFree irá liberar um objeto de memória bloqueado. 
    \Um objeto de memória bloqueado possui uma contagem de bloqueio maior que zero. 
    \A função GlobalLock bloqueia um objeto de memória global e aumenta a contagem de bloqueios em 1. 
    \A função GlobalUnlock o desbloqueia e diminui a contagem de bloqueios em 1. 
    \Para obter a contagem de bloqueios de um objeto de memória global, use a função GlobalFlags.
    \Se um aplicativo estiver sendo executado em uma versão de depuração do sistema, 
    \a função GlobalFree emitirá uma mensagem informando que um objeto bloqueado está sendo liberado. 
    \Se você estiver depurando o aplicativo, GlobalFree entrará em um ponto de interrupção antes de liberar um objeto bloqueado. 
    \Isso permite que você verifique o comportamento pretendido e, em seguida, continue a execução.
  Atribua 0 à área de impressão.

Etapas para que se finalize a tela:

Etapas para que se finalize o tela canvas:

Etapas para que se finalize um talker:
  Se o talker for inexistente, cancele.
  Call a release desta vtable deste talker com o talker.
  Atribua nil ao talker.

Etapas para que se finalize o janela do programa:
  Call "user32.dll" "DestroyWindow" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-destroywindow
  \A função DestroyWindow destrói a janela especificada. 
  \A função envia mensagens WM_DESTROY e WM_NCDESTROY para a janela para desativá-la e remover o foco do teclado dela. 
  \A função também destrói o menu da janela, 
  \esvazia a fila de mensagens do tópico, 
  \destrói temporizadores, 
  \remove a propriedade da área de transferência e 
  \quebra a cadeia do visualizador da área de transferência (se a janela estiver no topo da cadeia do visualizador).
  \Se a janela especificada for uma janela pai ou proprietária, 
  \DestroyWindow destrói automaticamente as janelas filhas ou proprietárias associadas ao destruir a janela pai ou proprietária. 
  \A função primeiro destrói as janelas filhas ou proprietárias e, em seguida, destrói a janela pai ou proprietária.
  \DestroyWindow também destrói caixas de diálogo não modais criadas pela função CreateDialog.
    A janela principal do programa. [hWnd] \O número identificador da janela a ser destruída.
    \Se a função for bem-sucedida, o valor de retorno será diferente de zero. Se a função falhar, o valor de retorno é zero.
    \Um thread não pode usar DestroyWindow para destruir uma janela criada por um thread diferente.
    \Se a janela que está sendo destruída for uma janela filho que não tem o estilo WS_EX_NOPARENTNOTIFY, uma mensagem WM_PARENTNOTIFY é enviada ao pai.
  Percorra. [o código abaixo]
  \ Execute a função "GetMessageA" da biblioteca "user32.dll" usando como argumentos os seguintes parâmetros: 
  \\o endereçamento dessa MSG e os valores 0, 0 e 0, esperando um número como resultado.
  Call "user32.dll" "GetMessageA" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getmessagea
  \A função GetMessageA obtém uma mensagem da fila de mensagens do thread de chamada. 
  \A função despacha mensagens enviadas de entrada até que uma mensagem postada esteja disponível para obtenção.
      O endereçamento dessa MSG [lpMsg] \Um ponteiro para uma estrutura MSG que recebe informações da mensagem da fila de mensagens do segmento.
      \https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-MSG
      e 0 [hWnd]  \Um identificador para a janela cujas mensagens devem ser recuperadas. A janela deve pertencer ao segmento atual.
    \Se hWnd for NULL, GetMessage recuperará mensagens para qualquer janela que pertença ao segmento atual 
    \e quaisquer mensagens na fila de mensagens do segmento atual cujo valor hwnd seja NULL.
    \Portanto, se hWnd for NULL, tanto as mensagens da janela quanto as mensagens do thread serão processadas.
      e 0 [wMsgFilterMin] \O valor inteiro do menor valor da mensagem a ser recuperado. 
      e 0 [wMsgFilterMax] \O valor inteiro do maior valor da mensagem a ser recuperado. 
    \Se wMsgFilterMin e wMsgFilterMax forem 0, GetMessage retorna todas as mensagens disponíveis (ou seja, nenhuma filtragem de intervalo é executada).
      devolvendo um número. \Se a função recuperar uma mensagem diferente de WM_QUIT, o valor de retorno será diferente de zero.    
    \Se houver um erro, o valor de retorno é -1. 
    \Por exemplo, a função falhará se hWnd for um identificador de janela inválido ou lpMsg for um ponteiro inválido. 
    Se o número for menor do que 1, pare. \Se a função recuperar a mensagem WM_QUIT, o valor de retorno será zero.
    Call "user32.dll" "TranslateMessage" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-translatemessage
    \Traduz mensagens de teclas virtuais em mensagens de caracteres. 
    \As mensagens de caracteres são postadas na fila de mensagens do thread de chamada, 
    \para serem lidas na próxima vez que o thread chamar a função GetMessage ou PeekMessage.
      o endereçamento desta MSG. [*lpMsg] \Um ponteiro para uma estrutura MSG 
      \ https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-msg
      \que contém informações de mensagem recuperadas da fila de mensagens do thread de chamada usando a função GetMessage ou PeekMessage.
      \Se a mensagem for traduzida (ou seja, uma mensagem de caractere é postada na fila de mensagens do encadeamento), o valor de retorno é diferente de zero.
      \Se a mensagem for WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN ou WM_SYSKEYUP, o valor de retorno será diferente de zero, independentemente da tradução.
    \Se a mensagem não for traduzida (ou seja, uma mensagem de caractere não é postada na fila de mensagens do encadeamento), o valor de retorno é zero.
    Call "user32.dll" "DispatchMessageA" com \ https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-dispatchmessagea
    \Envia uma mensagem para um procedimento de janela. Normalmente é usado para despachar uma mensagem recuperada pela função GetMessage.
      o endereçamento desta MSG.[*lpMsg]  \Um ponteiro para uma estrutura que contém a mensagem.
      \O valor de retorno especifica o valor retornado pelo procedimento de janela. E
      \mbora seu significado dependa da mensagem que está sendo despachada, o valor de retorno geralmente é ignorado.
  Repita. [o código acima]
  Desmanche a fila de eventos.
  Destrua o evento atual.

Etapas para que se finalize winsock:
  Call "ws2_32.dll" "WSACleanup". \https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsacleanup
  \A função WSACleanup encerra o uso da DLL Winsock 2 (Ws2_32.dll).
  \O valor de retorno é zero se a operação foi bem-sucedida. Caso contrário, o valor SOCKET_ERROR é retornado.
  \Um aplicativo ou DLL é necessário para executar uma chamada WSAStartup com êxito antes de usar os serviços do Windows Sockets. 
  \Quando tiver concluído o uso de Windows Sockets, 
  \o aplicativo ou DLL deve chamar WSACleanup para cancelar o registro de uma implementação de Windows Sockets
\  e permitir que a implementação libere quaisquer recursos alocados em nome do aplicativo ou DLL.

A find anchor é uma anchor.

Etapas para que se encontre uma choice usando uma localização:
  Start com nada no choice.
  Percorra. [o código abaixo]
    Obtenha o [first/next] choice desde as choices.
    Se o choice estiver sumido do mapa, cancele.
    Se a localização estiver na caixa desta choice, pare.
  Repita. [o código acima]

Etapas para que se encontre um dyad usando uns dyads e um nome:
  Esvazie o dyad.
  Percorra. [o código abaixo]
    Obtenha o dyad desde o dyads.
    Se o dyad for inexistente, cancele.
    Se o nome deste dyad for o nome, cancele.
  Repita. [o código acima]

Etapas para que se encontre next usando uma row e um text e um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Lance um subtexto sobre a string deste row.
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres deste texto pesquisado menos 1 ao caractere final deste subtexto.
  Se o número da linha desta row for o número da linha deste find anchor, mova o subtexto usando o número de coluna deste find anchor menos 1.
  Percorra. [o código abaixo]
    Se o caractere final deste subtexto for maior do que ou igual ao caractere final desta string desta row, cancele.
    Se o subtexto for o texto pesquisado (comparação de caracteres acentuados), pare. \ for spanish incremental find
    Mova o subtexto usando 1.
  Repita. [o código acima]
  Ligue o detector.
  Atribua o caractere inicial deste subtexto menos o caractere inicial desta string desta row mais 1 ao anchor número de coluna deste text.
  Atribua o número da linha desta row ao anchor número da linha deste text .
  Atribua o caractere final deste subtexto menos o caractere inicial desta string desta row mais 2 ao cursor de texto número de coluna deste text.
  Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas para que se encontre next usando um text e um detector:
  Se o wrap detector deste text estiver ativo, encontre next usando o text e o detector (wrapped text); volte.
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a quantidade de caracteres deste texto pesquisado for 0, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
    Encontre next usando a row e o text e o detector.
    Se o detector estiver ativo, cancele.
  Repita. [o código acima]

Etapas para que se encontre next usando um text e um detector (wrapped text):
  Desative o detector.
  Se o text for inexistente, cancele.
  Converta o find anchor para um posicionamento absoluto denominado offset usando o text.
  Extraia uma string desde o text (sem adicionar quebras de linha).
  Atribua o caractere inicial desta string mais o offset menos 1 ao caractere inicial desse subtexto.
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres deste texto pesquisado menos 1 ao caractere final deste subtexto.
  Percorra. [o código abaixo]
    Se o caractere final deste subtexto for maior do que o caractere final desta string, cancele.
    Se o subtexto for a texto pesquisado (comparação de caracteres acentuados), pare. \ para A spanish incremental find
    Mova o subtexto usando 1.
  Repita. [o código acima]
  Ligue o detector.
  Atribua o caractere inicial deste subtexto menos o caractere inicial desta string mais 1 a um anchor posicionamento absoluto.
  Atribua o caractere final deste subtexto menos o caractere inicial desta string mais 2 a um cursor de texto posicionamento absoluto.
  Converta o anchor posicionamento absoluto para o anchor deste text usando o text.
  Converta o cursor de texto posicionamento absoluto para o cursor de texto deste text usando o text.

Etapas para que se encontre o next misspelling usando uma row e um text e um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Lance um percorredor sobre a string deste row.
  Se o número da linha desta row for o número da linha deste find anchor, adicione o número de coluna deste find anchor menos 1 para o caractere inicial deste segmento final deste percorredor.
  Se o caractere inicial deste segmento final deste percorredor não for o caractere inicial desta string desta row, skip palavra characters no segmento final deste percorredor.
  Percorra. [o código abaixo]
    Mova o percorredor (spell checking rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Se o segmento inicial deste percorredor não estiver escrito incorretamente, repita.
  Ligue o detector.
  Atribua o caractere inicial deste segmento inicial deste percorredor menos o caractere inicial desta string desta row mais 1 ao anchor número de coluna deste text.
  Atribua o número da linha desta row ao anchor número da linha deste text .
  Atribua o caractere final deste segmento inicial deste percorredor menos o caractere inicial desta string desta row mais 2 ao cursor de texto número de coluna deste text.
  Atribua o número da linha desta row ao número de linhas do cursor deste text.

Etapas para que se encontre o next misspelling em um text usando um detector:
  Desative o detector.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for menor do que o número da linha deste find anchor, repita.
    Encontre o next misspelling usando a row e o text e o detector.
    Se o detector estiver ativo, cancele.
  Repita. [o código acima]



Etapas para que se encontre um endereço de memória usando uma string e um catálogo:
  Encontre um refer usando a string e o catálogo.
  Se o refer não for inexistente, atribua o endereço de memória deste refer ao endereço de memória; volte.
  Esvazie o endereço de memória.

Etapas para que se encontre um refer usando uma string e um catálogo:
  Se o catálogo for inexistente, cancele.
  Se a string estiver em branco, esvazie o refer; volte.
  Obtenha um bucket usando a string e o catálogo.
  Encontre o refer usando a string e os refers deste bucket.

Etapas para que se encontre um refer usando uma string e uns refers:
  Esvazie o refer.
  Percorra. [o código abaixo]
    Obtenha o refer desde o refers.
    Se o refer for inexistente, cancele.
    Se a string for a string deste refer, cancele.
  Repita. [o código acima]

Etapas para que se encontre um sector usando uma malha e uma localização:
  Atribua a coordenada X desta localização dividido pelo número X desta malha times o número X desta malha à coordenada X deste sector.
  Atribua a coordenada Y desta localização dividido pelo número Y desta malha times o número Y desta malha à coordenada Y deste sector.

Etapas para que se encontre um square root of um número:
  \ arredonda para baixo
  Isole o número.
  De-sign o número.
  Se o número for 0, atribua 0 ao square root; volte.
  Se o número for 1, atribua 1 ao square root; volte.
  Atribua 1 a um square número.
  Atribua 3 a um delta número.
  Percorra. [o código abaixo]
    Se o square for maior do que o número, pare.
    Adicione o delta para o square.
    Adicione 2 para o delta.
  Repita. [o código acima]
  Atribua o delta dividido por 2 menos 1 ao square root.

Etapas para que se encontre uma string usando uns conjunto de textos e uma string#:
  Limpe a string.
  Percorra. [o código abaixo]
    Obtenha um conjunto de texto desde o conjunto de textos.
    Se o conjunto de texto for inexistente, cancele.
    Adicione 1 para uma contagem.
    Se a contagem não for a string#, repita.
  Atribua a string deste conjunto de texto à string.

O texto pesquisado é uma string.

Etapas para que se encontre um conjunto de texto usando uma string e uns conjunto de textos:
  Esvazie o conjunto de texto.
  Percorra. [o código abaixo]
    Obtenha o conjunto de texto usando o conjunto de textos.
    Se o conjunto de texto for inexistente, pare.
    Se a string deste conjunto de texto é a string, pare.
  Repita. [o código acima]

Etapas para que se encontre um subtexto em uma string usando uma segunda string:
  Lance o subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o subtexto começa com a segunda string, pare.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]
  Atribua o caractere inicial deste subtexto mais a quantidade de caracteres desta segunda string menos 1 ao caractere final deste subtexto.

Etapas para que se encontre um value string usando uns dyads e um nome:
  Encontre um dyad usando o dyads e o nome.
  Se o dyad for inexistente, limpe o value string; volte.
  Atribua a value string deste dyad ao value string.

Etapas para que se encontre uma value string usando o environment variáveis e um nome:
  Isole o nome.
  Termine com o caractere NULL o nome.
  Atribua 32767 a uma quantidade de caracteres. \ max size por environment variável
  Reassign o first  endereço de memória do pedaço desta value string usando a quantidade de caracteres.
  Call "kernel32.dll" "GetEnvironmentVariableA" com 
    O caractere inicial deste nome 
    e O caractere inicial desta value string
    e A quantidade de caracteres 
    devolvendo a quantidade de caracteres.
  Atribua o caractere inicial desta value string mais a quantidade de caracteres menos 1 ao caractere final desta value string. 

Um finger é um endereço de memória do pedaço .

\Um flag has 4 pedaços.
Um detector é uma coisa com 4 pedaços. \é um conjunto com

Etapas para que se flip um fração:
  Permute o numerador desta fração com o denominador desta fração.

Etapas para que se flip o gpBitmap em uma imagem:
  Se a imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Flip o gpBitmap desta imagem.

Etapas para que se flip um GpImage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O GpImage 
    e 6 [RotateNoneFlipY aka Rotate180FlipX].

Etapas para que se flip uma imagem:
  Se a imagem for inexistente, cancele.
  Atribua a coordenada Y deste center desta caixa desta imagem menos a coordenada Y deste center desta caixa intacta desta imagem ao número Y desse par de números.
  Multiplique o número Y deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Flip o gpBitmap no imagem.

Etapas para que se flip um polígono:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia a coordenada Y do canto superior esquerdo desta caixa desde a coordenada Y deste vértice.
    Atribua a coordenada Y do canto inferior direito desta caixa menos a coordenada Y deste vértice à coordenada Y deste vértice.
  Repita. [o código acima]

Etapas para que se desmanche all input;
Etapas para que se desmanche all inputs;
Etapas para que se desmanche all events:
  Desmanche algum tipo de messages.
  Desmanche a fila de eventos.

Etapas para que se desmanche algum tipo de messages:
  Call "user32.dll" "PeekMessageA" com 
    O endereçamento dessa MSG 
    e 0 
    e 0 
    e 0 
    e 1 [PM_REMOVE] devolvendo um número.
  Se o número for 0, cancele.
  Se a message desta MSG for 15 [WM_PAINT], Call "user32.dll" "ValidateRect" com a janela principal do programa e 0. \ que tal ter uma rotina específica para isso?
  Repita. [o código acima]

Etapas para que se desmanche um fila de eventos:
  Obtenha um event desde a fila de eventos.
  Se o event for inexistente, cancele.
  Remove o event desde a fila de eventos.
  Destrua o event.
  Repita. [o código acima]

Uma font é um conjunto com 
  Um nome e 
  Uma altura.

Um altura da fonte é uns twips. \ indicates linha reta altura - o letras will fit nicely em uma caixa of this altura

Um font resource é um número identificador.

Um pé são 12 polegadas.

Etapas para que se format um número e um singular string ou um plural string Para uma string: \verificar
  Converta o número para a string.
  Posponha o caractere de espaço para a string.
  Se o número for 1, posponha o singular para a string.
  Se o número não for 1, posponha o plural para a string.

Um fração é um conjunto com 
  Um numerador número e 
  Um denominador número, e 
  Um topo número sob o numerador e 
  Um base número sob o denominador.

Um par de números fracionários é um conjunto com 
  Uma fração e 
  Uma segunda fração.

Um máximo divisor comum é um número.

Um figura geométrica é um figura.

Etapas para que se obtenha um abcA e um abcC usando uma string e um canvas:
  Atribua 0 ao abcA.
  Atribua 0 ao abcC.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste caractere inicial desta string 
    e O conteúdo deste caractere inicial desta string 
    e O endereçamento desse ABC.
  Atribua o abcA deste ABC ao abcA.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste caractere final desta string 
    e O conteúdo deste caractere final desta string 
    e O endereçamento desse segunda ABC.
  Atribua o abcC desta segunda ABC ao abcC.

Etapas para que se obtenha um abcA usando uma string e um canvas:
  Atribua 0 ao abcA.
  Se a quantidade de caracteres desta string for menor do que 1, cancele.
  Call "gdi32.dll" "GetCharABCWidthsA" com 
    O canvas 
    e O conteúdo deste caractere inicial desta string 
    e O conteúdo deste caractere inicial desta string 
    e O endereçamento desse ABC.
  Atribua o abcA deste ABC ao abcA.

Etapas para que se obtenha uns addrinfo routines:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "LoadLibraryA" com "ws2_32.dll"'s caractere inicial devolvendo um número identificador.
  Se o número identificador for 0, atribua "Não foi possível obter o valor do endereço de memória da biblioteca ws2_32.dll." ao erro do fluxo de entrada/saída; volte.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador \Um identificador para o módulo DLL que contém a função ou variável. 
    \A função LoadLibrary, LoadLibraryEx, LoadPackagedLibrary ou GetModuleHandle retorna esse identificador.
    e "getaddrinfo"'s caractere inicial [ponteiro para uma string constante]  \ O nome da função ou variável, ou o valor ordinal da função. 
    \Se este parâmetro for um valor ordinal, ele deve estar contido na word de ordem inferior; a word de ordem superior deve ser zero.
    devolvendo um endereço de memória. \ obtendo/recebendo/aguardando como resultado
  Se o endereço de memória for inexistente, atribua "Infelizmente essa rotinas só funciona no Windows XP ou superior." ao erro do fluxo de entrada/saída; volte.
  Atribua o endereço de memória ao getaddrinfo endereço de memória destas addrinfo routines.
  Call "kernel32.dll" "GetProcAddress" com 
    O número identificador 
    e "freeaddrinfo"'s caractere inicial [ponteiro para uma string constante] 
    devolvendo o endereço de memória.
  Se o endereço de memória for inexistente, atribua "Infelizmente essas rotinas só funcionam no Windows XP ou numa versão superior do Windows." ao erro do fluxo de entrada/saída; volte.
  Atribua o endereço de memória ao freeaddrinfo endereço de memória destas addrinfo routines.

Etapas para que se obtenha uma caixa pelo cursor de texto em um text:
  Se o text for inexistente, zero a caixa; volte.
  Obtenha uma localização usando o cursor de texto deste text e o text.
  Atribua a localização e a localização ao caixa.
  Adicione a altura da linha deste text para a coordenada Y do canto inferior direito desta caixa.
  Ajuste a caixa usando 0 e a quantidade de twips/pixel e 0 e - a quantidade de twips/pixel .
  Atribua a globalized origem deste text a um origem.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X desta origem, atribua a coordenada X desta origem à coordenada X do canto superior esquerdo desta caixa; atribua a coordenada X desta origem à coordenada X do canto inferior direito desta caixa.
  Se o wrap detector deste text não estiver ativo, cancele.
  Limite a coordenada X do canto superior esquerdo desta caixa para a coordenada X do canto superior esquerdo deste text e a coordenada X do canto inferior direito deste text.
  Limite a coordenada X do canto inferior direito desta caixa para a coordenada X do canto superior esquerdo deste text e a coordenada X do canto inferior direito deste text.

Etapas para que se obtenha uma caixa por uma linha reta:
  Atribua a localização inicial desta linha reta ao canto superior esquerdo desta caixa.
  Atribua a localização final desta linha reta ao canto inferior direito desta caixa.
  Normalize a caixa.

Etapas para que se obtenha uma caixa usando uma row e um text:
  Se o text for inexistente, zero a caixa; volte.
  Se a row for inexistente, zero a caixa; volte.
  Atribua a globalized origem deste text ao canto superior esquerdo desta caixa.
  Adicione o número da linha desta row menos 1 times a altura da linha deste text para a coordenada Y do canto superior esquerdo desta caixa.
  Atribua a coordenada X do canto inferior direito deste text à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura da linha deste text à coordenada Y do canto inferior direito desta caixa.

Etapas para que se obtenha um bucket usando um bucket# e um catálogo:
  \ if o catálogo for inexistente, esvazie o bucket; volte. \ para fazer compilador faster
  Atribua o first bucket deste catálogo ao bucket.
  Adicione o bucket# times a magnitude desse conjunto de buckets para o bucket.

Etapas para que se obtenha um bucket usando um catálogo:
  \Se o catálogo for inexistente, esvazie o bucket; volte. \ para fazer o compilador mais rápido
  Se o bucket for inexistente, atribua o first bucket deste catálogo ao bucket; volte.
  Se o bucket for o last bucket deste catálogo, esvazie o bucket; volte.
  Adicione a magnitude desse conjunto de buckets para o bucket.

Etapas para que se obtenha um bucket usando uma string e um catálogo:
  \ if o catálogo for inexistente, esvazie o bucket; volte. \ para fazer compilador faster
  Obtenha um bucket# usando a string e o catálogo.
  Obtenha o bucket usando o bucket# e o catálogo.

Etapas para que se obtenha um bucket# usando uma string e um catálogo:
  \ baseado no algoritmo djb2 
  \ if o catálogo for inexistente, atribua 0 ao bucket#; volte. \ para fazer compilador faster
  Atribua a quantidade de caracteres desta string ao bucket#.
  Se o bucket# for 0, cancele.
  Adicione 5381 para o bucket#.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Atribua o conteúdo deste caractere inicial deste subtexto a um pedaço.
    Lowercase o pedaço.
    Atribua o bucket# a um número.
    Desloque o bucket# left 5 bits.
    Adicione o número para o bucket#.
    Adicione o pedaço para o bucket#.
    Adicione 3 para o caractere inicial deste subtexto.
    Se o subtexto estiver em branco, pare.
  Repita. [o código acima]
  Conjuncione logicamente o bucket# com o maior número.
  Divida o bucket# pela contagem de buckets deste catálogo usando um quociente e o bucket#.

Etapas para que se obtenha um pedaço desde uma string:
  Se a string estiver em branco, atribua o caractere null ao pedaço; volte.
  Atribua o conteúdo deste caractere inicial desta string ao pedaço.
  Remove o first pedaço desde a string.

Etapas para que se obtenha um pedaço desde uma string (backwards):
  Se a string estiver em branco, atribua o caractere null ao pedaço; volte.
  Atribua o conteúdo deste caractere final desta string ao pedaço.
  Remove o last pedaço desde a string.

Etapas para que se obtenha um center localização usando uma localização e uma segunda localização:
  Atribua a localização e a segunda localização a uma linha reta.
  Atribua o center desta linha reta ao center.

Etapas para que se obtenha uma cor usando uma localização:
  Call "gdi32.dll" "GetPixel" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    devolvendo um código da cor.
  Converta o código da cor para a cor.

Etapas para que se obtenha um número de coluna usando uma row e uma localização e um text:
  Atribua 0 ao número de coluna.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a quantidade de caracteres desta string desta row ao número de coluna; volte. \ only happens sobre last row of text
  Crie o número da fonte of o memory canvas usando a font deste text.
  Obtenha um start largura e um subtexto usando a row e a localização e o text (for "get um número de coluna usando uma row...").
  Percorra. [o código abaixo]
    Se o caractere final deste subtexto é o caractere final desta string desta row, pare.
    Obtenha uma largura usando o subtexto e o memory canvas.
    Adicione o start largura para a largura.
    Obtenha uma segunda largura usando o conteúdo deste caractere final deste subtexto e o memory canvas.
    Divida a segunda largura por 2.
    Subtraia a segunda largura desde a largura.
    Se a coordenada X desta localização for menor do que a largura, pare.
    Adicione 1 para o caractere final deste subtexto.
  Repita. [o código acima]
  Atribua o caractere final deste subtexto menos o caractere inicial desta string desta row mais 1 ao número de coluna.
  Destrua o número da fonte of o memory canvas.

Etapas para que se obtenha uma contagem of items em um endereço completo no sistema de arquivos:
  Atribua 0 à contagem.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for encontrado, cancele.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se obtenha um description por um endereço completo:
  Limpe o description.
  Obtenha um categoria da unidade de disco pelo endereço completo.
  Atribua o categoria da unidade de disco ao description.
  Obtenha um nome da unidade de disco pelo endereço completo.
  Se o nome da unidade de disco não estiver em branco, atribua o nome da unidade de disco ao description.
  Lowercase o description.

Etapas para que se obtenha um difference entre um par de números e um segundo par de números:
  Atribua o par de números à difference.
  Subtraia o segundo par de números desde a difference.

Etapas para que se obtenha um difference entre um par de números e um segundo par de números usando uma malha par de números:
  Obtenha a difference entre o par de números e o segundo par de números.
  Arredonde a difference para a malha.

Etapas para que se obtenha um distance entre uma localização e uma segunda localização (approximate):
  Atribua a coordenada X desta localização menos o x desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos o y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número times o número ao distance.
  Adicione o segundo número times o segundo número para o distance.
  Encontre um square root of o distance.
  Atribua o square root ao distance.
  Se a tecla D/d estiver sendo pressionada, produza o relatório de informações usando o distance.

Etapas para que se obtenha um distance entre uma localização e uma segunda localização (chessboard):
  Atribua a coordenada X desta localização menos a coordenada X desta segunda localização a um número.
  De-sign o número.
  Atribua a coordenada Y desta localização menos a coordenada Y desta segunda localização a um segundo número.
  De-sign o segundo número.
  Atribua o número ao distance.
  Se o segundo número for maior do que o número, atribua o segundo número ao distance.

Etapas para que se obtenha um categoria da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetDriveTypeA" com 
    O caractere inicial deste endereço completo 
    devolvendo um número.
  Se o número for 2 [DRIVE_REMOVABLE], atribua "Disco removível" à categoria da unidade de disco; volte. \ removable drive
  Se o número for 3 [DRIVE_FIXED], atribua "Disco Rígido / Pendrive" à categoria da unidade de disco; volte.\ hard disk / flash drive
  Se o número for 4 [DRIVE_REMOTE], atribua "Unidade de rede" à categoria da unidade de disco; volte. \ network drive
  Se o número for 5 [DRIVE_CDROM], atribua "Unidade de CD/DVD" à categoria da unidade de disco; volte. \ cd-rom / dvd drive
  Se o número for 6 [DRIVE_RAMDISK], atribua "Unidade de disco RAM" à categoria da unidade de disco; volte. \ unidade virtual de disco criada a partir da RAM
  Atribua "" à categoria da unidade de disco.

Etapas para que se obtenha um nome da unidade de disco por um endereço completo:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Atribua 512 a uma quantidade de caracteres.
  Reassign o caractere inicial desse trecho usando a quantidade de caracteres.
  Call "kernel32.dll" "GetVolumeInformationA" com 
    O caractere inicial deste endereço completo 
    e O caractere inicial deste trecho
   e A quantidade de caracteres 
   e 0 
   e 0 
   e 0 
   e 0 
   e 0 devolvendo um número.
  Se o número for 0, limpe o nome da unidade de disco; volte.
  Converta o caractere inicial deste trecho como um endereçamento de caractere para o nome da unidade de disco.

Etapas para que se obtenha o first-eighth equivalent of uma orientação:
  Obtenha o first-quarter equivalent of a orientação.
  Se a orientação for menor do que 480, cancele.
  Subtraia 960 desde a orientação.
  De-sign a orientação.

Etapas para que se obtenha o first-quarter equivalent of uma orientação:
  Se a orientação for menor do que 960, cancele.
  Subtraia 960 desde a orientação.
  Repita. [o código acima]

Etapas para que se obtenha fresh random números;
Etapas para que se obtenha new random números;
Etapas para que se seed o número aleatório generator:
  Atribua a contagem de intervalos do sistema à seed.

Etapas para que se obtenha um máximo divisor comum usando um número e um segundo número:
  Atribua o número a um dividend número.
  Atribua o segundo número ao máximo divisor comum.
  De-sign o dividend número.
  De-sign o máximo divisor comum.
  Se o dividend for menor do que o máximo divisor comum, permute o dividend com o máximo divisor comum.
  Se o máximo divisor comum for 0, atribua 1 ao máximo divisor comum; volte.
  Percorra. [o código abaixo]
    Divida o dividend pelo máximo divisor comum usando um quociente e um resto.
    Se o resto for 0, cancele.
    Atribua o máximo divisor comum ao dividend.
    Atribua o resto ao máximo divisor comum.
  Repita. [o código acima]

Etapas para que se obtenha um Endereço IP usando um host string:
  Limpe o Endereço IP.
  Obtenha um sockaddr usando o host string.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Atribua o s_addr deste sin_addr deste sockaddr ao número deste Endereço IP.
  Call "ws2_32.dll" "inet_ntoa" com 
    O número deste Endereço IP 
    devolvendo um endereçamento de caractere.
  Converta o endereçamento de caractere para a string deste Endereço IP.

Etapas para que se obtenha um item (novamente):
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "FindNextFileA" com 
    O número identificador deste item 
    e O endereçamento deste WIN32FINDDATA deste item 
    devolvendo um número.
  Se o número não for 0, ajuste o item; volte.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindClose" com 
    O número identificador deste item.

Etapas para que se obtenha um item desde um endereço completo:
  Se o endereço completo não for endereço da pasta-format, cancele.
  Atribua o endereço completo ao endereço da pasta deste item.
  Se a categoria deste item estiver em branco, obtenha o item desde o endereço completo (pela primeira vez); volte.
  Obtenha o item (novamente).

Etapas para que se obtenha um item desde um endereço completo (pela primeira vez):
  Limpe o erro do fluxo de entrada/saída.
  Isole o endereço completo.
  Posponha "*.*" para o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Limpe a categoria deste item.
  Call "kernel32.dll" "FindFirstFileA" com 
    O caractere inicial deste endereço completo 
    e O endereçamento deste WIN32FINDDATA deste item 
    devolvendo o número identificador deste item.
  Se o número identificador deste item for -1 [INVALID_HANDLE_VALUE], cancele.
  Ajuste o item.

Etapas para que se obtenha um mínimo múltiplo comum usando um número e um segundo número:
  Obtenha um máximo divisor comum usando o número e o segundo número.
  Call "kernel32.dll" "MulDiv" com 
    O número 
    e O segundo número 
    e O máximo divisor comum 
    devolvendo o mínimo múltiplo comum.

Etapas para que se obtenha um letra desde o alphabet:
  Atribua o next letra ao letra.
  Avance o next letra limitando-a para o 'A' maiúsculo e o Z maiúsculo.
  Adicione 1 para o next letra.
  Se o next letra for maior do que o Z maiúsculo, atribua o 'A' maiúsculo à next letra.

Etapas para que se obtenha um número desde a stack:
  Atribua 0 ao número.
  Obtenha um stack entry desde o stack.
  Se a stack entry for inexistente, cancele.
  Converta a string desta stack entry para o número.
  Remove a stack entry desde o stack.
  Destrua a stack entry.

Etapas para que se obtenha um offset par de números usando uma string e uma caixa e uma font e um alinhamento:
  Crie o número da fonte of o memory canvas usando a font.
  Obtenha o offset par de números usando a string e a caixa e a font e o alinhamento (fast).
  Destrua o número da fonte of o memory canvas.

Etapas para que se obtenha um offset par de números usando uma string e uma caixa e uma font e um alinhamento (fast):
  Se o alinhamento for "left", obtenha o número X deste offset par de números usando a string e a caixa (fast - left).
  Se o alinhamento for "right", obtenha o número X deste offset par de números usando a string e a caixa (fast - right).
  Se o alinhamento for "center", obtenha o número X deste offset par de números usando a string e a caixa (fast - center).
  Call "gdi32.dll" "GetTextMetricsA" com 
    O memory canvas 
    e O endereçamento desse textmetric.
  Adicione a altura desta caixa menos a tmheight deste textmetric dividido por 2 para o número Y deste offset par de números.

Etapas para que se obtenha uma position usando uma localização e um text:
  Se o text for inexistente, limpe o position; volte.
  Obtenha uma row usando a localização e o text.
  Atribua o número da linha desta row ao número da linha desta position.
  Obtenha o número de coluna desta position usando a row e a localização e o text.

Etapas para que se obtenha um endereço de memória RGB desde um BitmapData sob um número da linha e um número de coluna:
  \ 1 based
  Atribua o scan0 deste BitmapData ao endereço de memória RGB.
  Adicione o número da linha menos 1 times o stride deste BitmapData para o endereço de memória RGB.
  Adicione o número de coluna menos 1 times a magnitude desse espaço de cor RGB para o endereço de memória RGB.

Etapas para que se obtenha um deslocamento vertical e um deslocamento horizontal usando uma orientação: \deslocamento horizontal e vertical?
  \ veja https://pt.wikipedia.org/wiki/Trigonometria_racional
  \ https://pt.wikipedia.org/wiki/Física_digital
  \ A trigonometria racional evita o uso direto de funções transcendentes, como seno e cosseno, substituindo-as por seus equivalentes quadráticos.
  Isole a orientação.
  Normalize a orientação.
  Normalize o original orientação.
  Se a orientação não for uniformemente divisível por 20, estime o deslocamento vertical e o deslocamento horizontal usando a orientação; volte.
  \ special cases
  Se a orientação for 0, atribua -10000 ao deslocamento vertical; atribua -0 ao deslocamento horizontal; volte. \ 0 graus
  Se a orientação for 960, atribua 10000 ao deslocamento horizontal; atribua -0 ao deslocamento vertical; volte. \ 90 graus
  Se a orientação for 1920, atribua 10000 ao deslocamento vertical; atribua 0 ao deslocamento horizontal; volte. \ 180 graus
  Se a orientação for 2880, atribua -10000 ao deslocamento horizontal; atribua 0 ao deslocamento vertical; volte. \ 270 graus
  Se a orientação for 3840, produza o relatório de informações usando "orientação inválida"; produza o relatório de informações usando a orientação; produza o relatório de informações usando o original orientação.
  \ force it ao first eighth of o círculo
  Obtenha o first-eighth equivalent of a orientação.
  \ encontre o first eighth of o círculo unsigned values
  Se a orientação for 20, atribua 0327 ao deslocamento horizontal; atribua 9995 ao deslocamento vertical; pare. \ 1.875 degrees
  Se a orientação for 40, atribua 0654 ao deslocamento horizontal; atribua 9979 ao deslocamento vertical; pare. \ 3.75 degrees
  Se a orientação for 60, atribua 0980 ao deslocamento horizontal; atribua 9952 ao deslocamento vertical; pare. \ 5.625 degrees = 1/64 of o caminho
  Se a orientação for 80, atribua 1305 ao deslocamento horizontal; atribua 9914 ao deslocamento vertical; pare. \7.5 degrees
  Se a orientação for 100, atribua 1629 ao deslocamento horizontal; atribua 9866 ao deslocamento vertical; pare. \ 9.375 degrees
  Se a orientação for 120, atribua 1951 ao deslocamento horizontal; atribua 9808 ao deslocamento vertical; pare. \ 11.25 degrees = 2/64 of o caminho
  Se a orientação for 140, atribua 2271 ao deslocamento horizontal; atribua 9739 ao deslocamento vertical; pare. \ 13.125 degrees
  Se a orientação for 160, atribua 2588 ao deslocamento horizontal; atribua 9659 ao deslocamento vertical; pare. \ 15 degrees
  Se a orientação for 180, atribua 2903 ao deslocamento horizontal; atribua 9569 ao deslocamento vertical; pare. \ 16.875 degrees = 3/64 of o caminho
  Se a orientação for 200, atribua 3214 ao deslocamento horizontal; atribua 9469 ao deslocamento vertical; pare. \ 18.75 degrees
  Se a orientação for 220, atribua 3523 ao deslocamento horizontal; atribua 9359 ao deslocamento vertical; pare. \ 20.625 degrees
  Se a orientação for 240, atribua 3827 ao deslocamento horizontal; atribua 9239 ao deslocamento vertical; pare. \ 22.5 degrees = 4/64 of o caminho
  Se a orientação for 260, atribua 4127 ao deslocamento horizontal; atribua 9109 ao deslocamento vertical; pare. \ 24.375 degrees
  Se a orientação for 280, atribua 4423 ao deslocamento horizontal; atribua 8969 ao deslocamento vertical; pare. \ 26.25 degrees
  Se a orientação for 300, atribua 4714 ao deslocamento horizontal; atribua 8819 ao deslocamento vertical; pare. \ 28.125 degrees = 5/64 of o caminho
  Se a orientação for 320, atribua 5000 ao deslocamento horizontal; atribua 8660 ao deslocamento vertical; pare. \ 30 degrees
  Se a orientação for 340, atribua 5281 ao deslocamento horizontal; atribua 8492 ao deslocamento vertical; pare. \ 31.875 degrees
  Se a orientação for 360, atribua 5556 ao deslocamento horizontal; atribua 8315 ao deslocamento vertical; pare. \ 33.75 degrees = 6/64 of o caminho
  Se a orientação for 380, atribua 5825 ao deslocamento horizontal; atribua 8128 ao deslocamento vertical; pare. \ 35.625 degrees
  Se a orientação for 400, atribua 6088 ao deslocamento horizontal; atribua 7934 ao deslocamento vertical; pare. \ 37.5 degrees
  Se a orientação for 420, atribua 6344 ao deslocamento horizontal; atribua 7730 ao deslocamento vertical; pare. \ 39.375 degrees = 7/64 of o caminho
  Se a orientação for 440, atribua 6593 ao deslocamento horizontal; atribua 7518 ao deslocamento vertical; pare. \ 41.25 degrees
  Se a orientação for 460, atribua 6836 ao deslocamento horizontal; atribua 7299 ao deslocamento vertical; pare. \ 43.125 degrees
  Se a orientação for 480, atribua 7071 ao deslocamento horizontal; atribua 7071 ao deslocamento vertical; pare. \ 45 degrees = 8/64 of o caminho
  Repita. [o código acima] \ não é realmente um comando de repetição, é apenas um marcador para as "breaks" aí de cima.
  \ ajuste por segunda eighths of o círculo
  Se o original orientação estiver entre 0 e 480, negate o deslocamento vertical; volte. \ 1st eighth (12:00 para 1:30)
  Se o original orientação estiver entre 480 e 960, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento vertical; volte. \ 2nd eighth (1:30 para 3:00)
  Se o original orientação estiver entre 960 e 1440, permute o deslocamento horizontal com o deslocamento vertical; volte. \ 3rd eighth (3:00 para 4:30)
  Se o original orientação estiver entre 1440 e 1920, cancele. \ 4th eighth (4:30 para 6:00)
  Se o original orientação estiver entre 1920 e 2400, negate o deslocamento horizontal; volte. \ 5th eighth (6:00 para 7:30)
  Se o original orientação estiver entre 2400 e 2880, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; volte. \ 6th eighth (7:30 para 9:00)
  Se o original orientação estiver entre 2880 e 3360, permute o deslocamento horizontal com o deslocamento vertical; negate o deslocamento horizontal; negate o deslocamento vertical; volte. \ 7th eighth (9:00 para 10:30)
  Se o original orientação estiver entre 3360 e 3840, negate o deslocamento horizontal; negate o deslocamento vertical; volte. \ 8th eighth (10:30 para 12:00)

Etapas para que se obtenha uma row usando um número da linha e um text:
  Esvazie a row.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha a row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se o número da linha desta row for o número da linha, cancele.
  Repita. [o código acima]

Etapas para que se obtenha uma row usando uma localização e um text:
  Se o text for inexistente, esvazie a row; volte.
  Atribua a coordenada Y desta localização a uma coordenada Y.
  Limite a coordenada Y para a coordenada Y do canto superior esquerdo deste text e a coordenada Y do canto inferior direito deste text.
  Atribua a coordenada Y menos a coordenada Y desta globalized origem deste text dividido pela altura da linha deste text mais 1 a um número da linha.
  Limite o número da linha para 1 e a contagem de linhas deste text.
  Obtenha a row usando o número da linha e o text.

Etapas para que se obtenha uma caixa de seleção usando uma row e um text:
  Limpe a caixa de seleção.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Atribua a caixa ao caixa de seleção.
  Obtenha a caixa de seleção usando a row e o text (lado esquerdo).
  Obtenha a caixa de seleção usando a row e o text (lado direito).

Etapas para que se obtenha uma caixa de seleção usando uma row e um text (lado esquerdo):
  Atribua a normalized seleção deste text a uma seleção.
  Atribua a coordenada X desta globalized origem deste text à coordenada X do canto superior esquerdo desta caixa de seleção.
  Se o anchor número da linha desta seleção for o número da linha desta row, obtenha uma localização usando o anchor desta seleção e o text; atribua a coordenada X desta localização à coordenada X do canto superior esquerdo desta caixa de seleção.
  Limite a coordenada X do canto superior esquerdo desta caixa de seleção para a coordenada X do canto superior esquerdo deste text e a coordenada X do canto inferior direito deste text.

Etapas para que se obtenha uma caixa de seleção usando uma row e um text (lado direito):
  Atribua a normalized seleção deste text a uma seleção.
  Atribua a coordenada X do canto inferior direito deste text à coordenada X do canto inferior direito desta caixa de seleção.
  Se o número de linhas do cursor desta seleção for o número da linha desta row, obtenha uma localização usando o cursor de texto desta seleção e o text; atribua a coordenada X desta localização à coordenada X do canto inferior direito desta caixa de seleção.
  Limite a coordenada X do canto inferior direito desta caixa de seleção para a coordenada X do canto superior esquerdo deste text e a coordenada X do canto inferior direito deste text.

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos:
  Se o endereço completo for endereço da pasta-format, obtenha o size usando o endereço completo no sistema de arquivos (pasta)[endereço].
  Se o endereço completo for file-format, obtenha o size usando o endereço completo no sistema de arquivos (arquivo).

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos (pasta)[endereço]:
  Atribua 0 ao size.
  Percorra. [o código abaixo]
    Obtenha um item desde o endereço completo.
    Se o item não for encontrado, cancele.
    Se a categoria deste item for "arquivo", adicione o size deste item para o size; repita.
    Atribua o endereço completo a uma segunda endereço completo.
    Posponha o designador deste item para a segunda endereço completo.
    Obtenha uma segunda size usando a segunda endereço completo no sistema de arquivos.
    Adicione a segunda size para o size.
  Repita. [o código acima]

Etapas para que se obtenha um size usando um endereço completo no sistema de arquivos (arquivo):
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesExA" com 
    O caractere inicial deste endereço completo 
    e 0 
    e O endereçamento desse WIN32FINDDATA.
  Atribua o nFileSizeLow deste WIN32FINDDATA ao size.

Etapas para que se obtenha um sockaddr usando um host string:
  Limpe o erro do fluxo de entrada/saída.
  \ prepare strings
  Isole o host string.
  Termine com o caractere NULL o host string.
  \ obtenha o function addresses
  Obtenha uns addrinfo routines.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  \ obtenha o sockaddr
  Atribua 2 [AF_INET] ao ai_family desse addrinfo.
  Atribua 1 [SOCK_STREAM] ao ai_sockettype deste addrinfo.
  Atribua 6 [IPPROTO_TCP] ao ai_protocol deste addrinfo.
  Call o getaddrinfo destas addrinfo routines com 
    O caractere inicial desta host string 
    e 0 e o endereçamento deste addrinfo
   e o endereçamento desse addrinfoptr 
     devolvendo um número resultante.
  Se o número resultante não for 0, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; volte.
  Se o addrinfoptr for inexistente, atribua "Não foi possível encontrar o nome do seguinte anfitrião (host): " junto com o host seguido de "." ao erro do fluxo de entrada/saída; volte.
  Atribua o conteúdo deste ai_addr deste addrinfoptr ao sockaddr.
  Call o freeaddrinfo destas addrinfo routines com o addrinfoptr.

Etapas para que se obtenha uma localização usando uma position e um text:
  Limpe a localização.
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número da linha desta position e o text.
  Obtenha uma caixa usando a row e o text.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização.
  Atribua o caractere inicial desta string desta row ao caractere inicial desse subtexto.
  Atribua o caractere inicial deste subtexto mais o número de coluna desta position menos 2 ao caractere final deste subtexto.
  Obtenha uma largura usando o subtexto e o memory canvas e a font deste text.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais a largura à coordenada X desta localização.
  Obtenha um offset par de números usando o working string desta row e a caixa e a font deste text e o alinhamento deste text.
  Adicione o número X deste offset par de números para a coordenada X desta localização.

Etapas para que se obtenha um start largura e um subtexto usando uma row e uma localização e um text (for "get um número de coluna usando uma row..."):
  Limpe o start largura.
  Limpe o subtexto.
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Obtenha uma caixa usando a row e o text.
  Lance o subtexto sobre o working string desta row.
  Obtenha um offset par de números usando o subtexto e a caixa e a font deste text e o alinhamento deste text (fast).
  Atribua a coordenada X desta globalized origem deste text mais o número X deste offset par de números ao start largura.
  Atribua o caractere inicial deste subtexto mais o text cutoff menos 1 ao caractere final deste subtexto.
  Percorra. [o código abaixo]
    Se o caractere final deste subtexto for maior do que ou igual ao caractere final desta string desta row, pare.
    Obtenha uma largura usando o subtexto e o memory canvas.
    Atribua o start largura mais a largura a uma segunda largura.
    Se a coordenada X desta localização for menor do que ou igual ao segunda largura, pare.
    Adicione a largura para o start largura.
    Mova o subtexto usando o text cutoff.
  Repita. [o código acima]
  Atribua o caractere inicial deste subtexto ao caractere final deste subtexto.

Etapas para que se obtenha uma string desde o stack:
  Limpe a string.
  Obtenha um stack entry desde o stack.
  Se o stack entry for inexistente, atribua "ERRO" à string; volte.
  Atribua a string desta stack entry para a string.
  Remove o stack entry desde o stack.
  Destrua o stack entry.

Etapas para que se obtenha uma string desde a área de transferência do Windows:
  Limpe a string.
  Call "user32.dll" "OpenClipboard" com 
    A janela principal do programa.
  Call "user32.dll" "GetClipboardData" com 
  1 [CF_TEXT] 
    devolvendo um número identificador.
  Se o número identificador for 0, Call "user32.dll" "CloseClipboard"; volte.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador 
    devolvendo um endereçamento de caractere.
  Converta o endereçamento de caractere para a string.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "user32.dll" "CloseClipboard".

Etapas para que se obtenha uma coisa desde umas coisas:
  Se  as coisas estiverem vazio, esvazie a coisa; volte.
  Se a coisa for inexistente, atribua o first destas coisas à coisa; volte.
  Atribua o next desta coisa à coisa.

Etapas para que se obtenha uma coisa desde umas coisas (backwards):
  Se  as coisas estiverem vazio, esvazie a coisa; volte.
  Se a coisa for inexistente, atribua o last destas coisas à coisa; volte.
  Atribua o previous desta coisa à coisa.

Etapas para que se obtenha um segmento inicial desde um reply:
  Remove algum tipo de leading noise desde o reply.
  Limpe o segmento inicial.
  Percorra. [o código abaixo]
    Se o reply estiver em branco, cancele.
    Obtenha um pedaço desde o reply.
    Se o pedaço for o caractere de espaço, cancele.
    Posponha o pedaço para o segmento inicial.
  Repita. [o código acima]

Etapas para que se obtenha uma largura usando um pedaço e um canvas:
  Call "gdi32.dll" "GetTextExtentPoint32A" com 
    O canvas 
    e O endereçamento deste pedaço 
    e 1 
    e O endereçamento desse par de números.
  Atribua o número X deste par de números à largura.

Etapas para que se obtenha uma largura usando um pedaço e uns font larguras:
  Atribua o pedaço a um número.
  Obtenha a largura usando o número e a font larguras.

Etapas para que se obtenha uma largura usando um número e uns font larguras:
  \ indexes são 0 based
  Se a font larguras são nil, limpe a largura; volte.
  Atribua o data destes font larguras a um endereço numérico.
  Adicione o número times a magnitude deste número para o endereço numérico.
  Atribua o conteúdo deste endereço numérico ao largura.

Etapas para que se obtenha uma largura usando uma string e um canvas:
  \ presume que a font já esteja selecionada no canvas
  Call "gdi32.dll" "GetTextExtentPoint32A" com 
    O canvas 
    e O caractere inicial desta string 
    e A quantidade de caracteres desta string 
    e O endereçamento desse par de números.
  Atribua o número X deste par de números ao largura.

Etapas para que se obtenha uma largura usando uma string e um canvas e um font:
  Crie o número da fonte of o canvas usando a font.
  Obtenha a largura usando a string e o canvas.
  Destrua o número da fonte of o canvas.

Etapas para que se obtenha uma largura usando uma string e um font:
  \ assumes memory canvas
  Obtenha a largura usando a string e o memory canvas e a font.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - center):
  Obtenha uma largura usando a string e o memory canvas.
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Atribua a largura menos o abcA menos o abcC ao largura.
  Atribua a largura desta caixa menos a largura dividido por 2 menos o abcA à coordenada X.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - left):
  Obtenha um abcA usando a string e o memory canvas.
  Atribua - o abcA à coordenada X.

Etapas para que se obtenha uma coordenada X usando uma string e uma caixa (fast - right):
  Obtenha um abcA e um abcC usando a string e o memory canvas.
  Obtenha uma largura usando a string e o memory canvas.
  Atribua a largura menos o abcA menos o abcC ao largura.
  Atribua a largura desta caixa menos a largura menos o abcA à coordenada X.

Um gigabyte é 1024 megabytes.

Etapas para que se globalize uma caixa usando um par de números:
  Mova a caixa usando o par de números.

Etapas para que se globalize uma localização usando um par de números:
  Mova a localização usando o par de números.

Etapas para que se go back para where we were:
  Restaure o context.

Um GpBitmap é um GpImage.

Um GpGraphic é um endereço de memória.

Um GpImage é um endereço de memória.



Um GpRect é um conjunto com
  Um número denominado x,
  Um número denominado y,
  Um número denominado largura,
  Um número denominado altura.

O gpToken é um gpToken.

Um gpToken é um número.



Uma malha é um par de números.

Etapas para que se garanta one row em um text:
  Se o text for inexistente, cancele.
  Se as rows deste text não estiverem vazio, cancele.
  Crie uma row usando o retorno de carro.
  Posponha a row para as rows deste text.
  Renumere as rows deste text.

Um guid é um UUID. \ identificador único global

O hand cursor é um cursor.

Etapas para que se mude alinhamento usando um text e um alinhamento:
  Se o text for inexistente, cancele.
  Relembre o text com "alinhamento".
  Alinhe o text usando o alinhamento.

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam:
  Separe o wParam a um word e uma segunda word.
  Atribua a segunda word a um número.
  Se o número for 0, execute algum tipo de WM_ACTIVATE com o wParam (deactivate); volte.
  Execute algum tipo de WM_ACTIVATE com o wParam (activate).

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam (activate):
  Call "user32.dll" "SetFocus" com 
    A janela principal do programa.
  Call "user32.dll" "ClipCursor" com 
  0.
  \ seterrormode(sem_failcriticalerrors) \ keeps certain disk erros desde appearing
  Crie um event.
  Atribua "activate" à categoria deste event. \pode ser traduzido
  Enfileire o event.
  Call "user32.dll" "PostMessageA" com 
    A janela principal do programa 
    e 0 [wm_null] 
    e 0 
    e 0.

Etapas para que se execute algum tipo de WM_ACTIVATE com um wParam (deactivate):
  Crie um event.
  Atribua "deactivate" à categoria deste event. \pode ser traduzido
  Enfileire o event.
  Call "user32.dll" "PostMessageA" com 
    A janela principal do programa 
    e 0 [wn_null] 
    e 0 
    e 0.

Etapas para que se execute algum tipo de WM_CHAR com um wParam e um lParam:
  \Se a tecla Alt está para baixo, cancele. \ removed por Spanish teclado AltGr e ctrl+alt characters
  \Se a tecla Ctrl está para baixo, cancele. \ removed por Spanish teclado AltGr e ctrl+alt characters
  Atribua o wParam a um pedaço.
  Se o pedaço não for imprimível, cancele.
  Crie um event.
  Atribua "pressionamento de tecla" à categoria deste event. \traduzido
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste event.
  Atribua o pedaço ao pedaço deste event.
  Converta o lParam para a tecla deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_CREATE com um janela do programa:
  Atribua a janela do programa à janela principal do programa.

Etapas para que se execute algum tipo de WM_DESTROY:
  Call "user32.dll" "PostQuitMessage" com 
  0.

Etapas para que se execute algum tipo de WM_LBUTTONDBLCLK com um lParam:
  Crie um event.
  Atribua "clique duplo" à categoria deste event. \traduzido
  Se a tecla Alt está para baixo, acione o detector de tecla Alt deste event.
  Se a tecla Ctrl está para baixo, acione o detector de tecla Ctrl deste event.
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste event.
  Converta o lParam para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_LBUTTONDOWN com um lParam:
  Crie um event.
  Atribua "clique" à categoria deste event. \traduzido
  Se a tecla Alt está para baixo, acione o detector de tecla Alt deste event.
  Se a tecla Ctrl está para baixo, acione o detector de tecla Ctrl deste event.
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste event.
  Converta o lParam para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_PAINT com um janela do programa:
  Call "user32.dll" "BeginPaint" com 
    A janela do programa 
    e O endereçamento desse paintstruct.
  Call "user32.dll" "EndPaint" com 
    A janela do programa 
    e O endereçamento desta paintstruct.
  Crie um event.
  Atribua "atualização de tela" à categoria deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_RBUTTONDBLCLK com um lParam:
  Crie um event.
  Atribua "clique direito duplo" à categoria deste event.
  Se a tecla Alt está para baixo, acione o detector de tecla Alt deste event.
  Se a tecla Ctrl está para baixo, acione o detector de tecla Ctrl deste event.
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste event.
  Converta o lParam para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_RBUTTONDOWN com um lParam:
  Crie um event.
  Atribua "clique direito" à categoria deste event.
  Se a tecla Alt está para baixo, acione o detector de tecla Alt deste event.
  Se a tecla Ctrl está para baixo, acione o detector de tecla Ctrl deste event.
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste event.
  Converta o lParam para a localização deste event.
  Enfileire o event.

Etapas para que se execute algum tipo de WM_SETCURSOR:
  Atualize o cursor.

Etapas para que se execute algum tipo de WM_SYSKEYDOWN com um wParam e um lParam;
Etapas para que se execute algum tipo de WM_KEYDOWN com um wParam e um lParam:
  Atribua o wParam a um tecla.
  Se a tecla com o lParam é alguma tecla de cancelamento ou tecla modificadora, cancele.
  Se a tecla for algum tipo de WM_CHAR tecla, cancele.
  Crie um event.
  Atribua "pressionamento de tecla" à categoria deste event.
  Se a tecla Alt está para baixo, acione o detector de tecla Alt deste event.
  Se a tecla Ctrl está para baixo, acione o detector de tecla Ctrl deste event.
  Se a tecla Shift está para baixo, acione o detector de tecla Shift deste event.
  Atribua a tecla à tecla deste event.
  Enfileire o event.

Etapas para que se execute capitalize usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "capitalize".
  Capitalize algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se efetue cópias usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Extraia uma string desde o text (trecho selecionado).
  Atribua a string sobre o área de transferência do Windows.

Etapas para que se execute cut usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text.
  Extraia uma string desde o text (trecho selecionado).
  Atribua a string sobre o área de transferência do Windows.
  Remove qualquer trecho selecionado no text.
  Wrap o text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um console:
  Se o console for inexistente, cancele. \não falta o clique normal aqui?
  Se a categoria deste event for "pressionamento de tecla", execute o event usando o console (pressionamento de tecla); volte.
  Se a categoria deste event for "atualização de tela", execute o event usando o console (atualização de tela); volte.
  Se a categoria deste event for "clique direito", execute o event usando o console (clique direito); volte.
  Se a categoria deste event for "mostrar seta", execute o event usando o console (mostrar seta do mouse); volte.

Etapas para que se execute um event usando um console (tecla backspace):
  Se o reply deste console estiver em branco, cancele.
  Se o event foi alterado, cancele.
  Execute o event usando o text deste console (tecla backspace).
  Remove o last pedaço desde o reply deste console.
  Mostre o console.

Etapas para que se execute um event usando um console (seta pra baixo):
  Role o text deste console para baixo one linha reta.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla End):
  Role o text deste console para o base.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Enter):
  Execute o event usando o text deste console (tecla Enter).
  Relinquish control.

Etapas para que se execute um event usando um console (tecla Home):
  Role o text deste console para o topo.
  Mostre o console.

Etapas para que se execute um event usando um console (pressionamento de tecla):
  Se a tecla deste event for a tecla backspace, execute o event usando o console (tecla backspace); volte.
  Se a tecla deste event for a seta pra baixo, execute o event usando o console (seta pra baixo); volte.
  Se a tecla deste event for a tecla End, execute o event usando o console (tecla End); volte.
  Se a tecla deste event for a tecla Enter, execute o event usando o console (tecla Enter); volte.
  Se a tecla deste event for a tecla Home, execute o event usando o console (tecla Home); volte.
  Se a tecla deste event for a tecla PgDn, execute o event usando o console (tecla Page Down); volte.
  Se a tecla deste event for a tecla PgUp, execute o event usando o console (tecla Page Up); volte.
  Se a tecla deste event for a seta pra cima, execute o event usando o console (seta pra cima); volte.
  Se o pedaço deste event não for imprimível, cancele.
  Posponha o pedaço deste event para o reply deste console.
  Execute o event usando o text deste console (caracteres gráficos).
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Page Down):
  Role o text deste console para baixo one página.
  Mostre o console.

Etapas para que se execute um event usando um console (tecla Page Up):
  Role o text deste console para cima one página.
  Mostre o console.

Etapas para que se execute um event usando um console (atualização de tela):
  Mostre o console.

Etapas para que se execute um event usando um console (clique direito):
  Mostre o hand cursor.
  Role o console usando o event.
  Atualize o cursor.

Etapas para que se execute um event usando um console (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas para que se execute um event usando um console (seta pra cima):
  Role o text deste console para cima one linha reta.
  Mostre o console.

Etapas para que se execute um event usando um terminal:
  Se o terminal for inexistente, cancele.
  Se a categoria deste event for "pressionamento de tecla", execute o event usando o terminal (pressionamento de tecla); volte.
  Se a categoria deste event for "atualização de tela", execute o event usando o terminal (atualização de tela); volte.
  Se a categoria deste event for "mostrar seta", execute o event usando o terminal (mostrar seta do mouse); volte.
  Se a categoria deste event for "clique", relinquish control. \ *** added por invisível turtle book questionable

Etapas para que se execute um event usando um terminal (tecla backspace):
  Se o reply deste terminal estiver em branco, cancele.
  Se o event foi alterado, cancele.
  Remove o last pedaço desde o reply deste terminal.
  Remove o last pedaço desde a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (tecla Enter):
  Relinquish control. \Abdique

Etapas para que se execute um event usando um terminal (pressionamento de tecla):
  Se a tecla deste event for a tecla backspace, execute o event usando o terminal (tecla backspace); volte.
  Se a tecla deste event for a tecla Enter, execute o event usando o terminal (tecla Enter); volte.
  Se o pedaço deste event não for imprimível, cancele.
  Posponha o pedaço deste event para o reply deste terminal.
  Posponha o pedaço deste event para a string deste last deste quora deste terminal.
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (atualização de tela):
  Mostre o terminal.

Etapas para que se execute um event usando um terminal (mostrar seta do mouse):
  Mostre a seta do mouse.

Etapas para que se execute um event usando um text (tecla backspace):
  Se o text for inexistente, cancele.
  Se não existir something para backspace no text, cancele.
  Relembre o text com "backspace".
  Se o event foi alterado, remova pedaços de o text (backspace com jump).
  Se o event não foi alterado, remova pedaços de o text (backspace).
  Wrap o text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (tecla Delete):
  Se o text for inexistente, cancele.
  Se não existir something para remove no text, cancele.
  Relembre o text com "delete".
  Se o event foi alterado, remova pedaços de o text (forward delete com jump).
  Se o event não foi alterado, remova pedaços de o text (forward delete).
  Wrap o text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (seta pra baixo):
  Se o text for inexistente, cancele.
  Se o cursor de texto of o text é sobre o last linha reta, acione um detector.
  Se o detector estiver ativo, mova o cursor de texto para o last pedaço of o text.
  Se o detector não estiver ativo, mova o cursor de texto para baixo no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (tecla End):
  Se o text for inexistente, cancele.
  Se o event foi alterado, mova o cursor de texto para o last pedaço of o text.
  Se o event não foi alterado, mova o cursor de texto para o last pedaço of o current row of o text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (tecla Enter):
  Se o text for inexistente, cancele.
  Relembre o text com "insert return".
  Remove qualquer trecho selecionado no text.
  Insira o retorno de carro ao text.
  Wrap o text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (tecla Esc):
  Se o text for inexistente, cancele.
  Desvencilhe-se de o text.

Etapas para que se execute um event usando um text (tecla Home):
  Se o text for inexistente, cancele.
  Se o event foi alterado, mova o cursor de texto para o first pedaço of o text.
  Se o event não foi alterado, mova o cursor de texto para o first pedaço of o current row of o text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (clique duplo):
  Se o text for inexistente, cancele.
  Desvencilhe-se de o text.
  Mova o cursor de texto right para algum tipo de non-alfanumérico pedaço no text.
  Mova o anchor left para algum tipo de non-alfanumérico pedaço no text.

Etapas para que se execute um event usando um text (seta esquerda):
  Se o text for inexistente, cancele.
  Se o event foi alterado, jump o cursor de texto left no text.
  Se o event não foi alterado, mova o cursor de texto left no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (tecla Page Down):
  Se o text for inexistente, cancele.
  Role o text para baixo one página.
  Mova o cursor de texto para baixo one página no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.

Etapas para que se execute um event usando um text (tecla Page Up):
  Se o text for inexistente, cancele.
  Role o text para cima one página.
  Mova o cursor de texto para cima one página no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.

Etapas para que se execute um event usando um text (caracteres gráficos):
  Relembre o text com "insert".
  Remove qualquer trecho selecionado no text.
  Insira o pedaço deste event ao text.
  Wrap o text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (seta direita):
  Se o text for inexistente, cancele.
  Se o event foi alterado, jump o cursor de texto right no text.
  Se o event não foi alterado, mova o cursor de texto right no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (tecla Tab):
  Se o text for inexistente, cancele.
  Relembre o text com "insert".
  Remove qualquer trecho selecionado no text.
  Insira o caractere de espaço ao text.
  Divida o cursor de texto número de coluna deste text por 2 usando um quociente e um resto.
  Se o resto for 0, insira o caractere de espaço ao text.
  Role o text para o cursor de texto.

Etapas para que se execute um event usando um text (seta pra cima):
  Se o text for inexistente, cancele.
  Mova o cursor de texto para cima no text.
  Se o detector de tecla Shift deste event não estiver ativo, desvencilhe-se de o text.
  Limpe a última operação deste text.
  Role o text para o cursor de texto.

Etapas para que se execute events usando um console:
  Se o console for inexistente, cancele.
  Percorra. [o código abaixo]
    Desenfileire um event.
    Se o event for inexistente, cancele.
    Execute o event usando o console.
  Repita. [o código acima]

Etapas para que se execute events usando um terminal:
  Se o terminal for inexistente, cancele.
  Percorra. [o código abaixo]
    Desenfileire um event.
    Se o event for inexistente, cancele.
    Execute o event usando o terminal.
  Repita. [o código acima]

Etapas para que se mude tamanho usando um text e uma caixa e uma altura da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "altura da fonte".
  Mude o text usando a caixa.
  Mude o text usando a altura da fonte.

Etapas para que se mude tamanho usando um text e uma altura da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "altura da fonte".
  Mude o text usando a altura da fonte.

Etapas para que se mude nome da fonte usando um text e uma nome da fonte:
  Se o text for inexistente, cancele.
  Relembre o text com "nome da fonte".
  Mude o text usando o nome da fonte.

Etapas para que se execute indent usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "dent".
  Indent algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Um número identificador é um número.

Etapas para que se execute lowercase usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "case".
  Lowercase qualquer trecho selecionado no text.
  Wrap o text.

Etapas para que se execute outdent usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "dent".
  Outdent algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute paste usando um text:
  Se o text for inexistente, cancele.
  Se não existir text sobre o área de transferência do Windows, cancele.
  Relembre o text.
  Remove qualquer trecho selecionado no text.
  Obtenha uma string desde o área de transferência do Windows.
  Insira a string ao text.
  Wrap o text.
  Role o text para o cursor de texto.

Etapas para que se efetue alteração de cor usando um text e uma cor:
  Se o text for inexistente, cancele.
  Relembre o text com "pincel".
  Atribua a cor ao pincel deste text.

Etapas para que se execute redo usando um text:
  Se o text for inexistente, cancele.
  Se o last destes redos deste text for inexistente, cancele.
  Copie o text a um segundo text.
  Posponha o segundo text para os undos deste text.
  Atribua o last destes redos deste text a um terceiro text.
  Remove o terceiro text desde os redos deste text.
  Copie as propriedades of o terceiro text para o text.
  Destrua o terceiro text.
  Ligue o detector de alteração deste text.

Etapas para que se execute reverse usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "reverse".
  Reverse algum tipo de rows selecionadas of o text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute select all usando um text:
  Se o text for inexistente, cancele.
  Selecione cada pedaço no text.

Etapas para que se execute classifique algum tipo de rows selecionadas usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "classifique rows selecionadas".
  Classifique algum tipo de rows selecionadas no text.
  Square para cima algum tipo de seleção no text.
  Wrap o text.

Etapas para que se execute undo usando um text:
  Se o text for inexistente, cancele.
  Se o last destes undos deste text for inexistente, cancele.
  Copie o text a um segundo text.
  Posponha o segundo text para os redos deste text.
  Atribua o last destes undos deste text a um terceiro text.
  Remove o terceiro text desde os undos deste text.
  Copie as propriedades of o terceiro text para o text.
  Destrua o terceiro text.
  Ligue o detector de alteração deste text.

Etapas para que se execute uppercase usando um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Relembre o text com "case".
  Uppercase qualquer trecho selecionado no text.
  Wrap o text.

Um hBitMap é um número identificador.

Um hBrush é um número identificador.

Um hDC é um número identificador.

Um orientação é uns points.

A contagem do heap é um número.

O endereço heap é um endereço de memória.

Um altura é uns twips.

Um texto hexadecimal é uma string.

Um número da fonte é um número identificador.

Um hIcon é um número identificador.

Etapas para que se oculte o cursor:
  Call "user32.dll" "ShowCursor" com 
  0 
    devolvendo um número.
  Se o número for menor do que 0, cancele.
  Repita. [o código acima]

Um horizontal linha reta é uma linha reta.

Um hour é 60 minutes.

Um hPen é um número identificador.

Um hRgn é um número identificador.

Um matiz é uns precise degrees [0 para 3599].

  

O i-beam cursor é um cursor.

Um iid é um UUID. \ Um interface identifier é um Identificador único universal

Etapas para que se imagine uma caixa uns twips por uns segunda twips;
Etapas para que se faça uma caixa uns twips por uns segunda twips:
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa.
  Atribua os twips à coordenada X do canto inferior direito desta caixa.
  Atribua a segunda twips à coordenada Y do canto inferior direito desta caixa.

Etapas para que se imagine uma caixa uns twips high por uns segunda twips wide;
Etapas para que se faça uma caixa uns twips high por uns segunda twips wide:
  Atribua 0 e 0 e a segunda twips e os twips ao caixa.

Etapas para que se imagine uma caixa uns twips smaller do que uma segunda caixa;
Etapas para que se faça uma caixa uns twips smaller do que uma segunda caixa:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips dividido por 2.

Etapas para que se imagine uma caixa uns twips smaller do que uma segunda caixa sobre cada side:
  Atribua a segunda caixa ao caixa.
  Indent a caixa pelo twips.

Etapas para que se imagine uma caixa uns twips wide por uns segunda twips high;
Etapas para que se faça uma caixa uns twips wide por uns segunda twips high:
  Atribua 0 e 0 e os twips e a segunda twips ao caixa.

Etapas para que se imagine uma caixa com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito;
Etapas para que se faça uma caixa com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito ao caixa.

Etapas para que se imagine uma caixa com uma localização e uma segunda localização;
Etapas para que se faça uma caixa com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao caixa.

Etapas para que se imagine uma cor desde um matiz e um saturação e um luminosidade;
Etapas para que se faça uma cor desde um matiz e um saturação e um luminosidade:
  Atribua o matiz e o saturação e o luminosidade à cor.

Etapas para que se imagine um dot about uns twips wide;
Etapas para que se faça um dot about uns twips wide;
Etapas para que se faça um dot uns twips wide:
  Faça o dot os twips pelo twips.

Etapas para que se imagine um dot entre uns twips e uns segunda twips wide;
Etapas para que se faça um dot entre uns twips e uns segunda twips wide:
  Escolha aleatoriamente uns terceiro twips entre os twips e a segunda twips.
  Faça o dot o terceiro twips wide.

Etapas para que se imagine uma elipse usando uma caixa;
Etapas para que se faça uma elipse usando uma caixa:
  Atribua a caixa à caixa desta elipse.

Etapas para que se imagine uma elipse uns twips por uns segunda twips;
Etapas para que se faça uma elipse uns twips por uns segunda twips:
  Atribua 0 à coordenada X do canto superior esquerdo desta elipse.
  Atribua 0 à coordenada Y do canto superior esquerdo desta elipse.
  Atribua os twips à coordenada X do canto inferior direito desta elipse.
  Atribua a segunda twips à coordenada Y do canto inferior direito desta elipse.

Etapas para que se imagine uma elipse com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito;
Etapas para que se faça uma elipse com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito ao elipse.

Etapas para que se imagine uma elipse com uma localização e uma segunda localização;
Etapas para que se faça uma elipse com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao elipse.

Etapas para que se imagine uma figura using uma string e uma localização;
Etapas para que se faça uma figura using uma string e uma localização;
Etapas para que se crie uma figura using uma string e um center localização:
  Crie a figura.
  Posponha a figura para as figuras.
  Isole a string.
  Lowercase a string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
  Skip algum tipo de leading noise no subtexto.
  Se a quantidade de caracteres deste subtexto for menor do que 2, cancele.
  Atribua o conteúdo deste caractere inicial deste subtexto a um pedaço.
  Atribua o pedaço menos o 'a' minúsculo ao y desse localização.
  Adicione 1 para o caractere inicial deste subtexto.
  Atribua o conteúdo deste caractere inicial deste subtexto ao pedaço.
  Atribua o pedaço menos o 'a' minúsculo ao x desta localização.
  Multiplique a localização por 24 px.
  Adicione o x deste center localização menos 299 pixels para a coordenada X desta localização.
  Adicione o y deste center localização menos 299 pixels para a coordenada Y desta localização.
  Posponha a localização para a figura.
  Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se imagine um horizontal linha reta uma fração of o caminho para cima desde o base of uma caixa;
Etapas para que se faça um horizontal linha reta uma fração of o caminho para cima desde o base of uma caixa:
  Imagine o horizontal linha reta across a caixa a fração of o caminho para cima desde o base.

Etapas para que se imagine uma linha reta across o base of uma caixa;
Etapas para que se faça uma linha reta across o base of uma caixa;
Etapas para que se imagine uma linha reta along o base of uma caixa;
Etapas para que se faça uma linha reta along o base of uma caixa:
  Atribua a coordenada Y do canto inferior direito desta caixa linha reta ao linha reta.

Etapas para que se imagine uma linha reta across uma caixa uma fração of o caminho para cima desde o base;
Etapas para que se faça uma linha reta across uma caixa uma fração of o caminho para cima desde o base:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa times a fração a uns twips.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização inicial desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização final desta linha reta.

Etapas para que se imagine uma linha reta across o topo of uma caixa;
Etapas para que se faça uma linha reta across o topo of uma caixa;
Etapas para que se imagine uma linha reta along o topo of uma caixa;
Etapas para que se faça uma linha reta along o topo of uma caixa:
  Atribua a coordenada Y do canto superior esquerdo desta caixa linha reta ao linha reta.

Etapas para que se imagine uma linha reta no middle of uma caixa;
Etapas para que se faça uma linha reta no middle of uma caixa;
Etapas para que se imagine uma linha reta across o middle of uma caixa;
Etapas para que se faça uma linha reta across o middle of uma caixa;
Etapas para que se imagine uma linha reta no center of uma caixa;
Etapas para que se faça uma linha reta no center of uma caixa;
Etapas para que se imagine uma linha reta across o center of uma caixa;
Etapas para que se faça uma linha reta across o center of uma caixa:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua o y deste center desta caixa ao y desta localização inicial desta linha reta.
  Atribua o y deste center desta caixa ao y desta localização final desta linha reta.

Etapas para que se imagine uma linha reta uns twips para cima desde o base of uma caixa;
Etapas para que se faça uma linha reta uns twips para cima desde o base of uma caixa:
  Atribua a coordenada X do canto superior esquerdo desta caixa ao x desta localização inicial desta linha reta.
  Atribua a coordenada X do canto inferior direito desta caixa ao x desta localização final desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização inicial desta linha reta.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips ao y desta localização final desta linha reta.

Etapas para que se imagine uma linha reta com uma localização e uma segunda localização;
Etapas para que se faça uma linha reta com uma localização e uma segunda localização:
  Atribua a localização e a segunda localização ao linha reta.

Etapas para que se imagine uma linha reta com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y;
Etapas para que se faça uma linha reta com uma coordenada X e uma coordenada Y e uma segunda coordenada X e uma segunda coordenada Y:
  Atribua a coordenada X e a coordenada Y e a segunda coordenada X e a segunda coordenada Y ao linha reta.

Etapas para que se imagine uma caixa arredondada desde uma caixa e um raio;
Etapas para que se faça uma caixa arredondada desde uma caixa e um raio:
  Atribua a caixa e o raio ao caixa arredondada.

Etapas para que se imagine uma caixa arredondada uns twips por uns segunda twips;
Etapas para que se faça uma caixa arredondada uns twips por uns segunda twips com um raio:
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa arredondada.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa arredondada.
  Atribua os twips à coordenada X do canto inferior direito desta caixa arredondada.
  Atribua a segunda twips à coordenada Y do canto inferior direito desta caixa arredondada.
  Atribua o raio ao raio desta caixa arredondada.

Etapas para que se imagine uma caixa arredondada com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito e um raio;
Etapas para que se faça uma caixa arredondada com uma coordenada X do canto superior esquerdo e uma coordenada Y do canto superior esquerdo e uma coordenada X do canto inferior direito e uma coordenada Y do canto inferior direito e um raio:
  Atribua a coordenada X do canto superior esquerdo e a coordenada Y do canto superior esquerdo e a coordenada X do canto inferior direito e a coordenada Y do canto inferior direito e o raio ao caixa arredondada.

Etapas para que se imagine uma caixa arredondada com uma localização e uma segunda localização e um raio;
Etapas para que se faça uma caixa arredondada com uma localização e uma segunda localização e um raio:
  Atribua a localização e a segunda localização e o raio ao caixa arredondada.

Etapas para que se imagine uma localização com uma coordenada X e uma coordenada Y;
Etapas para que se faça uma localização com uma coordenada X e uma coordenada Y:
  Atribua a coordenada X e a coordenada Y à localização.

Etapas para que se indent algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
  Se a row for inexistente, cancele.
  Se a row of o text não estiver selecionado, repita.
  Se a row estiver em branco, repita.
  Anteponha o caractere de espaço para a string deste row.
  Anteponha o caractere de espaço para a string deste row.
  Repita. [o código acima]

Um indent é uma contagem.

Um catálogo é uma coisa com
Um contagem de buckets,
Um first bucket e um last bucket.

Etapas para que se catalogue um endereço de memória usando uma string e um catálogo:
    \ if o catálogo for inexistente, cancele. \ para fazer compilador faster
  Se a quantidade de caracteres desta string for 0, cancele.
  Obtenha um bucket usando a string e o catálogo.
  Crie um refer.
  Posponha o refer para os refers deste bucket.
  Atribua a string à string deste refer.
  Atribua o endereço de memória ao endereço de memória deste refer.

Etapas para que se catalogue uma string em um catálogo:
  \ if o catálogo for inexistente, cancele. \ para fazer compilador faster
  Catalogue nil usando a string e o catálogo.

Etapas para que se initalize o terminal:
  Crie o terminal na caixa desta tela.

Etapas para que se initialize before run:
  Call "user32.dll" "DisableProcessWindowsGhosting".
  Call "kernel32.dll" "GetProcessHeap" 
    devolvendo o endereço heap.
  Call "kernel32.dll" "LoadLibraryA" com 
  "kernel32.dll"'s caractere inicial 
    devolvendo um número identificador.
  Se o número identificador não for 0, Call "kernel32.dll" "GetProcAddress" com 
    O número identificador 
    e "HeapSetInformation"'s caractere inicial 
    devolvendo um endereço de memória.
  Se o endereço de memória não for inexistente, Call o endereço de memória com o endereço heap e 0 e 2's endereçamento e 4.

Etapas para que se inicialize o canvases:
  Inicialize o tela canvas.
  Inicialize o memory canvas.
  Atribua o memory canvas ao quadro atual.

Etapas para que se inicialize o cgi:
  Call "kernel32.dll" "AllocConsole".
  Call "kernel32.dll" "GetStdHandle" com 
  -10 [STD_INPUT_HANDLE] 
    devolvendo o número identificador do fluxo de entrada padrão.
  Call "kernel32.dll" "GetStdHandle" com 
  -11 [STD_OUTPUT_HANDLE] 
    devolvendo o número identificador do fluxo de saída padrão.

\Etapas para que se inicialize o Component Object Model:
\Mande os códigos 0 e 2 para a função "CoInitializeEx" da biblioteca "ole32.dll" [COINIT_APARTMENTTHREADED].

Etapas para que se inicialize o Component Object Model:
  Call "ole32.dll" "CoInitializeEx" com 
  0 
    e 2 [COINIT_APARTMENTTHREADED].

Etapas para que se inicialize um context:
  Aloque memória para o context.
  Atribua o center desta tela à localização deste context.
  Atribua 0 à orientação deste context.
  Atribua a cor verde à cor deste context.
  Atribua o tamanho de letra pequena à tamanho da letra deste context.
  \Atribua 1/60 second ao delay. ***
  Seed o número aleatório generator.

Etapas para que se inicialize os cursors:
  Inicialize os cursors (seta do mouse).
  Inicialize os cursors (hand cursor).
  Inicialize os cursors (i-beam cursor).
  \Atribua a seta do mouse ao cursor flecha.
  \Atribua o hand cursor ao cursor mano.
  \Atribua o i-beam cursor ao cursor rayo-i.
  Oculte o cursor.

Etapas para que se inicialize os cursors (seta do mouse):
  Posponha $00000000000000004000000060000000 para uma máscara de disjunção exclusiva.
  Posponha $70000000780000007C0000007E000000 para a máscara de disjunção exclusiva.
  Posponha $7F0000007F8000007C0000006C000000 para a máscara de disjunção exclusiva.
  Posponha $46000000060000000300000003000000 para a máscara de disjunção exclusiva.
  Posponha $01800000018000000000000000000000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 48.
  Posponha $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF para uma máscara de conjunção lógica.
  Posponha $07FFFFFF03FFFFFF01FFFFFF00FFFFFF para a máscara de conjunção lógica.
  Posponha $007FFFFF003FFFFF001FFFFF01FFFFFF para a máscara de conjunção lógica.
  Posponha $10FFFFFF30FFFFFF787FFFFFF87FFFFF para a máscara de conjunção lógica.
  Posponha $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 48.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 0 
    e 0 
    e 32 
    e 32 
    e O caractere inicial desta máscara de conjunção lógica 
    e O caractere inicial desta máscara de disjunção exclusiva 
    devolvendo a seta do mouse.

Etapas para que se inicialize o cursors (hand cursor):
  Posponha $000000000180000019B0000019B00000 para uma máscara de disjunção exclusiva.
  Posponha $0DB200000DB6000007F6000067FE0000 para a máscara de disjunção exclusiva.
  Posponha $7FFC00003FFC00001FFC00001FF80000 para a máscara de disjunção exclusiva.
  Posponha $0FF8000007F0000003F0000003F00000 para a máscara de disjunção exclusiva.
  Posponha $00 para a máscara de disjunção exclusiva usando 64.
  Posponha $FE7FFFFFE40FFFFFC007FFFFC005FFFF para uma máscara de conjunção lógica.
  Posponha $E000FFFFE000FFFF9000FFFF0000FFFF para a máscara de conjunção lógica.
  Posponha $0001FFFF8001FFFFC001FFFFC003FFFF para a máscara de conjunção lógica.
  Posponha $E003FFFFF007FFFFF807FFFFF807FFFF para a máscara de conjunção lógica.
  Posponha $FF para a máscara de conjunção lógica usando 64.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 2 
    e 1 
    e 32 
    e 32 
    e O caractere inicial desta máscara de conjunção lógica 
    e O caractere inicial desta máscara de disjunção exclusiva 
    devolvendo o hand cursor.

Etapas para que se inicialize o cursors (i-beam cursor):
  Posponha $EE000000100000001000000010000000 para um máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $10000000100000001000000010000000 para o máscara de disjunção exclusiva.
  Posponha $100000001000000010000000EE000000 para o máscara de disjunção exclusiva.
  Posponha $00 para o máscara de disjunção exclusiva usando 64.
  Posponha $FF para um máscara de conjunção lógica usando 128.
  Call "user32.dll" "CreateCursor" com 
    O número identificador deste module 
    e 3 
    e 7 
    e 32 
    e 32 
    e O caractere inicial desta máscara de conjunção lógica 
    e O caractere inicial desta máscara de disjunção exclusiva 
    devolvendo o i-beam cursor.

Etapas para que se inicialize as fonts:
  Call "gdi32.dll" "GetStockObject" com 
  11 [ANSI_FIXED_FONT 0x0000000B] 
    devolvendo o null número da fonte.
  \Call "gdi32.dll" "AddFontMemResourceEx" com o caractere inicial desta osmosian font source e a quantidade de caracteres desta osmosian font source e 0 e o endereçamento desse número devolvendo o osmosian font resource.
  \Call "gdi32.dll" "AddFontMemResourceEx" com o caractere inicial desta fonte Segoe UI e a quantidade de caracteres desta fonte Segoe UI e 0 e o endereçamento desse número devolvendo o Segoe UI resource.
  Call "gdi32.dll" "AddFontMemResourceEx" com 
    O caractere inicial desta fonte Tahoma 
    e A quantidade de caracteres desta fonte Tahoma 
    e 0 
    e O endereçamento desse número 
    devolvendo o recurso de fonte Tahoma.
  \Atribua "Segoe UI" e 1/6 polegada à fonte padrão.
  \Atribua "osmosian" e 24 pixels à fonte padrão.
  Atribua "Tahoma" e 20 pixels à fonte padrão.
  \ stroked fonts debaixo of
  Atribua 12 pixels ao tamanho de letra pequena.
  Atribua 24 pixels ao tamanho de letra médio.
  Atribua 48 pixels ao tamanho de letra grande.

Etapas para que se inicialize gdi+:
  Atribua 1 ao GdiplusVersion desse GdiplusStartupInput.
  Call "gdiplus.dll" "GdiplusStartup" com 
    O endereçamento deste gpToken 
    e O endereçamento deste GdiplusStartupInput 
    e 0.
    \Windows GDI+ é uma API baseada em classe para programadores C/C++. 
    \Ela permite que os aplicativos usem elementos gráficos e texto formatado na exibição de vídeo e na impressora. 
    \Aplicativos baseados na API do Microsoft Win32 não acessam diretamente o hardware gráfico. 
    \Em vez disso, GDI+ interage com drivers de dispositivo em nome de aplicativos. 
    \GDI+ também é suportado pelo Microsoft Win64.

Etapas para que se inicialize o memory canvas:
  Call "gdi32.dll" "CreateCompatibleDC" com 
    O tela canvas 
    devolvendo o memory canvas.
  Call "gdi32.dll" "GetCurrentObject" com 
    O memory canvas 
    e 7 [OBJ_BITMAP] 
    devolvendo o saved memory hBitMap.
  Call "gdi32.dll" "CreateCompatibleBitmap" com 
    O tela canvas 
    e A pixel largura desta tela 
    e A pixel altura desta tela devolvendo um hBitMap.
  Call "gdi32.dll" "SelectObject" com 
    O memory canvas 
    e O hBitMap.
  Normalize o memory canvas.

Etapas para que se inicialize o module:
  \ temp endereço completo
  Atribua 512 a uma quantidade de caracteres.
  Reassign o caractere inicial deste temp endereço completo usando a quantidade de caracteres.
  Call "kernel32.dll" "GetTempPathA" com 
    A quantidade de caracteres 
    e O caractere inicial deste temp endereço completo 
    devolvendo a quantidade de caracteres.
  Atribua o caractere inicial deste temp endereço completo mais a quantidade de caracteres menos 1 ao caractere final deste temp endereço completo.
  Termine com o caractere NULL o temp endereço completo.
  \ module handle
  Call "kernel32.dll" "GetModuleHandleA" com 
  0 
    devolvendo o número identificador deste module.
  \ module nome
  Atribua 512 à quantidade de caracteres.
  Reassign o caractere inicial deste endereço completo deste module usando a quantidade de caracteres.
  Call "kernel32.dll" "GetModuleFileNameA" com 
    O número identificador deste module 
    e O caractere inicial deste endereço completo deste module 
    e A quantidade de caracteres 
    devolvendo a quantidade de caracteres.
  Atribua o caractere inicial deste endereço completo deste module mais a quantidade de caracteres menos 1 ao caractere final deste endereço completo deste module.
  Se o endereço completo deste module começa com "\\?\", remove leading pedaços desde o endereço completo deste module usando 4.
  Lowercase o endereço completo deste module.
  Termine com o caractere NULL o endereço completo deste module. \ segunda endereço completo pieces deste module
  Extraia o nome deste module desde o endereço completo deste module.
  Termine com o caractere NULL o nome deste module.
  Extraia o endereço da pasta deste module desde o endereço completo deste module.
  Termine com o caractere NULL o endereço da pasta deste module.
  Extraia o root endereço da pasta deste module desde o endereço da pasta deste module.
  Termine com o caractere NULL o root endereço da pasta deste module.

Etapas para que se inicialize o mouse:
  Atribua 1 ao botão esquerdo deste mouse.
  Atribua 2 ao botão direito deste mouse.
  Call "user32.dll" "GetSystemMetrics" com 
  23 [SM_SWAPBUTTON] 
    devolvendo um número.
  Se o número for 0, cancele.
  Permute o botão esquerdo deste mouse com o botão direito deste mouse.

Etapas para que se inicialize a área de impressão:
  Atribua a magnitude [quantidade de bytes] desse printdlgex ao lstructsize deste printdlgex.
  Atribua a janela principal do programa ao hwndowner deste printdlgex.
  Atribua 1288 [PD_RETURNDC + PD_RETURNDEFAULT + PD_NOPAGENUMS] ao flags deste printdlgex.
  Atribua -1 [START_PAGE_GENERAL] ao nstartpage deste printdlgex.
  Call "comdlg32.dll" "PrintDlgExA" com 
    O endereçamento deste printdlgex.
  Call "kernel32.dll" "GlobalFree" com 
    O hdevnames deste printdlgex.
  Atribua o hdevmode deste printdlgex ao número identificador do modo de dispositivo da impressora.
  Atribua o hDC deste printdlgex à área de impressão.

Etapas para que se inicialize o tela:
  Call "user32.dll" "GetSystemMetrics" com 
  0 [sm_cxscreen] 
    devolvendo a pixel largura desta tela.
  Call "user32.dll" "GetSystemMetrics" com 
  1 [sm_cyscreen] 
    devolvendo a pixel altura desta tela.
  Atribua 96 ao ppi.
  Atribua o tpi dividido pelo ppi ao quantidade de twips/pixel .
  Atribua a pixel largura desta tela times a quantidade de twips/pixel a uma largura.
  Atribua a pixel altura desta tela times a quantidade de twips/pixel a uma altura.
  Atribua 0 e 0 e a largura e a altura à caixa desta tela.
  Subtraia a quantidade de twips/pixel desde o canto inferior direito desta tela.

Etapas para que se inicialize o tela canvas:
  Call "user32.dll" "GetDC" com 
    A janela principal do programa 
    devolvendo o tela canvas.
  Normalize o tela canvas.

Etapas para que se inicialize um talker:
  Converta "{96749377-3391-11D2-9EE3-00C04F797396}" [CLSID_SpVoice] para um clsid.
  Converta "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [IID_ISpVoice] para um iid.
  Call "ole32.dll" "CoCreateInstance" com 
    O endereçamento deste clsid 
    e 0 
    e 7 [CLSCTX_ALL] 
    e O endereçamento deste iid 
    e O endereçamento deste talker.

Etapas para que se inicialize a janela do programa: \\ para inicializar a janela
  Atribua a magnitude [tamanho em bytes] dessa janela do programa class [estrutura] ao cbSize deste janela do programa class.
  Atribua 40 [CS_OWNDC + CS_DBLCLKS] ao style deste janela do programa class.
    \o valor cs_owndc Aloca um contexto de dispositivo exclusivo para cada janela da classe.
    \ o valor cs_dblclks permite que o windows informe ao programa que aquele é um clique duplo (ao invés de dois cliques)
  Point o lpfnWndProc deste janela do programa class para rotina handle algum tipo de message com um janela do programa um message número um wParam e um lParam.
    \ Isso define o procedimento da classe dessa janela como sendo WndProc
    \LPARAM é um typedef para um LONG_PTR que é um número inteiro (32 bits com sinal) em win32 e __int64 (64 bits com sinal) em x86_64.
    \WPARAM é um typedef para um UINT_PTR que é um número sem sinal (32 bits sem sinal) em win32 e __int64 sem sinal (64 bits sem sinal) em x86_64.
  Atribua o número identificador deste module ao hInstance desta janela do programa class.
  Atribua o caractere inicial deste nome deste module ao lpszClassName desta janela do programa class.
  Call "user32.dll" "RegisterClassExA" \ Antes de criar uma janela, você deve registrar uma classe pra essa janela chamando a função RegisterClass.
  com o endereçamento deste janela do programa class. \Esta função requer um único parâmetro, que é um ponteiro para uma estrutura do tipo WNDCLASS.
  Call "user32.dll" "CreateWindowExA" com 
  0  \ o estilo opcional da janela, como transparências por exemplo. veja mais detalhes em  https://docs.microsoft.com/en-us/windows/desktop/winmsg/extended-janela do programa-styles
    e O caractere inicial deste nome deste module  \\ O nome da classe da janela
    e O caractere inicial deste nome deste module  \\ O texto da janela
    e 2147483648 [13565952  WS_OVERLAPPEDWINDOW 0x00CF0000]   [-2147483648 = WS_POPUP 0x80000000] \\  aqui define o tipo da janela. Use valores em decimal;  
    \para isso Converta os valores hexadecimais da lista  https://www.autoitscript.com/autoit3/docs/appendix/GUIStyles.htm para decimal;
    \outra opção é usar o site https://www.magnumdb.com/
    \ O valor na documentação do windows está em hexadecimal (ou em string), mas esse compilador usa números inteiros (longint). 
    \ Para colocar a barra padrão, use o valor 13565952
    e 0  \\ posição horizontal inicial da janela
    e 0  \\  posição vertical inicial da janela
    e A pixel largura desta tela  \\ A largura da janela em pixels;
    e A pixel altura desta tela  \\ A altura da janela em pixels
    e 0  \ opcional. Informa o número identificador do controle pai da janela (se existir) ou da janela em si
    e 0 \ a mesma coisa, só que identifica o número do menu da janela.
    e O número identificador deste module  \\ descrição auto explicável
    e 0. \ aqui é um ponteiro que passa a informação pra janela. Usamos um valor nulo pq não precisamos dele.
  Call "user32.dll" "ShowWindow" com 
    A janela principal do programa 
    e 1 [SW_SHOWNORMAL].

Etapas para que se inicialize winsock:
  Call "ws2_32.dll" "WSAStartup" com 
  2 
    e O endereçamento desse wsadata.

Um input é um event.

Etapas para que se insira um pedaço Para um text:
  Se o text for inexistente, cancele.
  Atribua o pedaço a uma string.
  Insira a string ao text.

Etapas para que se insira uma localização Para um polígono after um vértice:
  Se o polígono for inexistente, cancele.
  Crie um segundo vértice usando a localização.
  Insira o segundo vértice aos vértices deste polígono after o vértice.

Etapas para que se insira uma string Para uma segunda string antes de um byte#:
  Se a quantidade de caracteres desta string for 0, cancele.
  Isole o byte#.
  Limite o byte# para 1 e a quantidade de caracteres desta segunda string mais 1.
  Lance um subtexto sobre a segunda string. \ left side
  Atribua o caractere inicial deste subtexto mais o byte# menos 2 ao caractere final deste subtexto.
  Lance um segundo subtexto sobre a segunda string. \ right side
  Atribua o caractere inicial deste segundo subtexto mais o byte# menos 1 ao caractere inicial deste segundo subtexto.
  Atribua a quantidade de caracteres desta segunda string mais a quantidade de caracteres desta string a uma quantidade de caracteres agrupados.
  Reassign um endereço de memória usando a quantidade de caracteres agrupados.
  Atribua o endereço de memória ao caractere inicial desse terceiro subtexto.
  Copie pedaços desde o caractere inicial deste subtexto para o caractere inicial deste terceiro subtexto pelo quantidade de caracteres deste subtexto.
  Adicione a quantidade de caracteres deste subtexto para o caractere inicial deste terceiro subtexto.
  Copie pedaços desde o caractere inicial desta string para o caractere inicial deste terceiro subtexto pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o caractere inicial deste terceiro subtexto.
  Copie pedaços desde o caractere inicial deste segundo subtexto para o caractere inicial deste terceiro subtexto pelo quantidade de caracteres deste segundo subtexto.
  Unassign o caractere inicial desta segunda string. \ dont use atribua uma string a uma string para prevent extra allocating e copying
  Atribua o endereço de memória ao caractere inicial desta segunda string.
  Atribua o caractere inicial desta segunda string mais a quantidade de caracteres agrupados menos 1 ao caractere final desta segunda string.

Etapas para que se insira uma string Para um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row menos o cursor de texto número de coluna deste text a um número.
  Atribua a string deste row a uma segunda string.
  Insira a string ao segunda string antes de o cursor de texto número de coluna deste text.
  Converta a segunda string para uns rows.
  Atribua o last destas rows a uma segunda row.
  Insira a rows A as rows deste text antes de a row.
  Remove a row desde as rows deste text.
  Destrua a row.
  Renumere as rows deste text.
  Atribua o número da linha desta segunda row ao número de linhas do cursor deste text.
  Atribua a quantidade de caracteres desta string desta segunda row menos o número ao cursor de texto número de coluna deste text.
  Desvencilhe-se de o text.

Etapas para que se insira uma coisa para uns coisas after uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se a segunda coisa for inexistente, anteponha a coisa para as coisas; volte.
  Insira a coisa a as coisas antes de o next desta segunda coisa.

Etapas para que se insira uma coisa para uns coisas antes de uma segunda coisa:
  Se a coisa for inexistente, cancele.
  Se as coisas estiverem vazio, posponha a coisa para as coisas; volte.
  Se a segunda coisa for inexistente, posponha a coisa para as coisas; volte.
  Se a segunda coisa for o first destas coisas, anteponha a coisa para as coisas; volte.
  Atribua a coisa a uma new coisa.
  Atribua a segunda coisa a uma previous coisa.
  Atribua a new coisa ao next deste previous desta previous coisa.
  Atribua a previous coisa ao next desta new coisa.
  Atribua o previous desta previous coisa ao previous desta new coisa.
  Atribua o new coisa ao previous desta previous coisa.

Etapas para que se insira uns coisas para uns segunda coisas after um coisa:
  Se a coisa for inexistente, anteponha  as coisas para a segunda coisas; volte.
  Insira  as coisas ao segunda coisas antes de o next desta coisa.

Etapas para que se insira uns coisas para uns segunda coisas antes de um coisa:
  Isole o coisa.
  Percorra. [o código abaixo]
    Atribua o first destas coisas a uma segunda coisa.
    Se a segunda coisa for inexistente, cancele.
    Remove a segunda coisa desde as coisas.
    Insira a segunda coisa ao segunda coisas antes de o coisa.
  Repita. [o código acima]

Etapas para que se insira um vértice para um polígono after um segundo vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono after o segundo vértice.

Etapas para que se insira um vértice para um polígono sob uma localização:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um segundo vértice desde os vértices deste polígono.
    Se o segundo vértice for inexistente, cancele.
    Se o next deste segundo vértice for inexistente, cancele.
    Atribua a localização deste segundo vértice e a localização deste next deste segundo vértice a uma linha reta.
    Se a localização não estiver sobre a linha reta, repita.
  Insira o vértice aos vértices deste polígono after o segundo vértice.

Etapas para que se insira um vértice para um polígono antes de um segundo vértice:
  Se o polígono for inexistente, cancele.
  Se o vértice for inexistente, cancele.
  Insira o vértice aos vértices deste polígono antes de o segundo vértice.

Etapas para que se intersect uma caixa com uma segunda caixa usando um terceiro caixa:
  \ caixas does not touch
  Limpe o terceiro caixa.
  Se a coordenada X do canto superior esquerdo desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, cancele.
  Se a coordenada Y do canto superior esquerdo desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, cancele.
  Se a coordenada X do canto inferior direito desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, cancele.
  Se a coordenada Y do canto inferior direito desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, cancele.
  \ caixas touch
  Atribua a caixa ao terceiro caixa.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo desta segunda caixa, atribua a coordenada X do canto superior esquerdo desta segunda caixa à coordenada X do canto superior esquerdo desta terceiro caixa.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo desta segunda caixa, atribua a coordenada Y do canto superior esquerdo desta segunda caixa à coordenada Y do canto superior esquerdo desta terceiro caixa.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito desta segunda caixa, atribua a coordenada X do canto inferior direito desta segunda caixa à coordenada X do canto inferior direito desta terceiro caixa.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito desta segunda caixa, atribua a coordenada Y do canto inferior direito desta segunda caixa à coordenada Y do canto inferior direito desta terceiro caixa.

 \Etapas para que se invert um detector:
\ see "reverse um detector"
\Se o detector for yes, atribua no ao detector; volte.
 \Atribua yes ao detector.

Um Endereço IP é um conjunto com
  Um número, 
  Uma string. 

Um grupo data/hora de criação é uma string.

Um item é um conjunto com
  Uma categoria [pasta, arquivo, etc], \ 
  Um endereço completo, 
  Um endereço da pasta, 
  Um designador, 
  Uma extensão,
  Um size, 
  Um grupo data/hora de criação,
  Um WIN32FINDDATA e 
  Um número identificador.

Etapas para que se jump o cursor de texto left em um text:
  Se o text for inexistente, cancele.
  Mova o cursor de texto left para algum tipo de non-noise pedaço no text.
  Se o cursor de texto número de coluna deste text for 1, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua o caractere inicial desta string desta row mais o cursor de texto número de coluna deste text menos 2 a um endereço de memória do pedaço .
  Se o conteúdo deste endereço de memória do pedaço for alfanumérico, mova o cursor de texto left para algum tipo de non-alfanumérico pedaço no text.
  Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, mova o cursor de texto left para algum tipo de non-symbolic pedaço no text.
  Mova o cursor de texto left para algum tipo de non-noise pedaço no text.

Etapas para que se jump o cursor de texto right em um text:
  Se o text for inexistente, cancele.
  Mova o cursor de texto right para algum tipo de non-noise pedaço no text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o cursor de texto número de coluna deste text é a quantidade de caracteres desta string desta row, cancele.
  Atribua o caractere inicial desta string desta row mais o cursor de texto número de coluna deste text menos 1 a um endereço de memória do pedaço .
  Se o conteúdo deste endereço de memória do pedaço é alfanumérico, mova o cursor de texto right para algum tipo de non-alfanumérico pedaço no text.
  Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, mova o cursor de texto right para algum tipo de non-symbolic pedaço no text.
  Mova o cursor de texto right para algum tipo de non-noise pedaço no text.

Um key é um número.

Um kilobyte é 1024 units.

Um categoria é uma string.

Um lParam é um número.

Um folha modo paisagem é uma folha.

O tamanho de letra grande é um tamanho da letra.

O maior número é 2147483647.

Um mínimo múltiplo comum é um número.

Um clique é um input.

Um left é uns twips.

Uma quantidade de caracteres é uns twips.

Um tamanho da letra é uns twips. \ indicates actual altura of um typical uppercase letra

Uma letra é um pedaço.

O dicionário léxico é uma coisa com um catálogo.

Etapas para que se clareie uma cor por um quantia:
  Adicione o quantia para a luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se clareie uma cor por uns percentual;
Etapas para que se clareie uma cor about uns percentual;
Etapas para que se clareie uma cor por about uns percentual;
Etapas para que se clareie uma cor uns percentual:
  Atribua a luminosidade desta cor mais o percentual à luminosidade desta cor.
  Limite a luminosidade desta cor para 0 e 1000.

Etapas para que se clareie o current cor about uns percentual:
  Clareie a cor deste context pelo percentual.

Etapas para que se clareie um matiz por uns degrees:
  Adicione o degrees para o matiz.

Etapas para que se clareie um matiz por uns points:
  Converta o matiz para uns segunda points.
  Adicione o points para a segunda points.
  Converta a segunda points para o matiz.

Um luminosidade é um número [que vai desde o número 0 até o número 1000].

Etapas para que se limite uma caixa para uma segunda caixa:
  Limite a coordenada X do canto superior esquerdo desta caixa para a coordenada X do canto superior esquerdo desta segunda caixa e a coordenada X do canto inferior direito desta segunda caixa.
  Limite a coordenada Y do canto superior esquerdo desta caixa para a coordenada Y do canto superior esquerdo desta segunda caixa e a coordenada Y do canto inferior direito desta segunda caixa.
  Limite a coordenada X do canto inferior direito desta caixa para a coordenada X do canto superior esquerdo desta segunda caixa e a coordenada X do canto inferior direito desta segunda caixa.
  Limite a coordenada Y do canto inferior direito desta caixa para a coordenada Y do canto superior esquerdo desta segunda caixa e a coordenada Y do canto inferior direito desta segunda caixa.

Etapas para que se limite o cursor de texto em um text:
  Se o text for inexistente, cancele.
  Limite o número de linhas do cursor deste text para 1 e a contagem de linhas deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Limite o cursor de texto número de coluna deste text para 1 e a quantidade de caracteres desta string desta row.

Etapas para que se limite um número para um segundo número e um terceiro número:
  Se o número for menor do que o segundo número, atribua o segundo número ao número; volte.
  Se o número for maior do que o terceiro número, atribua o terceiro número ao número.

Etapas para que se limite a origem of um text:
  Se o text for inexistente, cancele.
  Limite a coordenada X deste text para o menor número e a margem deste text.
  Atribua a contagem de linhas deste text menos 1 times a altura da linha deste text a um número.
  Limite a coordenada Y deste text para - o número e 0.

Etapas para que se limite uma localização para uma caixa:
  Se a coordenada X desta localização for menor do que a coordenada X do canto superior esquerdo desta caixa, atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização.
  Se a coordenada Y desta localização for menor do que a coordenada Y do canto superior esquerdo desta caixa, atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização.
  Se a coordenada X desta localização for maior do que a coordenada X do canto inferior direito desta caixa, atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização.
  Se a coordenada Y desta localização for maior do que a coordenada Y do canto inferior direito desta caixa, atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização.

Etapas para que se limite uns texts para uma contagem:
  Atribua a contagem destes texts a uma segunda contagem.
  Percorra. [o código abaixo]
    Se a segunda contagem for menor do que ou igual à contagem, cancele.
    Atribua o first destes texts a um text.
    Remove o text desde o texts.
    Destrua o text.
    Subtraia 1 desde a segunda contagem.
  Repita. [o código acima]

Uma localização inicial é uma localização.
Uma localização final é uma localização.

Uma linha reta é um conjunto com \ linha, traço, risco, traçado, listra
  Uma localização inicial e 
  Uma localização final.

Etapas para que se liste umas choices em uma caixa;
Etapas para que se pinte umas choices em uma caixa:
  \Pinte really fast. ***
  Obtenha uma [first/next] choice desde as choices.
  Se a choice estiver sumido do mapa [because we have drawn them all], cancele.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais 24 pixels à coordenada X do canto superior esquerdo desta choice.
  Atribua a coordenada X do canto inferior direito desta caixa menos 24 pixels à coordenada X do canto inferior direito desta choice.
  Se a choice for o first desta choice, atribua a coordenada Y do canto superior esquerdo desta caixa mais 24 pixels à coordenada Y do canto superior esquerdo desta choice.
  Se a choice não for o first desta choice, atribua a coordenada Y do canto inferior direito deste previous desta choice à coordenada Y do canto superior esquerdo desta choice.
  Atribua a coordenada Y do canto superior esquerdo desta choice mais 24 pixels à coordenada Y do canto inferior direito desta choice.
  \Pinte a caixa desta choice com a cor púrpura. \ temp ***
  Pinte o nome desta choice na caixa desta choice com a cor deste context.
  Repita. [o código acima]

Etapas para que se liste umas choices em uma caixa com uma cor;
Etapas para que se pinte umas choices em uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Pinte o choices na caixa.

Etapas para que se carregue o dicionário léxico:
  Se o dicionário léxico não for inexistente, cancele.
  Extraia um endereço da pasta desde o endereço completo deste module.
  Percorra. [o código abaixo]
    Se o endereço da pasta estiver em branco, cancele.
    Atribua o endereço da pasta seguido de "dicionário léxico\" a um endereço completo.
    Se o endereço completo estiver no sistema de arquivos, Carregue o dicionário léxico usando o endereço completo; volte.
    Extraia o endereço da pasta desde o endereço da pasta.
  Repita. [o código acima]

Etapas para que se carregue o dicionário léxico usando um trecho:
  Se o dicionário léxico for inexistente, crie o dicionário léxico.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Mova o percorredor (catálogo dicionário léxico rules).
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Catalogue o segmento inicial deste percorredor no catálogo deste dicionário léxico.
  Repita. [o código acima]

Etapas para que se carregue o dicionário léxico usando um endereço completo:
  Obtenha um item desde o endereço completo.
  Se o item não for encontrado, cancele.
  Se a categoria deste item não for "arquivo", repita.
  Read o endereço completo deste item a um trecho.
  Se o erro do fluxo de entrada/saída não estiver em branco, repita.
  Carregue o dicionário léxico usando o trecho.
  Repita. [o código acima]

Etapas para que se localize uma caixa usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a caixa usando o par de números.

Etapas para que se localize uma localização usando um par de números:
  Isole o par de números.
  Negate o par de números.
  Mova a localização usando o par de números.

Etapas para que se lock um gpBitmap usando um BitmapData (24-bit espaço de cor RGB):
  Atribua o gprect deste gpBitmap a um gprect.
  Call "gdiplus.dll" "GdipBitmapLockBits" com
   o gpBitmap 
   e o endereçamento deste gprect 
   e 3 [ImageLockModeRead ou ImageLockModeWrite] 
   e 137224 [PixelFormat24bppRGB] 
   e o endereçamento deste BitmapData.

\Um logbrush é um conjunto com \ documentar
\Um número denominado lbstyle,
\Um código da cor denominado lbcolor,
\Um número denominado lbhatch.

Etapas para que se lowercase qualquer trecho selecionado em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita.
    Lance um subtexto sobre qualquer trecho selecionado na row of o text.
    Lowercase o subtexto.
  Repita. [o código acima]

Etapas para que se lowercase um pedaço:
  \Add 32 to each letter in the string entre "A" and "Z".
  Translate o pedaço usando o tabela de caracteres minúsculos ASCII .

Etapas para que se lowercase o character depois de um finger e atribua it para uma string:
  Se o finger for inexistente, cancele.
  Atribua o conteúdo deste finger à string.
  Lowercase a string.

Etapas para que se lowercase uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Lowercase o conteúdo deste caractere inicial deste subtexto.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se lowercase um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, pare.
    Lowercase a string deste row.
  Repita. [o código acima]
  Wrap o text.

A janela principal do programa é um janela do programa.

Etapas para que se faça uma fração com um número e um segundo número:
  Atribua o número ao numerador desta fração.
  Atribua o segundo número ao denominador desta fração.

Etapas para que se faça um par de números racionais usando uma caixa e uma segunda caixa;
Etapas para que se faça uma par de números fracionários usando uma caixa e uma segunda caixa:
  Atribua o x-extent desta caixa à numerador desta fração deste par de números fracionários.
  Atribua o x-extent desta segunda caixa ao denominador desta fração deste par de números fracionários.
  Atribua o y-extent desta caixa ao numerador desta segunda fração deste par de números fracionários.
  Atribua o y-extent desta segunda caixa ao denominador desta segunda fração deste par de números fracionários.

Um margem é um número.

Etapas para que se cubra internamente uma caixa:
  Crie um hRgn usando a caixa.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente uma elipse:
  Crie um hRgn usando a elipse.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hRgn e 4 [RGN_DIFF].

Etapas para que se cubra internamente um polígono:
  Crie um hRgn usando o polígono.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra internamente uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Cubra internamente o hRgn.
  Destrua o hRgn.

Um mask é um texto hexadecimal.

Etapas para que se cubra somente dentro de uma caixa:
  Exponha tudo.
  Cubra internamente a caixa.

Etapas para que se cubra somente dentro de uma elipse:
  Exponha tudo.
  Cubra internamente a elipse.

Etapas para que se cubra somente dentro de um polígono:
  Exponha tudo.
  Cubra internamente o polígono.

Etapas para que se cubra somente dentro de uma caixa arredondada:
  Exponha tudo.
  Cubra internamente a caixa arredondada.

Etapas para que se cubra somente fora de uma caixa:
  Exponha tudo.
  Cubra externamente a caixa.

Etapas para que se cubra somente fora de uma elipse:
  Exponha tudo.
  Cubra externamente a elipse.

Etapas para que se cubra somente fora de um polígono:
  Exponha tudo.
  Cubra externamente o polígono.

Etapas para que se cubra somente fora de uma caixa arredondada:
  Exponha tudo.
  Cubra externamente a caixa arredondada.

Etapas para que se cubra externamente uma caixa:
  Crie um hRgn usando a caixa.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente uma elipse:
  Crie um hRgn usando a elipse.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hRgn e 1 [RGN_AND].

Etapas para que se cubra externamente um polígono:
  Crie um hRgn usando o polígono.
  Cubra externamente o hRgn.
  Destrua o hRgn.

Etapas para que se cubra externamente uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Cubra externamente o hRgn.
  Destrua o hRgn.

O max text undos é uma contagem igual a 32.

O tamanho de letra médio é um tamanho da letra.

O memory canvas é um canvas.

Etapas para que se minimize um janela do programa:
  Call "user32.dll" "ShowWindow" com 
    A janela do programa 
    e 6 [SW_MINIMIZE].

Etapas para que se mirror o gpBitmap em uma imagem:
  Se a imagem for inexistente, cancele.
  Reverse o mirror detector desta imagem.
  Mirror o gpBitmap desta imagem.

Etapas para que se mirror um GpImage:
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O GpImage 
    e 4 [RotateNoneFlipX].

Etapas para que se mirror uma imagem:
  Se a imagem for inexistente, cancele.
  Atribua a coordenada X deste center desta caixa desta imagem menos a coordenada X deste center desta caixa intacta desta imagem ao número X desse par de números.
  Multiplique o número X deste par de números por 2.
  Mova a caixa intacta desta imagem usando o par de números.
  Mirror o gpBitmap no imagem.

Etapas para que se mova o anchor left para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o anchor número da linha deste text e o text.
  Percorra. [o código abaixo]
    Se o anchor número de coluna deste text for 1, cancele.
    Atribua o caractere inicial desta string desta row mais o anchor número de coluna deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Subtraia 1 desde o anchor número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o cursor de texto para baixo em um text:
  Se o text for inexistente, cancele.
  Adicione 1 para o número de linhas do cursor deste text.
  Limite o cursor de texto no text.

Etapas para que se mova o cursor de texto para baixo one página em um text:
  Se o text for inexistente, cancele.
  Adicione as rows/box deste text para o número de linhas do cursor deste text.
  Subtraia 1 desde o número de linhas do cursor deste text.
  Limite o cursor de texto no text.

Etapas para que se mova o cursor de texto para o first pedaço of o current row of um text:
  Se o text for inexistente, cancele.
  Atribua 1 ao cursor de texto número de coluna deste text.

Etapas para que se mova o cursor de texto para o first pedaço of um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao cursor de texto deste text.

Etapas para que se mova o cursor de texto para o last pedaço of o current row of um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row ao cursor de texto número de coluna deste text.

Etapas para que se mova o cursor de texto para o last pedaço of um text:
  Se o text for inexistente, cancele.
  Atribua a contagem de linhas deste text ao número de linhas do cursor deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua a quantidade de caracteres desta string desta row ao cursor de texto número de coluna deste text.

Etapas para que se mova o cursor de texto left para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o cursor de texto número de coluna deste text for 1, cancele.
    Atribua o caractere inicial desta string desta row mais o cursor de texto número de coluna deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Subtraia 1 desde o cursor de texto número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o cursor de texto left para algum tipo de non-noise pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o cursor de texto número de coluna deste text for 1, cancele.
    Atribua o caractere inicial desta string desta row mais o cursor de texto número de coluna deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for irrelevante, cancele.
    Subtraia 1 desde o cursor de texto número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o cursor de texto left para algum tipo de non-symbolic pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o cursor de texto número de coluna deste text for 1, cancele.
    Atribua o caractere inicial desta string desta row mais o cursor de texto número de coluna deste text menos 2 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for symbolic, cancele.
    Subtraia 1 desde o cursor de texto número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o cursor de texto left em um text:
  Se o text for inexistente, cancele.
  Subtraia 1 desde o cursor de texto número de coluna deste text.
  Limite o cursor de texto no text.

Etapas para que se mova o cursor de texto right para algum tipo de non-alfanumérico pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o cursor de texto número de coluna deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o caractere inicial desta string desta row mais o cursor de texto número de coluna deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for alfanumérico, cancele.
    Adicione 1 para o cursor de texto número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o cursor de texto right para algum tipo de non-noise pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o cursor de texto número de coluna deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o caractere inicial desta string desta row mais o cursor de texto número de coluna deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for irrelevante, cancele.
    Adicione 1 para o cursor de texto número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o cursor de texto right para algum tipo de non-symbolic pedaço em um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Percorra. [o código abaixo]
    Se o cursor de texto número de coluna deste text é a quantidade de caracteres desta string desta row, cancele.
    Atribua o caractere inicial desta string desta row mais o cursor de texto número de coluna deste text menos 1 a um endereço de memória do pedaço .
    Se o conteúdo deste endereço de memória do pedaço não for symbolic, cancele.
    Adicione 1 para o cursor de texto número de coluna deste text.
  Repita. [o código acima]

Etapas para que se mova o cursor de texto right em um text:
  Se o text for inexistente, cancele.
  Adicione 1 para o cursor de texto número de coluna deste text.
  Limite o cursor de texto no text.

Etapas para que se mova o cursor de texto para cima em um text:
  Se o text for inexistente, cancele.
  Subtraia 1 desde o número de linhas do cursor deste text.
  Limite o cursor de texto no text.

Etapas para que se mova o cursor de texto para cima one página em um text:
  Se o text for inexistente, cancele.
  Subtraia as rows/box deste text desde o número de linhas do cursor deste text.
  Adicione 1 para o número de linhas do cursor deste text.
  Limite o cursor de texto no text.

Etapas para que se mova um finger over um número:
  Se o finger for inexistente, cancele.
  Adicione 1 para o finger.

Etapas para que se mova uma imagem para baixo uns twips:
  Mova a imagem usando 0 e os twips.

Etapas para que se mova uma imagem usando um par de números:
  Mova a imagem usando o número X deste par de números e o número Y deste par de números.

Etapas para que se mova uma imagem usando uns x-twips e uns y-twips:
  Se a imagem for inexistente, cancele.
  Mova a caixa desta imagem usando o x-twips e o y-twips.
  Mova a caixa intacta desta imagem usando o x-twips e o y-twips.

Etapas para que se mova uma imagem left uns twips:
  Mova a imagem usando - os twips e 0.

Etapas para que se mova uma imagem right uns twips:
  Mova a imagem usando os twips e 0.

Etapas para que se mova uma imagem para uma localização:
  Se a imagem for inexistente, cancele.
  Obtenha um difference entre a localização e o canto superior esquerdo desta imagem.
  Mova a imagem usando a difference.

Etapas para que se mova uma imagem para cima uns twips:
  Mova a imagem usando 0 e - os twips.

Etapas para que se mova uns squares:
  Mova o square size times o squares dividido por 1 square. \ squares são scaled para cima por precision hence o division sob o end

Etapas para que se mova uns squares diagonally;
Etapas para que se mova uns squares slantways:
  Mova o square size times o squares times o raiz de dois dividido por 1 square. \ squares são scaled para cima por precision hence o division sob o end

Etapas para que se mova um subtexto usando um número:
  Adicione o número para o caractere inicial deste subtexto.
  Adicione o número para o caractere final deste subtexto.

Etapas para que se mova uma coisa desde uns coisas para uns segunda coisas:
  Se a coisa for inexistente, cancele.
  Isole o coisa.
  Remove a coisa desde as coisas.
  Posponha a coisa para a segunda coisas.

Etapas para que se mova uns coisas para uns segunda coisas:
  Atribua o first destas coisas ao first destas segunda coisas.
  Atribua o last destas coisas ao last destas segunda coisas.
  Limpe as coisas.

Etapas para que se mova uma janela do programa left:
  Call "user32.dll" "GetWindowRect" com 
    A janela principal do programa 
    e O endereçamento dessa caixa.
  Subtraia a pixel largura desta tela desde a coordenada X do canto superior esquerdo desta caixa.
  Call "user32.dll" "MoveWindow" com 
    A janela do programa 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A pixel largura desta tela 
    e A pixel altura desta tela 
    e 1.

Etapas para que se mova uma janela do programa right:
  Call "user32.dll" "GetWindowRect" com 
    A janela principal do programa 
    e O endereçamento dessa caixa.
  Adicione a pixel largura desta tela para a coordenada X do canto superior esquerdo desta caixa.
  Call "user32.dll" "MoveWindow" com 
    A janela do programa 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A pixel largura desta tela 
    e A pixel altura desta tela 
    e 1.

Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números racionais;
Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um par de números fracionários:
  Se a imagem for inexistente, cancele.
  Mova a caixa intacta desta imagem usando o par de números fracionários e o canto superior esquerdo desta caixa desta imagem.
  Redimensione a caixa intacta desta imagem usando o par de números fracionários.
  Redimensione a caixa desta imagem usando o par de números fracionários.
  Se a coordenada X do canto inferior direito desta imagem for menor do que a coordenada X do canto superior esquerdo desta imagem, mirror o gpBitmap no imagem.
  Se a coordenada Y do canto inferior direito desta imagem for menor do que a coordenada Y do canto superior esquerdo desta imagem, flip o gpBitmap no imagem.

Etapas para que se redimensione cuidadosamente [sem perder qualidade] uma imagem usando um twip par de números:
  Se a imagem for inexistente, cancele.
  Atribua a caixa desta imagem a uma caixa.
  Redimensione a caixa usando o twip par de números.
  Faça uma par de números fracionários usando a caixa e a caixa desta imagem.
  redimensione cuidadosamente [sem perder qualidade] a imagem usando o par de números fracionários.

Etapas para que se normalize um ângulo:
  Divida o ângulo por 3600 usando um quociente e o ângulo.

Etapas para que se normalize uma caixa:
  Se a coordenada X do canto inferior direito desta caixa for menor do que a coordenada X do canto superior esquerdo desta caixa, permute a coordenada X do canto superior esquerdo desta caixa com a coordenada X do canto inferior direito desta caixa.
  Se a coordenada Y do canto inferior direito desta caixa for menor do que a coordenada Y do canto superior esquerdo desta caixa, permute a coordenada Y do canto superior esquerdo desta caixa com a coordenada Y do canto inferior direito desta caixa.

Etapas para que se normalize um canvas:
  Call "gdi32.dll" "SetGraphicsMode" com 
    O canvas 
    e 2 [GM_ADVANCED].
  Call "gdi32.dll" "SetBkMode" com 
    O canvas 
    e 1 [TRANSPARENT].
  Call "gdi32.dll" "SetMapMode" com 
    O canvas 
    e 8 [MM_ANISOTROPIC ].
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O canvas 
    e 0 
    e 0 
    e nil.
  Call "gdi32.dll" "SetViewportExtEx" com 
    O canvas 
    e O ppi 
    e O ppi 
    e nil.
  Call "gdi32.dll" "SetWindowOrgEx" com 
    O canvas 
    e 0 
    e 0 
    e nil.
  Call "gdi32.dll" "SetWindowExtEx" com 
    O canvas 
    e O tpi 
    e O tpi 
    e nil.

Etapas para que se normalize uma elipse:
  Normalize a caixa desta elipse.

Etapas para que se normalize uma fração e uma segunda fração:
  Obtenha um mínimo múltiplo comum usando o denominador desta fração e o denominador desta segunda fração.
  Multiplique o numerador desta fração pelo mínimo múltiplo comum dividido pelo denominador desta fração.
  Atribua o mínimo múltiplo comum ao denominador desta fração.
  Multiplique o numerador desta segunda fração pelo mínimo múltiplo comum dividido pelo denominador desta segunda fração.
  Atribua o mínimo múltiplo comum ao denominador desta segunda fração.

Etapas para que se normalize uma orientação:
  Divida a orientação por 3840 usando um quociente e um resto.
  Atribua o resto à orientação.
  Se a orientação for menor do que 0, adicione 3840 para a orientação.

Etapas para que se normalize um horizontal linha reta:
  Se a localização final desta linha reta for menor do que a localização inicial desta linha reta, permute a localização final desta linha reta com a localização inicial desta linha reta.

Etapas para que se normalize um matiz:
  Divida o matiz por 3600 usando um quociente e um resto.
  Atribua o resto ao matiz.
  Se o matiz for menor do que 0, adicione 3600 para o matiz.

Etapas para que se normalize uma imagem:
  Se a imagem for inexistente, cancele.
  Normalize a caixa desta imagem.
  Normalize a caixa intacta desta imagem.

Etapas para que se normalize uma seleção:
  Se o anchor número da linha desta seleção for menor do que o número de linhas do cursor desta seleção, cancele.
  Se o anchor número da linha desta seleção for maior do que o número de linhas do cursor desta seleção, permute o anchor desta seleção com o cursor de texto desta seleção; volte.
  Se o anchor número de coluna desta seleção for maior do que o cursor de texto número de coluna desta seleção, permute o anchor número de coluna desta seleção com o cursor de texto número de coluna desta seleção.

Etapas para que se normalize um text:
  Se o text for inexistente, cancele.
  Normalize a caixa deste text.

Etapas para que se normalize um vertical linha reta:
  Se a localização final desta linha reta for menor do que a localização inicial desta linha reta, permute a localização final desta linha reta com a localização inicial desta linha reta.

O null hBrush é um hBrush.

O null hPen é um hPen.

Etapas para que se termine com o caractere NULL uma string:
  Atribua a quantidade de caracteres desta string a uma quantidade de caracteres armazenados.
  Reassign o caractere inicial desta string usando a quantidade de caracteres armazenados mais 1.
  Atribua o caractere inicial desta string mais a quantidade de caracteres armazenados menos 1 ao caractere final desta string.
  Atribua o caractere final desta string mais 1 a um endereço de memória do pedaço .
  Atribua o caractere null ao conteúdo deste endereço de memória do pedaço.

Etapas para que se termine com o caractere NULL uma string composta de caracteres amplos:
  Atribua a quantidade de caracteres deste string composta de caracteres amplos a uma quantidade de caracteres armazenados.
  Reassign o caractere inicial desta string composta de caracteres amplos usando a quantidade de caracteres armazenados mais 2.
  Atribua o caractere inicial desta string composta de caracteres amplos mais a quantidade de caracteres armazenados menos 1 ao last deste string composta de caracteres amplos.

Um offset é um número.

Uma operação é uma string.

Uma origem é uma localização.

Etapas para que se outdent algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Se a row of o text não estiver selecionado, repita. \selecionada
    Se o conteúdo deste caractere inicial desta string desta row for o caractere de espaço, remove o first pedaço desde a string deste row.
    Se o conteúdo deste caractere inicial desta string desta row for o caractere de espaço, remove o first pedaço desde a string deste row.
  Repita. [o código acima]

Um outdent é um número.

Etapas para que se outline uma caixa com uma cor:
  Pinte a caixa com a cor e a cor preta.

  
Um x-offset é um offset.
Um y-offset é um offset.

Etapas para que se output o arco of uma elipse usando uma string: \\ interessante.
  Atribua 2761/10000 a um fração. \ (sqrt(2) -1 ) * (2/3)   = 0,2761423749153967
  Atribua o center desta elipse a um center localização.
  Atribua o x-extent desta elipse dividido por 2 a um half largura.
  Atribua o y-extent desta elipse dividido por 2 a um half altura.
  Atribua o x-extent desta elipse times a fração a um x-offset.
  Atribua o y-extent desta elipse times a fração a um y-offset.
  \ control point 1
  Se a string for "canto superior esquerdo", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y deste center menos o y-offset a um first control localização.
  Se a string for "canto superior direito", atribua a coordenada X deste center mais o x-offset e a coordenada Y do canto superior esquerdo desta elipse ao first control localização.
  Se a string for "canto inferior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y deste center mais o y-offset ao first control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X deste center menos o x-offset e a coordenada Y do canto inferior direito desta elipse ao first control localização.
  \ control point 2
  Se a string for "canto superior esquerdo", atribua a coordenada X deste center menos o x-offset e a coordenada Y do canto superior esquerdo desta elipse a um second control localização.
  Se a string for "canto superior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y deste center menos o y-offset ao second control localização.
  Se a string for "canto inferior direito", atribua a coordenada X deste center mais o x-offset e a coordenada Y do canto inferior direito desta elipse ao second control localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y deste center mais o y-offset ao second control localização.
  \ ending point
  Se a string for "canto superior esquerdo", atribua a coordenada X do canto superior esquerdo desta elipse mais o half largura e a coordenada Y do canto superior esquerdo desta elipse a um ending localização.
  Se a string for "canto superior direito", atribua a coordenada X do canto inferior direito desta elipse e a coordenada Y do canto superior esquerdo desta elipse mais o half altura ao ending localização.
  Se a string for "canto inferior direito", atribua a coordenada X do canto inferior direito desta elipse menos o half largura e a coordenada Y do canto inferior direito desta elipse ao ending localização.
  Se a string for "canto inferior esquerdo ", atribua a coordenada X do canto superior esquerdo desta elipse e a coordenada Y do canto inferior direito desta elipse menos o half altura ao ending localização.
  \ spit it out
  Output o first control localização sem passar pra próxima linha.
  Output o second control localização sem passar pra próxima linha.
  Output o ending localização sem passar pra próxima linha.
  Output "c".

Etapas para que se output uma cor sem passar pra próxima linha:
  Converta a cor para um espaço de cor RGB.
  Atribua o espectro vermelho deste espaço de cor RGB / 255 a um fração.
  Converta a fração para um red string usando 4.
  Atribua o espectro verde deste espaço de cor RGB / 255 à fração.
  Converta a fração para um green string usando 4.
  Atribua o espectro azul deste espaço de cor RGB / 255 à fração.
  Converta a fração para um blue string usando 4.
  Output o red string seguido de " " junto com o green string seguido de " " junto com o blue string sem passar pra próxima linha.

Etapas para que se output lineto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "l".

Etapas para que se output lineto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output lineto usando a localização.

Etapas para que se output moveto usando uma localização:
  Output a localização sem passar pra próxima linha.
  Output "m".

Etapas para que se output moveto usando um número X e um número Y:
  Atribua o número X e o número Y a uma localização.
  Output moveto usando a localização.

Etapas para que se output um número sem passar pra próxima linha:
  Converta o número para uma string.
  Output a string sem passar pra próxima linha.
  Output " " sem passar pra próxima linha.

Etapas para que se output stroke e preencha usando uma cor da borda e uma cor de preenchimento:
  Atribua "B" a uma string. \ stroke e preencha
  Se a cor de preenchimento estiver clear, atribua "S" à string. \ stroke
  Se a cor da borda estiver clear, atribua "f" à string. \ preencha
  Output a string.

\Um paintstruct é um conjunto com
\Um hDC denominado hDC,
\Um número denominado ferase,
\Um caixa denominado rcpaint,
\Um número denominado frestore,
\Um número denominado fincupdate,
\  32 pedaços.

Um número X é um número.
Um número Y é um número.

Um par de números é um conjunto com 
  Um número X e 
  Um número Y.

Um endereçamento de caractere é um endereço de memória do pedaço.

Um pdevmode é um endereço de memória para um devmode.

Etapas para que se escolha aleatoriamente um número within um quantia of um segundo número:
  Escolha aleatoriamente o número entre o segundo número menos o quantia e o segundo número mais o quantia.
  Atribua o número ao número deste context.

Uma imagem é uma coisa com \FIGURA?
\ as caixas estão em twits
Um caixa [location of cropped imagem sobre a página], 
Um caixa intacta [location of entire imagem sobre a página],
Um grayscale detector,
Um mirror detector,
Um ângulo de rotação, \ rotation é clockwise
Um texto hexadecimal denominado data [original pedaços em original format],
Um gpBitmap.

Etapas para que se toque um wave:
  Call "winmm.dll" "PlaySound" com 
    O first  endereço de memória do pedaço desta wave 
    e 0 
    e 5 [SND_MEMORY+SND_ASYNC].

Etapas para que se toque um wave e wait:
  Call "winmm.dll" "PlaySound" com 
    O first  endereço de memória do pedaço  desta wave 
    e 0 
    e 4 [SND_MEMORY+SND_SYNC].

Etapas para que se toque um wave file:
  Isole o wave file.
  Termine com o caractere NULL o wave file.
  Call "winmm.dll" "PlaySound" com 
    O first  endereço de memória do pedaço deste wave file 
    e 0 
    e 131073 [snd_filename+snd_async].

Etapas para que se toque um wave file e wait:
  Isole o wave file.
  Termine com o caractere NULL o wave file.
  Call "winmm.dll" "PlaySound" com 
    O first  endereço de memória do pedaço deste wave file 
    e 0 
    e 131072 [snd_filename+snd_sync].

Etapas para que se anteponha uma coisa para uns coisas:
  Se a coisa for inexistente, cancele.
  Atribua o first destas coisas ao next desta coisa.
  Se  as coisas não for vazio, atribua a coisa ao previous deste first destas coisas.
  Se  as coisas estiverem vazio, atribua a coisa ao last destas coisas.
  Atribua a coisa ao first destas coisas.

\Etapas para que se anteponha uns coisas para umas segunda coisas:
\ bug encontrado por Mike Gonta - corrected version debaixo of
\Obtenha uma coisa desde  as coisas (backwards).
\Se a coisa for inexistente, cancele.
\Remove a coisa desde as coisas.
\Anteponha a coisa para a segunda coisas.
\Repita. [o código acima]

Etapas para que se anteponha uns coisas para umas segunda coisas:
  Atribua o last destas coisas a uma coisa.
  Se a coisa for inexistente, cancele.
  Remove a coisa desde as coisas.
  Anteponha a coisa para a segunda coisas.
  Repita. [o código acima]

Um process é um número identificador.

Um process endereço de memória é um endereço de memória para um process.

Um punch linha reta é uma string.

Etapas para que se atribua o character depois de um finger para um character:
  Se o finger for inexistente, limpe o character; volte.
  Atribua o conteúdo deste finger ao character.

Etapas para que se atribua um date/time para uma segunda date/time:
  Atribua o year deste date/time ao year desta segunda date/time.
  Atribua o month deste date/time ao month desta segunda date/time.
  Atribua o week day deste date/time ao week day segunda date/time.
  Atribua o day deste date/time ao day desta segunda date/time.
  Atribua a hour deste date/time à hour desta segunda date/time.
  Atribua o minute deste date/time ao minute desta segunda date/time.
  Atribua o second deste date/time ao second desta segunda date/time.
  Atribua o millisecond deste date/time ao millisecond desta segunda date/time.

Etapas para que se atribua a string dessa date/time para uma string:
  Limpe a string.
  Posponha o year deste date/time para a string.
  Posponha "/" para a string.
  Zero preencha o month deste date/time usando 2 e posponha it para a string.
  Posponha "/" para a string.
  Zero preencha o day deste date/time usando 2 e posponha it para a string.
  Posponha " " para a string.
  Zero preencha a hour deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero preencha o minute deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero preencha o second deste date/time usando 2 e posponha it para a string.
  Posponha ":" para a string.
  Zero preencha o millisecond deste date/time usando 3 e posponha it para a string.

Etapas para que se atribua um finger sobre o first character of uma string:
  Atribua o caractere inicial desta string ao finger.

Etapas para que se atribua a contagem desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
  Obtenha um bucket usando o catálogo.
  Se o bucket for inexistente, cancele.
  Adicione a contagem destes refers deste bucket para a contagem.
  Repita. [o código acima]

Etapas para que se atribua a used contagem de buckets desse catálogo para uma contagem:
  Atribua 0 à contagem.
  Se o catálogo for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, cancele.
    Se os refers deste bucket estiverem vazio, repita.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se atribua um número para um word big-endian unsigned:
  Atribua o número a um word.
  Atribua a word ao word big-endian unsigned.

Etapas para que se atribua um número para uma string;
Etapas para que se converta um número para uma string:
  Limpe a string.
  Isole o número.
  De-sign o número.
  Percorra. [o código abaixo]
    Divida o número por 10 usando um quociente e um resto.
    Adicione 48 para o resto.
    Atribua o resto a um pedaço.
    Anteponha o pedaço para a string.
    Se o quociente for 0, pare.
    Atribua o quociente ao número.
  Repita. [o código acima]
  Se o original número for menor do que 0, anteponha o hífem para a string.

Etapas para que se atribua um número sobre o stack:
  Converta o número para um segmento inicial.
  Atribua o segmento inicial sobre o stack.

Etapas para que se atribua o absolute value desse número para um segundo número:
  Atribua o número ao segundo número.
  De-sign o segundo número.

Etapas para que se atribua um OutlineTextmetric para uma segunda OutlineTextmetric:
  Copie pedaços desde o endereçamento deste OutlineTextmetric para o endereçamento desta segunda OutlineTextmetric pela magnitude deste OutlineTextmetric.

Etapas para que se atribua o absolute value desse par de números para um segundo par de números:
  Atribua o par de números ao segundo par de números.
  De-sign o segundo par de números.

\ unclear why this does not get called properly when I replace hoja apaisada com caja ***

Etapas para que se atribua uma imagem no middle of uma caixa;
Etapas para que se centralize uma imagem em uma caixa:
  Se a imagem for inexistente, cancele.
  Centralize a imagem na caixa (horizontalmente).
  Centralize a imagem na caixa (verticalmente).

Etapas para que se atribua uma imagem sobre uma localização;
Etapas para que se centralize uma imagem sobre uma localização:
  Se a imagem for inexistente, cancele.
  Obtenha um difference entre a localização e o center desta caixa desta imagem.
  Arredonde a difference para o múltiplo imediato of a quantidade de twips/pixel .
  Mova a imagem usando a difference.

Etapas para que se atribua o working string dessa row para um subtexto:
  Se a row for inexistente, limpe o subtexto; volte.
  Lance o subtexto sobre a string deste row.
  Subtraia 1 desde o caractere final deste subtexto.

Etapas para que se atribua uma seleção para uma segunda seleção:
  Atribua o anchor desta seleção ao anchor desta segunda seleção.
  Atribua o cursor de texto desta seleção ao cursor de texto desta segunda seleção.

Etapas para que se atribua um sockaddr para uma segunda sockaddr:
  Copie pedaços desde o endereçamento deste sockaddr para o endereçamento desta segunda sockaddr pela magnitude deste sockaddr.

Etapas para que se atribua uma string para uma letra:
  Atribua o conteúdo deste caractere inicial desta string à letra.

Etapas para que se atribua uma string para um text:
  Se o text for inexistente, cancele.
  Destrua as rows deste text.
  Reset a origem of o text.
  Reset o cursor de texto of o text.
  Desvencilhe-se de o text.
  Isole a string.
  Posponha o retorno de carro para a string.
  Converta a string para as rows deste text.
  Wrap o text.

Etapas para que se atribua uma string sobre o área de transferência do Windows:
  Call "user32.dll" "OpenClipboard" com 
    A janela principal do programa.
  Call "user32.dll" "EmptyClipboard".
  Atribua a quantidade de caracteres desta string mais 1 a um número.
  Call "kernel32.dll" "GlobalAlloc" com 
  66 [GHND - 0x0042 - unifica GMEM_MOVEABLE e GMEM_ZEROINIT.] 
    e O número 
    devolvendo um número identificador.
  Call "kernel32.dll" "GlobalLock" com 
    O número identificador 
    devolvendo um endereço de memória.
  Copie pedaços desde o caractere inicial desta string para o endereço de memória pelo quantidade de caracteres desta string.
  Call "kernel32.dll" "GlobalUnlock" com 
    O número identificador.
  Call "user32.dll" "SetClipboardData" com 
  1 [CF_TEXT] 
    e O número identificador.
  Call "user32.dll" "CloseClipboard".

Etapas para que se atribua a largura dessa string para uma largura:
  \Consegui traduzir como:
  \Etapas para que se atribua uma largura desse string para uma segunda largura:
  Obtenha a largura usando a string e o memory canvas e a fonte padrão.

\\leave out - causes Spanish string atribuas para resolva here instead of "Atribua uma string a uma segunda string"
Etapas para que se atribua um subtexto para um segundo subtexto:
  Copie pedaços desde o endereçamento deste subtexto para o endereçamento deste segundo subtexto pela magnitude deste subtexto.

Etapas para que se atribua o date/time do system para um date/time:
  Call "kernel32.dll" "GetLocalTime" com o endereçamento desse SYSTEMTIME.
  Atribua o wYear deste SYSTEMTIME ao year deste date/time.
  Atribua o wMonth deste SYSTEMTIME ao month deste date/time.
  Atribua o wDayOfWeek deste SYSTEMTIME ao week day deste date/time.
  Atribua o wDay deste SYSTEMTIME ao day deste date/time.
  Atribua o wHour deste SYSTEMTIME à hour deste date/time.
  Atribua o wMinute deste SYSTEMTIME ao minute deste date/time.
  Atribua o wSecond deste SYSTEMTIME ao second deste date/time.
  Atribua os wMilliseconds deste SYSTEMTIME ao millisecond deste date/time.

Etapas para que se atribua o last erro do system para um número:
  Call "kernel32.dll" "GetLastError" devolvendo o número.

Etapas para que se atribua o last winsock erro do system para um número:
  Call "ws2_32.dll" "WSAGetLastError" devolvendo o número.

Etapas para que se atribua a contagem de intervalos do sistema para uns intervalos:
  \ wraps cada 24.8 days ou so
  Call "kernel32.dll" "GetTickCount" devolvendo os intervalos.
  Conjuncione logicamente os intervalos com o maior número.

Etapas para que se atribua um terminal no middle of uma caixa;
Etapas para que se centralize um terminal em uma caixa:
  Isole a caixa.
  Indent a caixa 24 px.
  Atribua a caixa à caixa deste terminal.

Etapas para que se atribua um text no middle of uma caixa;
Etapas para que se centralize um text em uma caixa:
  Se o text for inexistente, cancele.
  Centralize o text na caixa (horizontalmente).
  Centralize o text na caixa (verticalmente).

Etapas para que se atribua um text sobre uma localização;
Etapas para que se centralize um text sobre uma localização:
  Se o text for inexistente, cancele.
  Obtenha um difference entre a localização e o center desta caixa deste text.
  Arredonde a difference para o múltiplo imediato of a quantidade de twips/pixel .
  Mova o text usando a difference.

Etapas para que se atribua a first linha reta desse text para uma string:
  Se o text for inexistente, limpe a string; volte.
  Atribua a string desta first row deste text à string.
  Remove o last pedaço desde a string.

Etapas para que se atribua a first non-em branco linha reta desse text para uma string:
  \ *** new
  Limpe a string.
  Se o text for inexistente, cancele.
  Percorra. [o código abaixo]
    Obtenha uma row desde as rows deste text.
    Se a row for inexistente, cancele.
    Atribua a string deste row à string.
    Remove o last pedaço desde a string. \ cr ou space (see text rules)
    Remove algum tipo de leading noise desde a string.
    Remove algum tipo de trailing noise desde a string.
  Se a string estiver em branco, repita.
  \Se a string não estiver em branco, pare.

Etapas para que se atribua a globalized origem desse text para uma localização:
  Se o text for inexistente, limpe a localização; volte.
  Atribua a origem deste text à localização.
  Globalize a localização usando o canto superior esquerdo deste text.

Etapas para que se atribua a malha desse text para uma malha:
  Se o text for inexistente, limpe a malha; volte.
  Atribua a altura desta font deste text times 4 ao número X desta malha.
  Atribua a altura desta font deste text ao número Y desta malha.

Etapas para que se atribua a normalized seleção desse text para uma seleção:
  Se o text for inexistente, cancele.
  Atribua a seleção deste text à seleção.
  Normalize a seleção.

Etapas para que se atribua a contagem de linhas desse text para uma contagem:
  Se o text for inexistente, atribua 0 à contagem; volte.
  Se as rows deste text estiverem vazio, atribua 0 à contagem; volte.
  Atribua o número da linha deste last destas rows deste text à contagem.

Etapas para que se atribua a altura da linha desse text para uma altura:
  Se o text for inexistente, atribua 0 ao altura; volte.
  Atribua a altura desta font deste text ao altura.

Etapas para que se atribua a rows/box desse text para uma contagem:
  Se o text for inexistente, atribua 0 à contagem; volte.
  Atribua a altura desta caixa deste text dividido pela altura da linha deste text à contagem.

Etapas para que se atribua a quantidade de caracteres selecionados desse text para uma contagem:
  Atribua 0 à contagem.
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Percorra. [o código abaixo]
  Obtenha uma row desde as rows deste text.
  Se a row for inexistente, cancele.
  Lance um subtexto sobre qualquer trecho selecionado na row of o text.
  Adicione a quantidade de caracteres deste subtexto para a contagem.
  Repita. [o código acima]

Etapas para que se atribua a selecionado contagem de linhas desse text para uma contagem:
  Atribua 0 à contagem.
  Se o text for inexistente, cancele.
  Atribua a normalized seleção deste text a uma seleção.
  Se o anchor número da linha desta seleção é o número de linhas do cursor desta seleção, cancele.
  Atribua o número de linhas do cursor desta seleção à contagem.
  Subtraia o anchor número da linha desta seleção desde a contagem.
  Se o cursor de texto número de coluna desta seleção não for 1, adicione 1 para a contagem.

Etapas para que se atribua o painel de informações string desse text para uma string:
  Se o text for inexistente, limpe a string; volte.
  Atribua a selecionado contagem de linhas deste text a uma contagem.
  Se a contagem não for 0, format a contagem e "linha selecionada" ou "linhas selecionadas" à string; volte.
  Atribua a quantidade de caracteres selecionados deste text a uma segunda contagem.
  Se a segunda contagem não for 0, format a segunda contagem e "pedaço" ou "pedaços" à string; volte.
  Converta o número de linhas do cursor deste text para a string.
  Posponha ":" para a string.
  Posponha o cursor de texto número de coluna deste text para a string.

Etapas para que se atribua uma coisa sob o end of uns coisas;
Etapas para que se posponha uma coisa para uns coisas:
  Se a coisa for inexistente, cancele.
  Atribua o last destas coisas ao previous desta coisa.
  Se as coisas não estiverem vazio, atribua a coisa ao next deste last destas coisas.
  Se as coisas estiverem vazio, atribua a coisa ao first destas coisas.
  Atribua a coisa ao last destas coisas.

Etapas para que se atribua umas coisas para umas segunda coisas:
  Atribua o first destas coisas ao first destas segunda coisas.
  Atribua o last destas coisas ao last destas segunda coisas.

Etapas para que se atribua a contagem dessas coisas  para uma contagem:
  Atribua 0 à contagem.
  Percorra. [o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a coisa for inexistente, cancele.
    Adicione 1 para a contagem.
  Repita. [o código acima]

Etapas para que se atribua um temporizador para uma string;
Etapas para que se converta um temporizador para uma string:
  Converta os intervalos deste temporizador para a string.

Etapas para que se atribua a string desse temporizador para uma string:
  Converta os intervalos deste temporizador para a string.

Etapas para que se atribua os intervalos desse temporizador para uns intervalos:
  Atribua os intervalos totais deste temporizador aos intervalos.
  Se a contagem deste temporizador for 0, cancele.
  Atribua a contagem de intervalos do sistema a uns intervalos de temporização. 
  Subtraia os intervalos iniciais deste temporizador desde os intervalos de temporização.
  Adicione os intervalos de temporização para os intervalos.

Etapas para que se atribua um segmento inicial sobre o stack:
  Aloque memória para um stack entry.
  Atribua o segmento inicial à string desta stack entry.
  Anteponha o stack entry para o stack.

Etapas para que se quit;
Etapas para que se relinquish control:
  Desmanche a fila de eventos.
  Crie um event.
  Atribua "fechamento do programa" à categoria deste event.
  Enfileire o event.

Um quora é uma coisa com \ quora é abreviação de "question or answer"
  uma string e 
  uma cor. 

Etapas para que se quote uma string:
  \ inserts leading, trailing e nested double-quotes
  Atribua as aspas duplas a uma segunda string.
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, pare.
    Posponha o conteúdo deste caractere inicial deste subtexto para a segunda string.
    Se o conteúdo deste caractere inicial deste subtexto for as aspas duplas, posponha as aspas duplas para a segunda string.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]
  Posponha as aspas duplas para a segunda string.
  Atribua a segunda string à string.



Etapas para que se atualize a tela usando uma caixa:
  Call "gdi32.dll" "BitBlt" com 
    O tela canvas 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e A largura desta caixa 
    e A altura desta caixa 
    e O quadro atual 
    e A coordenada X do canto superior esquerdo desta caixa 
    e A coordenada Y do canto superior esquerdo desta caixa 
    e 13369376 [SRCCOPY].

Etapas para que se relembre um text:
  Se o text for inexistente, cancele.
  Destrua os redos deste text.
  Copie o text a um segundo text.
  Redimensione proporcionalmente o segundo text para 1/1.
  Posponha o segundo text para os undos deste text.
  Limite os undos deste text para o max text undos.
  Ligue o detector de alteração deste text.

Etapas para que se relembre um text com um operação:
  Se o text for inexistente, cancele.
  Se o última operação deste text for a operação, acione o detector de alteração deste text; volte.
  Relembre o text.
  Atribua o operação à última operação deste text.

Etapas para que se relembre where we are:
  Salve o context.

Etapas para que se remove qualquer trecho selecionado em um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Atribua a seleção deste text a uma seleção.
  Normalize a seleção.
  Obtenha uma row usando o anchor número da linha desta seleção e o text.
  Lance um subtexto sobre a string deste row.
  Atribua o caractere inicial deste subtexto mais o anchor número de coluna desta seleção menos 2 ao caractere final deste subtexto.
  Obtenha uma segunda row usando o número de linhas do cursor desta seleção e o text.
  Lance um segundo subtexto sobre a string desta segunda row.
  Atribua o caractere inicial deste segundo subtexto mais o cursor de texto número de coluna desta seleção menos 1 ao caractere inicial deste segundo subtexto.
  Atribua o subtexto junto com o segundo subtexto à string desta row.
  Remove as rows of o text entre o next desta row e a segunda row.
  Atribua o anchor desta seleção ao cursor de texto deste text.
  Desvencilhe-se de o text.

Etapas para que se remova pedaços de um text (backspace over um return):
  Se o text for inexistente, cancele.
  Se o número de linhas do cursor deste text for 1, cancele.
  Obtenha uma row usando o número de linhas do cursor deste text menos 1 e o text.
  Atribua a quantidade de caracteres desta string desta row e o número de linhas do cursor deste text menos 1 ao cursor de texto deste text.
  Remove qualquer trecho selecionado no text.

Etapas para que se remova pedaços de um text (backspace com jump):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove qualquer trecho selecionado no text; volte.
  Se o cursor de texto número de coluna deste text for 1, remova pedaços de o text (backspace over um return); volte.
  Jump o cursor de texto left no text.
  Remove qualquer trecho selecionado no text.

Etapas para que se remova pedaços de um text (backspace):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove qualquer trecho selecionado no text; volte.
  Se o cursor de texto número de coluna deste text for 1, remova pedaços de o text (backspace over um return); volte.
  Mova o cursor de texto left no text.
  Remove qualquer trecho selecionado no text.

Etapas para que se remova pedaços de um text (forward delete um return):
  Se o text for inexistente, cancele.
  Se o número de linhas do cursor deste text for a contagem de linhas deste text, cancele.
  Atribua 1 e o número de linhas do cursor deste text mais 1 ao cursor de texto deste text.
  Remove qualquer trecho selecionado no text.

Etapas para que se remova pedaços de um text (forward delete com jump):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove qualquer trecho selecionado no text; volte.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o cursor de texto número de coluna deste text é a quantidade de caracteres desta string desta row, remova pedaços de o text (forward delete um return); volte.
  Jump o cursor de texto right no text.
  Remove qualquer trecho selecionado no text.

Etapas para que se remova pedaços de um text (forward delete):
  Se o text for inexistente, cancele.
  Se something estiver selecionado no text, remove qualquer trecho selecionado no text; volte.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Se o cursor de texto número de coluna deste text é a quantidade de caracteres desta string desta row, remova pedaços de o text (forward delete um return); volte.
  Mova o cursor de texto right no text.
  Remove qualquer trecho selecionado no text.

Etapas para que se remove cada pedaço em um text:
  Se o text for inexistente, cancele.
  Atribua "" ao text.

Etapas para que se remove o first pedaço desde uma string:
  Lance um subtexto sobre o first pedaço of a string.
  Remova pedaços de a string usando o subtexto.

   
Etapas para que se remove o last pedaço desde uma string:
  Lance um subtexto sobre o last pedaço of a string.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove os last dois pedaços desde uma string:
  Remove trailing pedaços desde a string usando 2.

Etapas para que se remove leading pedaços desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; volte.
  Lance um subtexto sobre o first pedaço of a string.
  Atribua o caractere inicial deste subtexto mais a contagem menos 1 ao caractere final deste subtexto.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove leading noise desde uma string;
Etapas para que se remove algum tipo de leading noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste caractere inicial desta string não for irrelevante, cancele.
  Remove o first pedaço desde a string.
  Repita. [o código acima]

Etapas para que se remove a rows of um text entre uma row e uma segunda row:
  Se o text for inexistente, cancele.
  Se a row for inexistente, cancele.
  Se a segunda row for inexistente, cancele.
  Se o número da linha desta row for maior do que o número da linha desta segunda row, cancele.
  Isole a row.
  Atribua o next desta segunda row a uma stop row.
  Percorra. [o código abaixo]
    Se a row for a stop row, pare.
    Atribua o next desta row a uma next row.
    Remove a row desde as rows deste text.
    Destrua a row.
    Atribua o next row à row.
  Repita. [o código acima]
  Renumere as rows deste text.

Etapas para que se remove uma coisa desde uns coisas:
  Se a coisa for inexistente, cancele.
  Se a coisa for o first destas coisas, atribua o next desta coisa ao first destas coisas.
  Se a coisa for o last destas coisas, atribua o previous desta coisa ao last destas coisas.
  Se o next desta coisa não for inexistente, atribua o previous desta coisa ao previous deste next desta coisa.
  Se o previous desta coisa não for inexistente, atribua o next desta coisa ao next deste previous desta coisa.
  Esvazie o next desta coisa.
  Esvazie o previous desta coisa.

Etapas para que se remove trailing pedaços desde uma string usando uma contagem:
  Isole a contagem.
  Se a contagem for maior do que a quantidade de caracteres desta string, limpe a string; volte.
  Lance um subtexto sobre o last pedaço of a string.
  Atribua o caractere final deste subtexto menos a contagem mais 1 ao caractere inicial deste subtexto.
  Remova pedaços de a string usando o subtexto.

Etapas para que se remove trailing noise desde uma string;
Etapas para que se remove algum tipo de trailing noise desde uma string:
  Se a string estiver em branco, cancele.
  Se o conteúdo deste caractere final desta string não for irrelevante, cancele.
  Remove o last pedaço desde a string.
  Repita. [o código acima]

Etapas para que se rename um endereço completo para um segundo endereço completo no sistema de arquivos:
  Isole o endereço completo.
  Remove algum tipo de trailing barra invertida desde o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Isole o segundo endereço completo.
  Remove algum tipo de trailing barra invertida desde o segundo endereço completo.
  Termine com o caractere NULL o segundo endereço completo.
  Call "kernel32.dll" "MoveFileA" com 
    O caractere inicial deste endereço completo 
    e O caractere inicial deste segundo endereço completo 
    devolvendo um número.
  Limpe o erro do fluxo de entrada/saída.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro ao renomear o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se renumere uns rows:
  Obtenha uma row desde a rows.
  Se a row for inexistente, cancele.
  Adicione 1 para um número da linha.
  Atribua o número da linha ao número da linha desta row.
  Repita. [o código acima]

Etapas para que se replace um pedaço com um segundo pedaço em uma string:
  Lance um subtexto sobre a string.
  Percorra. [o código abaixo]
    Se o subtexto estiver em branco, cancele.
    Se o conteúdo deste caractere inicial deste subtexto não for o pedaço, adicione 1 para o caractere inicial deste subtexto; repita.
    Atribua o segundo pedaço ao conteúdo deste caractere inicial deste subtexto.
    Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

A reply é uma reply.

Uma reply é uma string.

Etapas para que se reenfileire um event:
  Copie o event a um segundo event.
  Enfileire o segundo event.

Etapas para que se reset o alphabet:
  Atribua o 'A' maiúsculo ao next letra.

Etapas para que se reset o cursor de texto of um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao cursor de texto deste text.

Etapas para que se reset o context:
  Restaure o context.
  Salve o context.

Etapas para que se reset uma contagem:
  Atribua 0 à contagem.

Etapas para que se reset o drawing origem:
  Defina o drawing origem para o zero localização.

Etapas para que se reset um detector:
  Desative o detector.

Etapas para que se reset a origem of um text:
  Se o text for inexistente, cancele.
  Atribua a margem deste text à coordenada X deste text.
  Atribua 0 à coordenada Y deste text.

Etapas para que se reset um temporizador:
  Atribua 0 à contagem deste temporizador.
  Atribua 0 aos intervalos iniciais deste temporizador.
  Atribua 0 aos intervalos totais deste temporizador.

Etapas para que se redimensione uma caixa usando um par de números racionais;
Etapas para que se redimensione uma caixa usando uma par de números fracionários:
  Atribua o x-extent desta caixa a uma largura.
  Atribua o y-extent desta caixa a uma altura.
  Redimensione proporcionalmente a largura usando a fração deste par de números fracionários.
  Redimensione proporcionalmente a altura usando a segunda fração deste par de números fracionários.
  Atribua a coordenada X do canto superior esquerdo desta caixa mais a largura à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada Y do canto superior esquerdo desta caixa mais a altura à coordenada Y do canto inferior direito desta caixa.

Etapas para que se redimensione uma caixa usando um twip par de números:
  Adicione o número X deste twip par de números para a coordenada X do canto inferior direito desta caixa.
  Adicione o número Y deste twip par de números para a coordenada Y do canto inferior direito desta caixa.

Etapas para que se redimensione uma elipse usando um par de números racionais;
Etapas para que se redimensione uma elipse usando uma par de números fracionários:
  Redimensione a caixa desta elipse usando o par de números fracionários.

Etapas para que se redimensione uma elipse usando um twip par de números:
  Redimensione a caixa desta elipse usando o twip par de números.

Etapas para que se redimensione uma linha reta usando um par de números racionais;
Etapas para que se redimensione uma linha reta usando uma par de números fracionários:
  Atribua a caixa desta linha reta a uma caixa.
  Subtraia o canto superior esquerdo desta caixa desde a localização inicial desta linha reta.
  Redimensione proporcionalmente a localização inicial desta linha reta usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para a localização inicial desta linha reta.
  Subtraia o canto superior esquerdo desta caixa desde a localização final desta linha reta.
  Redimensione proporcionalmente a localização final desta linha reta usando o par de números fracionários.
  Adicione o canto superior esquerdo desta caixa para a localização final desta linha reta.

Etapas para que se redimensione uma linha reta usando um twip par de números:
  Atribua a caixa desta linha reta a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Faça uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione a linha reta usando o par de números fracionários.

Etapas para que se redimensione uma imagem para uma largura por uma altura:
  Se a imagem for inexistente, cancele.
  Atribua a largura dividido pelo quantidade de twips/pixel a um pixel largura.
  Atribua a altura dividido pelo quantidade de twips/pixel a um pixel altura.
  Call "gdiplus.dll" "GdipCreateBitmapFromScan0" com 
    A pixel largura 
    e A pixel altura 
    e 0 
    e 137224 [pixelformat24bpprgb] 
    e 0 
    e O endereçamento desse gpBitmap.
  Call "gdiplus.dll" "GdipGetImageGraphicsContext" com 
    O gpBitmap 
    e O endereçamento desse gpGraphic.
  Call "gdiplus.dll" "GdipDrawImageRectRectI" com
   O gpGraphic 
   e O gpBitmap desta imagem
   e 0 
   e 0 
   e A pixel largura 
   e A pixel altura
   e 0 
   e 0 
   e A largura deste gpBitmap desta imagem menos 1 
   e A altura deste gpBitmap desta imagem menos 1
   e 2 [unitpixel] 
   e nil 
   e nil 
   e 0.
  Call "gdiplus.dll" "GdipDeleteGraphics" com 
   O gpGraphic.
  Destrua o gpBitmap desta imagem.
  Atribua o gpBitmap ao gpBitmap desta imagem.
  Ajuste a imagem (extraindo as caixas do gpBitmap).
  Limpe os data desta imagem.

Etapas para que se redimensione um polígono usando um par de números racionais;
Etapas para que se redimensione um polígono usando uma par de números fracionários:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Subtraia o canto superior esquerdo desta caixa desde a localização deste vértice.
    Redimensione proporcionalmente a localização deste vértice usando o par de números fracionários.
    Adicione o canto superior esquerdo desta caixa para a localização deste vértice.
  Repita. [o código acima]

Etapas para que se redimensione um polígono usando um twip par de números:
  Se o polígono for inexistente, cancele.
  Atribua a caixa deste polígono a uma caixa.
  Atribua a caixa a uma segunda caixa.
  Redimensione a segunda caixa usando o twip par de números.
  Faça uma par de números fracionários usando a segunda caixa e a caixa.
  Redimensione o polígono usando o par de números fracionários.

Etapas para que se redimensione um text usando um par de números racionais;
Etapas para que se redimensione um text usando uma par de números fracionários:
  Se o text for inexistente, cancele.
  Redimensione a caixa deste text usando o par de números fracionários.
  Wrap o text.

Etapas para que se redimensione um text usando um twip par de números:
  Se o text for inexistente, cancele.
  Redimensione a caixa deste text usando o twip par de números.
  Wrap o text.

Etapas para que se restart um temporizador:
  Adicione 1 para a contagem deste temporizador.
  Se a contagem deste temporizador não for 1, cancele.
  Atribua a contagem de intervalos do sistema aos intervalos iniciais deste temporizador. \ a intervalo contagem deste system

Etapas para que se restaure um canvas:
  Call "gdi32.dll" "RestoreDC" com 
    O canvas [hDC]
    e -1. \ nSavedDC - O estado salvo a ser restaurado. 
    \Se este parâmetro for positivo, ele representa uma instância específica do estado a ser restaurado. 
    \Se este parâmetro for negativo, ele representa uma instância relativa ao estado atual. 
    \Nesse caso, o valor -1 restaura o estado salvo mais recentemente.

Etapas para que se restaure um context:
  Obtenha um saved context desde o context stack.
  Se o saved context for inexistente, cancele.
  Atribua a localização deste saved context à localização deste context.
  Atribua a orientação deste saved context à orientação deste context.
  Atribua a tamanho da letra deste saved context à tamanho da letra deste context.
  Atribua a cor deste saved context à cor deste context.
  Atribua o número deste saved context ao número deste context.
  Remove o saved context desde o context stack.
  Destrua o saved context.

Etapas para que se restaure uma janela do programa:
  Call "user32.dll" "ShowWindow" com 
    A janela do programa 
    e 9 [SW_RESTORE].

Etapas para que se reverse algum tipo de rows selecionadas of um text:
  Se o text for inexistente, cancele.
  Separe a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
  Reverse o rows selecionadas.
  Posponha a rows para as rows deste text.
  Posponha o rows selecionadas para as rows deste text.
  Posponha a segunda rows para as rows deste text.
  Renumere as rows deste text.

Etapas para que se reverse uma cor:
  Se a cor for a cor preta, atribua a cor branca à cor; volte.
  Se a cor for a cor branca, atribua a cor preta à cor; volte.
  Atribua 1000 menos a luminosidade desta cor à luminosidade desta cor.
    \Atribua 1000 menos a saturação desta cor à saturação desta cor.
  Adicione 1800 para a matiz desta cor. Normalize a matiz desta cor.

Etapas para que se invert um detector;
Etapas para que se reverse um detector:
  Se o detector for 1, atribua 0 ao detector; volte.
  Atribua 1 ao detector.

Etapas para que se reverse uma string:
  \ podia ser more efficient
  Isole a string.
  Limpe o original string.
  Percorra. [o código abaixo]
    Se a string estiver em branco, pare.
    Obtenha um character desde a string (backwards).
    Posponha o character para o original string.
  Repita. [o código acima]

Etapas para que se reverse uns coisas:
  Permute  as coisas com uns segunda coisas.
  Percorra. [o código abaixo]
    Atribua o last destas segunda coisas a uma coisa.
    Se a coisa for inexistente, cancele.
    Mova a coisa desde a segunda coisas para as coisas.
  Repita. [o código acima]

Um deslocamento vertical é um número.
Um deslocamento horizontal é um número.

Etapas para que se rotate uma caixa:
  Atribua o center desta caixa a um center localização.
  Atribua a caixa a uma segunda caixa.
  Atribua a coordenada Y deste center menos a coordenada Y do canto superior esquerdo desta segunda caixa mais a coordenada X deste center à coordenada X do canto inferior direito desta caixa.
  Atribua a coordenada X do canto superior esquerdo desta segunda caixa menos a coordenada X deste center mais a coordenada Y deste center à coordenada Y do canto superior esquerdo desta caixa.
  Atribua a coordenada Y deste center menos a coordenada Y do canto inferior direito desta segunda caixa mais a coordenada X deste center à coordenada X do canto superior esquerdo desta caixa.
  Atribua a coordenada X do canto inferior direito desta segunda caixa menos a coordenada X deste center mais a coordenada Y deste center à coordenada Y do canto inferior direito desta caixa.

Etapas para que se rotate uma elipse:
  Rotate a caixa desta elipse.

Etapas para que se rotate um GpImage:
  Se o GpImage for inexistente, cancele.
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O GpImage 
    e 1 [Rotate90FlipNone].

Etapas para que se rotate um GpImage usando um ângulo:
  \ o ângulo pode ser 0, 900, 1800, 2700
  Se o GpImage for inexistente, cancele.
  Atribua 0 [RotateNoneFlipNone] a um número.
  Se o ângulo for 900, atribua 1 [Rotate90FlipNone] ao número.
  Se o ângulo for 1800, atribua 2 [Rotate180FlipNone ] ao número.
  Se o ângulo for 2700, atribua 3 [Rotate270FlipNone ] ao número.
  Call "gdiplus.dll" "GdipImageRotateFlip" com 
    O GpImage 
    e O número.

Etapas para que se rotate uma linha reta:
  Atribua o center desta linha reta a um center localização.
  Rotate a localização inicial desta linha reta around o center.
  Rotate a localização final desta linha reta around o center.

Etapas para que se rotate uma imagem:
  Se a imagem for inexistente, cancele.
  Adicione 900 para o ângulo de rotação desta imagem.
  Se o mirror detector desta imagem estiver ativo, adicione 1800 para o ângulo de rotação desta imagem.
  Normalize o ângulo de rotação desta imagem.
  Rotate a caixa desta imagem.
  Rotate a caixa intacta desta imagem.
  Atribua o center desta caixa desta imagem a um center localização.
  Atribua o center desta caixa intacta desta imagem a uma segunda center localização.
  Atribua a coordenada Y deste center menos a coordenada Y desta segunda center mais a coordenada X deste center ao número X desse twip par de números.
  Subtraia a coordenada X desta segunda center desde o número X deste twip par de números.
  Atribua a coordenada Y deste center mais a coordenada X desta segunda center menos a coordenada X deste center ao número Y deste twip par de números.
  Subtraia a coordenada Y desta segunda center desde o número Y deste twip par de números.
  Mova a caixa intacta desta imagem usando o twip par de números.
  Rotate o gpBitmap desta imagem.

Etapas para que se rotate um polígono:
  Se o polígono for inexistente, cancele.
  Atribua o center deste polígono a um center localização.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Rotate a localização deste vértice around o center.
  Repita. [o código acima]

Etapas para que se rotate uma localização around um center localização:
  Atribua a localização a uma segunda localização.
  Atribua a coordenada Y deste center menos a coordenada Y desta segunda localização mais a coordenada X deste center à coordenada X desta localização.
  Atribua a coordenada X desta segunda localização menos a coordenada X deste center mais a coordenada Y deste center à coordenada Y desta localização.

Etapas para que se rotate um text:
  Se o text for inexistente, cancele.
  Rotate a caixa deste text.
  Wrap o text.

Etapas para que se arredonde um número para um segundo número:
  Arredonde o número para o múltiplo imediato of o segundo número.

Etapas para que se arredonde um número para baixo para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número.
  Multiplique o número pelo segundo número.

Etapas para que se arredonde um número para o múltiplo imediato of um outro número:
  Se o outro número for 0, cancele.
  Isole o outro número.
  Divida o número pelo outro número usando um quociente e um resto.
  Divida o outro número por 2.
  Se o resto for maior do que ou igual ao outro número, arredonde o número para cima para o múltiplo imediato of o original outro número; volte.
  Arredonde o número para baixo para o múltiplo imediato of o original outro número.

Etapas para que se arredonde um número para cima para o múltiplo imediato of um segundo número:
  Divida o número pelo segundo número usando um quociente e um resto.
  Se o resto for 0, cancele.
  Adicione o segundo número menos o resto para o número.

Etapas para que se arredonde um par de números para um segundo par de números:
  Arredonde o par de números para o múltiplo imediato of o segundo par de números.

Etapas para que se arredonde um par de números para o múltiplo imediato of um segundo par de números:
  Arredonde o número X deste par de números para o múltiplo imediato of o número X deste segundo par de números.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número Y deste segundo par de números.

Etapas para que se arredonde um par de números para o múltiplo imediato of um número:
  Arredonde o número X deste par de números para o múltiplo imediato of o número.
  Arredonde o número Y deste par de números para o múltiplo imediato of o número.

Etapas para que se arredonde um par de números para um número:
  Arredonde o par de números para o múltiplo imediato of o número.

Um caixa arredondada é uma caixa com
  Uma coordenada X do canto superior esquerdo, 
  Uma coordenada Y do canto superior esquerdo, 
  Uma coordenada X do canto inferior direito, 
  Uma coordenada Y do canto inferior direito,
  Um canto superior esquerdo localização sob a coordenada X do canto superior esquerdo , 
  Um canto inferior direito localização sob a coordenada X do canto inferior direito, e 
  Um raio.



Um número da linha é um número.

Etapas para que se salve um canvas:
  Call "gdi32.dll" "SaveDC" com o canvas.

Etapas para que se salve um context:
  Aloque memória para um saved context.
  Atribua a localização deste context à localização deste saved context.
  Atribua a orientação deste context à orientação deste saved context.
  Atribua a tamanho da letra deste context à tamanho da letra deste saved context.
  Atribua a cor deste context à cor deste saved context.
  Atribua o número deste context ao número deste saved context.
  Anteponha o saved context para o context stack.

O saved memory hBitMap é um hBitMap.

O saved quantidade de twips/pixel é um número.

Etapas para que se say um número:
  Atribua o número a uma string.
  Say a string.

Etapas para que se say uma string;
Etapas para que se speak uma string:
  Se o silent detector estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para uma string composta de caracteres amplos.
  Termine com o caractere NULL a string composta de caracteres amplos.
  Call o speak desta vtable deste talker com 
    O talker 
    e O caractere inicial desta string composta de caracteres amplos 
    e 17 [SVSFDefault+SVSFlagsAsync +SVSFIsNotXML]  \ https://docs.microsoft.com/en-us/previous-versions/windows/desktop/ms720892(v=vs.85)
    e 0.

Etapas para que se say uma string e wait;
Etapas para que se speak uma string e wait:
  Se o silent detector estiver ativo, cancele.
  Se la bandera silenciosa estiver ativo, cancele.
  Se o talker for inexistente, cancele.
  Se a string estiver em branco, cancele.
  Converta a string para uma string composta de caracteres amplos.
  Termine com o caractere NULL a string composta de caracteres amplos.
  Call o speak desta vtable deste talker com 
    O talker 
    e O caractere inicial desta string composta de caracteres amplos 
    e 16 [SVSFDefault+SVSFIsNotXML] 
    e 0.

Etapas para que se redimensione proporcionalmente uma caixa usando um ratio;
Etapas para que se redimensione proporcionalmente uma caixa usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada X do canto superior esquerdo desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada Y do canto superior esquerdo desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada X do canto inferior direito desta caixa usando a fração.
  Redimensione proporcionalmente a coordenada Y do canto inferior direito desta caixa usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a caixa usando a fração.

Etapas para que se redimensione proporcionalmente uma elipse usando um ratio;
Etapas para que se redimensione proporcionalmente uma elipse usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta elipse usando a fração.

Etapas para que se redimensione proporcionalmente uma elipse para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a elipse usando a fração.

Etapas para que se redimensione proporcionalmente uma font usando um ratio;
Etapas para que se redimensione proporcionalmente uma font usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a altura desta font usando a fração.

Etapas para que se redimensione proporcionalmente uma fração usando uma segunda fração;
Etapas para que se multiplique uma fração por uma segunda fração:
  Multiplique o numerador desta fração pelo numerador desta segunda fração.
  Multiplique o denominador desta fração pelo denominador desta segunda fração.
  Reduza a fração.

Etapas para que se redimensione proporcionalmente uma linha reta usando um ratio;
Etapas para que se redimensione proporcionalmente uma linha reta usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a localização inicial desta linha reta usando a fração.
  Redimensione proporcionalmente a localização final desta linha reta usando a fração.

Etapas para que se redimensione proporcionalmente uma linha reta para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a linha reta usando a fração.

Etapas para que se redimensione proporcionalmente um par de números usando um ratio;
Etapas para que se redimensione proporcionalmente um par de números usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente o número X deste par de números usando a fração.
  Redimensione proporcionalmente o número Y deste par de números usando a fração.

Etapas para que se redimensione proporcionalmente um par de números usando um par de números racionais;
Etapas para que se redimensione proporcionalmente um par de números usando uma par de números fracionários:
  Redimensione proporcionalmente o número X deste par de números usando a fração deste par de números fracionários.
  Redimensione proporcionalmente o número Y deste par de números usando a segunda fração deste par de números fracionários.

Etapas para que se redimensione proporcionalmente um par de números para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o par de números usando a fração.

Etapas para que se redimensione proporcionalmente uma imagem usando um ratio;
Etapas para que se redimensione proporcionalmente uma imagem usando um fração:
  Se a imagem for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa desta imagem usando a fração.
  Redimensione proporcionalmente a caixa intacta desta imagem usando a fração.

Etapas para que se redimensione proporcionalmente uma imagem para um percentual:
  Se a imagem for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a imagem usando a fração.

Etapas para que se redimensione proporcionalmente um polígono usando um ratio;
Etapas para que se redimensione proporcionalmente um polígono usando um fração:
  Se o polígono for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Percorra. [o código abaixo]
    Obtenha um vértice desde os vértices deste polígono.
    Se o vértice for inexistente, cancele.
    Redimensione proporcionalmente o vértice usando a fração.
  Repita. [o código acima]

Etapas para que se redimensione proporcionalmente um polígono para um percentual:
  Se o polígono for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o polígono usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa arredondada usando um ratio;
Etapas para que se redimensione proporcionalmente uma caixa arredondada usando um fração:
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa arredondada como uma caixa usando a fração.
  Redimensione proporcionalmente o raio desta caixa arredondada usando a fração.

Etapas para que se redimensione proporcionalmente uma caixa arredondada para um percentual:
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente a caixa arredondada usando a fração.

Etapas para que se redimensione proporcionalmente um text para um fração:
  \ absolute
  Se o text for inexistente, cancele.
  Atribua a scale deste text a uma segunda fração.
  Flip a segunda fração.
  Multiplique a segunda fração pela fração.
  Redimensione proporcionalmente o text usando a segunda fração.

Etapas para que se redimensione proporcionalmente um text usando um ratio;
Etapas para que se redimensione proporcionalmente um text usando um fração:
  Se o text for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a caixa deste text usando a fração.
  Redimensione proporcionalmente a origem deste text usando a fração.
  Redimensione proporcionalmente a font deste text usando a fração.
  Redimensione proporcionalmente a scale deste text usando a fração.

Etapas para que se redimensione proporcionalmente um text para um percentual:
  Se o text for inexistente, cancele.
  Atribua o percentual / 100 a um fração.
  Redimensione proporcionalmente o text usando a fração.

Etapas para que se redimensione proporcionalmente um vértice usando um ratio;
Etapas para que se redimensione proporcionalmente um vértice usando um fração:
  Se o vértice for inexistente, cancele.
  Se a fração for 1/1, cancele.
  Redimensione proporcionalmente a coordenada X deste vértice usando a fração.
  Redimensione proporcionalmente a coordenada Y deste vértice usando a fração.

O tela canvas é um canvas.

A tela é um conjunto com 
  Uma caixa, 
  Uma pixel altura e 
  Uma pixel largura.

Etapas para que se role um console usando um event:
  Se o console for inexistente, cancele.
  Encontre um sector usando a malha deste console e a localização deste event.
  Percorra. [o código abaixo]
    Se o botão direito deste mouse não estiver sendo pressionado, cancele.
    Encontre uma segunda sector usando a malha deste console e a localização deste mouse.
    Obtenha um difference entre a segunda sector e o sector.
    Se a difference for 0, repita.
    Role o text deste console usando a difference.
    Mostre o console.
    Adicione a difference para o sector.
  Repita. [o código acima]

Etapas para que se role um text para o base:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua a contagem de linhas deste text menos 1 a um número.
  Atribua - o número times a altura da linha deste text à coordenada Y deste text.
  Limite a origem of o text.

  Multiplique o número por -1.
  Multiplique o número pela altura da linha deste texto.
  Adicione 2 ao número.
  Atribua o número à Coordenada Y deste texto.

Etapas para que se role um text para o cursor de texto:
  Se o text for inexistente, cancele.
  Se o número de coluna deste cursor de texto deste text for 1, atribua a margem deste text à coordenada X deste text.
  Obtenha uma caixa pelo cursor de texto no text.
  Ajuste a caixa usando 0 e - a quantidade de twips/pixel e 0 e a quantidade de twips/pixel . \ cursor de texto caixas do not preencha entire row
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo deste text, atribua a coordenada Y do canto superior esquerdo deste text menos a coordenada Y do canto superior esquerdo desta caixa ao número Y dessa difference.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito deste text, atribua a coordenada Y do canto inferior direito deste text menos a coordenada Y do canto inferior direito desta caixa ao número Y desta difference.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo deste text , atribua a coordenada X do canto superior esquerdo deste text menos a coordenada X do canto superior esquerdo desta caixa ao número X desta difference.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito deste text, atribua a coordenada X do canto inferior direito deste text menos a coordenada X do canto inferior direito desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role o text usando a difference.

Etapas para que se role um text para o cursor de texto e center it:
  Se o text for inexistente, cancele.
  Atribua a margem deste text à coordenada X deste text.
  Obtenha uma caixa pelo cursor de texto no text.
  Se a caixa estiver inside a caixa deste text, cancele.
  Ajuste a caixa usando 0 e - a quantidade de twips/pixel e 0 e a quantidade de twips/pixel . \ cursor de texto caixas don not preencha entire row
  Atribua o y-extent desta caixa deste text dividido por 2 a uma altura.
  Arredonde a altura para baixo para o múltiplo imediato of a altura da linha deste text.
  Atribua a coordenada Y do canto superior esquerdo desta caixa deste text mais a altura a uma coordenada Y do canto superior esquerdo.
  Atribua a coordenada Y do canto superior esquerdo mais a altura da linha deste text a uma coordenada Y do canto inferior direito.
  Se a coordenada Y do canto superior esquerdo desta caixa for menor do que a coordenada Y do canto superior esquerdo, atribua a coordenada Y do canto superior esquerdo menos a coordenada Y do canto superior esquerdo desta caixa ao número Y dessa difference.
  Se a coordenada Y do canto inferior direito desta caixa for maior do que a coordenada Y do canto inferior direito, atribua a coordenada Y do canto inferior direito menos a coordenada Y do canto inferior direito desta caixa ao número Y desta difference.
  Se a coordenada X do canto superior esquerdo desta caixa for menor do que a coordenada X do canto superior esquerdo deste text , atribua a coordenada X do canto superior esquerdo deste text menos a coordenada X do canto superior esquerdo desta caixa ao número X desta difference.
  Se a coordenada X do canto inferior direito desta caixa for maior do que a coordenada X do canto inferior direito deste text, atribua a coordenada X do canto inferior direito deste text menos a coordenada X do canto inferior direito desta caixa ao número X desta difference.
  Se a difference for 0, cancele.
  Role o text usando a difference.

Etapas para que se role um text para baixo one linha reta:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua - a altura da linha deste text ao número Y dessa difference. \ reescrever esse comando
  Role o text usando a difference.

Etapas para que se role um text para baixo one página:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Subtraia o y-extent desta caixa deste text desde a coordenada Y deste text.
  Adicione a altura da linha deste text para a coordenada Y deste text.
  Limite a origem of o text.

Etapas para que se role um text usando um difference:
  Se o text for inexistente, cancele.
  Isole a difference.
  Se o horizontal scroll detector deste text não estiver ativo, atribua 0 ao número X desta difference.
  Se o vertical scroll detector deste text não estiver ativo, atribua 0 ao número Y desta difference.
  Se a difference for 0, cancele.
  Mova a origem deste text usando a difference.
  Limite a origem of o text.

Etapas para que se role um text para o topo:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua 0 à coordenada Y deste text.
  Limite a origem of o text.

Etapas para que se role um text para cima one linha reta:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Atribua a altura da linha deste text ao número Y dessa difference.
  Role o text usando a difference.

Etapas para que se role um text para cima one página:
  Se o text for inexistente, cancele.
  Se o vertical scroll detector deste text não estiver ativo, cancele.
  Adicione o y-extent desta caixa deste text para a coordenada Y deste text.
  Subtraia a altura da linha deste text desde a coordenada Y deste text.
  Limite a origem of o text.

Um sector é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y [indicating o canto superior esquerdo of o sector].

A seed é um número.

Etapas para que se selecione cada pedaço em um text:
  Se o text for inexistente, cancele.
  Atribua 1 e 1 ao anchor deste text.
  Atribua a quantidade de caracteres desta string deste last destas rows deste text e a contagem de linhas deste text ao cursor de texto deste text.

Etapas para que se selecione um número da linha usando um text:
  Se o text for inexistente, cancele.
  Obtenha uma row usando o número da linha e o text.
  Se a row for inexistente, cancele.
  Atribua o número da linha ao anchor número da linha deste text .
  Atribua 1 ao anchor número de coluna deste text.
  Atribua o número da linha ao número de linhas do cursor deste text.
  Atribua a quantidade de caracteres desta string desta row ao cursor de texto número de coluna deste text.

Um caixa de seleção é uma caixa.

Uma seleção é um conjunto com 
  Um anchor número de coluna,
  Um anchor número da linha, 
  Um anchor sob o anchor número de coluna,
  Um cursor de texto número de coluna, 
  Um número de linhas do cursor, 
  Um cursor de texto sob o cursor de texto número de coluna.

Etapas para que se send um trecho para um socket:
  Limpe o erro do fluxo de entrada/saída.
  Atribua o caractere inicial deste trecho a um endereço de memória.
  Atribua a quantidade de caracteres deste trecho a uma quantidade de caracteres.
  Percorra. [o código abaixo]
  Se a quantidade de caracteres for 0, pare.
    Call "ws2_32.dll" "send" com 
       O socket 
       e O endereço de memória 
       e A quantidade de caracteres 
       e 0 
       devolvendo um número.
    Se o número for -1 [SOCKET_ERROR ], atribua "Ocorreu um erro na hora de enviar dados." ao erro do fluxo de entrada/saída; volte.
    Subtraia o número desde a quantidade de caracteres.
    Adicione o número para o endereço de memória.
  Repita. [o código acima]

Etapas para que se send um data string para uma requisição WinHTTP:
  Se a requisição WinHTTP for inexistente, cancele.
  Call "WinHTTP.dll" "WinHttpSendRequest" com 
    O número identificador de requisição desta requisição WinHTTP 
    e 0 [WINHTTP_NO_ADDITIONAL_HEADERS] 
    e 0 
    e O caractere inicial desta data string
    e A quantidade de caracteres destes data string
    e A quantidade de caracteres destes data string
    e 0 
    devolvendo um número resultante.
  Se o result for 0, atribua "Erro. Não foi possível enviar a solicitação." ao erro do fluxo de entrada/saída; volte.

Etapas para que se send um email:
  Limpe o erro do fluxo de entrada/saída.
  \ crie socket
  Crie um socket usando o smtp server deste email e 25.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  \ initial receive here por date/time stuff desde server
  Receive um response string desde o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send HELO
  Send "HELO " junto com o nome deste module junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send MAIL FROM: <xxx>
  Send "MAIL FROM: <" junto com o sender deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send RCPT TO: <xxx>
  Send "RCPT TO: <" junto com o recipient deste email seguido de ">" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send DATA
  Send "DATA" junto com o texto CRLF para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
  Limpe um temp string.
  Posponha "De: " junto com o sender deste email junto com o texto CRLF para o temp string.
  Posponha "Para: " junto com o recipient deste email junto com o texto CRLF para o temp string.
  Posponha "Assunto: " junto com o subject deste email junto com o texto CRLF ao temp string.
  Posponha "Reply-To: " junto com o sender deste email junto com o texto CRLF ao temp string.
  Posponha o texto CRLF para o temp string.
  Posponha a message deste email para o temp string (handling email transparency).
  Posponha o texto CRLF seguido de "." junto com o texto CRLF para o temp string.
  Send o temp string para o socket e receive o response string.
  Se o erro do fluxo de entrada/saída não estiver em branco, destrua o socket; volte.
  Se o response começa com "5", atribua o response ao erro do fluxo de entrada/saída; trim o erro do fluxo de entrada/saída; destrua o socket; volte.
  \ send QUIT
  Send "QUIT" junto com o texto CRLF para o socket.
  \ destrua socket
  Destrua o socket.

Etapas para que se send um message desde um sender para um recipient:
  Send o message para o recipient desde o sender.

Etapas para que se send um message desde um sender para um recipient via um smtp server:
  Send o message para o recipient desde o sender via o smtp server.

Etapas para que se send um message desde um sender para um recipient com um subject:
  Send o message para o recipient desde o sender com o subject.

Etapas para que se send um message desde um sender para um recipient com um subject via um smtp server:
  Send o message para o recipient desde o sender com o subject via o smtp server.

Etapas para que se send um message para um recipient desde um sender:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender com um subject:
  Atribua o default smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send um message para um recipient desde um sender com um subject via um smtp server:
  Atribua o smtp server ao smtp server desse email.
  Atribua o recipient ao recipient deste email.
  Atribua o sender ao sender deste email.
  Atribua o subject ao subject deste email.
  Atribua o message à message deste email.
  Send o email.

Etapas para que se send uma string para um socket e receive um response string:
  Limpe a response string.
  Send a string para o socket.
  Se o erro do fluxo de entrada/saída não estiver em branco, cancele.
  Receive a response string desde o socket.

Um sender é uma string.

Etapas para que se defina o código da cor of um canvas usando uma cor:
  Converta a cor para um código da cor.
  Call "gdi32.dll" "SetTextColor" com 
    O canvas e o código da cor.

Etapas para que se defina o drawing origem para uma localização:
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 112 [PhysicalOffsetYX] 
    devolvendo o número X desse par de números.
  Call "gdi32.dll" "GetDeviceCaps" com 
    O quadro atual 
    e 113 [PhysicalOffsetY ] 
    devolvendo o número Y deste par de números.
  Negate o par de números.
  Se o quadro atual não for a área de impressão, limpe o par de números.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e O número X deste par de números 
    e O número Y deste par de números 
    e nil.
  Isole a localização.
  Call "gdi32.dll" "LPtoDP" com 
    O quadro atual 
    e O endereçamento desta localização 
    e 1.
  Call "gdi32.dll" "SetViewportOrgEx" com 
    O quadro atual 
    e A coordenada X desta localização 
    e A coordenada Y desta localização 
    e nil.

Etapas para que se acione um detector;
Etapas para que se ative um detector;
Etapas para que se dispare um detector;
Etapas para que se toque um detector;
Etapas para que se ligue um detector:
  Atribua 1 ao detector. \ era "Atribua sim ao detector." O valor binário do termo sim era herdado do CAL-1000 de acordo com o Dan.

Etapas para que se defina um endereço completo para read-write mode:
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "GetFileAttributesA" com 
    O caractere inicial deste endereço completo 
    devolvendo um número.
  Conjuncione logicamente o número com -2 [everything except FILE_ATTRIBUTE_READONLY].
  Call "kernel32.dll" "SetFileAttributesA" com 
    O caractere inicial deste endereço completo 
    e O número.

Um folha é uma caixa.

Etapas para que se mostre um console:
  Se o console for inexistente, cancele.
  Salve o quadro atual.
  Pinte o console.
  Atualize o tela usando a caixa deste console.
  Restaure o quadro atual.

Etapas para que se mostre um cursor:
  Call "user32.dll" "SetCursor" com o cursor.
  Call "user32.dll" "ShowCursor" com 1 
    devolvendo um número.
  Se o número for maior do que 0, cancele.
  Repita. [o código acima]

Etapas para que se mostre um terminal:
  Se o terminal for inexistente, cancele.
  Salve o quadro atual.
  Pinte o terminal.
  Atualize o tela usando a caixa deste terminal.
  Restaure o quadro atual.

Etapas para que se shrink uma caixa por uns twips;
Etapas para que se indent uma caixa uns twips;
Etapas para que se indent uma caixa por uns twips;
Etapas para que se indent uma caixa uns twips sobre cada side;
Etapas para que se indent uma caixa usando uns twips:
  Adicione os twips para a coordenada X do canto superior esquerdo desta caixa.
  Adicione os twips para a coordenada Y do canto superior esquerdo desta caixa.
  Subtraia os twips desde a coordenada X do canto inferior direito desta caixa.
  Subtraia os twips desde a coordenada Y do canto inferior direito desta caixa.

Etapas para que se feche o programa;
Etapas para que se feche o nosso programa;
Etapas para que se feche nosso programa;
Etapas para que se feche tudo;
Etapas para que se shut para baixo:
  Destrua o Bíblia.
  Destrua o stack.
  Destrua o dicionário léxico.
  Destrua o console.
  Destrua o terminal.
  Finalize o context.
  Finalize os canvases.
  Finalize o mouse.
  Finalize os cursors.
  Finalize as fonts.
  Finalize a janela do programa.
  Finalize o tela.
  Finalize as cors.
  Finalize o module.
  Finalize o talker.
  Finalize gdi+.
  Finalize winsock.
  Finalize COM.

Etapas para que se shut para baixo o cgi:
  Finalize o cgi.
  Finalize o module.
  Finalize winsock.

O silent detector é um detector.

Etapas para que se simplify um reply:
  Se o reply estiver em branco, pare.
  Obtenha um pedaço desde o reply.
  Se o pedaço é algum tipo de sinal de pontuação, repita.
  Posponha o pedaço para uma string.
  Repita. [o código acima]
  Atribua a string ao reply.

Um size é uns twips.

Etapas para que se skip algum tipo de leading quebra de linha em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere inicial deste subtexto não for a quebra de linha, cancele.
  Adicione 1 para o caractere inicial deste subtexto.

Etapas para que se skip algum tipo de leading noise em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere inicial deste subtexto não for irrelevante, cancele.
  Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se skip algum tipo de non-alfanumérico pedaços em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o conteúdo deste caractere inicial deste subtexto for alfanumérico, cancele.
  Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se skip uma linha reta sobre o terminal:
  Escreva "" sobre o terminal.

Etapas para que se skip palavra characters em um subtexto:
  Se o subtexto estiver em branco, cancele.
  Se o subtexto está sobre alguma espécie de contração, adicione 1 para o caractere inicial deste subtexto; repita.
  Se o conteúdo deste caractere inicial deste subtexto não for alfanumérico, cancele.
  Adicione 1 para o caractere inicial deste subtexto.
  Repita. [o código acima]

Etapas para que se lance um percorredor sobre um segundo percorredor:
  Lance o segmento final deste percorredor sobre o segmento final deste segundo percorredor.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas para que se lance um percorredor sobre uma string:
  Lance o subtexto original deste percorredor sobre a string.
  Lance o segmento final deste percorredor sobre a string.
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.

Etapas para que se lance um subtexto sobre qualquer trecho selecionado em uma row of um text:
  Limpe o subtexto.
  Se o text for inexistente, cancele.
  Se a row of o text não estiver selecionado, cancele.
  Lance o subtexto sobre a string deste row.
  Atribua a normalized seleção deste text a uma seleção.
  Se o número da linha desta row é o número de linhas do cursor desta seleção, atribua o caractere inicial deste subtexto mais o cursor de texto número de coluna desta seleção menos 2 ao caractere final deste subtexto.
  Se o número da linha desta row é o anchor número da linha desta seleção, atribua o caractere inicial deste subtexto mais o anchor número de coluna desta seleção menos 1 ao caractere inicial deste subtexto.

Etapas para que se lance um subtexto sobre o first pedaço of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o caractere inicial desta string ao caractere final deste subtexto.

Etapas para que se lance um subtexto sobre o last pedaço of uma string:
  Lance o subtexto sobre a string.
  Se a string estiver em branco, cancele.
  Atribua o caractere final desta string ao caractere inicial deste subtexto.

Etapas para que se suavize um polígono:
  Se o polígono for inexistente, cancele.
  Se a contagem destes vértices deste polígono for menor do que 3, cancele.
  Se o polígono estiver closed, posponha a localização deste next deste first vértice deste polígono para o polígono; ative um detector.
  Atribua o first vértice deste polígono a um left vértice.
  Percorra. [o código abaixo]
    Se o next deste left vértice for inexistente, pare.
    Atribua o next deste left vértice a um right vértice.
    Obtenha um center localização usando a localização deste left vértice e a localização deste right vértice.
    Insira o center ao polígono after o left vértice.
    Atribua o next deste left vértice a um new vértice.
    Se o previous deste left vértice for inexistente, atribua o right vértice ao left vértice; repita.
    Obtenha uma segunda center localização usando a localização deste previous deste left vértice e a localização deste new vértice.
    Obtenha um difference entre a segunda center e a localização deste left vértice.
    Divida a difference por 2.
    Adicione a difference para a localização deste left vértice.
    Atribua o right vértice ao left vértice.
  Repita. [o código acima]
  Se o detector não estiver ativo, cancele.
  Destrua o first vértice deste polígono usando o polígono.
  Destrua o last vértice deste polígono usando o polígono.

Etapas para que se suavize um polígono uns times; 
Etapas para que se suavize um polígono umas vezes:
  \ this use para "times" é um fluke, I think -- see "some times é um número"
  Isole o times.
  Percorra. [o código abaixo]
    Se o times for 0, cancele.
    Suavize o polígono.
    Subtraia 1 desde o times.
  Repita. [o código acima]

Some vezes é um número.

Um smtp server é uma string.

Um socket é um endereço de memória.

Etapas para que se classifique algum tipo de rows selecionadas em um text:
  Se o text for inexistente, cancele.
  Separe a rows of o text a uns rows e uns rows selecionadas e uns segunda rows.
  Classifique o rows selecionadas.
  Posponha a rows para as rows deste text.
  Posponha o rows selecionadas para as rows deste text.
  Posponha a segunda rows para as rows deste text.
  Renumere as rows deste text.

Etapas para que se classifique uns rows:
  Se o first destas rows for o last destas rows, cancele.
  Separe a rows a uns left rows e umas right rows.
  Classifique as left rows.
  Classifique as right rows.
  Percorra. [o código abaixo]
    Atribua o first destas left rows a uma left row.
    Atribua o first destas right rows a uma right row.
    Se a left row for inexistente, posponha as right rows para as rows; volte.
    Se a right row for inexistente, posponha as left rows para as rows; volte.
    Se a string desta left row for maior do que a string desta right row, mova a right row desde as right rows para as rows; repita.
    Mova a left row desde as left rows para as rows.
  Repita. [o código acima]

Etapas para que se separe um trecho para uns dyads:
  Destrua o dyads.
  Se o trecho estiver em branco, cancele.
  Lance um percorredor sobre o trecho.
  Percorra. [o código abaixo]
    Mova o percorredor usando o & comercial.
    Se o segmento inicial deste percorredor estiver em branco, cancele.
    Crie um dyad.
    Posponha o dyad para o dyads.
    Separe o segmento inicial deste percorredor a um nome subtexto e um query subtexto usando o sinal de igualdade.
    Atribua o nome subtexto ao nome deste dyad.
    Converta o query subtexto como um texto de consulta ao value deste dyad.
  Repita. [o código acima]

Etapas para que se separe um pedaço para uma cifra binária e uma segunda cifra binária:
  Atribua o pedaço à cifra binária.
  Desloque a cifra binária right 4 bits.
  Atribua o pedaço ao segunda cifra binária.
  Conjuncione logicamente a segunda cifra binária com 15.

Etapas para que se separe uma linha reta para uma segunda linha reta e um terceiro linha reta:
  Isole a linha reta.
  Atribua o center desta linha reta a um center localização.
  Atribua a localização inicial desta linha reta e o center ao segunda linha reta.
  Atribua o center e a localização final desta linha reta ao terceiro linha reta.

Etapas para que se separe um número para um word e uma segunda word:
  Isole o número.
  Desloque o número right 16 bits.
  Atribua o número ao word.
  Atribua o original número ao segunda word.

Etapas para que se separe a rows of um text para uns rows e uns rows selecionadas e uns segunda rows:
  Se o text for inexistente, limpe as rows; limpe o rows selecionadas; limpe as segunda rows; volte.
  Percorra. [o código abaixo]
    Atribua o first destas rows deste text a uma row.
    Se a row for inexistente, cancele.
    Remove a row desde as rows deste text.
    Se a row of o text estiver selecionado, acione um detector; posponha a row para o rows selecionadas; repita.
    Se o detector estiver ativo, posponha a row para a segunda rows; repita.
    Posponha a row para a rows.
  Repita. [o código acima]

Etapas para que se separe uma string para um left subtexto e um right subtexto usando um separator pedaço:
  Limpe o left .
  Limpe o right subtexto.
  Se a string estiver em branco, cancele.
  Atribua o caractere inicial desta string ao caractere inicial desse subtexto.
  Atribua o caractere inicial deste subtexto menos 1 ao caractere final deste subtexto.
  Percorra. [o código abaixo]
    Se o caractere final deste subtexto for maior do que o caractere final desta string, cancele.
    Adicione 1 para o caractere final deste subtexto.
    Se o conteúdo deste caractere final deste subtexto for o separator pedaço, pare.
  Repita. [o código acima]
  Atribua o caractere inicial deste subtexto ao caractere inicial deste left subtexto.
  Atribua o caractere final deste subtexto menos 1 ao caractere final deste left subtexto.
  Atribua o caractere final deste subtexto mais 1 ao caractere inicial deste right subtexto.
  Atribua o caractere final desta string ao caractere final deste right subtexto.

Etapas para que se separe uma string para uns conjunto de textos usando um separator pedaço:
  Destrua o conjunto de textos.
  Se a string estiver em branco, cancele.
  Lance um percorredor sobre a string.
  Percorra. [o código abaixo]
    Mova o percorredor usando o separator pedaço.
    Adicione o segmento inicial deste percorredor para o conjunto de textos.
    Se o segmento final deste percorredor estiver em branco, pare.
  Repita. [o código acima]
  Se o conteúdo deste caractere final desta string não for o separator pedaço, cancele.
  Adicione "" para o conjunto de textos.

Etapas para que se separe uns coisas para uns left coisas e uns right coisas:
  Se  as coisas estiverem vazio, limpe o left coisas; limpe o right coisas; volte.
  Atribua a contagem destas coisas dividido por 2 a uma contagem.
  Percorra. [o código abaixo]
    Obtenha uma coisa desde as coisas.
    Se a contagem for 0, pare.
    Subtraia 1 desde a contagem.
    Repita. [o código acima]
    Separe  as coisas ao left coisas e o right coisas sob o coisa.

Etapas para que se separe uns coisas para uns left coisas e uns right coisas sob um coisa:
  Limpe o left coisas.
  Limpe o right coisas.
  Se a coisa for inexistente, permute  as coisas com o left coisas; volte.
  Se o previous desta coisa for inexistente, permute  as coisas com o left coisas; volte.
  \ abra para cima o left chain
  Atribua o first destas coisas ao first destas left coisas.
  Atribua o previous desta coisa ao last destas left coisas.
  Esvazie o next deste previous desta coisa.
  \ abra para cima o right chain
  Atribua a coisa ao first destas right coisas.
  Esvazie o previous desta coisa.
  Atribua o last destas coisas ao last destas right coisas.
  \ fix o original chain
  Limpe as coisas.

Etapas para que se separe um word para um pedaço e um segundo pedaço:
  Isole a word.
  Desloque a word right 8 bits.
  Atribua a word ao pedaço.
  Atribua o original word ao segundo pedaço.

Uma localização é um par de números com 
  Uma coordenada X e 
  Uma coordenada Y e 
  Uma left sob a coordenada X e 
  Um topo sob a coordenada Y.

Uma endereço de memória da localização é um endereço de memória para uma localização.

Etapas para que se square para cima algum tipo de seleção em um text:
  Se o text for inexistente, cancele.
  Se nada estiver selecionado no text, cancele.
  Normalize a seleção deste text.
  Obtenha uma row usando o número de linhas do cursor deste text e o text.
  Atribua 1 ao anchor número de coluna deste text.
  Se o cursor de texto número de coluna deste text não for 1, adicione 1 para o número de linhas do cursor deste text; atribua 1 ao cursor de texto número de coluna deste text.
  Se o número de linhas do cursor deste text for menor do que ou igual à contagem de linhas deste text, cancele.
  Atribua a contagem de linhas deste text ao número da linha deste cursor de texto deste text.
  Atribua a quantidade de caracteres desta string desta row ao número de coluna deste cursor de texto deste text.



Etapas para que se start anywhere em uma caixa:
  Escolha aleatoriamente a localização deste context na caixa.

Etapas para que se start anywhere sobre um horizontal linha reta:
  Escolha aleatoriamente uma localização sobre o horizontal linha reta.
  Atribua a localização à localização deste context.

Etapas para que se start sob o base left corner of uma caixa facing east:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face east.

Etapas para que se start sob o base left corner of uma caixa facing north:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face north.

Etapas para que se start sob o base left corner of uma caixa facing south:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face south.

Etapas para que se start sob o base left corner of uma caixa facing west:
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face west.

Etapas para que se start sob o base of um horizontal linha reta:
  Atribua o end desta vertical linha reta à localização deste context.

Etapas para que se start sob o base right corner of uma caixa facing east:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face east.

Etapas para que se start sob o base right corner of uma caixa facing north:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face north.

Etapas para que se start sob o base right corner of uma caixa facing south:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face south.

Etapas para que se start sob o base right corner of uma caixa facing west:
  Atribua o canto inferior direito desta caixa à localização deste context.
  Face west.

Etapas para que se start sob o left of um horizontal linha reta:
  Atribua o start desta horizontal linha reta à localização deste context.

Etapas para que se start sob o middle of o base of uma caixa;
Etapas para que se start no middle of o base of uma caixa;
Etapas para que se start sob o center of o base of uma caixa;
Etapas para que se start no center of o base of uma caixa:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.

Etapas para que se start sob o middle of o base of uma caixa facing east;
Etapas para que se start no middle of o base of uma caixa facing east;
Etapas para que se start sob o center of o base of uma caixa facing east;
Etapas para que se start no center of o base of uma caixa facing east:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.
  Face east.

Etapas para que se start sob o middle of o base of uma caixa facing north;
Etapas para que se start no middle of o base of uma caixa facing north;
Etapas para que se start sob o center of o base of uma caixa facing north;
Etapas para que se start no center of o base of uma caixa facing north:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.
  Face north.

Etapas para que se start sob o middle of o base of uma caixa facing south;
Etapas para que se start no middle of o base of uma caixa facing south;
Etapas para que se start sob o center of o base of uma caixa facing south;
Etapas para que se start no center of o base of uma caixa facing south:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.
  Face south.

Etapas para que se start sob o middle of o base of uma caixa facing west;
Etapas para que se start no middle of o base of uma caixa facing west;
Etapas para que se start sob o center of o base of uma caixa facing west;
Etapas para que se start no center of o base of uma caixa facing west:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa à coordenada Y desta localização deste context.
  Face west.

Etapas para que se start sob o middle of o left of uma caixa facing east;
Etapas para que se start no middle of o left of uma caixa facing east;
Etapas para que se start sob o center of o left of uma caixa facing east;
Etapas para que se start no center of o left of uma caixa facing east:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face east.

Etapas para que se start sob o middle of o left of uma caixa facing north;
Etapas para que se start no middle of o left of uma caixa facing north;
Etapas para que se start sob o center of o left of uma caixa facing north;
Etapas para que se start no center of o left of uma caixa facing north:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face north.

Etapas para que se start sob o middle of o left of uma caixa facing south;
Etapas para que se start no middle of o left of uma caixa facing south;
Etapas para que se start sob o center of o left of uma caixa facing south;
Etapas para que se start no center of o left of uma caixa facing south:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face south.

Etapas para que se start sob o middle of o left of uma caixa facing west;
Etapas para que se start no middle of o left of uma caixa facing west;
Etapas para que se start sob o center of o left of uma caixa facing west;
Etapas para que se start no center of o left of uma caixa facing west:
  Atribua a coordenada X do canto superior esquerdo desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face west.

Etapas para que se start sob o middle of o right of uma caixa facing east;
Etapas para que se start no middle of o right of uma caixa facing east;
Etapas para que se start sob o center of o right of uma caixa facing east;
Etapas para que se start no center of o right of uma caixa facing east:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face east.

Etapas para que se start sob o middle of o right of uma caixa facing north;
Etapas para que se start no middle of o right of uma caixa facing north;
Etapas para que se start sob o center of o right of uma caixa facing north;
Etapas para que se start no center of o right of uma caixa facing north:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face north.

Etapas para que se start sob o middle of o right of uma caixa facing south;
Etapas para que se start no middle of o right of uma caixa facing south;
Etapas para que se start sob o center of o right of uma caixa facing south;
Etapas para que se start no center of o right of uma caixa facing south:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face south.

Etapas para que se start sob o middle of o right of uma caixa facing west;
Etapas para que se start no middle of o right of uma caixa facing west;
Etapas para que se start sob o center of o right of uma caixa facing west;
Etapas para que se start no center of o right of uma caixa facing west:
  Atribua a coordenada X do canto inferior direito desta caixa à coordenada X desta localização deste context.
  Atribua o y deste center desta caixa à coordenada Y desta localização deste context.
  Face west.

Etapas para que se start sob o middle of o topo of uma caixa;
Etapas para que se start no middle of o topo of uma caixa;
Etapas para que se start sob o center of o topo of uma caixa;
Etapas para que se start no center of o topo of uma caixa:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.

Etapas para que se start sob o middle of o topo of uma caixa facing east;
Etapas para que se start no middle of o topo of uma caixa facing east;
Etapas para que se start sob o center of o topo of uma caixa facing east;
Etapas para que se start no center of o topo of uma caixa facing east:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.
  Face east.

Etapas para que se start sob o middle of o topo of uma caixa facing north;
Etapas para que se start no middle of o topo of uma caixa facing north;
Etapas para que se start sob o center of o topo of uma caixa facing north;
Etapas para que se start no center of o topo of uma caixa facing north:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.
  Face north.

Etapas para que se start sob o middle of o topo of uma caixa facing south;
Etapas para que se start no middle of o topo of uma caixa facing south;
Etapas para que se start sob o center of o topo of uma caixa facing south;
Etapas para que se start no center of o topo of uma caixa facing south:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.
  Face south.

Etapas para que se start sob o middle of o topo of uma caixa facing west;
Etapas para que se start no middle of o topo of uma caixa facing west;
Etapas para que se start sob o center of o topo of uma caixa facing west;
Etapas para que se start no center of o topo of uma caixa facing west:
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto superior esquerdo desta caixa à coordenada Y desta localização deste context.
  Face west.

Etapas para que se start sob o right of um horizontal linha reta:
  Atribua o end desta horizontal linha reta à localização deste context.

Etapas para que se start sob uma localização:
  Atribua a localização à localização deste context.

Etapas para que se start sob uma localização facing east:
  Atribua a localização à localização deste context.
  Face east.

Etapas para que se start sob uma localização facing north:
  Atribua a localização à localização deste context.
  Face north.

Etapas para que se start sob uma localização facing south:
  Atribua a localização à localização deste context.
  Face south.

Etapas para que se start sob uma localização facing west:
  Atribua a localização à localização deste context.
  Face west.

Etapas para que se start sob o topo left corner of uma caixa facing east:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face east.

Etapas para que se start sob o topo left corner of uma caixa facing north:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face north.

Etapas para que se start sob o topo left corner of uma caixa facing south:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face south.

Etapas para que se start sob o topo left corner of uma caixa facing west:
  Atribua o canto superior esquerdo desta caixa à localização deste context.
  Face west.

Etapas para que se start sob o topo of um vertical linha reta:
  Atribua o start desta vertical linha reta à localização deste context.

Etapas para que se start sob o topo right corner of uma caixa facing east:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face east.

Etapas para que se start sob o topo right corner of uma caixa facing north:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face north.

Etapas para que se start sob o topo right corner of uma caixa facing south:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face south.

Etapas para que se start sob o topo right corner of uma caixa facing west:
  Atribua o canto superior direito desta caixa à localização deste context.
  Face west.

Etapas para que se start no middle of uma caixa facing east;
Etapas para que se start sob o middle of uma caixa facing east;
Etapas para que se mova para o middle of uma caixa facing east;
Etapas para que se mova para o middle of uma caixa e face east;
Etapas para que se start no center of uma caixa facing east;
Etapas para que se start sob o center of uma caixa facing east;
Etapas para que se mova para o center of uma caixa facing east;
Etapas para que se mova para o center of uma caixa e face east:
  Atribua o center desta caixa à localização deste context.
  Face east.

Etapas para que se start no middle of uma caixa facing north;
Etapas para que se start sob o middle of uma caixa facing north;
Etapas para que se mova para o middle of uma caixa facing north;
Etapas para que se mova para o middle of uma caixa e face north;
Etapas para que se start no center of uma caixa facing north;
Etapas para que se start sob o center of uma caixa facing north;
Etapas para que se mova para o center of uma caixa facing north;
Etapas para que se mova para o center of uma caixa e face north:
  Atribua o center desta caixa à localização deste context.
  Face north.

Etapas para que se start no middle of uma caixa facing north menos uns points;
Etapas para que se start no center of uma caixa facing north menos uns points:
  Atribua o center desta caixa à localização deste context.
  Face north.
  Vire left o points.

Etapas para que se start no middle of uma caixa facing south;
Etapas para que se start sob o middle of uma caixa facing south;
Etapas para que se mova para o middle of uma caixa facing south;
Etapas para que se mova para o middle of uma caixa e face south;
Etapas para que se start no center of uma caixa facing south;
Etapas para que se start sob o center of uma caixa facing south;
Etapas para que se mova para o center of uma caixa facing south;
Etapas para que se mova para o center of uma caixa e face south:
  Atribua o center desta caixa à localização deste context.
  Face south.

Etapas para que se start no middle of uma caixa facing west;
Etapas para que se start sob o middle of uma caixa facing west;
Etapas para que se mova para o middle of uma caixa facing west;
Etapas para que se mova para o middle of uma caixa e face west;
Etapas para que se start no center of uma caixa facing west;
Etapas para que se start sob o center of uma caixa facing west;
Etapas para que se mova para o center of uma caixa facing west;
Etapas para que se mova para o center of uma caixa e face west:
  Atribua o center desta caixa à localização deste context.
  Face west.

Etapas para que se start um process usando um endereço completo:
  \ must ser chamado com um global variável
  Limpe o erro do fluxo de entrada/saída.
  Se o process não for 0, atribua "Erro. Este processo já está sendo executado." ao erro do fluxo de entrada/saída; volte.
  Atribua a magnitude dessa startupinfo ao cb desta startupinfo.
  Extraia um endereço da pasta desde o endereço completo.
  Termine com o caractere NULL o endereço da pasta.
  Isole o endereço completo. termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateProcessA" com 
    O caractere inicial deste endereço completo 
    e 0 
    e 0 
    e 0 
    e 0 
    e 67108904 [CREATE_DEFAULT_ERROR_MODE + NORMAL_PRIORITY_CLASS + DETACHED_PROCESS] 
    e 0 
    e O caractere inicial deste endereço da pasta 
    e O endereçamento desta startupinfo 
    e O endereçamento dessa PROCESS_INFORMATION 
    devolvendo um número.
  Se o número for 0, atribua "Erro. Não foi possível executar o programa." ao erro do fluxo de entrada/saída; volte.
  Atribua o hprocess deste PROCESS_INFORMATION ao process.
  Call "kernel32.dll" "CloseHandle" com 
    O hthread deste PROCESS_INFORMATION.
  Point um endereço de memória para rotina aguarde por um process endereço de memória. \redirecione
  Call "kernel32.dll" "CreateThread" com 0 
    e 0 
    e O endereço de memória 
    e O endereçamento deste process 
    e 0 
    e O endereçamento desse segundo número
    devolvendo um número identificador.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador. \ does not end o thread, just dumps o handle

Etapas para que se start um temporizador:
  Reset o temporizador.
  Restart o temporizador.

Etapas para que se start uns twips acima of o middle of o base of uma caixa:
  \ incomplete abra of these
  Atribua a coordenada X deste center desta caixa à coordenada X desta localização deste context.
  Atribua a coordenada Y do canto inferior direito desta caixa menos os twips à coordenada Y desta localização deste context.

Etapas para que se start uns twips para baixo desde uma localização;
Etapas para que se start uns twips debaixo of uma localização:
  Atribua a coordenada X desta localização ao x deste context.
  Atribua a coordenada Y desta localização mais os twips ao y deste context.

Etapas para que se start uns twips desde o center of uma caixa:
  Atribua o center desta caixa à localização deste context.
  Mova os twips.

Etapas para que se start uns twips para o left e uns segunda twips para baixo desde uma localização;
Etapas para que se start uns twips left e uns segunda twips para baixo desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.
  Atribua a coordenada Y desta localização mais a segunda twips ao y deste context.

Etapas para que se start uns twips left e uns segunda twips para cima desde uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.
  Atribua a coordenada Y desta localização menos a segunda twips ao y deste context.

Etapas para que se start uns twips para o left e uns segunda twips para cima desde uma localização;
Etapas para que se start uns twips para o left of uma localização;
Etapas para que se start uns twips left of uma localização:
  Atribua a coordenada X desta localização menos os twips ao x deste context.

Etapas para que se start uns twips para o right e uns segunda twips para baixo desde uma localização;
Etapas para que se start uns twips right e uns segunda twips para baixo desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste context.
  Atribua a coordenada Y desta localização mais a segunda twips ao y deste context.

Etapas para que se start uns twips para o right e uns segunda twips para cima desde uma localização;
Etapas para que se start uns twips right e uns segunda twips para cima desde uma localização:
  Atribua a coordenada X desta localização mais os twips ao x deste context.
  Atribua a coordenada Y desta localização menos a segunda twips ao y deste context.

Etapas para que se start uns twips para cima desde uma coordenada:
  Atribua a coordenada menos os twips ao y deste context.

Etapas para que se start uns twips para cima desde uma localização;
Etapas para que se start uns twips acima of uma localização:
  Atribua a coordenada Y desta localização ao y deste context.
  Subtraia os twips desde a coordenada Y deste context.

Etapas para que se carregue as bibliotecas padrão do sistema;
Etapas para que se start para cima:
  inicialize o Component Object Model.
  Inicialize winsock.
  Inicialize gdi+.
  Inicialize o talker.
  Inicialize o module.
  Inicialize as cors.
  Inicialize o tela.
  Inicialize a janela do programa.
  Inicialize as fonts.
  Inicialize os cursors.
  Inicialize o mouse.
  Inicialize os canvases.
  Inicialize o context.
  Initalize o terminal.
  Crie o console.

Etapas para que se start para cima o cgi:
  Inicialize winsock.
  Inicialize o module.
  Inicialize o cgi.

Etapas para que se start com uma cor:
  Atribua a cor à cor deste context.

Etapas para que se start com nada em um endereço de memória:
  Esvazie o endereço de memória.

O número identificador do fluxo de entrada padrão é um número identificador.

O número identificador do fluxo de saída padrão é um número identificador.

Etapas para que se suspenda um process:
  Se o process for 0, cancele.
  Call "kernel32.dll" "TerminateProcess" com 
    O process 
    e 0.
  Atribua 0 ao process.

Etapas para que se suspenda um temporizador:
  Se a contagem deste temporizador for 0, cancele.
  Subtraia 1 desde a contagem deste temporizador.
  Se a contagem deste temporizador não for 0, cancele.
  Atribua a contagem de intervalos do sistema a uns intervalos.
  Subtraia os intervalos iniciais deste temporizador desde o intervalos.
  Adicione o intervalos para os intervalos totais deste temporizador.



Etapas para que se pinte uma caixa com uma cor:
  Atribua a cor à cor deste context.
  Atribua o canto inferior esquerdo desta caixa à localização deste context.
  Face north.
  Pinte a altura desta caixa.
  Vire right.
  Pinte a largura desta caixa.
  Vire right.
  Pinte a altura desta caixa.
  Vire right.
  Pinte a largura desta caixa.

Um subject é uma string.

Etapas para que se take off all o masking tape:
  Exponha tudo.

Etapas para que se take off algum tipo de masking tape:
  Exponha tudo.

Um talker é um endereço de memória para um talker object.

O talker é um talker.

Um talker object é um conjunto com um talker vtable denominado vtable.

Um talker vtable é um endereço de memória para um talker vtable conjunto.

O temp endereço completo é um endereço completo.

O terminal é um terminal.

Um terminal é uma coisa com 
  Uma caixa, 
  Uns quoras, 
  Uma output cor, 
  Uma input cor, e 
  Uma reply string.

O text cutoff é um número igual a 500.





Um temporizador é um conjunto com 
  Uma contagem, 
  Uns intervalos iniciais e 
  Uns intervalos totais.

Some times é um número. \ this é um fluke, I think -- see "suavize um polígono uns times"

Um topo é uns twips.

Etapas para que se trim uma string:
  Remove algum tipo de leading noise desde a string.
  Remove algum tipo de trailing noise desde a string.

Etapas para que se dê meia volta:
  Vire right 1/2.

Etapas para que se vire uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire a fração.

\Etapas para que se vire uma fração do caminho;
Etapas para que se vire uma fração of o caminho;
Etapas para que se vire uma fração of o caminho around;
Etapas para que se vire uma fração:
  Se a fração for 1/1, cancele.
  Atribua 3840 times a fração mais a orientação deste context à orientação deste context.
  Normalize a orientação deste context.

Etapas para que se vire pra left;
Etapas para que se vire para a left;
\Etapas para que se vire à left;
Etapas para que se vire left:
  Vire -1/4.

\Etapas para que se vire à left uma fração igual para um número over um segundo número;
Etapas para que se vire pra left uma fração igual para um número over um segundo número;
Etapas para que se vire para a left uma fração igual para um número over um segundo número;
Etapas para que se vire left uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire left a fração.

\Etapas para que se vire uma fração à left do caminho;
\Etapas para que se vire uma fração pra left do caminho;
Etapas para que se vire uma fração para a left do caminho;
Etapas para que se vire left uma fração of o caminho;
Etapas para que se vire left uma fração of o caminho around;
Etapas para que se vire left um fração:
  Isole a fração.
  Negate a fração.
  Vire a fração.

\Etapas para que se vire à left uns points;
Etapas para que se vire pra left uns points;
Etapas para que se vire para a left uns points;
Etapas para que se vire left uns points:
  Atribua o points e 3840 a um fração.
  Vire left a fração.

\Etapas para que se vire à right;
Etapas para que se vire pra right;
Etapas para que se vire para a right;
Etapas para que se vire right:
  Vire 1/4.

\Etapas para que se vire uns degrees à right;
\Etapas para que se vire uns degrees pra right;
Etapas para que se vire uns degrees para a right;
Etapas para que se vire right uns degrees:
  Atribua o degrees times 10 e 3600 a um fração.
  Vire right a fração.

Etapas para que se vire uns degrees:
  Atribua o degrees times 10 e 3600 a um fração.
  \Se o degrees forem negativo, vire left o fração; volte.
  Vire right a fração.

\Etapas para que se vire à right uma fração igual para um número over um segundo número;
Etapas para que se vire pra right uma fração igual para um número over um segundo número;
Etapas para que se vire para a right uma fração igual para um número over um segundo número;
Etapas para que se vire right uma fração igual para um número over um segundo número:
  Atribua o número à coordenada Y do canto superior esquerdo desta fração.
  Atribua o segundo número à coordenada Y do canto inferior direito desta fração.
  Vire right a fração.

\Etapas para que se vire à right uma fração of o caminho;
Etapas para que se vire pra right uma fração of o caminho;
Etapas para que se vire para a right uma fração of o caminho;
Etapas para que se vire right uma fração of o caminho;
Etapas para que se vire right uma fração of o caminho around;
Etapas para que se vire right um fração:
  Vire a fração.

Etapas para que se vire right uma fração of o caminho uns percentual of o time;
Etapas para que se vire right uma fração about uns percentual of o time;
Etapas para que se vire right uma fração of o caminho about uns percentual of o time;
Etapas para que se vire right uma fração uns percentual of o time:
  Escolha aleatoriamente um número entre 1 e 100.
  Se o número for maior do que o percentual, cancele.
  Vire right a fração.

\Etapas para que se vire uns points à right;
\Etapas para que se vire uns points pra right;
Etapas para que se vire uns points para a right;
Etapas para que se vire right uns points:
  Atribua o points e 3840 a um fração.
  Vire right a fração.

Etapas para que se unlock um gpBitmap usando um BitmapData:
  Call "gdiplus.dll" "GdipBitmapUnlockBits" com 
    O gpBitmap e 
  o endereçamento deste BitmapData.

Etapas para que se exponha tudo:
  Call "gdi32.dll" "SelectClipRgn" com 
    O quadro atual 
    e 0.

Etapas para que se exponha conteúdo de uma caixa:
  Crie um hRgn usando a caixa.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de uma elipse:
  Crie um hRgn usando a elipse.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de um hRgn:
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual e 
  o hRgn e 2 [RGN_OR].

Etapas para que se exponha conteúdo de um polígono:
  Crie um hRgn usando o polígono.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha conteúdo de uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Mostre dentro de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma caixa:
  Crie um hRgn usando a caixa.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma elipse:
  Crie um hRgn usando a elipse.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de um hRgn:
  Crie um old hRgn usando o zero caixa.
  Call "gdi32.dll" "GetClipRgn" com 
    O quadro atual e 
  o old hRgn 
    devolvendo um número.
  Se o número não for 1, limpe o old hRgn.
  Call "gdi32.dll" "SelectClipRgn" com 
    O quadro atual 
    e 0.
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O hRgn 
    e 4 [RGN_DIFF].
  Call "gdi32.dll" "ExtSelectClipRgn" com 
    O quadro atual 
    e O old hRgn 
    e 2 [RGN_OR].
  Destrua o old hRgn.

Etapas para que se exponha exterior de um polígono:
  Crie um hRgn usando o polígono.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se exponha exterior de uma caixa arredondada:
  Crie um hRgn usando a caixa arredondada.
  Mostre fora de o hRgn.
  Destrua o hRgn.

Etapas para que se renove a tela;
Etapas para que se mostre;
Etapas para que se mostre tudo;
Etapas para que se mostre exponha o canvas;
Etapas para que se atualize a tela:
  Atualize a tela usando a caixa desta tela.

Um número de porta é um número.
Um nome de protocolo é uma string.
Um nome de host é uma string.
Um parâmetro de consulta é uma string.
Um endereço de recurso é uma string.

Uma URL simplificada é um conjunto com
  Um nome do protocolo,\lpszScheme? dwFlags? -> exemplo: http / ftp / https / etc
  Um nome de host, \lpszHostName ?  -> exemplo: www.google.com ou mail.stackoverflow.com
  Um endereço de recurso, \lpszUrlPath? -> exemplo: index.html ou /css/style.css ou questions/SubmitQuestion.aspx
  Um parâmetro de consulta, \lpszExtraInfo? -> exemplo: ?useLiveData=1&internal=0
  Um número de porta. \ nPort? -. números de porta ocupam (geralmente) 16 bits

Um série de vértices é um endereço de memória para uma série de vértices conjunto.

Uma quantidade de vértices é um número.

Um série de vértices conjunto é um conjunto com 
  Uma quantidade de vértices e 
  Uma endereço de memória da localização.

Um vértice é uma coisa com 
  Uma coordenada X, 
  Uma coordenada Y, 
  Uma localização sob a coordenada X.

Etapas para que se aguarde por um event;
Etapas para que se desenfileire um event:
  Yield para windows.
  Atribua o first desta fila de eventos ao event.
  Se o event for inexistente, repita.
  Remove o event desde a fila de eventos.
  Se a categoria deste event for "fechamento do programa", destrua o event; volte.
  Destrua o evento atual.
  Atribua o event ao evento atual.

Etapas para que se aguarde uns milliseconds;
Etapas para que se espere uns milliseconds;
Etapas para que se aguarde por uns milliseconds:
  Se o milliseconds forem menor do que ou igual para 0, cancele.
  Call "kernel32.dll" "Sleep" com os milliseconds. \ https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep

Etapas para que se aguarde até finalizar a narração;
Etapas para que se aguarde até que a narração esteja finalizada;
Etapas para que se aguarde até finalizarmos narração;
Etapas para que se aguarde até que narração esteja concluída:
  Se o talker for inexistente, cancele.
  Call o WaitUntilDone  desta vtable [SpVoice] deste talker com o talker e -1.

Etapas para que se aguarde até que pressionemos uma tecla;
Etapas para que se aguarde até pressionarmos uma tecla;
Etapas para que se aguarde por uma tecla;
Etapas para que se aguarde o pressionamento de uma tecla;
Etapas para que se aguarde pelo pressionamento de uma tecla;
Etapas para que se aguarde uma tecla ser pressionada;
Etapas para que se aguarde uma tecla:
  Aguarde pela tecla para go para baixo.
  Aguarde pela tecla para come para cima.
  Desmanche all events.

Um wave file é um endereço completo.

Um wave é um texto hexadecimal.

Uma largura é uns twips.

Etapas para que se wrap um text:
  Se o text for inexistente, cancele.
  Se o wrap detector deste text não estiver ativo, cancele.
  Converta o anchor deste text para um posicionamento absoluto usando o text.
  Converta o cursor de texto deste text para uma segunda posicionamento absoluto usando o text.
  Atribua a scale deste text a um fração.
  Redimensione proporcionalmente o text para 1/1.
  Extraia uma string desde o text.
  Posponha o retorno de carro para a string.
  Destrua as rows deste text.
  Lance um percorredor sobre a string.
  Crie o número da fonte of o memory canvas usando a font deste text.
  Percorra. [o código abaixo]
    Mova o percorredor usando a caixa deste text (word wrapping rules).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Crie uma row usando o segmento inicial deste percorredor.
    Posponha a row para as rows deste text.
  Repita. [o código acima]
  Destrua o número da fonte of o memory canvas.
  Renumere as rows deste text.
  Redimensione proporcionalmente o text para a fração.
  Converta o posicionamento absoluto para o anchor deste text usando o text.
  Converta a segunda posicionamento absoluto para o cursor de texto deste text usando o text.
  Limite a origem of o text.

Etapas para que se salve um trecho em um file;
Etapas para que se armazene um trecho em um file;
Etapas para que se grave um trecho em um file;
Etapas para que se escreva um trecho para um file:
  Limpe o erro do fluxo de entrada/saída.
  Call "kernel32.dll" "SetFilePointer" com 
    O file 
    e 0 
    e 0 
    e 0 [FILE_BEGIN] 
    devolvendo um número resultante.
  Se o número resultante for -1, atribua "Ocorreu um erro durante o posicionamento do ponteiro do arquivo." ao erro do fluxo de entrada/saída; volte.
  Call "kernel32.dll" "WriteFile" com 
    O file e 
  o caractere inicial deste trecho 
    e A quantidade de caracteres deste trecho 
    e O endereçamento desse número 
    e 0 
    devolvendo o número resultante.
  Se o número resultante for 0, atribua "Ocorreu um erro durante a gravação do arquivo." ao erro do fluxo de entrada/saída; volte.

Etapas para que se salve um trecho em um endereço completo;
Etapas para que se armazene um trecho em um endereço completo;
Etapas para que se grave um trecho em um endereço completo;
Etapas para que se escreva um trecho para um endereço completo:
  Limpe o erro do fluxo de entrada/saída.
  Extraia um endereço da pasta desde o endereço completo.
  Se o endereço da pasta não estiver no sistema de arquivos, atribua "A pasta: " junto com o endereço da pasta seguido de " não existe." ao erro do fluxo de entrada/saída; volte.
  Defina o endereço completo para read-write mode.
  Isole o endereço completo.
  Termine com o caractere NULL o endereço completo.
  Call "kernel32.dll" "CreateFileA" com 
    O caractere inicial deste endereço completo 
    e 1073741824 [GENERIC_WRITE] 
  And 0 e 0 e 2 [CREATE_ALWAYS] 
    e -2147483520 [FILE_FLAG_WRITE_THROUGH ou FILE_ATTRIBUTE_NORMAL] 
    e 0 
    devolvendo um número identificador.
  Se o número identificador for -1 [INVALID_HANDLE_VALUE], atribua "Ocorreu um erro ao tentar abrir o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída; volte.
  Call "kernel32.dll" "WriteFile" com 
    O número identificador 
    e O caractere inicial deste trecho 
    e A quantidade de caracteres deste trecho 
    e O endereçamento desse número 
    e 0 
    devolvendo o número.
  Call "kernel32.dll" "CloseHandle" com 
    O número identificador.
  Se o número não for 0, cancele.
  Atribua "Ocorreu um erro ao tentar salvar o arquivo: " junto com o endereço completo seguido de "." ao erro do fluxo de entrada/saída.

Etapas para que se escreva um pedaço:
  Atribua o pedaço a uma string.
  Escreva a string.

Etapas para que se escreva um pedaço para StdOut:
  Call "kernel32.dll" "WriteFile" com \ https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile
    O stdout handle [hFile] \Um identificador para o arquivo ou dispositivo de E / S
  \(por exemplo, um arquivo, fluxo de arquivo, disco físico, volume, buffer de console, unidade de fita, soquete, recurso de comunicação, processador de mensagens ou canal).
    e O endereçamento deste pedaço [lpBuffer] \Um ponteiro para o buffer que contém os dados a serem gravados no arquivo ou dispositivo.
    e 1 [nNumberOfBytesToWrite] \ representa o nº de bytes a serem gravados no arquivo ou dispositivo.
    e O endereçamento desse número [lpNumberOfBytesWritten]  \Um ponteiro para a variável que recebe o número de bytes gravados ao usar um parâmetro hFile síncrono . 
    e nil. [lpOverlapped] \ serve pra especificar se deseja gravar em outra região, por exemplo o final do arquivo. 

Etapas para que se escreva um pedaço sem passar pra próxima linha:
  Atribua o pedaço a uma string.
  Escreva a string sem passar pra próxima linha.

     \ will translate para English because "Converta um detector" é used para externalize reams pelo caderno
Etapas para que se escreva um detector:
  Converta o detector para uma string.
  Escreva a string.

Etapas para que se escreva um detector sem passar pra próxima linha:
  Converta o detector para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um fração:
  Converta a fração para uma string.
  Escreva a string.

Etapas para que se escreva uma fração sem passar pra próxima linha:
  Converta a fração para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um número:
  Converta o número para uma string.
  Escreva a string.

Etapas para que se escreva um número sem passar pra próxima linha:
  Converta o número para uma string.
  Escreva a string sem passar pra próxima linha.

Etapas para que se escreva um número sobre um console:
  Converta o número para uma string.
  Escreva a string sobre o console.

Etapas para que se escreva uns quoras em uma caixa: \descomentar pra ver o que acontece
  \Pinte a caixa com a cor vermelha e a cor preta. \ temp ***
  Atribua a caixa a uma quora caixa.
  Atribua a coordenada Y do canto superior esquerdo desta quora caixa mais 24 pixels à coordenada Y do canto inferior direito desta quora caixa.
  Percorra. [o código abaixo]
    Obtenha um quora desde o quoras.
    Se o quora for inexistente, pare.
  \pinte really fast. ***
    Pinte o quora caixa com a cor amarela. \ temp ***
    Escreva a string deste quora no quora caixa com a cor deste quora.
    Mova o quora caixa para baixo 24 px.
  Repita. [o código acima]

Etapas para que se yield para windows:
  Se a fila de eventos não estiver vazio, cancele.
  Call "user32.dll" "GetMessageA" com 
    O endereçamento dessa MSG 
    e 0 
    e 0 
    e 0 
    devolvendo um número.
  Se o número for 0, cancele.
  Call "user32.dll" "TranslateMessage" com 
    O endereçamento desta MSG.
  Call "user32.dll" "DispatchMessageA" com 
    O endereçamento desta MSG.

Etapas para que se zero uma caixa:
    \ was clear uma caixa, got confounded com "clear uma caixa " (which deveria pinte a caixa all black como does "clear o tela")
  Atribua 0 à coordenada X do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada Y do canto superior esquerdo desta caixa.
  Atribua 0 à coordenada X do canto inferior direito desta caixa.
  Atribua 0 à coordenada Y do canto inferior direito desta caixa.

O zero caixa é uma caixa.

Etapas para que se zero preencha um número usando uma contagem e posponha it para uma string:
  Converta o número para uma segunda string.
  Zero preencha a segunda string usando a contagem.
  Posponha a segunda string para a string.

O zero linha reta é uma linha reta. \ tracer

O zero localização é uma localização.

O erro do fluxo de entrada/saída é uma string.

