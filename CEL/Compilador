\ O compilador copyright © 2006-2021 a ordem osmosiana
\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

 \Este compilador armazena strings em duas partes para que seja fácil trocar o primeiro e o último bytes de uma string, com um pequeno comando como este:
 \ Permute o conteúdo deste caractere inicial desta string com o conteúdo do caractere final desta string.
 \Todos os parâmetros são passados por referência, então a string modificada é retornada na variável passada, que é a maneira natural e óbvia de fazer isso.
 \Por exemplo, se você passar o saleiro para alguém na mesa de jantar e ela usar um pouco, você receberá o saleiro de volta com menos sal do que quando passou.
\Quando um parâmetro é passado "por referência", o chamador e o receptor usam a mesma variável para o parâmetro. 
\Se o receptor modifica a variável do parâmetro, o efeito é visível para a variável do chamador.
\Quando um parâmetro é passado "por valor", o chamador e o receptor têm duas variáveis independentes com o mesmo valor. 
\Se o receptor modifica a variável de parâmetro, o efeito não é visível para o chamador.

Uma mensagem de erro é uma string.
Uma contagem de nomes é uma contagem.

O temporizador de escrita é um temporizador. \ Um temporizador é um estrutura com uma contagem, uns intervalos iniciais e uns intervalos totais. \ Um intervalo é um número.
O temporizador de transmutação é um temporizador.
O temporizador de análise/verificação é um temporizador.
O temporizador de resolução de variáveis globais é um temporizador.
O temporizador de resolução de tipos é um temporizador.
O temporizador de operacionalização é um temporizador.
O temporizador de deslocamentos é um temporizador.
O temporizador de vinculação é um temporizador.
O temporizador de ferramentas de catalogação é um temporizador.
O temporizador de compilação do conteúdo das rotinas é um temporizador.
O temporizador de compilação de cabeçalhos de rotina é um temporizador.
O temporizador de etapas de cálculo é um temporizador.
O temporizador de endereçamento é um temporizador.
O temporizador de adição de rotinas pré-definidas de mémoria é um temporizador.
O temporizador de adição de rotinas pré-definidas de inicialização é um temporizador.

A etiqueta de interrupção é uma etiqueta igual a 1.
A etiqueta de demanda externa é uma etiqueta igual a 2.
A etiqueta de demanda indireta é uma etiqueta igual a 3.
A etiqueta de demanda interna é uma etiqueta igual a 4.
A etiqueta de revogação é uma etiqueta igual a 5.
A etiqueta delimitadora de bloco condicional é uma etiqueta igual a 6.
A etiqueta conclusiva é uma etiqueta igual a 7.
A etiqueta de retorno é uma etiqueta igual a 8.
A etiqueta de finalização é uma etiqueta igual a 9.
A etiqueta de acréscimo é uma etiqueta igual a 10.
A etiqueta de decodificação é uma etiqueta igual a 11.
A etiqueta de desvio falso é uma etiqueta igual a 12.
A etiqueta de carregamento de endereço é uma etiqueta igual a 13.
A etiqueta de carregamento de registrador EAX é uma etiqueta igual a 14.
A etiqueta de laço é uma etiqueta igual a 15.
A etiqueta de negação lógica é uma etiqueta igual a 16.
A etiqueta preliminar é uma etiqueta igual a 17.
A etiqueta de inserção de endereço [na stack] é uma etiqueta igual a 18.
A etiqueta de inserção de valor [na stack] é uma etiqueta igual a 19.
A etiqueta de obtenção do registrador EAX é uma etiqueta igual a 20.
A etiqueta de repetição é uma etiqueta igual a 21.
A etiqueta de endereço de rotina é uma etiqueta igual a 22.

O compilador é um estrutura com
  Um endereço da pasta,
  Um temporizador,
  Um detector de erros, 
  Um mensagem de erro,
  Um endereço do arquivo atual,
  Um número da linha de erro,
  Uma contagem de nomes,
  Um trecho EXE,
  Um trecho de listagem.

Um trecho de listagem é um trecho.

Um endereço do arquivo atual é um endereço completo.

Etapas para que se apresente uma mensagem de erro contendo uma string:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Ative o detector de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.

Etapas para que se apresente uma mensagem de erro contendo uma string e um ponteiro do byte:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Ative o detector de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.
  Encontre o endereço do arquivo atual deste compilador e o número da linha de erro deste compilador usando o ponteiro do byte .
  Se o endereço do arquivo atual deste compilador estiver em branco, retorne.
  Extraia um nome do arquivo desde o endereço do arquivo atual deste compilador.
  Anteponha "Erro no " junto com o nome do arquivo seguido de ". " para a mensagem de erro deste compilador.

Etapas para que se apresente uma mensagem de erro contendo uma string e um percorredor:
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo a string e o caractere inicial deste segmento inicial deste percorredor; retorne.
  Apresente a mensagem de erro contendo a string e o caractere final deste segmento final deste percorredor.

Etapas para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Adicione a rotina de finalização pelo tipo.
  Adicione a rotina de alocação para o tipo.
  Adicione a rotina de desalocação para o tipo.
  Adicione a rotina de destruição pelo tipo.
 Recomece. [percorra novamente o código acima]

Etapas para que se adicione o rotina de alocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o conteúdo tipo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "Aloque memória para um " junto com o nome deste tipo para o string do cabeçalho desta rotina. \ traduzir aqui
  Posponha "Associe o " junto com o nome deste tipo seguido de " usando " para a string do corpo desta rotina. \Nomeie
  Posponha a quantidade de caracteres deste conteúdo tipo deste tipo seguido de "." para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre o string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "~Initialize before run e Run e Finalize after run" para o string do cabeçalho desta rotina.
  Posponha "Initialize before run. " para a string do corpo desta rotina.
  Posponha os global initializers para a string do corpo desta rotina.
  Posponha "Execute o programa. " para a string do corpo desta rotina. \ traduzir
  Posponha os global finalizers para a string do corpo desta rotina.
  Posponha "Finalize after run. " para a string do corpo desta rotina.
  Posponha "Processe ""kernel32.dll"" ""ExitProcess"" com 0. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre o string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.
  Compile o corpo of a rotina.

Etapas para que se adicione os built-in tipos:
  Adicione um built-in tipo usando "byte" e "bytes" e 1.
  Adicione um outro built-in tipo usando "estrutura" e "estruturas" e 0.

Etapas para que se adicione um built-in tipo usando um nome e um plural nome e uma quantidade de caracteres:
  Adicione o built-in tipo para os tipos usando o nome e o plural nome e o nome.
  Atribua a quantidade de caracteres à quantidade de caracteres deste built-in tipo.
  Atribua o built-in tipo ao tipo base deste built-in tipo.
  Catalogue o built-in tipo.

Etapas para que se adicione o rotina de desalocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o conteúdo tipo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "Desaloque um " junto com o nome deste tipo para o string do cabeçalho desta rotina.
  Posponha "Se o " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o conteúdo tipo deste tipo deveria ser finalizado, posponha "~Finalize o conteúdo de este " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina. \ precisa ter uma rotina de destruição gerada automaticamente para ele "
  Posponha "Desassocie o " junto com o nome deste tipo seguido de "." para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre o string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione o rotina de destruição por um tipo:
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo não deveria ser ignorado, retorne.
  Se o tipo puder ser reduzido para "listas", adicione o rotina de destruição pelo tipo (listas); retorne.
  Se o tipo puder ser reduzido para "ponteiro", adicione o rotina de destruição pelo tipo (ponteiro); retorne.

Etapas para que se adicione o rotina de destruição por um tipo (ponteiro):
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua "Destrua [" junto com o nome deste tipo seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "Destrua um " junto com o nome deste tipo para o string do cabeçalho desta rotina.
  Posponha "Se o " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o conteúdo tipo deste tipo puder ser reduzido para "ponteiro", posponha "Destrua o conteúdo de este " junto com o nome deste tipo seguido de "'. " para a string do corpo desta rotina.
  Se o conteúdo tipo deste tipo puder ser reduzido para "listas", posponha "Destrua o conteúdo de este " junto com o nome deste tipo seguido de "'. " para a string do corpo desta rotina.
  Comece. [a executar o código abaixo]
    Obtenha um campo desde os campos deste conteúdo tipo deste tipo.
    Se o campo for inexistente, pare.
    Se o detector de referência deste campo estiver ativo, recomece.
    Se o tipo deste campo não deveria ser ignorado, recomece.
    Posponha "Destrua o " junto com o nome deste tipo seguido de "'s " junto com o nome deste campo seguido de ". " para a string do corpo desta rotina.
  Recomece. [percorra novamente o código acima]
  Posponha "Desaloque o " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina. \ traduzir aqui
  Lance a cabeçalho de rotina desta rotina sobre o string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione o rotina de destruição por um tipo (listas):
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.  
  Se o first campo destes campos deste tipo for inexistente, apresente uma mensagem de erro contendo "Erro interno #1'"; retorne. \
  Se o tipo deste first campo destes campos deste tipo for inexistente, apresente a mensagem de erro contendo "Erro interno #2'"; retorne.
  Atribua "Destrua [" junto com o nome deste tipo seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "Destrua um " junto com o nome deste tipo para o string do cabeçalho desta rotina.
  Posponha "Se o " junto com o nome deste tipo seguido de "'s first for inexistente, retorne. " para a string do corpo desta rotina. \ listas duplamente encadeadas
  Atribua o nome deste tipo deste first campo destes campos deste tipo para um nome.
  Posponha "Atribua o " junto com o nome deste tipo seguido de "'s first para um " junto com o nome seguido de ". " para a string do corpo desta rotina.
  Posponha "Remove o " junto com o nome seguido de " desde o " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  Posponha "Destrua o " junto com o nome seguido de ". " para a string do corpo desta rotina.
  Posponha "Recomece. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre o string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Um nome da DLL é um nome.
Um nome da função é um nome.

Etapas para que se adicione um função para umas DLLs usando uma nome da DLL e um nome da função:
  Encontre uma DLL usando a nome da DLL.
  Se a DLL for inexistente, adicione a DLL para as DLLs usando a nome da DLL.
  Encontre a função usando a nome da função e as funções desta DLL.
  Se a função não for inexistente, retorne.
  Crie a função.
  Posponha a função para as funções desta DLL.
  Atribua a nome da função ao nome desta função.

Etapas para que se adicione um campo para uns campos usando um nome e um apelido e um nome do tipo e um detector:
  Adicione o campo para o campos usando "campo" e nil.
  Atribua o nome ao nome deste campo.
  Atribua o apelido ao apelido deste campo.
  Atribua o nome do tipo ao nome do tipo deste campo.
  Atribua um detector de referência ao detector de referência deste campo.

Etapas para que se adicione a rotina de finalização por um tipo:
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo não deveria ser finalizado, retorne.
  Se o nome deste tipo for "string", adicione a rotina de finalização pelo tipo (cadeia de caracteres); retorne.
  Se o nome deste tipo for "texto", adicione a rotina de finalização pelo tipo (cadeia de caracteres); retorne.
  Se o tipo puder ser reduzido para "string", retorne. \ prevents generation of finalizer por derived string tipos
  Se o tipo puder ser reduzido para "texto", retorne.
  Adicione a rotina de finalização pelo tipo (estrutura).

Etapas para que se adicione a rotina de finalização por um tipo (estrutura):
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "~Finalize um " junto com o nome deste tipo para o string do cabeçalho desta rotina.
  Posponha "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> push the 4 bytes value in EAX onto the stack
  \The push instruction places its operand onto the top of the hardware supported stack in memory. 
  \Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location sob address [ESP]. 
  \ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde high addresses to lower addresses.
  Comece. [a executar o código abaixo]
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, pare.
    Se o tipo deste campo não deveria ser finalizado, recomece.
    Posponha "~Finalize o " junto com o nome deste tipo seguido de "'s " junto com o nome deste campo seguido de ". " para a string do corpo desta rotina.
  Recomece. [percorra novamente o código acima]
  Posponha "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> pop the top element of the stack into memory ar the four bytes starting at location EAX.
  \  \pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location). 
  \It first moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre o string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione a rotina de finalização por um tipo (cadeia de caracteres):
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "~Finalize um " junto com o nome deste tipo para o string do cabeçalho desta rotina.
  Posponha "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> push the 4 bytes value in EAX onto the stack
  \ Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location sob endereço [ESP]. 
  \ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde high addresses to lower addresses.
  Posponha "Desassocie o caractere inicial de esta string . " para a string do corpo desta rotina. \\ traduzir string aqui  
  Posponha "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> pop the top element of the stack into memory at the four bytes starting at location EAX.
  \pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location). 
  \ It first moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre o string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione um fragmento usando uma etiqueta:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Posponha o fragmento para os fragmentos desta rotina utilizada atualmente.

Etapas para que se adicione um fragmento usando uma etiqueta e um função:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Posponha o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a função à função deste fragmento.

Etapas para que se adicione um fragmento usando uma etiqueta e um detector:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Posponha o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua o detector ao detector deste fragmento.

Etapas para que se adicione um fragmento usando uma etiqueta e uma rotina:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Posponha o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a rotina à rotina deste fragmento.
  Compile o corpo of a rotina.

Etapas para que se adicione um fragmento usando uma etiqueta e uma variável:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Posponha o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Ative o compiled detector na variável.

Etapas para que se adicione um fragmento usando uma etiqueta e uma variável e uma segunda variável:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Posponha o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Atribua a segunda variável ao segunda variável deste fragmento.
  Ative o compiled detector na variável.
  Ative o compiled detector na segunda variável.

Etapas para que se adicione um fragmento usando uma etiqueta e uma variável e um número:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Posponha o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Atribua o número ao número deste fragmento.
  Ative o compiled detector na variável.

Etapas para que se adicione uma DLL para umas DLLs usando uma nome da DLL:
  Crie a DLL.
  Posponha a DLL para as DLLs.
  Atribua a nome da DLL ao nome desta DLL.

Etapas para que se adicione um intermediate usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente, esvazie o intermediate; retorne.
  Adicione o intermediate para as variáveis locais desta rotina utilizada atualmente usando "local" e o endereço local.
  Gere o nome deste intermediate usando "~I".
  Atribua o nome do tipo ao nome do tipo deste intermediate.
  Resolva o intermediate.

Etapas para que se adicione um literal para uns variáveis usando um endereço local:
  Adicione o literal como uma variável para as variáveis usando "literal" e o endereço local.
  Gere o nome deste literal usando "~L".

Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando um expression:
  Crie a unidade semântica.
  Posponha a unidade semântica para as unidades semânticas.
  Atribua a phrase desta expression à string desta unidade semântica.
  Atribua a variável desta expression à variável desta unidade semântica.
  Se a variável desta expression não for inexistente, atribua o tipo desta expression ao tipo desta unidade semântica.

  \# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando uma string: \ creio que isso aqui ajude nas funções
  Crie a unidade semântica.
  Posponha a unidade semântica para as unidades semânticas.  
  \\ conjunções
  Se a string for "e", atribua "e" à string desta unidade semântica; retorne. \ and
  Se a string for "ou", atribua "ou" à string desta unidade semântica; retorne. \ or
  \ usando
  Se a string for "desde", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "a partir de", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "partindo de", atribua "usando" à string desta unidade semântica; retorne.
  \Se a string for "de", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "dada", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "dado", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "dadas", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "dados", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "com", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "usando", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "contendo", atribua "usando" à string desta unidade semântica; retorne.
  \\ para
  \Se a string for "em", atribua "para" à string desta unidade semântica; retorne. 
  Se a string for "a", atribua "para" à string desta unidade semântica; retorne. \  ver isso aqui com calma
  Se a string for "para", atribua "para" à string desta unidade semântica; retorne.
  \\ VERBO SER/ESTAR
  Se a string for "é", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "está", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "for", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "foi", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "foram", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "forem", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estiver", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estiverem", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estamos", atribua "é" à string desta unidade semântica; retorne.
  \Se a string for "seja", atribua "é" à string desta unidade semântica; retorne.
  \Se a string for "tem", atribua "é" à string desta unidade semântica; retorne.
  \Se a string for "tiver", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "são", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estão", atribua "é" à string desta unidade semântica; retorne.  
  Se a string for "forem", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estiverem", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "puder", atribua "pode" à string desta unidade semântica; retorne.
  Se a string for "puderem", atribua "pode" à string desta unidade semântica; retorne.
  Se a string for "existe", atribua "existe" à string desta unidade semântica; retorne.
  Se a string for "existir", atribua "existe" à string desta unidade semântica; retorne.
  \\ allocates e destroys  
  \Se a string for "aloque", atribua "allocate" à string desta unidade semântica; retorne.  
  Se a string for "pelo", atribua "por o" à string desta unidade semântica; retorne.
  Se a string for "pela", atribua "por o" à string desta unidade semântica; retorne.  
  \Se a string for "desaloque", atribua "desaloque" à string desta unidade semântica; retorne.
  \Se a string for "esvazie", atribua "deallocate" à string desta unidade semântica; retorne.
  \Se a string for "destrua", atribua "destrua" à string desta unidade semântica; retorne.
  \\ usando    
  Se a string for "com", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "usando", atribua "usando" à string desta unidade semântica; retorne.
  \ é
  Se a string for "is", atribua "é" à string desta unidade semântica; retorne.
  \ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
  Se a string for "backward", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "backwards", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "counterclockwise", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "counter-clockwise", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "anticlockwise", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "anti-clockwise", atribua "backward" à string desta unidade semântica; retorne.
  \ sobre
  Se a string for "sob", atribua "sobre" à string desta unidade semântica; retorne.
  Se a string for "on", atribua "sobre" à string desta unidade semântica; retorne.
  Se a string for "sobre", atribua "sobre" à string desta unidade semântica; retorne.
  \ other
  Atribua a string à string desta unidade semântica.

Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando um tipo:
  Crie a unidade semântica.
  Posponha a unidade semântica para as unidades semânticas.
  Atribua o tipo ao tipo desta unidade semântica.

Etapas para que se adicione push fragmentos usando umas unidades semânticas:
  Se a rotina utilizada atualmente for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde as unidades semânticas (backwards).
    Se a unidade semântica for inexistente, retorne.
    Se a variável desta unidade semântica for inexistente, recomece.
    Se o subtexto atual desta unidade semântica não estiver em branco, recomece.
    Se o tipo atual desta unidade semântica for inexistente, recomece.
    Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável desta unidade semântica.
  Recomece. [percorra novamente o código acima]

Etapas para que se adicione o atribua ou converta fragmentos usando uma variável e uma segunda variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Encontre uma rotina usando "atribua" e o tipo desta variável e "para" e o tipo desta segunda variável.
  Se a rotina for inexistente, encontre a rotina usando "converta" e o tipo desta variável e "para" e o tipo desta segunda variável.
  Se a rotina não for inexistente, adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina; retorne.
  \ Mensagem de Erro
  Adicione uma unidade semântica para umas unidades semânticas usando "atribua/converta".
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione um terceiro unidade semântica para as unidades semânticas usando "para/a".
  Adicione um quarto unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Apresente uma mensagem de erro contendo "Eu não sei como: " junto com a representação interna da rotina seguido de "." e o endereço local.

Etapas para que se adicione uma rotina para umas rotinas usando um endereço local:
  Crie a rotina.
  Posponha a rotina para as rotinas.
  Atribua o endereço local ao endereço local desta rotina.

Etapas para que se adicione um scratch usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente, esvazie o scratch; retorne.
  Adicione o scratch para as variáveis locais desta rotina utilizada atualmente usando "scratch" e o endereço local.
  Gere o nome deste scratch usando "~S".
  Atribua o nome do tipo ao nome do tipo deste scratch.
  Resolva o scratch.

Etapas para que se adicione several fragmentos usando uma string e uma variável e uma segunda string e uma segunda variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione um terceiro unidade semântica para as unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " junto com a representação interna da rotina seguido de "." e o endereço local; retorne.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione several fragmentos usando uma string e uma variável e uma segunda string e uma segunda variável e uma terceira string e um terceira variável e um ponteiro do byte :
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e o terceira variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um terceiro fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione um terceiro unidade semântica para as unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Adicione um quinto unidade semântica para as unidades semânticas usando a terceira string.
  Adicione um sexto unidade semântica para as unidades semânticas usando o tipo desta terceira variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " junto com a representação interna da rotina seguido de "." e o ponteiro do byte; retorne.
  Adicione um quarto fragmento usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione um arquivo fonte para uns arquivos fontes usando um endereço completo:
  Crie o arquivo fonte.
  Posponha o arquivo fonte para os arquivos fontes.
  Atribua o endereço completo ao endereço completo deste arquivo fonte.

Etapas para que se adicione two fragmentos usando uma string e uma variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro. A rotina para que se '" junto com a representação interna da rotina seguido de "' ainda não foi definida." e o endereço local; retorne.
  Adicione um segundo fragmento usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione um tipo para uns tipos usando um endereço local:
  Crie o tipo.
  Posponha o tipo para o tipos.
  Atribua o endereço local ao endereço local deste tipo.

Etapas para que se adicione um tipo para uns tipos usando um nome e um plural nome e um base nome:
  Adicione o tipo para os tipos usando o nome e o plural nome e o base nome e nil.

Etapas para que se adicione um tipo para uns tipos usando um nome e um plural nome e um base nome e um endereço local:
  Crie o tipo.
  Posponha o tipo para o tipos.
  Atribua o endereço local ao endereço local deste tipo.
  Atribua o nome ao nome deste tipo.
  Atribua o plural nome ao plural nome deste tipo.
  Atribua o base nome ao base nome deste tipo.

Etapas para que se adicione uma variável para uns variáveis usando um categoria e um endereço local:
  Crie a variável usando a categoria.
  Posponha a variável para as variáveis.
  Atribua o endereço local ao endereço local desta variável.

  

Etapas para que se enderece uns funções:
  Obtenha um função desde o funções.
  Se a função for inexistente, retorne.
  Enderece o função.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece um função:
  Atribua o endereço do nome usado atualmente ao endereço do nome desta função.
  Atribua a quantidade de caracteres deste nome deste função mais 3 para um número.
  Arredonde o número para cima usando o múltiplo imediato de 2.
  Adicione o número para o endereço do nome usado atualmente.
  Atribua o endereço pré-calculado atual ao endereço thunk desta função.
  Atribua o image base mais o endereço pré-calculado atual ao endereço desta função.
  Adicione 4 para o endereço pré-calculado atual.

Etapas para que se enderece um fragmento usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o fragmento for inexistente, retorne.
  Atribua o image base mais o endereço ao endereço deste fragmento.
  Se a etiqueta deste fragmento for a etiqueta de inserção de endereço [na stack], adicione 7 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda interna, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de endereço, adicione 12 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de acréscimo, adicione 10 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de revogação, adicione 14 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de desvio falso, adicione 9 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de negação lógica, adicione 3 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de retorno, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de repetição, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de interrupção, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta preliminar, enderece o fragmento usando o endereço (etapa preliminar); retorne.
  Se a etiqueta deste fragmento for a etiqueta conclusiva, enderece o fragmento usando o endereço (etapa conclusiva); retorne.
  Se a etiqueta deste fragmento for a etiqueta de decodificação, adicione a quantidade de caracteres deste código deste fragmento para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de inserção de valor [na stack], enderece o fragmento usando o endereço (empilhamento de valor); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda externa, adicione 6 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de registrador EAX, adicione 5 para o endereço; retorne. \ Era 8 quando "load eax" aceitava variáveis; agora "load eax" só aceita números
  Se a etiqueta deste fragmento for a etiqueta de obtenção do registrador EAX, enderece o fragmento usando o endereço (registrador EAX); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda indireta, adicione 8 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de endereço de rotina, adicione 12 para o endereço; retorne.

Etapas para que se enderece um fragmento usando um endereço (etapa conclusiva):
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.
  Adicione 6 para o endereço.

Etapas para que se enderece um fragmento usando um endereço (etapa preliminar):
  Adicione 3 para o endereço.
  Se o tamanho local desta rotina utilizada atualmente não for 0, adicione 10 para o endereço.
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.

Etapas para que se enderece um fragmento usando um endereço (empilhamento de valor):
  Adicione 6 para o endereço.
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #3."; retorne.
  Se o tipo desta variável deste fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #4"; retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, adicione 2 para o endereço; retorne.
  Se a quantidade de caracteres for 2, adicione 3 para o endereço; retorne.
  Se a quantidade de caracteres for 1, adicione 4 para o endereço; retorne.
  Apresente a mensagem de erro contendo "Erro interno #5".

Etapas para que se enderece um fragmento usando um endereço (registrador EAX):
  Adicione 6 para o endereço.
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #6"; retorne.
  Se o tipo desta variável deste fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #7"; retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, adicione 2 para o endereço; retorne.
  Se a quantidade de caracteres for 2, adicione 3 para o endereço; retorne.
  Se a quantidade de caracteres for 1, adicione 2 para o endereço; retorne.
  Apresente a mensagem de erro contendo "Erro interno #8".

Etapas para que se enderece uns fragmentos usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Enderece o fragmento usando o endereço.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece uma DLL:
  Atribua o endereço do nome usado atualmente ao endereço do nome desta DLL.
  Atribua o endereço do cabeçalho usado atualmente ao endereço do cabeçalho desta DLL.
  Atribua o endereço do nome usado atualmente ao nome memory endereço deste import header desta DLL.
  Atribua a quantidade de caracteres deste nome desta DLL mais 1 para um número.
  Arredonde o número para cima usando o múltiplo imediato de 2.
  Adicione o número para o endereço do nome usado atualmente.
  Adicione a magnitude desse import header para o endereço do cabeçalho usado atualmente. 
  Atribua o endereço pré-calculado atual ao first previamente calculado memory endereço deste import header desta DLL.
  Enderece as funções desta DLL.
  Adicione 4 para o endereço pré-calculado atual.

Etapas para que se enderece umas DLLs usando um endereço:
  Atribua o endereço ao endereço do cabeçalho usado atualmente.
  Atribua as contagem destas DLLs para uma contagem.
  Adicione 1 para a contagem.
  Multiplique a contagem pela magnitude desse import header.
  Atribua o endereço mais a contagem ao endereço pré-calculado atual.
  Obtenha uma segunda contagem usando as DLLs (todas as funções mais os marcadores).
  Multiplique a segunda contagem por 4.
  Atribua o endereço pré-calculado atual mais a segunda contagem ao endereço do nome usado atualmente.
  Comece. [a executar o código abaixo]
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, pare.
    Enderece a DLL.
  Recomece. [percorra novamente o código acima]
  Atribua o endereço do nome usado atualmente menos o endereço para um número.
  Adicione o número para o endereço.

Um endereço é um número.

Etapas para que se enderece uma rotina usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina for inexistente, retorne.
  Se o employs representação interna da rotina desta rotina não estiver em branco, retorne. \ employs são addressed later
  Se o compiled detector desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Atribua o image base mais o endereço ao endereço desta rotina.
  Enderece os fragmentos desta rotina usando o endereço.
  Arredonde o endereço para cima usando o múltiplo imediato de 4.

Etapas para que se enderece umas rotinas usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, pare.
  Enderece a rotina usando o endereço.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece uma variável usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável for inexistente, retorne.
  Se o compiled detector desta variável não estiver ativo, retorne.
  Atribua o image base mais o endereço ao endereço desta variável.
  Adicione a quantidade de caracteres deste tipo desta variável para o endereço.
  Se o tipo desta variável puder ser reduzido para "string", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Se o tipo desta variável puder ser reduzido para "cadeia de caracteres", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Se o tipo desta variável puder ser reduzido para "texto", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Arredonde  para cima o endereço usando o múltiplo imediato de 4.

Etapas para que se enderece uns variáveis usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Enderece a variável usando o endereço.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha um função para um trecho (com separador):
  Se a função for inexistente, posponha "(entrada não inicializada)" para o trecho (com separador); retorne.
  Posponha o nome desta função para o trecho (com separador).

Etapas para que se posponha um detector para um trecho (com separador):
  Converta o detector para uma string.
  Posponha a string para o trecho (com separador).

Etapas para que se posponha os global finalizers para uma string:
  Obtenha um global desde o globals.
  Se o global for inexistente, retorne.
  Se o compiled detector deste global não estiver ativo, recomece.
  Se o tipo deste global não deveria ser finalizado, recomece.
  Posponha "~finalize o " junto com o nome deste global seguido de ". " para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha os global initializers para uma string:
  Obtenha um global desde o globals.
  Se o global for inexistente, retorne.
  Se o literal deste global for inexistente, recomece.
  Se o compiled detector deste global não estiver ativo, recomece.
  Desative um detector.
  Posponha o texto inicializador deste global para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha uma unidade semântica para uma representação interna da rotina :
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, posponha o caractere de espaço para a representação interna da rotina.
  Se o tipo desta unidade semântica não for inexistente, posponha "[" e o nome deste tipo desta unidade semântica e "]" para a representação interna da rotina (fast); retorne. \ moniker
  Se a string desta unidade semântica não estiver em branco, posponha a string desta unidade semântica para a representação interna da rotina ; retorne.

Etapas para que se posponha uma unidade semântica para uma representação interna da rotina (while bubbling):
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, posponha o caractere de espaço para a representação interna da rotina.
  Se o subtexto atual desta unidade semântica não estiver em branco, posponha o subtexto atual desta unidade semântica para a representação interna da rotina ; retorne.
  Se o tipo atual desta unidade semântica não for inexistente, posponha "[" e o nome deste tipo atual desta unidade semântica e "]" para a representação interna da rotina (fast); retorne.

Etapas para que se posponha um número para um trecho (cifra hexadecimal com separador):
  Converta o número para uma cifra hexadecimal.
  Posponha a cifra hexadecimal para o trecho (com separador).

Etapas para que se posponha um número para um trecho (com separador):
  Converta o número para uma string.
  Posponha a string para o trecho (com separador).

Etapas para que se posponha uma proporção para um trecho (com separador):
  Converta a proporção para uma string.
  \ Se a string for "0", posponha "---" para o trecho; retorne.
  Posponha a string para o trecho (com separador).

Etapas para que se posponha uma rotina para um trecho (com separador):
  Se a rotina for inexistente, posponha "(rotina inexistente)" para o trecho (com separador); retorne.
  Posponha a representação interna da rotina deste rotina para o trecho (com separador).

\ Etapas para que se posponha 3 strings distintas para uma string.
Etapas para que se posponha uma string e uma segunda string e uma terceira string para uma quarta string (fast):
  Atribua a quantidade de caracteres desta quarta string para uma quantidade de caracteres. \ Atribua a quantidade de caracteres da 4ª string para uma quantidade de caracteres. 
  Adicione a quantidade de caracteres desta string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 1ª string para a quantidade de caracteres. 
  Adicione a quantidade de caracteres desta segunda string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 2ª string para a quantidade de caracteres. 
  Adicione a quantidade de caracteres desta terceira string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 3ª string para a quantidade de caracteres. 
  Reaponte um ponteiro usando a quantidade de caracteres.
  Atribua o ponteiro para um ponteiro do byte .
  Copie bytes desde o caractere inicial desta quarta string para o ponteiro do byte pelo quantidade de caracteres desta quarta string.
  Adicione a quantidade de caracteres desta quarta string para o ponteiro do byte .
  Copie bytes desde o caractere inicial desta string para o ponteiro do byte pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o ponteiro do byte .
  Copie bytes desde o caractere inicial desta segunda string para o ponteiro do byte pelo quantidade de caracteres desta segunda string.
  Adicione a quantidade de caracteres desta segunda string para o ponteiro do byte .
  Copie bytes desde o caractere inicial desta terceira string para o ponteiro do byte pelo quantidade de caracteres desta terceira string.
  Desassocie o caractere inicial desta quarta string.
  Atribua o ponteiro ao caractere inicial desta quarta string.
  Atribua o ponteiro mais a quantidade de caracteres menos 1 ao caractere final desta quarta string.

Etapas para que se posponha uma string para um trecho (com separador):
  Posponha a string para o trecho.
  Posponha " | " para o trecho.

Etapas para que se posponha uma etiqueta para um trecho (as um fragmento etiqueta string com separador):
  Se a etiqueta for a etiqueta de interrupção, posponha "Interrupção do Laço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda externa, posponha "Demanda Externa" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda indireta, posponha "Demanda Indireta" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda interna, posponha "Demanda Interna" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de revogação, posponha "Dereferência" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta delimitadora de bloco condicional, posponha "Fim de bloco condicional" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta conclusiva, posponha "Epílogo" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de retorno, posponha "Retorno de Rotina" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de finalização, posponha "Finalização" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de acréscimo, posponha "Incremento" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de decodificação, posponha "Decodifique" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de desvio falso, posponha "Desvio de condição insatisfeita" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de carregamento de endereço, posponha "Carregamento de endereço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de carregamento de registrador EAX, posponha "Atribuição EAX" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de laço, posponha "Loop" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de negação lógica, posponha "Negação Lógica" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta preliminar, posponha "Prólogo" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de inserção de endereço [na stack], posponha "Empilhamento de endereço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de inserção de valor [na stack], posponha "Empilhamento de valor" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de obtenção do registrador EAX, posponha "Requisição EAX" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de repetição, posponha "Repetição" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de endereço de rotina, posponha "Endereço de Rotina" para o trecho (com separador); retorne.
  [Caso não seja nenhum dessas etiquetas, então:] Posponha "?" para o trecho (com separador).

Etapas para que se posponha um tipo para um trecho (com separador):
  Se o tipo for inexistente, posponha "(tipo não inicializado)" para o trecho (com separador); retorne.
  Posponha o nome deste tipo para o trecho (com separador).

Etapas para que se posponha uma variável para um trecho (com separador):
  Se a variável for inexistente, posponha "(variável não inicializada)" para o trecho (com separador); retorne.
  Posponha o nome desta variável para o trecho (com separador).

Etapas para que se determine se uma string é algum contração de preposição com artigo definido:
  Se a string for "do", diga sim.
  Se a string for "da", diga sim.
  Se a string for "dos", diga sim.
  Se a string for "das", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de concatenação contraído usando um percorredor:
  Se o segmento inicial deste percorredor de contrações for "seguido", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "seguida", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "junto", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "acompanhado", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for uma variável, recue o percorredor.
  Se o segmento inicial deste percorredor de contrações for algum contração de preposição com artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string está precisando ser decomposta:
  Lance um percorredor sobre a string.
  Se a string for algum operador de concatenação contraído usando o percorredor, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se posponha uma string para uma segunda string usando uma terceira string (para expandir contrações):
  \# contrações
  Se a string for "ao", posponha "a o" para a segunda string; retorne.
  Se a string for "à", posponha "a a" para a segunda string; retorne.
  Se a string for "aos", posponha "a os" para a segunda string; retorne.
  Se a string for "às", posponha "a as" para a segunda string; retorne.
  \Se a string estiver precisando ser decomposta, posponha "de o" para a segunda string; retorne.
  \Se a string for "dos", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, posponha "de os" para a segunda string; exit
  \Se a string for "da", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, posponha "de a" para a segunda string; exit
  \Se a string for "das", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, posponha "de as" para a segunda string; exit
  \Se a string for "do", posponha "de o" para a segunda string; retorne.
  \Se a string for "da", posponha "de a" para a segunda string; retorne.
  \Se a string for "dos", posponha "de os" para a segunda string; retorne.
  \Se a string for "das", posponha "de as" para a segunda string; retorne.
  \Se a string for "dum", posponha "de um" para a segunda string; retorne.
  \Se a string for "duma", posponha "de uma" para a segunda string; retorne.
  \Se a string for "dumas", posponha "de umas" para a segunda string; retorne.
  \Se a string for "duns", posponha "de uns" para a segunda string; retorne.
  Se a string for "daqui", posponha "de aqui" para a segunda string; retorne.
  Se a string for "dali", posponha "de ali" para a segunda string; retorne.
  Se a string for "dele", posponha "de ele" para a segunda string; retorne.
  Se a string for "dela", posponha "de ela" para a segunda string; retorne.
  Se a string for "desse", posponha "de esse" para a segunda string; retorne.
  Se a string for "dessa", posponha "de essa" para a segunda string; retorne.
  Se a string for "desses", posponha "de esses" para a segunda string; retorne.
  Se a string for "dessas", posponha "de essas" para a segunda string; retorne.
  Se a string for "deste", posponha "de este" para a segunda string; retorne.
  Se a string for "desta", posponha "de esta" para a segunda string; retorne.
  Se a string for "destes", posponha "de estes" para a segunda string; retorne.
  Se a string for "destas", posponha "de estas" para a segunda string; retorne.
  Se a string for "disso", posponha "de isso" para a segunda string; retorne.
  Se a string for "disto", posponha "de isto" para a segunda string; retorne.
  Se a string for "nesse", posponha "em esse" para a segunda string; retorne.
  Se a string for "nesses", posponha "em esses" para a segunda string; retorne.
  Se a string for "neste", posponha "em este" para a segunda string; retorne.
  Se a string for "nestes", posponha "em estes" para a segunda string; retorne.
  Se a string for "nisso", posponha "em isso" para a segunda string; retorne.
  Se a string for "nisto", posponha "em isto" para a segunda string; retorne.
  Se a string for "nessa", posponha "em essa" para a segunda string; retorne.
  Se a string for "nessas", posponha "em essas" para a segunda string; retorne.
  Se a string for "nesta", posponha "em esta" para a segunda string; retorne.
  Se a string for "nestas", posponha "em estas" para a segunda string; retorne.
  \Se a string for "donde", posponha "de onde" para a segunda string; retorne.
  \Se a string for "dentre", posponha "de entre" para a segunda string; retorne.
  \Se a string for "dantes", posponha "de antes" para a segunda string; retorne.
  Se a string for "dalguém", posponha "de alguém" para a segunda string; retorne.
  Se a string for "dalgum", posponha "de um" para a segunda string; retorne.
  Se a string for "dalguma", posponha "de uma" para a segunda string; retorne.
  Se a string for "dalguns", posponha "de uns" para a segunda string; retorne.
  Se a string for "dalgumas", posponha "de umas" para a segunda string; retorne.
  Se a string for "nalgum", posponha "em um" para a segunda string; retorne.
  Se a string for "nalguma", posponha "em uma" para a segunda string; retorne.
  Se a string for "nalguns", posponha "em uns" para a segunda string; retorne.
  Se a string for "nalgumas", posponha "em umas" para a segunda string; retorne.
  Se a string for "doutro", posponha "de outro" para a segunda string; retorne.
  Se a string for "doutra", posponha "de outra" para a segunda string; retorne.
  Se a string for "doutros", posponha "de outros" para a segunda string; retorne.
  Se a string for "doutras", posponha "de outras" para a segunda string; retorne.
  Se a string for "noutro", posponha "em outro" para a segunda string; retorne.
  Se a string for "noutra", posponha "em outra" para a segunda string; retorne.
  Se a string for "noutros", posponha "em outros" para a segunda string; retorne.
  Se a string for "noutras", posponha "em outras" para a segunda string; retorne.
  \# "no" pode ser uma negação em inglês.
  Se a string for alguma espécie de contração usando a terceira string (strings em português -> em + o), posponha "em o" para a segunda string; retorne.
  Se a string for "na", posponha "em a" para a segunda string; retorne.
  Se a string for "nos", posponha "em os" para a segunda string; retorne.
  Se a string for "nas", posponha "em as" para a segunda string; retorne.
  \Se a string for "noutro", posponha "em outro" para a segunda string; retorne.
  \Se a string for "noutra", posponha "em outra" para a segunda string; retorne.
  \Se a string for "noutros", posponha "em outros" para a segunda string; retorne.
  \Se a string for "noutras", posponha "em outras" para a segunda string; retorne.
  Se a string for "num", posponha "em um" para a segunda string; retorne.
  Se a string for "numa", posponha "em uma" para a segunda string; retorne.
  Se a string for "nuns", posponha "em uns" para a segunda string; retorne.
  Se a string for "numas", posponha "em umas" para a segunda string; retorne.
  Se a string for "pelo", posponha "por o" para a segunda string; retorne.
  Se a string for "pela", posponha "por a" para a segunda string; retorne.
  Se a string for "pelos", posponha "por os" para a segunda string; retorne.
  Se a string for "pelas", posponha "por as" para a segunda string; retorne.
  Posponha a string para a segunda string.

Etapas para que se acrescente endereço loading código para um texto hexadecimal usando uma variável:
  \ loads para edx
  Se a variável for inexistente, acrescente $C7C200000000 para o texto hexadecimal; retorne. \ mov edx,0
  Se a categoria desta variável for "global", acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; retorne. \ mov edx,the endereço da variável
  Se a categoria desta variável for "literal", acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; retorne. \ mov edx,the endereço da variável
  Se a categoria desta variável for "local", acrescente $8D95 e o deslocamento desta variável para o texto hexadecimal; retorne. \ lea edx,[ebp+ the deslocamento da variável]
  Se a categoria desta variável for "scratch", acrescente $8B95 e o deslocamento desta variável para o texto hexadecimal; retorne. \ mov edx, [ebp+ the deslocamento da variável]
  Se a categoria desta variável não for "parâmetro", apresente uma mensagem de erro contendo "Erro interno#9"; retorne.
  Se o detector de passagem por-valor desta variável estiver ativo, acrescente $8D95 e o deslocamento desta variável para o texto hexadecimal; retorne. \ lea edx,[ebp+the deslocamento da variável]
  Acrescente $8B95 e o deslocamento desta variável para o texto hexadecimal. \ mov edx,[ebp+ the deslocamento da variável]

Etapas para que se acrescente um texto hexadecimal e um endereço para um fragmento:
  \ Processe ou Salto
  Atribua o endereço para um número.
  Subtraia o endereço deste fragmento desde o número.
  Subtraia a quantidade de caracteres deste código deste fragmento desde o número.
  Subtraia a quantidade de caracteres deste texto hexadecimal desde o número.
  Subtraia 4 desde o número.
  Acrescente o texto hexadecimal e o número para o código deste fragmento.

Etapas para que se acrescente um texto hexadecimal e um número e um segundo texto hexadecimal para um terceiro texto hexadecimal:
  Posponha o texto hexadecimal para o terceiro texto hexadecimal.
  Converta o número para um quarto texto hexadecimal.
  Posponha o quarto texto hexadecimal para o terceiro texto hexadecimal.
  Posponha o segundo texto hexadecimal para o terceiro texto hexadecimal.

Etapas para que se acrescente um texto hexadecimal e um número e um segundo número para um segundo texto hexadecimal:
  Posponha o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Posponha o terceiro texto hexadecimal para o segundo texto hexadecimal.
  Converta o segundo número para um quarto texto hexadecimal.
  Posponha o quarto texto hexadecimal para o segundo texto hexadecimal.

Etapas para que se acrescente um texto hexadecimal e um detector para um segundo texto hexadecimal;
Etapas para que se acrescente um texto hexadecimal e um número para um segundo texto hexadecimal:
  Posponha o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Posponha o terceiro texto hexadecimal para o segundo texto hexadecimal.

Etapas para que se disponibilize bytes usando um ponteiro e uma quantidade de caracteres e um trecho e um deslocamento:
  Atribua o caractere inicial deste trecho mais o deslocamento para um segundo ponteiro.
  Copie bytes desde o ponteiro para o segundo ponteiro pelo quantidade de caracteres.

Etapas para que se disponibilize um cabeçalho DOS para um trecho:
  Disponibilize bytes usando o endereçamento deste cabeçalho DOS e o magnitude deste cabeçalho DOS e o trecho e 0.

Etapas para que se disponibilize umas funções para um trecho:
  Obtenha um função desde o funções.
  Se a função for inexistente, retorne.
  Disponibilize a função ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize um função para um trecho:
  Disponibilize bytes usando o endereçamento deste endereço do nome desta função e 4 e o trecho e o endereço thunk desta função.
  Atribua o endereço do nome desta função mais 2 para um endereço.
  Disponibilize o nome desta função ao trecho sob o endereço.

Etapas para que se disponibilize um fragmento para um trecho:
  Se o código deste fragmento estiver em branco, retorne.
  Atribua o endereço deste fragmento menos o image base para um endereço.
  Disponibilize o código deste fragmento ao trecho sob o endereço.

Etapas para que se disponibilize uns fragmentos para um trecho:
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Disponibilize o fragmento ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize uma DLL para um trecho:
  Disponibilize bytes usando o endereçamento deste import header desta DLL e o magnitude deste import header desta DLL e o trecho e o endereço do cabeçalho desta DLL.
  Disponibilize o nome desta DLL ao trecho sob o endereço do nome desta DLL.
  Disponibilize as funções desta DLL ao trecho.

Etapas para que se disponibilize umas DLLs para um trecho:
  Obtenha uma DLL desde as DLLs.
  Se a DLL for inexistente, retorne.
  Disponibilize a DLL ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize um cabeçalho PE para um trecho:
  Disponibilize bytes usando o endereçamento deste cabeçalho PE e o magnitude deste cabeçalho PE e o trecho e 256.

Etapas para que se disponibilize uma rotina para um trecho:
  Se o compiled detector desta rotina não estiver ativo, retorne.
  Disponibilize os fragmentos desta rotina ao trecho.

Etapas para que se disponibilize umas rotinas para um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Disponibilize a rotina ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize uma string para um trecho sob um endereço:
  Disponibilize bytes usando o caractere inicial desta string e a quantidade de caracteres desta string e o trecho e o endereço.

Etapas para que se disponibilize uma variável para um trecho:
  Se o compiled detector desta variável não estiver ativo, retorne.
  Se o tipo desta variável puder ser reduzido para "string", disponibilize a variável ao trecho (como um texto); retorne.
  Se o tipo desta variável puder ser reduzido para "cadeia de caracteres", disponibilize a variável ao trecho (como um texto); retorne.
  Se o tipo desta variável puder ser reduzido para "texto", disponibilize a variável ao trecho (como um texto); retorne.
  Atribua o endereço desta variável menos o image base para um endereço. \ Atribua a diferença entre o endreço da variável e a base da imagem em um endereço.
  Disponibilize o data desta variável ao trecho sob o endereço.

Etapas para que se disponibilize uma variável para um trecho (como um texto):
  Atribua o endereço desta variável menos o image base para um endereço.
  Atribua a quantidade de caracteres deste data desta variável para uma quantidade de caracteres.
  Atribua o endereço para um segundo endereço.
  Adicione a magnitude desse prototype string para o segundo endereço.
  Adicione o image base para o segundo endereço.
  Atribua 0 ao caractere inicial desta prototype string.
  Atribua -1 ao caractere final desta prototype string.
  Se a quantidade de caracteres não for 0, atribua o segundo endereço ao caractere inicial desta prototype string.
  Se a quantidade de caracteres não for 0, atribua o caractere inicial desta prototype string mais a quantidade de caracteres menos 1 ao caractere final desta prototype string.
  Disponibilize bytes usando o endereçamento desta prototype string e a magnitude desta prototype string e o trecho e o endereço.
  Adicione a magnitude [tamanho em bytes] desta prototype string para o endereço.
  Disponibilize os data desta variável ao trecho sob o endereço.

Etapas para que se disponibilize uns variáveis para um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Disponibilize a variável ao trecho.
  Recomece. [percorra novamente o código acima]

Um endereço base é um endereço.

Uma zona é um estrutura com 
  Um endereço base, 
  Uma quantidade de caracteres e 
  Um tamanho.

Etapas para que se bubble uma unidade semântica:
  Se a unidade semântica for inexistente, retorne.
  Se o subtexto atual desta unidade semântica não estiver em branco, limpe o subtexto atual desta unidade semântica; retorne.
  Se o tipo atual desta unidade semântica for inexistente, retorne.
  Se o tipo atual desta unidade semântica for algum tipo pré-definido, atribua nil ao tipo atual desta unidade semântica; retorne.
  Atribua o tipo base deste tipo atual desta unidade semântica ao tipo atual desta unidade semântica.

Um built-in tipo é um tipo.

Etapas para que se calculate a quantidade de caracteres of um tipo:
  Se o tipo for inexistente, retorne.
  Se a quantidade de caracteres deste tipo não for -1, retorne.
  Calculate a quantidade de caracteres of o tipo base deste tipo.
  Se os campos deste tipo estiverem vazios, atribua a quantidade de caracteres deste tipo base deste tipo à quantidade de caracteres deste tipo; retorne.
  Atribua 0 à quantidade de caracteres deste tipo.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde o campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o nome de redefinição de conteúdo deste campo não estiver em branco, recomece.
    Calculate a quantidade de caracteres of o tipo deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo times a contagem deste campo para a quantidade de caracteres deste tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate os comprimentos of uns tipos:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calculate a quantidade de caracteres of o tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate os deslocamentos em um tipo:
  Se o tipo for inexistente, retorne.
  Atribua 0 para um deslocamento.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o nome de redefinição de conteúdo deste campo não estiver em branco, recomece.
    Atribua o deslocamento ao deslocamento deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo times a contagem deste campo para o deslocamento.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate os deslocamentos em uns tipos:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calculate os deslocamentos no tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate o redefinition deslocamentos em um tipo:
  Se o tipo for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o nome de redefinição de conteúdo deste campo estiver em branco, recomece.
    Encontre um segundo campo usando o nome de redefinição de conteúdo deste campo e os campos deste tipo.
    Se o segundo campo for inexistente, apresente uma mensagem de erro contendo "Erro. Comando de redefinição inválido. O campo '" junto com o nome de redefinição de conteúdo deste campo seguido de "' não pode ser encontrado." e o endereço local deste campo; retorne.
    Atribua o deslocamento deste segundo campo ao deslocamento deste campo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate o redefinition deslocamentos em uns tipos:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calculate o redefinition deslocamentos no tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se verifique por informações opcionais inválidas em um tipo:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo for inexistente, retorne.
  Se o conteúdo nome deste tipo não estiver em branco, verifique por informações opcionais inválidas em o tipo (conteúdo).
  Se o campos deste tipo não estiverem vazios, verifique por informações opcionais inválidas em o tipo (campos).
  Se a razão de escala deste tipo não for 0, verifique por informações opcionais inválidas em o tipo (scale).

Etapas para que se verifique por informações opcionais inválidas em um tipo (campos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo não puder ser reduzido para "estrutura", apresente uma mensagem de erro contendo "Erro. A palavra-chave 'com' só é permitida em estruturas." e o endereço local deste tipo; retorne. \\mudar aqui

Etapas para que se verifique por informações opcionais inválidas em um tipo (scale):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo não puder ser reduzido para "número", apresente uma mensagem de erro contendo "Erro. Proporções e escalas de medida só podem ser utilizadas em tipos de dados numéricos." e o endereço local deste tipo; retorne.

Etapas para que se verifique por informações opcionais inválidas em um tipo (conteúdo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", apresente uma mensagem de erro contendo "Erro. A palavra-chave 'para' só pode ser utilizada ao apontar para variáveis do tipo ponteiro." e o endereço local deste tipo; retorne.

Etapas para que se limpe um campo termo:
  Preencha bytes com o caractere null começando sob o endereçamento deste campo termo pelo magnitude deste campo termo.

Etapas para que se limpe um termo:
  Esvazie a variável deste termo.
  Limpe o phrase deste termo.

Etapas para que se compile os corpos of as rotinas:
  Compile o corpo of a rotina denominada "Initialize before run".
  Compile o corpo of a rotina denominada "Execute o programa".
  Compile o corpo of a rotina denominada "Finalize after run".

Etapas para que se compile o corpo of uma rotina:
  Se a rotina for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o compiled detector desta rotina estiver ativo, retorne.
  Ative o compiled detector desta rotina.
  Lance um percorredor sobre as instruções desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for o ponto&vírgula, compile o corpo of a rotina usando o percorredor (sobrecarga de métodos); retorne. \ *** alternate wording
  Se o segmento inicial deste percorredor for uma keyword de reutilização de rotina, compile o corpo of a rotina usando o percorredor (cláusula de reutilização); retorne.
  Atribua a rotina utilizada atualmente para um saved rotina.
  Atribua a rotina à rotina utilizada atualmente.
  Crie o apelido catálogo desta rotina usando 101.
  Elimine apelidos duplicados desde os parâmetros desta rotina usando o apelido catálogo desta rotina.
  Compile o corpo of a rotina (etapa preliminar).
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Compile a próxima instrução usando o percorredor.
  Recomece. [percorra novamente o código acima]
  Compile o corpo of a rotina (etapa conclusiva).
  Atribua o saved rotina à rotina utilizada atualmente.

Etapas para que se compile o corpo of uma rotina (etapa conclusiva):
  Se a rotina for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um fragmento usando a etiqueta de finalização.
  Comece. [a executar o código abaixo]
    Obtenha uma variável desde as variáveis locais desta rotina.
    Se a variável for inexistente, pare.
    Se a categoria desta variável for "scratch", recomece.
    Se o tipo desta variável não deveria ser finalizado, recomece.
    Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
    Encontre uma segunda rotina usando "~finalize" e o tipo desta variável.
    Se a segunda rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno #10'"; retorne.
    Adicione um terceiro fragmento usando a etiqueta de demanda interna e a segunda rotina.
  Recomece. [percorra novamente o código acima]
  Adicione um quarto fragmento usando o etiqueta conclusiva.

Etapas para que se compile o corpo of uma rotina (etapa preliminar):
  Se a rotina for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um fragmento usando o etiqueta preliminar.
  Adicione um segundo fragmento usando o etiqueta de laço.

Etapas para que se compile o corpo of a rotina denominada uma string;
Etapas para que se compile o corpo of a rotina denominado uma string:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Encontre uma rotina usando a string e o catálogo geral de rotinas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro. A rotina 'para que se " junto com a string seguido de "' não pode ser encontrada."; retorne.
  Compile o corpo of a rotina.

Etapas para que se compile o corpo of uma rotina usando um percorredor (sobrecarga de métodos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ *** do we need this?
  Atribua a subsequente rotina desta rotina para um conteúdo rotina.
  Se o conteúdo rotina for inexistente, apresente uma mensagem de erro contendo "Erro. Não foi possível encontrar o cabeçalho alternativo desta rotina." e o percorredor; retorne.
  Atribua a representação interna da rotina deste conteúdo rotina ao employs representação interna da rotina desta rotina.
  Compile o corpo of o conteúdo rotina.

Etapas para que se compile o corpo of uma rotina usando um percorredor (cláusula de reutilização):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma referência da rotina usando o percorredor.
  Converta a referência da rotina para o employs representação interna da rotina desta rotina.
  Destrua a referência da rotina.
  Se o segmento inicial deste percorredor não for ".", apresente uma mensagem de erro contendo "Erro. O comando 'Empregue' deve terminar com um ponto, não com: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Erro. Permitido apenas uma cláusula de reutilização por rotina" e o percorredor; retorne.
  Encontre uma segunda rotina usando o employs representação interna da rotina desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente, apresente a mensagem de erro contendo "Erro. A rotina para que se '" junto com o employs representação interna da rotina desta rotina seguido de "' não foi encontrada." e o endereço local desta rotina; retorne.
  Compile o corpo of a segunda rotina.

Etapas para que se compile a parte designadora usando um percorredor e uma variável:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável for inexistente, retorne.
  Atribua o nome desta variável ao nome do tipo desta variável.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável usando o percorredor.

Etapas para que se compile um endereço da pasta:
  Compile o endereço da pasta (inicialização).
  Compile o endereço da pasta (arquivos de código fonte).
  Compile o endereço da pasta (análise dos arquivos fornecidos).
  Compile o endereço da pasta (identificação dos tipos das variáveis).
  Compile o endereço da pasta (identificação de variáveis globais).
  Compile o endereço da pasta (cabeçalhos de rotinas).
  Compile o endereço da pasta (cálculo de tamanhos e deslocamentos).
  Compile o endereço da pasta (Adicione o built-in memory rotinas).
  Compile o endereço da pasta (catalogue as rotinas por utility use).
  Compile o endereço da pasta (conteúdo das rotinas).
  Compile o endereço da pasta (Adicione e compile o built-in startup rotina).
  Compile o endereço da pasta (deslocamento de parâmetros e variáveis).
  Compile o endereço da pasta (address).
  Compile o endereço da pasta (transmutação).
  Compile o endereço da pasta (link).
  Compile o endereço da pasta (etapa final).
  Compile o endereço da pasta (interrupção).

Etapas para que se compile um endereço da pasta (Adicione e compile o built-in startup rotina):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Adicionando e agrupando as tarefas padrão de inicialização..".
  Start o temporizador de adição de rotinas pré-definidas de inicialização.
  Adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução.
  Suspenda o temporizador de adição de rotinas pré-definidas de inicialização.

Etapas para que se compile um endereço da pasta (Adicione o built-in memory rotinas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Adicionando tarefas predefinidas na memória...".
  Start o temporizador de adição de rotinas pré-definidas de mémoria .
  Adicione as rotinas de alocação e desalocação e finalização e destruição.
  Suspenda o temporizador de adição de rotinas pré-definidas de mémoria .

A região de código é um zona.

Etapas para que se compile um endereço da pasta (address):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Obtendo endereço dos itens...".
  Start o temporizador de endereçamento.
  Atribua 4096 para um endereço.
  Atribua o endereço à endereço base desta seção de DLLs.
  Enderece as DLLs usando o endereço.
  Atribua o endereço menos a endereço base desta seção de DLLs à quantidade de caracteres desta seção de DLLs.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta região de dados.
  Enderece os globals usando o endereço.
  Enderece os literals usando o endereço.
  Atribua o endereço menos a endereço base desta região de dados à quantidade de caracteres desta região de dados.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta região de código. \ Uma zona é uma estrutura que contém um endereço base, uma quantidade de caracteres e um tamanho.
  Enderece as rotinas usando o endereço.
  Atribua o endereço menos a endereço base desta região de código à quantidade de caracteres desta região de código.
  Suspenda o temporizador de endereçamento.

Etapas para que se compile um endereço da pasta (cálculo de tamanhos e deslocamentos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Calculando tamanhos e deslocamentos...".
  Start o temporizador de etapas de cálculo.
  Calculate os comprimentos of o tipos.
  Calculate os deslocamentos no tipos.
  Calculate o redefinition deslocamentos no tipos.
  Suspenda o temporizador de etapas de cálculo.

Etapas para que se compile um endereço da pasta (conteúdo das rotinas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Agrupando o conteúdo das tarefas...".
  Start o temporizador de compilação do conteúdo das rotinas.
  Compile os corpos of as rotinas.
  Suspenda o temporizador de compilação do conteúdo das rotinas.

Etapas para que se compile um endereço da pasta (cabeçalhos de rotinas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Agrupando os nomes das tarefas...".
  Start o temporizador de compilação de cabeçalhos de rotina.
  Compile os cabelalhos of as rotinas.
  Suspenda o temporizador de compilação de cabeçalhos de rotina.

Etapas para que se compile um endereço da pasta (catalogue as rotinas por utility use):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Catalogando tarefas...".
  Start o temporizador de ferramentas de catalogação.
  Catalogue as rotinas por utility use.
  Scrub o catálogo de rotinas úteis.
  Organize o catálogo de rotinas úteis.
  Suspenda o temporizador de ferramentas de catalogação.

Etapas para que se compile um endereço da pasta (link):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Elencando arquivos..".
  Start o temporizador de vinculação.
  Link.
  Suspenda o temporizador de vinculação.

Etapas para que se compile um endereço da pasta (deslocamento de parâmetros e variáveis):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Deslocando parâmetros e variáveis...".
  Start o temporizador de deslocamentos.
  Alinhe o parâmetros na rotinas.
  Alinhe as variáveis locais na rotinas.
  Suspenda o temporizador de deslocamentos.

Etapas para que se compile um endereço da pasta (arquivos de código fonte):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Carregando arquivos...".
  Start o temporizador de operacionalização.
  Carregue os arquivos fontes.
  Suspenda o temporizador de operacionalização.

Etapas para que se compile um endereço da pasta (identificação de variáveis globais):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Resolvendo itens de escopo global...".
  Start o temporizador de resolução de variáveis globais.
  Resolva o globals.
  Suspenda o temporizador de resolução de variáveis globais.

Etapas para que se compile um endereço da pasta (identificação dos tipos das variáveis):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Resolvendo tipos...".
  Start o temporizador de resolução de tipos.
  Resolva os tipos (expand listas).
  Resolva os tipos (registro de plurais).
  Resolva os tipos (tipos de dados primitivos).
  Resolva os tipos (dados complementares).
  Suspenda o temporizador de resolução de tipos.

Etapas para que se compile um endereço da pasta (análise dos arquivos fornecidos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Analisando arquivos...".
  Start o temporizador de análise/verificação.
  Examine os arquivos fontes.
  Suspenda o temporizador de análise/verificação.

Etapas para que se compile um endereço da pasta (inicialização):
  Mostre no painel de informações "Iniciando...".
  Finalize o compilador.
  Start o temporizador deste compilador.
  Inicialize o compilador usando o endereço da pasta.
  Adicione o built-in tipos.

Etapas para que se compile um endereço da pasta (interrupção):
  Suspenda o temporizador deste compilador.
  Mostre no painel de informações "Interrompendo".

Etapas para que se compile um endereço da pasta (transmutação):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Modificando...".
  Start o temporizador de transmutação.
  Transforme em código hexadecimal as rotinas.
  Suspenda o temporizador de transmutação.

Etapas para que se compile um endereço da pasta (etapa final):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Gerando arquivo executável...".
  Start o temporizador de escrita.
  Escreva o trecho EXE deste compilador para o endereço EXE completo deste compilador.
  Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo o erro do fluxo de entrada/saída.
  Suspenda o temporizador de escrita.

Etapas para que se compile um expression usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Compile um termo usando o percorredor.
  Atribua o termo ao expression.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor não for algum operator aritmético, retorne.
    Se o segmento inicial deste percorredor for algum operator de divisão, compile o expression usando o percorredor (operador de divisão); recomece.
    Se o segmento inicial deste percorredor for algum operator de subtração, compile o expression usando o percorredor (operador de subtração); recomece.
    Se o segmento inicial deste percorredor for algum operator de adição, compile o expression usando o percorredor (operador de adição); recomece.
    Se o segmento inicial deste percorredor for algum operador de concatenação, compile o expression usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for algum operator de multiplicação, compile o expression usando o percorredor (operador de multiplicação); recomece.
    Se o segmento inicial deste percorredor for "junto", compile o expression usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "juntamente", compile o expression usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "seguido", compile o expression usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "acompanhado", compile o expression usando o percorredor (operador de concatenação); recomece.

Etapas para que se compile um expression usando um percorredor (operador de divisão):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum objeto indireto, apresente uma mensagem de erro contendo "Erro. Você deve usar o termo 'dividido POR'." e o percorredor; retorne.
  Se a variável desta expression for inexistente, apresente a mensagem de erro contendo "Erro. Comando 'dividido por' inválido. Erro na variável  '" junto com a phrase desta expression seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Erro. O comando 'dividido por', está errado. Não é possível dividir por '" junto com a phrase deste termo seguido de "'." e o percorredor; retorne.
  Adicione um intermediate usando o nome do tipo desta expression e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "atribua" e a variável desta expression e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "divida" e o intermediate e "por" e a variável deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile um expression usando um percorredor (operador de subtração):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Erro. O comando 'menos', está incorreto. Não é possível subtrair de '" junto com a phrase desta expression seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Erro. O comando 'menos', está incorreto. Não consigo diminuir de '" junto com a phrase deste termo seguido de "'." e o percorredor; retorne.
  Adicione um intermediate usando o nome do tipo desta expression e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "atribua" e a variável desta expression e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "subtraia" e a variável deste termo e "desde" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile um expression usando um percorredor (operador de adição):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Erro. O comando 'mais' está incorreto. Não é possível somar o '" junto com a phrase desta expression seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação). \talvez fosse o caso de repetir aqui
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Erro. O comando 'mais' está incorreto. Não é possível adicionar o" junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando o nome do tipo desta expression e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "atribua" e a variável desta expression e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.\aqui muda o atribua
  Adicione several fragmentos usando "adicione" e a variável deste termo e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor. \ aqui muda o add
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile um expression usando um percorredor (operador de concatenação):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for "do",  recue/atribua/posponha "de o" ao 
  Se o segmento inicial deste percorredor não for algum palavra de concatenação, apresente uma mensagem de erro contendo "Erro. Necessário escrever 'junto DE/junto COM/etc'." e o percorredor; retorne.
  Se a variável desta expression for inexistente, apresente a mensagem de erro contendo "Erro. Eu não entendi a variável da expressão: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor. \\ aqui que deve compilar o termo
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Erro. Eu não achei a variável do termo: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione um intermediate usando "texto" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragmentos usando a variável desta expression e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Converta o termo por concatenação usando o percorredor. \\ aqui faz a concatenação
  Adicione several fragmentos usando "posponha" e a variável deste termo e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile um expression usando um percorredor (operador de multiplicação):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Erro. Comando 'vezes' incorreto. Não é póssível multiplicar por '" junto com a phrase desta expression seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Erro. Comando 'multiplicado por' incorreto. Não é póssível multiplicar por '" junto com a phrase deste termo seguido de "'." e o percorredor; retorne.
  Adicione um intermediate usando o nome do tipo desta expression e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "atribua" e a variável desta expression e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "multiplique" e o intermediate e "por" e a variável deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile o cabeçalho of uma rotina:
  Se a rotina for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Lance um percorredor sobre a cabeçalho de rotina desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum comando de deliberação, compile o cabeçalho of a rotina usando o percorredor (rotina deliberativa); retorne.
  Se o percorredor for o início of algum função possessiva reversa, compile o cabeçalho of a rotina usando o percorredor (função do possessivo reverso); retorne.
  Se o percorredor for o início of algum função, compile o cabeçalho of a rotina usando o percorredor (função); retorne.
  Se o segmento inicial deste percorredor for "compativelmente", compile o cabeçalho of a rotina usando o percorredor (modo de compatibilidade); retorne.
  Compile o cabeçalho of a rotina usando o percorredor (procedimento).

Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (modo de compatibilidade):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o detector de compatibilidade desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Erro. A rotina para que se '" junto com a representação interna da rotina desta rotina seguido de "' já foi definida anteriormente." e o endereço local desta rotina; retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (rotina deliberativa):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional, apresente uma mensagem de erro contendo "Erro. Rotina 'Para que se determine se' com sintaxe inválida" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o detector de deliberação desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Se alguns of as unidades semânticas desta rotina forem advérbios de negação, apresente a mensagem de erro contendo "Erro. A palavra-chave 'não' não é permitida em cabeçalhos de funções booleanas." e o percorredor; retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Erro. A rotina para que se ''" junto com a representação interna da rotina desta rotina seguido de "' já havia sido definida anteriormente." e o endereço local desta rotina; retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (função):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Ative o detector de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessive, apresente uma mensagem de erro contendo "Erro. Necessário inserir um 's no código." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "Erro. Keyword 'para' ausente. Encontrado a palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Adicione um terceiro unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Erro. Rotina para que se '" junto com a representação interna da rotina seguido de "' já definida." e o endereço local desta rotina; retorne. \ not translated - no possessives em Spanish
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente a mensagem de erro contendo "Erro. Necessário artigo indefinido. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Erro. Encontrado comandos extras no fim da função." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ por employs

Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (procedimento):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Erro. Rotina para que se '" junto com a representação interna da rotina desta rotina seguido de "' já codificada." e o endereço local desta rotinas; retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile os cabelalhos of umas rotinas:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Compile o cabeçalho of a rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se compile um literal usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione o literal para os literals usando o caractere inicial deste segmento inicial deste percorredor .
  \Se o segmento inicial deste percorredor for algum detector literal, compile o literal usando o percorredor (detector); retorne.
  Se o segmento inicial deste percorredor for algum hex literal, compile o literal usando o percorredor (hex); retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal, compile o literal usando o percorredor (numeric); retorne.
  Se o segmento inicial deste percorredor for algum ponteiro literal, compile o literal usando o percorredor (ponteiro); retorne.
  Se o segmento inicial deste percorredor for algum string literal, compile o literal usando o percorredor (cadeia de caracteres); retorne.
  Apresente uma mensagem de erro contendo "Erro interno #11 - Consulte a rotina para que se compile um termo usando um percorredor (literal)" e o percorredor.

Etapas para que se compile um literal usando um percorredor (detector):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para um detector.
  Converta o detector para os data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "detector" ao nome do tipo deste literal.
  Resolva o literal. \ Que tal utilizar os termos "decifre", "traduza", "destrinche", "decodifique"?

Etapas para que se compile um literal usando um percorredor (hex):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta o parte da cifra binária para o data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "texto hexadecimal" ao nome do tipo deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (valor numérico - integer):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para um número.
  Converta o número para os data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "número" ao nome do tipo deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (valor numérico - proporção):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Converta a proporção para o data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "proporção" ao nome do tipo deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (valor numérico - com unidade de medida):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente, apresente uma mensagem de erro contendo "Erro. O(A) '" junto com o nome seguido de "' é uma unidade de medida inexistente." e o endereço local deste literal; retorne.
  Se o tipo não puder ser reduzido para "número", apresente a mensagem de erro contendo "Erro. O(A) '" junto com o nome seguido de "' é uma unidade de medida inválida." e o endereço local deste literal; retorne.
  Atribua a razão de escala deste tipo para um final proporção.
  Se a razão de escala deste tipo for 0, atribua 1/1 ao final proporção.
  Multiplique o final proporção pelo proporção.
  Reduza o final proporção.
  Se o denominador deste final proporção for 0, apresente a mensagem de erro contendo "Erro. Denominador igual a zero. Unidade de medida inválida." e o endereço local deste literal.
  Atribua o numerador deste final proporção dividido pelo denominador deste final proporção para um número.
  Atribua o nome deste tipo ao nome do tipo deste literal.
  Converta o número para o data deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (numeric):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o percorredor estiver acompanhado por algum unidade de medida, compile o literal usando o percorredor (valor numérico - com unidade de medida); retorne.
  Se o segmento inicial deste percorredor for algum integer literal, compile o literal usando o percorredor (valor numérico - integer); retorne.
  Se o segmento inicial deste percorredor for algum proporção literal, compile o literal usando o percorredor (valor numérico - proporção); retorne.
  Se o segmento inicial deste percorredor for algum numeral misto literal, compile o literal usando o percorredor (valor numérico - proporção); retorne.

Etapas para que se compile um literal usando um percorredor (ponteiro):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta 0 para os data deste literal. \ was nil
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "ponteiro" ao nome do tipo deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (cadeia de caracteres):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o segmento inicial deste percorredor aos data deste literal.
  Remove aspas de os data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "string" ao nome do tipo deste literal.
  \Atribua "texto" ao nome do tipo deste literal.
  Resolva o literal.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum artigo definido, compile as unidades semânticas e o parâmetros usando o percorredor (artigo definido); recomece.
  Se o percorredor estiver sobre algum artigo indefinido, compile as unidades semânticas e o parâmetros usando o percorredor (artigo indefinido); recomece.
  Se o percorredor estiver sobre algum unidade semântica string, compile as unidades semânticas e o parâmetros usando o percorredor (unidade semântica string); recomece.
  Apresente uma mensagem de erro contendo "Erro. Rotina para que se '" junto com o segmento inicial deste percorredor seguido de "' não localizada." e o percorredor.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo definido):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para as unidades semânticas usando o nome.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo indefinido):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um parâmetro para o parâmetros usando "parâmetro" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outras", atribua "outras" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outros", atribua "outros" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segundos", atribua "segundos" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segunda", atribua "segundas" ao nome deste parâmetro.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Extend o nome destes parâmetro com o nome.
  Se o segmento inicial deste percorredor for uma keyword de designação, compile a parte designadora usando o percorredor e o parâmetro.
  Resolva o parâmetro.
  Se o parâmetro estiver duplicada no parâmetros, apresente uma mensagem de erro contendo "Erro. O parâmetro '" junto com o nome deste parâmetro seguido de "' já foi declarado anteriormente." e o endereço local deste parâmetro; retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o tipo deste parâmetro.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (unidade semântica string):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile umas unidades semânticas usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o percorredor estiver sobre algum unidade semântica string, adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação); recomece.
  Se o segmento inicial deste percorredor não for o início of algum expressão, retorne.
  Compile um expression usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o expression.
  Recomece. [percorra novamente o código acima]

\Etapas para que se compile umas unidades semânticas usando um percorredor:
\Se o detector de erros deste compilador estiver ativado, retorne.
\Se o segmento inicial deste percorredor for algum unidade semântica string, adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação); recomece.
\Se o segmento inicial deste percorredor não for o início of algum expressão, retorne.
\Compile um expression usando o percorredor.
\Se o detector de erros deste compilador estiver ativado, retorne.
\Adicione uma segunda unidade semântica para as unidades semânticas usando o expression.
\Recomece. [percorra novamente o código acima]

Etapas para que se compile a próxima instrução usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor for algum comando condicional, compile a próxima instrução usando o percorredor (cláusula de condicional); retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento, compile a próxima instrução usando o percorredor (cláusula de inicio de laço); retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção, compile a próxima instrução usando o percorredor (cláusula de isolamento); retorne.
  Se o segmento inicial deste percorredor não for o início of algum declaração, apresente uma mensagem de erro contendo "Eu esperava uma declaração aqui, mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Compile a próxima instrução usando o percorredor (demais cláusulas).
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Este comando está incorreto ou é uma keyword reservada." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de interrupção):
  Adicione um fragmento usando o etiqueta de interrupção.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (Keyword 'processe' - chamada externa):
  Atribua o segmento inicial deste percorredor para uma string.
  Remove aspas de a string.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum string literal, apresente uma mensagem de erro contendo "Erro. O compiplador exige que o nome da biblioteca esteja entre aspas. Encontrado: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Atribua o segmento inicial deste percorredor para uma segunda string.
  Remove aspas de a segunda string.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione um função para as DLLs usando a string e a segunda string.
  Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (Keyword 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "contendo", compile a próxima instrução usando o percorredor (Keyword 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "usando", compile a próxima instrução usando o percorredor (Keyword 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "devolvendo", compile a próxima instrução usando o percorredor devolvendo um termo (Keyword 'processe' - cláusula devolvendo).
  \Se o segmento inicial deste percorredor for uma keyword de devolução, compile a próxima instrução usando o percorredor devolvendo um termo (Keyword 'processe' - cláusula devolvendo).
  Adicione um fragmento usando a etiqueta de demanda externa e o função.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Erro. A variável do termo '" junto com a phrase deste termo seguido de "' não pode ser localizada." e o percorredor; retorne.
  Adicione um segundo fragmento usando o etiqueta de obtenção do registrador EAX e a variável deste termo.

Etapas para que se compile a próxima instrução usando um percorredor (Keyword 'processe' - chamada indireta):
  Compile um expression usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Erro. A variável da expressão'" junto com a phrase desta expression seguido de "' não pode ser localizada." e o percorredor; retorne.
  Se o tipo desta expression não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "Erro. Neste comando 'Processe' é necessário usar uma expressão do tipo ponteiro." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (Keyword 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "contendo", compile a próxima instrução usando o percorredor (Keyword 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "devolvendo", compile a próxima instrução usando o percorredor devolvendo um termo (Keyword 'processe' - cláusula devolvendo).
  Adicione um fragmento usando a etiqueta de demanda indireta e a variável desta expression.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Erro. A variável do termo '" junto com a phrase deste termo seguido de "' é inexistente." e o percorredor; retorne.
  Adicione um segundo fragmento usando o etiqueta de obtenção do registrador EAX e a variável deste termo.

Etapas para que se compile a próxima instrução usando um percorredor (Keyword 'processe' - chamada interna):
  Compile umas unidades semânticas usando o percorredor.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente, adicione push fragmentos usando as unidades semânticas.
  Se a rotina não for inexistente, destrua as unidades semânticas; adicione um fragmento usando a etiqueta de demanda interna e a rotina; retorne.
  [Caso a rotina seja inexistente, então:]
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.  
  Atribua a representação interna da rotina ao texto retornado. 
  Apresente uma mensagem de erro contendo "Erro. A rotina para que se " junto com a representação interna da rotina seguido de " não foi localizada." e o percorredor.

Etapas para que se compile a próxima instrução usando um percorredor (Keyword 'processe' - cláusula com):
  \ this routine is recursise so parameters get passed right to  left
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um expression usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Erro. A variável da expression '" junto com a phrase desta expression seguido de "' é inexistente." e o percorredor; retorne.
  Se o tipo desta expression não for valor empilhável, apresente a mensagem de erro contendo "Erro. O tipo '" junto com o nome deste tipo desta expression seguido de "' da expressão é um valor empilhável." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum and, compile a próxima instrução usando o percorredor (Keyword 'processe' - cláusula com).
  Adicione um fragmento usando o etiqueta de inserção de valor [na stack] e a variável desta expression.

Etapas para que se compile a próxima instrução usando um percorredor (Processe):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum string literal, compile a próxima instrução usando o percorredor (Keyword 'processe' - chamada externa); retorne.
  Compile a próxima instrução usando o percorredor (Keyword 'processe' - chamada indireta).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de retorno):
  Se o detector de deliberação desta rotina utilizada atualmente estiver ativo, apresente uma mensagem de erro contendo "Erro. Funções booleanas devem retornar um 'sim' ou 'não'" e o percorredor; retorne.  
  Adicione um fragmento usando o etiqueta de retorno.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de condicional):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile umas unidades semânticas usando o percorredor.
  Remove algum negatives desde as unidades semânticas devolvendo um detector.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente, adicione push fragmentos usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro. A rotina para que se '" junto com a representação interna da rotina seguido de "' não existe." e o percorredor; retorne.
  Se o detector de deliberação desta rotina não estiver ativo, apresente a mensagem de erro contendo "Erro. Necessário utilizar um decisor." e o percorredor; retorne.
  \ Se o segmento inicial deste percorredor não for a vírgula, apresente a mensagem de erro contendo "Acho que você esqueceu de uma vírgula, eu achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Se o segmento inicial deste percorredor não for qualquer separador de comandos, apresente a mensagem de erro contendo "Erro. Necessário incluir uma vírgula ao invés de: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um fragmento usando a etiqueta de demanda interna e a rotina.
  Se o detector estiver ativo, adicione um segundo fragmento usando a etiqueta de negação lógica.
  Adicione um terceiro fragmento usando o etiqueta de desvio falso.
  Mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Compile a próxima instrução usando o percorredor (demais cláusulas).
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, mova o percorredor (usando diretrizes de compilação); recomece.
    \Se o segmento inicial deste percorredor for "Senão", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for "Caso", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for a vírgula, mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Erro. Necessário incluir um '.' ao invés de: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione um quarto fragmento usando o etiqueta delimitadora de bloco condicional.

Etapas para que se determine se um subtexto é qualquer separador de comandos:
  Se o subtexto for a vírgula, diga sim.
  Se o subtexto for "então", diga sim.
  [Caso contrário] Diga não.

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de decodificação):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum hex literal, apresente uma mensagem de erro contendo "Erro. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'. Esperado instrução hexadecimal" e o percorredor; retorne.
  Adicione um fragmento usando o etiqueta de decodificação.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta o parte da cifra binária para o código deste fragmento.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de inicio de laço):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um fragmento usando o etiqueta de laço.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Erro. Necessário incluir um '.' após comandos em blocos de repetição." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (demais cláusulas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum comando de retorno de rotina, compile a próxima instrução usando o percorredor (cláusula de retorno); retorne.
  Se o segmento inicial deste percorredor for algum comando de repetição, compile a próxima instrução usando o percorredor(cláusula de repetição); retorne.
  Se o segmento inicial deste percorredor for algum comando de interrupção de repetições, compile a próxima instrução usando o percorredor (cláusula de interrupção); retorne.
  Se o segmento inicial deste percorredor for algum comando de confirmação ou negação, compile a próxima instrução usando o percorredor (keyword diga); retorne.
  Se o segmento inicial deste percorredor for "Decodifique", compile a próxima instrução usando o percorredor (cláusula de decodificação); retorne.
  Se o segmento inicial deste percorredor for "Push", compile a próxima instrução usando o percorredor (cláusula de empilhamento); retorne.
  Se o segmento inicial deste percorredor for algum chamada de biblioteca externa, compile a próxima instrução usando o percorredor (Processe); retorne.
  Se o segmento inicial deste percorredor for algum point, compile a próxima instrução usando o percorredor (point); retorne.
  Se o segmento inicial deste percorredor for algum comando condicional, apresente uma mensagem de erro contendo "Erro. O aninhamento de condicionais não é permitido." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção, apresente a mensagem de erro contendo "Erro. A keyword 'Isole' não pode ser usada nesse tipo de comando." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento, apresente a mensagem de erro contendo "Erro. Loops não são permitidos em condicionais." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for uma keyword de reutilização de rotina, apresente a mensagem de erro contendo "Erro. O comando 'Empregue' deve ser o único comando de uma rotina." e o percorredor; retorne.
  \Se o segmento inicial deste percorredor for "senão", mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o segmento inicial deste percorredor for "caso", mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes de compilação); retorne.
  Compile a próxima instrução usando o percorredor (Keyword 'processe' - chamada interna).

Etapas para que se compile a próxima instrução usando um percorredor (point):
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. A variável '" junto com a phrase deste termo seguido de "' deste termo não pode ser encontrada." e o percorredor; retorne.
  Se a categoria deste termo for "literal", apresente a mensagem de erro contendo "Erro. Identificado valor literal na categoria deste termo." e o percorredor.
  Se a quantidade de caracteres deste tipo deste termo não for 4, apresente a mensagem de erro contendo "Erro. Variável de comprimento diferente de 4 ." e o percorredor.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "Erro. A keyword 'para é necessária após o comando 'aponte'. Termo encontrado: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "rotina", apresente a mensagem de erro contendo "Erro. A sintaxe  do comando é 'Aponte para rotina'. Encontrado termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma referência da rotina usando o percorredor.
  Converta a referência da rotina para uma representação interna da rotina.
  Destrua a referência da rotina.
  Encontre uma rotina usando a representação interna da rotina e o catálogo geral de rotinas.
  Se a rotina for inexistente, apresente a mensagem de erro contendo "Erro. A rotina para que se " junto com a representação interna da rotina seguido de " é inexistente." e o percorredor; retorne.
  Adicione um fragmento usando a etiqueta de endereço de rotina e a rotina.
  Atribua a variável deste termo à variável deste fragmento.

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de isolamento):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. Comando 'isole', Inválido. Termo da variável: " junto com a phrase deste termo seguido de "' está vazio." e o percorredor; retorne.
  Se a categoria deste termo não for "parâmetro", apresente a mensagem de erro contendo "Erro. Apenas arâmetros podem ser isolados." e o percorredor; retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o nome deste termo ao nome desta variável local.
  Atribua o apelido deste termo ao apelido desta variável local.
  Atribua o nome do tipo deste termo ao nome do tipo desta variável local.
  Resolva a variável local.
  Anteponha "original " para o nome deste termo. \ Deveria ser "posponha"
  Se o apelido deste termo não estiver em branco, Anteponha "original " para o apelido deste termo.
  Adicione several fragmentos usando "atribua" e a variável deste termo e "para" e a variável local e o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Erro. Necessário incluir um '.' ao dim do comando" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de empilhamento):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um expression usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Erro. Comando de empilhamento inválido devido a expressão: " junto com a phrase desta expression seguido de "' ser inexistente." e o percorredor; retorne.
  Se o tipo desta expression não for valor empilhável, apresente a mensagem de erro contendo "Erro. Valores do tipo: " junto com o nome deste tipo desta expression seguido de "' não podem ser empilhados." e o percorredor; retorne.
  Adicione um fragmento usando o etiqueta de inserção de valor [na stack] e a variável desta expression.

Etapas para que se compile a próxima instrução usando um percorredor(cláusula de repetição):
  Adicione um fragmento usando a etiqueta de repetição.
  Mova o percorredor (usando diretrizes de compilação).

\Etapas para que se compile a próxima instrução usando um percorredor (keyword diga):
\Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (Keyword 'processe' - chamada interna); retorne.
\Mova o percorredor (usando diretrizes de compilação).
\Compile um expression usando o percorredor.
\Se o detector de erros deste compilador estiver ativado, retorne.
\Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "No es válido este 'diga', no entiendo la variável: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
\Se o tipo desta expression não puder ser reduzido para "detector", apresente uma mensagem de erro contendo "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; retorne.
\Adicione um fragmento usando o etiqueta de carregamento de registrador EAX e a variável desta expression.
\Adicione um segundo fragmento usando o etiqueta de retorno.

Etapas para que se compile a próxima instrução usando um percorredor (keyword diga):
  Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (Keyword 'processe' - chamada interna); retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando de deliberação literal, apresente uma mensagem de erro contendo "Erro. Funções booleanas devem terminar com um 'sim' ou 'não'." e o percorredor; retorne.
  Desative um detector. Se o segmento inicial deste percorredor for algum positive decider literal, ative o detector.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Erro. O compilador esperava encontrar um '.' Encontrado o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um fragmento usando o etiqueta de carregamento de registrador EAX e o detector.
  Adicione um segundo fragmento usando o etiqueta de retorno.

Etapas para que se compile a próxima instrução usando um percorredor devolvendo um termo (Keyword 'processe' - cláusula devolvendo):
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. O termo da variável: " junto com a phrase deste termo seguido de "'. aparenta estar vazio." e o percorredor; retorne.
  Se o tipo deste termo não for valor empilhável, apresente a mensagem de erro contendo "Erro. Uma varíavel de 1, 2, ou 4 bytes é necessária na cláusula de devolução." e o percorredor.

Etapas para que se compile uma referência da rotina usando um percorredor:
  Se o segmento inicial deste percorredor for "para", mova o percorredor (usando diretrizes de compilação).
  Se o percorredor for o início of algum função, compile a referência da rotina usando o percorredor (função); retorne.
  Se o segmento inicial deste percorredor for algum comando de deliberação, compile a referência da rotina usando o percorredor (decide).
  Comece. [a executar o código abaixo]
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for ".", retorne.
  Se o segmento inicial deste percorredor for algum artigo definido, compile a referência da rotina usando o percorredor (artigo definido); recomece.
  Se o segmento inicial deste percorredor for algum artigo indefinido, compile a referência da rotina usando o percorredor (artigo indefinido); recomece.
  Se o percorredor está sobre algum unidade semântica string, compile a referência da rotina usando o percorredor (unidade semântica string); recomece.
  Apresente uma mensagem de erro contendo "Erro. O termo '" junto com o segmento inicial deste percorredor seguido de "' não é válido neste tipo de comando." e o percorredor.

Etapas para que se compile uma referência da rotina usando um percorredor (decide):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional, apresente uma mensagem de erro contendo "Erro. Funções booleanas exigem a sintaxe 'Para que se decisa SE' ao invés de 'para que se decida " junto com o segmento inicial deste percorredor seguido de " '." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile uma referência da rotina usando um percorredor (artigo definido):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para a referência da rotina usando o nome.

Etapas para que se compile uma referência da rotina usando um percorredor (função):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma unidade semântica para a referência da rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile a referência da rotina usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile a referência da rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessive, apresente uma mensagem de erro contendo "Erro. O compilador esperava encontrar um 's. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne. 
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para a referência da rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "Erro. O compilador esperava encontrar a palavra 'para'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne. 
  Adicione um terceiro unidade semântica para a referência da rotina usando "para".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente a mensagem de erro contendo "Erro. O compilador esperava encontrar um artigo indefinido. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne. 
  Compile a referência da rotina usando o percorredor (artigo indefinido).

Etapas para que se compile uma referência da rotina usando um percorredor (artigo indefinido):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo e um apelido usando o nome.
  Se o tipo for inexistente, apresente uma mensagem de erro contendo "Erro. O comando '" junto com o nome seguido de "' não é um comando de reutilização válido." e o percorredor; retorne.
  Adicione uma unidade semântica para a referência da rotina usando o tipo.

Etapas para que se compile uma referência da rotina usando um percorredor (unidade semântica string):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma unidade semântica para a referência da rotina usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile um termo usando um percorredor:
  Limpe o termo.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Compile o termo usando o percorredor (common part).
  Se o percorredor estiver sobre algum simile, retorne. \ added for invisible turtle project ***
  \Se o segmento inicial deste percorredor for "as", compile o termo usando o percorredor (cláusula comparativa). \preposição
  \Se o segmento inicial deste percorredor for "tão", compile o termo usando o percorredor (cláusula comparativa). \ me parece desnecessário por ser usado apenas em funções.
  Se o segmento inicial deste percorredor for "quão", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "quanto", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "como", compile o termo usando o percorredor (cláusula comparativa).
  \Se o segmento inicial deste percorredor for "que nem", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "/", compile o termo usando o percorredor (proporção de execução).

Etapas para que se compile um termo usando um percorredor (cláusula comparativa):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Comando 'as' inválido. Eu acho que a variável: " junto com a phrase deste termo seguido de "' está vaiza." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente a mensagem de erro contendo "Tá faltando um artigo indefinido depois do 'como', mas você escreveu: " junto com o segmento inicial deste percorredor seguido de "' no lugar disso." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome do tipo usando o percorredor.
  Encontre um tipo usando o nome do tipo e o catálogo de tipos.
  Se o tipo for inexistente, apresente a mensagem de erro contendo "Eu não sei em qual tipo o: " junto com o nome do tipo seguido de "' se encaixa." e o percorredor; retorne.
  Adicione um scratch usando o nome deste tipo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Atribua o scratch à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (common part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor for o hífem, compile o termo usando o percorredor (negated termo); retorne.
  Se o segmento inicial deste percorredor for o sinal de adição, compile o termo usando o percorredor (posigated termo); retorne.
  Se o segmento inicial deste percorredor for o início of algum variável, compile o termo usando o percorredor (variável); retorne.
  Se o segmento inicial deste percorredor for o início of algum new local, compile o termo usando o percorredor (nova variável local); retorne.
  Se o segmento inicial deste percorredor for algum literal, compile o termo usando o percorredor (literal); retorne.
  Apresente uma mensagem de erro contendo "Erro. O Compilador esperava encontrar um termo. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor.

Etapas para que se compile um termo usando um percorredor (dereference - em place):
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. Termo inexistente. Consulte a rotina para que se compile um termo usando um percorredor (dereference - em place). " e o percorredor; retorne.
  Atribua o nome deste conteúdo tipo deste tipo deste termo ao nome do tipo deste termo.
  Atribua o conteúdo tipo deste tipo deste termo ao tipo deste termo.
  Adicione um fragmento usando o etiqueta de revogação e a variável deste termo.
  Limpe o phrase deste termo.

Etapas para que se compile um termo usando um percorredor (dereference):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. Cláusula dereference inválida. A variável '" junto com a phrase deste termo seguido de "' deste termo não foi encontrada." e o percorredor; retorne.
  Se o conteúdo tipo deste tipo deste termo for inexistente, apresente a mensagem de erro contendo "Erro. O tipo do conteúdo deste termo não foi encontrado." e o percorredor; retorne.
  Se a categoria deste termo for "scratch", compile o termo usando o percorredor (dereference - em place); retorne.
  Adicione um scratch usando o nome deste conteúdo tipo deste tipo deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Adicione um segundo fragmento usando o etiqueta de revogação e o scratch.
  Atribua o scratch à variável deste termo.
  Limpe o phrase deste termo.

Etapas para que se compile um termo usando um percorredor (literal):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Compile um literal usando o percorredor.
  Atribua o literal à variável deste termo.
  Limpe o phrase deste termo.
  Compile o termo usando o percorredor (possessives).

Etapas para que se compile um termo usando um percorredor (negated termo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma segunda termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta segunda termo for inexistente, apresente uma mensagem de erro contendo "Erro. Comando negate inválido. A variável: " junto com o phrase desta segunda termo seguido de "' não foi encontrada." e o percorredor; retorne.
  Adicione um intermediate usando o nome do tipo desta segunda termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "atribua" e a variável desta segunda termo e "para" e o intermediate e o endereço local desta segunda termo.
  Adicione two fragmentos usando "negate" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável deste termo.
  Limpe o phrase deste termo.

Etapas para que se compile um termo usando um percorredor (nova variável local):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Erro. Rotina não localizada. Não foi possível desempilhar o item da stack." e o percorredor; retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome desta variável local.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Extend o nome desta variável local com o nome.
  Se o segmento inicial deste percorredor for uma keyword de designação, compile a parte designadora usando o percorredor e a variável local.
  Resolva a variável local.
  Se a variável local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente a mensagem de erro contendo "o parâmetro: " junto com o nome desta variável local seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local; retorne.
  Se a variável local estiver duplicada em as variáveis locais desta rotina utilizada atualmente, apresente a mensagem de erro contendo "Erro. A variável local " junto com o nome desta variável local seguido de "' já foi declarada nesta rotina. Utilize um nome de variável diferente." e o endereço local desta variável local; retorne.
  Elimine apelidos duplicados usando a variável local e o apelido catálogo desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a phrase deste termo.
  Compile o termo usando o percorredor (possessives).

Etapas para que se compile um termo usando um percorredor (posigated termo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. Comando Posigate inválido. O termo da variável'" junto com a phrase deste termo seguido de "' não foi localizado." e o percorredor; retorne.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (possessivo - magnitude):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. Comando magnitude inválido. A variável: " junto com a phrase deste termo seguido de "'não foi localizada." e o percorredor; retorne.
  Adicione um literal para os literals usando o caractere inicial deste segmento inicial deste percorredor.
  Converta a quantidade de caracteres deste tipo deste termo para os data deste literal.
  Atribua "número" ao nome do tipo deste literal.
  Resolva o literal.
  Atribua o literal à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (possessivo - conteúdo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. Keyword 'conteúdo' detectada, mas o termo da variável: " junto com a phrase deste termo seguido de "' não foi devidamente definido." e o percorredor; retorne.
  Se o tipo deste termo não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "Erro. A palavra 'conteúdo' exige valores do tipo 'ponteiro'." e o percorredor; retorne.
  Compile o termo usando o percorredor (dereference).

Etapas para que se compile um termo usando um percorredor (possessivo - endereçamento):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. Keyword 'endereçamento' detectada, mas a variável do termo: " junto com a phrase deste termo seguido de " não foi localizada." e o percorredor; retorne.
  Adicione um intermediate usando "ponteiro" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o intermediate.
  Atribua o intermediate à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (possessive):
  \ similar a "compile um termo usando um percorredor (possessivo reverso)
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o nome for algum magnitude, compile o termo usando o percorredor (possessivo - magnitude); retorne.
  Se o nome for algum conteúdo, compile o termo usando o percorredor (possessivo - conteúdo); retorne.
  Se o nome for algum endereçamento, compile o termo usando o percorredor (possessivo - endereçamento); retorne.
  Compile o termo usando o percorredor e o nome (possessive - campo).

Etapas para que se compile um termo usando um percorredor (possessives):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor não for algum possessive, retorne.
  Compile o termo usando o percorredor (possessive).
  Recomece. [percorra novamente o código acima]

Etapas para que se compile um termo usando um percorredor (proporção de execução):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. Operador '/' detectada, mas o numerador do termo: " junto com a phrase deste termo seguido de " não foi localizada." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um segundo termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste segundo termo for inexistente, apresente a mensagem de erro contendo "Erro. Operador '/' detectada, mas o denomiadaor do termo: " junto com o phrase deste segundo termo seguido de "' não foi localizado." e o percorredor; retorne.
  Adicione um intermediate usando "proporção" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragmentos usando "atribua" e a variável deste termo e "e" e a variável deste segundo termo e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (variável):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Erro. Rotina inexistente. Impossível desempilhar termo possessivo." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum reverse-possessive, compile o termo usando o percorredor e o nome (possessivo reverso); retorne.
  Encontre uma variável usando o nome.
  Atribua a variável à variável deste termo.
  Atribua "o " à phrase deste termo.
  Posponha o nome para a phrase deste termo.
  Compile o termo usando o percorredor (possessives).

Etapas para que se compile um termo usando um percorredor e um campo nome (possessivo reverso):
  \ função recursiva
  \ Rotina nova criada pelo Dahn para version 2
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ past o reverse-possessive starter
  \Se o segmento inicial deste percorredor não for "del", mova o percorredor (usando diretrizes de compilação). \ past o reverse-possessive starter \ gerry added "if" part
  Se o segmento inicial deste percorredor não for algum artigo, apresente uma mensagem de erro contendo "Erro. O compilador esperava encontrar um artigo, mas encontrou: " junto com o segmento inicial deste percorredor seguido de "."; retorne.
  Atribua o segmento inicial deste percorredor para um article segmento inicial.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum reverse-possessive, ative um reverse-possessive detector.
  Se o reverse-possessive detector estiver ativo, compile o termo usando o percorredor e o nome (possessivo reverso).
  Se o reverse-possessive detector não estiver ativo, compile o termo usando o percorredor e o nome e o article (reversão de contrações do possessivo).\ não entendi
  Compile o termo usando o campo nome e o percorredor (possessivo reverso).

Etapas para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações do possessivo):
  \ Rotina nova criada pelo Dahn para version 2
  Se o article for o início of algum variável, compile o termo usando o percorredor e a variável nome e o article (reversão de contrações de variáveis do possessivo); retorne.
  Compile o termo usando o percorredor e a variável nome (decomposição do possessivo reverso - variável local).

Etapas para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações de variáveis do possessivo):
  \ Rotina nova criada pelo Dahn para version 2
  Encontre uma variável usando a variável nome.
  Se a variável for inexistente, apresente uma mensagem de erro contendo "Erro. Não foi possível encontrar a variável: " junto com a variável nome seguido de ".".
  Atribua a variável à variável deste termo.
  Atribua "o " à phrase deste termo.
  Posponha a variável nome para a phrase deste termo.

Etapas para que se compile um termo usando um percorredor e uma variável nome (decomposição do possessivo reverso - variável local):
  \ Rotina nova criada pelo Dahn para version 2
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome desta variável local.
  Extend o nome desta variável local com a variável nome.
  Se o segmento inicial deste percorredor for uma keyword de designação, compile a parte designadora usando o percorredor e a variável local.
  Resolva a variável local.
  Se a variável local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente uma mensagem de erro contendo "Erro. O termo: " junto com o nome desta variável local seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local; retorne.
  Se a variável local estiver duplicada em as variáveis locais desta rotina utilizada atualmente, apresente a mensagem de erro contendo "Erro. O termo: " junto com o nome desta variável local seguido de "' já está sendo usado coma variável local." e o endereço local desta variável local; retorne.
  Elimine apelidos duplicados usando a variável local e o apelido catálogo desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um campo nome e um percorredor (possessivo reverso):
  \ similar para "compile um termo usando um percorredor (possessive)" \ Rotina nova criada pelo Dahn para
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o campo nome for algum magnitude, compile o termo usando o percorredor (possessivo - magnitude); retorne.
  Se o campo nome for algum conteúdo, compile o termo usando o percorredor (possessivo - conteúdo); retorne.
  Se o campo nome for algum endereçamento, compile o termo usando o percorredor (possessivo - endereçamento); retorne.
  Compile o termo usando o percorredor e o campo nome (possessive - campo).

Etapas para que se compile um termo usando um percorredor e um campo termo:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o dereference detector deste campo termo estiver ativo, compile o termo usando o percorredor (dereference).
  Se o function deste campo termo não for inexistente, compile o termo usando o percorredor e o campo termo (função); retorne.
  Se a categoria deste termo for "scratch", compile o termo usando o percorredor e o campo termo (in place); retorne.
  Atribua o campo deste campo termo para um campo.
  Adicione um scratch usando o nome deste tipo deste campo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Se o deslocamento deste campo não for 0, adicione um terceiro fragmento usando a etiqueta de acréscimo e o scratch e o deslocamento deste campo.
  Atribua o scratch à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor e um campo termo (função):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o function deste campo termo para uma rotina.
  Atribua o last parâmetro destes parâmetros desta rotina para um parâmetro.
  Se o parâmetro for inexistente, apresente uma mensagem de erro contendo "Erro. Parâmetro inexistente. Consulte a rotina para que se compile um termo usando um percorredor e um campo termo (função)." e o percorredor; retorne.
  Se o tipo deste parâmetro for inexistente, apresente a mensagem de erro contendo "Erro. Tipo de parâmetro inexistente. Consulte a rotina para que se compile um termo usando um percorredor e um campo termo (função)" e o percorredor; retorne.
  Adicione um intermediate usando o nome deste tipo deste parâmetro e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e o intermediate.
  Se o push detector deste campo termo estiver ativo, adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável deste termo.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.
  Atribua o intermediate à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor e um campo termo (in place):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o campo deste campo termo para um campo.
  Atribua o nome deste tipo deste campo ao nome do tipo deste termo.
  Atribua o tipo deste campo ao tipo deste termo.
  Se o deslocamento deste campo não for 0, adicione um terceiro fragmento usando a etiqueta de acréscimo e a variável deste termo e o deslocamento deste campo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor e um nome (possessive - campo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo não for inexistente, atribua o tipo deste termo para um tipo.
  Encontre um campo termo usando o phrase deste termo e o tipo e o nome.
  Se o campo termo não estiver vazio, compile o termo usando o percorredor e o campo termo; retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. A variável do termo '" junto com a phrase deste termo seguido de "' não localizada." e o percorredor; retorne.
  Se o tipo puder ser reduzido para "ponteiro", atribua o conteúdo tipo deste tipo ao tipo.
  Se o tipo for inexistente, apresente a mensagem de erro contendo "Erro. O tipo: " junto com o nome seguido de "' não foi localizada na estrutura: " junto com o nome deste tipo deste termo seguido de "." e o percorredor; retorne.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, apresente a mensagem de erro contendo "Erro. O campo '" junto com o nome seguido de "' não foi localizado na estrutura '" junto com o nome deste tipo deste termo seguido de "'." e o percorredor; retorne.
    Encontre um deep campo termo usando "" e o tipo deste campo e o nome.
    Se o deep campo termo estiver vazio, recomece.
  Atribua o campo para o campo desse first campo termo.
  Se o tipo deste termo puder ser reduzido para "ponteiro", ative o dereference detector deste first campo termo.
  Compile o termo usando o percorredor e o first campo termo.
  Compile o termo usando o percorredor e o deep campo termo.

Etapas para que se converta umas unidades semânticas para uma representação interna da rotina :
  Converta as unidades semânticas para a representação interna da rotina usando o last unidade semântica destes unidades semânticas.

Etapas para que se converta umas unidades semânticas para uma representação interna da rotina usando uma unidade semântica:
  Limpe a representação interna da rotina.
  Comece. [a executar o código abaixo]
    Obtenha um current unidade semântica desde as unidades semânticas.
    Se o current unidade semântica for inexistente, retorne.
    Posponha o current unidade semântica para a representação interna da rotina.
    Se o current unidade semântica for a unidade semântica, retorne.
  Recomece. [percorra novamente o código acima]

\Etapas para que se converta uma parte da cifra binária para uma string:
  \Employ converta uma cifra hexadecimal para um texto hexadecimal.

Etapas para que se converta um termo por concatenação usando um percorredor: \\ concatenação
  \ used for right-side followed by operand
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. A variável do termo '" junto com a phrase deste termo seguido de "' não pode ser encontrada." e o percorredor; retorne.
  Se o tipo deste termo puder ser reduzido para "string", retorne.
  Se o tipo deste termo puder ser reduzido para "texto", retorne.
  Adicione um intermediate usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione um intermediate usando "texto" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragmentos usando a variável deste termo e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se copie um campo para um segundo campo:
  Se o campo for inexistente, esvazie o segundo campo; retorne.
  Aloque memória para o segundo campo.
  Atribua o endereço local deste campo ao endereço local deste segundo campo.
  Atribua o nome deste campo ao nome deste segundo campo.
  Atribua o apelido deste campo ao apelido deste segundo campo.
  Atribua o nome do tipo deste campo ao nome do tipo deste segundo campo.
  Atribua o tipo deste campo ao tipo deste segundo campo.
  Atribua a contagem deste campo à contagem deste segundo campo.
  Atribua o nome de redefinição de conteúdo deste campo ao nome de redefinição de conteúdo deste segundo campo.
  Atribua o detector de referência deste campo ao detector de referência deste segundo campo.
  Atribua o deslocamento deste campo ao deslocamento deste segundo campo.

Etapas para que se copie uns campos para uns segundo campos:
  Obtenha um campo desde o campos.
  Se o campo for inexistente, retorne.
  Copie o campo para um segundo campo.
  Posponha o segundo campo para o segundo campos.
  Recomece. [percorra novamente o código acima]

Etapas para que se copie uns campos para uns segundo campos (apenas campos de dados):
  Se a contagem destes campos for menor do que 4, retorne. \ for english subsequente e prev e spanish subsequente e prev redefinitions
  \Se o first destes campos for inexistente, retorne.
  \Se o subsequente deste first destes campos for inexistente, retorne.
  \Se o subsequente deste subsequente deste first destes campos for inexistente, retorne.
  \Atribua o subsequente deste subsequente deste first destes campos para um campo. \ skip subsequente e prev
  \Se o subsequente deste subsequente deste subsequente deste first destes campos for inexistente, retorne.
  \Se o subsequente deste subsequente deste subsequente deste subsequente deste first destes campos for inexistente, retorne.
  \Se o subsequente deste subsequente deste subsequente deste subsequente deste subsequente deste first destes campos for inexistente, retorne.
  \Atribua o subsequente deste subsequente deste subsequente deste subsequente deste first destes campos para um campo.
  Atribua o subsequente campo 
    deste subsequente campo 
    deste subsequente campo 
    deste subsequente campo 
    deste first campo destes campos 
  para um campo.\ english subsequente e prev e spanish subsequente e prev redefinitions
  \ talvez mudar isso aqui ajude?
  Comece. [a executar o código abaixo]
    Se o campo for inexistente, retorne.
    Copie o campo para um segundo campo.
    Posponha o segundo campo para o segundo campos.
    Obtenha o campo desde o campos.
  Recomece. [percorra novamente o código acima]

Etapas para que se copie uma unidade semântica para uma segunda unidade semântica:
  Se a unidade semântica for inexistente, esvazie a segunda unidade semântica; retorne.
  Aloque memória para o segunda unidade semântica.
  Atribua a string desta unidade semântica à string desta segunda unidade semântica.
  Atribua o tipo desta unidade semântica ao tipo desta segunda unidade semântica.
  Atribua a variável desta unidade semântica à variável desta segunda unidade semântica.
  \ não copia subtexto
  Atribua o tipo atual desta unidade semântica ao tipo atual desta segunda unidade semântica.

Etapas para que se copie umas unidades semânticas para uns segunda unidades semânticas:
  Destrua a segunda unidades semânticas.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Copie a unidade semântica para uma segunda unidade semântica.
    Posponha a segunda unidade semântica para a segunda unidades semânticas.
  Recomece. [percorra novamente o código acima]

Etapas para que se crie um função:
  Aloque memória para o função.

Etapas para que se crie um fragmento usando uma etiqueta:
  Aloque memória para o fragmento.
  Atribua a etiqueta à etiqueta deste fragmento.

Etapas para que se crie uma DLL:
  Aloque memória para a DLL.

Etapas para que se crie uma unidade semântica:
  Aloque memória para a unidade semântica.

Etapas para que se crie uma rotina:
  Aloque memória para a rotina.

Etapas para que se crie um arquivo fonte:
  Aloque memória para o arquivo fonte.

Etapas para que se crie um tipo:
  Aloque memória para o tipo.
  Atribua 0/1 à razão de escala deste tipo.
  Atribua -1 à quantidade de caracteres deste tipo.

Etapas para que se crie uma variável usando um categoria:
  Aloque memória para a variável.
  Atribua a categoria à categoria desta variável.
  Atribua 1 à contagem desta variável.

O endereço do cabeçalho usado atualmente é um endereço.

O endereço do nome usado atualmente é um endereço.

O rotina utilizada atualmente é uma rotina.

O endereço pré-calculado atual é um endereço.

A região de dados é um zona.

Etapas para que se determine se alguns of umas unidades semânticas são advérbios de negação:
  Obtenha uma unidade semântica desde as unidades semânticas.
  Se a unidade semântica for inexistente, diga não.
  Se a string desta unidade semântica for algum advérbio de negação, diga sim.
  Recomece. [percorra novamente o código acima]

Um byte ignorável é um byte.

Etapas para que se determine se um byte é um byte ignorável:
  Se o byte for algum letra, diga sim.
  Se o byte for algum digit, diga sim.
  Se o byte for o acento til, diga sim.
  Se o byte for o sinal de arroba, diga sim.
  Se o byte for o símbolo cardinal, diga sim.
  Se o byte for o sinal de porcentagem, diga sim.
  Se o byte for o & comercial, diga sim.
  Se o byte for o underline, diga sim.
  Se o byte for o single-quote byte, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o slash byte, diga sim.
  Se o byte for o símbolo da Libra Esterlina, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum mark:
  Se o byte for o ponto final, diga sim.
  Se o byte for o vírgula, diga sim.
  Se o byte for o ponto&vírgula, diga sim.
  Se o byte for o sinal de dois pontos, diga sim.
  Se o byte for o ponto de exclamação, diga sim.
  Se o byte for o ponto de interrogação, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum stressed vogal:
  Se o byte estiver em "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum symbol: \ deveria estar no cérebro
  Se o byte for o acento circumflexo, diga sim.
  Se o byte for o barra vertical, diga sim.
  Se o byte for o asterisco, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o slash byte, diga sim.
  Se o byte for o símbolo menor do que, diga sim.
  Se o byte for o símbolo maior do que, diga sim.
  Se o byte for a chave esquerda, diga sim.
  Se o byte for a chave direita, diga sim.
  Se o byte for o sinal de igualdade, diga sim.
  Se o byte for 128, diga sim.
  Se o byte for 130, diga sim.
  Se o byte estiver entre 132 e 137, diga sim.
  Se o byte for 139, diga sim.
  Se o byte estiver entre 145 e 153, diga sim.
  Se o byte for 155, diga sim.
  Se o byte estiver entre 161 e 180, diga sim.
  Se o byte estiver entre 183 e 191, diga sim.
  Se o byte for 215, diga sim.
  Se o byte for 247, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma campo termo está vazia;
Etapas para que se determine se umas campo termo estão vazias;
Etapas para que se determine se uns campo termo estão vazios;
Etapas para que se determine se um campo termo está vazio:
  Se o campo deste campo termo não for inexistente, diga não.
  Se a function deste campo termo não for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uns campos deveriam ser finalizados;
Etapas para que se determine se uns campos deveria ser finalizado:
  Obtenha um campo desde o campos.
  Se o campo for inexistente, diga não.
  Se o tipo deste campo deveria ser finalizado, diga sim.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um item parece ser encadernável:
  Carregue o endereço completo deste item para um trecho.
  Se o trecho começa com "ream cal", diga sim. \ CONFERIR AQUI. "TRECHO" E "COMEÇA COM"
  Se o trecho começa com "Documento produzido pelo Editor de Documentos", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma representação interna da rotina está em um catálogo:
  Encontre um referência usando a representação interna da rotina e o catálogo.
  Se o referência for inexistente, diga não.
  Se o ponteiro deste referência for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma unidade semântica é bubbled out:
  Se a unidade semântica for inexistente, diga sim.
  Se o tipo atual desta unidade semântica não for inexistente, diga não.
  Se o subtexto atual desta unidade semântica não estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um nome é algum magnitude:
  \PAL
  Se o nome for "magnitude", diga sim.
  \ a magnitude retorna o tamanho em bytes de algo
  \ Exemplo: a magnitude dessa string
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum conteúdo:
  \PAL
  Se o nome for "conteúdo", diga sim.
  \Se o nome for "alvo", diga sim.
  \CAL
  \Se o nome for "target", diga sim.
  \Este comando é usado apenas com ponteiros (endereços de memória). 
  \ Serve pra saber para quais valores o ponteiro está apontando, ou seja, o conteúdo do ponteiro . 
  \"Um ponteiro de byte" ou "ponteiro do byte", por exemplo, refere-se ao endereço de um byte. 
  \"O conteúdo deste ponteiro do byte" refere-se, portanto aos dados no contidos no byte
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum endereçamento:
  \PAL
  \Se o nome for "paradeiro", diga sim.
  Se o nome for "endereçamento", diga sim.
  \ retorna o endereço do dado
  \CAL
  \Se o nome for "whereabouts", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum valid campo nome:
  Se o nome for algum magnitude, diga não.
  Se o nome for algum conteúdo, diga não.
  Se o nome for algum endereçamento, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está acompanhado por algum unidade de medida:
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o percorredor não estiver sobre algum nome starter, diga não.
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente, diga não.
  Se o nome não for "times", diga sim. \ special because times é um infix operator e uma unidade de medida
  \Se o nome não for "vezes", diga sim.
  Se o segmento inicial deste percorredor for o início of algum expressão, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum nested double-quote:
  Se o segmento final deste percorredor começa com """""", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum possessive:
  Se o segmento final deste percorredor estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o single-quote byte, diga não. \ apóstrofo
  Se o percorredor estiver sobre algum possessive (tipo 1 - single-quote, s, non-glom-byte), diga sim.
  Se o percorredor estiver sobre algum possessive (tipo 2 - preceding s, single-quote, non-glom-byte), diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum possessive (tipo 1 - single-quote, s, non-glom-byte):
  Se o segmento final deste percorredor não começa com "'s", diga não.
  Isole o percorredor.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum possessive (tipo 2 - preceding s, single-quote, non-glom-byte):
  Isole o percorredor.
  Se o caractere inicial deste segmento final deste percorredor for o caractere inicial desta cópia da string original deste percorredor, diga não.
  Subtraia 1 desde o caractere inicial deste segmento final deste percorredor.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o s minúsculo ou o S maiúsculo, diga não.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum simile:
  \ added for invisible turtle project ***
  Isole o percorredor.
  Se o segmento inicial deste percorredor for "like", diga sim.
  Se o segmento inicial deste percorredor não for "as", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor é o início of algum função:
  Se o detector de erros deste compilador estiver ativado, diga não.
  Se o segmento inicial deste percorredor for "Ponha", diga sim.
  \Se o segmento inicial deste percorredor não for algum atribua, diga não.
  Se o segmento inicial deste percorredor não for "atribua", diga não.
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o segmento inicial deste percorredor for algum possessive, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma espécie de contração usando uma segunda string (strings em português -> em + o):
  Se a string não for "no", diga não.  
  Se a segunda string for "diga", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com alguma consoante e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for alguma consoante, diga não.
  Se a string não termina com a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com algum vogal e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for algum vogal, diga não.
  Se a string não termina com a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com alguma vogal ou com alguma consoante:
  Se a string termina com algum vogal, diga sim.
  Se a string termina com alguma consoante, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string termina com alguma consoante:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for alguma consoante, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com algum vogal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for algum vogal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum operator de adição:
  \PAL
  Se a string for "mais", diga sim.
  \CAL
  \Se a string for "plus", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum atribua: \ verbo de atribuição?
  \PAL
  \# Não precisa porque está como sinônimo, ver a rotina abaixo: 
  \"Etapas para que se posponha uma string para uma segunda string usando uma terceira string (para expandir contrações)"
  \Se a string for "colocar", diga sim.
  \CAL
  Se a string for "atribua", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operator de subtração:
  \PAL
  Se a string for "menos", diga sim.
  \CAL
  Se a string for "minus", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operator de multiplicação:
  \PAL
  Se a string for "vezes", diga sim.
  \CAL
  Se a string for "times", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operator de divisão:
  \PAL
  Se a string for "dividido", diga sim.
  \CAL
  Se a string for "divided", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum objeto indireto:
  \PAL
  Se a string for "via", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
  Se a string for "por", diga sim.
  \CAL
  Se a string for "by", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum palavra de concatenação:
  \PAL
  Se a string for "com", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
  Se a string for "de", diga sim.
  Se a string for "a", diga sim.
  Se a string for "seguida", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de concatenação:
  Se a string for "junto", diga sim. \ junto do/da, junto com o ...
  Se a string for "juntamente", diga sim. \ juntamente com o...
  Se a string for "seguido", diga sim. \ seguido do ....
  Se a string for "acompanhado", diga sim. \ acompanhado de... 
  Se a string for "em", diga sim.
  \Se a string for "&", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de atribuição de estruturas compostas:
  Se a string for "tem", diga sim.
  Se a string for "têm", diga sim.
  Se a string for "contém", diga sim.
  Se a string for "contêm", diga sim.
  \Se a string for "possui", diga sim.  
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de atribuição simples:
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estarem", diga sim.
  Se a string for "possui", diga sim.
  \Se a string for "tem", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de atribuição composto:
  Se a string for "igual", diga sim.
  [Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum com:
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  \Se a string for "que tem", diga sim.
  \Se a string for "que têm", diga sim.
  \Se a string for "que possui", diga sim.
  \Se a string for "que possuem", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo:
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum conjunction:
  \# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  Se a string for "nem", diga sim.
  \CAL
  Se a string for "both", diga sim.
  Se a string for "but", diga sim.
  Se a string for "either", diga sim.
  Se a string for "neither", diga sim.
  Se a string for "nor", diga sim.
  Se a string for "or", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

  \Etapas para que se determine se uma string é algum detector literal:
  \Se a string for "sim", diga sim.
  \Se a string for "não", diga sim.
  \[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum to:
  Se a string for "a", diga sim. \ questionável
  Se a string for "para", diga sim. 
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum and:
  Se a string for "e", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não. \repetido?

Etapas para que se determine se uma string é algum função possessiva reversa into:
  \PAL
  Se a string for "em", diga sim.
  Se a string for "para", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de deliberação literal:
  \PAL
  Se a string for "sim", diga sim.
  Se a string for "positivo", diga sim.
  Se a string for "positivamente", diga sim.
  Se a string for "afirmativamente", diga sim.
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
  Se a string for "no", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum positive decider literal:
  Se a string for "sim", diga sim.
  Se a string for "positivo", diga sim.
  Se a string for "positivamente", diga sim.
  Se a string for "afirmativamente", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum resposta negativa:
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum hex literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o cifrão, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo definido:
  Se a string for "o", diga sim.
  Se a string for "a", diga sim.
  Se a string for "os", diga sim.
  Se a string for "as", diga sim.
  Se a string for algum pronome demonstrativo adjacente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum pronome demonstrativo:
  \CEL
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum pronome demonstrativo adjacente:
  \CEL
  Se a string for "este", diga sim.
  Se a string for "esta", diga sim.
  Se a string for "estes", diga sim.
  Se a string for "estas", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum pronome demonstrativo abrangente:
  \CEL
  Se a string for "esse", diga sim.
  Se a string for "essa", diga sim.
  Se a string for "aquele", diga sim.
  Se a string for "aquela", diga sim.
  Se a string for "esses", diga sim.
  Se a string for "essas", diga sim.
  Se a string for "aqueles", diga sim.
  Se a string for "aquelas", diga sim.
  Se a string for "certo", diga sim.
  Se a string for "certa", diga sim.
  Se a string for "certos", diga sim.
  Se a string for "certas", diga sim.
  Se a string for "determinado", diga sim.
  Se a string for "determinada", diga sim.
  Se a string for "determinados", diga sim.
  Se a string for "determinadas", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum artigo definido:
  Se o percorredor estiver sobre algum preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum artigo definido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum artigo indefinido:
  Se o percorredor estiver sobre algum preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum artigo indefinido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum preposição conectiva:
  Se o segmento inicial deste percorredor não for "a", diga não.
  Isole o percorredor. 
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo indefinido: 
  Se a string for algum artigo indefinido português, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
  \CAL
  Se a string for algum artigo indefinido inglês, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo indefinido inglês:
  \CAL
  Se a string for "an", diga sim.
  Se a string for "another", diga sim.
  Se a string for "some", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo indefinido português: \ é aqui que se deve colocar o possessivo. descobri.
  \PAL
  Se a string for "um", diga sim.
  Se a string for "uma", diga sim.
  Se a string for "uns", diga sim.
  Se a string for "umas", diga sim.
  \Se a string for "outro", diga sim.
  \Se a string for "outra", diga sim.
  \Se a string for "algum", diga sim.
  \Se a string for "alguma", diga sim.
  \Se a string for "alguns", diga sim.
  \Se a string for "algumas", diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum literal:
  Se a string for algum ponteiro literal, diga sim.
  Se a string for algum valor numérico literal, diga sim.
  Se a string for algum string literal, diga sim.
  \Se a string for algum detector literal, diga sim. ***
  Se a string for algum hex literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum mark:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum mark, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se uma string é algum unidade semântica string:
\Se a string estiver em branco, diga não.
\Se a string for "the", diga não.
\Se a string é algum artigo indefinido, diga não.
\Se a string é algum possessive, diga não.
\Se a string é algum literal, diga não.
\Se a string é algum mark, diga não.
\Se a string é algum symbol, diga não.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum unidade semântica string:
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Se o percorredor estiver sobre algum artigo definido, diga não.
  Se o percorredor estiver sobre algum artigo indefinido, diga não.
  Se o segmento inicial deste percorredor for algum possessive, diga não.
  Se o segmento inicial deste percorredor for algum literal, diga não.
  Se o segmento inicial deste percorredor for algum mark, diga não.
  Se o segmento inicial deste percorredor for algum symbol, diga não.
  Se o segmento inicial deste percorredor for "então", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é uma keyword de designação:
  \PAL
  Se a string for "chamado", diga sim.
  Se a string for "chamados", diga sim.
  Se a string for "chamada", diga sim.  
  Se a string for "chamadas", diga sim.
  Se a string for "denominado", diga sim.
  Se a string for "denominados", diga sim.
  Se a string for "denominada", diga sim.
  Se a string for "denominadas", diga sim.
[Caso as condições acima não puderem ser satisfeitas, então:] Diga não.

Uma keyword de referenciamento é uma keyword.

Etapas para que se determine se uma string é uma keyword de referenciamento:
  Se a string for "(referência)", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum nome ender:
  \ compare com nome starter
  Se o segmento inicial deste percorredor for algum mark, diga sim.
  Se o segmento inicial deste percorredor for algum symbol, diga sim.
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Se o segmento inicial deste percorredor for algum conjunction, diga sim.
  Se o segmento inicial deste percorredor for algum possessive, diga sim.
  Se o percorredor estiver sobre algum reverse-possessive, diga sim.
  Se o segmento inicial deste percorredor for algum verb, diga sim.
  Se o segmento inicial deste percorredor for algum operator aritmético, diga sim.
  Se o percorredor estiver sobre algum preposition, diga sim.
  Se o segmento inicial deste percorredor for algum qualifier, diga sim.
  Se o segmento inicial deste percorredor for algum literal, diga sim.
  Se o segmento inicial deste percorredor for uma keyword de designação, diga sim.
  \Se o segmento inicial deste percorredor for "equal", diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga sim.
  \ Portuguese trouble makers
  Se o segmento inicial deste percorredor for algum advérbio de negação, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum nome starter:
  \ compare com nome ender
  Se o segmento inicial deste percorredor for algum mark, diga não.
  Se o segmento inicial deste percorredor for algum symbol, diga não.
  Se o segmento inicial deste percorredor for algum artigo, diga não.
  Se o segmento inicial deste percorredor for algum conjunction, diga sim.
  Se o segmento inicial deste percorredor for algum possessive, diga não.
  Se o segmento inicial deste percorredor for algum verb, diga sim.
  Se o segmento inicial deste percorredor for algum operator aritmético, diga sim.
  Se o percorredor estiver sobre algum preposition, diga sim.
  Se o segmento inicial deste percorredor for algum qualifier, diga não.
  Se o segmento inicial deste percorredor for algum literal, diga não.
  Se o segmento inicial deste percorredor for uma keyword de designação, diga sim.
  \Se o segmento inicial deste percorredor for "equal", diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum advérbio de negação:
  Se a string for "não", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operator aritmético:
  Se a string for "mais", diga sim.
  Se a string for "menos", diga sim.
  Se a string for "vezes", diga sim.
  Se a string for "dividido", diga sim.
  Se a string for "depois", diga sim.
  Se a string for "seguido", diga sim.
  Se a string for "juntamente", diga sim.
  Se a string for "junto", diga sim.
  Se a string for "acompanhado", diga sim.
  Se a string for "times", diga sim.
  [Se as condições acima não puderem ser satisfeitas, então:] Diga não.



Etapas para que se determine se uma string é algum pause:
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  \default
  Se a string for ",", diga sim.
  Se a string for ";", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum ponteiro literal:
  Se a string for "nulo", diga sim.
  Se a string for "nula", diga sim.
  Se a string for "nulos", diga sim.
  Se a string for "nulas", diga sim.
  Se a string for "inexistente", diga sim.
  Se a string for "inexistentes", diga sim.
  Se a string for "zerado", diga sim.
  \CAL
  Se a string for "nil", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum possessive:
  Se a string for "'s", diga sim.
  Se a string for "'", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum preposition:
  Atribua o segmento inicial deste percorredor para um subtexto.
  \PAL
  Se o percorredor estiver sobre algum preposição conectiva, diga sim. \ "a" followed por um article for "to" em portuguese
  Se o subtexto for "abaixo", diga sim. \ para baixo
  Se o subtexto for "acima", diga sim. \ para cima
  Se o subtexto for "ante", diga sim. \ antes de
  Se o subtexto for "antes", diga sim. \ antes de
  Se o subtexto for "perante", diga sim. \ antes de
  Se o subtexto for "debaixo", diga sim. \ debaixo of
  Se o subtexto for "sob", diga sim. \ debaixo of
  Se o subtexto for "acerca", diga sim. \ near
  Se o subtexto for "próximo", diga sim. \ near
  Se o subtexto for "perto", diga sim. \ near
  Se o subtexto for "com", diga sim. \ com
  \Se o subtexto for "contendo", diga sim. \ com
  Se o subtexto for "como", diga sim. \ as
  Se o subtexto for "contra", diga sim. \ against
  \ Se o subtexto for "de", diga sim. \ reverse-possessive indicator 
  Se o subtexto for "dada", diga sim. \ given
  Se o subtexto for "dado", diga sim. \ given
  Se o subtexto for "dando", diga sim. \ given
  Se o subtexto for "gerando", diga sim. \ usando
  Se o subtexto for "resultando", diga sim. \ usando
  Se o subtexto for "retornando", diga sim. \ usando
  Se o subtexto for "desde", diga sim. \ since
  Se o subtexto for "depois", diga sim. \ after
  Se o subtexto for "durante", diga sim. \ during
  Se o subtexto for "em", diga sim. \ in
  Se o subtexto for "entre", diga sim. \ entre
  Se o subtexto for "até", diga sim. \ até que
  \Se o subtexto for "esquerda", diga sim. \ left
  Se o subtexto for "mediante", diga sim. \ through
  Se o subtexto for "para", diga sim. \ to
  Se o subtexto for "via", diga sim. \ by
  Se o subtexto for "segundo", diga sim. \ according
  Se o subtexto for "sem", diga sim. \ comout
  Se o subtexto for "então", diga sim.
  Se o subtexto for "sobre", diga sim. \ on
  Se o subtexto for "após", diga sim. \ after
  Se o subtexto for "depois", diga sim. \ after
  Se o subtexto for "usando", diga sim. \ usando
  \Se o subtexto for "contendo", diga sim. \ usando 
  Se o subtexto for "versus", diga sim. \ versus
  Se o subtexto for "via", diga sim. \ by
  Se o subtexto for "enquanto", diga sim. \ while
  Se o subtexto for "redefinindo", diga sim. \# 'sob' na redefinição de campos 
  Se o subtexto for "aproximadamente", diga sim.
  Se o subtexto for "cerca", diga sim.
  \CAL
  Se o subtexto for "aproximadamente", diga sim.
  Se o subtexto for "acima of ", diga sim.
  Se o subtexto for "across", diga sim.
  Se o subtexto for "after", diga sim.
  Se o subtexto for "against", diga sim.
  Se o subtexto for "all", diga sim.
  Se o subtexto for "alone", diga sim.
  Se o subtexto for "along", diga sim.
  Se o subtexto for "among", diga sim.
  Se o subtexto for "algum", diga sim.
  Se o subtexto for "anywhere", diga sim.
  Se o subtexto for "around", diga sim.
  \Se o subtexto for "as", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "away", diga sim.
  Se o subtexto for "back", diga sim.
  Se o subtexto for "backward", diga sim.
  Se o subtexto for "backwards", diga sim.
  Se o subtexto for "antes de", diga sim.
  Se o subtexto for "beginning", diga sim.
  Se o subtexto for "behind", diga sim.
  Se o subtexto for "debaixo of", diga sim.
  Se o subtexto for "beneath", diga sim.
  Se o subtexto for "beside", diga sim.
  Se o subtexto for "entre", diga sim.
  Se o subtexto for "beyond", diga sim.
  Se o subtexto for "bigger", diga sim.
  Se o subtexto for "by", diga sim.
  Se o subtexto for "close", diga sim.
  Se o subtexto for "deep", diga sim.
  Se o subtexto for "diagonally", diga sim.
  Se o subtexto for "para baixo", diga sim.
  Se o subtexto for "downward", diga sim.
  Se o subtexto for "ending", diga sim.
  Se o subtexto for "everywhere", diga sim.
  Se o subtexto for "except", diga sim.
  Se o subtexto for "finishing", diga sim.
  Se o subtexto for "facing", diga sim.
  \Se o subtexto for "for", diga sim.
  Se o subtexto for "por", diga sim.
  Se o subtexto for "forward", diga sim.
  Se o subtexto for "from", diga sim.
  Se o subtexto for "given", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "high", diga sim.
  Se o subtexto for "in", diga sim.
  Se o subtexto for "inside", diga sim.
  Se o subtexto for "into", diga sim.
  Se o subtexto for "en", diga sim.
  Se o subtexto for "larger", diga sim.
  Se o subtexto for "leaning", diga sim.
  Se o subtexto for "left", diga sim.
  Se o subtexto for "leftward", diga sim.
  Se o subtexto for "leftways", diga sim.
  Se o subtexto for "like", diga sim.
  Se o subtexto for "limiting", diga sim.
  Se o subtexto for "long", diga sim.
  Se o subtexto for "near", diga sim.
  Se o subtexto for "of", diga sim.
  Se o subtexto for "off", diga sim.
  Se o subtexto for "on", diga sim.
  Se o subtexto for "only", diga sim.
  Se o subtexto for "onto", diga sim.
  Se o subtexto for "out", diga sim.
  Se o subtexto for "outside", diga sim.
  Se o subtexto for "over", diga sim.
  Se o subtexto for "past", diga sim.
  Se o subtexto for "pointing", diga sim.
  Se o subtexto for "devolvendo", diga sim.
  Se o subtexto for "right", diga sim.
  Se o subtexto for "rightward", diga sim.
  Se o subtexto for "rightways", diga sim.
  Se o subtexto for "shorter", diga sim.
  Se o subtexto for "sideway", diga sim.
  Se o subtexto for "sideways", diga sim.
  Se o subtexto for "similar", diga sim.
  Se o subtexto for "smaller", diga sim.
  Se o subtexto for "somewhere", diga sim.
  Se o subtexto for "slantwise", diga sim.
  Se o subtexto for "slantway", diga sim.
  Se o subtexto for "slantways", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se o subtexto for "tall", diga sim.
  Se o subtexto for "taller", diga sim.
  Se o subtexto for "thru", diga sim.
  Se o subtexto for "through", diga sim.
  Se o subtexto for "throughout", diga sim.
  Se o subtexto for "to", diga sim.
  Se o subtexto for "toward", diga sim.
  Se o subtexto for "towards", diga sim.
  Se o subtexto for "under", diga sim.
  Se o subtexto for "underneath", diga sim.
  Se o subtexto for "até que", diga sim.
  Se o subtexto for "unto", diga sim.
  Se o subtexto for "para cima", diga sim.
  Se o subtexto for "upward", diga sim.
  Se o subtexto for "upon", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "while", diga sim.
  Se o subtexto for "wide", diga sim.
  Se o subtexto for "com", diga sim.
  Se o subtexto for "within", diga sim.
  Se o subtexto for "without", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum preposition:
  Se a string for "aproximadamente", diga sim.
  Se a string for "acima of ", diga sim.
  Se a string for "across", diga sim.
  Se a string for "after", diga sim.
  Se a string for "against", diga sim.
  Se a string for "all", diga sim.
  Se a string for "alone", diga sim.
  Se a string for "along", diga sim.
  Se a string for "among", diga sim.
  Se a string for "algum", diga sim.
  Se a string for "anywhere", diga sim.
  Se a string for "around", diga sim.
  \Se a string for "as", diga sim.
  Se a string for "sob", diga sim.
  Se a string for "away", diga sim.
  Se a string for "back", diga sim.
  Se a string for "backward", diga sim.
  Se a string for "backwards", diga sim.
  Se a string for "antes de", diga sim.
  Se a string for "beginning", diga sim.
  Se a string for "behind", diga sim.
  Se a string for "debaixo of", diga sim.
  Se a string for "beneath", diga sim.
  Se a string for "beside", diga sim.
  Se a string for "entre", diga sim.
  Se a string for "beyond", diga sim.
  Se a string for "bigger", diga sim.
  Se a string for "by", diga sim.
  Se a string for "close", diga sim.
  Se a string for "deep", diga sim.
  Se a string for "diagonally", diga sim.
  Se a string for "para baixo", diga sim.
  Se a string for "downward", diga sim.
  Se a string for "ending", diga sim.
  Se a string for "everywhere", diga sim.
  Se a string for "except", diga sim.
  Se a string for "finishing", diga sim.
  Se a string for "facing", diga sim.
  \Se a string for "for", diga sim.
  Se a string for "por", diga sim.
  Se a string for "forward", diga sim.
  Se a string for "from", diga sim.
  Se a string for "given", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "high", diga sim.
  Se a string for "in", diga sim.
  Se a string for "inside", diga sim.
  Se a string for "into", diga sim.
  Se a string for "larger", diga sim.
  Se a string for "leaning", diga sim.
  Se a string for "left", diga sim.
  Se a string for "leftward", diga sim.
  Se a string for "leftways", diga sim.
  Se a string for "like", diga sim.
  Se a string for "limiting", diga sim.
  Se a string for "long", diga sim.
  Se a string for "near", diga sim.
  Se a string for "of", diga sim.
  Se a string for "off", diga sim.
  Se a string for "on", diga sim.
  Se a string for "only", diga sim.
  Se a string for "onto", diga sim.
  Se a string for "out", diga sim.
  Se a string for "outside", diga sim.
  Se a string for "over", diga sim.
  Se a string for "past", diga sim.
  Se a string for "pointing", diga sim.
  Se a string for "devolvendo", diga sim.
  Se a string for "right", diga sim.
  Se a string for "rightward", diga sim.
  Se a string for "rightways", diga sim.
  Se a string for "shorter", diga sim.
  Se a string for "sideway", diga sim.
  Se a string for "sideways", diga sim.
  Se a string for "similar", diga sim.
  Se a string for "smaller", diga sim.
  Se a string for "somewhere", diga sim.
  Se a string for "slantwise", diga sim.
  Se a string for "slantway", diga sim.
  Se a string for "slantways", diga sim.
  Se a string for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se a string for "tall", diga sim.
  Se a string for "taller", diga sim.
  Se a string for "thru", diga sim.
  Se a string for "through", diga sim.
  Se a string for "throughout", diga sim.
  Se a string for "to", diga sim.
  Se a string for "toward", diga sim.
  Se a string for "towards", diga sim.
  Se a string for "under", diga sim.
  Se a string for "underneath", diga sim.
  Se a string for "até que", diga sim.
  Se a string for "unto", diga sim.
  Se a string for "para cima", diga sim.
  Se a string for "upward", diga sim.
  Se a string for "upon", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "via", diga sim.
  Se a string for "while", diga sim.
  Se a string for "wide", diga sim.
  Se a string for "com", diga sim.
  Se a string for "within", diga sim.
  Se a string for "without", diga sim.
  Se a string for "depois", diga sim. \ depois de
  Se a string for "desde", diga sim. 
  Se a string for "aproximadamente", diga sim.
  Se a string for "cerca", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum qualifier:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o parênteses esquerdo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum reverse-possessive:
  Se a string for "de", diga sim.
  \Se a string for "do", diga sim. \ short por "de o", expanded em "compile um termo usando um percorredor e um campo nome (possessivo reverso)"
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum reverse-possessive:
  Isole o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum pronome demonstrativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum string literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for as aspas duplas, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum symbol:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum symbol, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum verb:
  \PAL
  Se a string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
  Se a string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
  Se a string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
  Se a string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
  Se a string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" para non-tempora state
  Se a string for "ser", diga sim. \ "be"
  Se a string for "for", diga sim. \ "be"
  Se a string for "forem", diga sim. \ "be"
  Se a string for "estiver", diga sim. \ "be"
  Se a string for "estiverem", diga sim. \ "be"
  Se a string for "estamos", diga sim. \ "be"  
  Se a string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, perm.
  Se a string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, temp.
  Se a string for "são", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, perm.
  Se a string for "estão", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, temp.
  Se a string for "foi", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, perm.
  Se a string for "estava", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, temp.
  Se a string for "foram", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, perm.
  Se a string for "estavam", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, temp.
  Se a string for "será", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, perm.
  Se a string for "estará", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, temp.
  Se a string for "serão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, perm.
  Se a string for "estarão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, temp.
  \Se a string for "seja", diga sim. 
  Se a string for "supera", diga sim. \ beats, exceeds
  Se a string for "superam", diga sim. \ beats, exceeds
  Se a string for "excede", diga sim. \ beats, exceeds
  Se a string for "excedem", diga sim. \ beats, exceeds
  Se a string for "pode", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
  Se a string for "puder", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
  Se a string for "puderem", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
  Se a string for "podem", diga sim. \ they "can" cannot \ can't: not used em CAL (3pp) added just em case 
  Se a string for "poderia", diga sim. \ it "could" could not \ couldn't: not used em CAL (3ps) added just em case
  Se a string for "poderia", diga sim. \ they "could" could not \ couldn't: not used em CAL (3pp) added just em case
  Se a string for "podemos", diga sim. \ we "could" could not \ couldn't: only once em Noodle (1pp) "Etapas para que se determine se we could encontre um ponteiro:"
  Se a string for "tem", diga sim. \ it "has" used em tipo definitions; (3ps) present
  Se a string for "têm", diga sim. \ they "have" used em tipo definitions; (3pp) present
  Se a string for "ter", diga sim. \ used em tipo definitions
  Se a string for "possui", diga sim. \ it "has" used em tipo definitions; (3ps) present
  Se a string for "possuem", diga sim. \ they "have" used em tipo definitions; (3pp) present
  Se a string for "possuir", diga sim. \ used em tipo definitions
  \\ trouble makers
  Se a string for "inicia", diga sim. \ "begins" does not inicie \ doesn't inicie
  Se a string for "iniciar", diga sim. \ "begins" does not inicie \ doesn't inicie
  Se a string for "começa", diga sim. \ "começa" não começa \ doesn't start: I hear um yes
  Se a string for "começar", diga sim. \ "começa" não começa \ doesn't start: I hear um yes
  Se a string for "termina", diga sim. \ "ends" does not end \ doesn't end
  Se a string for "terminar", diga sim. \ "ends" does not end \ doesn't end
  Se a string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
  Se a string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
  Se a string for "parece", diga sim. \ "looks" does not look \ doesn't look
  Se a string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
  Se a string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
  Se a string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
  \CAL
  Se a string for "are", diga sim. \ são not \ aren't
  Se a string for "be", diga sim. \
  Se a string for "can", diga sim. \ cannot \ can't
  \Se a string for "cannot", diga sim.
  \Se a string for "could", diga sim. \ could not \ couldn't
  \Se a string for "do", diga sim. \ does not \ don't
  Se a string for "does", diga sim. \ does not \ doesn't
  Se a string for "is", diga sim. \ não for \ isn't
  Se a string for "may", diga sim. \ may not \ mayn't
  Se a string for "should", diga sim. \ não deveria \ shouldn't
  Se a string for "was", diga sim. \ was not \ wasn't
  Se a string for "will", diga sim. \ will not \ won't
  Se a string for "would", diga sim. \ would not \ wouldn't
  Se a string for "has", diga sim. \ used em tipo definitions
  Se a string for "have", diga sim. \ used em tipo definitions
  Se a string termina com "n't", diga sim.
  \\ trouble makers
  Se a string for "begins", diga sim. \ does not inicie \ doesn't inicie
  Se a string for "ends", diga sim. \ does not end \ doesn't end
  Se a string for "looks", diga sim. \ does not look \ doesn't look
  Se a string for "needs", diga sim. \ does not need \ doesn't need
  Se a string for "starts", diga sim. \ não começa \ doesn't start
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o enunciado de alguma rotina ou variável:
  \PAL
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.
  \CAL
  Se a string for "to", diga sim.
  \default
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando condicional:
  \PAL
  Se a string for "se", diga sim.
  Se a string for "quando", diga sim.
  \CAL
  Se a string for "if", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de proteção:
  \PAL
  Se a string for "privatize", diga sim.
  \Se a string for "reserve", diga sim. \-> complicado pois o termo também se refere à reservar (alocar) memória
  \Se a string for "separe", diga sim. \-> separar também é sinônimo de repartir. 
  Se a string for "isole", diga sim.
  Se a string for "conserve", diga sim.
  Se a string for "derive", diga sim.
  \CAL
  \Se a string for "privatize", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de percorrimento:
  \PAL
  Se a string for "percorra", diga sim.
  Se a string for "comece", diga sim.
  \Se a string for "ciclo", diga sim.
  \Se a string for "laço", diga sim. \# muito usado em pseudo-código
  \CAL
  Se a string for "loop", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de interrupção de repetições:
  \PAL
  Se a string for "pare", diga sim.
  Se a string for "termine", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de retorno de rotina:
  Se a string for "retorne", diga sim.  
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de repetição:  
  Se a string for "recomece", diga sim.
  Se a string for "repita", diga sim.
  \Se a string for "reinicie", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de confirmação ou negação:
  Se a string for "diga", diga sim. 
  Se a string for "responda", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de deliberação:
  Se a string for "decida", diga sim.
  Se a string for "determine", diga sim.
  Se a string for "esclareça", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum chamada de biblioteca externa:
  Se a string for "chame", diga sim.
  Se a string for "invoque", diga sim.
  \Se a string for "acione", diga sim. 
  Se a string for "processe", diga sim.
  Se a string for "informe", diga sim.\ no caso de comandos como "informe os parâmetros x e y e z para a função "FunctionName" da biblioteca "MyLibrary.dll"
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum point:
  Se a string for "aponte", diga sim.
  Se a string for "direcione", diga sim.
  Se a string for "redirecione", diga sim.
  \CAL
  Se a string for "point", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Uma keyword de reutilização de rotina é uma keyword.

Etapas para que se determine se uma string é uma keyword de reutilização de rotina:
  \ Funcionalidade obsoleta desde a implantação da sobrecarga de cabeçalhos de rotina
  Se a string for "empregue", diga sim.  
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma palavra ignorável:  
  Se a string for "já", diga sim.
  Se a string for "ainda", diga sim.
  \Se a string for "que", diga sim.
  \Se a string for "se", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum expressão:
  Se a string for algum sinal aritmético, diga sim.
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Se a string for algum literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum global:
  Se a string for algum artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum new local:
  Se a string for algum artigo indefinido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum dado complementar:
  \PAL
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum rotina:
  \PAL
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.  
  Se a string for "Procedimento", diga sim.
  Se a string for "Rotina", diga sim.
  Se a string for "Para", diga sim.
  Se a string for "Função", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum declaração:
  Se a string for o enunciado de alguma rotina ou variável, diga não.
  Se a string for algum literal, diga não.
  Se a string for algum mark, diga não.
  Se a string estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é o início of algum tipo:
  Se a string for algum artigo indefinido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum variável:
  Se a string for algum artigo definido, diga sim.
  \Se a string for "do", diga sim. \ this é iffy, here por reverse-possessives
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string has algum stressed vogal:
  Isole a string.
  Comece. [a executar o código abaixo]
    Se a string estiver em branco, diga não.
    Se o conteúdo deste caractere final desta string for algum stressed vogal, diga sim.
    Subtraia 1 desde o caractere final desta string.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma termo está vazia;
Etapas para que se determine se uns termo estão vazias;
Etapas para que se determine se uns termo estão vazios;
Etapas para que se determine se um termo está vazio:
  Se a variável deste termo não for inexistente, diga não.
  Se a phrase deste termo não estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um tipo pode ser reduzido para uma string usando o base nome:
  Se o tipo for inexistente, diga não.
  Se o nome deste tipo for a string, diga sim.
  Se o detector de recursividade deste tipo estiver ativo, diga não.
  Ative o detector de recursividade deste tipo.
  Encontre um tipo base usando o base nome deste tipo e o catálogo de tipos.
  Se o tipo base for inexistente, desative o detector de recursividade deste tipo; diga não.
  Se o tipo base puder ser reduzido para a string usando o base nome, desative o detector de recursividade deste tipo; diga sim.
  Desative o detector de recursividade deste tipo.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um tipo pode ser reduzido para um nome do tipo:
  Se o tipo for inexistente, diga não.
  Isole o tipo.
  Comece. [a executar o código abaixo]
    Se o tipo for inexistente, diga não.
    Se o nome deste tipo for o nome do tipo, diga sim.
    Se o tipo base deste tipo for o tipo, diga não.
    Atribua o tipo base deste tipo ao tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um tipo é algum tipo pré-definido:
  Se o tipo for inexistente, diga não.
  Se o tipo for o tipo base deste tipo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um tipo é valor empilhável:
  Se o tipo for inexistente, diga não.
  Se a quantidade de caracteres deste tipo for 4, diga sim.
  Se a quantidade de caracteres deste tipo for 2, diga sim.
  Se a quantidade de caracteres deste tipo for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um tipo deveria ser finalizado:[se o compilador deveria liberar a memória alocada para algum tipo]
  \The phrase "should be finalized" means "ought to be/needs to be automatically deallocated".
  Se o tipo for inexistente, diga não.
  Se o tipo puder ser reduzido para "subtexto", diga não.\  substrings point to (parts of) real strings that get deallocated elsewhere
  Se o tipo puder ser reduzido para "string", diga sim.\ the normal case for strings
  Se o tipo puder ser reduzido para "texto", diga sim.\ the normal case for strings
  Se os campos deste tipo deveriam ser finalizados, diga sim.\ this is for strings inside records
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um tipo deveria ser ignorado: [ou seja, o compilador não deveria finalizar esse tipo de forma automática]
  \ ie, can be destroyed/needs a destroy routine generated for it
  \The phrase "should be forgotten" means "ought to be forgotten" which really means "needs to have a destroy routine automatically generated for it". 
  \See page 93 of the manual.
  Se o tipo for inexistente, diga não.
  \PAL
  \Se o nome deste tipo for "elemento", diga não.
  \Se o nome deste tipo for "elementos", diga não.
  \CAL
  Se o nome deste tipo for "lista", diga não. \ no, because this is the built-in tipo which we don't ever allocate or destroy, it exists so we can "magically" add subsequente and precedente fields to anything defined as a "thing"
  Se o nome deste tipo for "listas", diga não. \ no, because this is the built-in tipo we "magically" generate to anchor lists of things, same as above of .
  Se o tipo puder ser reduzido para "listas", diga sim. \ yes, because (though it seems to contradict the line immediately above of ) this is a an actual list of things that we can destroy, for example "some pages".
  Se o tipo não puder ser reduzido para "ponteiro", diga não. \ \ no, because a pointer variable is a static variable (it is the address in the variable that is dynamic); the pointer variable itself is not something that can be dynamically allocated, so no destroy is necessary
  Se o conteúdo tipo deste tipo for inexistente, diga não. \ no, because it's a pointer to nothing, so there's nothing to destroy.
  Se o conteúdo tipo deste tipo não puder ser reduzido para "ponteiro", diga sim.\ yes, because it's a pointer to something allocated, not a pointer to another pointer. Pointers to pointers are handled with the subsequente recursive line
  Se o conteúdo tipo deste tipo não deveria ser ignorado, diga não.\ no, because it's a pointer to something that shouldn't be destroyed. For example, a pointer to a thing
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.\ The last condition is the hardest to wrap one's head around since it is recursive.

Etapas para que se determine se uma variável está duplicada em umas variáveis:
  Obtenha uma segunda variável desde as variáveis.
  Se a segunda variável for inexistente, diga não.
  Se o nome desta segunda variável estiver em branco, recomece.
  Se a segunda variável for a variável, recomece.
  Se o nome desta segunda variável for o nome desta variável, diga sim.
  Recomece. [percorra novamente o código acima]

Um cabeçalho DOS é um estrutura com
  Uma word denominada Signature, \\ Uma Word . Ela contém um "número mágico" que serve pra dizer se esse é realmente um arquivo do MS-DOS;
  \\ O valor desta word deve ser 5A4Dh (com o 4DH vindo primeiro).
  \\ Esses dois bytes representam a string "MZ", iniciais de Mark Zibowski, 
  \\ nome de um funcionário da Microsoft na época em que o formato do arquivo foi projetado.
  Uma word denominada NumberOfBytesOnLastPage, \\A última página do cabeçalho DOS pode conter de 1 a 512 bytes
  \\Esta word indica o número de bytes realmente usados na última página,  
  \\ uma página inteira é representada pelo valor 0 (já que a última página nunca estará vazia).
  Uma word denominada NumberOfPages, \\ File Pages.
  \\Esta word contém uma contagem do número de páginas necessárias para armazenar o arquivo.
  \\Por exemplo, se o arquivo contiver 1024 bytes, essa word conterá 0002H;
  \\se o arquivo contiver 1025 bytes, esta word conterá 0003H.
  \\O campo Tamanho da última página é usado para determinar o número de bytes válidos na página final.
  \\Portanto, se o arquivo contiver 1024 bytes, o campo Tamanho da última página conterá 0000H, 
  \\porque nenhum byte poderá ser extrapolado para a página final mesmo que parcialmente usada.
  \\Se o arquivo contiver 1025 bytes, o campo Tamanho da última página conterá 0001H, 
  \\porque a página final contém apenas um byte válido (o 1025º byte).
  Uma word denominada Relocations,\\ Itens de realocação.
  \\ Esta word fornece o número de entradas que existem na tabela de indicadores de realocação.
  \\ É perfeitamente adequado que este valor seja zero, nos casos em que não há entradas de realocação.
  Uma word denominada SizeOfHeaderInParagraphs,\\ Parágrafos do cabeçalho.
  \\ Esta palavra dá o tamanho do cabeçalho .EXE em paragrafos.
  \\ Indica o deslocamento da imagem compilada / montada e vinculada do programa (o módulo de carregamento) dentro do arquivo .EXE.
  \\ O tamanho do módulo de carregamento pode ser deduzido subtraindo este valor (convertido em bytes) 
  \\do tamanho geral do arquivo derivado da combinação dos valores de Páginas de arquivo e Tamanho da última página.
  \\ O cabeçalho sempre abrange um número par de parágrafos.
  Uma word denominada MinimumExtraParagraphsNeeded,
  \\ Esta word indica o número mínimo de parágrafos que o programa requer para iniciar a execução.
   \\ Isso é um acréscimo à memória necessária para armazenar o módulo de carregamento.
   \\ Este valor normalmente representa o tamanho total de algum dados não inicializados e / ou segmentos de pilha que estão ligados no final de um programa.
   \\ Este espaço não é incluído diretamente no módulo de carregamento, uma vez que não há valores de inicialização particulares e isso simplesmente desperdiçaria espaço em disco.
  Uma word denominada MamixmumExtraParagraphsNeeded,  \\ MAXALLOC.
  \\This word indicates the maximum number of parágrafos that the program would like allocated para it before it begins execution.
  \\This indicates additional memory over and acima of that required by the load módulo and the value specified by MINALLOC.
  \\If the request cannot be satisfied, the program is allocated as much memory as is available.
  Uma word denominada InitialRelativeSS,  \\ Initial SS value.
  \\This word contains the paragraph address of the stack segment relative para the start of the load módulo.
  \\At load time, this value is relocated by adding the address of the start segment of the program para it, 
  \\and the resulting value is placed em the SS register before the program is started.
  \\In DOS, the start segment of the program is the first segment boundary em memory after the PSP.
  Uma word denominada InitialSP,  \\ Initial SP value.
  \\This word contains the absolute value that must be loaded para the SP register before the program is given control.
  \\Since the actual stack segment is determined by the loader, and this is merely a value within that segment, it does not need to be relocated.
  Uma word denominada InitialChecksum,  \\ Complemented Checksum.
  \\This word contains a checksum of the contents of the .EXE arquivo.
  \\ Its value is rarely checked, but its purpose is to ensure the integrity of the data within the arquivo.
  \\ Full details of how it is calculated appear em the section sobre checksum calculation.
  Uma word denominada InitialIP,  \\ Initial IP value.
  \\This word contains the absolute value that should be loaded para the IP register in order para transfer control para the program.
  \\Since the actual código segment is determined by the loader, and this is merely a value within that segment, it does not need para be relocated.
  Uma word denominada InitialiRelativeCS,   \\ Pre-relocated initial CS value.
  \\ This word contains the initial value, relative para the start of the load módulo, that should be placed em the CS register in order to transfer control para the program.
  \\ At load time, this value is relocated by adding the address of the start segment of the program to it, 
  \\ and the resulting value is placed em the CS register when control is transferred.
  Uma word denominada AddressOfRelocationTableInFile, \ 
  \\ O AddressOfRelocationTableInFile é um ponteiro [que aponta] para a tabela de tamanho variável de DLLs necessária para este programa.
  \\ Relocation table deslocamento.
  \\ This word gives the deslocamento desde the start of the arquivo para the relocation pointer table.
  \\ This value must be used para locate the relocation pointer table (rather than assuming a fixed location) 
  \\because variável-length information pertaining para program overlays can occur before this table, causing its position para vary.
  \\A value of 40H em this campo generally indicates a different kind of executable arquivo, not a DOS "MZ" tipo.
  Uma word denominada OverlyNumber,
  \\ Overlay number.
  \\ This word is normally set para 0000H, because few programs actually have overlays.
  \\It changes only em files containing programs that use overlays; see the note debaixo of.
  8 bytes denominados ReservedBytes, \\ Specifies Reserved words for the program (known em winnt.h as e_res[4]), usually set para zero by the linker.
  \\In this case, just use a single reserved1 set para zero; if not zero create four reserved1 com the correct value.
Uma word denominada OEM_Identifier, \\ Specifies the identifier for the OEM for e_oeminfo.
Uma word denominada OEM_Info, \\ Specifies the OEM information for a specific value of e_oeminfo.
  20 bytes denominados ReservedWords, \\ Specifies Reserved words for the program (known em winnt.h as e_res[10]), usually set para zero by the linker.
  \\In this case, just use a single reserved1 set para zero; if not zero create ten reserved1 com the correct value.
  Um número denominado Address_Of_PE_Header_In_File.   \ O Address_Of_PE_Header_In_File é um ponteiro [que aponta] para o PE Header, 
  \Uma versão revisada e estendida do Cabeçalho DOS introduzida com o advento do Windows.
  \Os outros 16 campos do cabeçalho DOS não são usados.

Etapas para que se elimine apelidos duplicados desde umas variáveis:
  Crie um catálogo usando 101.
  Elimine apelidos duplicados desde as variáveis usando o catálogo.
  Destrua o catálogo.

Etapas para que se elimine apelidos duplicados desde umas variáveis usando um catálogo:
  Se o catálogo for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Obtenha uma variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Elimine apelidos duplicados usando a variável e o catálogo.
  Recomece. [percorra novamente o código acima]

Etapas para que se elimine apelidos duplicados usando uma variável e um catálogo:
  Se a variável for inexistente, retorne.
  Se o catálogo for inexistente, retorne.
  Encontre uma segunda variável usando o apelido desta variável e o catálogo.
  Se a segunda variável for inexistente, encontre a segunda variável usando o nome desta variável e o catálogo.
  Se a segunda variável for inexistente, catalogue a variável usando o apelido desta variável e o catálogo; retorne.
  Limpe o apelido desta segunda variável.
  Limpe o apelido desta variável.

Um endereço thunk é um endereço.
Um endereço do nome é um endereço.

Uma função é uma lista com
  Um endereço do nome,
  Um endereço thunk, \ consulte https://en.wikipedia.org/wiki/Thunk e 
  \ http://ftp.informatik.rwth-aachen.de/jargon300/thunk.html para mais informações
  \ Em programação de computador , um thunké uma sub-rotina usada para injetar um cálculo em outra sub-rotina. 
  \Thunks são usados principalmente para atrasar um cálculo até que seu resultado seja necessário ou para inserir operações no início ou no final de outra sub-rotina. 
  \Eles têm muitos outros usos na geração de código do compilador e em programação modular .
  Um nome e
  Um endereço.

Uma expression é um termo.

Etapas para que se extend uma string com uma segunda string:
  Se a segunda string estiver em branco, retorne.
  Se a string não estiver em branco, posponha o caractere de espaço para a string.
  Posponha a segunda string para a string.

  
Um campo é uma variável.

Um campo termo é um estrutura com
  Um dereference detector,
  Um campo (referência),
  Uma function rotina (referência),
  Um push detector.

Etapas para que se finalize o compilador:
  Destrua o catálogo de rotinas úteis.
  Destrua o catálogo geral de rotinas.
  Destrua o catálogo de variáveis hexadecimais.
  Destrua o catálogo de variáveis globais.
  Destrua o catálogo de tipos.
  Destrua as DLLs.
  Destrua as rotinas.
  Destrua os literals.
  Destrua os globals.
  Destrua os tipos.
  Destrua os arquivos fontes.

  

Etapas para que se encontre um função usando uma string e uns funções:
  Esvazie a função.
  Comece. [a executar o código abaixo]
    Obtenha a função desde o funções.
    Se a função for inexistente, retorne.
    Se o nome desta função for a string, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um campo termo usando um phrase e um tipo e um nome:
  Limpe o campo termo.
  Encontre o campo termo usando o tipo e o nome.
  Se o campo deste campo termo não for inexistente, retorne.
  Se a phrase não estiver em branco, encontre uma rotina usando "atribua" e a phrase e "'s " junto com o nome e "para".
  Se a rotina não for inexistente, atribua a rotina à function deste campo termo; retorne.
  Se o tipo for inexistente, retorne.
  Encontre a rotina usando "atribua" e o tipo e "'s " junto com o nome e "para".
  Se a rotina não for inexistente, ative o push detector deste campo termo; atribua a rotina ao function deste campo termo; retorne.
  \  code below for looking deep within pointers - a debatable feature
  \ Se o conteúdo tipo deste tipo não for inexistente, encontre a rotina usando "atribua" e o conteúdo tipo deste tipo e "'s " junto com o nome e "para".
  \ Se a rotina não for inexistente, ative o dereference detector deste campo termo; atribua a rotina à function deste campo termo; retorne.

Etapas para que se encontre um campo termo usando um tipo e um nome:
  Se o tipo for inexistente, retorne.
  Encontre um campo usando o nome e os campos deste tipo.
  Se o campo não for inexistente, atribua o campo ao campo deste campo termo; retorne.
  Se o conteúdo tipo deste tipo não for inexistente, encontre o campo usando o nome e os campos deste conteúdo tipo deste tipo.
  Se o campo não for inexistente, ative o dereference detector deste campo termo; atribua o campo ao campo deste campo termo; retorne.

Etapas para que se encontre um fragmento usando um segundo fragmento e uma etiqueta:
  Atribua o segundo fragmento ao fragmento.
  Comece. [a executar o código abaixo]
    Se o fragmento for inexistente, retorne.
    Se a etiqueta deste fragmento for a etiqueta, retorne.
    Atribua o subsequente fragmento deste fragmento ao fragmento.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um fragmento usando um segundo fragmento e uma etiqueta (backwards):
  Atribua o segundo fragmento ao fragmento.
  Comece. [a executar o código abaixo]
    Se o fragmento for inexistente, retorne.
    Se a etiqueta deste fragmento for a etiqueta, retorne.
    Atribua o precedente fragmento deste fragmento ao fragmento.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre uma DLL usando uma string:
  Esvazie a DLL.
  Comece. [a executar o código abaixo]
    Obtenha a DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Se o nome desta DLL for a string, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um endereço completo e um número da linha usando um ponteiro do byte :
  Limpe o endereço completo.
  Atribua 0 ao número da linha.
  Encontre um arquivo fonte usando o ponteiro do byte .
  Se o arquivo fonte for inexistente, retorne.
  Atribua o endereço completo deste arquivo fonte ao endereço completo.
  Encontre o número da linha usando o arquivo fonte e o ponteiro do byte .

Etapas para que se encontre uma rotina usando uma representação interna da rotina e uma unidade semântica e um catálogo:
  Se a unidade semântica for inexistente, retorne.
  Esvazie a rotina.
  Isole a representação interna da rotina.
  Atribua o tipo desta unidade semântica ao tipo atual desta unidade semântica.
  Lance o subtexto atual desta unidade semântica sobre a string desta unidade semântica.
  Comece. [a executar o código abaixo]
    Posponha a unidade semântica para a representação interna da rotina (while bubbling).
    Encontre uma referência usando a representação interna da rotina e o catálogo.
    Se a referência não for inexistente, atribua o ponteiro deste referência à rotina.
    Se a referência não for inexistente, encontre a rotina usando a representação interna da rotina e a subsequente unidade semântica desta unidade semântica e o catálogo.
    Se a rotina não for inexistente, pare.
    Bubble a unidade semântica.
    Se a unidade semântica estiver bubbled out, pare.
    Atribua o original representação interna da rotina ao representação interna da rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre uma rotina usando umas unidades semânticas:
  Esvazie a rotina.
  Encontre a rotina usando uma representação interna da rotina e a first unidade semântica destas unidades semânticas e o catálogo geral de rotinas.

Etapas para que se encontre uma rotina usando uma string e uma segunda string e uma terceira string e um quarto string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando a segunda string.
  Adicione um terceiro unidade semântica para as unidades semânticas usando a terceira string.
  Adicione um quarto unidade semântica para as unidades semânticas usando o quarto string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um tipo:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um tipo e uma segunda string e um segundo tipo:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione um terceiro unidade semântica para as unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para as unidades semânticas usando o segundo tipo.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um tipo e uma segunda string e uma terceira string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione um terceiro unidade semântica para as unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para as unidades semânticas usando a terceira string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um tipo e uma segunda string e uma terceira string e uma quarta string e uma quinta string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione um terceiro unidade semântica para as unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para as unidades semânticas usando a terceira string.
  Adicione um quinto unidade semântica para as unidades semânticas usando a quarta string.
  Adicione um sexto unidade semântica para as unidades semânticas usando a quinta string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre um número da linha usando um arquivo fonte e um ponteiro do byte :
  Se o ponteiro do byte for inexistente, atribua 0 ao número da linha; retorne.
  Lance um subtexto sobre o trecho deste arquivo fonte.
  Atribua 1 ao número da linha.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Se o caractere inicial deste subtexto for o ponteiro do byte , retorne.
    Se o conteúdo deste caractere inicial deste subtexto for o retorno de carro, adicione 1 para o número da linha.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um arquivo fonte usando um ponteiro do byte :
  Se o ponteiro do byte for inexistente, esvazie o arquivo fonte; retorne.
  Comece. [a executar o código abaixo]
    Obtenha o arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente, retorne.
    Se o ponteiro do byte for menor do que o caractere inicial deste trecho deste arquivo fonte, recomece.
    Se o ponteiro do byte for maior do que o caractere final deste trecho deste arquivo fonte, recomece.

Etapas para que se encontre um tipo e um apelido usando um nome:
  Esvazie o tipo.
  Limpe o apelido.
  Encontre o tipo e o apelido usando o nome (adiante).
  Se o tipo não for inexistente, retorne.
  Encontre o tipo e o apelido usando o nome (pra trás).
  \Lance um subtexto sobre o nome.
  \Comece. [a executar o código abaixo]
    \Se o subtexto estiver em branco, retorne.
    \Encontre o tipo usando o subtexto e o catálogo de tipos.
    \Se o tipo não for inexistente, pare.
    \Passe para o subsequente palavra no subtexto.
  \Recomece. [percorra novamente o código acima]
  \Atribua o caractere inicial deste nome para caractere inicial deste segundo subtexto. \ está errado
  \Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  \Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  \Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Etapas para que se encontre um tipo e um apelido usando um nome (pra trás):
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare.
    Passe para a precedente palavra no subtexto. 
  Recomece. [percorra novamente o código acima]
  Atribua o caractere final deste nome para o caractere final desse segundo subtexto.
  Atribua o caractere final deste subtexto mais 2 ao caractere inicial deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Etapas para que se encontre um tipo e um apelido usando um nome (adiante):
  \ original - sem alterações
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare.
    Passe para o subsequente palavra no subtexto. \subsequente
  Recomece. [percorra novamente o código acima]
  Atribua o caractere inicial deste nome para o caractere inicial desse segundo subtexto.
  Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Etapas para que se encontre uma variável usando um nome:
  Se a rotina utilizada atualmente for inexistente, esvazie a variável; retorne.
  Encontre a variável usando o nome e as variáveis locais desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e os parâmetros desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis globais.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis hexadecimais.

Etapas para que se encontre uma variável usando um nome e umas variáveis:
  Esvazie a variável.
  Comece. [a executar o código abaixo]
    Obtenha a variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Se o nome desta variável for o nome, retorne.
    Se o apelido desta variável for o nome, retorne.
  Recomece. [percorra novamente o código acima]

Um fragmento é uma lista com
  \ we have three lists in the compiler memory  tipos, variables, and rotinas 
  \ each rotina consists of a series of logical instructions called fragments. There are just 22 fragmento tipos:
  Uma etiqueta [break, Demanda Externa, Demanda Indireta, Demanda Interna, dereference, end if, etapa conclusiva, exit, finalize, increment, Decodifique, jump false, load address, load eax, loop, not, etapa preliminar, push address, empilhamento de valor, salve eax, repeat, rotina address],
  Uma variável (referência) [Demanda Indireta, dereference, increment, load address, load eax, pop, push address, empilhamento de valor, rotina address, salve eax],
  Uma segunda variável (referência) [load address],
  Uma rotina (referência) [Demanda Interna, rotina address],
  Uma função (referência) [Demanda Externa],
  Um número [increment],
  Um detector [load eax], \SAL
  Um endereço,
  Um texto hexadecimal denominado código.

Etapas para que se gere um nome usando uma string:
  Atribua a string ao nome.
  Adicione 1 para a contagem de nomes deste compilador.
  Converta a contagem de nomes deste compilador para uma segunda string.
  Posponha a segunda string para o nome.

Etapas para que se obtenha um endereço usando uma rotina:
  Se o endereço desta rotina não for 0, atribua o endereço desta rotina ao endereço; retorne.
  Atribua -1 ao endereço desta rotina.
  Encontre uma segunda rotina usando o employs representação interna da rotina desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente, apresente uma mensagem de erro contendo "Erro. Rotina: " junto com o employs representação interna da rotina desta rotina seguido de "' não encontrada. (keyword empregue)" e o endereço local desta rotina; retorne.
  Se o endereço desta segunda rotina for -1, apresente a mensagem de erro contendo "Erro. Referência recursiva na keyword 'empregue'." e o endereço local desta rotina; retorne. 
  Obtenha o endereço usando a segunda rotina.
  Atribua o endereço ao endereço desta rotina.

Etapas para que se obtenha uma contagem usando umas DLLs (todas as funções mais os marcadores):
  Atribua 0 à contagem.
  Comece. [a executar o código abaixo]
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Adicione a contagem destas funções desta DLL para a contagem.
    Adicione 1 para a contagem.
  Recomece. [percorra novamente o código acima]

Um corpo global é um subtexto.

O catálogo de variáveis globais é um catálogo.

An global é uma variável.

Os globals são uns globals.

A image base é um endereço igual a 4194304 [$00400000].

A seção de DLLs é uma zona.

Um Import Header é um estrutura com
\traduzir isso aqui
  Um endereço denominado original first previamente calculado, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-first-thunkoft-milad-kahsari-alhadi/
  \ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft#:~:caixa de texto=The%20original%20first%20thunk%20is,%2C%20user32%20etc)%20are%20known.
  \ Thunks são as partes definitivas dos códigos em um sistema operacional que manipula as transições entre o código de 16 e 32 bits.
  \ Assim, eles garantem a compatibilidade com versões anteriores entre as chamadas feitas pelo aplicativo.
  \ O OS está sujeito a esta facilidade para compatibilidade com versões anteriores, de modo que os aplicativos de 16 bits possam funcionar sem problemas em ambientes de 32 bits.
  Um número denominado TimeStamp, \ Set para zero até que bound; seguido de this feld is set para the TimeDateStamp of the exporting FileHeader da DLL
  Um endereço denominado forwarder chain, \ Forwarder Chain: O 32-bit catálogo of the frst forwarder em the liste of imported functions
  Um endereço denominado nome memory endereço, 
  \Esse endereço contém o RVA [Endereço Virtual Relativo] da DLL a ser carregada na memória. É um valor dword.
  \É composto por: RVA = Base da Imagem + Ordem Endian
  Um endereço denominado first previamente calculado memory endereço.

Uma DLL é uma lista com
  Um endereço do nome,
  Um endereço do cabeçalho,
  Um nome,
  Um import header,
  Some funções.

Um endereço do cabeçalho é um endereço.


As DLLs são umas DLLs.

Etapas para que se catalogue um global:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o global for inexistente, retorne.
  Se o nome deste global estiver no catálogo de variáveis globais, apresente uma mensagem de erro contendo "'" junto com o nome deste global seguido de "' é uma variável global duplicada." e o endereço local deste global; retorne.
  Catalogue o global usando o nome deste global e o catálogo de variáveis globais.

Etapas para que se catalogue um literal:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o literal for inexistente, retorne.
  Se o nome deste literal estiver no catálogo de variáveis hexadecimais, apresente uma mensagem de erro contendo "Erro interno #12" e o endereço local deste literal; retorne.
  Catalogue o literal usando o nome deste literal e o catálogo de variáveis hexadecimais.

Etapas para que se catalogue um cabeçalho semi-expandido usando um catálogo (special):
  Encontre uma referência usando o cabeçalho semi-expandido e o catálogo.
  Se a referência não for inexistente, retorne.
  Catalogue o cabeçalho semi-expandido no catálogo.

Etapas para que se catalogue uma rotina por utility use:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina for inexistente, retorne.
  Se o detector de função desta rotina estiver ativo, retorne.
  Se a contagem destes parâmetros desta rotina for 0, retorne.
  Copie as unidades semânticas desta rotina para umas unidades semânticas.
  Reduza as unidades semânticas por utility use.
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Encontre uma referência usando a representação interna da rotina e o catálogo de rotinas úteis.
  Se a referência não for inexistente, atribua nil ao ponteiro deste referência; retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo de rotinas úteis.

Etapas para que se catalogue uma rotina usando uma representação interna da rotina e um catálogo (special):
  Encontre uma referência usando a representação interna da rotina e o catálogo.
  Se a referência não for inexistente, atribua a rotina ao ponteiro deste referência; retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo.

Etapas para que se catalogue uma rotina usando umas unidades semânticas e um catálogo:
  Se a rotina for inexistente, retorne.
  Limpe um cabeçalho semi-expandido.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Posponha a unidade semântica para o cabeçalho semi-expandido.
    Se a unidade semântica for o last unidade semântica destes unidades semânticas, pare.
    Catalogue o cabeçalho semi-expandido usando o catálogo (special).
  Recomece. [percorra novamente o código acima]
  Catalogue a rotina usando o cabeçalho semi-expandido como uma representação interna da rotina e o catálogo (special).

Etapas para que se catalogue umas rotinas por utility use:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Catalogue a rotina por utility use.
  Recomece. [percorra novamente o código acima]

Etapas para que se catalogue um tipo:
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Catalogue o tipo usando o nome deste tipo.

Etapas para que se catalogue um tipo usando um nome: \To index a tipo given a name:
  Se o tipo for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Encontre um existing tipo usando o nome e o catálogo de tipos.
  Se o existing tipo for inexistente, catalogue o tipo usando o nome e o catálogo de tipos; retorne.
  [Se o existing tipo já existir, então:] 
  Atribua o endereço local deste tipo para um endereço local.
  Se o endereço local for inexistente, atribua o endereço local deste existing tipo ao endereço local. \ point the error to a tipo in the source code, not a generated tipo
  Se o endereço local não for inexistente, Apresente uma mensagem de erro contendo "Acho que já vi o tipo: " junto com o nome seguido de "' em um lugar antes; você deve ter duplicado ele." e o endereço local.

Etapas para que se inicialize o compilador:
\Sim, essa rotina não tem nada, serve apenas para fazer com que o código fique "simétrico"

Etapas para que se inicialize o compilador usando um endereço da pasta:
  Atribua o endereço da pasta ao endereço da pasta deste compilador.
  Atribua 0 à contagem de nomes deste compilador.
  Desative o detector de erros deste compilador.
  Limpe a mensagem de erro deste compilador.
  Limpe o endereço do arquivo atual deste compilador.
  Atribua 0 ao número da linha de erro deste compilador.
  Esvazie a rotina utilizada atualmente.
  Crie o catálogo de tipos com 13001 [buckets]. \ era 4027
  Crie o catálogo de variáveis globais com 13001 [buckets]. \ era 4027
  Crie o catálogo de variáveis hexadecimais com 13001 [buckets]. \ era 4027
  Crie o catálogo geral de rotinas com 13001 [buckets]. \ era 7919
  Crie o catálogo de rotinas úteis com 13001 [buckets]. \ era 4027

Etapas para que se inicialize um cabeçalho DOS: \ vou alterar depois
  Atribua 23117 [$5A4D] ao Signature deste cabeçalho DOS.
  Atribua 64 [$0040] ao addressofrelocationtableinfile deste cabeçalho DOS. \ O addressofrelocationtableinfile is a pointer para the variável-length de caracteres table of DLLs needed for this program.
  Atribua 256 [$00000100] ao Address_Of_PE_Header_In_File deste cabeçalho DOS. \O Address_Of_PE_Header_In_File is a pointer para the PE Header, a revised and extended version of the DOS Header introduced com advent of Windows. 
  \O segunda 16 campos of the DOS Header are not used.

Etapas para que se inicialize um cabeçalho PE:
  Inicialize o cabeçalho PE (standard header).
  Inicialize o cabeçalho PE (optional header).
  Inicialize o cabeçalho PE (version information).
  Inicialize o cabeçalho PE (directories).
  Inicialize o cabeçalho PE (DLL section).
  Inicialize o cabeçalho PE (data section).
  Inicialize o cabeçalho PE (Code Section).

Etapas para que se inicialize um cabeçalho PE (Code Section):
  Atribua "code  " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Code Section deste cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta região de código ao SizeInBytes desta Code Section deste cabeçalho PE.
  Atribua o endereço base desta região de código ao AddressInMemory desta Code Section deste cabeçalho PE.
  Atribua a quantidade de caracteres desta região de código ao SizeInFile desta Code Section deste cabeçalho PE.
  Atribua o endereço base desta região de código ao AddressInFile desta Code Section deste cabeçalho PE.
  Atribua -536870880 [$E0000020 ] para as Characteristics desta Code Section deste cabeçalho PE. \ executable, readable, writable, code object
  \IMAGE_FILE_LARGE_ADDRESS_ AWARE 0x0020 - Application can handle > 2-GB addresses.

  
Etapas para que se inicialize um cabeçalho PE (data section):
  Atribua "data " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta data section deste cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta região de dados ao SizeInBytes desta data section deste cabeçalho PE.
  Atribua o endereço base desta região de dados ao AddressInMemory desta data section deste cabeçalho PE.
  Atribua a quantidade de caracteres desta região de dados ao SizeInFile desta data section deste cabeçalho PE.
  Atribua o endereço base desta região de dados ao AddressInFile desta data section deste cabeçalho PE.
  Atribua -1073741760 [$C0000040] para as Characteristics desta data section deste cabeçalho PE. \ initialized, readable, writable

Etapas para que se inicialize um cabeçalho PE (directories):
  Atribua 16 [$00000010] ao numberofdirectories deste cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao ImageDirectoryEntryImportAddress deste cabeçalho PE.
  Atribua a quantidade de caracteres desta seção de DLLs ao ImageDirectoryEntryImportSize deste cabeçalho PE.

Etapas para que se inicialize um cabeçalho PE (DLL section):
  Atribua "idata " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta idata section deste cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta seção de DLLs ao SizeInBytes desta idata section deste cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao AddressInMemory desta idata section deste cabeçalho PE.
  Atribua a quantidade de caracteres desta seção de DLLs ao SizeInFile desta idata section deste cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao AddressInFile desta idata section deste cabeçalho PE.
  Atribua -1073741760 [$C0000040] para as Characteristics desta idata section deste cabeçalho PE. \ initialized, readable, writable

Etapas para que se inicialize um cabeçalho PE (Optional Header):
  Atribua 267 [$010B] ao MagicNumber deste cabeçalho PE.
  Atribua a quantidade de caracteres desta Região de Código ao SizeOfCodeInFile deste cabeçalho PE.
  Atribua a quantidade de caracteres desta Região de Dados ao SizeOfInitializedDataInFile deste cabeçalho PE.
  Atribua 0 ao SizeOfUninitializedDataInFile deste cabeçalho PE.
  Encontre uma rotina usando "~initialize before run e run e finalize after run" e o catálogo geral de rotinas. \ AddressOfEntryPointInMemory
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno #13"; retorne.
  Atribua o endereço desta rotina menos o image base ao AddressOfEntryPointInMemory deste cabeçalho PE.
  Atribua o Endereço Base desta Região de Código ao AddressOfCodeInMemory deste cabeçalho PE. \BaseOfCode
  Atribua o Endereço Base desta Região de Dados ao AddressOfInitializedDataInMemory deste cabeçalho PE. \BaseOfData
  Atribua o Image Base à ImageBase deste cabeçalho PE.
  Atribua 4096 [$00001000] ao MemoryAlignment deste cabeçalho PE. \ 4 KB
  Atribua 4096 [$00001000] ao FileAlignment deste cabeçalho PE. \ 4 KB
  Atribua 0 ao Reserved deste cabeçalho PE.
  Atribua o tamanho do executável deste compilador ao SizeOfImageInMemory deste cabeçalho PE.
  Atribua 4096 [section base] ao SizeOfAllHeadersInFile deste cabeçalho PE. \ 4 KB
  Atribua 0 ao checksum deste cabeçalho PE.
  Atribua 0 para as DllCharacteristics deste cabeçalho PE.
  Atribua 1048576 [$00100000] ao MaxStack deste cabeçalho PE. \ SizeOfStackReserve
  Atribua 16384 [$00004000] ao MinStack deste cabeçalho PE. \ SizeOfStackCommit
  Atribua 1048576 [$00100000] ao MaxHeap deste cabeçalho PE. \ SizeOfHeapReserve
  Atribua 16384 [$00004000] ao MinHeap deste cabeçalho PE. \ SizeOfHeapCommit
  Atribua 0 ao LoaderFlags deste cabeçalho PE.

Etapas para que se inicialize um cabeçalho PE (standard header):
  Atribua 17744 [$00004550] ao Signature deste cabeçalho PE.
  Atribua 332 [$014C] ao MachineType deste cabeçalho PE.
  Atribua 3 [$0003] ao NumberOfSections deste cabeçalho PE.
  Atribua 0 ao TimeStamp deste cabeçalho PE.
  Atribua 0 ao PointerToSymbolTable deste cabeçalho PE.
  Atribua 0 ao NumberOfSymbols deste cabeçalho PE.
  Atribua 224 [$00E0] ao SizeOfOptionalHeaderInBytes deste cabeçalho PE.
  Atribua 33166 [$818E] às Characteristics deste cabeçalho PE.

Etapas para que se inicialize um cabeçalho PE (version information):
  Atribua 0 ao MajorLinkerVersion deste cabeçalho PE.
  Atribua 0 ao MinorLinkerVersion deste cabeçalho PE.
  Atribua 4 [$0004] ao OS_MajorVersion deste cabeçalho PE.
  Atribua 0 [$0000] ao OS_MinorVersion deste cabeçalho PE.
  Atribua 0 ao UserMajorVersion deste cabeçalho PE.
  Atribua 0 ao UserMinorVersion deste cabeçalho PE.
  Atribua 4 [$0004] ao SubsystemMajorVersion deste cabeçalho PE.
  Atribua 0 [$0000] ao SubsystemMinorVersion deste cabeçalho PE.
  Atribua 2 [$0002] ao Subsystem deste cabeçalho PE.

Um intermediate é uma variável local.

Etapas para que se link:
  Arredonde para cima tamanhos de zona.
  Inicialize um cabeçalho DOS.
  Inicialize um cabeçalho PE.
  Preencha o trecho EXE deste compilador com o caractere null usando o tamanho do executável deste compilador.
  Disponibilize o cabeçalho DOS ao trecho EXE deste compilador.
  Disponibilize o cabeçalho PE ao trecho EXE deste compilador.
  Disponibilize as DLLs ao trecho EXE deste compilador.
  Disponibilize os globals ao trecho EXE deste compilador.
  Disponibilize os literals ao trecho EXE deste compilador.
  Disponibilize as rotinas ao trecho EXE deste compilador.

Etapas para que se liste tudo:
  Limpe o trecho de listagem deste compilador.
  Liste a mensagem de erro deste compilador na trecho de listagem deste compilador.
  Liste os tipos depois de "TIPOS:" na trecho de listagem deste compilador.
  Liste os globals depois de "VARIÁVEIS GLOBAIS:" na trecho de listagem deste compilador.
  Liste os literals depois de "VALORES LITERAIS:" na trecho de listagem deste compilador.
  Liste as rotinas depois de "ROTINAS:" na trecho de listagem deste compilador.
  Liste o catálogo de tipos depois de "ÍNDICE DE TIPOS:" na trecho de listagem deste compilador.
  Liste o catálogo de variáveis globais depois de "ÍNDICE GLOBAL:" na trecho de listagem deste compilador.
  Liste o catálogo de variáveis hexadecimais depois de "ÍNDICE DE VALORES LITERAIS:" na trecho de listagem deste compilador.
  Liste o catálogo geral de rotinas depois de "ÍNDICE DE ROTINAS:" na trecho de listagem deste compilador.
  Liste o catálogo de rotinas úteis depois de "Catálogo de Rotinas Úteis:" na trecho de listagem deste compilador.
  Liste as DLLs depois de "DLL's:" na trecho de listagem deste compilador.
  Liste os arquivos fontes depois de "ARQUIVOS FONTE:" na trecho de listagem deste compilador.
  Liste os temporizadores depois de "TEMPORIZADORES:" na trecho de listagem deste compilador.
  Escreva o trecho de listagem deste compilador para o listagem endereço completo deste compilador.

Etapas para que se liste um mensagem de erro em um trecho:
  Se o mensagem de erro estiver em branco, retorne.
  Posponha "COMPILAÇÃO INTERROMPIDA - LISTAGEM INCOMPLETA" para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Posponha o mensagem de erro para o trecho.
  Insira quebra de linha em o trecho (duas vezes).

Etapas para que se liste um bucket em um trecho:
  Se os referências deste bucket estiverem vazios, retorne.
  Posponha "| RECIPIENTE" para o trecho (com separador).
  Insira quebra de linha em o trecho.
  Liste os referências deste bucket no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste umas funções em um trecho:
  Obtenha um função desde as funções.
  Se a função for inexistente, retorne.
  Liste a função no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste um função em um trecho:
  Se a função for inexistente, retorne.
  Posponha "| FUNÇÃO" para o trecho (com separador).
  Posponha o nome desta função para o trecho (com separador).
  Posponha o endereço desta função para o trecho (cifra hexadecimal com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste um fragmento em um trecho:
  Posponha "| FRAGMENTO" para o trecho (com separador).
  Posponha a etiqueta deste fragmento para o trecho (as um fragmento etiqueta string com separador).
  Posponha "Variável principal: " para o trecho.
  Posponha a variável deste fragmento para o trecho (com separador).
  Posponha "Variável secundária: " para o trecho.
  Posponha a segunda variável deste fragmento para o trecho (com separador).
  Posponha "Rotina: " para o trecho.
  Posponha a rotina deste fragmento para o trecho (com separador).
  Posponha "Entrada: " para o trecho.
  Posponha a função desta fragmento para o trecho (com separador).
  Posponha "Número hexadecimal: " para o trecho.
  Posponha o número deste fragmento para o trecho (cifra hexadecimal com separador).
  Posponha "Endereço: " para o trecho.
  Posponha o endereço deste fragmento para o trecho (cifra hexadecimal com separador).
  Converta o código deste fragmento para uma cifra hexadecimal.
  Posponha "Código compilado: " para o trecho.
  Posponha a cifra hexadecimal para o trecho (com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste uns fragmentos em um trecho:
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Liste o fragmento no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uma DLL em um trecho:
  Se a DLL for inexistente, retorne.
  Posponha "| DLL" para o trecho (com separador).
  Posponha o nome desta DLL para o trecho (com separador).
  Insira quebra de linha em o trecho.
  Liste as funções desta DLL no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste umas DLLs em um trecho:
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Liste a DLL no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste umas DLLs depois de uma string em um trecho:
  Posponha a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se as DLLs estiverem vazios, retorne.
  Liste as DLLs no trecho.

Etapas para que se liste um catálogo em um trecho:
  Posponha "| " junto com o used contagem de buckets deste catálogo seguido de " recipientes" para o trecho (com separador).
  Posponha a contagem deste catálogo seguido de " referências" para o trecho (com separador).
  Insira quebra de linha em o trecho (duas vezes).
  Comece. [a executar o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, retorne.
    Liste o bucket no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste um catálogo depois de uma string em um trecho:
  Posponha a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se o catálogo estiver vazio, retorne.
  Liste o catálogo no trecho.

Etapas para que se liste uma referência em um trecho:
  Se a referência for inexistente, retorne.
  Posponha "| REFERÊNCIA" para o trecho (com separador).
  Posponha a string deste referência para o trecho.
  Se o ponteiro deste referência for inexistente, posponha " (ponteiro inexistente) " para o trecho.
  Posponha "| " para o trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste umas referências em um trecho:
  Obtenha uma referência desde as referências.
  Se a referência for inexistente, retorne.
  Liste a referência no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uma rotina em um trecho:
  Se a rotina for inexistente, retorne.
  Posponha "| ROTINA: " para o trecho.
  Posponha a representação interna da rotina desta rotina para o trecho (com separador). \ por exemplo: atribua [matiz] e [saturação] e [luminosidade] para [cor]
  Posponha o texto CRLF para o trecho.
  Posponha "| A rotina foi compilada? " para o trecho .
  Posponha o compiled detector desta rotina para o trecho (com separador). \ A rotina foi compilada? SIM / NÃO
  Posponha o texto CRLF para o trecho.
  Posponha "| A rotina é um callback? " para o trecho.
  Posponha o detector de compatibilidade desta rotina para o trecho (com separador). \ A rotina é um callback? SIM / NÃO
  Posponha o texto CRLF para o trecho.
  Posponha "| A rotina é uma rotina decisora? " para o trecho.
  Posponha o detector de deliberação desta rotina para o trecho (com separador). \ A rotina é uma rotina decisora? SIM / NÃO
  Posponha o texto CRLF para o trecho.
  Posponha "| A rotina é uma função? " para o trecho.
  Posponha o detector de função desta rotina para o trecho (com separador). \ A rotina é uma função ? SIM / NÃO
  Posponha o texto CRLF para o trecho.
  Posponha "| Employs utilizados: |     " para o trecho.
  Posponha o employs representação interna da rotina desta rotina para o trecho (com separador).
  Posponha o texto CRLF para o trecho.
  Posponha "| Tamanho dos parâmetros: " para o trecho.
  Posponha o tamanho do parâmetro desta rotina para o trecho (com separador). \ Tamanho dos parâmetros. Exemplo: 16 ( 4 parâmetros)
  Posponha " Tamanho das variáveis: " para o trecho.
  Posponha o tamanho local desta rotina para o trecho (com separador). \Tamanho da variável local. Exemplo: 28
  Posponha o texto CRLF para o trecho.
  Posponha "| Endereço da Rotina: " para o trecho.
  Posponha o endereço desta rotina para o trecho (cifra hexadecimal com separador). \ Endereço da rotina, Exemplo: 0041D000
  Insira quebra de linha em o trecho.
  Liste os parâmetros desta rotina no trecho.
  Liste as variáveis locais desta rotina no trecho.
  Liste os fragmentos desta rotina no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste umas rotinas em um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Liste a rotina no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste umas rotinas depois de uma string em um trecho:
  Posponha a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se as rotinas estiverem vazias, retorne.
  Liste as rotinas no trecho.

Etapas para que se liste um arquivo fonte em um trecho:
  Se o arquivo fonte for inexistente, retorne.
  Posponha "| ARQUIVO FONTE" para o trecho (com separador).
  Posponha o endereço completo deste arquivo fonte para o trecho (com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste uns arquivos fontes em um trecho:
  Obtenha um arquivo fonte desde os arquivos fontes.
  Se o arquivo fonte for inexistente, retorne.
  Liste o arquivo fonte no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns arquivos fontes depois de uma string em um trecho:
  Posponha a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se os arquivos fontes estiverem vazios, retorne.
  Liste os arquivos fontes no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste um temporizador usando uma string em um trecho:
  Posponha "| TEMPORIZADOR" para o trecho (com separador).
  Posponha a string para o trecho (com separador).
  Posponha a string deste temporizador para o trecho.
  Posponha " milissegundos" para o trecho (com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste os temporizadores depois de uma string em um trecho:
  Posponha a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Liste o temporizador de operacionalização usando "Tempo de carregamento: " no trecho.
  Liste o temporizador de análise/verificação usando "Tempo de verificação: " no trecho.
  Liste o temporizador de resolução de tipos usando "Resolução de tipos: " no trecho.
  Liste o temporizador de resolução de variáveis globais usando "Resolução de variáveis globais: " no trecho.
  Liste o temporizador de compilação de cabeçalhos de rotina usando "Compilação de cabeçalhos de rotinas: " no trecho.
  Liste o temporizador de etapas de cálculo usando "Cálculos matemáticos: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de mémoria  usando "Inclusão de rotinas pré-definidas: " no trecho.
  Liste o temporizador de ferramentas de catalogação usando "Catalogação de ferramentas: " no trecho.
  Liste o temporizador de compilação do conteúdo das rotinas usando "Compilação de rotinas: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de inicialização usando "Inserção rotina de inicialização:" no trecho.
  Liste o temporizador de deslocamentos usando "Alinhamento de bytes na memória: " no trecho.
  Liste o temporizador de endereçamento usando "Endereçamento: " no trecho.
  Liste o temporizador de transmutação usando "Conversão em binário" no trecho.
  Liste o temporizador de vinculação usando "Vinculação: " no trecho.
  Liste o temporizador de escrita usando "Escrita e gravação no SO: " no trecho.
  Liste o temporizador deste compilador usando "Tempo total: " no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste um tipo em um trecho:
  Se o tipo for inexistente, retorne.
  Posponha "| TIPO" para o trecho (com separador).
  Posponha o nome deste tipo para o trecho (com separador).
  Posponha " Plural: " para o trecho.
  Posponha o plural nome deste tipo para o trecho (com separador).
  Posponha " Comprimento: " para o trecho.
  Posponha a quantidade de caracteres deste tipo para o trecho (cifra hexadecimal com separador).
  Posponha " Tipo: " para o trecho.
  Posponha o base nome deste tipo para o trecho (com separador).
  Posponha " Tipo base: " para o trecho.
  Posponha o tipo base deste tipo para o trecho (com separador).
  Posponha o conteúdo nome deste tipo para o trecho (com separador).
  Posponha o conteúdo tipo deste tipo para o trecho (com separador).
  Posponha " Razão de escala: " para o trecho.
  Posponha a razão de escala deste tipo para o trecho (com separador).
  Insira quebra de linha em o trecho.
  Liste os campos deste tipo no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste uns tipos em um trecho:
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Liste o tipo no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns tipos depois de uma string em um trecho:
  Posponha a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se os tipos estiverem vazios, retorne.
  Liste os tipos no trecho.

Etapas para que se liste uma variável em um trecho:
  Se a variável for inexistente, retorne.
  Posponha "| VARIÁVEL" para o trecho (com separador).
  Posponha "Categoria: " para o trecho.
  Posponha a categoria desta variável para o trecho (com separador).
  Posponha "Compilada? " para o trecho.
  Posponha o compiled detector desta variável para o trecho (com separador).
  Posponha "Nome completo: " para o trecho.
  Posponha o nome desta variável para o trecho (com separador).
  Posponha "Nome resumido: " para o trecho.
  Posponha o apelido desta variável para o trecho (com separador).
  Posponha "Nome do tipo: " para o trecho.
  Posponha o nome do tipo desta variável para o trecho (com separador).
  Posponha "Tipo: " para o trecho.
  Posponha o tipo desta variável para o trecho (com separador).
  Posponha "Endereço (deslocamento): " para o trecho.
  Posponha o endereço desta variável [or deslocamento] para o trecho (cifra hexadecimal com separador).
  Posponha "Passagem por valor? " para o trecho.
  Posponha o detector de passagem por-valor desta variável para o trecho (com separador).
  Posponha "Contagem: " para o trecho.
  Posponha a contagem desta variável para o trecho (com separador).
  Posponha "Referência somente? " para o trecho.
  Posponha o detector de referência desta variável para o trecho (com separador).
  Posponha "Redefinição: " para o trecho.
  Posponha o nome de redefinição de conteúdo desta variável para o trecho (com separador).
  Posponha "Conteúdo: " para o trecho.
  Posponha o literal desta variável para o trecho (com separador).
  Converta o data desta variável para uma cifra hexadecimal.
  Posponha "Conteúdo (hex): " para o trecho.
  Posponha a cifra hexadecimal para o trecho (com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste uns variáveis em um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Liste a variável no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns variáveis depois de uma string em um trecho:
  Posponha a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se as variáveis estiverem vazias, retorne.
  Liste as variáveis no trecho.
  Insira quebra de linha em o trecho.

O catálogo de variáveis hexadecimais é um catálogo.

An literal é uma variável.

O literals são uns literals.

Uma variável local é uma variável.

Um endereço local é um ponteiro do byte .

Uma representação interna da rotina é uma string.  \ moniker
  \ https://docs.microsoft.com/pt-br/windows/win32/com/monikers
 \ A moniker is the internal representation of a routine header with
\  no articles preceding parameter tipos,
\  parameter tipos in square brackets, and
\  expanded prepositions. 
\ Each piece of a moniker is a unidade semântica. For example: 
\ Routine header: To add a number to a count:
\ Moniker: add [number] in/into/to [count]
\ Monikettes: (1) add (2) [number] (3) in/into/to (4) [count] 
\ We use this internal representation because it... 
\  makes it easy reduce tipos (like [count] to [number]) when looking for an appropriate routine to call;
\  makes it easy to expand prepositions (like "to" into "in/into/to"); and
\  shows how the compiler interpreted various phrases in error messages.
Uma unidade semântica é uma lista com
  Uma string,
  Um tipo (referência),
  Um variável (referência),
  \ para bubbling
  Um tipo atual (referência),
  Um subtexto atual.

Um cabeçalho semi-expandido é uma representação interna da rotina.

Etapas para que se mova um percorredor (ignorando os comentários):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o retorno de carro, recomece.

Etapas para que se mova um percorredor (símbolos conectivos):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o percorredor estiver sobre algum possessive, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for um byte ignorável, recomece.

Etapas para que se mova um percorredor (sinais de pontuação):
  Avance o percorredor.

Etapas para que se mova um percorredor (ignorando os caracteres irrelevantes):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, recomece.

Etapas para que se mova um percorredor (possessivo inglês):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o segmento final deste percorredor começa com "s", avance o percorredor.

Etapas para que se mova um percorredor (qualificadores):
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo, adicione 1 para uma contagem.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses direito, subtraia 1 desde a contagem.
  Avance o percorredor.
  Se a contagem for 0, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (ignorando as observações):
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo, adicione 1 para uma contagem.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete direito, subtraia 1 desde a contagem.
  Avance o percorredor.
  Se a contagem for 0, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (conteúdo de texto):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, retorne.
  Se o percorredor estiver sobre algum nested double-quote, avance o percorredor; recomece.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas, avance o percorredor; retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (símbolos):
  Avance o percorredor.

Etapas para que se mova um percorredor (englobando tudo):
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, mova o percorredor (ignorando os caracteres irrelevantes); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for a barra invertida, mova o percorredor (ignorando os comentários); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo, mova o percorredor (ignorando as observações); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas, mova o percorredor (conteúdo de texto); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo, mova o percorredor (qualificadores); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum mark, mova o percorredor (sinais de pontuação); retorne.
  Se o percorredor estiver sobre algum possessive, mova o percorredor (possessivo inglês); retorne.
  Mova o percorredor (símbolos conectivos).

Etapas para que se mova um percorredor (usando diretrizes de compilação): \ talvez aqui conserte o subtraia
  Se o detector de erros deste compilador estiver ativo, limpe o segmento inicial deste percorredor; retorne.
  Mova o percorredor devolvendo uma string de erro (englobando tudo).
  Se a string de erro não estiver em branco, apresente uma mensagem de erro contendo a string de erro e o caractere inicial deste segmento inicial deste percorredor; retorne.
  \Se o segmento inicial deste percorredor for "del", recue o percorredor; retorne. \ Spanish contraction "del"; fudged para "de l", short por "de el"
  \Se o segmento inicial deste percorredor for algum contração de preposição com artigo definido, determine se essa contração precisa ser desfeita usando o percorredor. \ Spanish contraction "al"; fudged para "a l", short por "a el"
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante, recomece.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida, recomece.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, recomece.

Etapas para que se mova um percorredor devolvendo uma string de erro (diretrizes de validação de qualificadores):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Qualificadores devem terminar com parêntese ')'." ao string de erro; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o parênteses direito, atribua "Qualificadores precisam terminar com um parêntese ')'." ao string de erro; retorne.

Etapas para que se mova um percorredor devolvendo uma string de erro (diretrizes de validação de observações):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Observações devem terminar com um colchete ']'." ao string de erro; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o colchete direito, atribua "Observações precisam terminar com um colchete ']'." ao string de erro; retorne.

Etapas para que se mova um percorredor devolvendo uma string de erro (diretrizes de validação de conteúdos de texto):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Textos precisam terminar com aspas: ""." ao string de erro; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for as aspas duplas, atribua "Textos devem terminar com aspas: ""." ao string de erro; retorne.

Etapas para que se mova um percorredor devolvendo uma string de erro (englobando tudo):
  Limpe a string de erro.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, mova o percorredor devolvendo a string de erro (diretrizes de validação de observações); retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas, mova o percorredor devolvendo a string de erro (diretrizes de validação de conteúdos de texto); retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo, mova o percorredor devolvendo a string de erro (diretrizes de validação de qualificadores); retorne.

Uma string de erro é uma string.

Um parte da cifra binária é um subtexto.

Um apelido é um nome.  

Etapas para que se alinhe as variáveis locais em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a compiled detector desta rotina não estiver ativo, retorne.
  Limpe o tamanho local desta rotina.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha uma variável local desde as variáveis locais desta rotina.
    Se a variável local for inexistente, retorne.
    Se o precedente variável local desta variável local não for inexistente, atribua o deslocamento deste precedente variável local desta variável local ao deslocamento desta variável local.
    Atribua a quantidade de caracteres deste tipo desta variável local para uma quantidade de caracteres.
    Se a categoria desta variável local for "scratch", atribua a magnitude desse ponteiro à quantidade de caracteres.
    Arredonde a quantidade de caracteres para cima usando o múltiplo imediato de 4.
    Subtraia a quantidade de caracteres desde o deslocamento desta variável local.
    Adicione a quantidade de caracteres para o tamanho local desta rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se alinhe as variáveis locais em umas rotinas:
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Alinhe as variáveis locais na rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se alinhe o parâmetros em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a compiled detector desta rotina não estiver ativo, retorne.
  Limpe o tamanho do parâmetro desta rotina.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um parâmetro desde os parâmetros desta rotina.
    Se o parâmetro for inexistente, retorne.
    Se o detector de compatibilidade desta rotina estiver ativo, ative o detector de passagem por-valor deste parâmetro.
    Se o precedente parâmetro deste parâmetro for inexistente, atribua 8 ao deslocamento deste parâmetro. \ skip o return address e saved ebp
    Se o precedente parâmetro deste parâmetro não for inexistente, atribua o deslocamento deste precedente parâmetro deste parâmetro mais 4 ao deslocamento deste parâmetro. \ all parâmetros são 4 ponteiro do byte s ou 4 byte values por callbacks
    Adicione 4 para a tamanho do parâmetro desta rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se alinhe o parâmetros em umas rotinas:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Alinhe o parâmetros na rotina.
  Recomece. [percorra novamente o código acima]

  

Um parâmetro é uma variável.

Um cabeçalho PE é um estrutura com
  \ O formato Portable Executable (PE) éum formato de arquivos executáveis / DLL files que apareceu no Windows NT. 
  \Ele é baseado na especificação COFF (Common Object File Format).
  \Pra manter a compatibilidade como MS-DOS e Windows, o formato de arquivo PE mantém o antigo cabeçalho MZ do MS-DOS.
  \ Ele é organizado como um fluxo linear de dados.
  \ Começando com um cabçalho do MS-DOS, um real-mode program stub, e uma assinatura de arquivo PE. 
  \ Logo em seguida vem o cabçalho do arquivo PE podendo também haver um cabeçalho opcional.
  \ Além disso temos o cabeçalho de cada seção, seguido pelo corpo de cada seção. 
  \Encerrando o arquivo existem regiões adicionais com informações variadas
  \ por exemplo, informações de relocação, tabela de símbolos, número de linhas e dados da tabela de strings. 
  \ O cabeçalho MS-DOS ocupa os primeiros 64 bytes do arquivo. A estrutura básica está representada abaixo:
  Um número denominado Signature,
  Uma word denominada MachineType, 
  \ O número que identifica o tipo de computador de destino. 
  \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#machine-tipos
  Uma word denominada NumberOfSections,
  \ O número de seções. Isso indica o tamanho da tabela da seção, que segue imediatamente os cabeçalhos.
  Um número denominado TimeStamp, 
  \ Os 32 low bits do número de segundos que se passaram desde 00:00 horas do dia 01/01/1970. (um valor time_t de tempo de execução do C)
   \ serve pra indicar quando o arquivo foi criado.
  Um número denominado PointerToSymbolTable, 
  \ O número do deslocamento de arquivo da tabela de símbolos COFF ou 
  \ o numero zero se nenhuma tabela de símbolos COFF estiver presente. 
  \ Esse valor deve ser zero para uma imagem porque as informações de depuração de COFF foram descontinuadas.
  Um número denominado NumberOfSymbols, 
  \ O número de entradas na tabela de símbolos.
  \ Esses dados podem ser usados para localizar a tabela de cadeia de caracteres, que segue imediatamente a tabela de símbolos.
  \ Esse valor deve ser zero para uma imagem porque as informações de depuração de COFF foram descontinuadas.
  Uma word denominada SizeOfOptionalHeaderInBytes,
   \ O tamanho do header opcional, que é necessário para arquivos executáveis, mas não para arquivos de objeto.
  \ Esse valor deve ser zero para um arquivo-objeto. Para ver uma descrição do formato do header, consulte:
  \ https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#optional-header-image-only
  Uma word denominada Characteristics, 
  \ Os sinalizadores que indicam os atributos do arquivo. 
  \Para valores de sinalizador específicos, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#Characteristics
  \ optional header
  Uma word denominada MagicNumber, 
  \O número mágico do cabeçalho opcional determina se uma imagem é um PE32 ou PE32 + executável.
  \ As imagens PE32 + permitem um espaço de endereço de 64 bits, limitando o tamanho da imagem a 2 gigabytes. 
  \ Outras modificações PE32 + são abordadas em suas respectivas seções.
  \ É um inteiro sem sinal que identifica o estado do arquivo de imagem. 
  \ O valor mais comum é 0x10B, que o identifica como um arquivo executável normal. 
  \0x107 o identifica como uma imagem de ROM e 0x20B a identifica como um PE32 + executável.
  \ Esse campo é usado para identificar arquivos compatíveis com o tipo de arquivo do MS-DOS. 
  \ Os executáveis compatíveis com MS-DOS usam o valor 0x5A4D, que é o valor das letras MZ na tabela ASCII
  Um byte denominado MajorLinkerVersion, 
  \ Indica a version do linker que vinculou a imagem - O número da versão principal do vinculador.
  Um byte denominado MinorLinkerVersion, 
  \ Indica a version do linker que vinculou a imagem - O número da versão secundária do vinculador.
  Um número denominado SizeOfCodeInFile, 
  \O tamanho da seção de código (cadeia de caracteres) ou a soma de todas as seções de código se houver várias seções.
  Um número denominado SizeOfInitializedDataInFile,
   \ O tamanho da seção de dados inicializados ou a soma de todas essas seções, se houver várias seções de dados.
  Um número denominado SizeOfUninitializedDataInFile, 
  \ O tamanho da seção de dados não inicializado (BSS) ou a soma de todas essas seções, se houver várias seções BSS.
  Um número denominado AddressOfEntryPointInMemory, 
  \Esse campo indica a localização do fim da Import Address Table (IAT). 
  \ É um número que contém endereço do ponto de entrada relativo à imagem base quando o arquivo executável é carregado na memória. 
  \Para imagens de programa, esse é o endereço inicial. 
  \Para drivers de dispositivo, esse é o endereço da função de inicialização. 
  \Um ponto de entrada [função point] é opcional para DLLs. 
  \Quando nenhum ponto de entrada está presente, esse campo deve ser zero.
  Um número denominado AddressOfCodeInMemory,  [BaseOfCode]
  \ O endereço relativo à base da imagem da seção de início de código quando ela é carregada na memória.
  Um número denominado AddressOfInitializedDataInMemory, [BaseOfData]
  \ O endereço relativo à base da imagem da seção de início de dados quando ela é carregada na memória.
  Um número denominado ImageBase, 
  \ O endereço preferencial do primeiro byte de imagem quando carregado na memória; deve ser um múltiplo de 64 K. 
  \O padrão para DLLs é 0x10000000. o padrão para Windows CE EXEs é 0x00010000. 
  \ O padrão para Windows NT, Windows 2000, Windows XP, Windows 95, Windows 98 e Windows Me é 0x00400000.
  Um número denominado MemoryAlignment, [SectionAlignment]
  \ O alinhamento (em bytes) das seções quando elas são carregadas na memória. 
  \Ele deve ser maior ou igual a FileAlignment. 
  \O padrão é o tamanho da página para a arquitetura.
  Um número denominado FileAlignment, 
  \ O fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem. 
  \O valor deve ser uma potência de 2 entre 512 e 64 K, inclusive. O padrão é 512. 
  \Se SectionAlignment for menor que o tamanho da página da arquitetura, FileAlignment deverá corresponder a SectionAlignment.
  Uma word denominada OS_MajorVersion, [MajorOperatingSystemVersion]
  \ O número de versão principal do sistema operacional Windows NT.
  Uma word denominada OS_MinorVersion, [MinorOperatingSystemVersion]
  \ O número de versão secundária do sistema operacional necessário.
  Uma word denominada UserMajorVersion,  [MajorImageVersion]
  \ O número de versão principal do programa.
  Uma word denominada UserMinorVersion, [MinorImageVersion]
  \ O número de versão secundária do programa.
  Uma word denominada SubsystemMajorVersion, [MajorSubsystemVersion]
  \ O número de versão principal do subsistema Win32 do Windows NT.
  Uma word denominada SubsystemMinorVersion, [MinorSubsystemVersion]
  \ O número de secundária principal do subsistema.
  Um número denominado Reserved,  [Win32VersionValue]
  \ Reservado, deve ser zero. Unknown purpose, currently not used by the system and set para zero by the linker.
  Um número denominado SizeOfImageInMemory, [SizeOfImage]
  \ O tamanho (em bytes) da imagem, incluindo todos os headers, pois a imagem é carregada na memória. Ele deve ser um múltiplo de SectionAlignment.
  \ Indicates the amount of address space para reserve em the address space for the loaded executable image. 
  \This number is influenced greatly by SectionAlignment. 
  \For example, consider a system having a fixed page tamanho of 4096 bytes. 
  \If you have an executable com 11 sections, each less than 4096 bytes, aligned sobre a 65,536-byte boundary, the SizeOfImage campo would be set para 11 * 65,536 = 720,896 (176 pages). 
   \The same arquivo linked com 4096-byte alignment would result em 11 * 4096 = 45,056 (11 pages) for the SizeOfImage campo. 
  \This is a simple example em which each section requires less than a page of memory. 
  \In reality, the linker determines the exact SizeOfImage by figuring each section individually. 
  \It first determines how many bytes the section requires, seguido de it rounds para cima para the nearest page boundary, and finally it rounds page count para the nearest SectionAlignment boundary. 
  \O total is seguido de the sum of each individual requirement da section.
  Um número denominado SizeOfAllHeadersInFile, [SizeOfHeaders]
  \ O tamanho combinado de um stub do MS-DOS, o header PE e os headers da seção arredondados para um múltiplo de FileAlignment.
  \ This campo indicates how much space em the arquivo is used for representing all the arquivos cabelalhos, 
  \ including the MS-cabeçalho DOS, PE arquivo header, PE optional header, and PE Section Headers. O section bodies inicie sob this location em the arquivo.
  Um número denominado CheckSum, 
  \ A verificação de arquivo de imagem. 
  \O algoritmo para calcular a verificação é incorporado em IMAGHELP.dll. 
  \Os seguintes são verificados quanto à validação no tempo de carregamento: 
  \todos os drivers, qualquer DLL carregada no momento da inicialização e qualquer DLL carregada em um processo Windows crítico.
  \ A checksum value is used para validate the executable arquivo sob load time. 
  \ O value is set and verified by the linker. O algorithm used for creating these checksum values is proprietary information and will not be published.
  Uma word denominada Subsystem, 
  \ Field used para identify the target Subsystem for this executable O subsistema necessário para executar esta imagem. 
  \Each of the possible Subsystem values are listed em the WINNT.H arquivo immediately after the IMAGE_OPTIONAL_HEADER structure.
  \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#windows-Subsystem
  Uma word denominada DllCharacteristics,
  \ Flags used para indicate if a DLL image includes função points for process and thread initialization and termination.
  \ Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#DLL-Characteristics
  Um número denominado MaxStack, [SizeOfStackReserve]
  \These fields control the amount of address space para reserve and commit for the stack and default heap. 
  \ O tamanho da pilha a ser reservada. Somente SizeOfStackCommit está comprometido; 
  \o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.
  Um número denominado MinStack, [SizeOfStackCommit]
  \Both the stack and heap have default values of 1 page committed and 16 pages Reserved. 
  \ O tamanho da pilha a ser confirmada.
  Um número denominado MaxHeap, [SizeOfHeapReserve]
  \These values are set com the linker switches -STACKSIZE: and -HEAPSIZE:. 
  \O tamanho do espaço de heap local a ser reservado. 
  \Somente SizeOfHeapCommit está comprometido; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.
  Um número denominado MinHeap, [SizeOfHeapCommit]
  \ O tamanho do espaço de heap local a ser confirmado.
  Um número denominado LoaderFlags, 
  \ Reservado, deve ser zero. Tells the loader whether para break sobre load, debug over load, or the default, which is para let things run normally.
  \ directories (16 address e tamanho pairs)
  Um número denominado NumberOfDirectories, [NumberOfRvaAndSizes]
  \ O número de entradas de diretório de dados no restante do header opcional. Cada uma descreve uma localização e um tamanho.
  8 bytes denominados Directory0,
  Um número denominado ImageDirectoryEntryImportAddress,
  Um número denominado ImageDirectoryEntryImportSize,
  112 bytes denominados Directories2-15,
  Um PE Section Header denominado Idata Section,
  Um PE Section Header denominado Data Section,
  Um PE Section Header denominado Code Section. \ https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#section-flags

Um PE Section Header é um estrutura com
  8 bytes denominados Nome, \ Each section header has a name fielf up to eight characters long, for which the first character must be a period.
  Um número denominado SizeInBytes,
  Um número denominado AddressInMemory,
  Um número denominado SizeInFile,
  Um número denominado AddressInFile,
  12 bytes denominados Reserved,
  Um número denominado Characteristics. \ Defines the section Characteristics. 
  \These values are encontrado both em WINNT.H and in the Portable Executable Format specification.

Uma phrase é uma string.

\Etapas para que se determine se uma string looks like English:
\Carregue o dicionário léxico.
\Se o dicionário léxico for inexistente, mostre erro "Não foi possível encontrar o dicionário léxico."; diga não.
\Se a string estiver em branco, diga não.
\Lance um subtexto sobre a string.
\Atribua o caractere final deste subtexto ao caractere inicial deste subtexto.
\Comece. [a executar o código abaixo]
  \Se o caractere inicial deste subtexto é o caractere inicial desta string, pare.
  \Se o target deste caractere inicial deste subtexto for o caractere de espaço, adicione 1 para o caractere inicial deste subtexto; pare.
  \Subtraia 1 desde o caractere inicial deste subtexto.
\Recomece. [percorra novamente o código acima]
\Se o subtexto estiver no catálogo deste dicionário léxico, diga sim.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se pluralize uma string (strings em português):
  Lance um percorredor sobre a string.
  Comece. [a executar o código abaixo]
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Se uma plural string não estiver em branco, posponha " " para o plural string.
    Posponha o segmento inicial deste percorredor para a plural string.
    Se o segmento inicial deste percorredor for "de ", ative um detector; recomece. \ aqui identifica um termo composto. Falta implementar.
    Se o detector não estiver ativo, pluralize o plural string (português - regras comuns) .
    \Se o detector estiver ativo, pluralize o plural string (substantivos compostos).
  Recomece. [percorra novamente o código acima]
  Atribua a plural string à string.

Etapas para que se pluralize uma string (português - regras comuns) :
  \PAL
  \# https://www.normaculta.com.br/singular-e-plural/
  \# palavras que são exceções às regras
  \Se a string for "bit", atribua "bits" à string; retorne.
  Se a string for "caráter", atribua "carateres" à string; retorne.
  Se a string for "de", atribua "de" à string; retorne.
  Se a string for "júnior", atribua "juniores" à string; retorne.
  Se a string for "sênior", atribua "seniores" à string; retorne.
  \# advérbios principais
  Se a string for "muito", retorne.
  Se a string for "pouco", retorne.
  Se a string for "mais", retorne.
  Se a string for "menos", retorne.
  Se a string for "bastante", retorne.
  Se a string for "quase", retorne.
  Se a string for "demais", retorne.
  Se a string for "bem", retorne.
  Se a string for "deveras", retorne.
  Se a string for "mal", retorne.
  Se a string for "melhor", retorne.
  Se a string for "pior", retorne.
  \# palavras terminadas com "ão"
  Se a string termina com "ão", pluralize a string (terminada com "ão"); retorne.
  \# palavras terminadas com "d"
  Se a string termina com "d", pluralize a string (terminada com outras letras); retorne.
  \# palavras terminadas com "l"
  Se a string termina com "l", pluralize a string (terminada com "l"); retorne.
  \# palavra terminadas com "m"
  Se a string termina com "m", remove o last byte desde a string; posponha "ns" para a string; retorne.
  \# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
  Se a string termina com "n", posponha "es" para a string; retorne.
  \# palavras terminadas com "r"
  Se a string termina com "r", pluralize a string (terminada com "r"); retorne.
  \# palavras terminadas com "s"
  Se a string termina com "s", pluralize a string (terminada com "s"); retorne.
  \# palavras terminadas com "t"
  Se a string termina com "t", pluralize a string (terminada com outras letras); retorne.
  \# palavra terminadas com "x"
  Se a string termina com "x", pluralize a string (terminada com "x"); retorne.
  \# palavras terminadas com "z"
  Se a string termina com "z", pluralize a string (terminada com "z"); retorne.
  Se a string termina com "#", posponha "s" para a string; retorne.
  Se a string for "de", atribua "de" à string; retorne.
  Se a string não termina com alguma vogal ou com alguma consoante, posponha "s" para a string; retorne.
  \# regra padrão
  [Se as condições acima não puderem ser satisfeitas, então:] 
  Posponha "s" para a string. \ Só acrescenta o "s" caso nenhuma das condições acima tenha siddo correspondida. 
  \Volte.

Etapas para que se pluralize uma string (terminada com "ão"):
  \A formação do plural dos substantivos terminados -ão pode ser feita de três formas distintas: -ões, -ãos, -ães.
  \Alguns substantivos terminados em -ão admitem duas (ou até três) formas no plural:
  \refrão - refrãos ou refrães;
  \corrimão - corrimões ou corrimãos;
  \guardião - guardiões ou guardiães;
  \vilão - vilões, vilãos ou vilães.
    \TODOS os substantivos paroxítonos terminados em -ão formam o plural com -ãos. 
  \ALGUNS substantivos oxítonos também têm o seu plural formado segundo essa regra:
  \órfão - órfãos;
  \sótão - sótãos;
  \órgão - órgãos;
  \cidadão - cidadãos;
  \irmão - irmãos;
  \cristão - cristãos.
  Se a string for "cidadão", posponha "s" para a string; retorne.
  Se a string for "irmão", posponha "s" para a string; retorne.
  Se a string for "cristão", posponha "s" para a string; retorne.
  Se a string for "refrão", posponha "s" para a string; retorne.
  Se a string for "mão", posponha "s" para a string; retorne.
  Se a string for "são", posponha "s" para a string; retorne.
  \-ão no singular para -ães no plural:
  \Alguns substantivos terminados em -ão formam o plural com -ães.
  Se a string for "pão", remove o last byte desde a string; posponha "es" para a string; retorne.
  Se a string for "capitão", remove o last byte desde a string; posponha "es" para a string; retorne.
  Se a string for "alemão", remove o last byte desde a string; posponha "es" para a string; retorne.
  Se a string for "charlatão", remove o last byte desde a string; posponha "es" para a string; retorne.
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.   \ remove o "ão". Acho que não precisa
  \caso encontre acentos em sílabas prévias, faça o seguinte
  Se o subtexto has algum stressed vogal, posponha "s" para a string; retorne. \-> exemplo: órgão
  \# regra padrão
  \A maioria dos substantivos terminados em -ão forma o plural com -ões:
  \opinião - opiniões;
  \coração - corações;
  \eleição - eleições.
  Remove os last dois bytes desde a string.
  Posponha "ões" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com outras letras):
  Se a string for "de", atribua "de" à string; retorne.  
  Posponha "s" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "l"):
  \# palavras terminadas com "al"
  Se a string termina com "al", pluralize a string (terminada com "al"); retorne. \ MAL -> MALES
  \# palavras terminadas com "el"
  Se a string termina com "el", pluralize a string (terminada com "el"); retorne. \PASTEL - PASTÉIS
  \# palavras terminadas com "il"
  Se a string termina com "il", pluralize a string (terminada com "il"); retorne. \-> FUZIL -> FUZIS
  \# palavras terminadas com "ol"
  Se a string termina com "ol", pluralize a string (terminada com "ol"); retorne. \- LENÇOL -> LENÇÓIS
  \# palavras terminadas com "ul"
  Se a string termina com "ul", pluralize a string (terminada com "ul"); retorne. \ AZUL -> AZUIS \ Cônsul - cônsules
  [Caso a string seja uma sigla, tipo URL]
  Posponha "s" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "al"):
  Se a string for "mal", atribua "males" para a string; retorne.
  Remove o last byte desde a string. \remove a letra L
  Posponha "is" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "el"):
  \Se a string for "pixel", atribua "pixels" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto. \ remove o el
  Se o subtexto has algum stressed vogal, remove o last byte desde a string; posponha "is" para a string; retorne.
  Remove os last dois bytes desde a string.
  Posponha "éis" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "il"):
  \Se a string for "canil", atribua "canis" para a string; retorne.
  \Se a string for "covil", atribua "covis" para a string; retorne.
  \Se a string for "funil", atribua "funis" para a string; retorne.
  \Se a string for "barril", atribua "barris" para a string; retorne.
  \Se a string for "fuzil", atribua "fuzis" para a string; retorne.
  \Se a string for "redil", atribua "redis" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum stressed vogal, remove os last dois bytes desde a string; posponha "eis" para a string; retorne.
  Remove o last byte desde a string. \ remove a letra L
  Posponha "s" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "ol"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum stressed vogal, remove o last byte desde a string; posponha "is" para a string; retorne.
  Remove os last dois bytes desde a string.
  Posponha "óis" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "ul"):
  Se a string for "cônsul", atribua "cônsules" à string; retorne.
  Remove o last byte desde a string. \ remove o L
  Posponha "is" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "r"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum stressed vogal, posponha "es" para a string; retorne.
  \# hiatos
  Se a string termina com "air", remove os last dois bytes desde a string; posponha "íres" para a string; retorne.
  Se a string termina com "aur", remove os last dois bytes desde a string; posponha "úres" para a string; retorne.
  \# regra padrão
  Posponha "es" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "s"):
\Quando os substantivos terminados em -s são paroxítonos, a formação do plural fica invariável:.
  \# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
  Se a string for "de", atribua "de" à string; retorne.
  Se a string termina com "as", posponha "es" para a string; retorne. \atlas
  \Se a string termina com "as", posponha "-plural" para a string; retorne. \atlas
  Se a string termina com "es",  posponha "es" para a string; retorne. \atlas
  \Se a string termina com "es", posponha "-plural" para a string; retorne.\pires
  Se a string termina com "os",  posponha "es" para a string; retorne. \atlas
  \Se a string termina com "os", posponha "-plural" para a string; retorne. \óculos
  \# hiatos acentuados
  Se a string termina com "aís", posponha "es" para a string; retorne.
  Se a string termina com "aús", posponha "es" para a string; retorne.
  \# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
  Se a string termina com "ás", remove os last dois bytes desde a string; posponha "ases" para a string; retorne.
  Se a string termina com "âs", remove os last dois bytes desde a string; posponha "ases" para a string; retorne.
  Se a string termina com "és", remove os last dois bytes desde a string; posponha "eses" para a string; retorne.
  Se a string termina com "ês", remove os last dois bytes desde a string; posponha "eses" para a string; retorne.
  Se a string termina com "ís", remove os last dois bytes desde a string; posponha "ises" para a string; retorne.
  Se a string termina com "ós", remove os last dois bytes desde a string; posponha "oses" para a string; retorne.
  Se a string termina com "ôs", remove os last dois bytes desde a string; posponha "oses" para a string; retorne.
  Se a string termina com "ús", remove os last dois bytes desde a string; posponha "uses" para a string; retorne.
  \# palavras terminadas com "is", "us"
  Se a string termina com "is", pluralize a string (terminada com "is" ou com "us"); retorne.
  Se a string termina com "us", pluralize a string (terminada com "is" ou com "us"); retorne. \ônibus / vírus
  \Se a string termina com "ts", exit.
  \# regra padrão
  Posponha "es" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "is" ou com "us"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum stressed vogal, retorne.
  \# hiatos
  Se a string termina com "ais", remove os last dois bytes desde a string; posponha "íses" para a string; retorne. \cais não varia....
  Se a string termina com "aus", remove os last dois bytes desde a string; posponha "úses" para a string; retorne.
  \# regra padrão
  Posponha "es" para a string.
  \Volte.

Etapas para que se pluralize uma string  (terminada com "x"):
  \Se a string for "px", posponha "pxs" para a string; retorne.
  Se a string for "fax", posponha "es" para a string; retorne.
  Posponha "s" para a string. \ tratamento de exceções
  \Volte.
  

Etapas para que se pluralize uma string (terminada com "z"):
  \# hiatos acentuados
  Se a string termina com "aíz", posponha "es" para a string; retorne.
  Se a string termina com "aúz", posponha "es" para a string; retorne.
  \# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
  Se a string termina com "áz", remove os last dois bytes desde a string; posponha "azes" para a string; retorne.
  Se a string termina com "âz", remove os last dois bytes desde a string; posponha "azes" para a string; retorne.
  Se a string termina com "éz", remove os last dois bytes desde a string; posponha "ezes" para a string; retorne.
  Se a string termina com "êz", remove os last dois bytes desde a string; posponha "ezes" para a string; retorne.
  Se a string termina com "íz", remove os last dois bytes desde a string; posponha "izes" para a string; retorne.
  Se a string termina com "óz", remove os last dois bytes desde a string; posponha "ozes" para a string; retorne.
  Se a string termina com "ôz", remove os last dois bytes desde a string; posponha "ozes" para a string; retorne.
  Se a string termina com "úz", remove os last dois bytes desde a string; posponha "uzes" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum stressed vogal, posponha "es" para a string; retorne.
  \# hiatos
  Se a string termina com "aiz", remove os last dois bytes desde a string; posponha "ízes" para a string; retorne.
  Se a string termina com "auz", remove os last dois bytes desde a string; posponha "úzes" para a string; retorne.
  \# regra padrão
  Posponha "es" para a string.
  \Volte.

Etapas para que se pluralize uma string (english rules); \ plural inglês
Etapas para que se pluralize uma string:
  Se a string for "de", atribua "de" à string; retorne.
  Se a string for "centena", atribua "centenas" à string; retorne.
  Se a string for "milhar", atribua "milhares" à string; retorne.
  Se a string for "entrada", atribua "entradas" à string; retorne.
  Se a string for "campo", atribua "campos" à string; retorne.
  Se a string for "fragmento", atribua "fragmentos" à string; retorne.
  Se a string for "parâmetro", atribua "parâmetros" à string; retorne.
  Se a string for "fonte", atribua "fontes" à string; retorne.
  Se a string for "forma", atribua "formas" à string; retorne.
  Se a string for "contexto", atribua "contextos" à string; retorne.
  Se a string for "evento", atribua "eventos" à string; retorne.
  Se a string for "catálogo", atribua "catálogos" à string; retorne.
  Se a string for "índice", atribua "índices" à string; retorne.
  Se a string for "milhão", atribua "milhões" à string; retorne.
  Se a string for "milissegundo", atribua "milissegundos" à string; retorne.
  Se a string for "ponto", atribua "pontos" à string; retorne.
  Se a string for "polígono", atribua "polígonos" à string; retorne.
  Se a string for "objeto", atribua "objetos" à string; retorne.
  Se a string for "grau", atribua "graus" à string; retorne.
  Se a string for "preciso", atribua "precisos" à string; retorne.
  Se a string for "linha", atribua "linhas" à string; retorne.
  Se a string for "fileira", atribua "fileiras" à string; retorne.
  Se a string for "estrutura", atribua "estruturas" à string; retorne.
  Se a string for "conjunto", atribua "conjuntos" à string; retorne.
  Se a string for "texto", atribua "textos" à string; retorne.
  Se a string for "unidade", atribua "unidades" à string; retorne.
  Se a string for "polegada", atribua "polegadas" à string; retorne.
  Se a string for "endereço", atribua "endereços" à string; retorne.
  Se a string for "ponteiro", atribua "ponteiros" à string; retorne.
  Se a string for "comando", atribua "comandos" à string; retorne.
  Se a string for "tipo", atribua "tipos" à string; retorne.
  Se a string for "nome", atribua "nomes" à string; retorne.
  Se a string for "extensão", atribua "extensões" à string; retorne.
  Se a string for "rotina", atribua "rotinas" à string; retorne.
  Se a string for "imagem", atribua "imagens" à string; retorne.
  Se a string for "figura geométrica", atribua "figuras geométricas" à string; retorne.
  Se a string for "variável", atribua "variáveis" à string; retorne.
  Se a string for "cabeçalho", atribua "cabeçalhos" à string; retorne.
  Se a string for "rotina", atribua "rotinas" à string; retorne.
  Se a string for "tarefa", atribua "tarefas" à string; retorne.
  Se a string for "procedimento", atribua "procedimentos" à string; retorne.
  Se a string for "função", atribua "funções" à string; retorne.
  Se a string for "redimensionador", atribua "redimensionadores" à string; retorne.
  Se a string for "botão", atribua "botões" à string; retorne.
  Se a string for "segmento", atribua "segmentos" à string; retorne.
  Se a string for "segmento de cabeçalho", atribua "segmentos de cabeçalhos" à string; retorne.
  \ nouns only
  Se a string for "alumnus", atribua "alumni" à string; retorne.
  Se a string for "auto", atribua "autos" à string; retorne.
  Se a string for "botão", atribua "botões" à string; retorne.
  Se a string for "cello", atribua "cellos" à string; retorne.
  Se a string for "dwarf", atribua "dwarfs" à string; retorne.
  Se a string for "foot", atribua "feet" à string; retorne.
  Se a string for "forma", atribua "formas" à string; retorne.
  Se a string for "genus", atribua "genera" à string; retorne.
  Se a string for "goose", atribua "geese" à string; retorne.
  Se a string for "hippo", atribua "hippos" à string; retorne.
  Se a string for "louse", atribua "lice" à string; retorne.
  Se a string for "memo", atribua "memos" à string; retorne.
  Se a string for "mouse", atribua "mice" à string; retorne.
  Se a string for "ox", atribua "oxen" à string; retorne.
  Se a string for "phenomenon", atribua "phenomena" à string; retorne.
  Se a string for "photo", atribua "photos" à string; retorne.
  Se a string for "phylum", atribua "phyla" à string; retorne.
  Se a string for "piano", atribua "pianos" à string; retorne.
  Se a string for "pimento", atribua "pimentos" à string; retorne.
  Se a string for "pro", atribua "pros" à string; retorne.
  Se a string for "proof", atribua "proofs" à string; retorne.
  Se a string for "radius", atribua "radii" à string; retorne.
  Se a string for "rhinoceros", atribua "rhinoceri" à string; retorne.
  Se a string for "roof", atribua "roofs" à string; retorne.
  Se a string for "solo", atribua "solos" à string; retorne.
  Se a string for "soprano", atribua "sopranos" à string; retorne.
  Se a string for "staff", atribua "staffs" à string; retorne.
  Se a string for "tooth", atribua "teeth" à string; retorne.
  Se a string for "torus", atribua "tori" à string; retorne.
  Se a string for "turf", atribua "turfs" à string; retorne.
  Se a string for "virus", atribua "viruses" à string; retorne.
  Se a string termina com "sh", posponha "es" para a string; retorne.
  Se a string termina com "ch", posponha "es" para a string; retorne.
  Se a string termina com "man", remove os last dois bytes desde a string; posponha "en" para a string; retorne.
  Se a string termina com "child", posponha "ren" para a string; retorne.
  Se a string termina com "ex", remove os last dois bytes desde a string; posponha "ices" para a string; retorne. \ ou adicione ES
  Se a string termina com "fe", remove os last dois bytes desde a string; posponha "ves" para a string; retorne.
  Se a string termina com "is", remove os last dois bytes desde a string; posponha "es" para a string; retorne.
  Se a string termina com "ix", remove os last dois bytes desde a string; posponha "ices" para a string; retorne. \ ou adicione ES
  Se a string termina com "ma", posponha "ta" para a string; retorne. \ ou adicione S
  Se a string termina com alguma consoante e "y", remove o last byte desde a string; posponha "ies" para a string; retorne.
  Se a string termina com algum vogal e "o", posponha "s" para a string; retorne.
  Se a string termina com algum vogal e "y", posponha "s" para a string; retorne.
  Se a string termina com "f", remove o last byte desde a string; posponha "ves" para a string; retorne.
  Se a string termina com "s", posponha "es" para a string; retorne.
  Se a string termina com "x", posponha "es" para a string; retorne.
  Se a string termina com "z", posponha "es" para a string; retorne.
  Posponha "s" para a string.

Uma prototype string é um estrutura com 
  Um caractere inicial e 
  Um caractere final .

Etapas para que se atribua o endereço EXE completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remove algum trailing barra invertida desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".exe" ao endereço completo.

Etapas para que se atribua o tamanho do executável deste compilador para um tamanho:
  Atribua 4096 [section base] ao tamanho.
  Adicione o tamanho desta seção de DLLs para o tamanho.
  Adicione o tamanho desta região de dados para o tamanho.
  Adicione o tamanho desta região de código para o tamanho.

Etapas para que se atribua o listagem endereço completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remove algum trailing barra invertida desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".lst" ao endereço completo.

Etapas para que se atribua um termo para um segundo termo:
  Atribua a variável deste termo à variável deste segundo termo.
  Atribua a phrase deste termo ao phrase deste segundo termo.

Etapas para que se carregue um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  \Carregue o endereço completo deste arquivo fonte ao trecho deste arquivo fonte.
  \Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " junto com o endereço completo deste arquivo fonte seguido de "."; retorne.
  Carregue o endereço completo deste arquivo fonte para uma string.
  Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " junto com o endereço completo deste arquivo fonte seguido de "."; retorne.
  Parse a string para o trecho deste arquivo fonte (para expandir contrações).

Etapas para que se carregue uns arquivos fontes:
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um item desde o endereço da pasta deste compilador.
    Se o item não for encontrado, pare.
    Se a categoria deste item não for "arquivo", recomece.
    Se a extensão deste item não estiver em branco, recomece.
    Se o item parece ser encadernável, recomece.
    Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    Carregue o arquivo fonte.
  Recomece. [percorra novamente o código acima]

O percorredor de contrações é um percorredor.

Etapas para que se parse uma string para uma segunda string (para expandir contrações):
  Limpe a segunda string.
  Limpe uma terceira string.
  Lance o percorredor de contrações sobre a string.
  Comece. [a executar o código abaixo]
    Se o segmento final deste percorredor de contrações estiver em branco, retorne.
    Posicione o segmento inicial deste percorredor de contrações sobre o segmento final deste percorredor de contrações. 
    Mova o percorredor de contrações (englobando tudo).
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor de contrações 
    NÃO for um byte ignorável, posponha o segmento inicial deste percorredor de contrações para a segunda string; 
   Recomece.
    Posponha o segmento inicial deste percorredor de contrações para a segunda string usando a terceira string (para expandir contrações).
    Atribua o segmento inicial deste percorredor de contrações à terceira string.
  Recomece. [percorra novamente o código acima]

Etapas para que se reduza umas unidades semânticas por utility use:
  Obtenha uma unidade semântica desde as unidades semânticas.
  Se a unidade semântica for inexistente, retorne.
  Se o tipo desta unidade semântica for inexistente, recomece.
  Reduza o tipo desta unidade semântica para um tipo por utility use.
  Se o tipo não for inexistente, atribua o tipo ao tipo desta unidade semântica.
  Recomece. [percorra novamente o código acima]

Etapas para que se reduza um tipo para um segundo tipo por utility use:
  Atribua o tipo ao segundo tipo.
  Comece. [a executar o código abaixo]
    Se o segundo tipo for inexistente, retorne.
    Se o nome deste segundo tipo for "texto hexadecimal", retorne.
    Se o nome deste segundo tipo for "string", retorne.
    Se o nome deste segundo tipo for "texto", retorne.
    Se o nome deste segundo tipo for "número", retorne.
    Se o nome deste segundo tipo for "ponteiro", retorne.
    Se o nome deste segundo tipo for "lista", esvazie o segundo tipo; retorne.
    \PAL
    \Se o nome deste segundo tipo for "elemento", esvazie o segundo tipo; retorne.
    Se o tipo base deste segundo tipo for o segundo tipo, esvazie o segundo tipo; retorne.
    Atribua o tipo base deste segundo tipo ao segundo tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se organize o catálogo de rotinas úteis:
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um bucket usando o catálogo de rotinas úteis.
    Se o bucket for inexistente, retorne.
    Se os referências deste bucket estiverem vazios, recomece.
    Organize o catálogo de rotinas úteis usando os referências deste bucket.
  Recomece. [percorra novamente o código acima]

Etapas para que se organize o catálogo de rotinas úteis usando umas referências:
    Obtenha uma referência desde as referências.
    Se a referência for inexistente, retorne.
    Atribua o ponteiro deste referência para uma rotina.
    Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno #14"; retorne.
    Copie as unidades semânticas desta rotina para umas unidades semânticas.
    Reduza as unidades semânticas por utility use.
    Catalogue a rotina usando as unidades semânticas e o catálogo geral de rotinas.
    Destrua as unidades semânticas.
  Recomece. [percorra novamente o código acima]

Etapas para que se remove algum negatives desde umas unidades semânticas devolvendo um detector:
  Desative o detector.
  Permute as unidades semânticas com umas segunda unidades semânticas.
  Comece. [a executar o código abaixo]
    Atribua o first unidade semântica destas segunda unidades semânticas para uma unidade semântica.
    Se a unidade semântica for inexistente, retorne.
    Remove a unidade semântica desde a segunda unidades semânticas.
    \PAL
    Se a string desta unidade semântica for "não", reverse o detector; destrua a unidade semântica; recomece.
    \Se a string desta unidade semântica for "nada", reverse o detector; destrua a unidade semântica; recomece.
    \CAL
    Se a string desta unidade semântica for "not", reverse o detector; destrua a unidade semântica; recomece.
    \Se a string desta unidade semântica for "nothing", reverse o detector; destrua a unidade semântica; recomece.
    Posponha a unidade semântica para as unidades semânticas.
    Se a string desta unidade semântica for "can't", reverse o detector; atribua "can" à string desta unidade semântica; recomece.
    \Se a string desta unidade semântica for "cannot", reverse o detector; atribua "can" à string desta unidade semântica; recomece.
    Se a string desta unidade semântica for "nothing", reverse o detector; atribua "something" à string desta unidade semântica; recomece.
    Se a string desta unidade semântica for "nada", reverse o detector; atribua "something" à string desta unidade semântica; recomece.
    Se a string desta unidade semântica for "won't", reverse o detector; atribua "will" à string desta unidade semântica; recomece.
    Se a string desta unidade semântica termina com "n't", reverse o detector; remove trailing bytes desde a string desta unidade semântica usando 3; recomece.
  Recomece. [percorra novamente o código acima]

  

Etapas para que se resolva um campo:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o campo for inexistente, retorne.
  Resolva o campo como uma variável.
  Se o apelido deste campo não for algum valid campo nome, limpe o apelido deste campo. \it
  Se o nome deste campo não for algum valid campo nome, apresente uma mensagem de erro contendo "'" junto com o nome deste campo seguido de "' é um campo nome inválido." e o endereço local deste campo; retorne.

Etapas para que se resolva um global:
  Se o global for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o corpo global deste global não estiver em branco, resolva o global (compile corpo).
  Se o nome do tipo deste global estiver em branco, apresente uma mensagem de erro contendo "Tipo inválido: " junto com o nome deste global seguido de "' . O tipo da variável global está vazio." e o endereço local deste global; retorne.
  Resolva o global como uma variável.

Etapas para que se resolva um global (compile corpo):
  Se o global for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Lance um percorredor sobre o corpo global deste global.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum literal, apresente uma mensagem de erro contendo "Erro de tipo. O tipo: " junto com o segmento inicial deste percorredor seguido de "' deve ser do tipo literal." e o percorredor; retorne.
  Compile um literal usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Acho que era bom colocar um ponto por aqui, né?" e o percorredor; retorne.
  Se o nome do tipo deste global estiver em branco, atribua o nome deste tipo deste literal ao nome do tipo deste global.
  Atribua o literal ao literal deste global.
  Catalogue o literal.

Etapas para que se resolva uns globals:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um global desde o globals.
  Se o global for inexistente, retorne.
  Resolva o global.
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva um tipo (tipos de dados primitivos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo for inexistente, retorne.
  Se o tipo base deste tipo não for inexistente, retorne.
  Encontre o tipo base deste tipo usando o base nome deste tipo e o catálogo de tipos.
  Se o tipo base deste tipo for inexistente, apresente uma mensagem de erro contendo "Erro. Tipo base '" junto com o base nome deste tipo seguido de "' inválido." e o endereço local deste tipo; retorne.
  Ative o detector de recursividade deste tipo.
  Se o detector de recursividade deste tipo base deste tipo estiver ativo, apresente a mensagem de erro contendo "Definição recursiva com: " junto com o base nome deste tipo seguido de "." e o endereço local deste tipo; retorne.
  Resolva o tipo base deste tipo (tipos de dados primitivos).
  Desative o detector de recursividade deste tipo.

Etapas para que se resolva um tipo (expand lista): \ tipo base deste tipo não está resolved yet
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo for inexistente, retorne.
  Se o tipo base deste tipo não for inexistente, retorne.
  Se o nome deste tipo for "lista", retorne.
  \Se o nome deste tipo for "elemento", retorne.
  Se o tipo não puder ser reduzido para "lista" usando o base nome, retorne.
  Encontre um tipo base usando o base nome deste tipo e o catálogo de tipos.
  \ adicione lista estrutura - o número of secret campos é hard coded em two places: search por "du que 4" \ was 6
  Atribua o nome deste tipo seguido de " estrutura" para um nome.
  Atribua o nome deste tipo seguido de " estruturas" para um plural nome.
  Atribua o nome deste tipo base seguido de " estrutura" para um base nome.
  Adicione um conjunto tipo para os tipos usando o nome e o plural nome e o base nome.
  Adicione um campo para os campos deste conjunto tipo usando "subsequente " junto com o nome deste tipo e "subsequente" e o nome deste tipo e o detector de ignição.
  \PAL antecedente\anterior\prévio e subseqüente\posterior
  Adicione um portuguese campo para os campos deste conjunto tipo usando "seguinte " junto com o nome deste tipo e "seguinte" e o nome deste tipo e o detector de ignição.
  Atribua "subsequente " junto com o nome deste tipo ao nome de redefinição de conteúdo deste portuguese campo.
  \Adicione um portuguese reverse campo para os campos deste conjunto tipo usando o nome deste tipo seguido de " seguinte" e "seguinte" e o nome deste tipo e o detector de ignição.
  \Atribua "subsequente " junto com o nome deste tipo ao nome de redefinição de conteúdo deste portuguese reverse campo.
  Adicione um segundo campo para os campos deste conjunto tipo usando "precedente " junto com o nome deste tipo e "precedente" e o nome deste tipo e o detector de ignição.
  \Adicione uma segunda portuguese campo para os campos deste conjunto tipo usando "anterior " junto com o nome deste tipo e "anterior" e o nome deste tipo e o detector de ignição.
  \Atribua "precedente " junto com o nome deste tipo ao nome de redefinição de conteúdo desta segunda portuguese campo.
  Adicione um segundo portuguese reverse campo para os campos deste conjunto tipo usando o nome deste tipo seguido de " anterior" e "anterior" e o nome deste tipo e o detector de ignição.
  Atribua "precedente " junto com o nome deste tipo ao nome de redefinição de conteúdo deste segundo portuguese reverse campo.
  Se os campos deste tipo não estiverem vazios, posponha os campos deste tipo para os campos deste conjunto tipo.
  Catalogue o conjunto tipo.
  \ fix para cima original tipo para look like um ponteiro
  Atribua o nome deste conjunto tipo ao conteúdo nome deste tipo.
  \ adicione chain tipo
  Adicione um chain tipo para os tipos usando o plural nome deste tipo e "" e o plural nome deste tipo base.
  Adicione um terceiro campo para os campos deste chain tipo usando "first " junto com o nome deste tipo e "first" e o nome deste tipo e o detector de ignição.
  Adicione um terceiro portuguese campo para os campos deste chain tipo usando "primeiro " junto com o nome deste tipo e "primeiro" e o nome deste tipo e o detector de ignição.
  Atribua "first " junto com o nome deste tipo ao nome de redefinição de conteúdo deste terceiro portuguese campo.
  Adicione um terceiro feminine portuguese campo para os campos deste chain tipo usando "primeira " junto com o nome deste tipo e "primeira" e o nome deste tipo e o detector de ignição.
  Atribua "first " junto com o nome deste tipo ao nome de redefinição de conteúdo deste terceiro feminine portuguese campo.
  Adicione um quarto campo para os campos deste chain tipo usando "last " junto com o nome deste tipo e "last" e o nome deste tipo e o detector de ignição.
  Adicione um quarto portuguese campo para os campos deste chain tipo usando "último " junto com o nome deste tipo e "último" e o nome deste tipo e o detector de ignição.
  Atribua "last " junto com o nome deste tipo ao nome de redefinição de conteúdo deste quarto portuguese campo.
  Adicione um quarto portuguese feminine campo para os campos deste chain tipo usando "última " junto com o nome deste tipo e "última" e o nome deste tipo e o detector de ignição.
  Atribua "last " junto com o nome deste tipo ao nome de redefinição de conteúdo deste quarto portuguese feminine campo.
  Catalogue o chain tipo.

Etapas para que se resolva um tipo (registro de plurais):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo for inexistente, retorne.
  Se o plural nome deste tipo estiver em branco, retorne.
  Se o tipo puder ser reduzido para "lista" usando o base nome, retorne.
  Catalogue o tipo usando o plural nome deste tipo.

Etapas para que se resolva um tipo (dados opcionais - ponteiro):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o conteúdo tipo deste tipo não for inexistente, retorne.
  Se o conteúdo nome deste tipo estiver em branco, atribua o conteúdo tipo deste tipo base deste tipo ao conteúdo tipo deste tipo; retorne.
  Encontre o conteúdo tipo deste tipo usando o conteúdo nome deste tipo e o catálogo de tipos.
  Se o conteúdo tipo deste tipo for inexistente, apresente uma mensagem de erro contendo "Não sei bem pra que lista você está se referindo." e o endereço local deste tipo; retorne.

Etapas para que se resolva um tipo (dados opcionais - conjunto):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se os campos deste tipo estiverem vazios, copie os campos deste tipo base deste tipo aos campos deste tipo; retorne.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde os campos deste tipo (backwards).
    Se o campo for inexistente, pare.
    Se o campo estiver duplicada em os campos deste tipo, apresente uma mensagem de erro contendo "O campo '" junto com o nome deste campo seguido de "' está definido mais de uma vez." e o endereço local deste campo; retorne.
    Resolva o campo.
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o detector de recursividade deste tipo deste campo estiver ativo, apresente a mensagem de erro contendo "Definição recursiva encontrada no '" junto com o nome deste tipo deste campo seguido de "'." e o endereço local deste campo; retorne.
    Resolva o tipo deste campo (dados complementares). \ de novo
    Se o detector de referência deste campo não estiver ativo, recomece.
    Se o tipo deste campo não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "Não entendi o parâmetro '(referência)' nesse campo: " junto com o nome deste campo seguido de "'..." e o endereço local deste campo; retorne.
  Recomece. [percorra novamente o código acima]
  Elimine apelidos duplicados desde os campos deste tipo.
  Se o tipo não puder ser reduzido para "lista estrutura", retorne.
  Se a contagem destes campos deste tipo for maior do que 4, retorne. \ already copied? was 2 por subsequente e prev, now 6 para included Spanish redefiniions
  Copie os campos deste tipo base deste tipo aos campos deste tipo (apenas campos de dados).

Etapas para que se resolva um tipo (dados opcionais - scale):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o tipo base deste tipo para um tipo base.
  Se a razão de escala deste tipo for 0, atribua a razão de escala deste tipo base deste tipo à razão de escala deste tipo; retorne.
  Se a razão de escala deste tipo base for 0, retorne.
  Multiplique a razão de escala deste tipo pela razão de escala deste tipo base.
  Atribua o tipo base deste tipo base ao tipo base deste tipo.

Um tipo base é um tipo.

Etapas para que se resolva um tipo (dados complementares):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o tipo for inexistente, retorne.
  Se o optional info resolved detector deste tipo estiver ativo, retorne.
  Se o tipo base deste tipo for o tipo, retorne. \ para os tipos pré-definidos
  Verifique por informações opcionais inválidas em o tipo.
  Ative o detector de recursividade deste tipo.
  Resolva o tipo base deste tipo (dados complementares).
  Se o tipo puder ser reduzido para "ponteiro", resolva o tipo (dados opcionais - ponteiro).
  Se o tipo puder ser reduzido para "estrutura", resolva o tipo (dados opcionais - conjunto). \ mudar aqui
  Se o tipo puder ser reduzido para "número", resolva o tipo (dados opcionais - scale).
  Desative o detector de recursividade deste tipo.
  Ative o optional info resolved detector deste tipo.

Etapas para que se resolva uns tipos (tipos de dados primitivos): \ Esta rotina é recursiva.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Resolva o tipo (tipos de dados primitivos). 
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva uns tipos (expand listas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Resolva o tipo (expand lista).
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva uns tipos (registro de plurais):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Resolva o tipo (registro de plurais).
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva uns tipos (dados complementares):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Resolva o tipo (dados complementares).
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva uma variável:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável for inexistente, retorne.
  Se a tipo desta variável não for inexistente, retorne.
  Se o nome do tipo desta variável não estiver em branco, resolva a variável (usando o nome do tipo declarado); retorne.
  Encontre o tipo desta variável e o apelido desta variável usando o nome desta variável.
  Se o tipo desta variável não for inexistente, atribua o nome deste tipo desta variável ao nome do tipo desta variável; retorne.
  Apresente uma mensagem de erro contendo "Erro. Não foi possível determinar o tipo da variável '" junto com o nome desta variável seguido de "'." e o endereço local desta variável.

Etapas para que se resolva uma variável (usando o nome do tipo declarado):
  Encontre o tipo desta variável usando o nome do tipo desta variável e o catálogo de tipos.
  Se o tipo desta variável for inexistente, apresente uma mensagem de erro contendo "Erro. Não foi possível determinar o tipo da variável '" junto com o nome do tipo desta variável seguido de "' no catálogo de tipos." e o endereço local desta variável; retorne.

Etapas para que se arredonde tamanhos de zona para cima;
Etapas para que se arredonde para cima tamanhos de zona:
  Atribua a quantidade de caracteres desta seção de DLLs ao tamanho desta seção de DLLs.
  Arredonde para cima o tamanho desta seção de DLLs usando o múltiplo imediato de 4096.
  Atribua a quantidade de caracteres desta região de dados ao tamanho desta região de dados.
  Arredonde para cima o tamanho desta região de dados  usando o múltiplo imediato de 4096.
  Atribua a quantidade de caracteres desta região de código ao tamanho desta região de código.
  Arredonde para cima o tamanho desta região de código  usando o múltiplo imediato de 4096.

Uma instrução é um subtexto.

Um cabeçalho de rotina é um subtexto.

O catálogo geral de rotinas é um catálogo.

Um tamanho local é um tamanho.

Um detector de função é um detector.

Uma rotina é uma lista com
  Um endereço local (referência),
  Um detector de compatibilidade,
  Um detector de deliberação,
  Um detector de função,
  Um compiled detector,
  Um apelido catálogo,
  Um representação interna da rotina, 
  Uns unidades semânticas, 
  Uns parâmetros, 
  Um tamanho do parâmetro,
  Um employs representação interna da rotina ,
  Umas variáveis locais, 
  Um tamanho local,
  Um cabeçalho de rotina, 
  Uma string do cabeçalho,
  Umas instruções, 
  Uma string do corpo,
  Uns fragmentos,
  Um endereço.

Uma string do corpo é uma string.
Uma string do cabeçalho é uma string.
Uma referência da rotina é umas unidades semânticas.

As rotinas são umas rotinas.

Etapas para que se examine algum dado complementar por um tipo usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor for "to", examine algum dado complementar pelo tipo usando o percorredor (ponteiro); retorne.
  Se o segmento inicial deste percorredor for "para", examine algum dado complementar pelo tipo usando o percorredor (ponteiro); retorne.
  Se o segmento inicial deste percorredor for algum com, examine algum dado complementar pelo tipo usando o percorredor (estrutura); retorne.

Etapas para que se examine algum dado complementar por um tipo usando um percorredor (ponteiro):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente uma mensagem de erro contendo "A palavra 'to' precisa de um artigo indefinido depois dela, não de um: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o conteúdo nome deste tipo usando o percorredor.

Etapas para que se examine algum dado complementar por um tipo usando um percorredor (estrutura):
  Mova o percorredor (usando diretrizes de compilação).
  Examine o campos deste tipo usando o percorredor.

Etapas para que se examine algum pauses usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor não for algum pause, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Uma keyword é uma string.
Uma keyword de designação é uma keyword.

Etapas para que se examine um campo usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Examine o campo usando o percorredor (tipo geral).
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor for uma keyword de designação, examine o campo usando o percorredor (cláusula designadora); recomece.
    Se o segmento inicial deste percorredor for "sob", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    \Se o segmento inicial deste percorredor for "equivalente a", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    \Se o segmento inicial deste percorredor for "análogo a", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    \Se o segmento inicial deste percorredor for "análoga a", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for "em", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for "sob", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for "sobre", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for "redefinindo", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for uma keyword de referenciamento, examine o campo usando o percorredor (cláusula de referência); recomece.

Etapas para que se examine um campo usando um percorredor (cláusula designadora):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o nome do tipo deste campo estiver em branco, atribua o nome deste campo ao nome do tipo deste campo. \ byte array nome do tipo already filled in
  Examine o nome deste campo usando o percorredor.

Etapas para que se examine um campo usando um percorredor (cláusula de redefinição):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido, apresente uma mensagem de erro contendo "Eu estava esperando o artigo 'the', mas o que encontrei foi: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome de redefinição de conteúdo deste campo usando o percorredor.

Etapas para que se examine um campo usando um percorredor (cláusula de referência):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o detector de referência deste campo.

Etapas para que se examine um campo usando um percorredor (tipo: array de bytes):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Reduza a proporção.
  Se o denominador desta proporção não for 1, apresente uma mensagem de erro contendo "Erro. Arrays exigem tamanhos não fracionários" e o percorredor; retorne.
  Atribua o numerador desta proporção à contagem deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "byte" ou "bytes", apresente a mensagem de erro contendo "Erro. Necessário utilizar a palavra 'bytes' após um número designador." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "byte" ao nome do tipo deste campo.

Etapas para que se examine um campo usando um percorredor (tipo normal):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente uma mensagem de erro contendo "Erro. O compilador esperava um artigo idefinido. Termo encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.  
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outras", atribua "outras" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outros", atribua "outros" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundos", atribua "segundos" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundas", atribua "segundas" ao nome deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Extend o nome deste campo com o nome.

Etapas para que se examine um campo usando um percorredor (tipo geral):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal, examine o campo usando o percorredor (tipo: array de bytes); retorne.
  Examine o campo usando o percorredor (tipo normal).

Etapas para que se examine uns campos usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um campo para o campos usando "campo" e o caractere inicial deste segmento inicial deste percorredor.
  Examine o campo usando o percorredor.
  Se o segmento inicial deste percorredor não for algum pause, retorne.
  Examine algum pauses usando o percorredor.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um corpo global usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste corpo global.
  Atribua -1 ao caractere final deste corpo global.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne. \ o retorne sai da rotina
    Se o segmento inicial deste percorredor estiver em branco, retorne. \ o comando recomece volta pro começo do loop
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne. \ o comando pare sai do loop, mas não sai da rotina, apenas do loop
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste corpo global.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um global usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione o global para os globals usando "global" e o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome deste global usando o percorredor.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas, examine o global usando o percorredor(cláusula 'tem'); retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples, apresente uma mensagem de erro contendo "Erro. Necessário a utilização do verbo ser/estar ao invés de '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, examine o global usando o percorredor (literal termo); retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo deste global usando o percorredor.
  Se o segmento inicial deste percorredor for o início of algum dado complementar, examine o global usando o percorredor (dados complementares); retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, examine o global usando o percorredor (data part); retorne.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Erro. As definições devem terminar com um '.'" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um global usando um percorredor (data part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum to, apresente uma mensagem de erro contendo "Erro. A sintaxe correta é 'igual a'." junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o corpo global deste global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Erro. Necessário inserir um '.' ao final da variável global" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um global usando um percorredor(cláusula 'tem'):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "~inline " junto com o nome deste global seguido de " tipo" para um nome.
  Atribua o nome seguido de "s" para um plural nome.
  Adicione um tipo para os tipos usando o nome e o plural nome e "estrutura" e o endereço local deste global. \mudar aqui
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo deste global.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Erro. Insira um '.' no final da estrutura" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um global usando um percorredor (literal termo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Examine o corpo global deste global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Erro. Necessário incluir um '.' ao final de valores textuais ou numéricos." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um global usando um percorredor (dados complementares):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua "~inline " junto com o nome deste global seguido de " tipo" para um nome.
  Atribua o nome seguido de "s" para um plural nome. \ aqui pode estar o erro na formação do plural
  Adicione um tipo para os tipos usando o nome e o plural nome e o nome do tipo deste global e o endereço local deste global.
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo deste global.
  Examine algum dado complementar pelo tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Erro. Insira um '.' após as informações complementares." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um nome usando um percorredor:
  Limpe o nome.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o percorredor estiver sobre algum nome starter, extend o nome com o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o percorredor estiver sobre algum nome ender, pare.
    Extend o nome com o segmento inicial deste percorredor.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]
  Se o nome estiver em branco, apresente uma mensagem de erro contendo "Erro. Nome '" junto com o segmento inicial deste percorredor seguido de "' em branco." e o percorredor; retorne.

Etapas para que se examine uma instruções usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial destas instruções.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final destas instruções.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, apresente uma mensagem de erro contendo "Erro. Insira ':' ao final do cabeçalho desta rotina." e o percorredor; retorne.
    Se o segmento inicial deste percorredor não for o ponto final, mova o percorredor (usando diretrizes de compilação); recomece.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine uma rotina usando um percorredor:
    \ Define o cabeçalho de rotina.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione a rotina para as rotinas usando o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor for "Etapas", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "Passos", mova o percorredor (usando diretrizes de compilação). \ Pula a palavra  "Passos" ou "Etapas" e obtém o subsequente segmento inicial
  Se o segmento inicial deste percorredor for "necessários", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "necessárias", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "para", apresente uma mensagem de erro contendo "Erro. Insira a kewyword 'para' '" junto com o segmento inicial deste percorredor seguido de "' neste cabeçalho de rotina." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação). \ ignora o "para" e obtém o subsequente segmento inicial
  Se o segmento inicial deste percorredor for "que", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "que", apresente uma mensagem de erro contendo "Você precisa colocar um 'que' antes da palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ ignora o "que" e obtém o subsequente segmento inicial
  Se o segmento inicial deste percorredor for "se", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "se", apresente uma mensagem de erro contendo "Você precisa colocar um 'se' antes da palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ ignora o "se" e obtém o subsequente segmento inicial
  Examine a cabeçalho de rotina desta rotina usando o percorredor.
  Se o segmento inicial deste percorredor for o ponto&vírgula, examine a rotina usando o percorredor (sobrecarga de métodos); retorne. \ *** usado para nomes alternativos de rotinas
  Se o segmento inicial deste percorredor não for o sinal de dois pontos, apresente a mensagem de erro contendo "Erro. Insira ':' ao final do cabeçalho desta rotina." e o endereço local desta rotina; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine as instruções desta rotina usando o percorredor.

Etapas para que se examine uma rotina usando um percorredor (sobrecarga de métodos):
  \ *** para nomes alternativos de rotinas
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o início of algum rotina, apresente uma mensagem de erro contendo "Erro. Verifique a posição do ';'" e o original percorredor; retorne.
  Atribua o caractere inicial deste segmento inicial deste original percorredor ao caractere inicial destas instruções desta rotina.
  Atribua o caractere final deste segmento inicial deste original percorredor ao caractere final destas instruções desta rotina.
  Mova o original percorredor (usando diretrizes de compilação).

Etapas para que se examine uma cabeçalho de rotina usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste cabeçalho de rotina.
  Atribua -1 ao caractere final deste cabeçalho de rotina.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, retorne. \ *** alternate wording
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste cabeçalho de rotina.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Lance um percorredor sobre o trecho deste arquivo fonte.
  Mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o início of algum tipo, examine um tipo usando o percorredor; recomece.
    Se o segmento inicial deste percorredor for o início of algum global, examine um global usando o percorredor; recomece.
    Se o segmento inicial deste percorredor for o início of algum rotina, examine uma rotina usando o percorredor; recomece.
    Apresente uma mensagem de erro contendo "Erro. O compilador não reconhece a sintaxe '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine uns arquivos fontes:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um arquivo fonte desde os arquivos fontes.
  Se o arquivo fonte for inexistente, retorne.
  Examine o arquivo fonte.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um tipo usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne. 
  Se o segmento inicial deste percorredor for algum artigo indefinido português, ative um portuguese detector. 
  Se o segmento inicial deste percorredor for algum artigo indefinido inglês, ative um english detector. 
  Adicione o tipo para os tipos usando o caractere inicial deste segmento inicial deste percorredor. 
  Mova o percorredor (usando diretrizes de compilação). 
  Examine o nome deste tipo usando o percorredor. 
  Atribua o nome deste tipo ao plural nome deste tipo. 
  Atribua 0 a uma contagem.  
  Se o english detector não estiver ativo, pluralize o plural nome deste tipo (strings em português); adicione 1 à contagem.
  Se o english detector estiver ativo, pluralize o plural nome deste tipo (english rules); adicione 1 à contagem.
  \Se o portuguese detector estiver ativo, pluralize o plural nome deste tipo (strings em português); adicione 1 à contagem.
  Se a contagem for igual ou maior do que 2, 
    apresente uma mensagem de erro contendo "Erro, não foi possível detectar o idioma desta variável" e o endereço local deste tipo; retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas, examine o tipo usando o percorredor(cláusula 'tem'); retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples, 
    apresente a mensagem de erro contendo "Erro. Esperado 'ser/estar'. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum valor numérico literal, examine o tipo usando o percorredor (unidade de medida); retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido, 
    apresente a mensagem de erro contendo "Erro. Esperado um artigo indefinido. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o base nome deste tipo usando o percorredor.
  Examine algum dado complementar pelo tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, 
    apresente a mensagem de erro contendo "Erro. Insira um '.' após a declaração do tipo." 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Etapas para que se examine um tipo usando um percorredor(cláusula 'tem'):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "estrutura" ao base nome deste tipo. \\mudar aqui
  Examine o campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Erro. Esperado '.' após a keyword 'tem'. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Etapas para que se examine um tipo usando um percorredor (unidade de medida):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para a razão de escala deste tipo.
  Se a razão de escala deste tipo for 0, apresente uma mensagem de erro contendo "Erro. Impossível utilizar 0 em tipos de escala." e o endereço local deste tipo; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o base nome deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Erro. Necessário um '.' no fim desta fração. Encontrado. '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Um scratch é uma variável local.

Etapas para que se scrub um catálogo:
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, retorne.
      Se os referências deste bucket estiverem vazios, recomece.
    Scrub os referências deste bucket.
  Recomece. [percorra novamente o código acima]

Etapas para que se scrub umas referências:
  Permute as referências com uns segunda referências.
  Comece. [a executar o código abaixo]
    Atribua o first referência destes segunda referências para uma referência.
    Se a referência for inexistente, retorne.
    Remove a referência desde a segunda referências.
    Se o ponteiro deste referência for inexistente, destrua a referência; recomece.
    Posponha a referência para os referências.
  Recomece. [percorra novamente o código acima]

Etapas para que se ative o compiled detector em uma variável;
Etapas para que se ligue o compiled detector em uma variável:
  Se a variável for inexistente, retorne.
  Se o compiled detector desta variável [já] estiver ativo, retorne.
  Ative o compiled detector desta variável.
  Se a categoria desta variável não for "global", retorne.
  Se o literal desta variável for inexistente, retorne.
  Encontre uma rotina usando "atribua" e o tipo deste literal desta variável e "para" e o tipo desta variável.
  Se a rotina for inexistente, encontre a rotina usando "converta" e o tipo deste literal desta variável e "para" e o tipo desta variável; ative um detector.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro. O tipo e o valor da variável global  não estão correspondendo." e o endereço local desta variável; retorne.
  Compile o corpo of a rotina.
  Se o detector estiver ativo, atribua "converta o " junto com o nome deste literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao texto inicializador desta variável.
  Se o detector não estiver ativo, atribua "atribua o " junto com o nome deste literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao texto inicializador desta variável. \ Era " ao ". NÃO PODIA MUDAR O " ao " não sei o porquê

Etapas para que se passe para o subsequente palavra em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste subtexto for irrelevante, pare.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  ignore algum leading noise no subtexto.

Etapas para que se passe para o precedente palavra em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere final deste subtexto for irrelevante, pare.
  Subtraia 1 desde o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]
  ignore algum trailing noise no subtexto.

Um arquivo fonte é uma lista com 
  Um endereço completo e 
  Um trecho.

Os arquivos fontes são uns arquivos fontes.

Uma etiqueta é um número.

Um termo é um estrutura com 
  Uma variável e 
  Uma phrase.

Etapas para que se transforme em código hexadecimal um fragmento:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o fragmento for inexistente, retorne.
  Se a etiqueta deste fragmento for o etiqueta de inserção de endereço [na stack], transforme em código hexadecimal o fragmento (empilhamento de endereço); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda interna, transforme em código hexadecimal o fragmento (Demanda Interna); retorne.
  Se a etiqueta deste fragmento for o etiqueta de carregamento de endereço, transforme em código hexadecimal o fragmento (load endereço); retorne.
  Se a etiqueta deste fragmento for a etiqueta de acréscimo, transforme em código hexadecimal o fragmento (increment); retorne.
  Se a etiqueta deste fragmento for o etiqueta de revogação, transforme em código hexadecimal o fragmento (dereference); retorne.
  Se a etiqueta deste fragmento for o etiqueta de desvio falso, transforme em código hexadecimal o fragmento (desvio caso resultado negativo); retorne.
  Se a etiqueta deste fragmento for a etiqueta de negação lógica, transforme em código hexadecimal o fragmento (negação lógica); retorne.
  Se a etiqueta deste fragmento for o etiqueta de retorno, transforme em código hexadecimal o fragmento (cláusula de retorno); retorne.
  Se a etiqueta deste fragmento for a etiqueta de repetição, transforme em código hexadecimal o fragmento(cláusula de repetição); retorne.
  Se a etiqueta deste fragmento for o etiqueta de interrupção, transforme em código hexadecimal o fragmento (cláusula de interrupção); retorne.
  Se a etiqueta deste fragmento for o etiqueta preliminar, transforme em código hexadecimal o fragmento (etapa preliminar); retorne.
  Se a etiqueta deste fragmento for o etiqueta conclusiva, transforme em código hexadecimal o fragmento (etapa conclusiva); retorne.
  Se a etiqueta deste fragmento for o etiqueta de inserção de valor [na stack], transforme em código hexadecimal o fragmento (empilhamento de valor); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda externa, transforme em código hexadecimal o fragmento (Demanda Externa); retorne.
  Se a etiqueta deste fragmento for o etiqueta de carregamento de registrador EAX, transforme em código hexadecimal o fragmento (atribuição de EAX); retorne.
  Se a etiqueta deste fragmento for o etiqueta de obtenção do registrador EAX, transforme em código hexadecimal o fragmento (registrador EAX); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda indireta, transforme em código hexadecimal o fragmento (Demanda Indireta); retorne.
  Se a etiqueta deste fragmento for a etiqueta de endereço de rotina, transforme em código hexadecimal o fragmento (rotina endereço); retorne.

Etapas para que se transforme em código hexadecimal um fragmento (cláusula de interrupção):
  Atribua a etiqueta de repetição para uma etiqueta.
  Encontre um segundo fragmento usando o fragmento e a etiqueta.
  Se o segundo fragmento for inexistente, atribua a etiqueta de finalização ao etiqueta. \ para break sem um loop ou depois de um loop
  Encontre um terceiro fragmento usando o last fragmento destes fragmentos desta rotina utilizada atualmente e a etiqueta (backwards).
  Se o terceiro fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #15"; retorne.
  Se o subsequente fragmento deste terceiro fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #16"; retorne.
  Acrescente $E9 e o endereço deste subsequente fragmento deste terceiro fragmento para o fragmento. \ JMP o endereço da destination

Etapas para que se transforme em código hexadecimal um fragmento (Demanda Externa):
  Acrescente $FF15 e o endereço desta função deste fragmento para o código deste fragmento. \ Processe [o endereço desta função deste fragmento ]
  \ The acima of rotina generates the machine code for a Processe to the Windows operating system. 
  \The op code is specified, in hexadecimal ($FF15) and the rest of the instruction is the address of the função address of the target rotina, which is appended to the op code.

Etapas para que se transforme em código hexadecimal um fragmento (Demanda Indireta):
  Acrescente endereço loading código para o código deste fragmento usando a variável deste fragmento. \ coloca endereço para edx
  Acrescente $FF12 para o código deste fragmento. \ Processe [edx]

Etapas para que se transforme em código hexadecimal um fragmento (Demanda Interna):
  Obtenha um endereço usando o rotina deste fragmento.
  Acrescente $E8 e o endereço para o fragmento. \ Processe o address da rotina do fragmento 

Etapas para que se transforme em código hexadecimal um fragmento (dereference):
  Acrescente $8B95 e o deslocamento desta variável deste fragmento para o código deste fragmento. \ mov edx,[ebp+ o deslocamento desta variável deste fragmento]
  Acrescente $8B12 para o código deste fragmento. \ mov edx,[edx]
  Acrescente $8995 e o deslocamento desta variável deste fragmento para o código deste fragmento. \ mov [ebp+ o deslocamento desta variável deste fragmento]

Etapas para que se transforme em código hexadecimal um fragmento (etapa conclusiva):
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, acrescente $5F5E5B para o código deste fragmento. \ pop edi; pop esi; pop ebx;
  Acrescente $8BE5 para o código deste fragmento. \ mov esp,ebp -> não seria 89EC?
  Acrescente $5D para o código deste fragmento. \ pop ebp
  Acrescente $C2 e o tamanho do parâmetro desta rotina utilizada atualmente para o código deste fragmento. \ ret + o tamanho do parâmetro da rotina utilizada atualmente

Um tamanho do parâmetro é um tamanho.

Etapas para que se transforme em código hexadecimal um fragmento (cláusula de retorno):
  Encontre um segundo fragmento usando o fragmento e a etiqueta de finalização.
  Se o segundo fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #17"; retorne.
  Acrescente $E9 e o endereço deste segundo fragmento para o fragmento. \ jmp + o address da destination

Etapas para que se transforme em código hexadecimal um fragmento (increment):
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #18"; retorne.
  Se a categoria desta variável deste fragmento não for "scratch", apresente a mensagem de erro contendo "Erro interno #19"; retorne.
  Acrescente $8185 e o deslocamento desta variável deste fragmento e o número deste fragmento para o código deste fragmento. \ add [ebp+ o deslocamento desta variável deste fragmento], o número deste fragmento

Etapas para que se transforme em código hexadecimal um fragmento (desvio caso resultado negativo):
  Encontre um segundo fragmento usando o fragmento e o etiqueta delimitadora de bloco condicional.
  Se o segundo fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #20"; retorne.
  Acrescente $83F800 para o código deste fragmento. \ cmp eax,0
  Acrescente $0F84 e o endereço deste segundo fragmento para o fragmento. \ je + o address da destination

Etapas para que se transforme em código hexadecimal um fragmento (load endereço):
  Acrescente endereço loading código para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Acrescente $8995 e o deslocamento desta segunda variável deste fragmento para o código deste fragmento. \ mov [ebp+ o deslocamento desta variável deste fragmento],edx

\Etapas para que se transforme em código hexadecimal um fragmento (atribuição de EAX):
\Acrescente endereço loading código para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
\Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Internal erro - transforme em código hexadecimal um fragmento (atribuição de EAX)"; retorne.
\Se o tipo desta variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transforme em código hexadecimal um fragmento (atribuição de EAX)"; retorne.
 \Se a quantidade de caracteres deste tipo desta variável deste fragmento não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transforme em código hexadecimal um fragmento (atribuição de EAX)"; retorne.
\Acrescente $8B02 para o código deste fragmento. \ mov eax,[edx]

Etapas para que se transforme em código hexadecimal um fragmento (atribuição de EAX):
  Acrescente $B8 e o detector deste fragmento para o código deste fragmento. \ mov eax,detector
\Acrescente endereço loading código para o código deste fragmento usando a variável do fragmento. \ atribua endereço para edx
\Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Internal erro - transforme em código hexadecimal um fragmento (atribuição de EAX)"; retorne.
\Se o tipo desta variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transforme em código hexadecimal um fragmento (atribuição de EAX)"; retorne.
\Se a quantidade de caracteres deste tipo desta variável deste fragmento não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transforme em código hexadecimal um fragmento (atribuição de EAX)"; retorne.
\Acrescente $8B02 para o código deste fragmento. \ mov eax,[edx]

Etapas para que se transforme em código hexadecimal um fragmento (negação lógica):
  Acrescente $83F001 para o código deste fragmento. \ xor eax,1

Etapas para que se transforme em código hexadecimal um fragmento (etapa preliminar):
  Acrescente $55 para o código deste fragmento. \ push ebp -> saves the contents of the EBP register on the stack.
  Acrescente $8BEC para o código deste fragmento. \ mov ebp,esp -> puts the contents of the ESP register into the EBP register
  Atribua o tamanho local desta rotina utilizada atualmente dividido por 4 para um número.
  Se o número não for 0, acrescente $B9 \ mov ecx,number;  -> sets up the loop that will clear enough space on the stack for the routine's local variables
    e O número e $6A004975FB \loop: push 0; dec ecx; jnz loop -> a loop that pushes enough zeros onto the stack to initialize the local variables.
  para o código deste fragmento. 
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, acrescente $535657 para o código deste fragmento. \ push ebx, esi, edi ->  save the EBX, ESI, and EDI registers on the stack.

Etapas para que se transforme em código hexadecimal um fragmento (empilhamento de endereço):
  Acrescente endereço loading código para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Acrescente $52 para o código deste fragmento. \ push edx -> push the 4-byte value in edx onto the stack

Etapas para que se transforme em código hexadecimal um fragmento (empilhamento de valor):
  Acrescente endereço loading código para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #21"; retorne.
  Se o tipo desta variável deste fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #22"; retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, acrescente $FF32 para o código deste fragmento; retorne. \ push [edx]
  Se a quantidade de caracteres for 2, acrescente $66FF32 para o código deste fragmento; retorne. \ push word ptr [edx]
  Se a quantidade de caracteres for 1, acrescente $0FB61252 para o código deste fragmento; retorne. \ movzxb edx,[edx]; push edx
  Apresente a mensagem de erro contendo "Erro interno #23".

Etapas para que se transforme em código hexadecimal um fragmento(cláusula de repetição):
  Encontre um segundo fragmento usando o fragmento e o etiqueta de laço (backwards).
  Se o segundo fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #24 "; retorne.
  Acrescente $E9 e o endereço deste segundo fragmento para o fragmento. \ jmp o address da destination 

Etapas para que se transforme em código hexadecimal um fragmento (rotina endereço):
  Acrescente endereço loading código para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Se a rotina deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #25"; retorne.
  Obtenha um endereço usando a rotina deste fragmento.
  Acrescente $C702 e o endereço para o código deste fragmento. \ mov [edx],the endereço

Etapas para que se transforme em código hexadecimal um fragmento (registrador EAX):
  Acrescente endereço loading código para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #26"; retorne.
  Se o tipo desta variável deste fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #27"; retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, acrescente $8902 para o código deste fragmento; retorne. \ mov [edx],eax
  Se a quantidade de caracteres for 2, acrescente $668902 para o código deste fragmento; retorne. \ mov [edx],ax
  Se a quantidade de caracteres for 1, acrescente $8802 para o código deste fragmento; retorne. \ mov [edx],al
  [Se a quantidade de caracteres não for 1, 2 ou 4] Apresente a mensagem de erro contendo "Erro interno #28".

Etapas para que se transforme em código hexadecimal uns fragmentos:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Transforme em código hexadecimal o fragmento.
  Recomece. [percorra novamente o código acima]

Etapas para que se transforme em código hexadecimal uma rotina:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina for inexistente, retorne.
  Se o employs representação interna da rotina desta rotina não estiver em branco, retorne.
  Se o compiled detector desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Transforme em código hexadecimal os fragmentos desta rotina.

Etapas para que se transforme em código hexadecimal umas rotinas:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, pare.
  Transforme em código hexadecimal a rotina.
  Recomece. [percorra novamente o código acima]

O catálogo de tipos é um catálogo.

Um tipo é uma lista com
  Um endereço local (referência),
  Um nome, um plural nome,
  Um cabeçalho semi-expandido,
  Uma quantidade de caracteres,
  Um base nome, um tipo base (referência),
  Um conteúdo nome, um conteúdo tipo (referência) [endereço de memórias only],
  Uma razão de escala,
  Some campos [records only],
  Um detector de recursividade,
  Um optional info resolved detector.

Um detector de recursividade é um detector.

Um nome do tipo é um nome.

Os tipos são uns tipos.

O catálogo de rotinas úteis é um catálogo.

Uma variável é uma lista com
  Um endereço local (referência),
  Um categoria [literal, global, local, parâmetro, scratch],
  Um compiled detector,
  Um nome, 
  Um apelido, 
  Um nome do tipo,
  Um tipo (referência), \ tipo real em literal, global e local; dereferenced tipo em parâmetros e scratches
  Um endereço [globals e literals only] ou 
  Um deslocamento sob o endereço [variáveis locais, parâmetros, e campos only],
  Um contagem [campos only],
  Um detector de referência [campos only],
  Um nome de redefinição de conteúdo [campos only],
  Um detector de passagem por-valor [parâmetros only],
  Um corpo global [globals only],
  Um texto inicializador [globals only],
  Um literal (referência) [globals only - constant com which to initalize the global],
  Um texto hexadecimal denominado data [literals only].

Um deslocamento é um número.

Um texto inicializador é uma string.

Um detector de referência é um detector.
Um detector de passagem por-valor é um detector.
Um nome de redefinição de conteúdo é um nome.

Etapas para que se ignore algum trailing noise em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere final deste subtexto não for irrelevante, retorne.
  Subtraia 1 desde o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]

\ Rotina nova criada pelo Dahn para - reverse functions
\ To put o xxx uv a/the yyy para zzz
\ internally we turn this para "to put a/the yyy's xxx para zzz"
Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (função do possessivo reverso):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Ative o detector de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação). \ ignora "atribua" 
  Mova o percorredor (usando diretrizes de compilação). \ ignora "the" ou um artigo definido em português
  Examine um nome usando o percorredor. \ nome do campo
  Mova o percorredor (usando diretrizes de compilação). \ ignora "uv" ou "de"
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo definido).
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for algum função possessiva reversa into, apresente uma mensagem de erro contendo "Erro. O compilador esperava a palavra 'para', mas encontrou o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um terceiro unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Erro. A rotina para que se " junto com a representação interna da rotina seguido de ": já havia sido definida." e o endereço local desta rotina; retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente a mensagem de erro contendo "Erro. O compilador esperava encontrar um artigo indefinido, mas encontrou: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Erro. O compilador detectou a existência de outras listas no final desta função." e o percorredor; retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ por employs

\ Rotina nova criada pelo Dahn para - reverse functions
\ para atribua o xxx uv a/the yyy para zzz
Etapas para que se determine se um percorredor é o início of algum função possessiva reversa:
  Se o detector de erros deste compilador estiver ativo, diga não.
  Se o segmento inicial deste percorredor não for algum atribua, diga não.
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor não for sobre algum reverse-possessive, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

\finalmente  acabou
