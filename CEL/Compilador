\ O compilador copyright © 2006-2021 a ordem osmosiana
\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

 \Este compilador armazena strings em duas partes para que seja fácil trocar o primeiro e o último bytes de uma string, com um pequeno comando como este:
 \ Permute o conteúdo deste caractere inicial desta string com o conteúdo do caractere final desta string.
 \Todos os parâmetros são passados por referência, então a string modificada é retornada na variável passada, que é a maneira natural e óbvia de fazer isso.
 \Por exemplo, se você passar o saleiro para alguém na mesa de jantar e ela usar um pouco, você receberá o saleiro de volta com menos sal do que quando passou.
\Quando um parâmetro é passado "por referência", o chamador e o receptor usam a mesma variável para o parâmetro. 
\Se o receptor modifica a variável do parâmetro, o efeito é visível para a variável do chamador.
\Quando um parâmetro é passado "por valor", o chamador e o receptor têm duas variáveis independentes com o mesmo valor. 
\Se o receptor modifica a variável de parâmetro, o efeito não é visível para o chamador.

\ The EBP (base pointer) and ESP (stack pointer) registers, on the other hand, are used to manipulate the STACK which is an area of memory that you can think of like a stack of dinner plates, with each plate representing a saved register value, or an address somewhere in the program's code, or the address of a variable (that lives somewhere else in memory), or the contents of a variable. As is typical with Windows, the stack grows backways: that is, the address of the "top" of the stack is always less than the address of the "bottom".

\ The ESP register always holds the address of the "top" of the stack. The EBP register holds the address of the "bottom" of the stack for the current routine. By convention, this is how the STACK is used by Plain English (C uses the STACK in a similar way, but pushes the parameters in reverse order):

\ You can see that, once things are set up, a routine’s first parameter will be at the address in the EBP register plus 8, the second parameter at the address in EBP plus 12, etc. And that our local variables will be a the address in the EBP register minus 4, minus 8, etc, depending on the length of each of those variables.

\ THE PROLOG OF EVERY PLAIN ENGLISH ROUTINE BEGINS BY SAVING THE CALLER'S EBP ON THE STACK, JUST ABOVE THE RETURN ADDRESS. 
\ THE EPILOG OF EVERY ROUTINE REMOVES ANY LOCAL VARIABLES, RESTORES THE EBP, AND RETURNS TO THE CALLER, POPPING ANY PARAMETERS AS HE DOES. C programs operate in a similar way.

\ The Intel CPU knows how to PUSH 4-byte values and addresses onto the stack, and how to POP them back off. To get larger things on and off the stack we need to play with the ESP register directly. Subtracting 16 from the address in ESP, for example, makes room for 16 bytes of local data at the "top" of the stack; adding 16 takes those bytes off the stack.

Uma mensagem de erro é uma string.
Uma contagem de nomes é uma contagem.

O temporizador de escrita é um temporizador. \ Um temporizador é uma estrutura com uma contagem, uns intervalos iniciais e uns intervalos totais. \ Um intervalo é um número.
O temporizador de transmutação é um temporizador.
O temporizador de análise/verificação é um temporizador.
O temporizador de resolução de variáveis globais é um temporizador.
O temporizador de resolução de tipos é um temporizador.
O temporizador de operacionalização é um temporizador.
O temporizador de deslocamentos é um temporizador.
O temporizador de vinculação é um temporizador.
O temporizador de ferramentas de catalogação é um temporizador.
O temporizador de compilação do conteúdo das rotinas é um temporizador.
O temporizador de compilação de cabeçalhos de rotina é um temporizador.
O temporizador de etapas de cálculo é um temporizador.
O temporizador de endereçamento é um temporizador.
O temporizador de adição de rotinas pré-definidas de mémoria é um temporizador.
O temporizador de adição de rotinas pré-definidas de inicialização é um temporizador.

A etiqueta de interrupção é uma etiqueta igual a 1.
A etiqueta de demanda externa é uma etiqueta igual a 2.
A etiqueta de demanda indireta é uma etiqueta igual a 3.
A etiqueta de demanda interna é uma etiqueta igual a 4.
A etiqueta de redirecionamento é uma etiqueta igual a 5.
A etiqueta delimitadora de bloco condicional é uma etiqueta igual a 6.
A etiqueta conclusiva é uma etiqueta igual a 7.
A etiqueta de retorno é uma etiqueta igual a 8.
A etiqueta de finalização é uma etiqueta igual a 9.
A etiqueta de acréscimo é uma etiqueta igual a 10.
A etiqueta de decodificação é uma etiqueta igual a 11.
A etiqueta de desvio falso é uma etiqueta igual a 12.
A etiqueta de carregamento de endereço é uma etiqueta igual a 13.
A etiqueta de carregamento de registrador EAX é uma etiqueta igual a 14.
A etiqueta de laço é uma etiqueta igual a 15.
A etiqueta de negação lógica é uma etiqueta igual a 16.
A etiqueta preliminar é uma etiqueta igual a 17.
A etiqueta de inserção de endereço [na stack] é uma etiqueta igual a 18.
A etiqueta de inserção de valor [na stack] é uma etiqueta igual a 19.
A etiqueta de obtenção do registrador EAX é uma etiqueta igual a 20.
A etiqueta de repetição é uma etiqueta igual a 21.
A etiqueta de endereço de rotina é uma etiqueta igual a 22.

O compilador é uma estrutura com
  Um endereço da pasta,
  Um temporizador,
  Um detector de erros, 
  Um mensagem de erro,
  Um endereço do arquivo atual,
  Um número da linha de erro,
  Uma contagem de nomes,
  Um trecho EXE,
  Um trecho de listagem.

Um trecho de listagem é um trecho.
Um detector de erros é um detector.

Um endereço do arquivo atual é um endereço completo.
\Um problema é um número.

Etapas para que se determine se há algum problema de compilação;
Etapas para que se determine se existe algum problema de compilação:
  Se o detector de erros deste compilador estiver ativado, diga sim.

Etapas para que se apresente uma mensagem de erro contendo uma string:
  Se existir algum problema de compilação, retorne.
  Ative o detector de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.

Etapas para que se apresente uma mensagem de erro contendo uma string e um endereço de byte:
  Se existir algum problema de compilação, retorne.
  Ative o detector de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.
  Encontre o endereço do arquivo atual deste compilador e o número da linha de erro deste compilador usando o endereço de byte .
  Se o endereço do arquivo atual deste compilador estiver em branco, retorne.
  Extraia um nome do arquivo desde o endereço do arquivo atual deste compilador.
  Anteponha "Erro no arquivo '" junto com o nome do arquivo seguido de "'. " para a mensagem de erro deste compilador.

Etapas para que se apresente uma mensagem de erro contendo uma string e um percorredor:
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo a string e o caractere inicial deste segmento inicial deste percorredor; retorne.
  Apresente a mensagem de erro contendo a string e o caractere final deste segmento final deste percorredor.

Etapas para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Adicione a rotina de finalização para o tipo.
  Adicione a rotina de alocação para o tipo.
  Adicione a rotina de desalocação para o tipo.
  Adicione a rotina de destruição para o tipo.
 Recomece. [percorra novamente o código acima]

Etapas para que se adicione o rotina de alocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Aloque memória para um " junto com o nome deste tipo para a string do cabeçalho desta rotina. \ traduzir aqui
  Acrescente "Associe o " junto com o nome deste tipo seguido de " usando " para a string do corpo desta rotina. \Nomeie
  Acrescente a quantidade de caracteres deste tipo do conteúdo deste tipo seguido de "." para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução:
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Initialize before run e Run e Finalize after run" para a string do cabeçalho desta rotina.
  Acrescente "Initialize before run. " para a string do corpo desta rotina.
  Acrescente os inicializadores de variáveis globais para a string do corpo desta rotina.
  Acrescente "Execute este programa. " para a string do corpo desta rotina.
  Acrescente os finalizadores de variáveis globais para a string do corpo desta rotina.
  Acrescente "Finalize after run. " para a string do corpo desta rotina.
  Acrescente "Processe ""kernel32.dll"" ""ExitProcess"" com 0. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.
  Compile o corpo of a rotina.

Etapas para que se adicione os tipos primitivos:
  Adicione um tipo primitivo usando "byte" e "bytes" e 1.
  Adicione um outro tipo primitivo usando "estrutura" e "estruturas" e 0.

Um nome plural é um nome.

Etapas para que se adicione um tipo primitivo usando um nome e um nome plural e uma quantidade de caracteres:
  Adicione o tipo primitivo para os tipos usando o nome e o nome plural e o nome. \ o nome do tipo 
  Atribua a quantidade de caracteres à quantidade de caracteres deste tipo primitivo.
  Atribua o tipo primitivo ao tipo base deste tipo primitivo.
  Catalogue o tipo primitivo.

Etapas para que se adicione o rotina de desalocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Desaloque um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo deveria ser finalizado [automaticamente por uma rotina], 
    acrescente "~Finalize o conteúdo de este " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina. 
  \ Chamado quando o tipo precisa ter uma rotina de destruição gerada automaticamente para ele
  Acrescente "Desassocie o " junto com o nome deste tipo seguido de "." para a string do corpo desta rotina. \ Desaloque memória para o
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione o rotina de destruição para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser ignorado, retorne.
  Se o tipo puder ser reduzido para "listas", adicione o rotina de destruição para o tipo (listas); retorne.
  Se o tipo puder ser reduzido para "ponteiro", adicione o rotina de destruição para o tipo (ponteiros); retorne.

Etapas para que se adicione o rotina de destruição para um tipo (ponteiros):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Atribua "Destrua [" junto com o nome deste tipo seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Destrua um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo puder ser reduzido para "ponteiro", acrescente "Destrua o conteúdo de este " junto com o nome deste tipo seguido de "'. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo puder ser reduzido para "listas", acrescente "Destrua o conteúdo de este " junto com o nome deste tipo seguido de "'. " para a string do corpo desta rotina.
  Comece. [a executar o código abaixo]
    Obtenha um campo desde os campos deste tipo do conteúdo deste tipo.
    Se o campo for inexistente, pare.
    Se o detector de referência deste campo estiver ativo, recomece.
    Se o tipo deste campo não deveria ser ignorado, recomece.
    Acrescente "Destrua o " junto com o nome deste campo seguido de " de este " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  Recomece. [percorra novamente o código acima]
  Acrescente "Desaloque o " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina. \ traduzir aqui
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione o rotina de destruição para um tipo (listas):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.  
  Se o first campo destes campos deste tipo for inexistente, apresente uma mensagem de erro contendo "Erro interno #1'"; retorne. \
  Se o tipo deste first campo destes campos deste tipo for inexistente, apresente a mensagem de erro contendo "Erro interno #2'"; retorne.
  Atribua "Destrua [" junto com o nome deste tipo seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Destrua um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o first " junto com o nome deste tipo deste first campo destes campos deste tipo
    junto com " de este " junto com o nome deste tipo seguido de " for inexistente, retorne. " para a string do corpo desta rotina. \ listas duplamente encadeadas
  Atribua o nome deste tipo deste first campo destes campos deste tipo para um nome.
  Acrescente "Atribua o first " junto com o nome junto com " de este "junto com o nome deste tipo seguido de " para um " junto com o nome seguido de ". " para a string do corpo desta rotina.\ traduzir
  Acrescente "Remova o " junto com o nome seguido de " desde o " junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina. 
  Acrescente "Destrua o " junto com o nome seguido de ". " para a string do corpo desta rotina.
  Acrescente "Recomece. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Um nome da DLL é um nome.
Um nome da função é um nome.

Etapas para que se adicione uma função para umas DLLs usando um nome da DLL e um nome da função:
  Encontre uma DLL usando o nome da DLL.
  Se a DLL for inexistente, adicione a DLL para as DLLs usando o nome da DLL.
  Encontre a função usando o nome da função e as funções desta DLL.
  Se a função não for inexistente, retorne.
  Crie a função.
  Acrescente a função para as funções desta DLL.
  Atribua o nome da função ao nome desta função.

Etapas para que se adicione um campo para uns campos usando um nome e um apelido e um nome do tipo e um detector:
  Adicione o campo para o campos usando "campo" e nil.
  Atribua o nome ao nome deste campo.
  Atribua o apelido ao apelido deste campo.
  Atribua o nome do tipo ao nome do tipo deste campo.
  Atribua um detector de referência ao detector de referência deste campo.

Etapas para que se adicione a rotina de finalização para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser finalizado, retorne.
  Se o nome deste tipo for "string", adicione a rotina de finalização para o tipo (cadeia de caracteres); retorne.
  Se o nome deste tipo for "texto", adicione a rotina de finalização para o tipo (cadeia de caracteres); retorne.
  Se o nome deste tipo for "cadeia de caracteres", adicione a rotina de finalização para o tipo (cadeia de caracteres); retorne.
  Se o tipo puder ser reduzido para "string", retorne. \ impede a geração de finalizaores para tipos derivados de string
  Se o tipo puder ser reduzido para "texto", retorne.
  Se o tipo puder ser reduzido para "cadeia de caracteres", retorne.
  Adicione a rotina de finalização para o tipo (estrutura).

Etapas para que se adicione a rotina de finalização para um tipo (estrutura):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> push the 4 bytes value in EAX onto the stack
  \The push instruction places its operand onto the top of the hardware supported stack in memory. 
  \Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location sob address [ESP]. 
  \ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde high addresses to lower addresses.
  Comece. [a executar o código abaixo]
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, pare.
    Se o tipo deste campo não deveria ser finalizado, recomece.
    Acrescente "~Finalize o " junto com o nome deste tipo seguido de "'s " junto com o nome deste campo seguido de ". " para a string do corpo desta rotina.
  Recomece. [percorra novamente o código acima]
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> pop the top element of the stack into memory ar the four bytes starting at location EAX.
  \  \pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location). 
  \It first moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione a rotina de finalização para um tipo (cadeia de caracteres):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \ push eax -> push the 4 bytes value in EAX onto the stack
  \ Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location sob endereço [ESP]. 
  \ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde high addresses to lower addresses.
  Acrescente "Desassocie o caractere inicial de esta string . " para a string do corpo desta rotina. \\ traduzir string aqui  
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax -> pop the top element of the stack into memory at the four bytes starting at location EAX.
  \pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location). 
  \ It first moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho of a rotina.

Etapas para que se adicione um fragmento usando uma etiqueta:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.

Etapas para que se adicione um fragmento usando uma etiqueta e uma função:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a função à função deste fragmento.

Etapas para que se adicione um fragmento usando uma etiqueta e um detector:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua o detector ao detector deste fragmento.

Etapas para que se adicione um fragmento usando uma etiqueta e uma rotina:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a rotina à rotina deste fragmento.
  Compile o corpo of a rotina.

Um detector de compilação é um detector.

Etapas para que se adicione um fragmento usando uma etiqueta e uma variável:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Ative o detector de compilação na variável.

Etapas para que se adicione um fragmento usando uma etiqueta e uma variável e uma segunda variável:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Atribua a segunda variável à segunda variável deste fragmento.
  Ative o detector de compilação na variável.
  Ative o detector de compilação na segunda variável.

Etapas para que se adicione um fragmento usando uma etiqueta e uma variável e um número:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragmento; retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Atribua o número ao número deste fragmento.
  Ative o detector de compilação na variável.

Etapas para que se adicione uma DLL para umas DLLs usando um nome da DLL:
  Crie a DLL.
  Acrescente a DLL para as DLLs.
  Atribua o nome da DLL ao nome desta DLL.

Etapas para que se adicione uma variável intermediária usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente, esvazie a variável intermediária; retorne.
  Adicione a variável intermediária para as variáveis locais desta rotina utilizada atualmente usando "local" e o endereço local.
  Gere o nome desta variável intermediária usando "~I".
  Atribua o nome do tipo ao nome do tipo desta variável intermediária.
  Destrinche a variável intermediária.

Etapas para que se adicione um valor literal para umas variáveis usando um endereço local:
  Adicione o valor literal como uma variável para as variáveis usando "literal" e o endereço local.
  Gere o nome deste valor literal usando "~L".

Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando uma expressão matematica:
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  Atribua a frase desta expressão matematica à string desta unidade semântica.
  Atribua a variável desta expressão matematica à variável desta unidade semântica.
  Se a variável desta expressão matematica não for inexistente, atribua o tipo desta expressão matematica ao tipo desta unidade semântica.

  \# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando uma string: \ creio que isso aqui ajude nas funções
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.  
  \\ conjunções
  Se a string for "e", atribua "e" à string desta unidade semântica; retorne. \ and
  Se a string for "ou", atribua "ou" à string desta unidade semântica; retorne. \ or
  \ usando
  Se a string for "desde", atribua "usando" à string desta unidade semântica; retorne.  
  \Se a string for "de", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "dada", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "dado", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "dadas", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "dados", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "com", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "usando", atribua "usando" à string desta unidade semântica; retorne.
  Se a string for "contendo", atribua "usando" à string desta unidade semântica; retorne.
  \\ para
  \Se a string for "em", atribua "para" à string desta unidade semântica; retorne. 
  Se a string for "a", atribua "para" à string desta unidade semântica; retorne. \  ver isso aqui com calma
  Se a string for "para", atribua "para" à string desta unidade semântica; retorne.
  \\ VERBO SER/ESTAR
  Se a string for "é", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "está", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "for", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "foi", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "foram", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "forem", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estiver", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estiverem", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estamos", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "há", atribua "há" à string desta unidade semântica; retorne.
  Se a string for "houver", atribua "há" à string desta unidade semântica; retorne.
  \Se a string for "seja", atribua "é" à string desta unidade semântica; retorne.
  \Se a string for "tem", atribua "tem" à string desta unidade semântica; retorne.
  \Se a string for "tiver", atribua "tem" à string desta unidade semântica; retorne.
  Se a string for "são", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estão", atribua "é" à string desta unidade semântica; retorne.  
  Se a string for "forem", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "estiverem", atribua "é" à string desta unidade semântica; retorne.
  Se a string for "puder", atribua "pode" à string desta unidade semântica; retorne.
  Se a string for "puderem", atribua "pode" à string desta unidade semântica; retorne.
  Se a string for "existe", atribua "existe" à string desta unidade semântica; retorne.
  Se a string for "existir", atribua "existe" à string desta unidade semântica; retorne.
  Se a string for "há", atribua "há" à string desta unidade semântica; retorne.
  Se a string for "houver", atribua "há" à string desta unidade semântica; retorne.
  Se a string for "possuir", atribua "possui" à string desta unidade semântica; retorne.
  \\ allocates e destroys  
  \Se a string for "aloque", atribua "allocate" à string desta unidade semântica; retorne.  
  Se a string for "pelo", atribua "por o" à string desta unidade semântica; retorne.
  Se a string for "pela", atribua "por o" à string desta unidade semântica; retorne.  
  \Se a string for "desaloque", atribua "desaloque" à string desta unidade semântica; retorne.
  \Se a string for "esvazie", atribua "deallocate" à string desta unidade semântica; retorne.
  \Se a string for "destrua", atribua "destrua" à string desta unidade semântica; retorne.
  \ é
  Se a string for "is", atribua "é" à string desta unidade semântica; retorne.
  \ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
  Se a string for "backward", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "backwards", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "counterclockwise", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "counter-clockwise", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "anticlockwise", atribua "backward" à string desta unidade semântica; retorne.
  Se a string for "anti-clockwise", atribua "backward" à string desta unidade semântica; retorne.
  \ sobre
  Se a string for "sob", atribua "sobre" à string desta unidade semântica; retorne.
  Se a string for "on", atribua "sobre" à string desta unidade semântica; retorne.
  Se a string for "sobre", atribua "sobre" à string desta unidade semântica; retorne.
  \ other
  Atribua a string à string desta unidade semântica.

Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando um tipo:
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  Atribua o tipo ao tipo desta unidade semântica.

Etapas para que se adicione push fragmentos usando umas unidades semânticas:
  Se a rotina utilizada atualmente for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde as unidades semânticas (regressivamente).
    Se a unidade semântica for inexistente, retorne.
    Se a variável desta unidade semântica for inexistente, recomece.
    Se o subtexto atual desta unidade semântica não estiver em branco, recomece.
    Se o tipo atual desta unidade semântica for inexistente, recomece.
    Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável desta unidade semântica.
  Recomece. [percorra novamente o código acima]

Etapas para que se adicione o atribua ou converta fragmentos usando uma variável e uma segunda variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Encontre uma rotina usando "Atribua" e o tipo desta variável e "para" e o tipo desta segunda variável.
  Se a rotina for inexistente, encontre a rotina usando "Converta" e o tipo desta variável e "para" e o tipo desta segunda variável.
  Se a rotina não for inexistente, adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina; retorne.
  \ Mensagem de Erro
  Adicione uma unidade semântica para umas unidades semânticas usando "Atribua/Converta".
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando "para/a".
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Apresente uma mensagem de erro contendo "Eu não sei como: " junto com a representação interna da rotina seguido de "." e o endereço local.

Etapas para que se adicione uma rotina para umas rotinas usando um endereço local:
  Crie a rotina.
  Acrescente a rotina para as rotinas.
  Atribua o endereço local ao endereço local desta rotina.

Etapas para que se adicione um scratch usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente, esvazie o scratch; retorne.
  Adicione o scratch para as variáveis locais desta rotina utilizada atualmente usando "scratch" e o endereço local.
  Gere o nome deste scratch usando "~S".
  Atribua o nome do tipo ao nome do tipo deste scratch.
  Destrinche o scratch.

Etapas para que se adicione fragmentos diversos usando uma string e uma variável e uma segunda string e uma segunda variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "#29. A rotina para que se '" junto com a representação interna da rotina seguido de "' não foi encontrada." e o endereço local; retorne.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione fragmentos diversos usando uma string e uma variável e uma segunda string e uma segunda variável e uma terceira string e um terceira variável e um endereço de byte :
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e o terceira variável.
  Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um terceiro fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Adicione uma quinta unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma sexta unidade semântica para as unidades semânticas usando o tipo desta terceira variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "#30. A rotina para que se '" junto com a representação interna da rotina seguido de "' não pôde ser localizada." e o endereço de byte; retorne.
  Adicione um quarto fragmento usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione um arquivo fonte para uns arquivos fontes usando um endereço completo:
  Crie o arquivo fonte.
  Acrescente o arquivo fonte para os arquivos fontes.
  Atribua o endereço completo ao endereço completo deste arquivo fonte.

Etapas para que se adicione two fragmentos usando uma string e uma variável e um endereço local:
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro. A rotina para que se '" junto com a representação interna da rotina seguido de "' ainda não foi definida." e o endereço local; retorne.
  Adicione um segundo fragmento usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione um tipo para uns tipos usando um endereço local:
  Crie o tipo.
  Acrescente o tipo para o tipos.
  Atribua o endereço local ao endereço local deste tipo.

Etapas para que se adicione um tipo para uns tipos usando um nome e um nome plural e um nome do tipo primitivo:
  Adicione o tipo para os tipos usando o nome e o nome plural e o nome do tipo primitivo e nil.

Etapas para que se adicione um tipo para uns tipos usando um nome e um nome plural e um nome do tipo primitivo e um endereço local:
  Crie o tipo.
  Acrescente o tipo para o tipos. \ Um tipo é uma lista duplamente encadeada
  Atribua o endereço local ao endereço local deste tipo.
  Atribua o nome ao nome deste tipo.
  Atribua o nome plural ao nome plural deste tipo.
  Atribua o nome do tipo primitivo ao nome do tipo primitivo deste tipo.

Etapas para que se adicione uma variável para umas variáveis usando um categoria e um endereço local:
  Crie a variável usando a categoria.
  Acrescente a variável para as variáveis.
  Atribua o endereço local ao endereço local desta variável.

Etapas para que se enderece umas funções:
  Obtenha uma função desde as funções.
  Se a função for inexistente, retorne.
  Enderece a função.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece uma função:
  Atribua o endereço do nome usado atualmente ao endereço do nome desta função.
  Atribua a quantidade de caracteres deste nome deste função mais 3 para um número.
  Arredonde o número para cima usando o múltiplo imediato de 2.
  Adicione o número para o endereço do nome usado atualmente.
  Atribua o endereço pré-calculado atual ao endereço thunk desta função.
  Atribua o image base mais o endereço pré-calculado atual ao endereço desta função.
  Adicione 4 para o endereço pré-calculado atual.

Etapas para que se enderece um fragmento usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se o fragmento for inexistente, retorne.
  Atribua o image base mais o endereço ao endereço deste fragmento.
  Se a etiqueta deste fragmento for a etiqueta de inserção de endereço [na stack], adicione 7 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda interna, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de endereço, adicione 12 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de acréscimo, adicione 10 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de redirecionamento, adicione 14 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de desvio falso, adicione 9 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de negação lógica, adicione 3 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de retorno, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de repetição, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de interrupção, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta preliminar, enderece o fragmento usando o endereço (etapa preliminar); retorne.
  Se a etiqueta deste fragmento for a etiqueta conclusiva, enderece o fragmento usando o endereço (etapa conclusiva); retorne.
  Se a etiqueta deste fragmento for a etiqueta de decodificação, adicione a quantidade de caracteres deste código deste fragmento para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de inserção de valor [na stack], enderece o fragmento usando o endereço (empilhamento de valor); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda externa, adicione 6 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de registrador EAX, adicione 5 para o endereço; retorne. \ Era 8 quando "load eax" aceitava variáveis; agora "load eax" só aceita números
  Se a etiqueta deste fragmento for a etiqueta de obtenção do registrador EAX, enderece o fragmento usando o endereço (registrador EAX); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda indireta, adicione 8 para o endereço; retorne.
  Se a etiqueta deste fragmento for a etiqueta de endereço de rotina, adicione 12 para o endereço; retorne.

Etapas para que se enderece um fragmento usando um endereço (etapa conclusiva):
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.
  Adicione 6 para o endereço.

Etapas para que se enderece um fragmento usando um endereço (etapa preliminar):
  Adicione 3 para o endereço.
  Se o tamanho local desta rotina utilizada atualmente não for 0, adicione 10 para o endereço.
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.

Etapas para que se enderece um fragmento usando um endereço (empilhamento de valor):
  Adicione 6 para o endereço.
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #3."; retorne.
  Se o tipo desta variável deste fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #4"; retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, adicione 2 para o endereço; retorne.
  Se a quantidade de caracteres for 2, adicione 3 para o endereço; retorne.
  Se a quantidade de caracteres for 1, adicione 4 para o endereço; retorne.
  Apresente a mensagem de erro contendo "Erro interno #5".

Etapas para que se enderece um fragmento usando um endereço (registrador EAX):
  Adicione 6 para o endereço.
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #6"; retorne.
  Se o tipo desta variável deste fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #7"; retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, adicione 2 para o endereço; retorne.
  Se a quantidade de caracteres for 2, adicione 3 para o endereço; retorne.
  Se a quantidade de caracteres for 1, adicione 2 para o endereço; retorne.
  Apresente a mensagem de erro contendo "Erro interno #8".

Etapas para que se enderece uns fragmentos usando um endereço:
  Se existir algum problema de compilação, retorne.
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Enderece o fragmento usando o endereço.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece uma DLL:
  Atribua o endereço do nome usado atualmente ao endereço do nome desta DLL.
  Atribua o endereço do cabeçalho usado atualmente ao endereço do cabeçalho desta DLL.
  Atribua o endereço do nome usado atualmente ao endereço do nome deste cabeçalho da DLL desta DLL.
  Atribua a quantidade de caracteres deste nome desta DLL mais 1 para um número.
  Arredonde o número para cima usando o múltiplo imediato de 2.
  Adicione o número para o endereço do nome usado atualmente.
  Adicione a magnitude dum cabeçalho da DLL para o endereço do cabeçalho usado atualmente. 
  Atribua o endereço pré-calculado atual ao primeiro endereço thunk de memória deste cabeçalho da DLL desta DLL.
  Enderece as funções desta DLL.
  Adicione 4 para o endereço pré-calculado atual.

Etapas para que se enderece umas DLLs usando um endereço:
  Atribua o endereço ao endereço do cabeçalho usado atualmente.
  Atribua as contagem destas DLLs para uma contagem.
  Adicione 1 para a contagem.
  Multiplique a contagem pela magnitude dum cabeçalho da DLL.
  Atribua o endereço mais a contagem ao endereço pré-calculado atual.
  Obtenha uma segunda contagem usando as DLLs (todas as funções mais os marcadores).
  Multiplique a segunda contagem por 4.
  Atribua o endereço pré-calculado atual mais a segunda contagem ao endereço do nome usado atualmente.
  Comece. [a executar o código abaixo]
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, pare.
    Enderece a DLL.
  Recomece. [percorra novamente o código acima]
  Atribua o endereço do nome usado atualmente menos o endereço para um número.
  Adicione o número para o endereço.

Um endereço é um número.

Etapas para que se enderece uma rotina usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o representação de emprego desta rotina não estiver em branco, retorne. \ employs são addressed later
  Se o detector de compilação desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Atribua o image base mais o endereço ao endereço desta rotina.
  Enderece os fragmentos desta rotina usando o endereço.
  Arredonde o endereço para cima usando o múltiplo imediato de 4.

Etapas para que se enderece umas rotinas usando um endereço:
  Se existir algum problema de compilação, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, pare.
  Enderece a rotina usando o endereço.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece uma variável usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Se o detector de compilação desta variável não estiver ativo, retorne.
  Atribua o image base mais o endereço ao endereço desta variável.
  Adicione a quantidade de caracteres deste tipo desta variável para o endereço.
  Se o tipo desta variável puder ser reduzido para "string", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Se o tipo desta variável puder ser reduzido para "cadeia de caracteres", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Se o tipo desta variável puder ser reduzido para "texto", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Arredonde  para cima o endereço usando o múltiplo imediato de 4.

Etapas para que se enderece umas variáveis usando um endereço:
  Se existir algum problema de compilação, retorne.
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Enderece a variável usando o endereço.
  Recomece. [percorra novamente o código acima]

Etapas para que se acrescente uma função para um trecho (com separador):
  Se a função for inexistente, acrescente "(entrada não inicializada)" para o trecho (com separador); retorne.
  Acrescente o nome desta função para o trecho (com separador).

Etapas para que se acrescente um detector para um trecho (com separador):
  Converta o detector para uma string.
  Acrescente a string para o trecho (com separador).

Etapas para que se acrescente os finalizadores de variáveis globais para uma string:
  Obtenha uma variável global desde as variáveis globais.
  Se a variável global for inexistente, retorne.
  Se o detector de compilação desta variável global não estiver ativo, recomece.
  Se o tipo desta variável global não deveria ser finalizado, recomece.
  Acrescente "~Finalize o " junto com o nome desta variável global seguido de ". " para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se acrescente os inicializadores de variáveis globais para uma string:
  Obtenha uma variável global desde as variáveis globais.
  Se a variável global for inexistente, retorne.
  Se o valor literal desta variável global for inexistente, recomece.
  Se o detector de compilação desta variável global não estiver ativo, recomece.
  Desative um detector.
  Acrescente o texto inicializador desta variável global para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se acrescente uma unidade semântica para uma representação interna da rotina :
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, acrescente o caractere de espaço para a representação interna da rotina.
  Se o tipo desta unidade semântica não for inexistente, acrescente "[" e o nome deste tipo desta unidade semântica e "]" para a representação interna da rotina (fast); retorne. \ moniker
  Se a string desta unidade semântica não estiver em branco, acrescente a string desta unidade semântica para a representação interna da rotina ; retorne.

Etapas para que se acrescente uma unidade semântica para uma representação interna da rotina (inserção de colchetes):
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, acrescente o caractere de espaço para a representação interna da rotina.
  Se o subtexto atual desta unidade semântica não estiver em branco, acrescente o subtexto atual desta unidade semântica para a representação interna da rotina ; retorne.
  Se o tipo atual desta unidade semântica não for inexistente, acrescente "[" e o nome deste tipo atual desta unidade semântica e "]" para a representação interna da rotina (fast); retorne.

Etapas para que se acrescente um número para um trecho (cifra hexadecimal com separador):
  Converta o número para uma cifra hexadecimal.
  Acrescente a cifra hexadecimal para o trecho (com separador).

Etapas para que se acrescente um número para um trecho (com separador):
  Converta o número para uma string.
  Acrescente a string para o trecho (com separador).

Etapas para que se acrescente uma proporção para um trecho (com separador):
  Converta a proporção para uma string.
  \ Se a string for "0", acrescente "---" para o trecho; retorne.
  Acrescente a string para o trecho (com separador).

Etapas para que se acrescente uma rotina para um trecho (com separador):
  Se a rotina for inexistente, acrescente "(rotina inexistente)" para o trecho (com separador); retorne.
  Acrescente a representação interna da rotina deste rotina para o trecho (com separador).

\ Etapas para que se acrescente 3 strings distintas para uma string.
Etapas para que se acrescente uma string e uma segunda string e uma terceira string para uma quarta string (fast):
  Atribua a quantidade de caracteres desta quarta string para uma quantidade de caracteres. \ Atribua a quantidade de caracteres da 4ª string para uma quantidade de caracteres. 
  Adicione a quantidade de caracteres desta string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 1ª string para a quantidade de caracteres. 
  Adicione a quantidade de caracteres desta segunda string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 2ª string para a quantidade de caracteres. 
  Adicione a quantidade de caracteres desta terceira string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 3ª string para a quantidade de caracteres. 
  Reaponte um ponteiro usando a quantidade de caracteres.
  Atribua o ponteiro para um endereço de byte .
  Copie bytes desde o caractere inicial desta quarta string para o endereço de byte pelo quantidade de caracteres desta quarta string.
  Adicione a quantidade de caracteres desta quarta string para o endereço de byte .
  Copie bytes desde o caractere inicial desta string para o endereço de byte pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o endereço de byte .
  Copie bytes desde o caractere inicial desta segunda string para o endereço de byte pelo quantidade de caracteres desta segunda string.
  Adicione a quantidade de caracteres desta segunda string para o endereço de byte .
  Copie bytes desde o caractere inicial desta terceira string para o endereço de byte pelo quantidade de caracteres desta terceira string.
  Desassocie o caractere inicial desta quarta string.
  Atribua o ponteiro ao caractere inicial desta quarta string.
  Atribua o ponteiro mais a quantidade de caracteres menos 1 ao caractere final desta quarta string.

Etapas para que se acrescente uma string para um trecho (com separador):
  Acrescente a string para o trecho.
  Acrescente " | " para o trecho.

Etapas para que se acrescente uma etiqueta para um trecho (geral):
  Se a etiqueta for a etiqueta de interrupção, acrescente "Interrupção do Laço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda externa, acrescente "Demanda Externa" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda indireta, acrescente "Demanda Indireta" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda interna, acrescente "Demanda Interna" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de redirecionamento, acrescente "Redirecionamento" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta delimitadora de bloco condicional, acrescente "Fim de bloco condicional" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta conclusiva, acrescente "Epílogo" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de retorno, acrescente "Retorno de Rotina" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de finalização, acrescente "Finalização" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de acréscimo, acrescente "Incremento" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de decodificação, acrescente "Decodificação" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de desvio falso, acrescente "Desvio de condição insatisfeita" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de carregamento de endereço, acrescente "Carregamento de endereço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de carregamento de registrador EAX, acrescente "Atribuição EAX" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de laço, acrescente "Loop" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de negação lógica, acrescente "Negação Lógica" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta preliminar, acrescente "Prólogo" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de inserção de endereço [na stack], acrescente "Empilhamento de endereço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de inserção de valor [na stack], acrescente "Empilhamento de valor" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de obtenção do registrador EAX, acrescente "Requisição EAX" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de repetição, acrescente "Repetição" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de endereço de rotina, acrescente "Endereço de Rotina" para o trecho (com separador); retorne.
  [Caso não seja nenhum dessas etiquetas, então:] Acrescente "?" para o trecho (com separador).

Etapas para que se acrescente um tipo para um trecho (com separador):
  Se o tipo for inexistente, acrescente "(tipo não inicializado)" para o trecho (com separador); retorne.
  Acrescente o nome deste tipo para o trecho (com separador).

Etapas para que se acrescente uma variável para um trecho (com separador):
  Se a variável for inexistente, acrescente "(variável não inicializada)" para o trecho (com separador); retorne.
  Acrescente o nome desta variável para o trecho (com separador).

Etapas para que se determine se uma string é alguma contração de preposição com artigo definido:
  Se a string for "do", diga sim.
  Se a string for "da", diga sim.
  Se a string for "dos", diga sim.
  Se a string for "das", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de concatenação contraído usando um percorredor:
  Se o segmento inicial deste percorredor de contrações for "seguido", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "seguida", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "junto", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "acompanhado", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for uma variável, recue o percorredor.
  Se o segmento inicial deste percorredor de contrações for alguma contração de preposição com artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string está precisando ser decomposta:
  Lance um percorredor sobre a string.
  Se a string for algum operador de concatenação contraído usando o percorredor, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se acrescente uma string para uma segunda string usando uma terceira string (para expandir contrações):
  \# contrações
  Se a string for "ao", acrescente "a o" para a segunda string; retorne.
  Se a string for "à", acrescente "a a" para a segunda string; retorne.
  Se a string for "aos", acrescente "a os" para a segunda string; retorne.
  Se a string for "às", acrescente "a as" para a segunda string; retorne.
  \Se a string estiver precisando ser decomposta, acrescente "de o" para a segunda string; retorne.
  \Se a string for "dos", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de os" para a segunda string; exit
  \Se a string for "da", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de a" para a segunda string; exit
  \Se a string for "das", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, acrescente "de as" para a segunda string; exit
  \Se a string for "do", acrescente "de o" para a segunda string; retorne.
  \Se a string for "da", acrescente "de a" para a segunda string; retorne.
  \Se a string for "dos", acrescente "de os" para a segunda string; retorne.
  \Se a string for "das", acrescente "de as" para a segunda string; retorne.
  Se a string for "dum", acrescente "de esse" para a segunda string; retorne.
  Se a string for "duma", acrescente "de essa" para a segunda string; retorne.
  Se a string for "dumas", acrescente "de esses" para a segunda string; retorne.
  Se a string for "duns", acrescente "de esses" para a segunda string; retorne.
  Se a string for "daqui", acrescente "de aqui" para a segunda string; retorne.
  Se a string for "dali", acrescente "de ali" para a segunda string; retorne.
  Se a string for "dele", acrescente "de ele" para a segunda string; retorne.
  Se a string for "dela", acrescente "de ela" para a segunda string; retorne.
  Se a string for "desse", acrescente "de esse" para a segunda string; retorne.
  Se a string for "dessa", acrescente "de essa" para a segunda string; retorne.
  Se a string for "desses", acrescente "de esses" para a segunda string; retorne.
  Se a string for "dessas", acrescente "de essas" para a segunda string; retorne.
  Se a string for "deste", acrescente "de este" para a segunda string; retorne.
  Se a string for "desta", acrescente "de esta" para a segunda string; retorne.
  Se a string for "destes", acrescente "de estes" para a segunda string; retorne.
  Se a string for "destas", acrescente "de estas" para a segunda string; retorne.
  Se a string for "disso", acrescente "de isso" para a segunda string; retorne.
  Se a string for "disto", acrescente "de isto" para a segunda string; retorne.
  Se a string for "nesse", acrescente "em esse" para a segunda string; retorne.
  Se a string for "nesses", acrescente "em esses" para a segunda string; retorne.
  Se a string for "neste", acrescente "em este" para a segunda string; retorne.
  Se a string for "nestes", acrescente "em estes" para a segunda string; retorne.
  Se a string for "nisso", acrescente "em isso" para a segunda string; retorne.
  Se a string for "nisto", acrescente "em isto" para a segunda string; retorne.
  Se a string for "nessa", acrescente "em essa" para a segunda string; retorne.
  Se a string for "nessas", acrescente "em essas" para a segunda string; retorne.
  Se a string for "nesta", acrescente "em esta" para a segunda string; retorne.
  Se a string for "nestas", acrescente "em estas" para a segunda string; retorne.
  \Se a string for "donde", acrescente "de onde" para a segunda string; retorne.
  \Se a string for "dentre", acrescente "de entre" para a segunda string; retorne.
  \Se a string for "dantes", acrescente "de antes" para a segunda string; retorne.
  Se a string for "dalguém", acrescente "de alguém" para a segunda string; retorne.
  Se a string for "dalgum", acrescente "de um" para a segunda string; retorne.
  Se a string for "dalguma", acrescente "de uma" para a segunda string; retorne.
  Se a string for "dalguns", acrescente "de uns" para a segunda string; retorne.
  Se a string for "dalgumas", acrescente "de umas" para a segunda string; retorne.
  Se a string for "nalgum", acrescente "em um" para a segunda string; retorne.
  Se a string for "nalguma", acrescente "em uma" para a segunda string; retorne.
  Se a string for "nalguns", acrescente "em uns" para a segunda string; retorne.
  Se a string for "nalgumas", acrescente "em umas" para a segunda string; retorne.
  Se a string for "doutro", acrescente "de outro" para a segunda string; retorne.
  Se a string for "doutra", acrescente "de outra" para a segunda string; retorne.
  Se a string for "doutros", acrescente "de outros" para a segunda string; retorne.
  Se a string for "doutras", acrescente "de outras" para a segunda string; retorne.
  Se a string for "noutro", acrescente "em outro" para a segunda string; retorne.
  Se a string for "noutra", acrescente "em outra" para a segunda string; retorne.
  Se a string for "noutros", acrescente "em outros" para a segunda string; retorne.
  Se a string for "noutras", acrescente "em outras" para a segunda string; retorne.
  \# "no" pode ser uma negação em inglês.
  \Se a string deveria ser expandida usando a terceira string (análise de termos compostos), atribua "desde" para a string; atribua "" para a segunda string; retorne.
  Se a string for "na", acrescente "em a" para a segunda string; retorne.
  Se a string for "no", acrescente "em o" para a segunda string; retorne.
  Se a string for "nos", acrescente "em os" para a segunda string; retorne.
  Se a string for "nas", acrescente "em as" para a segunda string; retorne.
  \Se a string for "noutro", acrescente "em outro" para a segunda string; retorne.
  \Se a string for "noutra", acrescente "em outra" para a segunda string; retorne.
  \Se a string for "noutros", acrescente "em outros" para a segunda string; retorne.
  \Se a string for "noutras", acrescente "em outras" para a segunda string; retorne.
  Se a string for "num", acrescente "em um" para a segunda string; retorne.
  Se a string for "numa", acrescente "em uma" para a segunda string; retorne.
  Se a string for "nuns", acrescente "em uns" para a segunda string; retorne.
  Se a string for "numas", acrescente "em umas" para a segunda string; retorne.
  Se a string for "pelo", acrescente "por o" para a segunda string; retorne.
  Se a string for "pela", acrescente "por a" para a segunda string; retorne.
  Se a string for "pelos", acrescente "por os" para a segunda string; retorne.
  Se a string for "pelas", acrescente "por as" para a segunda string; retorne.
  Acrescente a string para a segunda string.

Etapas para que se acrescente a instrução de carregamento de endereço para um texto hexadecimal usando uma variável:
  \ loads para edx
  Se a variável for inexistente, acrescente $C7C200000000 para o texto hexadecimal; retorne. \ mov edx,0
  Se a categoria desta variável for "global", acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; retorne. \ mov edx,the endereço da variável
  Se a categoria desta variável for "literal", acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; retorne. \ mov edx,the endereço da variável
  Se a categoria desta variável for "local", acrescente $8D95 e o deslocamento desta variável para o texto hexadecimal; retorne. \ lea edx,[ebp+ the deslocamento da variável]
  Se a categoria desta variável for "scratch", acrescente $8B95 e o deslocamento desta variável para o texto hexadecimal; retorne. \ mov edx, [ebp+ the deslocamento da variável]
  Se a categoria desta variável não for "parâmetro", apresente uma mensagem de erro contendo "Erro interno#9"; retorne.
  Se o detector de passagem por-valor desta variável estiver ativo, acrescente $8D95 e o deslocamento desta variável para o texto hexadecimal; retorne. \ lea edx,[ebp+the deslocamento da variável]
  Acrescente $8B95 e o deslocamento desta variável para o texto hexadecimal. \ mov edx,[ebp+ the deslocamento da variável]

Etapas para que se acrescente um texto hexadecimal e um endereço para um fragmento:
  \ Processe ou Salto
  Atribua o endereço para um número.
  Subtraia o endereço deste fragmento desde o número.
  Subtraia a quantidade de caracteres deste código deste fragmento desde o número.
  Subtraia a quantidade de caracteres deste texto hexadecimal desde o número.
  Subtraia 4 desde o número.
  Acrescente o texto hexadecimal e o número para o código deste fragmento.

Etapas para que se acrescente um texto hexadecimal e um número e um segundo texto hexadecimal para um terceiro texto hexadecimal:
  Acrescente o texto hexadecimal para o terceiro texto hexadecimal.
  Converta o número para um quarto texto hexadecimal.
  Acrescente o quarto texto hexadecimal para o terceiro texto hexadecimal.
  Acrescente o segundo texto hexadecimal para o terceiro texto hexadecimal.

Etapas para que se acrescente um texto hexadecimal e um número e um segundo número para um segundo texto hexadecimal:
  Acrescente o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Acrescente o terceiro texto hexadecimal para o segundo texto hexadecimal.
  Converta o segundo número para um quarto texto hexadecimal.
  Acrescente o quarto texto hexadecimal para o segundo texto hexadecimal.

Etapas para que se acrescente um texto hexadecimal e um detector para um segundo texto hexadecimal;
Etapas para que se acrescente um texto hexadecimal e um número para um segundo texto hexadecimal:
  Acrescente o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Acrescente o terceiro texto hexadecimal para o segundo texto hexadecimal.

Etapas para que se disponibilize bytes usando um ponteiro e uma quantidade de caracteres e um trecho e um deslocamento:
  Atribua o caractere inicial deste trecho mais o deslocamento para um segundo ponteiro.
  Copie bytes desde o ponteiro para o segundo ponteiro pelo quantidade de caracteres.

Etapas para que se disponibilize um cabeçalho DOS para um trecho:
  Disponibilize bytes usando o endereçamento deste cabeçalho DOS e o magnitude deste cabeçalho DOS e o trecho e 0.

Etapas para que se disponibilize umas funções para um trecho:
  Obtenha uma função desde as funções.
  Se a função for inexistente, retorne.
  Disponibilize a função ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize uma função para um trecho:
  Disponibilize bytes usando o endereçamento deste endereço do nome desta função e 4 e o trecho e o endereço thunk desta função.
  Atribua o endereço do nome desta função mais 2 para um endereço.
  Disponibilize o nome desta função ao trecho sob o endereço.

Etapas para que se disponibilize um fragmento para um trecho:
  Se o código deste fragmento estiver em branco, retorne.
  Atribua o endereço deste fragmento menos o image base para um endereço.
  Disponibilize o código deste fragmento ao trecho sob o endereço.

Etapas para que se disponibilize uns fragmentos para um trecho:
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Disponibilize o fragmento ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize uma DLL para um trecho:
  Disponibilize bytes usando o endereçamento deste cabeçalho da DLL desta DLL e o magnitude deste cabeçalho da DLL desta DLL e o trecho e o endereço do cabeçalho desta DLL.
  Disponibilize o nome desta DLL ao trecho sob o endereço do nome desta DLL.
  Disponibilize as funções desta DLL ao trecho.

Etapas para que se disponibilize umas DLLs para um trecho:
  Obtenha uma DLL desde as DLLs.
  Se a DLL for inexistente, retorne.
  Disponibilize a DLL ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize um Cabeçalho PE para um trecho:
  Disponibilize bytes usando o endereçamento deste Cabeçalho PE e o magnitude deste Cabeçalho PE e o trecho e 256.

Etapas para que se disponibilize uma rotina para um trecho:
  Se o detector de compilação desta rotina não estiver ativo, retorne.
  Disponibilize os fragmentos desta rotina ao trecho.

Etapas para que se disponibilize umas rotinas para um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Disponibilize a rotina ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize uma string para um trecho sob um endereço:
  Disponibilize bytes usando o caractere inicial desta string e a quantidade de caracteres desta string e o trecho e o endereço.

Etapas para que se disponibilize uma variável para um trecho:
  Se o detector de compilação desta variável não estiver ativo, retorne.
  Se o tipo desta variável puder ser reduzido para "string", disponibilize a variável ao trecho (como um texto); retorne.
  Se o tipo desta variável puder ser reduzido para "cadeia de caracteres", disponibilize a variável ao trecho (como um texto); retorne.
  Se o tipo desta variável puder ser reduzido para "texto", disponibilize a variável ao trecho (como um texto); retorne.
  Atribua o endereço desta variável menos o image base para um endereço. \ Atribua a diferença entre o endereço da variável e a base da imagem para um endereço.
  Disponibilize o data desta variável ao trecho sob o endereço.

Etapas para que se disponibilize uma variável para um trecho (como um texto):
  Atribua o endereço desta variável menos o image base para um endereço.
  Atribua a quantidade de caracteres deste data desta variável para uma quantidade de caracteres.
  Atribua o endereço para um segundo endereço.
  Adicione a magnitude dum protótipo de string para o segundo endereço.
  Adicione o image base para o segundo endereço.
  Atribua 0 ao caractere inicial deste protótipo de string.
  Atribua -1 ao caractere final deste protótipo de string.
  Se a quantidade de caracteres não for 0, atribua o segundo endereço ao caractere inicial deste protótipo de string.
  Se a quantidade de caracteres não for 0, atribua o caractere inicial deste protótipo de string mais a quantidade de caracteres menos 1 ao caractere final deste protótipo de string.
  Disponibilize bytes usando o endereçamento deste protótipo de string e a magnitude deste protótipo de string e o trecho e o endereço.
  Adicione a magnitude [tamanho em bytes] deste protótipo de string para o endereço.
  Disponibilize os data desta variável ao trecho sob o endereço.

Etapas para que se disponibilize umas variáveis para um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Disponibilize a variável ao trecho.
  Recomece. [percorra novamente o código acima]

Um endereço base é um endereço.

Uma zona é uma estrutura com 
  Um endereço base, 
  Uma quantidade de caracteres e 
  Um tamanho.

Etapas para que se bubble uma unidade semântica:
  Se a unidade semântica for inexistente, retorne.
  Se o subtexto atual desta unidade semântica não estiver em branco, limpe o subtexto atual desta unidade semântica; retorne.
  Se o tipo atual desta unidade semântica for inexistente, retorne.
  Se o tipo atual desta unidade semântica for algum tipo pré-definido, atribua nil ao tipo atual desta unidade semântica; retorne.
  Atribua o tipo base deste tipo atual desta unidade semântica ao tipo atual desta unidade semântica.

Um tipo primitivo é um tipo.

Etapas para que se calculate a quantidade de caracteres of um tipo:
  Se o tipo for inexistente, retorne.
  Se a quantidade de caracteres deste tipo não for -1, retorne.
  Calculate a quantidade de caracteres of o tipo base deste tipo.
  Se os campos deste tipo estiverem vazios, atribua a quantidade de caracteres deste tipo base deste tipo à quantidade de caracteres deste tipo; retorne.
  Atribua 0 à quantidade de caracteres deste tipo.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde o campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o nome de redefinição de conteúdo deste campo não estiver em branco, recomece.
    Calculate a quantidade de caracteres of o tipo deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo times a contagem deste campo para a quantidade de caracteres deste tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate os comprimentos of uns tipos:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calculate a quantidade de caracteres of o tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate os deslocamentos em um tipo:
  Se o tipo for inexistente, retorne.
  Atribua 0 para um deslocamento.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o nome de redefinição de conteúdo deste campo não estiver em branco, recomece.
    Atribua o deslocamento ao deslocamento deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo times a contagem deste campo para o deslocamento.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate os deslocamentos em uns tipos:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calculate os deslocamentos no tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate o redefinition deslocamentos em um tipo:
  Se o tipo for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o nome de redefinição de conteúdo deste campo estiver em branco, recomece.
    Encontre um segundo campo usando o nome de redefinição de conteúdo deste campo e os campos deste tipo.
    Se o segundo campo for inexistente, apresente uma mensagem de erro contendo "#31. Comando de redefinição inválido. O campo '" junto com o nome de redefinição de conteúdo deste campo seguido de "' não pode ser encontrado." e o endereço local deste campo; retorne.
    Atribua o deslocamento deste segundo campo ao deslocamento deste campo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate o redefinition deslocamentos em uns tipos:
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Calculate o redefinition deslocamentos no tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se verifique por informações opcionais inválidas em um tipo:
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o nome do conteúdo deste tipo não estiver em branco, verifique por informações opcionais inválidas em o tipo (conteúdo).
  Se o campos deste tipo não estiverem vazios, verifique por informações opcionais inválidas em o tipo (campos).
  Se a razão de escala deste tipo não for 0, verifique por informações opcionais inválidas em o tipo (tipos fracionários).

Etapas para que se verifique por informações opcionais inválidas em um tipo (campos):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "estrutura", apresente uma mensagem de erro contendo "Erro. A palavra-chave 'com' só é permitida em estruturas." e o endereço local deste tipo; retorne. \\mudar aqui

Etapas para que se verifique por informações opcionais inválidas em um tipo (tipos fracionários):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "número", apresente uma mensagem de erro contendo "Erro. Proporções e escalas de medida só podem ser utilizadas em tipos de dados numéricos." e o endereço local deste tipo; retorne.

Etapas para que se verifique por informações opcionais inválidas em um tipo (conteúdo):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", apresente uma mensagem de erro contendo "Erro. A palavra-chave 'para' só pode ser utilizada ao apontar para variáveis do tipo ponteiro." e o endereço local deste tipo; retorne.

Etapas para que se limpe um campo de estrutura:
  Preencha bytes com o caractere null começando sob o endereçamento deste campo de estrutura pelo magnitude deste campo de estrutura.

Etapas para que se limpe um termo:
  Esvazie a variável deste termo.
  Limpe o frase deste termo.

Etapas para que se compile os corpos of as rotinas:
  Compile o corpo of a rotina denominada "Initialize before run".
  Compile o corpo of a rotina denominada "Execute o programa".
  Compile o corpo of a rotina denominada "Finalize after run".

Etapas para que se compile o corpo of uma rotina:
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o detector de compilação desta rotina estiver ativo, retorne.
  Ative o detector de compilação desta rotina.
  Lance um percorredor sobre as instruções desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for o ponto&vírgula, compile o corpo of a rotina usando o percorredor (sobrecarga de métodos); retorne. \ *** alternate wording
  \Se o segmento inicial deste percorredor for uma keyword de reutilização de rotina, compile o corpo of a rotina usando o percorredor (cláusula de reutilização); retorne.
  Atribua a rotina utilizada atualmente para um saved rotina.
  Atribua a rotina à rotina utilizada atualmente.
  Crie o apelido catálogo desta rotina usando 101.
  Elimine apelidos duplicados desde os parâmetros desta rotina usando o apelido catálogo desta rotina.
  Compile o corpo of a rotina (etapa preliminar).
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Compile a próxima instrução usando o percorredor.
  Recomece. [percorra novamente o código acima]
  Compile o corpo of a rotina (etapa conclusiva).
  Atribua o saved rotina à rotina utilizada atualmente.

Etapas para que se compile o corpo of uma rotina (etapa conclusiva):
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando a etiqueta de finalização.
  Comece. [a executar o código abaixo]
    Obtenha uma variável desde as variáveis locais desta rotina.
    Se a variável for inexistente, pare.
    Se a categoria desta variável for "scratch", recomece.
    Se o tipo desta variável não deveria ser finalizado, recomece.
    Adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável.
    Encontre uma segunda rotina usando "~Finalize" e o tipo desta variável.
    Se a segunda rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno #10'"; retorne.
    Adicione um terceiro fragmento usando a etiqueta de demanda interna e a segunda rotina.
  Recomece. [percorra novamente o código acima]
  Adicione um quarto fragmento usando o etiqueta conclusiva.

Etapas para que se compile o corpo of uma rotina (etapa preliminar):
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando o etiqueta preliminar.
  Adicione um segundo fragmento usando o etiqueta de laço.

Etapas para que se compile o corpo of a rotina denominada uma string;
Etapas para que se compile o corpo of a rotina denominado uma string:
  Se existir algum problema de compilação, retorne.
  Encontre uma rotina usando a string e o catálogo geral de rotinas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "#32. A rotina 'para que se " junto com a string seguido de "' não pode ser encontrada."; retorne.
  Compile o corpo of a rotina.

Etapas para que se compile o corpo of uma rotina usando um percorredor (sobrecarga de métodos):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ *** do we need this?
  Atribua a subsequente rotina desta rotina para um conteúdo rotina.
  Se o conteúdo rotina for inexistente, apresente uma mensagem de erro contendo "#33. Não foi possível encontrar o cabeçalho alternativo desta rotina." e o percorredor; retorne.
  Atribua a representação interna da rotina deste conteúdo rotina ao representação de emprego desta rotina.
  Compile o corpo of o conteúdo rotina.

Etapas para que se compile o corpo of uma rotina usando um percorredor (cláusula de reutilização):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma referência da rotina usando o percorredor.
  Converta a referência da rotina para o representação de emprego desta rotina.
  Destrua a referência da rotina.
  Se o segmento inicial deste percorredor não for ".", apresente uma mensagem de erro contendo "#34. O comando 'Empregue' deve terminar com um ponto, não com: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "#35. Permitido apenas uma cláusula de reutilização por rotina" e o percorredor; retorne.
  Encontre uma segunda rotina usando o representação de emprego desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente, apresente a mensagem de erro contendo "#36. A rotina para que se '" junto com o representação de emprego desta rotina seguido de "' não foi encontrada." e o endereço local desta rotina; retorne.
  Compile o corpo of a segunda rotina.

Etapas para que se compile a parte designadora usando um percorredor e uma variável:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Atribua o nome desta variável ao nome do tipo desta variável.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável usando o percorredor.

Etapas para que se compile um endereço da pasta:
  Compile o endereço da pasta (inicialização).
  Compile o endereço da pasta (arquivos de código fonte).
  Compile o endereço da pasta (análise dos arquivos fornecidos).
  Compile o endereço da pasta (identificação dos tipos das variáveis).
  Compile o endereço da pasta (identificação de variáveis globais).
  Compile o endereço da pasta (cabeçalhos de rotinas).
  Compile o endereço da pasta (cálculo de tamanhos e deslocamentos).
  Compile o endereço da pasta (adição de rotinas de memória incorporadas).
  Compile o endereço da pasta (catalogue as rotinas por utilização).
  Compile o endereço da pasta (conteúdo das rotinas).
  Compile o endereço da pasta (adição e compilação da rotina de inicialização).
  Compile o endereço da pasta (deslocamento de parâmetros e variáveis).
  Compile o endereço da pasta (endereço).
  Compile o endereço da pasta (transmutação).
  Compile o endereço da pasta (vinculação).
  Compile o endereço da pasta (etapa final).
  Compile o endereço da pasta (interrupção).

Etapas para que se compile um endereço da pasta (adição e compilação da rotina de inicialização):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Adicionando e agrupando as tarefas padrão de inicialização..".
  Start o temporizador de adição de rotinas pré-definidas de inicialização.
  Adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução.
  Suspenda o temporizador de adição de rotinas pré-definidas de inicialização.

Etapas para que se compile um endereço da pasta (adição de rotinas de memória incorporadas):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Adicionando tarefas predefinidas na memória...".
  Start o temporizador de adição de rotinas pré-definidas de mémoria .
  Adicione as rotinas de alocação e desalocação e finalização e destruição.
  Suspenda o temporizador de adição de rotinas pré-definidas de mémoria .

A região de código é um zona.

Etapas para que se compile um endereço da pasta (endereço):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Obtendo endereço dos itens...".
  Start o temporizador de endereçamento.
  Atribua 4096 para um endereço.
  Atribua o endereço à endereço base desta seção de DLLs.
  Enderece as DLLs usando o endereço.
  Atribua o endereço menos a endereço base desta seção de DLLs à quantidade de caracteres desta seção de DLLs.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta região de dados.
  Enderece as variáveis globais usando o endereço.
  Enderece os valores literais usando o endereço.
  Atribua o endereço menos a endereço base desta região de dados à quantidade de caracteres desta região de dados.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta região de código. \ Uma zona é uma estrutura que contém um endereço base, uma quantidade de caracteres e um tamanho.
  Enderece as rotinas usando o endereço.
  Atribua o endereço menos a endereço base desta região de código à quantidade de caracteres desta região de código.
  Suspenda o temporizador de endereçamento.

Etapas para que se compile um endereço da pasta (cálculo de tamanhos e deslocamentos):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Calculando tamanhos e deslocamentos...".
  Start o temporizador de etapas de cálculo.
  Calculate os comprimentos of o tipos.
  Calculate os deslocamentos no tipos.
  Calculate o redefinition deslocamentos no tipos.
  Suspenda o temporizador de etapas de cálculo.

Etapas para que se compile um endereço da pasta (conteúdo das rotinas):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Agrupando o conteúdo das tarefas...".
  Start o temporizador de compilação do conteúdo das rotinas.
  Compile os corpos of as rotinas.
  Suspenda o temporizador de compilação do conteúdo das rotinas.

Etapas para que se compile um endereço da pasta (cabeçalhos de rotinas):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Agrupando os nomes das tarefas...".
  Start o temporizador de compilação de cabeçalhos de rotina.
  Compile os cabelalhos of as rotinas.
  Suspenda o temporizador de compilação de cabeçalhos de rotina.

Etapas para que se compile um endereço da pasta (catalogue as rotinas por utilização):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Catalogando tarefas...".
  Start o temporizador de ferramentas de catalogação.
  Catalogue as rotinas por utilização.
  Scrub o catálogo de rotinas úteis.
  Organize o catálogo de rotinas úteis.
  Suspenda o temporizador de ferramentas de catalogação.

Etapas para que se compile um endereço da pasta (vinculação):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Elencando arquivos..".
  Start o temporizador de vinculação.
  Link.
  Suspenda o temporizador de vinculação.

Etapas para que se compile um endereço da pasta (deslocamento de parâmetros e variáveis):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Deslocando parâmetros e variáveis...".
  Start o temporizador de deslocamentos.
  Alinhe o parâmetros na rotinas.
  Alinhe as variáveis locais na rotinas.
  Suspenda o temporizador de deslocamentos.

Etapas para que se compile um endereço da pasta (arquivos de código fonte):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Carregando arquivos...".
  Start o temporizador de operacionalização.
  Carregue os arquivos fontes.
  Suspenda o temporizador de operacionalização.

Etapas para que se compile um endereço da pasta (identificação de variáveis globais):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Resolvendo itens de escopo variável global...".
  Start o temporizador de resolução de variáveis globais.
  Destrinche as variáveis globais.
  Suspenda o temporizador de resolução de variáveis globais.

Etapas para que se compile um endereço da pasta (identificação dos tipos das variáveis):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Resolvendo tipos...".
  Start o temporizador de resolução de tipos.
  Destrinche os tipos (expand listas).
  Destrinche os tipos (registro de plurais).
  Destrinche os tipos (tipos de dados primitivos).
  Destrinche os tipos (dados complementares).
  Suspenda o temporizador de resolução de tipos.

Etapas para que se compile um endereço da pasta (análise dos arquivos fornecidos):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Analisando arquivos...".
  Start o temporizador de análise/verificação.
  Examine os arquivos fontes.
  Suspenda o temporizador de análise/verificação.

Etapas para que se compile um endereço da pasta (inicialização):
  Mostre no painel de informações "Iniciando...".
  Finalize o compilador.
  Start o temporizador deste compilador.
  Inicialize o compilador usando o endereço da pasta.
  Adicione o tipos primitivos.

Etapas para que se compile um endereço da pasta (interrupção):
  Suspenda o temporizador deste compilador.
  Mostre no painel de informações "Interrompendo".

Etapas para que se compile um endereço da pasta (transmutação):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Modificando...".
  Start o temporizador de transmutação.
  Transforme as rotinas em código hexadecimal.
  Suspenda o temporizador de transmutação.

Etapas para que se compile um endereço da pasta (etapa final):
  Se existir algum problema de compilação, retorne.
  Mostre no painel de informações "Gerando arquivo executável...".
  Start o temporizador de escrita.
  Escreva o trecho EXE deste compilador para o endereço EXE completo deste compilador.
  Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo o erro do fluxo de entrada/saída.
  Suspenda o temporizador de escrita.

Etapas para que se compile uma expressão matematica usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Compile um termo usando o percorredor.
  Atribua o termo ao expressão matematica.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for algum operador aritmético, retorne.
    Se o segmento inicial deste percorredor for algum operador de divisão, compile o expressão matematica usando o percorredor (operador de divisão); recomece.
    Se o segmento inicial deste percorredor for algum operador de subtração, compile o expressão matematica usando o percorredor (operador de subtração); recomece.
    Se o segmento inicial deste percorredor for algum operador de adição, compile o expressão matematica usando o percorredor (operador de adição); recomece.
    Se o segmento inicial deste percorredor for algum operador de concatenação, compile o expressão matematica usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for algum operador de multiplicação, compile o expressão matematica usando o percorredor (operador de multiplicação); recomece.
    Se o segmento inicial deste percorredor for "junto", compile o expressão matematica usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "juntamente", compile o expressão matematica usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "seguido", compile o expressão matematica usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "acompanhado", compile o expressão matematica usando o percorredor (operador de concatenação); recomece.

Etapas para que se compile uma expressão matematica usando um percorredor (operador de divisão):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum objeto indireto, apresente uma mensagem de erro contendo "#37. Você deve usar o termo 'dividido POR'." e o percorredor; retorne.
  Se a variável desta expressão matematica for inexistente, apresente a mensagem de erro contendo "#38. Comando 'dividido por' inválido. Erro na variável  '" junto com a frase desta expressão matematica seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "#39. O comando 'dividido por', está errado. Não é possível dividir por '" junto com a frase deste termo seguido de "'." e o percorredor; retorne.
  Adicione uma variável intermediária usando o nome do tipo desta expressão matematica e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta expressão matematica e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Divida" e a variável intermediária e "por" e a variável deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Etapas para que se compile uma expressão matematica usando um percorredor (operador de subtração):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente, apresente uma mensagem de erro contendo "#40. O comando 'menos', está incorreto. Não é possível subtrair de '" junto com a frase desta expressão matematica seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "#41. O comando 'menos', está incorreto. Não consigo diminuir de '" junto com a frase deste termo seguido de "'." e o percorredor; retorne.
  Adicione uma variável intermediária usando o nome do tipo desta expressão matematica e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta expressão matematica e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Subtraia" e a variável deste termo e "desde" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Etapas para que se compile uma expressão matematica usando um percorredor (operador de adição):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente, apresente uma mensagem de erro contendo "#42. O comando 'mais' está incorreto. Não é possível somar o '" junto com a frase desta expressão matematica seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação). \talvez fosse o caso de repetir aqui
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "#43. O comando 'mais' está incorreto. Não é possível adicionar o" junto com a frase deste termo seguido de "." e o percorredor; retorne.
  Adicione uma variável intermediária usando o nome do tipo desta expressão matematica e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta expressão matematica e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.\aqui muda o atribua
  Adicione fragmentos diversos usando "Adicione" e a variável deste termo e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor. \ aqui muda o add
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Etapas para que se compile uma expressão matematica usando um percorredor (operador de concatenação):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum palavra de concatenação, apresente uma mensagem de erro contendo "#44. Necessário escrever 'junto DE/junto COM/etc'." e o percorredor; retorne.
  Se a variável desta expressão matematica for inexistente, apresente a mensagem de erro contendo "#45. Eu não entendi a variável da expressão matematica: " junto com a frase desta expressão matematica seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor. 
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "#46. Eu não achei a variável do termo: " junto com a frase deste termo seguido de "." e o percorredor; retorne.
  Adicione uma variável intermediária usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione uma variável intermediária usando "texto" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione uma variável intermediária usando "cadeia de caracteres" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragmentos usando a variável desta expressão matematica e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Converta o termo por concatenação usando o percorredor. \\ aqui faz a concatenação
  Adicione fragmentos diversos usando "Acrescente" e a variável deste termo e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Etapas para que se compile uma expressão matematica usando um percorredor (operador de multiplicação):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente, apresente uma mensagem de erro contendo "#47. Erro de sintaxe. Comando 'vezes' incorreto. Não é póssível multiplicar por '" junto com a frase desta expressão matematica seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "#48. Erro de sintaxe. Comando 'multiplicado por' incorreto. Não é póssível multiplicar por '" junto com a frase deste termo seguido de "'." e o percorredor; retorne.
  Adicione uma variável intermediária usando o nome do tipo desta expressão matematica e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta expressão matematica e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Multiplique" e a variável intermediária e "por" e a variável deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matematica.
  Limpe a frase desta expressão matematica.

Etapas para que se compile o cabeçalho of uma rotina:
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre a cabeçalho de rotina desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum comando de deliberação, compile o cabeçalho of a rotina usando o percorredor (rotina deliberativa); retorne.
  Se o percorredor for o início of alguma função possessiva reversa, compile o cabeçalho of a rotina usando o percorredor (função do possessivo reverso); retorne.
  Se o percorredor for o início of alguma função, compile o cabeçalho of a rotina usando o percorredor (função); retorne.
  Se o segmento inicial deste percorredor for "compativelmente", compile o cabeçalho of a rotina usando o percorredor (modo de compatibilidade); retorne.
  Compile o cabeçalho of a rotina usando o percorredor (procedimento).

Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (modo de compatibilidade): \ callback
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o detector de compatibilidade desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "#49. A rotina para que se '" junto com a representação interna da rotina desta rotina seguido de "' já foi definida anteriormente." e o endereço local desta rotina; retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (rotina deliberativa):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional, apresente uma mensagem de erro contendo "#50. Rotina 'Para que se determine se' com sintaxe inválida" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o detector de deliberação desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Se alguns of as unidades semânticas desta rotina forem advérbios de negação, apresente a mensagem de erro contendo "#51. A palavra-chave 'não' não é permitida em cabeçalhos de funções booleanas." e o percorredor; retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "#52. A rotina para que se ''" junto com a representação interna da rotina desta rotina seguido de "' já havia sido definida anteriormente." e o endereço local desta rotina; retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (função):
  Se existir algum problema de compilação, retorne.
  Ative o detector de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessivo inglês, apresente uma mensagem de erro contendo "#53. Necessário inserir um 's no código." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "#54. palavra-chave 'para' ausente. Encontrado a palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Adicione uma terceira unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "#55. Rotina para que se '" junto com a representação interna da rotina seguido de "' já definida." e o endereço local desta rotina; retorne. \ not translated - no possessives em Spanish
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente a mensagem de erro contendo "#56. Necessário artigo indefinido. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "#57. Encontrado comandos extras no fim da função." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ para employs

Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (procedimento):
  Se existir algum problema de compilação, retorne.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "#58. Rotina para que se '" junto com a representação interna da rotina desta rotina seguido de "' já codificada." e o endereço local desta rotinas; retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile os cabelalhos of umas rotinas:
  Se existir algum problema de compilação, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Compile o cabeçalho of a rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se compile um valor literal usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione o valor literal para os valores literais usando o caractere inicial deste segmento inicial deste percorredor .
  \Se o segmento inicial deste percorredor for algum detector literal, compile o valor literal usando o percorredor (valores booleanos); retorne.
  Se o segmento inicial deste percorredor for algum valor hexadecimal literal, compile o valor literal usando o percorredor (valores hexadecimais); retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal, compile o valor literal usando o percorredor (valor numérico - análise preliminar); retorne.
  Se o segmento inicial deste percorredor for algum ponteiro literal, compile o valor literal usando o percorredor (ponteiros); retorne.
  Se o segmento inicial deste percorredor for algum string literal, compile o valor literal usando o percorredor (cadeia de caracteres); retorne.
  Apresente uma mensagem de erro contendo "Erro interno #11 - Consulte a rotina para que se compile um termo usando um percorredor (valor literal)" e o percorredor.

Etapas para que se compile um valor literal usando um percorredor (valores booleanos):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para um detector.
  Converta o detector para os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "detector" ao nome do tipo deste valor literal.
  Destrinche o valor literal. \ Que tal utilizar os termos "decifre", "traduza", "destrinche", "decodifique"?

Etapas para que se compile um valor literal usando um percorredor (valores hexadecimais):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta o parte da cifra binária para o data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "texto hexadecimal" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Etapas para que se compile um valor literal usando um percorredor (valor numérico - números inteiros):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para um número.
  Converta o número para os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Etapas para que se compile um valor literal usando um percorredor (valor numérico - números fracionários):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Converta a proporção para o data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "proporção" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Etapas para que se compile um valor literal usando um percorredor (valor numérico - unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente, apresente uma mensagem de erro contendo "#59. O(A) '" junto com o nome seguido de "' é uma unidade de medida inexistente." e o endereço local deste valor literal; retorne.
  Se o tipo não puder ser reduzido para "número", apresente a mensagem de erro contendo "#60. O(A) '" junto com o nome seguido de "' é uma unidade de medida inválida." e o endereço local deste valor literal; retorne.
  Atribua a razão de escala deste tipo para um final proporção.
  Se a razão de escala deste tipo for 0, atribua 1/1 ao final proporção.
  Multiplique o final proporção pelo proporção.
  Reduza o final proporção.
  Se o denominador deste final proporção for 0, apresente a mensagem de erro contendo "#61. Denominador igual a zero. Unidade de medida inválida." e o endereço local deste valor literal.
  Atribua o numerador deste final proporção dividido pelo denominador deste final proporção para um número.
  Atribua o nome deste tipo ao nome do tipo deste valor literal.
  Converta o número para o data deste valor literal.
  Destrinche o valor literal.

Etapas para que se compile um valor literal usando um percorredor (valor numérico - análise preliminar):
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver acompanhado por algum unidade de medida, compile o valor literal usando o percorredor (valor numérico - unidade de medida); retorne.
  Se o segmento inicial deste percorredor for algum integer literal, compile o valor literal usando o percorredor (valor numérico - números inteiros); retorne.
  Se o segmento inicial deste percorredor for algum proporção literal, compile o valor literal usando o percorredor (valor numérico - números fracionários); retorne.
  Se o segmento inicial deste percorredor for algum numeral misto literal, compile o valor literal usando o percorredor (valor numérico - números fracionários); retorne.

Etapas para que se compile um valor literal usando um percorredor (ponteiros):
  Se existir algum problema de compilação, retorne.
  Converta 0 para os data deste valor literal. \ was nil
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "ponteiro" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Etapas para que se compile um valor literal usando um percorredor (cadeia de caracteres):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor aos data deste valor literal.
  Remova as aspas de os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "string" ao nome do tipo deste valor literal.
  \Atribua "texto" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum artigo definido, compile as unidades semânticas e o parâmetros usando o percorredor (artigo definido); recomece.
  Se o percorredor estiver sobre algum artigo indefinido, compile as unidades semânticas e o parâmetros usando o percorredor (artigo indefinido); recomece.
  Se o percorredor estiver sobre algum unidade semântica string, compile as unidades semânticas e o parâmetros usando o percorredor (string de unidade semântica); recomece.
  Apresente uma mensagem de erro contendo "#62. Rotina para que se '" junto com o segmento inicial deste percorredor seguido de "' não localizada." e o percorredor.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo definido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para as unidades semânticas usando o nome.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo indefinido):
  Se existir algum problema de compilação, retorne.
  Adicione um parâmetro para o parâmetros usando "parâmetro" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outras", atribua "outras" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outros", atribua "outros" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste parâmetro.  
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste parâmetro.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste parâmetro com o nome.
  Se o segmento inicial deste percorredor for uma keyword de designação, compile a parte designadora usando o percorredor e o parâmetro.
  Destrinche o parâmetro.
  Se o parâmetro estiver duplicada no parâmetros, apresente uma mensagem de erro contendo "#63. O parâmetro '" junto com o nome deste parâmetro seguido de "' já foi declarado anteriormente." e o endereço local deste parâmetro; retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o tipo deste parâmetro.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (string de unidade semântica):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile umas unidades semânticas usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver sobre algum unidade semântica string, adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação); recomece.
  Se o segmento inicial deste percorredor não for o início of alguma expressão matematica, retorne.
  Compile uma expressão matematica usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o expressão matematica.
  Recomece. [percorra novamente o código acima]

\Etapas para que se compile umas unidades semânticas usando um percorredor:
\Se existir algum problema de compilação, retorne.
\Se o segmento inicial deste percorredor for algum unidade semântica string, adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação); recomece.
\Se o segmento inicial deste percorredor não for o início of alguma expressão matematica, retorne.
\Compile uma expressão matematica usando o percorredor.
\Se existir algum problema de compilação, retorne.
\Adicione uma segunda unidade semântica para as unidades semânticas usando o expressão matematica.
\Recomece. [percorra novamente o código acima]

Etapas para que se compile a próxima instrução usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum comando condicional, compile a próxima instrução usando o percorredor (cláusula de condicional); retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento, compile a próxima instrução usando o percorredor (cláusula de inicio de laço); retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção, compile a próxima instrução usando o percorredor (cláusula de isolamento); retorne.
  Se o segmento inicial deste percorredor não for o início of alguma declaração, apresente uma mensagem de erro contendo "#64. Esperado declaração. Encontrado: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Compile a próxima instrução usando o percorredor (demais cláusulas).
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "#65. Este comando está incorreto ou é uma keyword reservada." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de interrupção):
  Adicione um fragmento usando o etiqueta de interrupção.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se determine se uma string é alguma keyword de devolução:
  Se a string for "retornando", diga sim.
  Se a string for "retornando", diga sim.
  Se a string for "recebendo", diga sim.
  Se a string for "obtendo", diga sim.
  \Se a string for "obtendo", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.


Etapas para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada externa):
  Atribua o segmento inicial deste percorredor para uma string.
  Remova as aspas de a string.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum string literal, apresente uma mensagem de erro contendo "#66. O compiplador exige que o nome da biblioteca esteja entre aspas. Encontrado: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Atribua o segmento inicial deste percorredor para uma segunda string.
  Remova as aspas de a segunda string.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione uma função para as DLLs usando a string e a segunda string.
  Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "usando", compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for alguma keyword de devolução, compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).
  \Se o segmento inicial deste percorredor for "retornando", compile a próxima instrução usando o percorredor retornando um outro termo (palavra-chave 'processe' - cláusula retornando).
  \Se o segmento inicial deste percorredor for uma keyword de devolução, compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).
  Adicione um fragmento usando a etiqueta de demanda externa e a função.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "#67. A variável do termo '" junto com a frase deste termo seguido de "' não pode ser localizada." e o percorredor; retorne.
  Adicione um segundo fragmento usando o etiqueta de obtenção do registrador EAX e a variável deste termo.

Etapas para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada indireta):
  Compile uma expressão matematica usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente, apresente uma mensagem de erro contendo "#68. A variável da expressão matematica'" junto com a frase desta expressão matematica seguido de "' não pode ser localizada." e o percorredor; retorne.
  Se o tipo desta expressão matematica não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "#69. Neste comando 'Processe' é necessário usar uma expressão matematica do tipo ponteiro." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "usando", compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for alguma keyword de devolução, compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).
  \Se o segmento inicial deste percorredor for "retornando", compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).
  Adicione um fragmento usando a etiqueta de demanda indireta e a variável desta expressão matematica.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "#70. A variável do termo '" junto com a frase deste termo seguido de "' é inexistente." e o percorredor; retorne.
  Adicione um segundo fragmento usando o etiqueta de obtenção do registrador EAX e a variável deste termo.

Etapas para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada interna):
  Compile umas unidades semânticas usando o percorredor.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente, adicione push fragmentos usando as unidades semânticas.
  Se a rotina não for inexistente, destrua as unidades semânticas; adicione um fragmento usando a etiqueta de demanda interna e a rotina; retorne.
  [Caso a rotina seja inexistente, então:]
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.  
  Atribua a representação interna da rotina ao texto retornado. 
  Apresente uma mensagem de erro contendo "#71. A rotina para que se " junto com a representação interna da rotina seguido de " não foi localizada." e o percorredor.

Etapas para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - cláusula com):
  \ this routine is recursise so parameters get passed right to  left
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma expressão matematica usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente, apresente uma mensagem de erro contendo "#72. A variável da expressão matematica '" junto com a frase desta expressão matematica seguido de "' é inexistente." e o percorredor; retorne.
  Se o tipo desta expressão matematica não for valor empilhável, apresente a mensagem de erro contendo "#73. O tipo '" junto com o nome deste tipo desta expressão matematica seguido de "' da expressão matematica é um valor empilhável." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum operador de continuidade, compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Adicione um fragmento usando o etiqueta de inserção de valor [na stack] e a variável desta expressão matematica.

Etapas para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum string literal, compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada externa); retorne.
  Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada indireta).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de retorno):
  Se o detector de deliberação desta rotina utilizada atualmente estiver ativo, apresente uma mensagem de erro contendo "#74. Funções booleanas devem retornar um 'sim' ou 'não'" e o percorredor; retorne.  
  Adicione um fragmento usando o etiqueta de retorno.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de condicional):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile umas unidades semânticas usando o percorredor.
  Remova alguns termos negativos desde as unidades semânticas retornando um detector.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente, adicione push fragmentos usando as unidades semânticas.
  Se a rotina for inexistente, converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "#75. A rotina para que se '" junto com a representação interna da rotina seguido de "' não existe." e o percorredor; retorne.
  Se o detector de deliberação desta rotina não estiver ativo, apresente a mensagem de erro contendo "#76. Necessário utilizar um decisor." e o percorredor; retorne.
  \ Se o segmento inicial deste percorredor não for a vírgula, apresente a mensagem de erro contendo "Acho que você esqueceu de uma vírgula, eu achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Se o segmento inicial deste percorredor não for qualquer separador de comandos, apresente a mensagem de erro contendo "#77. Necessário incluir uma vírgula ao invés de: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um fragmento usando a etiqueta de demanda interna e a rotina.
  Se o detector estiver ativo, adicione um segundo fragmento usando a etiqueta de negação lógica.
  Adicione um terceiro fragmento usando o etiqueta de desvio falso.
  Mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Compile a próxima instrução usando o percorredor (demais cláusulas).
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, mova o percorredor (usando diretrizes de compilação); recomece.
    \Se o segmento inicial deste percorredor for "Senão", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for "Caso", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for a vírgula, mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "#78. Necessário incluir um '.' ao invés de: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione um quarto fragmento usando o etiqueta delimitadora de bloco condicional.

Etapas para que se determine se um subtexto é qualquer separador de comandos:
  Se o subtexto for a vírgula, diga sim.
  Se o subtexto for "então", diga sim.
  [Caso contrário] Diga não.

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de decodificação):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum valor hexadecimal literal, apresente uma mensagem de erro contendo "#79. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'. Esperado instrução hexadecimal" e o percorredor; retorne.
  Adicione um fragmento usando o etiqueta de decodificação.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta o parte da cifra binária para o código deste fragmento.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de inicio de laço):
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando o etiqueta de laço.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "#80. Necessário incluir um '.' após comandos em blocos de repetição." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (demais cláusulas):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum comando de retorno de rotina, compile a próxima instrução usando o percorredor (cláusula de retorno); retorne.
  Se o segmento inicial deste percorredor for algum comando de repetição, compile a próxima instrução usando o percorredor(cláusula de repetição); retorne.
  Se o segmento inicial deste percorredor for algum comando de interrupção de repetições, compile a próxima instrução usando o percorredor (cláusula de interrupção); retorne.
  Se o segmento inicial deste percorredor for algum comando de confirmação ou negação, compile a próxima instrução usando o percorredor (palavra-chave 'diga'); retorne.
  Se o segmento inicial deste percorredor for "Decodifique", compile a próxima instrução usando o percorredor (cláusula de decodificação); retorne.
  Se o segmento inicial deste percorredor for "Push", compile a próxima instrução usando o percorredor (cláusula de empilhamento); retorne.
  Se o segmento inicial deste percorredor for alguma chamada de biblioteca externa, compile a próxima instrução usando o percorredor (palavra-chave 'processe'); retorne.
  Se o segmento inicial deste percorredor for algum point, compile a próxima instrução usando o percorredor (palavra-chave 'aponte'); retorne.
  Se o segmento inicial deste percorredor for algum comando condicional, apresente uma mensagem de erro contendo "#81. O aninhamento de condicionais não é permitido." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção, apresente a mensagem de erro contendo "#82. A keyword 'Isole' não pode ser usada nesse tipo de comando." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento, apresente a mensagem de erro contendo "#83. Loops não são permitidos em condicionais." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for uma keyword de reutilização de rotina, apresente a mensagem de erro contendo "#84. O comando 'Empregue' deve ser o único comando de uma rotina." e o percorredor; retorne.
  \Se o segmento inicial deste percorredor for "senão", mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o segmento inicial deste percorredor for "caso", mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes de compilação); retorne.
  Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna).

Etapas para que se compile a próxima instrução usando um percorredor (palavra-chave 'aponte'):
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#85. A variável '" junto com a frase deste termo seguido de "' deste termo não pode ser encontrada." e o percorredor; retorne.
  Se a categoria deste termo for "literal", apresente a mensagem de erro contendo "#86. Identificado valor literal na categoria deste termo." e o percorredor.
  Se a quantidade de caracteres deste tipo deste termo não for 4, apresente a mensagem de erro contendo "#87. Variável de comprimento diferente de 4 ." e o percorredor.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "#88. A keyword 'para é necessária após o comando 'aponte'. Termo encontrado: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "rotina", apresente a mensagem de erro contendo "#89. A sintaxe  do comando é 'Aponte para rotina'. Encontrado termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma referência da rotina usando o percorredor.
  Converta a referência da rotina para uma representação interna da rotina.
  Destrua a referência da rotina.
  Encontre uma rotina usando a representação interna da rotina e o catálogo geral de rotinas.
  Se a rotina for inexistente, apresente a mensagem de erro contendo "#90. A rotina para que se " junto com a representação interna da rotina seguido de " é inexistente." e o percorredor; retorne.
  Adicione um fragmento usando a etiqueta de endereço de rotina e a rotina.
  Atribua a variável deste termo à variável deste fragmento.

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de isolamento):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#91. Comando 'isole', Inválido. Termo da variável: " junto com a frase deste termo seguido de "' está vazio." e o percorredor; retorne.
  Se a categoria deste termo não for "parâmetro", apresente a mensagem de erro contendo "#92. Apenas parâmetros podem ser isolados." e o percorredor; retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o nome deste termo ao nome desta variável local.
  Atribua o apelido deste termo ao apelido desta variável local.
  Atribua o nome do tipo deste termo ao nome do tipo desta variável local.
  Destrinche a variável local.
  Anteponha "original " para o nome deste termo. \ Deveria ser "acrescente"
  Se o apelido deste termo não estiver em branco, Anteponha "original " para o apelido deste termo.
  Adicione fragmentos diversos usando "Atribua" e a variável deste termo e "para" e a variável local e o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "#93. Necessário incluir um '.' ao dim do comando" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (cláusula de empilhamento):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma expressão matematica usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matematica for inexistente, apresente uma mensagem de erro contendo "#94. Comando de empilhamento inválido devido a expressão matematica: " junto com a frase desta expressão matematica seguido de "' ser inexistente." e o percorredor; retorne.
  Se o tipo desta expressão matematica não for valor empilhável, apresente a mensagem de erro contendo "#95. Valores do tipo: " junto com o nome deste tipo desta expressão matematica seguido de "' não podem ser empilhados." e o percorredor; retorne.
  Adicione um fragmento usando o etiqueta de inserção de valor [na stack] e a variável desta expressão matematica.

Etapas para que se compile a próxima instrução usando um percorredor(cláusula de repetição):
  Adicione um fragmento usando a etiqueta de repetição.
  Mova o percorredor (usando diretrizes de compilação).

\Etapas para que se compile a próxima instrução usando um percorredor (palavra-chave 'diga'):
\Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna); retorne.
\Mova o percorredor (usando diretrizes de compilação).
\Compile uma expressão matematica usando o percorredor.
\Se existir algum problema de compilação, retorne.
\Se a variável desta expressão matematica for inexistente, apresente uma mensagem de erro contendo "No es válido este 'diga', no entiendo la variável: " junto com a frase desta expressão matematica seguido de "." e o percorredor; retorne.
\Se o tipo desta expressão matematica não puder ser reduzido para "detector", apresente uma mensagem de erro contendo "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; retorne.
\Adicione um fragmento usando o etiqueta de carregamento de registrador EAX e a variável desta expressão matematica.
\Adicione um segundo fragmento usando o etiqueta de retorno.

Etapas para que se compile a próxima instrução usando um percorredor (palavra-chave 'diga'):
  Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna); retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando de deliberação literal, apresente uma mensagem de erro contendo "#96. Funções booleanas devem terminar com um 'sim' ou 'não'." e o percorredor; retorne.
  Desative um detector. Se o segmento inicial deste percorredor for algum decisor literal afirmativo, ative o detector.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "#97. O compilador esperava encontrar um '.' Encontrado o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um fragmento usando o etiqueta de carregamento de registrador EAX e o detector.
  Adicione um segundo fragmento usando o etiqueta de retorno.

Etapas para que se compile a próxima instrução usando um percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando):
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#98. O termo da variável: " junto com a frase deste termo seguido de "'. aparenta estar vazio." e o percorredor; retorne.
  Se o tipo deste termo não for valor empilhável, apresente a mensagem de erro contendo "#99. Uma varíavel de 1, 2, ou 4 bytes é necessária na cláusula de devolução." e o percorredor.

Etapas para que se compile uma referência da rotina usando um percorredor:
  Se o segmento inicial deste percorredor for "para", mova o percorredor (usando diretrizes de compilação).
  Se o percorredor for o início of alguma função, compile a referência da rotina usando o percorredor (função); retorne.
  Se o segmento inicial deste percorredor for algum comando de deliberação, compile a referência da rotina usando o percorredor (decide).
  Comece. [a executar o código abaixo]
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for ".", retorne.
  Se o segmento inicial deste percorredor for algum artigo definido, compile a referência da rotina usando o percorredor (artigo definido); recomece.
  Se o segmento inicial deste percorredor for algum artigo indefinido, compile a referência da rotina usando o percorredor (artigo indefinido); recomece.
  Se o percorredor está sobre algum unidade semântica string, compile a referência da rotina usando o percorredor (string de unidade semântica); recomece.
  Apresente uma mensagem de erro contendo "#190. O termo '" junto com o segmento inicial deste percorredor seguido de "' não é válido neste tipo de comando." e o percorredor.

Etapas para que se compile uma referência da rotina usando um percorredor (decide):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional, apresente uma mensagem de erro contendo "#100. Esperado: 'Para que se decisa SE' .Encontrado: 'Para que se decida " junto com o segmento inicial deste percorredor seguido de " '." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile uma referência da rotina usando um percorredor (artigo definido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para a referência da rotina usando o nome.

Etapas para que se compile uma referência da rotina usando um percorredor (função):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para a referência da rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile a referência da rotina usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile a referência da rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessivo inglês, apresente uma mensagem de erro contendo "#101. O compilador esperava encontrar um 's. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne. 
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para a referência da rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "#102. O compilador esperava encontrar a palavra 'para'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne. 
  Adicione uma terceira unidade semântica para a referência da rotina usando "para".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente a mensagem de erro contendo "#103. O compilador esperava encontrar um artigo indefinido. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne. 
  Compile a referência da rotina usando o percorredor (artigo indefinido).

Etapas para que se compile uma referência da rotina usando um percorredor (artigo indefinido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo e um apelido usando o nome.
  Se o tipo for inexistente, apresente uma mensagem de erro contendo "#104. O comando '" junto com o nome seguido de "' não é um comando de reutilização válido." e o percorredor; retorne.
  Adicione uma unidade semântica para a referência da rotina usando o tipo.

Etapas para que se compile uma referência da rotina usando um percorredor (string de unidade semântica):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para a referência da rotina usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile um termo usando um percorredor:
  Limpe o termo.
  Se existir algum problema de compilação, retorne.
  Compile o termo usando o percorredor (análise preliminar).
  Se o percorredor estiver sobre algum simile, retorne. \ added for invisible turtle project ***
  \Se o segmento inicial deste percorredor for "as", compile o termo usando o percorredor (cláusula comparativa). \preposição
  \Se o segmento inicial deste percorredor for "tão", compile o termo usando o percorredor (cláusula comparativa). \ me parece desnecessário por ser usado apenas em funções.
  Se o segmento inicial deste percorredor for "quão", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "quanto", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "como", compile o termo usando o percorredor (cláusula comparativa).
  \Se o segmento inicial deste percorredor for "que nem", compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "/", compile o termo usando o percorredor (proporção de execução).

Etapas para que se compile um termo usando um percorredor (cláusula comparativa):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#105. Comando 'como' inválido. Variável: " junto com a frase deste termo seguido de "' está vaiza." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente a mensagem de erro contendo "#106. Esperado Artigo indefinido. Encontrado: " junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome do tipo usando o percorredor.
  Encontre um tipo usando o nome do tipo e o catálogo de tipos.
  Se o tipo for inexistente, apresente a mensagem de erro contendo "#107. Tipo: '" junto com o nome do tipo seguido de "' inválido." e o percorredor; retorne.
  Adicione um scratch usando o nome deste tipo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Atribua o scratch à variável deste termo.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um percorredor (análise preliminar):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for o sinal de subtração, compile o termo usando o percorredor (subtração de termo); retorne.
  Se o segmento inicial deste percorredor for o sinal de adição, compile o termo usando o percorredor (adição de termo); retorne.
  Se o segmento inicial deste percorredor for o início of alguma variável, compile o termo usando o percorredor (variável); retorne.
  Se o segmento inicial deste percorredor for o início of alguma variável local, compile o termo usando o percorredor (nova variável local); retorne.
  Se o segmento inicial deste percorredor for algum valor literal, compile o termo usando o percorredor (valor literal); retorne.
  Apresente uma mensagem de erro contendo "#108. O Compilador esperava encontrar um termo. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor.

Etapas para que se compile um termo usando um percorredor (redirecionamentos de endereços - campos de estruturas):
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#109. Termo inexistente. Consulte a rotina para que se compile um termo usando um percorredor (redirecionamentos de endereços - campos de estruturas). " e o percorredor; retorne.
  Atribua o nome deste tipo do conteúdo deste tipo deste termo ao nome do tipo deste termo.
  Atribua o tipo do conteúdo deste tipo deste termo ao tipo deste termo.
  Adicione um fragmento usando o etiqueta de redirecionamento e a variável deste termo.
  Limpe o frase deste termo.

Etapas para que se compile um termo usando um percorredor (cláusula de redirecionamento):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#110. Cláusula redirecionamento inválida. A variável '" junto com a frase deste termo seguido de "' deste termo não foi encontrada." e o percorredor; retorne.
  Se o tipo do conteúdo deste tipo deste termo for inexistente, apresente a mensagem de erro contendo "#111. O tipo do conteúdo deste termo não foi encontrado." e o percorredor; retorne.
  Se a categoria deste termo for "scratch", compile o termo usando o percorredor (redirecionamentos de endereços - campos de estruturas); retorne.
  Adicione um scratch usando o nome deste tipo do conteúdo deste tipo deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Adicione um segundo fragmento usando o etiqueta de redirecionamento e o scratch.
  Atribua o scratch à variável deste termo.
  Limpe o frase deste termo.

Etapas para que se compile um termo usando um percorredor (valor literal):
  Se existir algum problema de compilação, retorne.
  Compile um valor literal usando o percorredor.
  Atribua o valor literal à variável deste termo.
  Limpe o frase deste termo.
  Compile o termo usando o percorredor (possessives).

Etapas para que se compile um termo usando um percorredor (subtração de termo):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma segunda termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta segunda termo for inexistente, apresente uma mensagem de erro contendo "#112. Comando negate inválido. A variável: " junto com o frase desta segunda termo seguido de "' não foi encontrada." e o percorredor; retorne.
  Adicione uma variável intermediária usando o nome do tipo desta segunda termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável desta segunda termo e "para" e a variável intermediária e o endereço local desta segunda termo.
  Adicione two fragmentos usando "negate" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe o frase deste termo.

Etapas para que se compile um termo usando um percorredor (nova variável local):
  Se existir algum problema de compilação, retorne.
  Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "#113. Rotina não localizada. Não foi possível desempilhar o item da stack." e o percorredor; retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome desta variável local.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome desta variável local com o nome.
  Se o segmento inicial deste percorredor for uma keyword de designação, compile a parte designadora usando o percorredor e a variável local.
  Destrinche a variável local.
  Se a variável local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente a mensagem de erro contendo "#114. O parâmetro: " junto com o nome desta variável local seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local; retorne.
  Se a variável local estiver duplicada em as variáveis locais desta rotina utilizada atualmente, apresente a mensagem de erro contendo "#115. A variável local " junto com o nome desta variável local seguido de "' já foi declarada nesta rotina. Utilize um nome de variável diferente." e o endereço local desta variável local; retorne.
  Elimine apelidos duplicados usando a variável local e o apelido catálogo desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a frase deste termo.
  Compile o termo usando o percorredor (possessives).

Etapas para que se compile um termo usando um percorredor (adição de termo):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#116. Comando Posigate inválido. O termo da variável'" junto com a frase deste termo seguido de "' não foi localizado." e o percorredor; retorne.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um percorredor (possessivo - magnitude):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#117. Comando magnitude inválido. A variável: " junto com a frase deste termo seguido de "'não foi localizada." e o percorredor; retorne.
  Adicione um valor literal para os valores literais usando o caractere inicial deste segmento inicial deste percorredor.
  Converta a quantidade de caracteres deste tipo deste termo para os data deste valor literal.
  Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal.
  Atribua o valor literal à variável deste termo.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um percorredor (possessivo - conteúdo):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#118. Palavra-chave 'conteúdo' detectada, mas o termo da variável: " junto com a frase deste termo seguido de "' não foi devidamente definido." e o percorredor; retorne.
  Se o tipo deste termo não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "#119. A palavra 'conteúdo' exige valores do tipo 'ponteiro'." e o percorredor; retorne.
  Compile o termo usando o percorredor (cláusula de redirecionamento).

Etapas para que se compile um termo usando um percorredor (possessivo - endereçamento):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#120. palavra-chave 'endereçamento' detectada, mas a variável do termo: " junto com a frase deste termo seguido de " não foi localizada." e o percorredor; retorne.
  Adicione uma variável intermediária usando "ponteiro" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e a variável intermediária.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um percorredor (possessive):
  \ similar a "compile um termo usando um percorredor (possessivo reverso)
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se o nome for alguma keyword de obtenção de tamanho de variável, compile o termo usando o percorredor (possessivo - magnitude); retorne.
  Se o nome for algum conteúdo, compile o termo usando o percorredor (possessivo - conteúdo); retorne.
  Se o nome for algum endereçamento, compile o termo usando o percorredor (possessivo - endereçamento); retorne.
  Compile o termo usando o percorredor e o nome (possessive - campo).

Etapas para que se compile um termo usando um percorredor (possessives):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não for algum possessivo inglês, retorne.
  Compile o termo usando o percorredor (possessive).
  Recomece. [percorra novamente o código acima]

Etapas para que se compile um termo usando um percorredor (proporção de execução):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#121. Operador '/' detectada, mas o numerador do termo: " junto com a frase deste termo seguido de " não foi localizada." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um segundo termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste segundo termo for inexistente, apresente a mensagem de erro contendo "#122. Operador '/' detectada, mas o denomiadaor do termo: " junto com o frase deste segundo termo seguido de "' não foi localizado." e o percorredor; retorne.
  Adicione uma variável intermediária usando "proporção" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando "Atribua" e a variável deste termo e "e" e a variável deste segundo termo e "para" e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um percorredor (variável):
  Se existir algum problema de compilação, retorne.
  Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "#123. Rotina inexistente. Impossível desempilhar termo possessivo." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum possessivo reverso, compile o termo usando o percorredor e o nome (possessivo reverso); retorne.
  Encontre uma variável usando o nome.
  Atribua a variável à variável deste termo.
  Atribua "o " à frase deste termo.
  Acrescente o nome para a frase deste termo.
  Compile o termo usando o percorredor (possessives).

Um detector de possessivo reverso é um detector. 

Etapas para que se compile um termo usando um percorredor e um campo nome (possessivo reverso):
  \ função recursiva
  \ Rotina nova criada pelo Dahn para version 2
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ após o starter do possessivo reverso
  \Se o segmento inicial deste percorredor não for "del", mova o percorredor (usando diretrizes de compilação). 
  Se o segmento inicial deste percorredor não for algum artigo, apresente uma mensagem de erro contendo "#124. O compilador esperava encontrar um artigo, mas encontrou: " junto com o segmento inicial deste percorredor seguido de "."; retorne.
  Atribua o segmento inicial deste percorredor para um article segmento inicial.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum possessivo reverso, ative um detector de possessivo reverso.
  Se o detector de possessivo reverso estiver ativo, compile o termo usando o percorredor e o nome (possessivo reverso).
  Se o detector de possessivo reverso não estiver ativo, compile o termo usando o percorredor e o nome e o article (reversão de contrações do possessivo).\ não entendi
  Compile o termo usando o campo nome e o percorredor (possessivo reverso).

Etapas para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações do possessivo):
  \ Rotina nova criada pelo Dahn para version 2
  Se o article for o início of alguma variável, compile o termo usando o percorredor e a variável nome e o article (reversão de contrações de variáveis do possessivo); retorne.
  Compile o termo usando o percorredor e a variável nome (decomposição do possessivo reverso - variável local).

Etapas para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações de variáveis do possessivo):
  \ Rotina nova criada pelo Dahn para version 2
  Encontre uma variável usando a variável nome.
  Se a variável for inexistente, apresente uma mensagem de erro contendo "#125. Não foi possível encontrar a variável: " junto com a variável nome seguido de ".".
  Atribua a variável à variável deste termo.
  Atribua "o " à frase deste termo.
  Acrescente a variável nome para a frase deste termo.

Etapas para que se compile um termo usando um percorredor e uma variável nome (decomposição do possessivo reverso - variável local):
  \ Rotina nova criada pelo Dahn para version 2
  Se existir algum problema de compilação, retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome desta variável local.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome desta variável local.
  Expanda o nome desta variável local com a variável nome.
  Se o segmento inicial deste percorredor for uma keyword de designação, compile a parte designadora usando o percorredor e a variável local.
  Destrinche a variável local.
  Se a variável local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente uma mensagem de erro contendo "#126. O termo: " junto com o nome desta variável local seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local; retorne.
  Se a variável local estiver duplicada em as variáveis locais desta rotina utilizada atualmente, apresente a mensagem de erro contendo "#127. O termo: " junto com o nome desta variável local seguido de "' já está sendo usado coma variável local." e o endereço local desta variável local; retorne.
  Elimine apelidos duplicados usando a variável local e o apelido catálogo desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um campo nome e um percorredor (possessivo reverso):
  \ similar para "compile um termo usando um percorredor (possessive)" \ Rotina nova criada pelo Dahn para
  Se existir algum problema de compilação, retorne.
  Se o campo nome for alguma keyword de obtenção de tamanho de variável, compile o termo usando o percorredor (possessivo - magnitude); retorne.
  Se o campo nome for algum conteúdo, compile o termo usando o percorredor (possessivo - conteúdo); retorne.
  Se o campo nome for algum endereçamento, compile o termo usando o percorredor (possessivo - endereçamento); retorne.
  Compile o termo usando o percorredor e o campo nome (possessive - campo).

Etapas para que se compile um termo usando um percorredor e um campo de estrutura:
  Se existir algum problema de compilação, retorne.
  Se o detector de redirecionamento deste campo de estrutura estiver ativo, compile o termo usando o percorredor (cláusula de redirecionamento).
  Se a rotina de função deste campo de estrutura não for inexistente, compile o termo usando o percorredor e o campo de estrutura (função); retorne.
  Se a categoria deste termo for "scratch", compile o termo usando o percorredor e o campo de estrutura (campos de restruturas); retorne.
  Atribua o campo deste campo de estrutura para um campo.
  Adicione um scratch usando o nome deste tipo deste campo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Se o deslocamento deste campo não for 0, adicione um terceiro fragmento usando a etiqueta de acréscimo e o scratch e o deslocamento deste campo.
  Atribua o scratch à variável deste termo.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um percorredor e um campo de estrutura (função):
  Se existir algum problema de compilação, retorne.
  Atribua a rotina de função deste campo de estrutura para uma rotina.
  Atribua o last parâmetro destes parâmetros desta rotina para um parâmetro.
  Se o parâmetro for inexistente, apresente uma mensagem de erro contendo "#128. Parâmetro inexistente. Consulte a rotina para que se compile um termo usando um percorredor e um campo de estrutura (função)." e o percorredor; retorne.
  Se o tipo deste parâmetro for inexistente, apresente a mensagem de erro contendo "#129. Tipo de parâmetro inexistente. Consulte a rotina para que se compile um termo usando um percorredor e um campo de estrutura (função)" e o percorredor; retorne.
  Adicione uma variável intermediária usando o nome deste tipo deste parâmetro e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando o etiqueta de inserção de endereço [na stack] e a variável intermediária.
  Se o detector de empilhamento deste campo de estrutura estiver ativo, adicione um segundo fragmento usando o etiqueta de inserção de endereço [na stack] e a variável deste termo.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um percorredor e um campo de estrutura (campos de restruturas):
  Se existir algum problema de compilação, retorne.
  Atribua o campo deste campo de estrutura para um campo.
  Atribua o nome deste tipo deste campo ao nome do tipo deste termo.
  Atribua o tipo deste campo ao tipo deste termo.
  Se o deslocamento deste campo não for 0, adicione um terceiro fragmento usando a etiqueta de acréscimo e a variável deste termo e o deslocamento deste campo.
  Limpe a frase deste termo.

Etapas para que se compile um termo usando um percorredor e um nome (possessive - campo):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo não for inexistente, atribua o tipo deste termo para um tipo.
  Encontre um campo de estrutura usando o frase deste termo e o tipo e o nome.
  Se o campo de estrutura não estiver vazio, compile o termo usando o percorredor e o campo de estrutura; retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#130. A variável do termo '" junto com a frase deste termo seguido de "' não localizada." e o percorredor; retorne.
  Se o tipo puder ser reduzido para "ponteiro", atribua o tipo do conteúdo deste tipo ao tipo.
  Se o tipo for inexistente, apresente a mensagem de erro contendo "#131. O tipo: " junto com o nome seguido de "' não foi localizada na estrutura: " junto com o nome deste tipo deste termo seguido de "." e o percorredor; retorne.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, apresente a mensagem de erro contendo "#132. O campo '" junto com o nome seguido de "' não foi localizado na estrutura '" junto com o nome deste tipo deste termo seguido de "'." e o percorredor; retorne.
    Encontre um deep campo de estrutura usando "" e o tipo deste campo e o nome.
    Se o deep campo de estrutura estiver vazio, recomece.
  Atribua o campo para o campo dum first campo de estrutura.
  Se o tipo deste termo puder ser reduzido para "ponteiro", ative o detector de redirecionamento deste first campo de estrutura.
  Compile o termo usando o percorredor e o first campo de estrutura.
  Compile o termo usando o percorredor e o deep campo de estrutura.

Um detector de redirecionamento é um detector.

Etapas para que se converta umas unidades semânticas para uma representação interna da rotina :
  Converta as unidades semânticas para a representação interna da rotina usando o last unidade semântica destes unidades semânticas.

Etapas para que se converta umas unidades semânticas para uma representação interna da rotina usando uma unidade semântica:
  Limpe a representação interna da rotina.
  Comece. [a executar o código abaixo]
    Obtenha um current unidade semântica desde as unidades semânticas.
    Se o current unidade semântica for inexistente, retorne.
    Acrescente o current unidade semântica para a representação interna da rotina.
    Se o current unidade semântica for a unidade semântica, retorne.
  Recomece. [percorra novamente o código acima]

\Etapas para que se converta uma parte da cifra binária para uma string:
  \Employ converta uma cifra hexadecimal para um texto hexadecimal.

Etapas para que se converta um termo por concatenação usando um percorredor: \\ concatenação
  \ used for right-side followed by operand
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "#133. A variável do termo '" junto com a frase deste termo seguido de "' não pode ser encontrada." e o percorredor; retorne.
  Se o tipo deste termo puder ser reduzido para "string", retorne.
  Se o tipo deste termo puder ser reduzido para "texto", retorne.
  Adicione uma variável intermediária usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione uma variável intermediária usando "texto" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragmentos usando a variável deste termo e a variável intermediária e o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Etapas para que se copie um campo para um segundo campo:
  Se o campo for inexistente, esvazie o segundo campo; retorne.
  Aloque memória para o segundo campo.
  Atribua o endereço local deste campo ao endereço local deste segundo campo.
  Atribua o nome deste campo ao nome deste segundo campo.
  Atribua o apelido deste campo ao apelido deste segundo campo.
  Atribua o nome do tipo deste campo ao nome do tipo deste segundo campo.
  Atribua o tipo deste campo ao tipo deste segundo campo.
  Atribua a contagem deste campo à contagem deste segundo campo.
  Atribua o nome de redefinição de conteúdo deste campo ao nome de redefinição de conteúdo deste segundo campo.
  Atribua o detector de referência deste campo ao detector de referência deste segundo campo.
  Atribua o deslocamento deste campo ao deslocamento deste segundo campo.

Etapas para que se copie uns campos para uns segundo campos:
  Obtenha um campo desde o campos.
  Se o campo for inexistente, retorne.
  Copie o campo para um segundo campo.
  Acrescente o segundo campo para o segundo campos.
  Recomece. [percorra novamente o código acima]

Etapas para que se copie uns campos para uns segundo campos (apenas campos de dados):
  Se a contagem destes campos for menor do que 4, retorne. \ for english subsequente e prev e spanish subsequente e prev redefinitions
  \Se o first destes campos for inexistente, retorne.
  \Se o subsequente deste first destes campos for inexistente, retorne.
  \Se o subsequente deste subsequente deste first destes campos for inexistente, retorne.
  \Atribua o subsequente deste subsequente deste first destes campos para um campo. \ skip subsequente e prev
  \Se o subsequente deste subsequente deste subsequente deste first destes campos for inexistente, retorne.
  \Se o subsequente deste subsequente deste subsequente deste subsequente deste first destes campos for inexistente, retorne.
  \Se o subsequente deste subsequente deste subsequente deste subsequente deste subsequente deste first destes campos for inexistente, retorne.
  \Atribua o subsequente deste subsequente deste subsequente deste subsequente deste first destes campos para um campo.
  Atribua o subsequente campo 
    deste subsequente campo 
    deste subsequente campo 
    deste subsequente campo 
    deste first campo destes campos 
  para um campo.\ english subsequente e prev e spanish subsequente e prev redefinitions
  \ talvez mudar isso aqui ajude?
  Comece. [a executar o código abaixo]
    Se o campo for inexistente, retorne.
    Copie o campo para um segundo campo.
    Acrescente o segundo campo para o segundo campos.
    Obtenha o campo desde o campos.
  Recomece. [percorra novamente o código acima]

Etapas para que se copie uma unidade semântica para uma segunda unidade semântica:
  Se a unidade semântica for inexistente, esvazie a segunda unidade semântica; retorne.
  Aloque memória para o segunda unidade semântica.
  Atribua a string desta unidade semântica à string desta segunda unidade semântica.
  Atribua o tipo desta unidade semântica ao tipo desta segunda unidade semântica.
  Atribua a variável desta unidade semântica à variável desta segunda unidade semântica.
  \ não copia subtexto
  Atribua o tipo atual desta unidade semântica ao tipo atual desta segunda unidade semântica.

Etapas para que se copie umas unidades semânticas para uns segunda unidades semânticas:
  Destrua a segunda unidades semânticas.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Copie a unidade semântica para uma segunda unidade semântica.
    Acrescente a segunda unidade semântica para a segunda unidades semânticas.
  Recomece. [percorra novamente o código acima]

Etapas para que se crie uma função:
  Aloque memória para a função.

Etapas para que se crie um fragmento usando uma etiqueta:
  Aloque memória para o fragmento.
  Atribua a etiqueta à etiqueta deste fragmento.

Etapas para que se crie uma DLL:
  Aloque memória para a DLL.

Etapas para que se crie uma unidade semântica:
  Aloque memória para a unidade semântica.

Etapas para que se crie uma rotina:
  Aloque memória para a rotina.

Etapas para que se crie um arquivo fonte:
  Aloque memória para o arquivo fonte.

Etapas para que se crie um tipo:
  Aloque memória para o tipo.
  Atribua 0/1 à razão de escala deste tipo.
  Atribua -1 à quantidade de caracteres deste tipo.

Etapas para que se crie uma variável usando um categoria:
  Aloque memória para a variável.
  Atribua a categoria à categoria desta variável.
  Atribua 1 à contagem desta variável.

O endereço do cabeçalho usado atualmente é um endereço.

O endereço do nome usado atualmente é um endereço.

O rotina utilizada atualmente é uma rotina.

O endereço pré-calculado atual é um endereço.

A região de dados é um zona.

Etapas para que se determine se alguns of umas unidades semânticas são advérbios de negação:
  Obtenha uma unidade semântica desde as unidades semânticas.
  Se a unidade semântica for inexistente, diga não.
  Se a string desta unidade semântica for algum advérbio de negação, diga sim.
  Recomece. [percorra novamente o código acima]

Um byte ignorável é um byte.

Etapas para que se determine se um byte é um byte ignorável:
  Se o byte for algum letra, diga sim.
  Se o byte for algum digit, diga sim.
  Se o byte for o acento til, diga sim.
  Se o byte for o sinal de arroba, diga sim.
  Se o byte for o símbolo cardinal, diga sim.
  Se o byte for o sinal de porcentagem, diga sim.
  Se o byte for o & comercial, diga sim.
  Se o byte for o underline, diga sim.
  Se o byte for o single-quote byte, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o slash byte, diga sim.
  Se o byte for o símbolo da Libra Esterlina, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum sinal de pontuação:
  Se o byte for o ponto final, diga sim.
  Se o byte for o vírgula, diga sim.
  Se o byte for o ponto&vírgula, diga sim.
  Se o byte for o sinal de dois pontos, diga sim.
  Se o byte for o ponto de exclamação, diga sim.
  Se o byte for o ponto de interrogação, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é alguma vogal acentuada:
  Se o byte estiver em "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum símbolo: \ deveria estar no cérebro
  Se o byte for o acento circumflexo, diga sim.
  Se o byte for o barra vertical, diga sim.
  Se o byte for o asterisco, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o slash byte, diga sim.
  Se o byte for o símbolo menor do que, diga sim.
  Se o byte for o símbolo maior do que, diga sim.
  Se o byte for a chave esquerda, diga sim.
  Se o byte for a chave direita, diga sim.
  Se o byte for o sinal de igualdade, diga sim.
  Se o byte for 128, diga sim.
  Se o byte for 130, diga sim.
  Se o byte estiver entre 132 e 137, diga sim.
  Se o byte for 139, diga sim.
  Se o byte estiver entre 145 e 153, diga sim.
  Se o byte for 155, diga sim.
  Se o byte estiver entre 161 e 180, diga sim.
  Se o byte estiver entre 183 e 191, diga sim.
  Se o byte for 215, diga sim.
  Se o byte for 247, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma campo de estrutura está vazia;
Etapas para que se determine se umas campo de estrutura estão vazias;
Etapas para que se determine se uns campo de estrutura estão vazios;
Etapas para que se determine se um campo de estrutura está vazio:
  Se o campo deste campo de estrutura não for inexistente, diga não.
  Se a rotina de função deste campo de estrutura não for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uns campos deveriam ser finalizados;
Etapas para que se determine se uns campos deveria ser finalizado:
  Obtenha um campo desde o campos.
  Se o campo for inexistente, diga não.
  Se o tipo deste campo deveria ser finalizado, diga sim.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um item parece ser encadernável:
  Carregue o endereço completo deste item para um trecho.
  Se o trecho começa com "ream cal", diga sim. \ CONFERIR AQUI. "TRECHO" E "COMEÇA COM"
  Se o trecho começa com "Documento produzido pelo Editor de Documentos", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma representação interna da rotina está em um catálogo:
  Encontre um referência usando a representação interna da rotina e o catálogo.
  Se o referência for inexistente, diga não.
  Se o ponteiro deste referência for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma unidade semântica está bubbled out:
  Se a unidade semântica for inexistente, diga sim.
  Se o tipo atual desta unidade semântica não for inexistente, diga não.
  Se o subtexto atual desta unidade semântica não estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um nome é alguma keyword de obtenção de tamanho de variável:
  Se o nome for "magnitude", diga sim.  \ A "magnitude" retorna o tamanho em bytes de algo
  \Se o nome for "grandeza", diga sim.  
  \Se o nome for " grandiosidade", diga sim.  
  \Se o nome for " envergadura", diga sim.  
  \ Exemplo: a magnitude duma string
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum conteúdo:  
  Se o nome for "conteúdo", diga sim.
  \Este comando é usado apenas com ponteiros (endereços de memória). 
  \ Serve pra saber para quais valores o ponteiro está apontando, ou seja, o conteúdo do ponteiro . 
  \"Um endereço de byte" ou "O ponteiro do byte", por exemplo, refere-se ao endereço de um byte. 
  \"O conteúdo deste endereço de byte" refere-se, portanto aos dados no contidos no byte
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum endereçamento:
  Se o nome for "endereçamento", diga sim.  \ retorna o endereço do dado  
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum nome de campo válido:
  Se o nome for alguma keyword de obtenção de tamanho de variável, diga não.
  Se o nome for algum conteúdo, diga não.
  Se o nome for algum endereçamento, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está acompanhado por algum unidade de medida:
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o percorredor não estiver sobre algum indicador de início de variável, diga não.
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente, diga não.
  Se o nome não for "times", diga sim. \ special because times é um infix operador e uma unidade de medida
  \Se o nome não for "vezes", diga sim.
  Se o segmento inicial deste percorredor for o início of alguma expressão matematica, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum nested double-quote:
  Se o segmento final deste percorredor começa com """""", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum possessivo inglês:
  Se o segmento final deste percorredor estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o single-quote byte, diga não. \ apóstrofo
  Se o percorredor estiver sobre algum possessivo inglês (tipo 1 - single-quote, s, non-glom-byte), diga sim.
  Se o percorredor estiver sobre algum possessivo inglês (tipo 2 - preceding s, single-quote, non-glom-byte), diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum possessivo inglês (tipo 1 - single-quote, s, non-glom-byte):
  Se o segmento final deste percorredor não começa com "'s", diga não.
  Isole o percorredor.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum possessivo inglês (tipo 2 - preceding s, single-quote, non-glom-byte):
  Isole o percorredor.
  Se o caractere inicial deste segmento final deste percorredor for o caractere inicial desta cópia da string original deste percorredor, diga não.
  Subtraia 1 desde o caractere inicial deste segmento final deste percorredor.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o s minúsculo ou o S maiúsculo, diga não.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum simile:
  \ added for invisible turtle project ***
  Isole o percorredor.
  Se o segmento inicial deste percorredor for "like", diga sim.
  Se o segmento inicial deste percorredor não for "as", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor é o início of alguma função:
  Se existir algum problema de compilação, diga não.
  \Se o segmento inicial deste percorredor for "Ponha", diga sim.
  \Se o segmento inicial deste percorredor não for algum comando de atribuição, diga não.
  Se o segmento inicial deste percorredor não for "atribua", diga não.
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string deveria ser expandida usando uma segunda string (análise de termos compostos):  
  Se a string não for "partir", diga não.
  Se a string não for "partindo", diga não.
  Se a segunda string não for "de", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com alguma consoante e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for alguma consoante, diga não.
  Se a string não termina com a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com algum vogal e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for algum vogal, diga não.
  Se a string não termina com a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com alguma vogal ou com alguma consoante:
  Se a string termina com algum vogal, diga sim.
  Se a string termina com alguma consoante, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string termina com alguma consoante:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for alguma consoante, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com algum vogal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for algum vogal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum operador de adição:
  \PAL
  Se a string for "mais", diga sim.
  \CAL
  \Se a string for "plus", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de atribuição: 
  \"Etapas para que se acrescente uma string para uma segunda string usando uma terceira string (para expandir contrações)"
  Se a string for "atribua", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de subtração:  
  Se a string for "menos", diga sim.    
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de multiplicação:  
  Se a string for "vezes", diga sim.  
  Se a string for "times", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de divisão:
  Se a string for "dividido", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum objeto indireto:  
  Se a string for "via", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
  Se a string for "por", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum palavra de concatenação:
  Se a string for "com", diga sim. 
  Se a string for "de", diga sim.
  Se a string for "a", diga sim.
  Se a string for "seguida", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de concatenação:
  Se a string for "junto", diga sim. \ junto do/da, junto com o ...
  Se a string for "juntamente", diga sim. \ juntamente com o...
  Se a string for "seguido", diga sim. \ seguido do ....
  Se a string for "acompanhado", diga sim. \ acompanhado de... 
  Se a string for "em", diga sim.
  \Se a string for "&", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de atribuição de estruturas compostas:
  Se a string for "tem", diga sim.
  Se a string for "têm", diga sim.
  Se a string for "contém", diga sim.
  Se a string for "contêm", diga sim.
  \Se a string for "possui", diga sim.  
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de atribuição simples:
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estarem", diga sim.
  Se a string for "possui", diga sim.
  \Se a string for "tem", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de atribuição composto:
  Se a string for "igual", diga sim.
  [Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma keyword de complementação:
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo:
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma conjunção:
  \# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  Se a string for "nem", diga sim.
  \CAL
  Se a string for "both", diga sim.
  Se a string for "but", diga sim.
  Se a string for "either", diga sim.
  Se a string for "neither", diga sim.
  Se a string for "nor", diga sim.
  Se a string for "or", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum to:
  Se a string for "a", diga sim. \ questionável
  Se a string for "para", diga sim. 
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador de continuidade:
  Se a string for "e", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não. \repetido?

Etapas para que se determine se uma string é alguma função possessiva reversa into:  
  Se a string for "em", diga sim.
  Se a string for "para", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de deliberação literal:
  Se a string for "sim", diga sim.
  Se a string for "positivo", diga sim.
  Se a string for "positivamente", diga sim.
  Se a string for "afirmativamente", diga sim.
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
  Se a string for "no", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum decisor literal afirmativo:
  Se a string for "sim", diga sim.
  Se a string for "positivo", diga sim.
  Se a string for "positivamente", diga sim.
  Se a string for "afirmativamente", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum decisor literal negativo:
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum valor hexadecimal literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o cifrão, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo definido:
  Se a string for "o", diga sim.
  Se a string for "a", diga sim.
  Se a string for "os", diga sim.
  Se a string for "as", diga sim.
  Se a string for algum pronome demonstrativo adjacente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum pronome demonstrativo:
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum pronome demonstrativo adjacente:
  Se a string for "este", diga sim.
  Se a string for "esta", diga sim.
  Se a string for "estes", diga sim.
  Se a string for "estas", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum pronome demonstrativo abrangente:
  Se a string for "esse", diga sim.
  Se a string for "essa", diga sim.
  Se a string for "aquele", diga sim.
  Se a string for "aquela", diga sim.
  Se a string for "esses", diga sim.
  Se a string for "essas", diga sim.
  Se a string for "aqueles", diga sim.
  Se a string for "aquelas", diga sim.
  Se a string for "certo", diga sim.
  Se a string for "certa", diga sim.
  Se a string for "certos", diga sim.
  Se a string for "certas", diga sim.
  Se a string for "determinado", diga sim.
  Se a string for "determinada", diga sim.
  Se a string for "determinados", diga sim.
  Se a string for "determinadas", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum artigo definido:
  Se o percorredor estiver sobre algum preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum artigo definido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum artigo indefinido:
  Se o percorredor estiver sobre algum preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum artigo indefinido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum preposição conectiva:
  Se o segmento inicial deste percorredor não for "a", diga não.
  Isole o percorredor. 
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo indefinido: 
  Se a string for algum artigo indefinido português, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
  \CAL
  Se a string for algum artigo indefinido inglês, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo indefinido inglês:
  \CAL
  \Se a string for "an", diga sim.
  \Se a string for "another", diga sim.
  \Se a string for "some", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum artigo indefinido português: \ é aqui que se deve colocar o possessivo. descobri.
  \PAL
  Se a string for "um", diga sim.
  Se a string for "uma", diga sim.
  Se a string for "uns", diga sim.
  Se a string for "umas", diga sim.
  \Se a string for "outro", diga sim.
  \Se a string for "outra", diga sim.
  \Se a string for "algum", diga sim.
  \Se a string for "alguma", diga sim.
  \Se a string for "alguns", diga sim.
  \Se a string for "algumas", diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum valor literal:
  Se a string for algum ponteiro literal, diga sim.
  Se a string for algum valor numérico literal, diga sim.
  Se a string for algum string literal, diga sim.
  \Se a string for algum detector literal, diga sim. ***
  Se a string for algum valor hexadecimal literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum sinal de pontuação:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum sinal de pontuação, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se uma string é algum unidade semântica string:
\Se a string estiver em branco, diga não.
\Se a string for "the", diga não.
\Se a string é algum artigo indefinido, diga não.
\Se a string é algum possessivo inglês, diga não.
\Se a string é algum valor literal, diga não.
\Se a string é algum sinal de pontuação, diga não.
\Se a string é algum símbolo, diga não.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum unidade semântica string:
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Se o percorredor estiver sobre algum artigo definido, diga não.
  Se o percorredor estiver sobre algum artigo indefinido, diga não.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for "então", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é uma keyword de designação:
  Se a string for "chamado", diga sim.
  Se a string for "chamados", diga sim.
  Se a string for "chamada", diga sim.  
  Se a string for "chamadas", diga sim.
  Se a string for "denominado", diga sim.
  Se a string for "denominados", diga sim.
  Se a string for "denominada", diga sim.
  Se a string for "denominadas", diga sim.
[Caso as condições acima não puderem ser satisfeitas, então:] Diga não.

Uma keyword de referenciamento é uma keyword.

Etapas para que se determine se uma string é uma keyword de referenciamento:
  Se a string for "(referência)", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum indicador de fim de variável:
  \ compare com indicador de início de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga sim.
  Se o segmento inicial deste percorredor for algum símbolo, diga sim.
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga sim.
  Se o percorredor estiver sobre algum possessivo reverso, diga sim.
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga sim.
  Se o segmento inicial deste percorredor for algum valor literal, diga sim.
  Se o segmento inicial deste percorredor for uma keyword de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga sim.
  Se o segmento inicial deste percorredor for algum advérbio de negação, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum indicador de início de variável:
  \ compare com indicador de fim de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for algum artigo, diga não.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for uma keyword de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum advérbio de negação:
  Se a string for "não", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operador aritmético:
  Se a string for "mais", diga sim.
  Se a string for "menos", diga sim.
  Se a string for "vezes", diga sim.
  Se a string for "dividido", diga sim.
  Se a string for "depois", diga sim.
  Se a string for "seguido", diga sim.
  Se a string for "juntamente", diga sim.
  Se a string for "junto", diga sim.
  Se a string for "acompanhado", diga sim.
  Se a string for "times", diga sim.
  [Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma pausa:
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  \default
  Se a string for ",", diga sim.
  Se a string for ";", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum ponteiro literal:
  Se a string for "nulo", diga sim.
  Se a string for "nula", diga sim.
  Se a string for "nulos", diga sim.
  Se a string for "nulas", diga sim.
  Se a string for "inexistente", diga sim.
  Se a string for "inexistentes", diga sim.
  Se a string for "zerado", diga sim.
  \CAL
  Se a string for "nil", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum possessivo inglês:
  Se a string for "'s", diga sim.
  Se a string for "'", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre alguma preposição:
  Atribua o segmento inicial deste percorredor para um subtexto.
  Se o percorredor estiver sobre algum preposição conectiva, diga sim. \ "a" no sentido de "para"
  Se o subtexto for "abaixo", diga sim. 
  \Se o subtexto for "baixo", diga sim. 
  Se o subtexto for "acima", diga sim. 
  \Se o subtexto for "cima", diga sim. 
  Se o subtexto for "ante", diga sim. 
  Se o subtexto for "perante", diga sim. 
  Se o subtexto for "antes", diga sim. 
  Se o subtexto for "debaixo", diga sim. 
  Se o subtexto for "sob", diga sim. 
  Se o subtexto for "acerca", diga sim. 
  Se o subtexto for "cerca", diga sim. 
  Se o subtexto for "próximo", diga sim. 
  Se o subtexto for "perto", diga sim. 
  Se o subtexto for "com", diga sim.
  \Se o subtexto for "contendo", diga sim. 
  Se o subtexto for "como", diga sim. 
  Se o subtexto for "contra", diga sim. 
  Se o subtexto for "dada", diga sim. 
  Se o subtexto for "dado", diga sim. 
  Se o subtexto for "dando", diga sim. 
  Se o subtexto for "gerando", diga sim. 
  Se o subtexto for "resultando", diga sim. 
  Se o subtexto for "retornando", diga sim. 
  Se o subtexto for "desde", diga sim. 
  Se o subtexto for "depois", diga sim. 
  Se o subtexto for "após", diga sim. 
  Se o subtexto for "durante", diga sim. 
  Se o subtexto for "em", diga sim. 
  Se o subtexto for "entre", diga sim. 
  Se o subtexto for "dentre", diga sim. 
  Se o subtexto for "até", diga sim. 
  \Se o subtexto for "que", diga sim. 
  \Se o subtexto for "esquerda", diga sim. 
  Se o subtexto for "mediante", diga sim. 
  Se o subtexto for "para", diga sim. 
  Se o subtexto for "via", diga sim. 
  Se o subtexto for "segundo", diga sim.
  Se o subtexto for "acordo", diga sim. 
  Se o subtexto for "sem", diga sim. 
  Se o subtexto for "então", diga sim.
  Se o subtexto for "sobre", diga sim.     
  Se o subtexto for "usando", diga sim. 
  Se o subtexto for "versus", diga sim.
  Se o subtexto for "enquanto", diga sim. 
  Se o subtexto for "redefinindo", diga sim. 
  Se o subtexto for "aproximadamente", diga sim.
  \
  Se o subtexto for "através", diga sim.
  Se o subtexto for "across", diga sim.
  Se o subtexto for "after", diga sim.
  Se o subtexto for "against", diga sim.
  Se o subtexto for "all", diga sim.
  Se o subtexto for "alone", diga sim.
  Se o subtexto for "along", diga sim.
  Se o subtexto for "among", diga sim.
  Se o subtexto for "algum", diga sim.
  Se o subtexto for "anywhere", diga sim.
  Se o subtexto for "around", diga sim.
  \Se o subtexto for "as", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "away", diga sim.
  Se o subtexto for "back", diga sim.
  Se o subtexto for "backward", diga sim.
  Se o subtexto for "backwards", diga sim.
  Se o subtexto for "antes de", diga sim.
  Se o subtexto for "beginning", diga sim.
  Se o subtexto for "behind", diga sim.
  Se o subtexto for "debaixo of", diga sim.
  Se o subtexto for "beneath", diga sim.
  Se o subtexto for "beside", diga sim.
  Se o subtexto for "entre", diga sim.
  Se o subtexto for "beyond", diga sim.
  Se o subtexto for "bigger", diga sim.
  Se o subtexto for "by", diga sim.
  Se o subtexto for "close", diga sim.
  Se o subtexto for "deep", diga sim.
  Se o subtexto for "diagonally", diga sim.
  Se o subtexto for "para baixo", diga sim.
  Se o subtexto for "downward", diga sim.
  Se o subtexto for "ending", diga sim.
  Se o subtexto for "everywhere", diga sim.
  Se o subtexto for "except", diga sim.
  Se o subtexto for "finishing", diga sim.
  Se o subtexto for "facing", diga sim.
  \Se o subtexto for "for", diga sim.
  Se o subtexto for "por", diga sim.
  Se o subtexto for "forward", diga sim.
  Se o subtexto for "from", diga sim.
  Se o subtexto for "given", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "high", diga sim.
  Se o subtexto for "in", diga sim.
  Se o subtexto for "inside", diga sim.
  Se o subtexto for "into", diga sim.
  Se o subtexto for "en", diga sim.
  Se o subtexto for "larger", diga sim.
  Se o subtexto for "leaning", diga sim.
  Se o subtexto for "left", diga sim.
  Se o subtexto for "leftward", diga sim.
  Se o subtexto for "leftways", diga sim.
  Se o subtexto for "like", diga sim.
  Se o subtexto for "limiting", diga sim.
  Se o subtexto for "long", diga sim.
  Se o subtexto for "near", diga sim.
  Se o subtexto for "of", diga sim.
  Se o subtexto for "off", diga sim.
  Se o subtexto for "on", diga sim.
  Se o subtexto for "only", diga sim.
  Se o subtexto for "onto", diga sim.
  Se o subtexto for "out", diga sim.
  Se o subtexto for "outside", diga sim.
  Se o subtexto for "over", diga sim.
  Se o subtexto for "past", diga sim.
  Se o subtexto for "pointing", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "right", diga sim.
  Se o subtexto for "rightward", diga sim.
  Se o subtexto for "rightways", diga sim.
  Se o subtexto for "shorter", diga sim.
  Se o subtexto for "sideway", diga sim.
  Se o subtexto for "sideways", diga sim.
  Se o subtexto for "similar", diga sim.
  Se o subtexto for "smaller", diga sim.
  Se o subtexto for "somewhere", diga sim.
  Se o subtexto for "slantwise", diga sim.
  Se o subtexto for "slantway", diga sim.
  Se o subtexto for "slantways", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se o subtexto for "tall", diga sim.
  Se o subtexto for "taller", diga sim.
  Se o subtexto for "thru", diga sim.
  Se o subtexto for "through", diga sim.
  Se o subtexto for "throughout", diga sim.
  Se o subtexto for "to", diga sim.
  Se o subtexto for "toward", diga sim.
  Se o subtexto for "towards", diga sim.
  Se o subtexto for "under", diga sim.
  Se o subtexto for "underneath", diga sim.
  Se o subtexto for "até que", diga sim.
  Se o subtexto for "unto", diga sim.
  Se o subtexto for "para cima", diga sim.
  Se o subtexto for "upward", diga sim.
  Se o subtexto for "upon", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "while", diga sim.
  Se o subtexto for "wide", diga sim.
  Se o subtexto for "com", diga sim.
  Se o subtexto for "within", diga sim.
  Se o subtexto for "without", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma preposição:
  Se a string for "aproximadamente", diga sim.
  Se a string for "across", diga sim.
  Se a string for "através", diga sim.
  Se a string for "after", diga sim.
  Se a string for "against", diga sim.
  Se a string for "all", diga sim.
  Se a string for "alone", diga sim.
  Se a string for "along", diga sim.
  Se a string for "among", diga sim.
  Se a string for "algum", diga sim.
  Se a string for "anywhere", diga sim.
  Se a string for "around", diga sim.
  \Se a string for "as", diga sim.
  Se a string for "sob", diga sim.
  Se a string for "away", diga sim.
  Se a string for "back", diga sim.
  Se a string for "backward", diga sim.
  Se a string for "backwards", diga sim.
  Se a string for "antes de", diga sim.
  Se a string for "beginning", diga sim.
  Se a string for "behind", diga sim.
  Se a string for "debaixo of", diga sim.
  Se a string for "beneath", diga sim.
  Se a string for "beside", diga sim.
  Se a string for "entre", diga sim.
  Se a string for "beyond", diga sim.
  Se a string for "bigger", diga sim.
  Se a string for "by", diga sim.
  Se a string for "close", diga sim.
  Se a string for "deep", diga sim.
  Se a string for "diagonally", diga sim.
  Se a string for "para baixo", diga sim.
  Se a string for "downward", diga sim.
  Se a string for "ending", diga sim.
  Se a string for "everywhere", diga sim.
  Se a string for "except", diga sim.
  Se a string for "finishing", diga sim.
  Se a string for "facing", diga sim.
  \Se a string for "for", diga sim.
  Se a string for "por", diga sim.
  Se a string for "forward", diga sim.
  Se a string for "from", diga sim.
  Se a string for "given", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "high", diga sim.
  Se a string for "in", diga sim.
  Se a string for "inside", diga sim.
  Se a string for "into", diga sim.
  Se a string for "larger", diga sim.
  Se a string for "leaning", diga sim.
  Se a string for "left", diga sim.
  Se a string for "leftward", diga sim.
  Se a string for "leftways", diga sim.
  Se a string for "like", diga sim.
  Se a string for "limiting", diga sim.
  Se a string for "long", diga sim.
  Se a string for "near", diga sim.
  Se a string for "of", diga sim.
  Se a string for "off", diga sim.
  Se a string for "on", diga sim.
  Se a string for "only", diga sim.
  Se a string for "onto", diga sim.
  Se a string for "out", diga sim.
  Se a string for "outside", diga sim.
  Se a string for "over", diga sim.
  Se a string for "past", diga sim.
  Se a string for "pointing", diga sim.
  Se a string for "retornando", diga sim.
  Se a string for "retornando", diga sim.
  Se a string for "right", diga sim.
  Se a string for "rightward", diga sim.
  Se a string for "rightways", diga sim.
  Se a string for "shorter", diga sim.
  Se a string for "sideway", diga sim.
  Se a string for "sideways", diga sim.
  Se a string for "similar", diga sim.
  Se a string for "smaller", diga sim.
  Se a string for "somewhere", diga sim.
  Se a string for "slantwise", diga sim.
  Se a string for "slantway", diga sim.
  Se a string for "slantways", diga sim.
  Se a string for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se a string for "tall", diga sim.
  Se a string for "taller", diga sim.
  Se a string for "thru", diga sim.
  Se a string for "through", diga sim.
  Se a string for "throughout", diga sim.
  Se a string for "to", diga sim.
  Se a string for "toward", diga sim.
  Se a string for "towards", diga sim.
  Se a string for "under", diga sim.
  Se a string for "underneath", diga sim.
  Se a string for "até que", diga sim.
  Se a string for "unto", diga sim.
  Se a string for "para cima", diga sim.
  Se a string for "upward", diga sim.
  Se a string for "upon", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "via", diga sim.
  Se a string for "while", diga sim.
  Se a string for "wide", diga sim.
  Se a string for "com", diga sim.
  Se a string for "within", diga sim.
  Se a string for "without", diga sim.
  Se a string for "depois", diga sim. \ depois de
  Se a string for "desde", diga sim. 
  Se a string for "aproximadamente", diga sim.
  Se a string for "cerca", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum qualificador:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o parênteses esquerdo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum possessivo reverso:
  Se a string for "de", diga sim.
  \Se a string for "do", diga sim. \ short por "de o", expanded em "compile um termo usando um percorredor e um campo nome (possessivo reverso)"
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum possessivo reverso:
  Isole o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum pronome demonstrativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum string literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for as aspas duplas, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum símbolo:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum símbolo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum verbo:
  \PAL
  Se a string for "deve", diga sim. 
  Se a string for "deveria", diga sim. 
  Se a string for "deveriam", diga sim.
  Se a string for "devem", diga sim. 
  Se a string for "estar", diga sim. 
  Se a string for "ser", diga sim. 
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim. 
  Se a string for "estiver", diga sim. 
  Se a string for "estiverem", diga sim. 
  Se a string for "estamos", diga sim.
  Se a string for "há", diga sim. 
  Se a string for "houver", diga sim. 
  Se a string for "é", diga sim. 
  Se a string for "está", diga sim. 
  Se a string for "são", diga sim. 
  Se a string for "estão", diga sim. 
  Se a string for "foi", diga sim. 
  Se a string for "estava", diga sim. 
  Se a string for "foram", diga sim. 
  Se a string for "estavam", diga sim. 
  Se a string for "será", diga sim. 
  Se a string for "estará", diga sim. 
  Se a string for "serão", diga sim. 
  Se a string for "estarão", diga sim. 
  Se a string for "existir", diga sim.  
  Se a string for "existe", diga sim.  
  \Se a string for "seja", diga sim. 
  Se a string for "supera", diga sim. 
  Se a string for "superam", diga sim. 
  Se a string for "excede", diga sim. 
  Se a string for "excedem", diga sim. 
  Se a string for "pode", diga sim. 
  Se a string for "puder", diga sim. 
  Se a string for "puderem", diga sim. 
  Se a string for "podem", diga sim. 
  Se a string for "poderia", diga sim. 
  Se a string for "poderia", diga sim. 
  Se a string for "podemos", diga sim. 
  Se a string for "tem", diga sim. 
  Se a string for "têm", diga sim. 
  Se a string for "ter", diga sim. 
  Se a string for "possui", diga sim. 
  Se a string for "possuem", diga sim. 
  Se a string for "possuir", diga sim. 
  \\ trouble makers
  Se a string for "inicia", diga sim. 
  Se a string for "iniciar", diga sim. 
  Se a string for "começa", diga sim.
  Se a string for "começar", diga sim. 
  Se a string for "termina", diga sim. 
  Se a string for "terminar", diga sim. 
  Se a string for "finaliza", diga sim. 
  Se a string for "finalizar", diga sim. 
  Se a string for "parece", diga sim. 
  Se a string for "necessita", diga sim. 
  Se a string for "necessitar", diga sim. 
  Se a string for "requer", diga sim. 
  \CAL
  Se a string for "are", diga sim. 
  Se a string for "be", diga sim. 
  Se a string for "can", diga sim.   
  Se a string for "does", diga sim. 
  Se a string for "is", diga sim. 
  Se a string for "may", diga sim. 
  Se a string for "should", diga sim. 
  Se a string for "was", diga sim. 
  Se a string for "will", diga sim. 
  Se a string for "would", diga sim. 
  Se a string for "has", diga sim. 
  Se a string for "have", diga sim. 
  Se a string termina com "n't", diga sim.
  \\ trouble makers
  Se a string for "begins", diga sim. 
  Se a string for "ends", diga sim. 
  Se a string for "looks", diga sim. 
  Se a string for "needs", diga sim. 
  Se a string for "starts", diga sim. 
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o enunciado de alguma rotina ou variável:  
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.
  \CAL
  Se a string for "to", diga sim.
  \default
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando condicional:
  Se a string for "se", diga sim.
  Se a string for "quando", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de proteção:
  \Se a string for "reserve", diga sim. \-> complicado pois o termo também se refere à reservar (alocar) memória
  \Se a string for "separe", diga sim. \-> separar também é sinônimo de repartir. 
  Se a string for "isole", diga sim.
  Se a string for "conserve", diga sim.
  Se a string for "derive", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de percorrimento:
  Se a string for "percorra", diga sim.
  Se a string for "comece", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de interrupção de repetições:
  Se a string for "pare", diga sim.
  Se a string for "termine", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de retorno de rotina:
  Se a string for "retorne", diga sim.  
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de repetição:  
  Se a string for "recomece", diga sim.
  Se a string for "repita", diga sim.
  \Se a string for "reinicie", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de confirmação ou negação:
  Se a string for "diga", diga sim. 
  Se a string for "responda", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de deliberação:
  Se a string for "decida", diga sim.
  Se a string for "determine", diga sim.
  Se a string for "esclareça", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma chamada de biblioteca externa:
  Se a string for "chame", diga sim.
  Se a string for "invoque", diga sim.
  \Se a string for "acione", diga sim. 
  Se a string for "processe", diga sim.
  \Se a string for "informe", diga sim.\ no caso de comandos como "informe os parâmetros x e y e z para a função "FunctionName" da biblioteca "MyLibrary.dll"
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum point:
  Se a string for "aponte", diga sim.
  Se a string for "direcione", diga sim.
  Se a string for "redirecione", diga sim.
  \CAL
  Se a string for "point", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Uma keyword de reutilização de rotina é uma keyword.

Etapas para que se determine se uma string é uma keyword de reutilização de rotina:
  \ Funcionalidade obsoleta desde a implantação da sobrecarga de cabeçalhos de rotina
  Se a string for "empregue", diga sim.  
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma palavra ignorável:  
  Se a string for "já", diga sim.
  Se a string for "ainda", diga sim.
  \Se a string for "que", diga sim.
  \Se a string for "se", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of alguma expressão matematica:
  Se a string for algum sinal aritmético, diga sim.
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Se a string for algum valor literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of alguma variável global:
  Se a string for algum artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of alguma variável local:
  Se a string for algum artigo indefinido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum dado complementar:
  \PAL
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of alguma rotina:
  \PAL
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.  
  Se a string for "Procedimento", diga sim.
  Se a string for "Rotina", diga sim.
  Se a string for "Para", diga sim.
  Se a string for "Função", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of alguma declaração:
  Se a string for o enunciado de alguma rotina ou variável, diga não.
  Se a string for algum valor literal, diga não.
  Se a string for algum sinal de pontuação, diga não.
  Se a string estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é o início of algum tipo:
  Se a string for algum artigo indefinido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of alguma variável:
  Se a string for algum artigo definido, diga sim.
  \Se a string for "do", diga sim. \ this é iffy, here por reverse-possessives
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string possui alguma vogal acentuada:
  Isole a string.
  Comece. [a executar o código abaixo]
    Se a string estiver em branco, diga não.
    Se o conteúdo deste caractere final desta string for alguma vogal acentuada, diga sim.
    Subtraia 1 desde o caractere final desta string.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma termo está vazia;
Etapas para que se determine se uns termo estão vazias;
Etapas para que se determine se uns termo estão vazios;
Etapas para que se determine se um termo está vazio:
  Se a variável deste termo não for inexistente, diga não.
  Se a frase deste termo não estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um tipo pode ser reduzido para uma string usando o nome do tipo primitivo:
  Se o tipo for inexistente, diga não.
  Se o nome deste tipo for a string, diga sim.
  Se o detector de recursividade deste tipo estiver ativo, diga não.
  Ative o detector de recursividade deste tipo.
  Encontre um tipo base usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  Se o tipo base for inexistente, desative o detector de recursividade deste tipo; diga não.
  Se o tipo base puder ser reduzido para a string usando o nome do tipo primitivo, desative o detector de recursividade deste tipo; diga sim.
  Desative o detector de recursividade deste tipo.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um tipo pode ser reduzido para um nome do tipo:
  Se o tipo for inexistente, diga não.
  Isole o tipo.
  Comece. [a executar o código abaixo]
    Se o tipo for inexistente, diga não.
    Se o nome deste tipo for o nome do tipo, diga sim.
    Se o tipo base deste tipo for o tipo, diga não.
    Atribua o tipo base deste tipo ao tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um tipo é algum tipo pré-definido:
  Se o tipo for inexistente, diga não.
  Se o tipo for o tipo base deste tipo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um tipo é valor empilhável:
  Se o tipo for inexistente, diga não.
  Se a quantidade de caracteres deste tipo for 4, diga sim.
  Se a quantidade de caracteres deste tipo for 2, diga sim.
  Se a quantidade de caracteres deste tipo for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um tipo deveria ser finalizado:[se o compilador deveria liberar a memória alocada para algum tipo]
  \The frase "should be finalized" means "ought to be/needs to be automatically deallocated".
  Se o tipo for inexistente, diga não.
  Se o tipo puder ser reduzido para "subtexto", diga não.\ substrings point to (parts of) real strings that get deallocated elsewhere
  Se o tipo puder ser reduzido para "string", diga sim.\ the normal case for strings
  Se o tipo puder ser reduzido para "texto", diga sim.\ the normal case for strings
  Se os campos deste tipo deveriam ser finalizados, diga sim.\ this is for strings inside records
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um tipo deveria ser ignorado: [ou seja, o compilador não deveria finalizar esse tipo de forma automática]
  \ ie, can be destroyed/needs a destroy routine generated for it
  \The frase "should be forgotten" means "ought to be forgotten" which really means "needs to have a destroy routine automatically generated for it". 
  \See page 93 of the manual.
  Se o tipo for inexistente, diga não.
  \PAL
  \Se o nome deste tipo for "elemento", diga não.
  \Se o nome deste tipo for "elementos", diga não.
  \CAL
  Se o nome deste tipo for "lista", diga não. \ no, because this is the tipo primitivo which we don't ever allocate or destroy, it exists so we can "magically" add subsequente and precedente fields to anything defined as a "thing"
  Se o nome deste tipo for "listas", diga não. \ no, because this is the tipo primitivo we "magically" generate to anchor lists of things, same as above of .
  Se o tipo puder ser reduzido para "listas", diga sim. \ yes, because (though it seems to contradict the line immediately above of ) this is a an actual list of things that we can destroy, for example "some pages".
  Se o tipo não puder ser reduzido para "ponteiro", diga não. \ \ no, because a pointer variable is a static variable (it is the address in the variable that is dynamic); the pointer variable itself is not something that can be dynamically allocated, so no destroy is necessary
  Se o tipo do conteúdo deste tipo for inexistente, diga não. \ no, because it's a pointer to nothing, so there's nothing to destroy.
  Se o tipo do conteúdo deste tipo não puder ser reduzido para "ponteiro", diga sim.\ yes, because it's a pointer to something allocated, not a pointer to another pointer. Pointers to pointers are handled with the subsequente recursive line
  Se o tipo do conteúdo deste tipo não deveria ser ignorado, diga não.\ no, because it's a pointer to something that shouldn't be destroyed. For example, a pointer to a thing
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.\ The last condition is the hardest to wrap one's head around since it is recursive.

Etapas para que se determine se uma variável está duplicada em umas variáveis:
  Obtenha uma segunda variável desde as variáveis.
  Se a segunda variável for inexistente, diga não.
  Se o nome desta segunda variável estiver em branco, recomece.
  Se a segunda variável for a variável, recomece.
  Se o nome desta segunda variável for o nome desta variável, diga sim.
  Recomece. [percorra novamente o código acima]

Um cabeçalho DOS é uma estrutura com
\ Documentação: -> https://learn.microsoft.com/pt-br/windows/win32/debug/pe-format#file-headers
  Uma word denominada Signature, 
  Uma word denominada NumberOfBytesOnLastPage, 
  Uma word denominada NumberOfPages, 
  Uma word denominada Relocations,
  Uma word denominada SizeOfHeaderInParagraphs,
  Uma word denominada MinimumExtraParagraphsNeeded,
  Uma word denominada MamixmumExtraParagraphsNeeded, 
  Uma word denominada InitialRelativeSS,  \\ Initial Sstack segment
  Uma word denominada InitialSP,  \\ Initial Stack Pointer value.
  Uma word denominada InitialChecksum,  
  Uma word denominada InitialIP,  \\ Initial Instruction Pointer value.
  Uma word denominada InitialRelativeCS, \\ Pre-relocated initial CS register value.  
  Uma word denominada AddressOfRelocationTableInFile, \ 
  Uma word denominada OverlyNumber,
  8 bytes denominados ReservedBytes, 
  Uma word denominada OEM_Identifier, 
  Uma word denominada OEM_Info, 
  20 bytes denominados ReservedWords, 
  Um número denominado AddressOfPEHeaderInFile.  

Etapas para que se elimine apelidos duplicados desde umas variáveis:
  Crie um catálogo usando 101.
  Elimine apelidos duplicados desde as variáveis usando o catálogo.
  Destrua o catálogo.

Etapas para que se elimine apelidos duplicados desde umas variáveis usando um catálogo:
  Se o catálogo for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Obtenha uma variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Elimine apelidos duplicados usando a variável e o catálogo.
  Recomece. [percorra novamente o código acima]

Etapas para que se elimine apelidos duplicados usando uma variável e um catálogo:
  Se a variável for inexistente, retorne.
  Se o catálogo for inexistente, retorne.
  Encontre uma segunda variável usando o apelido desta variável e o catálogo.
  Se a segunda variável for inexistente, encontre a segunda variável usando o nome desta variável e o catálogo.
  Se a segunda variável for inexistente, catalogue a variável usando o apelido desta variável e o catálogo; retorne.
  Limpe o apelido desta segunda variável.
  Limpe o apelido desta variável.

Um endereço thunk é um endereço.
Um endereço do nome é um endereço.

Uma função é uma lista com
  Um endereço do nome,
  Um endereço thunk, \ consulte https://en.wikipedia.org/wiki/Thunk e 
  \ http://ftp.informatik.rwth-aachen.de/jargon300/thunk.html para mais informações
  \ Em programação de computador , um thunké uma sub-rotina usada para injetar um cálculo em outra sub-rotina. 
  \Thunks são usados principalmente para atrasar um cálculo até que seu resultado seja necessário ou para inserir operações no início ou no final de outra sub-rotina. 
  \Eles têm muitos outros usos na geração de código do compilador e em programação modular .
  Um nome e
  Um endereço.

Uma expressão matematica é um termo.

Etapas para que se expanda uma string com uma segunda string:
  Se a segunda string estiver em branco, retorne.
  Se a string não estiver em branco, acrescente o caractere de espaço para a string.
  Acrescente a segunda string para a string.

  
Um campo é uma variável.

Um detector de empilhamento é um detector.

Uma rotina de função é uma rotina.

Um campo de estrutura é uma estrutura com
  Um detector de redirecionamento,
  Um campo (referência),
  Uma rotina de função (referência),
  Um detector de empilhamento.

Etapas para que se finalize o compilador:
  Destrua o catálogo de rotinas úteis.
  Destrua o catálogo geral de rotinas.
  Destrua o catálogo de variáveis hexadecimais.
  Destrua o catálogo de variáveis globais.
  Destrua o catálogo de tipos.
  Destrua as DLLs.
  Destrua as rotinas.
  Destrua os valores literais.
  Destrua as variáveis globais.
  Destrua os tipos.
  Destrua os arquivos fontes.

Etapas para que se encontre uma função usando uma string e uns funções:
  Esvazie a função.
  Comece. [a executar o código abaixo]
    Obtenha a função desde as funções.
    Se a função for inexistente, retorne.
    Se o nome desta função for a string, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um campo de estrutura usando um frase e um tipo e um nome:
  Limpe o campo de estrutura.
  Encontre o campo de estrutura usando o tipo e o nome.
  Se o campo deste campo de estrutura não for inexistente, retorne.
  Se a frase não estiver em branco, encontre uma rotina usando "atribua" e a frase e "'s " junto com o nome e "para". \ traduzir
  Se a rotina não for inexistente, atribua a rotina à rotina de função deste campo de estrutura; retorne.
  Se o tipo for inexistente, retorne.
  Encontre a rotina usando "atribua" e o tipo e "'s " junto com o nome e "para".  \traduzir
  Se a rotina não for inexistente, ative o detector de empilhamento deste campo de estrutura; atribua a rotina à rotina de função deste campo de estrutura; retorne.
  \  code below for looking deep within pointers - a debatable feature
  \ Se o tipo do conteúdo deste tipo não for inexistente, encontre a rotina usando "atribua" e o tipo do conteúdo deste tipo e "'s " junto com o nome e "para".
  \ Se a rotina não for inexistente, ative o detector de redirecionamento deste campo de estrutura; atribua a rotina à rotina de função deste campo de estrutura; retorne.

Etapas para que se encontre um campo de estrutura usando um tipo e um nome:
  Se o tipo for inexistente, retorne.
  Encontre um campo usando o nome e os campos deste tipo.
  Se o campo não for inexistente, atribua o campo ao campo deste campo de estrutura; retorne.
  Se o tipo do conteúdo deste tipo não for inexistente, encontre o campo usando o nome e os campos deste tipo do conteúdo deste tipo.
  Se o campo não for inexistente, ative o detector de redirecionamento deste campo de estrutura; atribua o campo ao campo deste campo de estrutura; retorne.

Etapas para que se encontre um fragmento usando um segundo fragmento e uma etiqueta:
  Atribua o segundo fragmento ao fragmento.
  Comece. [a executar o código abaixo]
    Se o fragmento for inexistente, retorne.
    Se a etiqueta deste fragmento for a etiqueta, retorne.
    Atribua o subsequente fragmento deste fragmento ao fragmento.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um fragmento usando um segundo fragmento e uma etiqueta (regressivamente):
  Atribua o segundo fragmento ao fragmento.
  Comece. [a executar o código abaixo]
    Se o fragmento for inexistente, retorne.
    Se a etiqueta deste fragmento for a etiqueta, retorne.
    Atribua o precedente fragmento deste fragmento ao fragmento.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre uma DLL usando uma string:
  Esvazie a DLL.
  Comece. [a executar o código abaixo]
    Obtenha a DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Se o nome desta DLL for a string, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um endereço completo e um número da linha usando um endereço de byte :
  Limpe o endereço completo.
  Atribua 0 ao número da linha.
  Encontre um arquivo fonte usando o endereço de byte .
  Se o arquivo fonte for inexistente, retorne.
  Atribua o endereço completo deste arquivo fonte ao endereço completo.
  Encontre o número da linha usando o arquivo fonte e o endereço de byte .

Etapas para que se encontre uma rotina usando uma representação interna da rotina e uma unidade semântica e um catálogo:
  Se a unidade semântica for inexistente, retorne.
  Esvazie a rotina.
  Isole a representação interna da rotina.
  Atribua o tipo desta unidade semântica ao tipo atual desta unidade semântica.
  Lance o subtexto atual desta unidade semântica sobre a string desta unidade semântica.
  Comece. [a executar o código abaixo]
    Acrescente a unidade semântica para a representação interna da rotina (inserção de colchetes).
    Encontre uma referência usando a representação interna da rotina e o catálogo.
    Se a referência não for inexistente, atribua o ponteiro deste referência à rotina.
    Se a referência não for inexistente, encontre a rotina usando a representação interna da rotina e a subsequente unidade semântica desta unidade semântica e o catálogo.
    Se a rotina não for inexistente, pare.
    Bubble a unidade semântica.
    Se a unidade semântica estiver bubbled out, pare.
    Atribua o original representação interna da rotina ao representação interna da rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre uma rotina usando umas unidades semânticas:
  Esvazie a rotina.
  Encontre a rotina usando uma representação interna da rotina e a first unidade semântica destas unidades semânticas e o catálogo geral de rotinas.

Etapas para que se encontre uma rotina usando uma string e uma segunda string e uma terceira string e um quarto string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o quarto string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um tipo:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um tipo e uma segunda string e um segundo tipo:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o segundo tipo.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um tipo e uma segunda string e uma terceira string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando a terceira string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um tipo e uma segunda string e uma terceira string e uma quarta string e uma quinta string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma quinta unidade semântica para as unidades semânticas usando a quarta string.
  Adicione uma sexta unidade semântica para as unidades semânticas usando a quinta string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Etapas para que se encontre um número da linha usando um arquivo fonte e um endereço de byte :
  Se o endereço de byte for inexistente, atribua 0 ao número da linha; retorne.
  Lance um subtexto sobre o trecho deste arquivo fonte.
  Atribua 1 ao número da linha.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Se o caractere inicial deste subtexto for o endereço de byte , retorne.
    Se o conteúdo deste caractere inicial deste subtexto for o retorno de carro, adicione 1 para o número da linha.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um arquivo fonte usando um endereço de byte :
  Se o endereço de byte for inexistente, esvazie o arquivo fonte; retorne.
  Comece. [a executar o código abaixo]
    Obtenha o arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente, retorne.
    Se o endereço de byte for menor do que o caractere inicial deste trecho deste arquivo fonte, recomece.
    Se o endereço de byte for maior do que o caractere final deste trecho deste arquivo fonte, recomece.

Etapas para que se encontre um tipo e um apelido usando um nome:
  Esvazie o tipo.
  Limpe o apelido.
  Encontre o tipo e o apelido usando o nome (progressivamente).
  Se o tipo não for inexistente, retorne.
  Encontre o tipo e o apelido usando o nome (regressivamente).
  \ TRECHO DA VERSÃO ANTIGA
  \ Lance um subtexto sobre o nome.
  \ Comece. [a executar o código abaixo]
    \ Se o subtexto estiver em branco, retorne.
    \ Encontre o tipo usando o subtexto e o catálogo de tipos.
    \ Se o tipo não for inexistente, pare.
    \ Passe para a palavra subsequente no subtexto.
  \ Recomece. [percorra novamente o código acima]
  \ Atribua o caractere inicial deste nome para caractere inicial deste segundo subtexto. \ está errado
  \ Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  \ Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  \ Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Etapas para que se encontre um tipo e um apelido usando um nome (regressivamente):
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare.
    Passe para a precedente palavra no subtexto. 
  Recomece. [percorra novamente o código acima]
  Atribua o caractere final deste nome para o caractere final dum segundo subtexto.
  Atribua o caractere final deste subtexto mais 2 ao caractere inicial deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Etapas para que se encontre um tipo e um apelido usando um nome (progressivamente):
  \ original - sem alterações
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare.
    Passe para a palavra subsequente no subtexto. \subsequente
  Recomece. [percorra novamente o código acima]
  Atribua o caractere inicial deste nome para o caractere inicial dum segundo subtexto.
  Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Etapas para que se encontre uma variável usando um nome:
  Se a rotina utilizada atualmente for inexistente, esvazie a variável; retorne.
  Encontre a variável usando o nome e as variáveis locais desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e os parâmetros desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis globais.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis hexadecimais.

Etapas para que se encontre uma variável usando um nome e umas variáveis:
  Esvazie a variável.
  Comece. [a executar o código abaixo]
    Obtenha a variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Se o nome desta variável for o nome, retorne.
    Se o apelido desta variável for o nome, retorne.
  Recomece. [percorra novamente o código acima]

Um fragmento é uma lista com
  \ we have three lists in the compiler memory — tipos, variables, and rotinas 
  \ each rotina consists of a series of logical instructions called “fragments.” There are just 22 fragmento tipos:
  Uma etiqueta [break, Demanda Externa, Demanda Indireta, Demanda Interna, redirecionamento, end if, etapa conclusiva, exit, finalize, increment, Decodifique, jump false, load address, load eax, loop, not, etapa preliminar, push address, empilhamento de valor, salve eax, repeat, rotina address],
  Uma variável (referência) [Demanda Indireta, redirecionamento, increment, load address, load eax, pop, push address, empilhamento de valor, rotina address, salve eax],
  Uma segunda variável (referência) [load address],
  Uma rotina (referência) [Demanda Interna, rotina address],
  Uma função (referência) [Demanda Externa],
  Um número [increment],
  Um detector [load eax], \SAL
  Um endereço,
  Um texto hexadecimal denominado código.

Etapas para que se gere um nome usando uma string:
  Atribua a string ao nome.
  Adicione 1 para a contagem de nomes deste compilador.
  Converta a contagem de nomes deste compilador para uma segunda string.
  Acrescente a segunda string para o nome.

Etapas para que se obtenha um endereço usando uma rotina:
  Se o endereço desta rotina não for 0, atribua o endereço desta rotina ao endereço; retorne.
  Atribua -1 ao endereço desta rotina.
  Encontre uma segunda rotina usando o representação de emprego desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente, apresente uma mensagem de erro contendo "#134. Rotina: " junto com o representação de emprego desta rotina seguido de "' não encontrada. (keyword empregue)" e o endereço local desta rotina; retorne.
  Se o endereço desta segunda rotina for -1, apresente a mensagem de erro contendo "#135. Referência recursiva na keyword 'empregue'." e o endereço local desta rotina; retorne. 
  Obtenha o endereço usando a segunda rotina.
  Atribua o endereço ao endereço desta rotina.

Etapas para que se obtenha uma contagem usando umas DLLs (todas as funções mais os marcadores):
  Atribua 0 à contagem.
  Comece. [a executar o código abaixo]
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Adicione a contagem destas funções desta DLL para a contagem.
    Adicione 1 para a contagem.
  Recomece. [percorra novamente o código acima]

Um corpo de variável global é um subtexto.

O catálogo de variáveis globais é um catálogo.

Uma variável global é uma variável.

As variáveis globais são umas variáveis globais.

A image base é um endereço igual a 4194304 [$00400000].

A seção de DLLs é uma zona.

Um cabeçalho da DLL é uma estrutura com
\traduzir isso aqui
  Um endereço denominado primeiro thunk, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-first-thunkoft-milad-kahsari-alhadi/
  \ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft#:~:caixa de texto=The%20original%20first%20thunk%20is,%2C%20user32%20etc)%20are%20known.
  \ Thunks são as partes definitivas dos códigos em um sistema operacional que manipula as transições entre o código de 16 e 32 bits.
  \ Assim, eles garantem a compatibilidade com versões anteriores entre as chamadas feitas pelo aplicativo.
  \ O OS está sujeito a esta facilidade para compatibilidade com versões anteriores, de modo que os aplicativos de 16 bits possam funcionar sem problemas em ambientes de 32 bits.
  Um número denominado TimeStamp, \ Set para zero até que bound; seguido de this feld is set para the TimeDateStamp of the exporting FileHeader da DLL
  Um endereço denominado corrente de encaminhamento, \ corrente de encaminhamento: The 32-bit index of the first forwarder in the list of imported functions
  Um endereço denominado endereço do nome, 
  \Esse endereço contém o RVA [Endereço Virtual Relativo] da DLL a ser carregada na memória. É um valor dword.
  \É composto por: RVA = Base da Imagem + Ordem Endian
  Um endereço denominado primeiro endereço thunk de memória.

Uma DLL é uma lista com
  Um endereço do nome,
  Um endereço do cabeçalho,
  Um nome,
  Um cabeçalho da DLL,
  Umas funções.

Um endereço do cabeçalho é um endereço.


As DLLs são umas DLLs.

Etapas para que se catalogue uma variável global:
  Se existir algum problema de compilação, retorne.
  Se a variável global for inexistente, retorne.
  Se o nome desta variável global estiver no catálogo de variáveis globais, apresente uma mensagem de erro contendo "#136. '" junto com o nome desta variável global seguido de "' é uma variável variável global duplicada." e o endereço local desta variável global; retorne.
  Catalogue a variável global usando o nome desta variável global e o catálogo de variáveis globais.

Etapas para que se catalogue um valor literal:
  Se existir algum problema de compilação, retorne.
  Se o valor literal for inexistente, retorne.
  Se o nome deste valor literal estiver no catálogo de variáveis hexadecimais, apresente uma mensagem de erro contendo "Erro interno #12" e o endereço local deste valor literal; retorne.
  Catalogue o valor literal usando o nome deste valor literal e o catálogo de variáveis hexadecimais.

Etapas para que se catalogue um cabeçalho compactado usando um catálogo (special):
  Encontre uma referência usando o cabeçalho compactado e o catálogo.
  Se a referência não for inexistente, retorne.
  Catalogue o cabeçalho compactado no catálogo.

Etapas para que se catalogue uma rotina por utilização:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o detector de função desta rotina estiver ativo, retorne.
  Se a contagem destes parâmetros desta rotina for 0, retorne.
  Copie as unidades semânticas desta rotina para umas unidades semânticas.
  Reduza as unidades semânticas por utilização.
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Encontre uma referência usando a representação interna da rotina e o catálogo de rotinas úteis.
  Se a referência não for inexistente, atribua nil ao ponteiro deste referência; retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo de rotinas úteis.

Etapas para que se catalogue uma rotina usando uma representação interna da rotina e um catálogo (special):
  Encontre uma referência usando a representação interna da rotina e o catálogo.
  Se a referência não for inexistente, atribua a rotina ao ponteiro deste referência; retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo.

Etapas para que se catalogue uma rotina usando umas unidades semânticas e um catálogo:
  Se a rotina for inexistente, retorne.
  Limpe um cabeçalho compactado.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Acrescente a unidade semântica para o cabeçalho compactado.
    Se a unidade semântica for o last unidade semântica destes unidades semânticas, pare.
    Catalogue o cabeçalho compactado usando o catálogo (special).
  Recomece. [percorra novamente o código acima]
  Catalogue a rotina usando o cabeçalho compactado como uma representação interna da rotina e o catálogo (special).

Etapas para que se catalogue umas rotinas por utilização:
  Se existir algum problema de compilação, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Catalogue a rotina por utilização.
  Recomece. [percorra novamente o código acima]

Etapas para que se catalogue um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Catalogue o tipo usando o nome deste tipo.

Etapas para que se catalogue um tipo usando um nome: 
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Encontre um existing tipo usando o nome e o catálogo de tipos.
  Se o existing tipo for inexistente, catalogue o tipo usando o nome e o catálogo de tipos; retorne.
  [Se o existing tipo já existir, então:] 
  Atribua o endereço local deste tipo para um endereço local.
  Se o endereço local for inexistente, atribua o endereço local deste existing tipo ao endereço local. \ point the error to a type in the source code, not a generated type
  Se o endereço local não for inexistente, Apresente uma mensagem de erro contendo "#137. Tipo: " junto com o nome seguido de "' duplicado." e o endereço local.

Etapas para que se inicialize o compilador:
\Rotina em branco. Serve apenas para fazer com que o código fique "simétrico"

Etapas para que se inicialize o compilador usando um endereço da pasta:
  Atribua o endereço da pasta ao endereço da pasta deste compilador.
  Atribua 0 à contagem de nomes deste compilador.
  Desative o detector de erros deste compilador.
  Limpe a mensagem de erro deste compilador.
  Limpe o endereço do arquivo atual deste compilador.
  Atribua 0 ao número da linha de erro deste compilador.
  Esvazie a rotina utilizada atualmente.
  Crie o catálogo de tipos com 13001 [buckets]. \ era 4027
  Crie o catálogo de variáveis globais com 13001 [buckets]. \ era 4027
  Crie o catálogo de variáveis hexadecimais com 13001 [buckets]. \ era 4027
  Crie o catálogo geral de rotinas com 13001 [buckets]. \ era 7919
  Crie o catálogo de rotinas úteis com 13001 [buckets]. \ era 4027

Etapas para que se inicialize um cabeçalho DOS: \ vou alterar depois
  Atribua 23117 [$5A4D] ao Signature deste cabeçalho DOS.
  Atribua 64 [$0040] ao AddressOfRelocationTableInFile deste cabeçalho DOS. \ O AddressOfRelocationTableInFile is a pointer para the variável-length de caracteres table of DLLs needed for this program.
  Atribua 256 [$00000100] ao AddressOfPEHeaderInFile deste cabeçalho DOS. \O AddressOfPEHeaderInFile is a pointer para the PE Header, a revised and extended version of the DOS Header introduced com advent of Windows. 
  \O segunda 16 campos of the DOS Header are not used.

Etapas para que se inicialize um Cabeçalho PE:
  Inicialize o Cabeçalho PE (cabeçalho padrão).
  Inicialize o Cabeçalho PE (cabeçalho opcional).
  Inicialize o Cabeçalho PE (informação da versão).
  Inicialize o Cabeçalho PE (diretórios).
  Inicialize o Cabeçalho PE (Seção de DLLs).
  Inicialize o Cabeçalho PE (seção de dados).
  Inicialize o Cabeçalho PE (seção de código).

Etapas para que se inicialize um Cabeçalho PE (seção de código):
  Atribua "code  " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Code Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta região de código ao SizeInBytes desta Code Section deste Cabeçalho PE.
  Atribua o endereço base desta região de código ao AddressInMemory desta Code Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta região de código ao SizeInFile desta Code Section deste Cabeçalho PE.
  Atribua o endereço base desta região de código ao AddressInFile desta Code Section deste Cabeçalho PE.
  Atribua -536870880 [$E0000020 ] para as Characteristics desta Code Section deste Cabeçalho PE. \ executable, readable, writable, code object
  \IMAGE_FILE_LARGE_ADDRESS_ AWARE 0x0020 - Application can handle > 2-GB addresses.

  
Etapas para que se inicialize um Cabeçalho PE (seção de dados):
  Atribua "data " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Data Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta região de dados ao SizeInBytes desta Data Section deste Cabeçalho PE.
  Atribua o endereço base desta região de dados ao AddressInMemory desta Data Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta região de dados ao SizeInFile desta Data Section deste Cabeçalho PE.
  Atribua o endereço base desta região de dados ao AddressInFile desta Data Section deste Cabeçalho PE.
  Atribua -1073741760 [$C0000040] para as Characteristics desta Data Section deste Cabeçalho PE. \ initialized, readable, writable

Etapas para que se inicialize um Cabeçalho PE (diretórios):
  Atribua 16 [$00000010] ao numberofdirectories deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao ImageDirectoryEntryImportAddress deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta seção de DLLs ao ImageDirectoryEntryImportSize deste Cabeçalho PE.

Etapas para que se inicialize um Cabeçalho PE (Seção de DLLs):
  Atribua "idata " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Idata Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta seção de DLLs ao SizeInBytes desta Idata Section deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao AddressInMemory desta Idata Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta seção de DLLs ao SizeInFile desta Idata Section deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao AddressInFile desta Idata Section deste Cabeçalho PE.
  Atribua -1073741760 [$C0000040] para as Characteristics desta Idata Section deste Cabeçalho PE. \ initialized, readable, writable

Etapas para que se inicialize um Cabeçalho PE (cabeçalho opcional):
  Atribua 267 [$010B] ao MagicNumber deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta Região de Código ao SizeOfCodeInFile deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta Região de Dados ao SizeOfInitializedDataInFile deste Cabeçalho PE.
  Atribua 0 ao SizeOfUninitializedDataInFile deste Cabeçalho PE.
  Encontre uma rotina usando "~Initialize before run e Run e Finalize after run" e o catálogo geral de rotinas. \ AddressOfEntryPointInMemory
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno #13"; retorne.
  Atribua o endereço desta rotina menos o image base ao AddressOfEntryPointInMemory deste Cabeçalho PE.
  Atribua o Endereço Base desta Região de Código ao AddressOfCodeInMemory deste Cabeçalho PE. \BaseOfCode
  Atribua o Endereço Base desta Região de Dados ao AddressOfInitializedDataInMemory deste Cabeçalho PE. \BaseOfData
  Atribua o Image Base à ImageBase deste Cabeçalho PE.
  Atribua 4096 [$00001000] ao MemoryAlignment deste Cabeçalho PE. \ 4 KB
  Atribua 4096 [$00001000] ao FileAlignment deste Cabeçalho PE. \ 4 KB
  Atribua 0 ao Reserved deste Cabeçalho PE.
  Atribua o tamanho do executável deste compilador ao SizeOfImageInMemory deste Cabeçalho PE.
  Atribua 4096 [section base] ao SizeOfAllHeadersInFile deste Cabeçalho PE. \ 4 KB
  Atribua 0 ao checksum deste Cabeçalho PE.
  Atribua 0 para as DLLCharacteristics deste Cabeçalho PE.
  Atribua 1048576 [$00100000] ao MaxStack deste Cabeçalho PE. \ SizeOfStackReserve
  Atribua 16384 [$00004000] ao MinStack deste Cabeçalho PE. \ SizeOfStackCommit
  Atribua 1048576 [$00100000] ao MaxHeap deste Cabeçalho PE. \ SizeOfHeapReserve
  Atribua 16384 [$00004000] ao MinHeap deste Cabeçalho PE. \ SizeOfHeapCommit
  Atribua 0 ao LoaderFlags deste Cabeçalho PE.

Etapas para que se inicialize um Cabeçalho PE (cabeçalho padrão):
  Atribua 17744 [$00004550] ao Signature deste Cabeçalho PE.
  Atribua 332 [$014C] ao MachineType deste Cabeçalho PE.
  Atribua 3 [$0003] ao NumberOfSections deste Cabeçalho PE.
  Atribua 0 ao TimeStamp deste Cabeçalho PE.
  Atribua 0 ao PointerToSymbolTable deste Cabeçalho PE.
  Atribua 0 ao NumberOfSymbols deste Cabeçalho PE.
  Atribua 224 [$00E0] ao SizeOfOptionalHeaderInBytes deste Cabeçalho PE.
  Atribua 33166 [$818E] às Characteristics deste Cabeçalho PE.

Etapas para que se inicialize um Cabeçalho PE (informação da versão):
  Atribua 0 ao MajorLinkerVersion deste Cabeçalho PE.
  Atribua 0 ao MinorLinkerVersion deste Cabeçalho PE.
  Atribua 4 [$0004] ao OS_MajorVersion deste Cabeçalho PE.
  Atribua 0 [$0000] ao OS_MinorVersion deste Cabeçalho PE.
  Atribua 0 ao UserMajorVersion deste Cabeçalho PE.
  Atribua 0 ao UserMinorVersion deste Cabeçalho PE.
  Atribua 4 [$0004] ao SubsystemMajorVersion deste Cabeçalho PE.
  Atribua 0 [$0000] ao SubsystemMinorVersion deste Cabeçalho PE.
  Atribua 2 [$0002] ao Subsystem deste Cabeçalho PE.

Um variável intermediária é uma variável local.

Etapas para que se link:
  Arredonde para cima tamanhos de zona.
  Inicialize um cabeçalho DOS.
  Inicialize um Cabeçalho PE.
  Preencha o trecho EXE deste compilador com o caractere null usando o tamanho do executável deste compilador.
  Disponibilize o cabeçalho DOS ao trecho EXE deste compilador.
  Disponibilize o Cabeçalho PE ao trecho EXE deste compilador.
  Disponibilize as DLLs ao trecho EXE deste compilador.
  Disponibilize as variáveis globais ao trecho EXE deste compilador.
  Disponibilize os valores literais ao trecho EXE deste compilador.
  Disponibilize as rotinas ao trecho EXE deste compilador.

Etapas para que se liste tudo:
  Limpe o trecho de listagem deste compilador.
  Liste a mensagem de erro deste compilador na trecho de listagem deste compilador.
  Liste os tipos depois de "TIPOS:" na trecho de listagem deste compilador.
  Liste as variáveis globais depois de "VARIÁVEIS GLOBAIS:" na trecho de listagem deste compilador.
  Liste os valores literais depois de "VALORES LITERAIS:" na trecho de listagem deste compilador.
  Liste as rotinas depois de "ROTINAS:" na trecho de listagem deste compilador.
  Liste o catálogo de tipos depois de "ÍNDICE DE TIPOS:" na trecho de listagem deste compilador.
  Liste o catálogo de variáveis globais depois de "ÍNDICE GLOBAL:" na trecho de listagem deste compilador.
  Liste o catálogo de variáveis hexadecimais depois de "ÍNDICE DE VALORES LITERAIS:" na trecho de listagem deste compilador.
  Liste o catálogo geral de rotinas depois de "ÍNDICE DE ROTINAS:" na trecho de listagem deste compilador.
  Liste o catálogo de rotinas úteis depois de "Catálogo de Rotinas Úteis:" na trecho de listagem deste compilador.
  Liste as DLLs depois de "DLL's:" na trecho de listagem deste compilador.
  Liste os arquivos fontes depois de "ARQUIVOS FONTE:" na trecho de listagem deste compilador.
  Liste os temporizadores depois de "TEMPORIZADORES:" na trecho de listagem deste compilador.
  Escreva o trecho de listagem deste compilador para o listagem endereço completo deste compilador.

Etapas para que se liste um mensagem de erro em um trecho:
  Se o mensagem de erro estiver em branco, retorne.
  Acrescente "COMPILAÇÃO INTERROMPIDA - LISTAGEM INCOMPLETA" para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Acrescente o mensagem de erro para o trecho.
  Insira quebra de linha em o trecho (duas vezes).

Etapas para que se liste um bucket em um trecho:
  Se os referências deste bucket estiverem vazios, retorne.
  Acrescente "| RECIPIENTE" para o trecho (com separador).
  Insira quebra de linha em o trecho.
  Liste os referências deste bucket no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste umas funções em um trecho:
  Obtenha uma função desde as funções.
  Se a função for inexistente, retorne.
  Liste a função no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uma função em um trecho:
  Se a função for inexistente, retorne.
  Acrescente "| FUNÇÃO" para o trecho (com separador).
  Acrescente o nome desta função para o trecho (com separador).
  Acrescente o endereço desta função para o trecho (cifra hexadecimal com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste um fragmento em um trecho:
  Acrescente "| FRAGMENTO" para o trecho (com separador).
  Acrescente a etiqueta deste fragmento para o trecho (geral).
  Acrescente "Variável principal: " para o trecho.
  Acrescente a variável deste fragmento para o trecho (com separador).
  Acrescente "Variável secundária: " para o trecho.
  Acrescente a segunda variável deste fragmento para o trecho (com separador).
  Acrescente "Rotina: " para o trecho.
  Acrescente a rotina deste fragmento para o trecho (com separador).
  Acrescente "Entrada: " para o trecho.
  Acrescente a função desta fragmento para o trecho (com separador).
  Acrescente "Número hexadecimal: " para o trecho.
  Acrescente o número deste fragmento para o trecho (cifra hexadecimal com separador).
  Acrescente "Endereço: " para o trecho.
  Acrescente o endereço deste fragmento para o trecho (cifra hexadecimal com separador).
  Converta o código deste fragmento para uma cifra hexadecimal.
  Acrescente "Código compilado: " para o trecho.
  Acrescente a cifra hexadecimal para o trecho (com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste uns fragmentos em um trecho:
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Liste o fragmento no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uma DLL em um trecho:
  Se a DLL for inexistente, retorne.
  Acrescente "| DLL" para o trecho (com separador).
  Acrescente o nome desta DLL para o trecho (com separador).
  Insira quebra de linha em o trecho.
  Liste as funções desta DLL no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste umas DLLs em um trecho:
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Liste a DLL no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste umas DLLs depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se as DLLs estiverem vazios, retorne.
  Liste as DLLs no trecho.

Etapas para que se liste um catálogo em um trecho:
  Acrescente "| " junto com o used contagem de buckets deste catálogo seguido de " recipientes" para o trecho (com separador).
  Acrescente a contagem deste catálogo seguido de " referências" para o trecho (com separador).
  Insira quebra de linha em o trecho (duas vezes).
  Comece. [a executar o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, retorne.
    Liste o bucket no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste um catálogo depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se o catálogo estiver vazio, retorne.
  Liste o catálogo no trecho.

Etapas para que se liste uma referência em um trecho:
  Se a referência for inexistente, retorne.
  Acrescente "| REFERÊNCIA" para o trecho (com separador).
  Acrescente a string deste referência para o trecho.
  Se o ponteiro deste referência for inexistente, acrescente " (ponteiro inexistente) " para o trecho.
  Acrescente "| " para o trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste umas referências em um trecho:
  Obtenha uma referência desde as referências.
  Se a referência for inexistente, retorne.
  Liste a referência no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uma rotina em um trecho:
  Se a rotina for inexistente, retorne.
  Acrescente "| ROTINA: " para o trecho.
  Acrescente a representação interna da rotina desta rotina para o trecho (com separador). \ por exemplo: atribua [matiz] e [saturação] e [luminosidade] para [cor]
  Acrescente o texto CRLF para o trecho.
  Acrescente "| A rotina foi compilada? " para o trecho .
  Acrescente o detector de compilação desta rotina para o trecho (com separador). \ A rotina foi compilada? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| A rotina é um callback? " para o trecho.
  Acrescente o detector de compatibilidade desta rotina para o trecho (com separador). \ A rotina é um callback? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| A rotina é uma rotina decisora? " para o trecho.
  Acrescente o detector de deliberação desta rotina para o trecho (com separador). \ A rotina é uma rotina decisora? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| A rotina é uma função? " para o trecho.
  Acrescente o detector de função desta rotina para o trecho (com separador). \ A rotina é uma função ? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Employs utilizados: |     " para o trecho.
  Acrescente o representação de emprego desta rotina para o trecho (com separador).
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Tamanho dos parâmetros: " para o trecho.
  Acrescente o tamanho do parâmetro desta rotina para o trecho (com separador). \ Tamanho dos parâmetros. Exemplo: 16 ( 4 parâmetros)
  Acrescente " Tamanho das variáveis: " para o trecho.
  Acrescente o tamanho local desta rotina para o trecho (com separador). \Tamanho da variável local. Exemplo: 28
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Endereço da Rotina: " para o trecho.
  Acrescente o endereço desta rotina para o trecho (cifra hexadecimal com separador). \ Endereço da rotina, Exemplo: 0041D000
  Insira quebra de linha em o trecho.
  Liste os parâmetros desta rotina no trecho.
  Liste as variáveis locais desta rotina no trecho.
  Liste os fragmentos desta rotina no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste umas rotinas em um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Liste a rotina no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste umas rotinas depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se as rotinas estiverem vazias, retorne.
  Liste as rotinas no trecho.

Etapas para que se liste um arquivo fonte em um trecho:
  Se o arquivo fonte for inexistente, retorne.
  Acrescente "| ARQUIVO FONTE" para o trecho (com separador).
  Acrescente o endereço completo deste arquivo fonte para o trecho (com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste uns arquivos fontes em um trecho:
  Obtenha um arquivo fonte desde os arquivos fontes.
  Se o arquivo fonte for inexistente, retorne.
  Liste o arquivo fonte no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns arquivos fontes depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se os arquivos fontes estiverem vazios, retorne.
  Liste os arquivos fontes no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste um temporizador usando uma string em um trecho:
  Acrescente "| TEMPORIZADOR" para o trecho (com separador).
  Acrescente a string para o trecho (com separador).
  Acrescente a string deste temporizador para o trecho.
  Acrescente " milissegundos" para o trecho (com separador).
  Insira quebra de linha em o trecho.

Etapas para que se liste os temporizadores depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Liste o temporizador de operacionalização usando "Tempo de carregamento: " no trecho.
  Liste o temporizador de análise/verificação usando "Tempo de verificação: " no trecho.
  Liste o temporizador de resolução de tipos usando "Resolução de tipos: " no trecho.
  Liste o temporizador de resolução de variáveis globais usando "Resolução de variáveis globais: " no trecho.
  Liste o temporizador de compilação de cabeçalhos de rotina usando "Compilação de cabeçalhos de rotinas: " no trecho.
  Liste o temporizador de etapas de cálculo usando "Cálculos matemáticos: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de mémoria  usando "Inclusão de rotinas pré-definidas: " no trecho.
  Liste o temporizador de ferramentas de catalogação usando "Catalogação de ferramentas: " no trecho.
  Liste o temporizador de compilação do conteúdo das rotinas usando "Compilação de rotinas: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de inicialização usando "Inserção rotina de inicialização:" no trecho.
  Liste o temporizador de deslocamentos usando "Alinhamento de bytes na memória: " no trecho.
  Liste o temporizador de endereçamento usando "Endereçamento: " no trecho.
  Liste o temporizador de transmutação usando "Conversão em binário" no trecho.
  Liste o temporizador de vinculação usando "Vinculação: " no trecho.
  Liste o temporizador de escrita usando "Escrita e gravação no SO: " no trecho.
  Liste o temporizador deste compilador usando "Tempo total: " no trecho.
  Insira quebra de linha em o trecho.

Etapas para que se liste um tipo em um trecho:
  Se o tipo for inexistente, retorne.
  Acrescente "| TIPO" para o trecho (com separador).
  Acrescente o nome deste tipo para o trecho (com separador).
  Acrescente " Plural: " para o trecho.
  Acrescente o nome plural deste tipo para o trecho (com separador).
  Acrescente " Comprimento: " para o trecho.
  Acrescente a quantidade de caracteres deste tipo para o trecho (cifra hexadecimal com separador).
  Acrescente " Tipo: " para o trecho.
  Acrescente o nome do tipo primitivo deste tipo para o trecho (com separador).
  Acrescente " Tipo base: " para o trecho.
  Acrescente o tipo base deste tipo para o trecho (com separador).
  Acrescente o nome do conteúdo deste tipo para o trecho (com separador).
  Acrescente o tipo do conteúdo deste tipo para o trecho (com separador).
  Acrescente " Razão de escala: " para o trecho.
  Acrescente a razão de escala deste tipo para o trecho (com separador).
  Insira quebra de linha no trecho.
  Liste os campos deste tipo no trecho.
  Insira quebra de linha no trecho.

Etapas para que se liste uns tipos em um trecho:
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Liste o tipo no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns tipos depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se os tipos estiverem vazios, retorne.
  Liste os tipos no trecho.

Etapas para que se liste uma variável em um trecho:
  Se a variável for inexistente, retorne.
  Acrescente "| VARIÁVEL" para o trecho (com separador).
  Acrescente "Categoria: " para o trecho.
  Acrescente a categoria desta variável para o trecho (com separador).
  Acrescente "Compilada? " para o trecho.
  Acrescente o detector de compilação desta variável para o trecho (com separador).
  Acrescente "Nome completo: " para o trecho.
  Acrescente o nome desta variável para o trecho (com separador).
  Acrescente "Nome resumido: " para o trecho.
  Acrescente o apelido desta variável para o trecho (com separador).
  Acrescente "Nome do tipo: " para o trecho.
  Acrescente o nome do tipo desta variável para o trecho (com separador).
  Acrescente "Tipo: " para o trecho.
  Acrescente o tipo desta variável para o trecho (com separador).
  Acrescente "Endereço (deslocamento): " para o trecho.
  Acrescente o endereço desta variável [or deslocamento] para o trecho (cifra hexadecimal com separador).
  Acrescente "Passagem por valor? " para o trecho.
  Acrescente o detector de passagem por-valor desta variável para o trecho (com separador).
  Acrescente "Contagem: " para o trecho.
  Acrescente a contagem desta variável para o trecho (com separador).
  Acrescente "Referência somente? " para o trecho.
  Acrescente o detector de referência desta variável para o trecho (com separador).
  Acrescente "Redefinição: " para o trecho.
  Acrescente o nome de redefinição de conteúdo desta variável para o trecho (com separador).
  Acrescente "Conteúdo: " para o trecho.
  Acrescente o valor literal desta variável para o trecho (com separador).
  Converta o data desta variável para uma cifra hexadecimal.
  Acrescente "Conteúdo (valores hexadecimais): " para o trecho.
  Acrescente a cifra hexadecimal para o trecho (com separador).
  Insira quebra de linha no trecho.

Etapas para que se liste umas variáveis em um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Liste a variável no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste umas variáveis depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha em o trecho (duas vezes).
  Se as variáveis estiverem vazias, retorne.
  Liste as variáveis no trecho.
  Insira quebra de linha no trecho.

O catálogo de variáveis hexadecimais é um catálogo.

Um valor literal é uma variável.

Os valores literais são uns valores literais.

Uma variável local é uma variável.

Um endereço local é um endereço de byte .

Uma representação interna da rotina é uma string.  \ moniker
  \ https://docs.microsoft.com/pt-br/windows/win32/com/monikers
 \ A moniker is the internal representation of a routine header with
\ • no articles preceding parameter tipos,
\ • parameter tipos in square brackets, and
\ • expanded prepositions. 
\ Each piece of a moniker is a unidade semântica. For example: 
\ Routine header: To add a number to a count:
\ Moniker: add [number] in/into/to [count]
\ Monikettes: (1) add (2) [number] (3) in/into/to (4) [count] 
\ We use this internal representation because it... 
\ • makes it easy reduce tipos (like [count] to [number]) when looking for an appropriate routine to call;
\ • makes it easy to expand prepositions (like "to" into "in/into/to"); and
\ • shows how the compiler interpreted various phrases in error messages.
Uma unidade semântica é uma lista com
  Uma string,
  Um tipo (referência),
  Um variável (referência),
  \ para bubbling
  Um tipo atual (referência),
  Um subtexto atual.

Um cabeçalho compactado é uma representação interna da rotina.

Etapas para que se mova um percorredor (ignorando os comentários):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o retorno de carro, recomece.

Etapas para que se mova um percorredor (símbolos conectivos):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o percorredor estiver sobre algum possessivo inglês, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for um byte ignorável, recomece.

Etapas para que se mova um percorredor (sinais de pontuação):
  Avance o percorredor.

Etapas para que se mova um percorredor (ignorando os caracteres irrelevantes):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, recomece.

Etapas para que se mova um percorredor (possessivo inglês):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o segmento final deste percorredor começa com "s", avance o percorredor.

Etapas para que se mova um percorredor (qualificadores):
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo, adicione 1 para uma contagem.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses direito, subtraia 1 desde a contagem.
  Avance o percorredor.
  Se a contagem for 0, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (ignorando as observações):
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo, adicione 1 para uma contagem.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete direito, subtraia 1 desde a contagem.
  Avance o percorredor.
  Se a contagem for 0, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (conteúdo de texto):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, retorne.
  Se o percorredor estiver sobre algum nested double-quote, avance o percorredor; recomece.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas, avance o percorredor; retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (símbolos):
  Avance o percorredor.

Etapas para que se mova um percorredor (englobando tudo):
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, mova o percorredor (ignorando os caracteres irrelevantes); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for a barra invertida, mova o percorredor (ignorando os comentários); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo, mova o percorredor (ignorando as observações); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas, mova o percorredor (conteúdo de texto); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo, mova o percorredor (qualificadores); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum sinal de pontuação, mova o percorredor (sinais de pontuação); retorne.
  Se o percorredor estiver sobre algum possessivo inglês, mova o percorredor (possessivo inglês); retorne.
  Mova o percorredor (símbolos conectivos).

Etapas para que se mova um percorredor (usando diretrizes de compilação): \ talvez aqui conserte o subtraia
  Se o detector de erros deste compilador estiver ativo, limpe o segmento inicial deste percorredor; retorne.
  Mova o percorredor retornando uma string de erro (englobando tudo).
  Se a string de erro não estiver em branco, apresente uma mensagem de erro contendo a string de erro e o caractere inicial deste segmento inicial deste percorredor; retorne.
  \Se o segmento inicial deste percorredor for "del", recue o percorredor; retorne. \ Spanish contraction "del"; fudged para "de l", short por "de el"
  \Se o segmento inicial deste percorredor for alguma contração de preposição com artigo definido, determine se essa contração precisa ser desfeita usando o percorredor. \ Spanish contraction "al"; fudged para "a l", short por "a el"
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante, recomece.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida, recomece.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, recomece.

Etapas para que se mova um percorredor retornando uma string de erro (diretrizes de validação de qualificadores):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "#138. Qualificadores devem terminar com parêntese ')'." ao string de erro; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o parênteses direito, atribua "#139. Qualificadores precisam terminar com um parêntese ')'." ao string de erro; retorne.

Etapas para que se mova um percorredor retornando uma string de erro (diretrizes de validação de observações):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "#140. Observações devem terminar com um colchete ']'." ao string de erro; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o colchete direito, atribua "#141. Observações precisam terminar com um colchete ']'." ao string de erro; retorne.

Etapas para que se mova um percorredor retornando uma string de erro (diretrizes de validação de conteúdos de texto):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "#142. Textos precisam terminar com aspas: ""." ao string de erro; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for as aspas duplas, atribua "#143. Textos devem terminar com aspas: ""." ao string de erro; retorne.

Etapas para que se mova um percorredor retornando uma string de erro (englobando tudo):
  Limpe a string de erro.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, mova o percorredor retornando a string de erro (diretrizes de validação de observações); retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas, mova o percorredor retornando a string de erro (diretrizes de validação de conteúdos de texto); retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo, mova o percorredor retornando a string de erro (diretrizes de validação de qualificadores); retorne.

Uma string de erro é uma string.

Um parte da cifra binária é um subtexto.

Um apelido é um nome.  

Etapas para que se alinhe as variáveis locais em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a detector de compilação desta rotina não estiver ativo, retorne.
  Limpe o tamanho local desta rotina.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Obtenha uma variável local desde as variáveis locais desta rotina.
    Se a variável local for inexistente, retorne.
    Se o precedente variável local desta variável local não for inexistente, atribua o deslocamento deste precedente variável local desta variável local ao deslocamento desta variável local.
    Atribua a quantidade de caracteres deste tipo desta variável local para uma quantidade de caracteres.
    Se a categoria desta variável local for "scratch", atribua a magnitude dum ponteiro à quantidade de caracteres.
    Arredonde a quantidade de caracteres para cima usando o múltiplo imediato de 4.
    Subtraia a quantidade de caracteres desde o deslocamento desta variável local.
    Adicione a quantidade de caracteres para o tamanho local desta rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se alinhe as variáveis locais em umas rotinas:
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Alinhe as variáveis locais na rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se alinhe o parâmetros em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a detector de compilação desta rotina não estiver ativo, retorne.
  Limpe o tamanho do parâmetro desta rotina.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Obtenha um parâmetro desde os parâmetros desta rotina.
    Se o parâmetro for inexistente, retorne.
    Se o detector de compatibilidade desta rotina estiver ativo, ative o detector de passagem por-valor deste parâmetro.
    Se o precedente parâmetro deste parâmetro for inexistente, atribua 8 ao deslocamento deste parâmetro. \ skip o return address e saved ebp
    Se o precedente parâmetro deste parâmetro não for inexistente, atribua o deslocamento deste precedente parâmetro deste parâmetro mais 4 ao deslocamento deste parâmetro. \ all parâmetros são 4 endereço de byte s ou 4 byte values por callbacks
    Adicione 4 para a tamanho do parâmetro desta rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se alinhe o parâmetros em umas rotinas:
  Se existir algum problema de compilação, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Alinhe o parâmetros na rotina.
  Recomece. [percorra novamente o código acima]

  

Um parâmetro é uma variável.

Um Cabeçalho PE é uma estrutura com   \ O formato Portable Executable (PE) é baseado na especificação COFF (Common Object File Format).
\Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format
\ O cabeçalho MS-DOS ocupa os primeiros 64 bytes do arquivo. A estrutura básica está representada abaixo:
  Um número denominado Signature, 
  Uma word denominada MachineType, 
  Uma word denominada NumberOfSections, 
  Um número denominado TimeStamp, 
  Um número denominado PointerToSymbolTable, 
  Um número denominado NumberOfSymbols, 
  Uma word denominada SizeOfOptionalHeaderInBytes, 
  Uma word denominada Characteristics, 
  \ PARTE OPCIONAL - _IMAGE_OPTIONAL_HEADER64
  Uma word denominada MagicNumber, 
  Um byte denominado MajorLinkerVersion, 
  Um byte denominado MinorLinkerVersion, 
  Um número denominado SizeOfCodeInFile, \ SizeOfCode
  Um número denominado SizeOfInitializedDataInFile, 
  Um número denominado SizeOfUninitializedDataInFile, 
  Um número denominado AddressOfEntryPointInMemory, \ AddressOfEntryPoint
  Um número denominado AddressOfCodeInMemory,  [BaseOfCode]  
  Um número denominado AddressOfInitializedDataInMemory, [BaseOfData]  
  Um número denominado ImageBase, 
  Um número denominado MemoryAlignment, [SectionAlignment]
  Um número denominado FileAlignment, 
  Uma word denominada OS_MajorVersion, [MajorOperatingSystemVersion]
  Uma word denominada OS_MinorVersion, [MinorOperatingSystemVersion]
  Uma word denominada UserMajorVersion,  [MajorImageVersion]
  Uma word denominada UserMinorVersion, [MinorImageVersion]
  Uma word denominada SubsystemMajorVersion, [MajorSubsystemVersion]
  Uma word denominada SubsystemMinorVersion, [MinorSubsystemVersion]
  Um número denominado Reserved,  [Win32VersionValue]
  Um número denominado SizeOfImageInMemory, [SizeOfImage]
  Um número denominado SizeOfAllHeadersInFile, [SizeOfHeaders]  
  Um número denominado CheckSum, 
  Uma word denominada Subsystem, 
  Uma word denominada DLLCharacteristics, 
  Um número denominado MaxStack, [SizeOfStackReserve]  
  Um número denominado MinStack, [SizeOfStackCommit]
  Um número denominado MaxHeap, [SizeOfHeapReserve]
  Um número denominado MinHeap, [SizeOfHeapCommit]  
  Um número denominado LoaderFlags,  \ _IMAGE_OPTIONAL_HEADER64
  Um número denominado NumberOfDirectories, [NumberOfRvaAndSizes]
  8 bytes denominados Directory0,
  Um número denominado ImageDirectoryEntryImportAddress,
  Um número denominado ImageDirectoryEntryImportSize,
  112 bytes denominados Directories2-15,
  Um Cabeçalho de Seção PE denominado Idata Section,
  Um Cabeçalho de Seção PE denominado Data Section,
  Um Cabeçalho de Seção PE denominado Code Section. 

Um Cabeçalho de Seção PE é uma estrutura com
  8 bytes denominados Nome, \ Each section header has a name fielf up to eight characters long, for which the first character must be a period.
  Um número denominado SizeInBytes,
  Um número denominado AddressInMemory,
  Um número denominado SizeInFile,
  Um número denominado AddressInFile,
  12 bytes denominados Reserved,
  Um número denominado Characteristics. \ Defines the section Characteristics. 
  \These values are encontrado both em WINNT.H and in the Portable Executable Format specification.

Uma frase é uma string.

\Etapas para que se determine se uma string looks like English:
\Carregue o dicionário léxico.
\Se o dicionário léxico for inexistente, mostre erro "Não foi possível encontrar o dicionário léxico."; diga não.
\Se a string estiver em branco, diga não.
\Lance um subtexto sobre a string.
\Atribua o caractere final deste subtexto ao caractere inicial deste subtexto.
\Comece. [a executar o código abaixo]
  \Se o caractere inicial deste subtexto é o caractere inicial desta string, pare.
  \Se o target deste caractere inicial deste subtexto for o caractere de espaço, adicione 1 para o caractere inicial deste subtexto; pare.
  \Subtraia 1 desde o caractere inicial deste subtexto.
\Recomece. [percorra novamente o código acima]
\Se o subtexto estiver no catálogo deste dicionário léxico, diga sim.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se pluralize uma string (strings em português):
  Lance um percorredor sobre a string.
  Comece. [a executar o código abaixo]
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Se uma string plural não estiver em branco, acrescente " " para a string plural.
    Acrescente o segmento inicial deste percorredor para a string plural.
    Se o segmento inicial deste percorredor for "de ", ative um detector; recomece. \ aqui identifica um termo composto. Falta implementar.
    Se o detector não estiver ativo, pluralize a string plural (português - regras comuns) .
    \Se o detector estiver ativo, pluralize o string plural (substantivos compostos).
  Recomece. [percorra novamente o código acima]
  Atribua a string plural à string.

Etapas para que se pluralize uma string (português - regras comuns) :
  \# https://www.normaculta.com.br/singular-e-plural/
  \# palavras que são exceções às regras
  \Se a string for "bit", atribua "bits" à string; retorne.
  Se a string for "caráter", atribua "carateres" à string; retorne.
  Se a string for "de", atribua "de" à string; retorne.
  Se a string for "júnior", atribua "juniores" à string; retorne.
  Se a string for "sênior", atribua "seniores" à string; retorne.
  \# advérbios principais
  Se a string for "muito", retorne.
  Se a string for "pouco", retorne.
  Se a string for "mais", retorne.
  Se a string for "menos", retorne.
  Se a string for "bastante", retorne.
  Se a string for "quase", retorne.
  Se a string for "demais", retorne.
  Se a string for "bem", retorne.
  Se a string for "deveras", retorne.
  Se a string for "mal", retorne.
  Se a string for "melhor", retorne.
  Se a string for "pior", retorne.
  \# palavras terminadas com "ão"
  Se a string termina com "ão", pluralize a string (terminada com "ão"); retorne.
  \# palavras terminadas com "d"
  Se a string termina com "d", pluralize a string (terminada com outras letras); retorne.
  \# palavras terminadas com "l"
  Se a string termina com "l", pluralize a string (terminada com "l"); retorne.
  \# palavra terminadas com "m"
  Se a string termina com "m", remova o último caractere desde a string; acrescente "ns" para a string; retorne.
  \# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
  Se a string termina com "n", acrescente "es" para a string; retorne.
  \# palavras terminadas com "r"
  Se a string termina com "r", pluralize a string (terminada com "r"); retorne.
  \# palavras terminadas com "s"
  Se a string termina com "s", pluralize a string (terminada com "s"); retorne.
  \# palavras terminadas com "t"
  Se a string termina com "t", pluralize a string (terminada com outras letras); retorne.
  \# palavra terminadas com "x"
  Se a string termina com "x", pluralize a string (terminada com "x"); retorne.
  \# palavras terminadas com "z"
  Se a string termina com "z", pluralize a string (terminada com "z"); retorne.
  Se a string termina com "#", acrescente "s" para a string; retorne.
  Se a string for "de", atribua "de" à string; retorne.
  Se a string não termina com alguma vogal ou com alguma consoante, acrescente "s" para a string; retorne.
  \# regra padrão
  [Se as condições acima não puderem ser satisfeitas, então:] 
  Acrescente "s" para a string. \ Só acrescenta o "s" caso nenhuma das condições acima tenha siddo correspondida. 
  \Volte.

Etapas para que se pluralize uma string (terminada com "ão"):
  \A formação do plural dos substantivos terminados -ão pode ser feita de três formas distintas: -ões, -ãos, -ães.
  \Alguns substantivos terminados em -ão admitem duas (ou até três) formas no plural:
  \refrão - refrãos ou refrães;
  \corrimão - corrimões ou corrimãos;
  \guardião - guardiões ou guardiães;
  \vilão - vilões, vilãos ou vilães.
    \TODOS os substantivos paroxítonos terminados em -ão formam o plural com -ãos. 
  \ALGUNS substantivos oxítonos também têm o seu plural formado segundo essa regra:
  \órfão - órfãos;
  \sótão - sótãos;
  \órgão - órgãos;
  \cidadão - cidadãos;
  \irmão - irmãos;
  \cristão - cristãos.
  Se a string for "cidadão", acrescente "s" para a string; retorne.
  Se a string for "irmão", acrescente "s" para a string; retorne.
  Se a string for "cristão", acrescente "s" para a string; retorne.
  Se a string for "refrão", acrescente "s" para a string; retorne.
  Se a string for "mão", acrescente "s" para a string; retorne.
  Se a string for "são", acrescente "s" para a string; retorne.
  \-ão no singular para -ães no plural:
  \Alguns substantivos terminados em -ão formam o plural com -ães.
  Se a string for "pão", remova o último caractere desde a string; acrescente "es" para a string; retorne.
  Se a string for "capitão", remova o último caractere desde a string; acrescente "es" para a string; retorne.
  Se a string for "alemão", remova o último caractere desde a string; acrescente "es" para a string; retorne.
  Se a string for "charlatão", remova o último caractere desde a string; acrescente "es" para a string; retorne.
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.   \ remova o "ão". Acho que não precisa
  \caso encontre acentos em sílabas prévias, faça o seguinte
  Se o subtexto possui alguma vogal acentuada, acrescente "s" para a string; retorne. \-> exemplo: órgão
  \# regra padrão
  \A maioria dos substantivos terminados em -ão forma o plural com -ões:
  \opinião - opiniões;
  \coração - corações;
  \eleição - eleições.
  Remova os dois últimos caracteres desde a string. Acrescente "ões" para a string.\ Retorne.

Etapas para que se pluralize uma string (terminada com outras letras):
  Se a string for "de", atribua "de" à string; retorne.  
  Acrescente "s" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "l"):
  \# palavras terminadas com "al"
  Se a string termina com "al", pluralize a string (terminada com "al"); retorne. \ MAL -> MALES
  \# palavras terminadas com "el"
  Se a string termina com "el", pluralize a string (terminada com "el"); retorne. \PASTEL - PASTÉIS
  \# palavras terminadas com "il"
  Se a string termina com "il", pluralize a string (terminada com "il"); retorne. \-> FUZIL -> FUZIS
  \# palavras terminadas com "ol"
  Se a string termina com "ol", pluralize a string (terminada com "ol"); retorne. \- LENÇOL -> LENÇÓIS
  \# palavras terminadas com "ul"
  Se a string termina com "ul", pluralize a string (terminada com "ul"); retorne. \ AZUL -> AZUIS \ Cônsul - cônsules
  [Caso a string seja uma sigla, tipo URL]
  Acrescente "s" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "al"):
  Se a string for "mal", atribua "males" para a string; retorne.
  Remova o último caractere desde a string. \remova a letra L
  Acrescente "is" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "el"):
  \Se a string for "pixel", atribua "pixels" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto. \ remova o el
  Se o subtexto possui alguma vogal acentuada, remova o último caractere desde a string; acrescente "is" para a string; retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "éis" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "il"):
  \Se a string for "canil", atribua "canis" para a string; retorne.
  \Se a string for "covil", atribua "covis" para a string; retorne.
  \Se a string for "funil", atribua "funis" para a string; retorne.
  \Se a string for "barril", atribua "barris" para a string; retorne.
  \Se a string for "fuzil", atribua "fuzis" para a string; retorne.
  \Se a string for "redil", atribua "redis" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, remova os dois últimos caracteres desde a string; acrescente "eis" para a string; retorne.
  Remova o último caractere desde a string. \ remova a letra L
  Acrescente "s" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "ol"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, remova o último caractere desde a string; acrescente "is" para a string; retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "óis" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "ul"):
  Se a string for "cônsul", atribua "cônsules" à string; retorne.
  Remova o último caractere desde a string. \ remova o L
  Acrescente "is" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "r"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, acrescente "es" para a string; retorne.
  \# hiatos
  Se a string termina com "air", remova os dois últimos caracteres desde a string; acrescente "íres" para a string; retorne.
  Se a string termina com "aur", remova os dois últimos caracteres desde a string; acrescente "úres" para a string; retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "s"):
\Quando os substantivos terminados em -s são paroxítonos, a formação do plural fica invariável:.
  \# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
  Se a string for "de", atribua "de" à string; retorne.
  Se a string termina com "as", acrescente "es" para a string; retorne. \atlas
  \Se a string termina com "as", acrescente "-plural" para a string; retorne. \atlas
  Se a string termina com "es",  acrescente "es" para a string; retorne. \atlas
  \Se a string termina com "es", acrescente "-plural" para a string; retorne.\pires
  Se a string termina com "os",  acrescente "es" para a string; retorne. \atlas
  \Se a string termina com "os", acrescente "-plural" para a string; retorne. \óculos
  \# hiatos acentuados
  Se a string termina com "aís", acrescente "es" para a string; retorne.
  Se a string termina com "aús", acrescente "es" para a string; retorne.
  \# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
  Se a string termina com "ás", remova os dois últimos caracteres desde a string; acrescente "ases" para a string; retorne.
  Se a string termina com "âs", remova os dois últimos caracteres desde a string; acrescente "ases" para a string; retorne.
  Se a string termina com "és", remova os dois últimos caracteres desde a string; acrescente "eses" para a string; retorne.
  Se a string termina com "ês", remova os dois últimos caracteres desde a string; acrescente "eses" para a string; retorne.
  Se a string termina com "ís", remova os dois últimos caracteres desde a string; acrescente "ises" para a string; retorne.
  Se a string termina com "ós", remova os dois últimos caracteres desde a string; acrescente "oses" para a string; retorne.
  Se a string termina com "ôs", remova os dois últimos caracteres desde a string; acrescente "oses" para a string; retorne.
  Se a string termina com "ús", remova os dois últimos caracteres desde a string; acrescente "uses" para a string; retorne.
  \# palavras terminadas com "is", "us"
  Se a string termina com "is", pluralize a string (terminada com "is" ou com "us"); retorne.
  Se a string termina com "us", pluralize a string (terminada com "is" ou com "us"); retorne. \ônibus / vírus
  \Se a string termina com "ts", exit.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Etapas para que se pluralize uma string (terminada com "is" ou com "us"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, retorne.
  \# hiatos
  Se a string termina com "ais", remova os dois últimos caracteres desde a string; acrescente "íses" para a string; retorne. \cais não varia....
  Se a string termina com "aus", remova os dois últimos caracteres desde a string; acrescente "úses" para a string; retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Etapas para que se pluralize uma string  (terminada com "x"):
  \Se a string for "px", acrescente "pxs" para a string; retorne.
  Se a string for "fax", acrescente "es" para a string; retorne.
  Acrescente "s" para a string. \ tratamento de exceções
   \ Retorne.
  

Etapas para que se pluralize uma string (terminada com "z"):
  \# hiatos acentuados
  Se a string termina com "aíz", acrescente "es" para a string; retorne.
  Se a string termina com "aúz", acrescente "es" para a string; retorne.
  \# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
  Se a string termina com "áz", remova os dois últimos caracteres desde a string; acrescente "azes" para a string; retorne.
  Se a string termina com "âz", remova os dois últimos caracteres desde a string; acrescente "azes" para a string; retorne.
  Se a string termina com "éz", remova os dois últimos caracteres desde a string; acrescente "ezes" para a string; retorne.
  Se a string termina com "êz", remova os dois últimos caracteres desde a string; acrescente "ezes" para a string; retorne.
  Se a string termina com "íz", remova os dois últimos caracteres desde a string; acrescente "izes" para a string; retorne.
  Se a string termina com "óz", remova os dois últimos caracteres desde a string; acrescente "ozes" para a string; retorne.
  Se a string termina com "ôz", remova os dois últimos caracteres desde a string; acrescente "ozes" para a string; retorne.
  Se a string termina com "úz", remova os dois últimos caracteres desde a string; acrescente "uzes" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, acrescente "es" para a string; retorne.
  \# hiatos
  Se a string termina com "aiz", remova os dois últimos caracteres desde a string; acrescente "ízes" para a string; retorne.
  Se a string termina com "auz", remova os dois últimos caracteres desde a string; acrescente "úzes" para a string; retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Etapas para que se pluralize uma string (english rules); \ plural inglês
Etapas para que se pluralize uma string:
  Se a string for "de", retorne.
    \# https://www.normaculta.com.br/singular-e-plural/
  \# palavras que são exceções às regras
  \Se a string for "bit", atribua "bits" à string; retorne.
  Se a string for "caráter", atribua "carateres" à string; retorne.
  Se a string for "de", atribua "de" à string; retorne.
  Se a string for "júnior", atribua "juniores" à string; retorne.
  Se a string for "sênior", atribua "seniores" à string; retorne.
  \# advérbios principais
  Se a string for "muito", retorne.
  Se a string for "pouco", retorne.
  Se a string for "mais", retorne.
  Se a string for "menos", retorne.
  Se a string for "bastante", retorne.
  Se a string for "quase", retorne.
  Se a string for "demais", retorne.
  Se a string for "bem", retorne.
  Se a string for "deveras", retorne.
  Se a string for "mal", retorne.
  Se a string for "melhor", retorne.
  Se a string for "pior", retorne.
  \# palavras terminadas com "ão"
  Se a string termina com "ão", pluralize a string (terminada com "ão"); retorne.
  \# palavras terminadas com "d"
  Se a string termina com "d", pluralize a string (terminada com outras letras); retorne.
  \# palavras terminadas com "l"
  Se a string termina com "l", pluralize a string (terminada com "l"); retorne.
  \# palavra terminadas com "m"
  Se a string termina com "m", remova o último caractere desde a string; acrescente "ns" para a string; retorne.
  \# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
  Se a string termina com "n", acrescente "es" para a string; retorne.
  \# palavras terminadas com "r"
  Se a string termina com "r", pluralize a string (terminada com "r"); retorne.
  \# palavras terminadas com "s"
  Se a string termina com "s", pluralize a string (terminada com "s"); retorne.
  \# palavras terminadas com "t"
  Se a string termina com "t", pluralize a string (terminada com outras letras); retorne.
  \# palavra terminadas com "x"
  Se a string termina com "x", pluralize a string (terminada com "x"); retorne.
  \# palavras terminadas com "z"
  Se a string termina com "z", pluralize a string (terminada com "z"); retorne.
  Se a string termina com "#", acrescente "s" para a string; retorne.
  Se a string for "de", atribua "de" à string; retorne.
  Se a string não termina com alguma vogal ou com alguma consoante, acrescente "s" para a string; retorne.
  \Acrescente "s" para a string.

Uma protótipo de string é uma estrutura com 
  Um caractere inicial e 
  Um caractere final .

Etapas para que se atribua o endereço EXE completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remova alguma barra invertida final desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".exe" ao endereço completo.

Etapas para que se atribua o tamanho do executável deste compilador para um tamanho:
  Atribua 4096 [section base] ao tamanho.
  Adicione o tamanho desta seção de DLLs para o tamanho.
  Adicione o tamanho desta região de dados para o tamanho.
  Adicione o tamanho desta região de código para o tamanho.

Etapas para que se atribua o listagem endereço completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remova alguma barra invertida final desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".lst" ao endereço completo.

Etapas para que se atribua um termo para um segundo termo:
  Atribua a variável deste termo à variável deste segundo termo.
  Atribua a frase deste termo ao frase deste segundo termo.

Etapas para que se carregue um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  \Carregue o endereço completo deste arquivo fonte ao trecho deste arquivo fonte.
  \Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " junto com o endereço completo deste arquivo fonte seguido de "."; retorne.
  Carregue o endereço completo deste arquivo fonte para uma string.
  Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo "#144. Não foi possível carregar o arquivo: " junto com o endereço completo deste arquivo fonte seguido de "."; retorne.
  Parse a string para o trecho deste arquivo fonte (para expandir contrações).

Etapas para que se carregue uns arquivos fontes:
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Obtenha um item desde o endereço da pasta deste compilador.
    Se o item não for encontrado, pare.
    Se a categoria deste item não for "arquivo", recomece.
    Se a extensão deste item não estiver em branco, recomece.
    Se o item parece ser encadernável, recomece.
    Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    Carregue o arquivo fonte.
  Recomece. [percorra novamente o código acima]

O percorredor de contrações é um percorredor.

Etapas para que se parse uma string para uma segunda string (para expandir contrações):
  Limpe a segunda string.
  Limpe uma terceira string.
  Lance o percorredor de contrações sobre a string.
  Comece. [a executar o código abaixo]
    Se o segmento final deste percorredor de contrações estiver em branco, retorne.
    Posicione o segmento inicial deste percorredor de contrações sobre o segmento final deste percorredor de contrações. 
    Mova o percorredor de contrações (englobando tudo).
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor de contrações 
    NÃO for um byte ignorável, acrescente o segmento inicial deste percorredor de contrações para a segunda string; 
   Recomece.
    Acrescente o segmento inicial deste percorredor de contrações para a segunda string usando a terceira string (para expandir contrações).
    Atribua o segmento inicial deste percorredor de contrações à terceira string.
  Recomece. [percorra novamente o código acima]

Etapas para que se reduza umas unidades semânticas por utilização:
  Obtenha uma unidade semântica desde as unidades semânticas.
  Se a unidade semântica for inexistente, retorne.
  Se o tipo desta unidade semântica for inexistente, recomece.
  Reduza o tipo desta unidade semântica para um tipo por utilização.
  Se o tipo não for inexistente, atribua o tipo ao tipo desta unidade semântica.
  Recomece. [percorra novamente o código acima]

Etapas para que se reduza um tipo para um segundo tipo por utilização:
  Atribua o tipo ao segundo tipo.
  Comece. [a executar o código abaixo]
    Se o segundo tipo for inexistente, retorne.
    Se o nome deste segundo tipo for "texto hexadecimal", retorne.
    Se o nome deste segundo tipo for "string", retorne.
    Se o nome deste segundo tipo for "texto", retorne.
    Se o nome deste segundo tipo for "número", retorne.
    Se o nome deste segundo tipo for "ponteiro", retorne.
    Se o nome deste segundo tipo for "lista", esvazie o segundo tipo; retorne.
    \PAL
    \Se o nome deste segundo tipo for "elemento", esvazie o segundo tipo; retorne.
    Se o tipo base deste segundo tipo for o segundo tipo, esvazie o segundo tipo; retorne.
    Atribua o tipo base deste segundo tipo ao segundo tipo.
  Recomece. [percorra novamente o código acima]

Etapas para que se organize o catálogo de rotinas úteis:
    Se existir algum problema de compilação, retorne.
    Obtenha um bucket usando o catálogo de rotinas úteis.
    Se o bucket for inexistente, retorne.
    Se os referências deste bucket estiverem vazios, recomece.
    Organize o catálogo de rotinas úteis usando os referências deste bucket.
  Recomece. [percorra novamente o código acima]

Etapas para que se organize o catálogo de rotinas úteis usando umas referências:
    Obtenha uma referência desde as referências.
    Se a referência for inexistente, retorne.
    Atribua o ponteiro deste referência para uma rotina.
    Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno #14"; retorne.
    Copie as unidades semânticas desta rotina para umas unidades semânticas.
    Reduza as unidades semânticas por utilização.
    Catalogue a rotina usando as unidades semânticas e o catálogo geral de rotinas.
    Destrua as unidades semânticas.
  Recomece. [percorra novamente o código acima]

Etapas para que se remova alguns termos negativos desde umas unidades semânticas retornando um detector:
  Desative o detector.
  Permute as unidades semânticas com umas segunda unidades semânticas.
  Comece. [a executar o código abaixo]
    Atribua o first unidade semântica destas segunda unidades semânticas para uma unidade semântica.
    Se a unidade semântica for inexistente, retorne.
    Remova a unidade semântica desde a segunda unidades semânticas.
    \PAL
    Se a string desta unidade semântica for "não", inverta o detector; destrua a unidade semântica; recomece.
    \CAL
    Acrescente a unidade semântica para as unidades semânticas.
    Se a string desta unidade semântica for "nothing", inverta o detector; atribua "something" à string desta unidade semântica; recomece.
    Se a string desta unidade semântica for "nada", inverta o detector; atribua "something" à string desta unidade semântica; recomece.
    \Se a string desta unidade semântica termina com "n't", inverta o detector; remova trailing bytes desde a string desta unidade semântica usando 3; recomece.
  Recomece. [percorra novamente o código acima]

Etapas para que se destrinche um campo:
  Se existir algum problema de compilação, retorne.
  Se o campo for inexistente, retorne.
  Destrinche o campo como uma variável.
  Se o apelido deste campo não for algum nome de campo válido, limpe o apelido deste campo. \it
  Se o nome deste campo não for algum nome de campo válido, apresente uma mensagem de erro contendo "#145. '" junto com o nome deste campo seguido de "' é um campo nome inválido." e o endereço local deste campo; retorne.

Etapas para que se destrinche uma variável global:
  Se a variável global for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o corpo de variável global desta variável global não estiver em branco, destrinche a variável global (compile corpo).
  Se o nome do tipo desta variável global estiver em branco, apresente uma mensagem de erro contendo "#146. Tipo inválido: " junto com o nome desta variável global seguido de "' . O tipo da variável variável global está vazio." e o endereço local desta variável global; retorne.
  Destrinche a variável global como uma variável.

Etapas para que se destrinche uma variável global (compile corpo):
  Se a variável global for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o corpo de variável global desta variável global.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum valor literal, apresente uma mensagem de erro contendo "#147. Erro de tipo. O tipo: " junto com o segmento inicial deste percorredor seguido de "' deve ser do tipo literal." e o percorredor; retorne.
  Compile um valor literal usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "#148. Esperado '.' " e o percorredor; retorne.
  Se o nome do tipo desta variável global estiver em branco, atribua o nome deste tipo deste valor literal ao nome do tipo desta variável global.
  Atribua o valor literal ao valor literal desta variável global.
  Catalogue o valor literal.

Etapas para que se destrinche umas variáveis globais:
  Se existir algum problema de compilação, retorne.
  Obtenha uma variável global desde as variáveis globais.
  Se a variável global for inexistente, retorne.
  Destrinche a variável global.
  Recomece. [percorra novamente o código acima]

Etapas para que se destrinche um tipo (tipos de dados primitivos):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o tipo base deste tipo não for inexistente, retorne.
  Encontre o tipo base deste tipo usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  Se o tipo base deste tipo for inexistente, apresente uma mensagem de erro contendo "#149. Tipo base '" junto com o nome do tipo primitivo deste tipo seguido de "' inválido." e o endereço local deste tipo; retorne.
  Ative o detector de recursividade deste tipo.
  Se o detector de recursividade deste tipo base deste tipo estiver ativo, apresente a mensagem de erro contendo "#150. Definição recursiva com: " junto com o nome do tipo primitivo deste tipo seguido de "." e o endereço local deste tipo; retorne.
  Destrinche o tipo base deste tipo (tipos de dados primitivos).
  Desative o detector de recursividade deste tipo.

Um campo português é um campo.
Um campo português feminino é um campo.

Um tipo encadeado é um tipo.

Etapas para que se destrinche um tipo (expand lista): \ tipo base deste tipo não está resolved yet
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o tipo base deste tipo não for inexistente, retorne.
  Se o nome deste tipo for "lista", retorne.
  \Se o nome deste tipo for "elemento", retorne.
  Se o tipo não puder ser reduzido para "lista" usando o nome do tipo primitivo, retorne.
  Encontre um tipo base usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  \ adicione lista estrutura - o número of secret campos é hard coded em two places: search por "du que 4" \ was 6
  Atribua o nome deste tipo seguido de " estrutura" para um nome.
  Atribua o nome deste tipo seguido de " estruturas" para um nome plural.
  Atribua o nome deste tipo base seguido de " estrutura" para um nome do tipo primitivo.
  Adicione um conjunto tipo para os tipos usando o nome e o nome plural e o nome do tipo primitivo.
  Adicione um campo para os campos deste conjunto tipo usando "subsequente " junto com o nome deste tipo e "subsequente" e o nome deste tipo e o detector de ignição.
  Adicione um campo português para os campos deste conjunto tipo usando "seguinte " junto com o nome deste tipo e "seguinte" e o nome deste tipo e o detector de ignição.
  Atribua "subsequente " junto com o nome deste tipo ao nome de redefinição de conteúdo deste campo português.
  Adicione um segundo campo para os campos deste conjunto tipo usando "precedente " junto com o nome deste tipo e "precedente" e o nome deste tipo e o detector de ignição.  
  Adicione um segundo campo português para os campos deste conjunto tipo usando o nome deste tipo seguido de " anterior" e "anterior" e o nome deste tipo e o detector de ignição.
  Atribua "precedente " junto com o nome deste tipo ao nome de redefinição de conteúdo deste segundo campo português.
  Se os campos deste tipo não estiverem vazios, acrescente os campos deste tipo para os campos deste conjunto tipo.
  Catalogue o conjunto tipo.
  \ fix up original tipo para look like um ponteiro
  Atribua o nome deste conjunto tipo ao nome do conteúdo deste tipo.
  \ adicione tipo encadeado
  Adicione um tipo encadeado para os tipos usando o nome plural deste tipo e "" e o nome plural deste tipo base.
  Adicione um terceiro campo para os campos deste tipo encadeado usando "first " junto com o nome deste tipo e "first" e o nome deste tipo e o detector de ignição.
  Adicione um terceiro campo português para os campos deste tipo encadeado usando "primeiro " junto com o nome deste tipo e "primeiro" e o nome deste tipo e o detector de ignição.
  Atribua "first " junto com o nome deste tipo ao nome de redefinição de conteúdo deste terceiro campo português.
  Adicione um terceiro campo português feminino para os campos deste tipo encadeado usando "primeira " junto com o nome deste tipo e "primeira" e o nome deste tipo e o detector de ignição.
  Atribua "first " junto com o nome deste tipo ao nome de redefinição de conteúdo deste terceiro campo português feminino.
  Adicione um quarto campo para os campos deste tipo encadeado usando "last " junto com o nome deste tipo e "last" e o nome deste tipo e o detector de ignição.
  Adicione um quarto campo português para os campos deste tipo encadeado usando "último " junto com o nome deste tipo e "último" e o nome deste tipo e o detector de ignição.
  Atribua "last " junto com o nome deste tipo ao nome de redefinição de conteúdo deste quarto campo português.
  Adicione um quarto campo português feminino para os campos deste tipo encadeado usando "última " junto com o nome deste tipo e "última" e o nome deste tipo e o detector de ignição.
  Atribua "last " junto com o nome deste tipo ao nome de redefinição de conteúdo deste quarto campo português feminino.
  Catalogue o tipo encadeado.

Etapas para que se destrinche um tipo (registro de plurais):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o nome plural deste tipo estiver em branco, retorne.
  Se o tipo puder ser reduzido para "lista" usando o nome do tipo primitivo, retorne.
  Catalogue o tipo usando o nome plural deste tipo.

Etapas para que se destrinche um tipo (dados opcionais - ponteiro):
  Se existir algum problema de compilação, retorne.
  Se o tipo do conteúdo deste tipo não for inexistente, retorne.
  Se o nome do conteúdo deste tipo estiver em branco, atribua o tipo do conteúdo deste tipo base deste tipo ao tipo do conteúdo deste tipo; retorne.
  Encontre o tipo do conteúdo deste tipo usando o nome do conteúdo deste tipo e o catálogo de tipos.
  Se o tipo do conteúdo deste tipo for inexistente, apresente uma mensagem de erro contendo "#151. Não sei bem pra que lista você está se referindo." e o endereço local deste tipo; retorne.

Etapas para que se destrinche um tipo (dados opcionais - conjunto):
  Se existir algum problema de compilação, retorne.
  Se os campos deste tipo estiverem vazios, copie os campos deste tipo base deste tipo aos campos deste tipo; retorne.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo (regressivamente).
    Se o campo for inexistente, pare.
    Se o campo estiver duplicada em os campos deste tipo, apresente uma mensagem de erro contendo "#152. O campo '" junto com o nome deste campo seguido de "' está definido mais de uma vez." e o endereço local deste campo; retorne.
    Destrinche o campo.
    Se existir algum problema de compilação, retorne.
    Se o detector de recursividade deste tipo deste campo estiver ativo, apresente a mensagem de erro contendo "#153. Definição recursiva encontrada no '" junto com o nome deste tipo deste campo seguido de "'." e o endereço local deste campo; retorne.
    Destrinche o tipo deste campo (dados complementares). \ de novo
    Se o detector de referência deste campo não estiver ativo, recomece.
    Se o tipo deste campo não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "#154. Não entendi o parâmetro '(referência)' nesse campo: " junto com o nome deste campo seguido de "'..." e o endereço local deste campo; retorne.
  Recomece. [percorra novamente o código acima]
  Elimine apelidos duplicados desde os campos deste tipo.
  Se o tipo não puder ser reduzido para "lista estrutura", retorne.
  Se a contagem destes campos deste tipo for maior do que 4, retorne. \ already copied? was 2 por subsequente e prev, now 6 para included Spanish redefiniions
  Copie os campos deste tipo base deste tipo aos campos deste tipo (apenas campos de dados).

Etapas para que se destrinche um tipo (dados opcionais - scale):
  Se existir algum problema de compilação, retorne.
  Atribua o tipo base deste tipo para um tipo base.
  Se a razão de escala deste tipo for 0, atribua a razão de escala deste tipo base deste tipo à razão de escala deste tipo; retorne.
  Se a razão de escala deste tipo base for 0, retorne.
  Multiplique a razão de escala deste tipo pela razão de escala deste tipo base.
  Atribua o tipo base deste tipo base ao tipo base deste tipo.

Um tipo base é um tipo.

Etapas para que se destrinche um tipo (dados complementares):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o detector de informações complementares deste tipo estiver ativo, retorne.
  Se o tipo base deste tipo for o tipo, retorne. \ para os tipos pré-definidos
  Verifique por informações opcionais inválidas em o tipo.
  Ative o detector de recursividade deste tipo.
  Destrinche o tipo base deste tipo (dados complementares).
  Se o tipo puder ser reduzido para "ponteiro", destrinche o tipo (dados opcionais - ponteiro).
  Se o tipo puder ser reduzido para "estrutura", destrinche o tipo (dados opcionais - conjunto). \ mudar aqui
  Se o tipo puder ser reduzido para "número", destrinche o tipo (dados opcionais - scale).
  Desative o detector de recursividade deste tipo.
  Ative o detector de informações complementares deste tipo.

Etapas para que se destrinche uns tipos (tipos de dados primitivos): \ Esta rotina é recursiva.
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Destrinche o tipo (tipos de dados primitivos). 
  Recomece. [percorra novamente o código acima]

Etapas para que se destrinche uns tipos (expand listas):
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Destrinche o tipo (expand lista).
  Recomece. [percorra novamente o código acima]

Etapas para que se destrinche uns tipos (registro de plurais):
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Destrinche o tipo (registro de plurais).
  Recomece. [percorra novamente o código acima]

Etapas para que se destrinche uns tipos (dados complementares):
  Se existir algum problema de compilação, retorne.
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Destrinche o tipo (dados complementares).
  Recomece. [percorra novamente o código acima]

Etapas para que se destrinche uma variável:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Se o tipo desta variável não for inexistente, retorne.
  Se o nome do tipo desta variável não estiver em branco, destrinche a variável (usando o nome do tipo declarado); retorne.
  Encontre o tipo desta variável e o apelido desta variável usando o nome desta variável.
  Se o tipo desta variável não for inexistente, atribua o nome deste tipo desta variável ao nome do tipo desta variável; retorne.
  Apresente uma mensagem de erro contendo "#155. Não foi possível determinar o tipo da variável '" junto com o nome desta variável seguido de "'." e o endereço local desta variável.

Etapas para que se destrinche uma variável (usando o nome do tipo declarado):
  Encontre o tipo desta variável usando o nome do tipo desta variável e o catálogo de tipos.
  Se o tipo desta variável for inexistente, apresente uma mensagem de erro contendo "#156. Não foi possível determinar o tipo da variável '" junto com o nome do tipo desta variável seguido de "' no catálogo de tipos." e o endereço local desta variável; retorne.

Etapas para que se arredonde tamanhos de zona para cima;
Etapas para que se arredonde para cima tamanhos de zona:
  Atribua a quantidade de caracteres desta seção de DLLs ao tamanho desta seção de DLLs.
  Arredonde para cima o tamanho desta seção de DLLs usando o múltiplo imediato de 4096.
  Atribua a quantidade de caracteres desta região de dados ao tamanho desta região de dados.
  Arredonde para cima o tamanho desta região de dados  usando o múltiplo imediato de 4096.
  Atribua a quantidade de caracteres desta região de código ao tamanho desta região de código.
  Arredonde para cima o tamanho desta região de código  usando o múltiplo imediato de 4096.

Uma instrução é um subtexto.

Um cabeçalho de rotina é um subtexto.

O catálogo geral de rotinas é um catálogo.

Um tamanho local é um tamanho.

Um detector de função é um detector.

Uma representação de emprego é uma representação interna da rotina.

Uma rotina é uma lista com
  Um endereço local (referência),
  Um detector de compatibilidade,
  Um detector de deliberação,
  Um detector de função,
  Um detector de compilação,
  Um apelido catálogo,
  Um representação interna da rotina, 
  Uns unidades semânticas, 
  Uns parâmetros, 
  Um tamanho do parâmetro,
  Uma representação de emprego,
  Umas variáveis locais, 
  Um tamanho local,
  Um cabeçalho de rotina, 
  Uma string do cabeçalho,
  Umas instruções, 
  Uma string do corpo,
  Uns fragmentos,
  Um endereço.

Uma string do corpo é uma string.
Uma string do cabeçalho é uma string.
Uma referência da rotina é [composta de] umas unidades semânticas.

As rotinas são umas rotinas.

\Etapas para que se examine algum dado complementar de um tipo usando um percorredor:
Etapas para que se examine algum dado complementar para um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for "to", examine algum dado complementar para o tipo usando o percorredor (ponteiros); retorne.
  Se o segmento inicial deste percorredor for "para", examine algum dado complementar para o tipo usando o percorredor (ponteiros); retorne.
  Se o segmento inicial deste percorredor for alguma keyword de complementação, examine algum dado complementar para o tipo usando o percorredor (estrutura); retorne.

Etapas para que se examine algum dado complementar para um tipo usando um percorredor (ponteiros):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente uma mensagem de erro contendo "#157. Sintaxe incorreta no comando 'Aponte para um'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do conteúdo deste tipo usando o percorredor.

Etapas para que se examine algum dado complementar para um tipo usando um percorredor (estrutura):
  Mova o percorredor (usando diretrizes de compilação).
  Examine o campos deste tipo usando o percorredor.

Etapas para que se examine algum pauses usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não for alguma pausa, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Uma keyword é uma string.
Uma keyword de designação é uma keyword.

Etapas para que se examine um campo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Examine o campo usando o percorredor (tipo geral).
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for uma keyword de designação, examine o campo usando o percorredor (cláusula designadora); recomece.
    Se o segmento inicial deste percorredor for "sob", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    \Se o segmento inicial deste percorredor for "equivalente a", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    \Se o segmento inicial deste percorredor for "análogo a", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    \Se o segmento inicial deste percorredor for "análoga a", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for "em", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for "sob", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for "sobre", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for "redefinindo", examine o campo usando o percorredor (cláusula de redefinição); recomece.
    Se o segmento inicial deste percorredor for uma keyword de referenciamento, examine o campo usando o percorredor (cláusula de referência); recomece.

Etapas para que se examine um campo usando um percorredor (cláusula designadora):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o nome do tipo deste campo estiver em branco, atribua o nome deste campo ao nome do tipo deste campo. \ byte array nome do tipo already filled in
  Examine o nome deste campo usando o percorredor.

Etapas para que se examine um campo usando um percorredor (cláusula de redefinição):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido, apresente uma mensagem de erro contendo "#158. Sintaxe incorreta. Esperado 'o/a'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome de redefinição de conteúdo deste campo usando o percorredor.

Etapas para que se examine um campo usando um percorredor (cláusula de referência):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o detector de referência deste campo.

Etapas para que se examine um campo usando um percorredor (tipo: array de bytes):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Reduza a proporção.
  Se o denominador desta proporção não for 1, apresente uma mensagem de erro contendo "#159. Erro de sintaxe. Arrays exigem tamanhos não fracionários" e o percorredor; retorne.
  Atribua o numerador desta proporção à contagem deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "byte" ou "bytes", apresente a mensagem de erro contendo "#160. Erro de sintaxe. Esperado 'bytes' após um número designador." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "byte" ao nome do tipo deste campo.

Etapas para que se examine um campo usando um percorredor (tipo normal):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente uma mensagem de erro contendo "#161. Erro de sintaxe. Esperado 'um/uma'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.  
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outras", atribua "outras" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outros", atribua "outros" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundos", atribua "segundos" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundas", atribua "segundas" ao nome deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste campo com o nome.

Etapas para que se examine um campo usando um percorredor (tipo geral):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal, examine o campo usando o percorredor (tipo: array de bytes); retorne.
  Examine o campo usando o percorredor (tipo normal).

Etapas para que se examine uns campos usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione um campo para o campos usando "campo" e o caractere inicial deste segmento inicial deste percorredor.
  Examine o campo usando o percorredor.
  Se o segmento inicial deste percorredor não for alguma pausa, retorne.
  Examine algum pauses usando o percorredor.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um corpo de variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste corpo de variável global.
  Atribua -1 ao caractere final deste corpo de variável global.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne. \ o retorne sai da rotina
    Se o segmento inicial deste percorredor estiver em branco, retorne. \ o comando recomece volta pro começo do loop
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne. \ o comando pare sai do loop, mas não sai da rotina, apenas do loop
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste corpo de variável global.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Etapas para que se examine uma variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione a variável global para as variáveis globais usando "global" e o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas, examine a variável global usando o percorredor(cláusula 'tem'); retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples, apresente uma mensagem de erro contendo "#162. Erro de sintaxe. Esperado: 'é/está'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, examine a variável global usando o percorredor (literal termo); retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for o início of algum dado complementar, examine a variável global usando o percorredor (dados complementares); retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, examine a variável global usando o percorredor (data part); retorne.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "#163. Erro de sintaxe. Declaração de variáveis globais devem terminar com um '.'" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Etapas para que se examine uma variável global usando um percorredor (data part):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum to, apresente uma mensagem de erro contendo "#164. Erro de sintaxe na variável global. Esperado: 'igual'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "#165. Erro de sintaxe. Esperado '.' ao final de uma declaração variável variável global" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Etapas para que se examine uma variável global usando um percorredor(cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "~inline " junto com o nome desta variável global seguido de " tipo" para um nome.
  Atribua o nome seguido de "s" para um nome plural. \ mudar aqui
  Adicione um tipo para os tipos usando o nome e o nome plural e "estrutura" e o endereço local desta variável global. \mudar aqui
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "#166. Erro de sintaxe na estrutura. Esprado '.' no final de declarações de variáveis globais" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Etapas para que se examine uma variável global usando um percorredor (literal termo):
  Se existir algum problema de compilação, retorne.
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "#167. Erro de sintaxe. Esperado '.' no final de declarações de valores." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Etapas para que se examine uma variável global usando um percorredor (dados complementares):
  Se existir algum problema de compilação, retorne.
  Atribua "~inline " junto com o nome desta variável global seguido de " tipo" para um nome.
  Atribua o nome seguido de "s" para um nome plural. \ aqui pode estar o erro na formação do plural
  Adicione um tipo para os tipos usando o nome e o nome plural e o nome do tipo desta variável global e o endereço local desta variável global.
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "#168. Erro de sintaxe. Esperado '.' após informações complementares." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Etapas para que se examine um nome usando um percorredor:
  Limpe o nome.
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver sobre algum indicador de início de variável, expanda o nome com o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Se o percorredor estiver sobre algum indicador de fim de variável, pare.
    Expanda o nome com o segmento inicial deste percorredor.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]
  Se o nome estiver em branco, apresente uma mensagem de erro contendo "#169. Nome '" junto com o segmento inicial deste percorredor seguido de "' em branco." e o percorredor; retorne.

Etapas para que se examine uma instruções usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial destas instruções.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final destas instruções.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, apresente uma mensagem de erro contendo "#170. Insira ':' ao final do cabeçalho desta rotina." e o percorredor; retorne.
    Se o segmento inicial deste percorredor não for o ponto final, mova o percorredor (usando diretrizes de compilação); recomece.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine uma rotina usando um percorredor:
    \ Define o cabeçalho de rotina.
  Se existir algum problema de compilação, retorne.
  Adicione a rotina para as rotinas usando o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor for "Etapas", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "Passos", mova o percorredor (usando diretrizes de compilação). \ Pula a palavra  "Passos" ou "Etapas" e obtém o subsequente segmento inicial
  Se o segmento inicial deste percorredor for "necessários", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "necessárias", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "para", apresente uma mensagem de erro contendo "#171. Erro de sintaxe. Insira a keyword 'para' '" junto com o segmento inicial deste percorredor seguido de "' neste cabeçalho de rotina." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação). \ ignora o "para" e obtém o subsequente segmento inicial
  Se o segmento inicial deste percorredor for "que", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "que", apresente uma mensagem de erro contendo "Você precisa colocar um 'que' antes da palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ ignora o "que" e obtém o subsequente segmento inicial
  Se o segmento inicial deste percorredor for "se", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "se", apresente uma mensagem de erro contendo "Você precisa colocar um 'se' antes da palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ ignora o "se" e obtém o subsequente segmento inicial
  Examine a cabeçalho de rotina desta rotina usando o percorredor.
  Se o segmento inicial deste percorredor for o ponto&vírgula, examine a rotina usando o percorredor (sobrecarga de métodos); retorne. \ *** usado para nomes alternativos de rotinas
  Se o segmento inicial deste percorredor não for o sinal de dois pontos, apresente a mensagem de erro contendo "#171. Erro de sintaxe. ':' ausente ou mal posicionado" e o endereço local desta rotina; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine as instruções desta rotina usando o percorredor.

Etapas para que se examine uma rotina usando um percorredor (sobrecarga de métodos):
  \ *** para nomes alternativos de rotinas
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o início of alguma rotina, apresente uma mensagem de erro contendo "#172. Erro de sintaxe. ';' ausente ou mal posicionado" e o original percorredor; retorne.
  Atribua o caractere inicial deste segmento inicial deste original percorredor ao caractere inicial destas instruções desta rotina.
  Atribua o caractere final deste segmento inicial deste original percorredor ao caractere final destas instruções desta rotina.
  Mova o original percorredor (usando diretrizes de compilação).

Etapas para que se examine uma cabeçalho de rotina usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste cabeçalho de rotina.
  Atribua -1 ao caractere final deste cabeçalho de rotina.
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, retorne. \ *** alternate wording
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste cabeçalho de rotina.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o trecho deste arquivo fonte.
  Mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o início of algum tipo, examine um tipo usando o percorredor; recomece.
    Se o segmento inicial deste percorredor for o início of alguma variável global, examine uma variável global usando o percorredor; recomece.
    Se o segmento inicial deste percorredor for o início of alguma rotina, examine uma rotina usando o percorredor; recomece.
    Apresente uma mensagem de erro contendo "#172. O compilador não reconhece a sintaxe '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine uns arquivos fontes:
  Se existir algum problema de compilação, retorne.
  Obtenha um arquivo fonte desde os arquivos fontes.
  Se o arquivo fonte for inexistente, retorne.
  Examine o arquivo fonte.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne. 
  Se o segmento inicial deste percorredor for algum artigo indefinido português, ative um português detector. 
  Se o segmento inicial deste percorredor for algum artigo indefinido inglês, ative um english detector. 
  Adicione o tipo para os tipos usando o caractere inicial deste segmento inicial deste percorredor. 
  Mova o percorredor (usando diretrizes de compilação). 
  Examine o nome deste tipo usando o percorredor. 
  Atribua o nome deste tipo ao nome plural deste tipo. 
  Atribua 0 a uma contagem.  
  Se o english detector não estiver ativo, pluralize o nome plural deste tipo (strings em português); adicione 1 à contagem.
  Se o english detector estiver ativo, pluralize o nome plural deste tipo (english rules); adicione 1 à contagem.
  \Se o português detector estiver ativo, pluralize o nome plural deste tipo (strings em português); adicione 1 à contagem.
  Se a contagem for igual ou maior do que 2, 
    apresente uma mensagem de erro contendo "#173. não foi possível detectar o idioma desta variável" e o endereço local deste tipo; retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas, examine o tipo usando o percorredor(cláusula 'tem'); retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples, 
    apresente a mensagem de erro contendo "#174. Esperado 'é/está'. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum valor numérico literal, examine o tipo usando o percorredor (unidade de medida); retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido, 
    apresente a mensagem de erro contendo "#175. Esperado 'um/uma'. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, 
    apresente a mensagem de erro contendo "#176. Insira um '.' após a declaração do tipo." 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Etapas para que se examine um tipo usando um percorredor(cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "estrutura" ao nome do tipo primitivo deste tipo. \\mudar aqui
  Examine o campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "#177. Esperado '.' após a keyword 'tem'. Encontrado '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Etapas para que se examine um tipo usando um percorredor (unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para a razão de escala deste tipo.
  Se a razão de escala deste tipo for 0, apresente uma mensagem de erro contendo "#178. Impossível utilizar 0 em tipos escalares." e o endereço local deste tipo; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "#179. Necessário um '.' no fim desta fração. Encontrado. '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Um scratch é uma variável local.

Etapas para que se scrub um catálogo:
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, retorne.
      Se os referências deste bucket estiverem vazios, recomece.
    Scrub os referências deste bucket.
  Recomece. [percorra novamente o código acima]

Etapas para que se scrub umas referências:
  Permute as referências com uns segunda referências.
  Comece. [a executar o código abaixo]
    Atribua o first referência destes segunda referências para uma referência.
    Se a referência for inexistente, retorne.
    Remova a referência desde a segunda referências.
    Se o ponteiro deste referência for inexistente, destrua a referência; recomece.
    Acrescente a referência para os referências.
  Recomece. [percorra novamente o código acima]

Etapas para que se ative o detector de compilação em uma variável;
Etapas para que se ligue o detector de compilação em uma variável:
  Se a variável for inexistente, retorne.
  Se o detector de compilação desta variável [já] estiver ativo, retorne.
  Ative o detector de compilação desta variável.
  Se a categoria desta variável não for "global", retorne.
  Se o valor literal desta variável for inexistente, retorne.
  Encontre uma rotina usando "atribua" e o tipo deste valor literal desta variável e "para" e o tipo desta variável.
  Se a rotina for inexistente, encontre a rotina usando "converta" e o tipo deste valor literal desta variável e "para" e o tipo desta variável; ative um detector.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "#180. O tipo e o valor da variável variável global  não estão correspondendo." e o endereço local desta variável; retorne.
  Compile o corpo of a rotina.
  Se o detector estiver ativo, atribua "converta o " junto com o nome deste valor literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao texto inicializador desta variável.
  Se o detector não estiver ativo, atribua "atribua o " junto com o nome deste valor literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao texto inicializador desta variável. \ Era " ao ". NÃO PODIA MUDAR O " ao " não sei o porquê

Etapas para que se passe para a palavra subsequente em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste subtexto for irrelevante, pare.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  Ignore algum leading noise no subtexto.

Etapas para que se passe para o precedente palavra em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere final deste subtexto for irrelevante, pare.
  Subtraia 1 desde o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]
  Ignore algum caractere ignorável final no subtexto.

Um arquivo fonte é uma lista com 
  Um endereço completo e 
  Um trecho.

Os arquivos fontes são uns arquivos fontes.

Uma etiqueta é um número.

Um termo é uma estrutura com 
  Uma variável e 
  Uma frase.

Etapas para que se transforme um fragmento em código hexadecimal:
  Se existir algum problema de compilação, retorne.
  Se o fragmento for inexistente, retorne.
  Se a etiqueta deste fragmento for o etiqueta de inserção de endereço [na stack], transforme o fragmento em código hexadecimal (empilhamento de endereço); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda interna, transforme o fragmento em código hexadecimal (Demanda Interna); retorne.
  Se a etiqueta deste fragmento for o etiqueta de carregamento de endereço, transforme o fragmento em código hexadecimal (load endereço); retorne.
  Se a etiqueta deste fragmento for a etiqueta de acréscimo, transforme o fragmento em código hexadecimal (increment); retorne.
  Se a etiqueta deste fragmento for o etiqueta de redirecionamento, transforme o fragmento em código hexadecimal (cláusula de redirecionamento); retorne.
  Se a etiqueta deste fragmento for o etiqueta de desvio falso, transforme o fragmento em código hexadecimal (desvio caso resultado negativo); retorne.
  Se a etiqueta deste fragmento for a etiqueta de negação lógica, transforme o fragmento em código hexadecimal (negação lógica); retorne.
  Se a etiqueta deste fragmento for o etiqueta de retorno, transforme o fragmento em código hexadecimal (cláusula de retorno); retorne.
  Se a etiqueta deste fragmento for a etiqueta de repetição, transforme o fragmento em código hexadecimal(cláusula de repetição); retorne.
  Se a etiqueta deste fragmento for o etiqueta de interrupção, transforme o fragmento em código hexadecimal (cláusula de interrupção); retorne.
  Se a etiqueta deste fragmento for o etiqueta preliminar, transforme o fragmento em código hexadecimal (etapa preliminar); retorne.
  Se a etiqueta deste fragmento for o etiqueta conclusiva, transforme o fragmento em código hexadecimal (etapa conclusiva); retorne.
  Se a etiqueta deste fragmento for o etiqueta de inserção de valor [na stack], transforme o fragmento em código hexadecimal (empilhamento de valor); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda externa, transforme o fragmento em código hexadecimal (Demanda Externa); retorne.
  Se a etiqueta deste fragmento for o etiqueta de carregamento de registrador EAX, transforme o fragmento em código hexadecimal (atribuição de EAX); retorne.
  Se a etiqueta deste fragmento for o etiqueta de obtenção do registrador EAX, transforme o fragmento em código hexadecimal (registrador EAX); retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda indireta, transforme o fragmento em código hexadecimal (Demanda Indireta); retorne.
  Se a etiqueta deste fragmento for a etiqueta de endereço de rotina, transforme o fragmento em código hexadecimal (endereço de rotina); retorne.

Etapas para que se transforme um fragmento em código hexadecimal (cláusula de interrupção):
  Atribua a etiqueta de repetição para uma etiqueta.
  Encontre um segundo fragmento usando o fragmento e a etiqueta.
  Se o segundo fragmento for inexistente, atribua a etiqueta de finalização ao etiqueta. \ para break sem um loop ou depois de um loop
  Encontre um terceiro fragmento usando o last fragmento destes fragmentos desta rotina utilizada atualmente e a etiqueta (regressivamente).
  Se o terceiro fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #15"; retorne.
  Se o subsequente fragmento deste terceiro fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #16"; retorne.
  Acrescente $E9 e o endereço deste subsequente fragmento deste terceiro fragmento para o fragmento. \ JMP o endereço da destination

Etapas para que se transforme um fragmento em código hexadecimal (Demanda Externa):
  Acrescente $FF15 e o endereço desta função deste fragmento para o código deste fragmento. \ Processe [o endereço desta função deste fragmento ]
  \ The acima of rotina generates the machine code for a Processe to the Windows operating system. 
  \The op code is specified, in hexadecimal ($FF15) and the rest of the instruction is the address of the função address of the target rotina, which is appended to the op code.

Etapas para que se transforme um fragmento em código hexadecimal (Demanda Indireta):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ coloca endereço para edx
  Acrescente $FF12 para o código deste fragmento. \ Processe [edx]

Etapas para que se transforme um fragmento em código hexadecimal (Demanda Interna):
  Obtenha um endereço usando o rotina deste fragmento.
  Acrescente $E8 e o endereço para o fragmento. \ Processe o address da rotina do fragmento 

Etapas para que se transforme um fragmento em código hexadecimal (cláusula de redirecionamento):
  Acrescente $8B95 e o deslocamento desta variável deste fragmento para o código deste fragmento. \ mov edx,[ebp+ o deslocamento desta variável deste fragmento]
  Acrescente $8B12 para o código deste fragmento. \ mov edx,[edx]
  Acrescente $8995 e o deslocamento desta variável deste fragmento para o código deste fragmento. \ mov [ebp+ o deslocamento desta variável deste fragmento]

\ THE EPILOG OF EVERY ROUTINE REMOVES ANY LOCAL VARIABLES, RESTORES THE EBP, AND RETURNS TO THE CALLER, POPPING ANY PARAMETERS AS HE DOES.
Etapas para que se transforme um fragmento em código hexadecimal (etapa conclusiva):
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, acrescente $5F5E5B para o código deste fragmento. \ pop edi; pop esi; pop ebx;
  Acrescente $8BE5 para o código deste fragmento. \ mov esp,ebp -> não seria 89EC?
  Acrescente $5D para o código deste fragmento. \ pop ebp
  Acrescente $C2 e o tamanho do parâmetro desta rotina utilizada atualmente para o código deste fragmento. \ ret + o tamanho do parâmetro da rotina utilizada atualmente

Um tamanho do parâmetro é um tamanho.

Etapas para que se transforme um fragmento em código hexadecimal (cláusula de retorno):
  Encontre um segundo fragmento usando o fragmento e a etiqueta de finalização.
  Se o segundo fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #17"; retorne.
  Acrescente $E9 e o endereço deste segundo fragmento para o fragmento. \ jmp + o address da destination

Etapas para que se transforme um fragmento em código hexadecimal (increment):
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #18"; retorne.
  Se a categoria desta variável deste fragmento não for "scratch", apresente a mensagem de erro contendo "Erro interno #19"; retorne.
  Acrescente $8185 e o deslocamento desta variável deste fragmento e o número deste fragmento para o código deste fragmento. \ add [ebp+ o deslocamento desta variável deste fragmento], o número deste fragmento

Etapas para que se transforme um fragmento em código hexadecimal (desvio caso resultado negativo):
  Encontre um segundo fragmento usando o fragmento e o etiqueta delimitadora de bloco condicional.
  Se o segundo fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #20"; retorne.
  Acrescente $83F800 para o código deste fragmento. \ cmp eax,0
  Acrescente $0F84 e o endereço deste segundo fragmento para o fragmento. \ je + o address da destination

Etapas para que se transforme um fragmento em código hexadecimal (load endereço):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Acrescente $8995 e o deslocamento desta segunda variável deste fragmento para o código deste fragmento. \ mov [ebp+ o deslocamento desta variável deste fragmento],edx

\Etapas para que se transforme um fragmento em código hexadecimal (atribuição de EAX):
\Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
\Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Internal erro - transforme um fragmento em código hexadecimal (atribuição de EAX)"; retorne.
\Se o tipo desta variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transforme um fragmento em código hexadecimal (atribuição de EAX)"; retorne.
 \Se a quantidade de caracteres deste tipo desta variável deste fragmento não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transforme um fragmento em código hexadecimal (atribuição de EAX)"; retorne.
\Acrescente $8B02 para o código deste fragmento. \ mov eax,[edx]

Etapas para que se transforme um fragmento em código hexadecimal (atribuição de EAX):
  Acrescente $B8 e o detector deste fragmento para o código deste fragmento. \ mov eax,detector
\Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável do fragmento. \ atribua endereço para edx
\Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Internal erro - transforme um fragmento em código hexadecimal (atribuição de EAX)"; retorne.
\Se o tipo desta variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transforme um fragmento em código hexadecimal (atribuição de EAX)"; retorne.
\Se a quantidade de caracteres deste tipo desta variável deste fragmento não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transforme um fragmento em código hexadecimal (atribuição de EAX)"; retorne.
\Acrescente $8B02 para o código deste fragmento. \ mov eax,[edx]

Etapas para que se transforme um fragmento em código hexadecimal (negação lógica):
  Acrescente $83F001 para o código deste fragmento. \ xor eax,1

\ THE PROLOG OF EVERY PLAIN ENGLISH ROUTINE BEGINS BY SAVING THE CALLER'S EBP ON THE STACK, JUST ABOVE THE RETURN ADDRESS. 
Etapas para que se transforme um fragmento em código hexadecimal (etapa preliminar):
  Acrescente $55 para o código deste fragmento. \ push ebp -> saves the contents of the EBP register on the stack.
  Acrescente $8BEC para o código deste fragmento. \ mov ebp,esp -> puts the contents of the ESP register into the EBP register
  Atribua o tamanho local desta rotina utilizada atualmente dividido por 4 para um número.
  Se o número não for 0, acrescente $B9 \ mov ecx,number;  -> sets up the loop that will clear enough space on the stack for the routine's local variables
    e O número e $6A004975FB \loop: push 0; dec ecx; jnz loop -> a loop that pushes enough zeros onto the stack to initialize the local variables.
  para o código deste fragmento. 
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, acrescente $535657 para o código deste fragmento. \ push ebx, esi, edi ->  save the EBX, ESI, and EDI registers on the stack.

Etapas para que se transforme um fragmento em código hexadecimal (empilhamento de endereço):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Acrescente $52 para o código deste fragmento. \ push edx -> push the 4-byte value in edx onto the stack

Etapas para que se transforme um fragmento em código hexadecimal (empilhamento de valor):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribua endereço para edx
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #21"; retorne.
  Se o tipo desta variável deste fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #22"; retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, acrescente $FF32 para o código deste fragmento; retorne. \ push [edx]
  Se a quantidade de caracteres for 2, acrescente $66FF32 para o código deste fragmento; retorne. \ push word ptr [edx]
  Se a quantidade de caracteres for 1, acrescente $0FB61252 para o código deste fragmento; retorne. \ movzxb edx,[edx]; push edx
  Apresente a mensagem de erro contendo "Erro interno #23".

Etapas para que se transforme um fragmento em código hexadecimal(cláusula de repetição):
  Encontre um segundo fragmento usando o fragmento e o etiqueta de laço (regressivamente).
  Se o segundo fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #24 "; retorne.
  Acrescente $E9 e o endereço deste segundo fragmento para o fragmento. \ jmp o address da destination 

Etapas para que se transforme um fragmento em código hexadecimal (endereço de rotina):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribui o endereço para o registrador edx
  Se a rotina deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #25"; retorne.
  Obtenha um endereço usando a rotina deste fragmento.
  Acrescente $C702 e o endereço para o código deste fragmento. \ mov [edx],the endereço

Etapas para que se transforme um fragmento em código hexadecimal (registrador EAX):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento. \ atribui o endereço para o registrador edx
  Se a variável deste fragmento for inexistente, apresente uma mensagem de erro contendo "Erro interno #26"; retorne.
  Se o tipo desta variável deste fragmento for inexistente, apresente a mensagem de erro contendo "Erro interno #27"; retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, acrescente $8902 para o código deste fragmento; retorne. \ mov [edx],eax
  Se a quantidade de caracteres for 2, acrescente $668902 para o código deste fragmento; retorne. \ mov [edx],ax
  Se a quantidade de caracteres for 1, acrescente $8802 para o código deste fragmento; retorne. \ mov [edx],al
  [Se a quantidade de caracteres não for 1, 2 ou 4] Apresente a mensagem de erro contendo "Erro interno #28".

Etapas para que se transforme uns fragmentos em código hexadecimal:
  \Comece.
    Se existir algum problema de compilação, retorne.
    Obtenha um fragmento desde o fragmentos.
    Se o fragmento for inexistente, retorne.
    Transforme o fragmento em código hexadecimal.
  Recomece. [percorra novamente o código acima]

Etapas para que se transforme uma rotina em código hexadecimal:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o representação de emprego desta rotina não estiver em branco, retorne.
  Se o detector de compilação desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Transforme os fragmentos desta rotina em código hexadecimal.

Etapas para que se transforme umas rotinas em código hexadecimal:
  \Comece.
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, pare.
    Transforme a rotina em código hexadecimal.
  Recomece. [percorra novamente o código acima]

O catálogo de tipos é um catálogo.

Um nome do tipo primitivo é um nome.
O nome do conteúdo é um nome.
O tipo do conteúdo é um tipo.
Um detector de informações complementares é um detector.

Um tipo é uma lista com
  Um endereço local (referência),
  Um nome, um nome plural,
  Um cabeçalho compactado,
  Uma quantidade de caracteres,
  Um nome do tipo primitivo, 
  Um tipo base (referência),
  Um nome do conteúdo, 
  Um tipo do conteúdo (referência) [aplicável somente a ponteiros],
  Uma razão de escala,
  Uns campos [aplicável somente a estruturas],
  Um detector de recursividade,
  Um detector de informações complementares.

Um detector de recursividade é um detector.

Um nome do tipo é um nome.

Os tipos são uns tipos.

O catálogo de rotinas úteis é um catálogo.

Uma variável é uma lista com
  Um endereço local (referência),
  Um categoria [lvalor iteral, variável global, variável local, parâmetro, scratch],
  Um detector de compilação,
  Um nome, 
  Um apelido, 
  Um nome do tipo,
  Um tipo (referência), \ tipo real em literal, variável global e local; tipos revogados em parâmetros e scratches
  Um endereço [variáveis globais e valores literais somente] ou 
  Um deslocamento sob o endereço [variáveis locais, parâmetros, e campos somente],
  Uma contagem [campos somente],
  Um detector de referência [campos somente],
  Um nome de redefinição de conteúdo [campos somente],
  Um detector de passagem por-valor [parâmetros somente],
  Um corpo de variável global [variáveis globais somente],
  Um texto inicializador [variáveis globais somente],
  Um valor literal (referência) [variáveis globais somente - constante com a qual se inicializa a variável global],
  Um texto hexadecimal denominado data [literais somente].

Um deslocamento é um número.

Um texto inicializador é uma string.

Um detector de referência é um detector.
Um detector de passagem por-valor é um detector.
Um nome de redefinição de conteúdo é um nome.

Etapas para que se ignore algum caractere ignorável final em um subtexto:
  \Comece.
    Se o subtexto estiver em branco, retorne.
    Se o conteúdo deste caractere final deste subtexto não for irrelevante, retorne.
    Subtraia 1 desde o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]

\ Rotina nova criada pelo Dahn para - reverse functions
\ To put o xxx uv a/the yyy para zzz
\ internally we turn this para "to put a/the yyy's xxx para zzz"
Etapas para que se compile o cabeçalho of uma rotina usando um percorredor (função do possessivo reverso):
  Se existir algum problema de compilação, retorne.
  Ative o detector de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação). \ ignora "atribua" 
  Mova o percorredor (usando diretrizes de compilação). \ ignora "the" ou um artigo definido em português
  Examine um nome usando o percorredor. \ nome do campo
  Mova o percorredor (usando diretrizes de compilação). \ ignora "uv" ou "de"
  Se o segmento inicial deste percorredor for algum artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo definido).
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for alguma função possessiva reversa into, apresente uma mensagem de erro contendo "#181. Erro de sintaxe. Esperado: 'para'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Adicione uma terceira unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "#182. Erro. A rotina para que se " junto com a representação interna da rotina seguido de ": já havia sido definida." e o endereço local desta rotina; retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido, apresente a mensagem de erro contendo "#183. Erro. Esperado 'um/uma'. Encontrado: '" junto com o segmento inicial deste percorredor seguido de "'." e o percorredor; retorne.
  Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "#184. Comandos inválidos no final desta rotina." e o percorredor; retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ Para employs

\ Rotina nova criada pelo Dahn para - reverse functions
\ para atribua o xxx uv a/the yyy para zzz
Etapas para que se determine se um percorredor é o início of alguma função possessiva reversa:
  Se o detector de erros deste compilador estiver ativo, diga não.
  Se o segmento inicial deste percorredor não for algum comando de atribuição, diga não.
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor não for sobre algum possessivo reverso, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

\finalmente  acabou