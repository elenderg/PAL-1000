\ o compilador copyright © 2006-2021 a ordem osmosiana

 \ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

  
 \Plain English armazena strings em duas partes para que seja fácil trocar o primeiro e o último bytes de uma string, com um pequeno comando como este:
 \ Swap the string's first's target with the string's last's target.
 \Todos os parâmetros são passados  por referência, então a string modificada é retornada na variável passada, que é a maneira natural e óbvia de fazer isso.
 \Por exemplo, se você passar o saleiro para alguém na mesa de jantar e ela usar um pouco, você receberá o saleiro de volta com menos sal do que quando passou.

\Quando um parâmetro é passado "por referência", o chamador e o receptor usam a mesma variável para o parâmetro. 
\Se o receptor modifica a variável do parâmetro, o efeito é visível para a variável do chamador.
\Quando um parâmetro é passado "por valor", o chamador e o receptor têm duas variáveis independentes com o mesmo valor. 
\Se o receptor modifica a variável de parâmetro, o efeito não é visível para o chamador.
\ caso você precise, você pode "isolar" a variável

Uma mensagem de erro é uma string.
Uma contagem de nomes é uma contagem.

O temporizador de escrita é um temporizador. \ Um temporizador é um estrutura com uma contagem, uns intervalos iniciais e uns intervalos totais. \ Um intervalo é um número.
O temporizador de transmutação é um temporizador.
O temporizador de análise/verificação é um temporizador.
O temporizador de resolução de variáveis globais é um temporizador.
O temporizador de resolução de tipos é um temporizador.
O temporizador de operacionalização é um temporizador.
O temporizador de deslocamentos é um temporizador.
O temporizador de vinculação é um temporizador.
O temporizador de ferramentas de catalogação é um temporizador.
O temporizador de compilação do conteúdo das rotinas é um temporizador.
O temporizador de compilação de cabeçalhos de rotina é um temporizador.
O temporizador de etapas de cálculo é um temporizador.
O temporizador de endereçamento é um temporizador.
O temporizador de adição de rotinas pré-definidas de mémoria é um temporizador.
O temporizador de adição de rotinas pré-definidas de inicialização é um temporizador.

A etiqueta de interrupção é uma etiqueta igual a 1.
A etiqueta de demanda externa é uma etiqueta igual a 2.
A etiqueta de demanda indireta é uma etiqueta igual a 3.
A etiqueta de demanda interna é uma etiqueta igual a 4.
A etiqueta de revogação é uma etiqueta igual a 5.
A etiqueta delimitadora de bloco condicional é uma etiqueta igual a 6.
A epilog etiqueta é uma etiqueta igual a 7.
A etiqueta de retorno é uma etiqueta igual a 8.
A etiqueta de finalização é uma etiqueta igual a 9.
A etiqueta de acréscimo é uma etiqueta igual a 10.
A etiqueta de decodificação é uma etiqueta igual a 11.
A etiqueta de desvio falso é uma etiqueta igual a 12.
A etiqueta de carregamento de endereço é uma etiqueta igual a 13.
A etiqueta de carregamento de registrador EAX é uma etiqueta igual a 14.
A etiqueta de laço é uma etiqueta igual a 15.
A etiqueta de negação lógica é uma etiqueta igual a 16.
A etiqueta preliminar é uma etiqueta igual a 17.
A etiqueta de inserção de endereço [na stack] é uma etiqueta igual a 18.
A etiqueta de inserção de valor [na stack] é uma etiqueta igual a 19.
A etiqueta de obtenção do registrador EAX é uma etiqueta igual a 20.
A etiqueta de repetição é uma etiqueta igual a 21.
A etiqueta de endereço de rotina é uma etiqueta igual a 22.

O compilador é um estrutura com
  Um endereço da pasta,
  Um temporizador,
  Um detector de erros, 
  Um mensagem de erro,
  Um endereço completo do arquivo de erro,
  Um número da linha de erro,
  Uma contagem de nomes,
  Um trecho exe,
  Um listagem trecho.

Etapas para que se apresente uma mensagem de erro contendo uma string:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Ligue o detector de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.

Etapas para que se apresente uma mensagem de erro contendo uma string e um ponteiro do byte:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Ligue o detector de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.
  Encontre o endereço completo do arquivo de erro deste compilador e o número da linha de erro deste compilador usando o ponteiro do byte .
  Se o endereço completo do arquivo de erro deste compilador estiver em branco, retorne.
  Extraia um nome do arquivo desde o endereço completo do arquivo de erro deste compilador.
  Anteponha "Erro no " junto com o nome do arquivo seguido de ". " para a mensagem de erro deste compilador.

Etapas para que se apresente uma mensagem de erro contendo uma string e um percorredor:
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo a string e o caractere inicial deste segmento inicial deste percorredor; retorne.
  Apresente a mensagem de erro contendo a string e o caractere final deste segmento final deste percorredor.

Etapas para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Adicione a rotina de finalização pelo type.
  Adicione a rotina de alocação para o type.
  Adicione a rotina de desalocação para o type.
  Adicione a rotina de destruição pelo type.
 Recomece. [percorra novamente o código acima]

Etapas para que se adicione o rotina de alocação para um type:
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type não puder ser reduzido para "ponteiro", retorne.
  Se o conteúdo type deste type for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "Aloque memória para um " junto com o nome deste type para o header string desta rotina. \ traduzir aqui
  Posponha "Associe o " junto com o nome deste type seguido de " usando " para o body string desta rotina. \Nomeie
  Posponha a quantidade de caracteres deste conteúdo type deste type seguido de "." para o body string desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
  Lance as instruções desta rotina sobre o body string desta rotina.
  Compile o header of a rotina.

Etapas para que se adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "~initialize before run e run e finalize after run" para o header string desta rotina.
  Posponha "initialize before run. " para o body string desta rotina.
  Posponha os global initializers para o body string desta rotina.
  Posponha "execute o programa. " para o body string desta rotina. \ traduzir
  Posponha os global finalizers para o body string desta rotina.
  Posponha "finalize after run. " para o body string desta rotina.
  Posponha "Processe ""kernel32.dll"" ""ExitProcess"" com 0. " para o body string desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
  Lance as instruções desta rotina sobre o body string desta rotina.
  Compile o header of a rotina.
  Compile o body of a rotina.

Etapas para que se adicione os built-in types:
  Adicione um built-in type usando "byte" e "bytes" e 1.
  Adicione um outro built-in type usando "estrutura" e "estruturas" e 0.

Etapas para que se adicione um built-in type usando um nome e um plural nome e uma quantidade de caracteres:
  Adicione o built-in type para os types usando o nome e o plural nome e o nome.
  Atribua a quantidade de caracteres ao quantidade de caracteres deste built-in type.
  Atribua o built-in type ao base type deste built-in type.
  Catalogue o built-in type.

Etapas para que se adicione o rotina de desalocação para um type:
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type não puder ser reduzido para "ponteiro", retorne.
  Se o conteúdo type deste type for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "Desaloque um " junto com o nome deste type para o header string desta rotina.
  Posponha "Se o " junto com o nome deste type seguido de " for inexistente, retorne. " para o body string desta rotina.
  Se o conteúdo type deste type deveria ser finalizado, posponha "~finalize o conteúdo de este " junto com o nome deste type seguido de ". " para o body string desta rotina. \ precisa ter uma rotina de destruição gerada automaticamente para ele "
  Posponha "Desassocie o " junto com o nome deste type seguido de "." para o body string desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
  Lance as instruções desta rotina sobre o body string desta rotina.
  Compile o header of a rotina.

Etapas para que se adicione o rotina de destruição por um type:
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type não deveria ser ignorado, retorne.
  Se o type puder ser reduzido para "coisas", adicione o rotina de destruição pelo type (coisas); retorne.
  Se o type puder ser reduzido para "ponteiro", adicione o rotina de destruição pelo type (ponteiro); retorne.

Etapas para que se adicione o rotina de destruição por um type (ponteiro):
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua "Destrua [" junto com o nome deste type seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "Destrua um " junto com o nome deste type para o header string desta rotina.
  Posponha "Se o " junto com o nome deste type seguido de " for inexistente, retorne. " para o body string desta rotina.
  Se o conteúdo type deste type puder ser reduzido para "ponteiro", posponha "Destrua o conteúdo de este " junto com o nome deste type seguido de "'. " para o body string desta rotina.
  Se o conteúdo type deste type puder ser reduzido para "coisas", posponha "Destrua o conteúdo de este " junto com o nome deste type seguido de "'. " para o body string desta rotina.
  Comece. [a executar o código abaixo]
    Obtenha um campo desde os campos deste conteúdo type deste type.
    Se o campo for inexistente, pare.
    Se o reference detector deste campo estiver ativo, recomece.
    Se o type deste campo não deveria ser ignorado, recomece.
    Posponha "Destrua o " junto com o nome deste type seguido de "'s " junto com o nome deste campo seguido de ". " para o body string desta rotina.
  Recomece. [percorra novamente o código acima]
  Posponha "Desaloque o " junto com o nome deste type seguido de ". " para o body string desta rotina. \ traduzir aqui
  Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
  Lance as instruções desta rotina sobre o body string desta rotina.
  Compile o header of a rotina.

Etapas para que se adicione o rotina de destruição por um type (coisas):
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  \Atribua "Erro interno na hora de executar a tarefa de destruição de tipos" ao texto retornado.
  Se o first campo destes campos deste type for inexistente, apresente uma mensagem de erro contendo "Erro interno no campo do tipo. Veja rotina 'adicione um forget rotina por um type (coisas)'"; [Say o texto retornado;] exit. \Adicionado Say o texto retornado
  Se o type deste first campo destes campos deste type for inexistente, apresente a mensagem de erro contendo "Erro interno no tipo do campo. Consulte a rotina 'adicione o forget rotina por um type (coisas)'"; retorne.
  Atribua "Destrua [" junto com o nome deste type seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "Destrua um " junto com o nome deste type para o header string desta rotina.
  Posponha "Se o " junto com o nome deste type seguido de "'s first for inexistente, retorne. " para o body string desta rotina. \ listas duplamente encadeadas
  Atribua o nome deste type deste first campo destes campos deste type para um nome.
  Posponha "Atribua o " junto com o nome deste type seguido de "'s first para um " junto com o nome seguido de ". " para o body string desta rotina.
  Posponha "Remove o " junto com o nome seguido de " desde o " junto com o nome deste type seguido de ". " para o body string desta rotina.
  Posponha "Destrua o " junto com o nome seguido de ". " para o body string desta rotina.
  Posponha "Recomece. " para o body string desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
  Lance as instruções desta rotina sobre o body string desta rotina.
  Compile o header of a rotina.

Etapas para que se adicione um entry para uns imports usando um import nome e um entry nome:
  Encontre um import usando o import nome.
  Se o import for inexistente, adicione o import para o imports usando o import nome.
  Encontre a entry usando a entry nome e as entries deste import.
  Se a entry não for inexistente, retorne.
  Crie a entry.
  Posponha a entry para as entries deste import.
  Atribua a entry nome ao nome desta entry.

Etapas para que se adicione um campo para uns campos usando um nome e um nickname e um type nome e um reference detector:
  Adicione o campo para o campos usando "campo" e nil.
  Atribua o nome ao nome deste campo.
  Atribua o nickname ao nickname deste campo.
  Atribua o type nome ao type nome deste campo.
  Atribua o reference detector ao reference detector deste campo.

Etapas para que se adicione a rotina de finalização por um type:
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type não deveria ser finalizado, retorne.
  Se o nome deste type for "string", adicione a rotina de finalização pelo type (texto); retorne.
  Se o nome deste type for "texto", adicione a rotina de finalização pelo type (texto); retorne.
  Se o type puder ser reduzido para "string", retorne. \ prevents generation of finalizer por derived string types
  Se o type puder ser reduzido para "texto", retorne.
  Adicione a rotina de finalização pelo type (conjunto).

Etapas para que se adicione a rotina de finalização por um type (conjunto):
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "~finalize um " junto com o nome deste type para o header string desta rotina.
  Posponha "Decodifique $50. " para o body string desta rotina. \ push eax -> push the 4 bytes value in EAX onto the stack
  \The push instruction places its operand onto the top of the hardware supported stack in memory. 
  \Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location sob address [ESP]. 
  \ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde high addresses to lower addresses.
  Comece. [a executar o código abaixo]
    Obtenha um campo desde os campos deste type.
    Se o campo for inexistente, pare.
    Se o type deste campo não deveria ser finalizado, recomece.
    Posponha "~finalize o " junto com o nome deste type seguido de "'s " junto com o nome deste campo seguido de ". " para o body string desta rotina.
  Recomece. [percorra novamente o código acima]
  Posponha "Decodifique $58." para o body string desta rotina. \ pop eax -> pop the top element of the stack into memory ar the four bytes starting at location EAX.
  \  \pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location). 
  \It first moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
  Lance as instruções desta rotina sobre o body string desta rotina.
  Compile o header of a rotina.

Etapas para que se adicione a rotina de finalização por um type (texto):
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Posponha "~finalize um " junto com o nome deste type para o header string desta rotina.
  Posponha "Decodifique $50. " para o body string desta rotina. \ push eax -> push the 4 bytes value in EAX onto the stack
  \ Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location sob endereço [ESP]. 
  \ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde high addresses to lower addresses.
  Posponha "Desassocie o caractere inicial de esta string . " para o body string desta rotina. \\ traduzir string aqui  
  Posponha "Decodifique $58." para o body string desta rotina. \ pop eax -> pop the top element of the stack into memory at the four bytes starting at location EAX.
  \pop 4 bytes off the stack and put them into eax
  \ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location). 
  \ It first moves the 4 bytes located sob memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
  Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
  Lance as instruções desta rotina sobre o body string desta rotina.
  Compile o header of a rotina.

Etapas para que se adicione um fragment usando uma etiqueta:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragment; retorne.
  Crie o fragment usando a etiqueta.
  Posponha o fragment para os fragments desta rotina utilizada atualmente.

Etapas para que se adicione um fragment usando uma etiqueta e um entry:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragment; retorne.
  Crie o fragment usando a etiqueta.
  Posponha o fragment para os fragments desta rotina utilizada atualmente.
  Atribua a entry à entry deste fragment.

Etapas para que se adicione um fragment usando uma etiqueta e um detector:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragment; retorne.
  Crie o fragment usando a etiqueta.
  Posponha o fragment para os fragments desta rotina utilizada atualmente.
  Atribua o detector ao detector deste fragment.

Etapas para que se adicione um fragment usando uma etiqueta e uma rotina:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragment; retorne.
  Crie o fragment usando a etiqueta.
  Posponha o fragment para os fragments desta rotina utilizada atualmente.
  Atribua a rotina à rotina deste fragment.
  Compile o body of a rotina.

Etapas para que se adicione um fragment usando uma etiqueta e uma variável:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragment; retorne.
  Crie o fragment usando a etiqueta.
  Posponha o fragment para os fragments desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragment.
  Ligue o compiled detector na variável.

Etapas para que se adicione um fragment usando uma etiqueta e uma variável e uma segunda variável:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragment; retorne.
  Crie o fragment usando a etiqueta.
  Posponha o fragment para os fragments desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragment.
  Atribua a segunda variável ao segunda variável deste fragment.
  Ligue o compiled detector na variável.
  Ligue o compiled detector no segunda variável.

Etapas para que se adicione um fragment usando uma etiqueta e uma variável e um número:
  Se a rotina utilizada atualmente for inexistente, esvazie o fragment; retorne.
  Crie o fragment usando a etiqueta.
  Posponha o fragment para os fragments desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragment.
  Atribua o número ao número deste fragment.
  Ligue o compiled detector na variável.

Etapas para que se adicione um import para uns imports usando um import nome:
  Crie o import.
  Posponha o import para o imports.
  Atribua o import nome ao nome deste import.

Etapas para que se adicione um intermediate usando um type nome e um local de aparição:
  Se a rotina utilizada atualmente for inexistente, esvazie o intermediate; retorne.
  Adicione o intermediate para os locals desta rotina utilizada atualmente usando "local" e o local de aparição.
  Gere o nome deste intermediate usando "~I".
  Atribua o type nome ao type nome deste intermediate.
  Resolva o intermediate.

Etapas para que se adicione um literal para uns variáveis usando um local de aparição:
  Adicione o literal como uma variável para as variáveis usando "literal" e o local de aparição.
  Gere o nome deste literal usando "~L".

Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando um expression:
  Crie o unidade semântica.
  Posponha o unidade semântica para os unidades semânticas.
  Atribua a phrase desta expression à string deste unidade semântica.
  Atribua a variável desta expression à variável deste unidade semântica.
  Se a variável desta expression não for inexistente, atribua o type desta expression ao type deste unidade semântica.

  \# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando uma string: \ creio que isso aqui ajude nas funções
  Crie o unidade semântica.
  Posponha o unidade semântica para os unidades semânticas.
  \PAL
  \\ conjunctions
  Se a string for "e", atribua "e" à string deste unidade semântica; retorne. \ and
  Se a string for "ou", atribua "ou" à string deste unidade semântica; retorne. \ or
  \ usando
  Se a string for "desde", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "a partir de", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "partindo de", atribua "usando" à string deste unidade semântica; retorne.
  \Se a string for "de", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "dada", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "dado", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "dadas", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "dados", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "com", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "usando", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "contendo", atribua "usando" à string deste unidade semântica; retorne.
  \\ para
  \Se a string for "em", atribua "para" à string deste unidade semântica; retorne. \  ver isso aqui com calma
  Se a string for "a", atribua "para" à string deste unidade semântica; retorne.
  Se a string for "para", atribua "para" à string deste unidade semântica; retorne.
  \\ é
  Se a string for "é", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "está", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "for", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "foi", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "foram", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "forem", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "estiver", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "estiverem", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "estamos", atribua "é" à string deste unidade semântica; retorne.
  \Se a string for "seja", atribua "é" à string deste unidade semântica; retorne.
  \Se a string for "tem", atribua "é" à string deste unidade semântica; retorne.
  \Se a string for "tiver", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "são", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "estão", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "is", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "forem", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "estiverem", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "puder", atribua "pode" à string deste unidade semântica; retorne.
  Se a string for "puderem", atribua "pode" à string deste unidade semântica; retorne.
  Se a string for "existe", atribua "existe" à string deste unidade semântica; retorne.
  \Se a string for "decide", atribua "decidir" à string deste unidade semântica; retorne.
  \Se a string for "decidiu", atribua "decidir" à string deste unidade semântica; retorne.
  \Se a string for "decidindo", atribua "decidir" à string deste unidade semântica; retorne. \melhor não por gerúndio ou verbos compostos
  \Se a string for "decidiu-se", atribua "decidir" à string deste unidade semântica; retorne.
  Se a string for "existir", atribua "existe" à string deste unidade semântica; retorne.
  \\ allocates e destroys
  \Se a string for "alojar", atribua "allocate" à string deste unidade semântica; retorne.
  \Se a string for "aloje", atribua "allocate" à string deste unidade semântica; retorne.
  \Se a string for "alocar", atribua "allocate" à string deste unidade semântica; retorne.
  \Se a string for "aloque", atribua "allocate" à string deste unidade semântica; retorne.
  \Se a string for "reservar", atribua "allocate" à string deste unidade semântica; retorne.
  \Se a string for "reserve", atribua "allocate" à string deste unidade semântica; retorne.
  \Se a string for "memória", atribua "memória" à string deste unidade semântica; retorne.
  \Se a string for "for", atribua "por" à string deste unidade semântica; retorne. \\servia pra converter o "for" para "por"
  Se a string for "pelo", atribua "por o" à string deste unidade semântica; retorne.
  Se a string for "pela", atribua "por o" à string deste unidade semântica; retorne.
  \Se a string for "desalocar", atribua "deallocate" à string deste unidade semântica; retorne.
  \Se a string for "desaloque", atribua "deallocate" à string deste unidade semântica; retorne.
  \\Se a string for "desalojar", atribua "deallocate" à string deste unidade semântica; retorne.
  \Se a string for "desaloje", atribua "deallocate" à string deste unidade semântica; retorne.
  \Se a string for "esvaziar", atribua "deallocate" à string deste unidade semântica; retorne.
  \Se a string for "esvazie", atribua "deallocate" à string deste unidade semântica; retorne.
  \Se a string for "destruir", atribua "destroy" à string deste unidade semântica; retorne.
  \CAL
  \\ usando
  Se a string for "from", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "given", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "com", atribua "usando" à string deste unidade semântica; retorne.
  Se a string for "using", atribua "usando" à string deste unidade semântica; retorne.
  \ para
  Se a string for "in", atribua "para" à string deste unidade semântica; retorne.
  Se a string for "into", atribua "para" à string deste unidade semântica; retorne.
  Se a string for "to", atribua "para" à string deste unidade semântica; retorne.
  \ é
  Se a string for "are", atribua "é" à string deste unidade semântica; retorne.
  Se a string for "is", atribua "é" à string deste unidade semântica; retorne.
  \ aren't/isn't
  Se a string for "isn't", atribua "não é" à string deste unidade semântica; retorne.
  Se a string for "aren't", atribua "não é" à string deste unidade semântica; retorne.
  \ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
  Se a string for "backward", atribua "backward" à string deste unidade semântica; retorne.
  Se a string for "backwards", atribua "backward" à string deste unidade semântica; retorne.
  Se a string for "counterclockwise", atribua "backward" à string deste unidade semântica; retorne.
  Se a string for "counter-clockwise", atribua "backward" à string deste unidade semântica; retorne.
  Se a string for "anticlockwise", atribua "backward" à string deste unidade semântica; retorne.
  Se a string for "anti-clockwise", atribua "backward" à string deste unidade semântica; retorne.
  \ sobre
  Se a string for "sob", atribua "sobre" à string deste unidade semântica; retorne.
  Se a string for "on", atribua "sobre" à string deste unidade semântica; retorne.
  Se a string for "sobre", atribua "sobre" à string deste unidade semântica; retorne.
  \ other
  Atribua a string à string deste unidade semântica.

Etapas para que se adicione uma unidade semântica para umas unidades semânticas usando um type:
  Crie o unidade semântica.
  Posponha o unidade semântica para os unidades semânticas.
  Atribua o type ao type deste unidade semântica.

Etapas para que se adicione push fragments usando umas unidades semânticas:
  Se a rotina utilizada atualmente for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde os unidades semânticas (backwards).
    Se o unidade semântica for inexistente, retorne.
    Se a variável deste unidade semântica for inexistente, recomece.
    Se o subtexto atual deste unidade semântica não estiver em branco, recomece.
    Se o type atual deste unidade semântica for inexistente, recomece.
    Adicione um fragment usando o etiqueta de inserção de endereço [na stack] e a variável deste unidade semântica.
  Recomece. [percorra novamente o código acima]

Etapas para que se adicione o atribua ou converta fragments usando uma variável e uma segunda variável e um local de aparição:
  Adicione um fragment usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragment usando o etiqueta de inserção de endereço [na stack] e a variável.
  Encontre uma rotina usando "atribua" e o type desta variável e "para" e o type desta segunda variável.
  Se a rotina for inexistente, encontre a rotina usando "converta" e o type desta variável e "para" e o type desta segunda variável.
  Se a rotina não for inexistente, adicione um terceiro fragment usando a etiqueta de demanda interna e a rotina; retorne.
  \ erro message
  Adicione uma unidade semântica para umas unidades semânticas usando "atribua/converta".
  Adicione uma segunda unidade semântica para os unidades semânticas usando o type desta variável.
  Adicione um terceiro unidade semântica para os unidades semânticas usando "para/a".
  Adicione um quarto unidade semântica para os unidades semânticas usando o type desta segunda variável.
  Converta os unidades semânticas para uma representação interna da rotina.
  Destrua os unidades semânticas.
  Apresente uma mensagem de erro contendo "Eu não sei como: " junto com a representação interna da rotina seguido de "." e o local de aparição.

Etapas para que se adicione uma rotina para umas rotinas usando um local de aparição:
  Crie a rotina.
  Posponha a rotina para as rotinas.
  Atribua o local de aparição ao local de aparição desta rotina.

Etapas para que se adicione um scratch usando um type nome e um local de aparição:
  Se a rotina utilizada atualmente for inexistente, esvazie o scratch; retorne.
  Adicione o scratch para os locals desta rotina utilizada atualmente usando "scratch" e o local de aparição.
  Gere o nome deste scratch usando "~S".
  Atribua o type nome ao type nome deste scratch.
  Resolva o scratch.

Etapas para que se adicione several fragments usando uma string e uma variável e uma segunda string e uma segunda variável e um local de aparição:
  Adicione um fragment usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragment usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para os unidades semânticas usando o type desta variável.
  Adicione um terceiro unidade semântica para os unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para os unidades semânticas usando o type desta segunda variável.
  Encontre uma rotina usando os unidades semânticas.
  Se a rotina for inexistente, converta os unidades semânticas para uma representação interna da rotina.
  Destrua os unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " junto com a representação interna da rotina seguido de "." e o local de aparição; retorne.
  Adicione um terceiro fragment usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione several fragments usando uma string e uma variável e uma segunda string e uma segunda variável e uma terceira string e um terceira variável e um ponteiro do byte :
  Adicione um fragment usando o etiqueta de inserção de endereço [na stack] e o terceira variável.
  Adicione um segundo fragment usando o etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um terceiro fragment usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para os unidades semânticas usando o type desta variável.
  Adicione um terceiro unidade semântica para os unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para os unidades semânticas usando o type desta segunda variável.
  Adicione um quinto unidade semântica para os unidades semânticas usando a terceira string.
  Adicione um sexto unidade semântica para os unidades semânticas usando o type desta terceira variável.
  Encontre uma rotina usando os unidades semânticas.
  Se a rotina for inexistente, converta os unidades semânticas para uma representação interna da rotina.
  Destrua os unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " junto com a representação interna da rotina seguido de "." e o ponteiro do byte; retorne.
  Adicione um quarto fragment usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione um source file para uns sources files usando um endereço completo:
  Crie o source file.
  Posponha o source file para o sources files.
  Atribua o endereço completo ao endereço completo deste source file.

Etapas para que se adicione two fragments usando uma string e uma variável e um local de aparição:
  Adicione um fragment usando o etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para os unidades semânticas usando o type desta variável.
  Encontre uma rotina usando os unidades semânticas.
  Se a rotina for inexistente, converta os unidades semânticas para uma representação interna da rotina.
  Destrua os unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " junto com a representação interna da rotina seguido de "." e o local de aparição; retorne.
  Adicione um segundo fragment usando a etiqueta de demanda interna e a rotina.

Etapas para que se adicione um type para uns types usando um local de aparição:
  Crie o type.
  Posponha o type para o types.
  Atribua o local de aparição ao local de aparição deste type.

Etapas para que se adicione um type para uns types usando um nome e um plural nome e um base nome:
  Adicione o type para os types usando o nome e o plural nome e o base nome e nil.

Etapas para que se adicione um type para uns types usando um nome e um plural nome e um base nome e um local de aparição:
  Crie o type.
  Posponha o type para o types.
  Atribua o local de aparição ao local de aparição deste type.
  Atribua o nome ao nome deste type.
  Atribua o plural nome ao plural nome deste type.
  Atribua o base nome ao base nome deste type.

Etapas para que se adicione uma variável para uns variáveis usando um categoria e um local de aparição:
  Crie a variável usando a categoria.
  Posponha a variável para as variáveis.
  Atribua o local de aparição ao local de aparição desta variável.

  

Etapas para que se enderece uns entries:
  Obtenha um entry desde o entries.
  Se a entry for inexistente, retorne.
  Enderece o entry.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece um entry:
  Atribua o endereço do nome usado atualmente ao nome endereço desta entry.
  Atribua a quantidade de caracteres deste nome deste entry mais 3 para um número.
  Arredonde o número para cima para o múltiplo imediato of 2.
  Adicione o número para o endereço do nome usado atualmente.
  Atribua o endereço pré-calculado atual ao previamente calculado endereço desta entry.
  Atribua o image base mais o endereço pré-calculado atual ao endereço desta entry.
  Adicione 4 para o endereço pré-calculado atual.

Etapas para que se enderece um fragment usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o fragment for inexistente, retorne.
  Atribua o image base mais o endereço ao endereço deste fragment.
  Se a etiqueta deste fragment for a etiqueta de inserção de endereço [na stack], adicione 7 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de demanda interna, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de carregamento de endereço, adicione 12 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de acréscimo, adicione 10 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de revogação, adicione 14 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de desvio falso, adicione 9 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de negação lógica, adicione 3 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de retorno, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de repetição, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de interrupção, adicione 5 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta preliminar, enderece o fragment usando o endereço (etapa preliminar); retorne.
  Se a etiqueta deste fragment for a epilog etiqueta, enderece o fragment usando o endereço (epilog); retorne.
  Se a etiqueta deste fragment for a etiqueta de decodificação, adicione a quantidade de caracteres deste código deste fragment para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de inserção de valor [na stack], enderece o fragment usando o endereço (push value); retorne.
  Se a etiqueta deste fragment for a etiqueta de demanda externa, adicione 6 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de carregamento de registrador EAX, adicione 5 para o endereço; retorne. \ was 8 when "load eax" took em variáveis; now "load eax" only does um immediate value
  Se a etiqueta deste fragment for a etiqueta de obtenção do registrador EAX, enderece o fragment usando o endereço (registrador EAX); retorne.
  Se a etiqueta deste fragment for a etiqueta de demanda indireta, adicione 8 para o endereço; retorne.
  Se a etiqueta deste fragment for a etiqueta de endereço de rotina, adicione 12 para o endereço; retorne.

Etapas para que se enderece um fragment usando um endereço (epilog):
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.
  Adicione 6 para o endereço.

Etapas para que se enderece um fragment usando um endereço (etapa preliminar):
  Adicione 3 para o endereço.
  Se o local size desta rotina utilizada atualmente não for 0, adicione 10 para o endereço.
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.

Etapas para que se enderece um fragment usando um endereço (push value):
  Adicione 6 para o endereço.
  Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - endereço um fragment usando um endereço (push value)"; retorne.
  Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - endereço um fragment usando um endereço (push value)"; retorne.
  Atribua a quantidade de caracteres deste type desta variável deste fragment para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, adicione 2 para o endereço; retorne.
  Se a quantidade de caracteres for 2, adicione 3 para o endereço; retorne.
  Se a quantidade de caracteres for 1, adicione 4 para o endereço; retorne.
  Apresente a mensagem de erro contendo "Erro interno 3 - endereço um fragment usando um endereço (push value)".

Etapas para que se enderece um fragment usando um endereço (registrador EAX):
  Adicione 6 para o endereço.
  Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - endereço um fragment usando um endereço (push value)"; retorne.
  Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - endereço um fragment usando um endereço (push value)"; retorne.
  Atribua a quantidade de caracteres deste type desta variável deste fragment para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, adicione 2 para o endereço; retorne.
  Se a quantidade de caracteres for 2, adicione 3 para o endereço; retorne.
  Se a quantidade de caracteres for 1, adicione 2 para o endereço; retorne.
  Apresente a mensagem de erro contendo "Erro interno 3 - endereço um fragment usando um endereço (push value)".

Etapas para que se enderece uns fragments usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um fragment desde o fragments.
  Se o fragment for inexistente, retorne.
  Enderece o fragment usando o endereço.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece um import:
  Atribua o endereço do nome usado atualmente ao nome endereço deste import.
  Atribua o endereço do cabeçalho usado atualmente ao header endereço deste import.
  Atribua o endereço do nome usado atualmente ao nome memory endereço deste import header deste import.
  Atribua a quantidade de caracteres deste nome deste import mais 1 para um número.
  Arredonde o número para cima para o múltiplo imediato of 2.
  Adicione o número para o endereço do nome usado atualmente.
  Adicione a magnitude desse import header para o endereço do cabeçalho usado atualmente. \ tenho que traduzir com calma isso depois
  Atribua o endereço pré-calculado atual ao first previamente calculado memory endereço deste import header deste import.
  Enderece as entries deste import.
  Adicione 4 para o endereço pré-calculado atual.

Etapas para que se enderece uns imports usando um endereço:
  Atribua o endereço ao endereço do cabeçalho usado atualmente.
  Atribua as contagem destes imports para uma contagem.
  Adicione 1 para a contagem.
  Multiplique a contagem pela magnitude desse import header.
  Atribua o endereço mais a contagem ao endereço pré-calculado atual.
  Obtenha uma segunda contagem usando o imports (all entries mais markers).
  Multiplique a segunda contagem por 4.
  Atribua o endereço pré-calculado atual mais a segunda contagem ao endereço do nome usado atualmente.
  Comece. [a executar o código abaixo]
    Obtenha um import desde o imports.
    Se o import for inexistente, pare.
    Enderece o import.
  Recomece. [percorra novamente o código acima]
  Atribua o endereço do nome usado atualmente menos o endereço para um número.
  Adicione o número para o endereço.

Um endereço é um número.

Etapas para que se enderece uma rotina usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina for inexistente, retorne.
  Se o employs representação interna da rotina desta rotina não estiver em branco, retorne. \ employs são addressed later
  Se o compiled detector desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Atribua o image base mais o endereço ao endereço desta rotina.
  Enderece os fragments desta rotina usando o endereço.
  Arredonde o endereço para cima para o múltiplo imediato of 4.

Etapas para que se enderece umas rotinas usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, pare.
  Enderece a rotina usando o endereço.
  Recomece. [percorra novamente o código acima]

Etapas para que se enderece uma variável usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável for inexistente, retorne.
  Se o compiled detector desta variável não estiver ativo, retorne.
  Atribua o image base mais o endereço ao endereço desta variável.
  Adicione a quantidade de caracteres deste type desta variável para o endereço.
  Se o type desta variável puder ser reduzido para "string", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Se o type desta variável puder ser reduzido para "texto", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
  Arredonde o endereço para cima para o múltiplo imediato of 4.

Etapas para que se enderece uns variáveis usando um endereço:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Enderece a variável usando o endereço.
  Recomece. [percorra novamente o código acima]

  

Etapas para que se advance um trecho:
  Posponha o retorno de carro para o trecho.
  Posponha a quebra de linha para o trecho.

Etapas para que se advance um trecho (twice):
  Advance o trecho.
  Advance o trecho.

Etapas para que se posponha um entry para um trecho (com separador):
  Se a entry for inexistente, posponha "(entrada não inicializada)" para o trecho (com separador); retorne.
  Posponha o nome desta entry para o trecho (com separador).

Etapas para que se posponha um detector para um trecho (com separador):
  Converta o detector para uma string.
  Posponha a string para o trecho (com separador).

Etapas para que se posponha o global finalizers para uma string:
  Obtenha um global desde o globals.
  Se o global for inexistente, retorne.
  Se o compiled detector deste global não estiver ativo, recomece.
  Se o type deste global não deveria ser finalizado, recomece.
  Posponha "~finalize o " junto com o nome deste global seguido de ". " para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha os global initializers para uma string:
  Obtenha um global desde o globals.
  Se o global for inexistente, retorne.
  Se o literal deste global for inexistente, recomece.
  Se o compiled detector deste global não estiver ativo, recomece.
  Desative um detector.
  Posponha o initializer string deste global para a string.
  Recomece. [percorra novamente o código acima]

Etapas para que se posponha uma unidade semântica para uma representação interna da rotina :
  Se o unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, posponha o caractere de espaço para a representação interna da rotina.
  Se o type deste unidade semântica não for inexistente, posponha "[" e o nome deste type deste unidade semântica e "]" para a representação interna da rotina (fast); retorne.
  Se a string deste unidade semântica não estiver em branco, posponha a string deste unidade semântica para a representação interna da rotina ; retorne.

Etapas para que se posponha uma unidade semântica para uma representação interna da rotina (while bubbling):
  Se o unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco, posponha o caractere de espaço para a representação interna da rotina.
  Se o subtexto atual deste unidade semântica não estiver em branco, posponha o subtexto atual deste unidade semântica para a representação interna da rotina ; retorne.
  Se o type atual deste unidade semântica não for inexistente, posponha "[" e o nome deste type atual deste unidade semântica e "]" para a representação interna da rotina (fast); retorne.

Etapas para que se posponha um número para um trecho (as hex com separador):
  Converta o número para uma cifra hexadecimal.
  Posponha a cifra hexadecimal para o trecho (com separador).

Etapas para que se posponha um número para um trecho (com separador):
  Converta o número para uma string.
  Posponha a string para o trecho (com separador).

Etapas para que se posponha uma proporção para um trecho (com separador):
  Converta a proporção para uma string.
  \ Se a string for "0", posponha "---" para o trecho; retorne.
  Posponha a string para o trecho (com separador).

Etapas para que se posponha uma rotina para um trecho (com separador):
  Se a rotina for inexistente, posponha "(rotina inexistente)" para o trecho (com separador); retorne.
  Posponha a representação interna da rotina deste rotina para o trecho (com separador).

\ Etapas para que se posponha 3 strings distintas para uma string.
Etapas para que se posponha uma string e uma segunda string e uma terceira string para uma quarta string (fast):
  Atribua a quantidade de caracteres desta quarta string para uma quantidade de caracteres. \ Atribua a quantidade de caracteres da 4ª string para uma quantidade de caracteres. 
  Adicione a quantidade de caracteres desta string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 1ª string para a quantidade de caracteres. 
  Adicione a quantidade de caracteres desta segunda string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 2ª string para a quantidade de caracteres. 
  Adicione a quantidade de caracteres desta terceira string para a quantidade de caracteres. \ Atribua a quantidade de caracteres da 3ª string para a quantidade de caracteres. 
  Reassocie um ponteiro usando a quantidade de caracteres.
  Atribua o ponteiro para um ponteiro do byte .
  Copie bytes desde o caractere inicial desta quarta string para o ponteiro do byte pelo quantidade de caracteres desta quarta string.
  Adicione a quantidade de caracteres desta quarta string para o ponteiro do byte .
  Copie bytes desde o caractere inicial desta string para o ponteiro do byte pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o ponteiro do byte .
  Copie bytes desde o caractere inicial desta segunda string para o ponteiro do byte pelo quantidade de caracteres desta segunda string.
  Adicione a quantidade de caracteres desta segunda string para o ponteiro do byte .
  Copie bytes desde o caractere inicial desta terceira string para o ponteiro do byte pelo quantidade de caracteres desta terceira string.
  Desassocie o caractere inicial desta quarta string.
  Atribua o ponteiro ao caractere inicial desta quarta string.
  Atribua o ponteiro mais a quantidade de caracteres menos 1 ao caractere final desta quarta string.

Etapas para que se posponha uma string para um trecho (com separador):
  Posponha a string para o trecho.
  Posponha " | " para o trecho.

Etapas para que se posponha uma etiqueta para um trecho (as um fragment etiqueta string com separador):
  Se a etiqueta for a etiqueta de interrupção, posponha "Interrupção do Laço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda externa, posponha "Demanda Externa" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda indireta, posponha "Demanda Indireta" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de demanda interna, posponha "Demanda Interna" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de revogação, posponha "Dereferência" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta delimitadora de bloco condicional, posponha "Fim de bloco condicional" para o trecho (com separador); retorne.
  Se a etiqueta for a epilog etiqueta, posponha "Epílogo" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de retorno, posponha "Retorno de Rotina" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de finalização, posponha "finalize" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de acréscimo, posponha "Incremento" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de decodificação, posponha "Decodifique" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de desvio falso, posponha "Desvio de condição insatisfeita" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de carregamento de endereço, posponha "Carregamento de endereço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de carregamento de registrador EAX, posponha "Carregamento do Registrador EAX" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de laço, posponha "Loop" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de negação lógica, posponha "Negação Lógica" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta preliminar, posponha "Prólogo" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de inserção de endereço [na stack], posponha "Empilhamento de endereço" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de inserção de valor [na stack], posponha "Empilhamento de valor" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de obtenção do registrador EAX, posponha "Requisição EAX" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de repetição, posponha "Repetição" para o trecho (com separador); retorne.
  Se a etiqueta for a etiqueta de endereço de rotina, posponha "Endereço de Rotina" para o trecho (com separador); retorne.
  Posponha "?" para o trecho (com separador).

Etapas para que se posponha um type para um trecho (com separador):
  Se o type for inexistente, posponha "(tipo não inicializado)" para o trecho (com separador); retorne.
  Posponha o nome deste type para o trecho (com separador).

Etapas para que se posponha uma variável para um trecho (com separador):
  Se a variável for inexistente, posponha "(variável não inicializada)" para o trecho (com separador); retorne.
  Posponha o nome desta variável para o trecho (com separador).

Etapas para que se determine se uma string é algum tipo de contração de preposição com artigo definido:
  Se a string for "do", diga sim.
  Se a string for "da", diga sim.
  Se a string for "dos", diga sim.
  Se a string for "das", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de operador de concatenação contraído usando um percorredor:
  Se o segmento inicial deste percorredor de contrações for "seguido", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "seguida", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "junto", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor de contrações for "acompanhado", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for uma variável, recue o percorredor.
  Se o segmento inicial deste percorredor de contrações for algum tipo de contração de preposição com artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string está precisando ser decomposta:
  Lance um percorredor sobre a string.
  Se a string for algum tipo de operador de concatenação contraído usando o percorredor, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se posponha uma string para uma segunda string usando uma terceira string (para expandir contrações):
  \# contrações
  Se a string for "ao", posponha "a o" para a segunda string; retorne.
  Se a string for "à", posponha "a a" para a segunda string; retorne.
  Se a string for "aos", posponha "a os" para a segunda string; retorne.
  Se a string for "às", posponha "a as" para a segunda string; retorne.
  \Se a string estiver precisando ser decomposta, posponha "de o" para a segunda string; retorne.
  \Se a string for "dos", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, posponha "de os" para a segunda string; exit
  \Se a string for "da", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, posponha "de a" para a segunda string; exit
  \Se a string for "das", determine se a string precisa ser decomposta.
  \Se a string precisa ser decomposta, posponha "de as" para a segunda string; exit
  \Se a string for "do", posponha "de o" para a segunda string; retorne.
  \Se a string for "da", posponha "de a" para a segunda string; retorne.
  \Se a string for "dos", posponha "de os" para a segunda string; retorne.
  \Se a string for "das", posponha "de as" para a segunda string; retorne.
  \Se a string for "dum", posponha "de um" para a segunda string; retorne.
  \Se a string for "duma", posponha "de uma" para a segunda string; retorne.
  \Se a string for "dumas", posponha "de umas" para a segunda string; retorne.
  \Se a string for "duns", posponha "de uns" para a segunda string; retorne.
  Se a string for "daqui", posponha "de aqui" para a segunda string; retorne.
  Se a string for "dali", posponha "de ali" para a segunda string; retorne.
  Se a string for "dele", posponha "de ele" para a segunda string; retorne.
  Se a string for "dela", posponha "de ela" para a segunda string; retorne.
  Se a string for "desse", posponha "de esse" para a segunda string; retorne.
  Se a string for "dessa", posponha "de essa" para a segunda string; retorne.
  Se a string for "desses", posponha "de esses" para a segunda string; retorne.
  Se a string for "dessas", posponha "de essas" para a segunda string; retorne.
  Se a string for "deste", posponha "de este" para a segunda string; retorne.
  Se a string for "desta", posponha "de esta" para a segunda string; retorne.
  Se a string for "destes", posponha "de estes" para a segunda string; retorne.
  Se a string for "destas", posponha "de estas" para a segunda string; retorne.
  Se a string for "disso", posponha "de isso" para a segunda string; retorne.
  Se a string for "disto", posponha "de isto" para a segunda string; retorne.
  Se a string for "nesse", posponha "em esse" para a segunda string; retorne.
  Se a string for "nesses", posponha "em esses" para a segunda string; retorne.
  Se a string for "neste", posponha "em este" para a segunda string; retorne.
  Se a string for "nestes", posponha "em estes" para a segunda string; retorne.
  Se a string for "nisso", posponha "em isso" para a segunda string; retorne.
  Se a string for "nisto", posponha "em isto" para a segunda string; retorne.
  Se a string for "nessa", posponha "em essa" para a segunda string; retorne.
  Se a string for "nessas", posponha "em essas" para a segunda string; retorne.
  Se a string for "nesta", posponha "em esta" para a segunda string; retorne.
  Se a string for "nestas", posponha "em estas" para a segunda string; retorne.
  \Se a string for "donde", posponha "de onde" para a segunda string; retorne.
  \Se a string for "dentre", posponha "de entre" para a segunda string; retorne.
  \Se a string for "dantes", posponha "de antes" para a segunda string; retorne.
  Se a string for "dalguém", posponha "de alguém" para a segunda string; retorne.
  Se a string for "dalgum", posponha "de um" para a segunda string; retorne.
  Se a string for "dalguma", posponha "de uma" para a segunda string; retorne.
  Se a string for "dalguns", posponha "de uns" para a segunda string; retorne.
  Se a string for "dalgumas", posponha "de umas" para a segunda string; retorne.
  Se a string for "nalgum", posponha "em um" para a segunda string; retorne.
  Se a string for "nalguma", posponha "em uma" para a segunda string; retorne.
  Se a string for "nalguns", posponha "em uns" para a segunda string; retorne.
  Se a string for "nalgumas", posponha "em umas" para a segunda string; retorne.
  Se a string for "doutro", posponha "de outro" para a segunda string; retorne.
  Se a string for "doutra", posponha "de outra" para a segunda string; retorne.
  Se a string for "doutros", posponha "de outros" para a segunda string; retorne.
  Se a string for "doutras", posponha "de outras" para a segunda string; retorne.
  Se a string for "noutro", posponha "em outro" para a segunda string; retorne.
  Se a string for "noutra", posponha "em outra" para a segunda string; retorne.
  Se a string for "noutros", posponha "em outros" para a segunda string; retorne.
  Se a string for "noutras", posponha "em outras" para a segunda string; retorne.
  \# "no" pode ser uma negação em inglês.
  Se a string for alguma espécie de contração usando a terceira string (strings em português - "no"), posponha "em o" para a segunda string; retorne.
  Se a string for "na", posponha "em a" para a segunda string; retorne.
  Se a string for "nos", posponha "em os" para a segunda string; retorne.
  Se a string for "nas", posponha "em as" para a segunda string; retorne.
  \Se a string for "noutro", posponha "em outro" para a segunda string; retorne.
  \Se a string for "noutra", posponha "em outra" para a segunda string; retorne.
  \Se a string for "noutros", posponha "em outros" para a segunda string; retorne.
  \Se a string for "noutras", posponha "em outras" para a segunda string; retorne.
  Se a string for "num", posponha "em um" para a segunda string; retorne.
  Se a string for "numa", posponha "em uma" para a segunda string; retorne.
  Se a string for "nuns", posponha "em uns" para a segunda string; retorne.
  Se a string for "numas", posponha "em umas" para a segunda string; retorne.
  Se a string for "pelo", posponha "por o" para a segunda string; retorne.
  Se a string for "pela", posponha "por a" para a segunda string; retorne.
  Se a string for "pelos", posponha "por os" para a segunda string; retorne.
  Se a string for "pelas", posponha "por as" para a segunda string; retorne.
  Posponha a string para a segunda string.

Etapas para que se acrescente endereço loading código para um texto hexadecimal usando uma variável:
  \ loads para edx
  Se a variável for inexistente, acrescente $C7C200000000 para o texto hexadecimal; retorne. \ mov edx,0
  Se a categoria desta variável for "global", acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; retorne. \ mov edx,the endereço da variável
  Se a categoria desta variável for "literal", acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; retorne. \ mov edx,the endereço da variável
  Se a categoria desta variável for "local", acrescente $8D95 e o offset desta variável para o texto hexadecimal; retorne. \ lea edx,[ebp+ the offset da variável]
  Se a categoria desta variável for "scratch", acrescente $8B95 e o offset desta variável para o texto hexadecimal; retorne. \ mov edx, [ebp+ the offset da variável]
  Se a categoria desta variável não for "parâmetro", apresente uma mensagem de erro contendo "Erro interno - acrescente endereço loading código para um texto hexadecimal usando uma variável"; retorne.
  Se o by-value detector desta variável estiver ativo, acrescente $8D95 e o offset desta variável para o texto hexadecimal; retorne. \ lea edx,[ebp+the offset da variável]
  Acrescente $8B95 e o offset desta variável para o texto hexadecimal. \ mov edx,[ebp+ the offset da variável]

Etapas para que se acrescente um texto hexadecimal e um endereço para um fragment:
  \ Processe ou jump
  Atribua o endereço para um número.
  Subtraia o endereço deste fragment desde o número.
  Subtraia a quantidade de caracteres deste código deste fragment desde o número.
  Subtraia a quantidade de caracteres deste texto hexadecimal desde o número.
  Subtraia 4 desde o número.
  Acrescente o texto hexadecimal e o número para o código deste fragment.

Etapas para que se acrescente um texto hexadecimal e um número e um segundo texto hexadecimal para um terceiro texto hexadecimal:
  Posponha o texto hexadecimal para o terceiro texto hexadecimal.
  Converta o número para um quarto texto hexadecimal.
  Posponha o quarto texto hexadecimal para o terceiro texto hexadecimal.
  Posponha o segundo texto hexadecimal para o terceiro texto hexadecimal.

Etapas para que se acrescente um texto hexadecimal e um número e um segundo número para um segundo texto hexadecimal:
  Posponha o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Posponha o terceiro texto hexadecimal para o segundo texto hexadecimal.
  Converta o segundo número para um quarto texto hexadecimal.
  Posponha o quarto texto hexadecimal para o segundo texto hexadecimal.

Etapas para que se acrescente um texto hexadecimal e um detector para um segundo texto hexadecimal;
Etapas para que se acrescente um texto hexadecimal e um número para um segundo texto hexadecimal:
  Posponha o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Posponha o terceiro texto hexadecimal para o segundo texto hexadecimal.

Etapas para que se acrescente um texto hexadecimal para um segundo texto hexadecimal:
  Employ posponha uma string para uma segunda string.

Etapas para que se disponibilize bytes usando um ponteiro e uma quantidade de caracteres e um trecho e um offset:
  Atribua o caractere inicial deste trecho mais o offset para um segundo ponteiro.
  Copie bytes desde o ponteiro para o segundo ponteiro pelo quantidade de caracteres.

Etapas para que se disponibilize um DOS header para um trecho:
  Disponibilize bytes usando o endereçamento deste DOS header e o magnitude deste DOS header e o trecho e 0.

Etapas para que se disponibilize umas entries para um trecho:
  Obtenha um entry desde o entries.
  Se a entry for inexistente, retorne.
  Disponibilize a entry ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize um entry para um trecho:
  Disponibilize bytes usando o endereçamento deste nome endereço desta entry e 4 e o trecho e o previamente calculado endereço desta entry.
  Atribua o nome endereço desta entry mais 2 para um endereço.
  Disponibilize o nome desta entry ao trecho sob o endereço.

Etapas para que se disponibilize um fragment para um trecho:
  Se o código deste fragment estiver em branco, retorne.
  Atribua o endereço deste fragment menos o image base para um endereço.
  Disponibilize o código deste fragment ao trecho sob o endereço.

Etapas para que se disponibilize uns fragments para um trecho:
  Obtenha um fragment desde o fragments.
  Se o fragment for inexistente, retorne.
  Disponibilize o fragment ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize um import para um trecho:
  Disponibilize bytes usando o endereçamento deste import header deste import e o magnitude deste import header deste import e o trecho e o header endereço deste import.
  Disponibilize o nome deste import ao trecho sob o nome endereço deste import.
  Disponibilize as entries deste import ao trecho.

Etapas para que se disponibilize uns imports para um trecho:
  Obtenha um import desde o imports.
  Se o import for inexistente, retorne.
  Disponibilize o import ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize um PE header para um trecho:
  Disponibilize bytes usando o endereçamento deste PE header e o magnitude deste PE header e o trecho e 256.

Etapas para que se disponibilize uma rotina para um trecho:
  Se o compiled detector desta rotina não estiver ativo, retorne.
  Disponibilize os fragments desta rotina ao trecho.

Etapas para que se disponibilize umas rotinas para um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Disponibilize a rotina ao trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se disponibilize uma string para um trecho sob um endereço:
  Disponibilize bytes usando o caractere inicial desta string e a quantidade de caracteres desta string e o trecho e o endereço.

Etapas para que se disponibilize uma variável para um trecho:
  Se o compiled detector desta variável não estiver ativo, retorne.
  Se o type desta variável puder ser reduzido para "string", disponibilize a variável ao trecho (como um texto); retorne.
  Se o type desta variável puder ser reduzido para "texto", disponibilize a variável ao trecho (como um texto); retorne.
  Atribua o endereço desta variável menos o image base para um endereço. \ Atribua a diferença entre o endreço da variável e a base da imagem em um endereço.
  Disponibilize o data desta variável ao trecho sob o endereço.

Etapas para que se disponibilize uma variável para um trecho (como um texto):
  Atribua o endereço desta variável menos o image base para um endereço.
  Atribua a quantidade de caracteres deste data desta variável para uma quantidade de caracteres.
  Atribua o endereço para um segundo endereço.
  Adicione a magnitude desse prototype string para o segundo endereço.
  Adicione o image base para o segundo endereço.
  Atribua 0 ao caractere inicial desta prototype string.
  Atribua -1 ao caractere final desta prototype string.
  Se a quantidade de caracteres não for 0, atribua o segundo endereço ao caractere inicial desta prototype string.
  Se a quantidade de caracteres não for 0, atribua o caractere inicial desta prototype string mais a quantidade de caracteres menos 1 ao caractere final desta prototype string.
  Disponibilize bytes usando o endereçamento desta prototype string e a magnitude desta prototype string e o trecho e o endereço.
  Adicione a magnitude [tamanho em bytes] desta prototype string para o endereço.
  Disponibilize os data desta variável ao trecho sob o endereço.

Etapas para que se disponibilize uns variáveis para um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Disponibilize a variável ao trecho.
  Recomece. [percorra novamente o código acima]

Um endereço base é um endereço.

Uma zona é um estrutura com 
  Um endereço base, 
  Uma quantidade de caracteres e 
  Um size.

Etapas para que se bubble uma unidade semântica:
  Se o unidade semântica for inexistente, retorne.
  Se o subtexto atual deste unidade semântica não estiver em branco, limpe o subtexto atual deste unidade semântica; retorne.
  Se o type atual deste unidade semântica for inexistente, retorne.
  Se o type atual deste unidade semântica for algum tipo pré-definido, atribua nil ao type atual deste unidade semântica; retorne.
  Atribua o base type deste type atual deste unidade semântica ao type atual deste unidade semântica.

Um built-in type é um type.

Etapas para que se calculate a quantidade de caracteres of um type:
  Se o type for inexistente, retorne.
  Se a quantidade de caracteres deste type não for -1, retorne.
  Calculate a quantidade de caracteres of o base type deste type.
  Se os campos deste type estiverem vazios, atribua a quantidade de caracteres deste base type deste type ao quantidade de caracteres deste type; retorne.
  Atribua 0 ao quantidade de caracteres deste type.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde o campos deste type.
    Se o campo for inexistente, retorne.
    Se o redefinition conteúdo nome deste campo não estiver em branco, recomece.
    Calculate a quantidade de caracteres of o type deste campo.
    Adicione a quantidade de caracteres deste type deste campo times a contagem deste campo para a quantidade de caracteres deste type.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate o lengths of uns types:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Calculate a quantidade de caracteres of o type.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate o offsets em um type:
  Se o type for inexistente, retorne.
  Atribua 0 para um offset.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde os campos deste type.
    Se o campo for inexistente, retorne.
    Se o redefinition conteúdo nome deste campo não estiver em branco, recomece.
    Atribua o offset ao offset deste campo.
    Adicione a quantidade de caracteres deste type deste campo times a contagem deste campo para o offset.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate os offsets em uns types:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Calculate o offsets no type.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate o redefinition offsets em um type:
  Se o type for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde os campos deste type.
    Se o campo for inexistente, retorne.
    Se o redefinition conteúdo nome deste campo estiver em branco, recomece.
    Encontre um segundo campo usando o redefinition conteúdo nome deste campo e os campos deste type.
    Se o segundo campo for inexistente, apresente uma mensagem de erro contendo "Redefine inválido. Eu não consigo encontrar o campo: " junto com o redefinition conteúdo nome deste campo seguido de "' campo." e o local de aparição deste campo; retorne.
    Atribua o offset deste segundo campo ao offset deste campo.
  Recomece. [percorra novamente o código acima]

Etapas para que se calculate o redefinition offsets em uns types:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Calculate o redefinition offsets no type.
  Recomece. [percorra novamente o código acima]

Etapas para que se verifique por informações opcionais inválidas em um type:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type for inexistente, retorne.
  Se o conteúdo nome deste type não estiver em branco, verifique por informações opcionais inválidas em o type (conteúdo).
  Se o campos deste type não estiverem vazios, verifique por informações opcionais inválidas em o type (campos).
  Se a razão de escala deste type não for 0, verifique por informações opcionais inválidas em o type (scale).

Etapas para que se verifique por informações opcionais inválidas em um type (campos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type não puder ser reduzido para "estrutura", apresente uma mensagem de erro contendo "Erro. A palavra-chave 'com' só é permitida em estruturas." e o local de aparição deste type; retorne. \\mudar aqui

Etapas para que se verifique por informações opcionais inválidas em um type (scale):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type não puder ser reduzido para "número", apresente uma mensagem de erro contendo "Escalas são permitidas apenas em tipos numéricos." e o local de aparição deste type; retorne.

Etapas para que se verifique por informações opcionais inválidas em um type (conteúdo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type não puder ser reduzido para "ponteiro", apresente uma mensagem de erro contendo "A palavra 'para' só é permitida em ponteiro." e o local de aparição deste type; retorne.

Etapas para que se limpe um campo termo:
  Preencha bytes com o caractere null começando sob o endereçamento deste campo termo pelo magnitude deste campo termo.

Etapas para que se limpe um termo:
  Esvazie a variável deste termo.
  Limpe o phrase deste termo.

Etapas para que se compile o bodies of as rotinas:
  Compile o body of a rotina denominada "initialize before run".
  Compile o body of a rotina denominada "execute o programa".
  Compile o body of a rotina denominada "finalize after run".

Etapas para que se compile o body of uma rotina:
  Se a rotina for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o compiled detector desta rotina estiver ativo, retorne.
  Ligue o compiled detector desta rotina.
  Lance um percorredor sobre as instruções desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for o ponto&vírgula, compile o body of a rotina usando o percorredor (sobrecarga de métodos); retorne. \ *** alternate palavraing
  Se o segmento inicial deste percorredor for algum tipo de reutilização de rotina, compile o body of a rotina usando o percorredor (employ); retorne.
  Atribua a rotina utilizada atualmente para um saved rotina.
  Atribua a rotina à rotina utilizada atualmente.
  Crie o nickname catálogo desta rotina usando 101.
  Eliminate duplicate nicknames desde os parâmetros desta rotina usando o nickname catálogo desta rotina.
  Compile o body of a rotina (etapa preliminar).
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Compile a próxima instrução usando o percorredor.
  Recomece. [percorra novamente o código acima]
  Compile o body of a rotina (epilog).
  Atribua o saved rotina à rotina utilizada atualmente.

Etapas para que se compile o body of uma rotina (epilog):
  Se a rotina for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um fragment usando a etiqueta de finalização.
  Comece. [a executar o código abaixo]
    Obtenha uma variável desde os locals desta rotina.
    Se a variável for inexistente, pare.
    Se a categoria desta variável for "scratch", recomece.
    Se o type desta variável não deveria ser finalizado, recomece.
    Adicione um segundo fragment usando o etiqueta de inserção de endereço [na stack] e a variável.
    Encontre uma segunda rotina usando "~finalize" e o type desta variável.
    Se a segunda rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno - compile o body of uma rotina (epilog)"; retorne.
    Adicione um terceiro fragment usando a etiqueta de demanda interna e a segunda rotina.
  Recomece. [percorra novamente o código acima]
  Adicione um quarto fragment usando o epilog etiqueta.

Etapas para que se compile o body of uma rotina (etapa preliminar):
  Se a rotina for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um fragment usando o etiqueta preliminar.
  Adicione um segundo fragment usando o etiqueta de laço.

Etapas para que se compile o body of a rotina denominada uma string;
Etapas para que se compile o body of a rotina denominado uma string:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Encontre uma rotina usando a string e o catálogo geral de rotinas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Não consegui encontrar a rotina ''Etapas para que se " junto com a string seguido de ":''."; retorne.
  Compile o body of a rotina.

Etapas para que se compile o body of uma rotina usando um percorredor (sobrecarga de métodos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ *** do we need this?
  Atribua o next desta rotina para um conteúdo rotina.
  Se o conteúdo rotina for inexistente, apresente uma mensagem de erro contendo "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e o percorredor; retorne.
  Atribua a representação interna da rotina deste conteúdo rotina ao employs representação interna da rotina desta rotina.
  Compile o body of o conteúdo rotina.

Etapas para que se compile o body of uma rotina usando um percorredor (employ):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma rotina reference usando o percorredor.
  Converta a rotina reference para o employs representação interna da rotina desta rotina.
  Destrua a rotina reference.
  Se o segmento inicial deste percorredor não for ".", apresente uma mensagem de erro contendo "Employ statments devem terminar com um ponto, não com: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Somente um employ" e o percorredor; retorne.
  Encontre uma segunda rotina usando o employs representação interna da rotina desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente, apresente a mensagem de erro contendo "Não consigo encontrar um rotina: " junto com o employs representação interna da rotina desta rotina seguido de "' que você está tentando empregar." e o local de aparição desta rotina; retorne.
  Compile o body of a segunda rotina.

Etapas para que se compile o Processe'd part usando um percorredor e uma variável:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável for inexistente, retorne.
  Atribua o nome desta variável ao type nome desta variável.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável usando o percorredor.

Etapas para que se compile um endereço da pasta:
  Compile o endereço da pasta (inicialização).
  Compile o endereço da pasta (arquivos de código fonte).
  Compile o endereço da pasta (análise dos arquivos fornecidos).
  Compile o endereço da pasta (identificação dos tipos das variáveis).
  Compile o endereço da pasta (identificação de variáveis globais).
  Compile o endereço da pasta (cabeçalhos de rotinas).
  Compile o endereço da pasta (cálculo de tamanhos e deslocamentos).
  Compile o endereço da pasta (Adicione o built-in memory rotinas).
  Compile o endereço da pasta (catalogue as rotinas por utility use).
  Compile o endereço da pasta (conteúdo das rotinas).
  Compile o endereço da pasta (Adicione e compile o built-in startup rotina).
  Compile o endereço da pasta (deslocamento de parâmetros e variáveis).
  Compile o endereço da pasta (address).
  Compile o endereço da pasta (transmutação).
  Compile o endereço da pasta (link).
  Compile o endereço da pasta (etapa final).
  Compile o endereço da pasta (interrupção).

Etapas para que se compile um endereço da pasta (Adicione e compile o built-in startup rotina):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Adicionando e agrupando as tarefas padrão de inicialização..".
  Start o temporizador de adição de rotinas pré-definidas de inicialização.
  Adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução.
  Suspenda o temporizador de adição de rotinas pré-definidas de inicialização.

Etapas para que se compile um endereço da pasta (Adicione o built-in memory rotinas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Adicionando como tarefas predefinidas na memória...".
  Start o temporizador de adição de rotinas pré-definidas de mémoria .
  Adicione as rotinas de alocação e desalocação e finalização e destruição.
  Suspenda o temporizador de adição de rotinas pré-definidas de mémoria .

A zona de código é um zona.

Etapas para que se compile um endereço da pasta (address):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Obtendo endereço dos itens...".
  Start o temporizador de endereçamento.
  Atribua 4096 para um endereço.
  Atribua o endereço à endereço base desta import zona.
  Enderece o imports usando o endereço.
  Atribua o endereço menos a endereço base desta import zona ao quantidade de caracteres desta import zona.
  Arredonde o endereço para cima para o múltiplo imediato of 4096.
  Atribua o endereço à endereço base desta zona de dados.
  Enderece os globals usando o endereço.
  Enderece os literals usando o endereço.
  Atribua o endereço menos a endereço base desta zona de dados ao quantidade de caracteres desta zona de dados.
  Arredonde o endereço para cima para o múltiplo imediato of 4096.
  Atribua o endereço à endereço base desta zona de código. \ Uma zona é uma estrutura que contém um endereço base, uma quantidade de caracteres e um tamanho.
  Enderece as rotinas usando o endereço.
  Atribua o endereço menos a endereço base desta zona de código ao quantidade de caracteres desta zona de código.
  Suspenda o temporizador de endereçamento.

Etapas para que se compile um endereço da pasta (cálculo de tamanhos e deslocamentos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Calculando tamanhos e deslocamentos...".
  Start o temporizador de etapas de cálculo.
  Calculate o lengths of o types.
  Calculate o offsets no types.
  Calculate o redefinition offsets no types.
  Suspenda o temporizador de etapas de cálculo.

Etapas para que se compile um endereço da pasta (conteúdo das rotinas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Agrupando o conteúdo das tarefas...".
  Start o temporizador de compilação do conteúdo das rotinas.
  Compile o bodies of as rotinas.
  Suspenda o temporizador de compilação do conteúdo das rotinas.

Etapas para que se compile um endereço da pasta (cabeçalhos de rotinas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Agrupando os nomes das tarefas...".
  Start o temporizador de compilação de cabeçalhos de rotina.
  Compile o headers of as rotinas.
  Suspenda o temporizador de compilação de cabeçalhos de rotina.

Etapas para que se compile um endereço da pasta (catalogue as rotinas por utility use):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Catalogando tarefas...".
  Start o temporizador de ferramentas de catalogação.
  Catalogue as rotinas por utility use.
  Scrub o catálogo de rotinas úteis.
  Organize o catálogo de rotinas úteis.
  Suspenda o temporizador de ferramentas de catalogação.

Etapas para que se compile um endereço da pasta (link):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Elencando arquivos..".
  Start o temporizador de vinculação.
  Link.
  Suspenda o temporizador de vinculação.

Etapas para que se compile um endereço da pasta (deslocamento de parâmetros e variáveis):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Deslocando parâmetros e variáveis...".
  Start o temporizador de deslocamentos.
  Offset o parâmetros na rotinas.
  Offset o locals na rotinas.
  Suspenda o temporizador de deslocamentos.

Etapas para que se compile um endereço da pasta (arquivos de código fonte):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Carregando arquivos...".
  Start o temporizador de operacionalização.
  Carregue o sources files.
  Suspenda o temporizador de operacionalização.

Etapas para que se compile um endereço da pasta (identificação de variáveis globais):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Resolvendo itens de escopo abrangente...".
  Start o temporizador de resolução de variáveis globais.
  Resolva o globals.
  Suspenda o temporizador de resolução de variáveis globais.

Etapas para que se compile um endereço da pasta (identificação dos tipos das variáveis):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Resolvendo tipos...".
  Start o temporizador de resolução de tipos.
  Resolva os types (expand coisas).
  Resolva os types (registro de plurais).
  Resolva os types (base types).
  Resolva os types (optional info).
  Suspenda o temporizador de resolução de tipos.

Etapas para que se compile um endereço da pasta (análise dos arquivos fornecidos):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Analisando arquivos...".
  Start o temporizador de análise/verificação.
  Examine o sources files.
  Suspenda o temporizador de análise/verificação.

Etapas para que se compile um endereço da pasta (inicialização):
  Mostre no painel de informações "Iniciando...".
  Finalize o compilador.
  Start o temporizador deste compilador.
  Inicialize o compilador usando o endereço da pasta.
  Adicione o built-in types.

Etapas para que se compile um endereço da pasta (interrupção):
  Suspenda o temporizador deste compilador.
  Mostre no painel de informações "Interrompendo".

Etapas para que se compile um endereço da pasta (transmutação):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Modificando...".
  Start o temporizador de transmutação.
  Transforme em código hexadecimal as rotinas.
  Suspenda o temporizador de transmutação.

Etapas para que se compile um endereço da pasta (etapa final):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mostre no painel de informações "Gerando arquivo executável...".
  Start o temporizador de escrita.
  Escreva o exe deste compilador para o endereço exe completo deste compilador.
  Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo o erro do fluxo de entrada/saída.
  Suspenda o temporizador de escrita.

Etapas para que se compile um expression usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Compile um termo usando o percorredor.
  Atribua o termo ao expression.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor não for algum operator aritmético, retorne.
    Se o segmento inicial deste percorredor for algum operator de divisão, compile o expression usando o percorredor (operador de divisão); recomece.
    Se o segmento inicial deste percorredor for algum operator de subtração, compile o expression usando o percorredor (operador de subtração); recomece.
    Se o segmento inicial deste percorredor for algum operator de adição, compile o expression usando o percorredor (operador de adição); recomece.
    Se o segmento inicial deste percorredor for algum tipo de operador de concatenação, compile o expression usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for algum operator de multiplicação, compile o expression usando o percorredor (operador de multiplicação); recomece.
    Se o segmento inicial deste percorredor for "junto", compile o expression usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "juntamente", compile o expression usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "seguido", compile o expression usando o percorredor (operador de concatenação); recomece.
    Se o segmento inicial deste percorredor for "acompanhado", compile o expression usando o percorredor (operador de concatenação); recomece.

Etapas para que se compile um expression usando um percorredor (operador de divisão):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum objeto indireto, apresente uma mensagem de erro contendo "Você deve usar o termo 'dividido POR'." e o percorredor; retorne.
  Se a variável desta expression for inexistente, apresente a mensagem de erro contendo "Comando 'dividido por' inválido, há um erro na variável: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'dividido por', está errado. Não dá pra dividir por: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando o type nome desta expression e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "divida" e o intermediate e "por" e a variável deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile um expression usando um percorredor (operador de subtração):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'minus', está errado. Não consigo subtrair o(a): " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'minus', está errado. Não consigo diminuir do(a): " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando o type nome desta expression e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "subtraia" e a variável deste termo e "desde" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile um expression usando um percorredor (operador de adição):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'plus', está errado. Não consigo somar o: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação). \talvez fosse o caso de repetir aqui
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'plus', está errado. Não consigo somar um: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando o type nome desta expression e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.\aqui muda o atribua
  Adicione several fragments usando "adicione" e a variável deste termo e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor. \ aqui muda o add
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile um expression usando um percorredor (operador de concatenação):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for "do",  recue/atribua/posponha "de o" ao 
  Se o segmento inicial deste percorredor não for algum tipo de palavra de concatenação, apresente uma mensagem de erro contendo "Você deve usar o termo 'junto DE/junto COM/etc'." e o percorredor; retorne.
  Se a variável desta expression for inexistente, apresente a mensagem de erro contendo "O seu 'then', está errado. Eu não entendi a variável da expressão: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor. \\ aqui que deve compilar o termo
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'then', está errado. Eu não achei a variável do termo: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione um intermediate usando "texto" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragments usando a variável desta expression e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Converta o termo por concatenation usando o percorredor. \\ aqui faz a concatenação
  Adicione several fragments usando "posponha" e a variável deste termo e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile um expression usando um percorredor (operador de multiplicação):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'times', está errado. Eu não sei como multiplicar o: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'times', está errado. Eu não sei como multiplicar um: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando o type nome desta expression e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "multiplique" e o intermediate e "por" e a variável deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável desta expression.
  Limpe a phrase desta expression.

Etapas para que se compile o header of uma rotina:
  Se a rotina for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Lance um percorredor sobre a cabeçalho de rotina desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum comando de deliberação, compile o header of a rotina usando o percorredor (rotina deliberativa); retorne.
  Se o percorredor for o início of algum tipo de reverse-possessive function, compile o header of a rotina usando o percorredor (função do possessivo reverso); retorne.
  Se o percorredor for o início of algum tipo de function, compile o header of a rotina usando o percorredor (função); retorne.
  Se o segmento inicial deste percorredor for "compativelmente", compile o header of a rotina usando o percorredor (modo de compatibilidade); retorne.
  Compile o header of a rotina usando o percorredor (procedimento).

Etapas para que se compile o header of uma rotina usando um percorredor (modo de compatibilidade):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ligue o detector de compatibilidade desta rotina.
  Compile os unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta os unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Você já tinha escrito um função: " junto com a representação interna da rotina desta rotina seguido de "." e o local de aparição desta rotina; retorne.
  Catalogue a rotina usando os unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile o header of uma rotina usando um percorredor (rotina deliberativa):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional, apresente uma mensagem de erro contendo "Erro na sintaxe do comando 'Para que se determine se'" e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ligue o detector de deliberação desta rotina.
  Compile os unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Se alguns of os unidades semânticas desta rotina forem advérbios de negação, apresente a mensagem de erro contendo "Não consigo me dar bem com palavras negativos em nomes de funções decisoras." e o percorredor; retorne.
  Converta os unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Você já me contou como'" junto com a representação interna da rotina desta rotina seguido de "." e o local de aparição desta rotina; retorne.
  Catalogue a rotina usando os unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile o header of uma rotina usando um percorredor (função):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Ligue o detector de função desta rotina.
  Adicione uma unidade semântica para os unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile os unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile os unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum tipo de possessive, apresente uma mensagem de erro contendo "Tá faltando um 's por aqui (ou está no lugar errado)." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para os unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "Eu estava esperando um palavra 'para', mas encontrei a palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Adicione um terceiro unidade semântica para os unidades semânticas desta rotina usando "para".
  Converta os unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Eu já sei como: " junto com a representação interna da rotina seguido de "." e o local de aparição desta rotina; retorne. \ not translated - no possessives em Spanish
  Catalogue a rotina usando os unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Estava esperando um artigo indefinido, mas achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Compile os unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Tem comandos extras no fim dessa função." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Converta os unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando os unidades semânticas desta rotina e o catálogo geral de rotinas. \ por employs

Etapas para que se compile o header of uma rotina usando um percorredor (procedimento):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Compile os unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta os unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Você já escreveu como fazer: " junto com a representação interna da rotina desta rotina seguido de "." e o local de aparição desta rotinas; retorne.
  Catalogue a rotina usando os unidades semânticas desta rotina e o catálogo geral de rotinas.

Etapas para que se compile o headers of uns rotinas:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Compile o header of a rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se compile um literal usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione o literal para os literals usando o caractere inicial deste segmento inicial deste percorredor .
  \Se o segmento inicial deste percorredor for algum tipo de detector literal, compile o literal usando o percorredor (detector); retorne.
  Se o segmento inicial deste percorredor for algum tipo de hex literal, compile o literal usando o percorredor (hex); retorne.
  Se o segmento inicial deste percorredor for algum tipo de numeric literal, compile o literal usando o percorredor (numeric); retorne.
  Se o segmento inicial deste percorredor for algum tipo de ponteiro literal, compile o literal usando o percorredor (ponteiro); retorne.
  Se o segmento inicial deste percorredor for algum tipo de string literal, compile o literal usando o percorredor (texto); retorne.
  Apresente uma mensagem de erro contendo "Erro interno - compile um termo usando um percorredor (literal)" e o percorredor.

Etapas para que se compile um literal usando um percorredor (detector):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para um detector.
  Converta o detector para os data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "detector" ao type nome deste literal.
  Resolva o literal. \ Que tal utilizar os termos "decifre", "traduza", "destrinche", "decodifique"?

Etapas para que se compile um literal usando um percorredor (hex):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta o parte da cifra binária para o data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "texto hexadecimal" ao type nome deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (numeric - integer):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para um número.
  Converta o número para os data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "número" ao type nome deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (numeric - proporção):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Converta a proporção para o data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "proporção" ao type nome deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (numeric - com unidade de medida):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um type usando o nome e o catálogo de tipos.
  Se o type for inexistente, apresente uma mensagem de erro contendo "'" junto com o nome seguido de "' é uma unidade de medida inexistente." e o local de aparição deste literal; retorne.
  Se o type não puder ser reduzido para "número", apresente a mensagem de erro contendo "'" junto com o nome seguido de "' é uma unidade de medida inválida." e o local de aparição deste literal; retorne.
  Atribua a razão de escala deste type para um final proporção.
  Se a razão de escala deste type for 0, atribua 1/1 ao final proporção.
  Multiplique o final proporção pelo proporção.
  Reduza o final proporção.
  Se o denominador deste final proporção for 0, apresente a mensagem de erro contendo "Parece que essa é uma unidade de medida inválida." e o local de aparição deste literal.
  Atribua o numerador deste final proporção dividido pelo denominador deste final proporção para um número.
  Atribua o nome deste type ao type nome deste literal.
  Converta o número para o data deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (numeric):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o percorredor estiver acompanhado por algum tipo de unidade de medida, compile o literal usando o percorredor (numeric - com unidade de medida); retorne.
  Se o segmento inicial deste percorredor for algum tipo de integer literal, compile o literal usando o percorredor (numeric - integer); retorne.
  Se o segmento inicial deste percorredor for algum tipo de proporção literal, compile o literal usando o percorredor (numeric - proporção); retorne.
  Se o segmento inicial deste percorredor for algum tipo de numeral misto literal, compile o literal usando o percorredor (numeric - proporção); retorne.

Etapas para que se compile um literal usando um percorredor (ponteiro):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta 0 para os data deste literal. \ was nil
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "ponteiro" ao type nome deste literal.
  Resolva o literal.

Etapas para que se compile um literal usando um percorredor (texto):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o segmento inicial deste percorredor aos data deste literal.
  Remove aspas de os data deste literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "string" ao type nome deste literal.
  \Atribua "texto" ao type nome deste literal.
  Resolva o literal.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum tipo de artigo definido, compile os unidades semânticas e o parâmetros usando o percorredor (artigo definido); recomece.
  Se o percorredor estiver sobre algum tipo de artigo indefinido, compile os unidades semânticas e o parâmetros usando o percorredor (artigo indefinido); recomece.
  Se o percorredor estiver sobre algum tipo de unidade semântica string, compile os unidades semânticas e o parâmetros usando o percorredor (unidade semântica string); recomece.
  Apresente uma mensagem de erro contendo "'" junto com o segmento inicial deste percorredor seguido de "' não é um nome de função que eu conheça." e o percorredor.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo definido):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para os unidades semânticas usando o nome.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo indefinido):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um parâmetro para o parâmetros usando "parâmetro" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outras", atribua "outras" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "outros", atribua "outros" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segundos", atribua "segundos" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste parâmetro.
  Se o segmento inicial deste percorredor for "segunda", atribua "segundas" ao nome deste parâmetro.
  \CAL
  Se o segmento inicial deste percorredor for "another", atribua "segunda" ao nome deste parâmetro.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Extend o nome destes parâmetro com o nome.
  Se o segmento inicial deste percorredor for algum called, compile o Processe'd part usando o percorredor e o parâmetro.
  Resolva o parâmetro.
  Se o parâmetro estiver duplicada no parâmetros, apresente uma mensagem de erro contendo "Cara, você repetiu o parâmetro: " junto com o nome deste parâmetro seguido de "." e o local de aparição deste parâmetro; retorne.
  Adicione uma unidade semântica para os unidades semânticas usando o type deste parâmetro.

Etapas para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (unidade semântica string):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma unidade semântica para os unidades semânticas usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile umas unidades semânticas usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o percorredor estiver sobre algum tipo de unidade semântica string, adicione uma unidade semântica para os unidades semânticas usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação); recomece.
  Se o segmento inicial deste percorredor não for o início of algum tipo de expression, retorne.
  Compile um expression usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma segunda unidade semântica para os unidades semânticas usando o expression.
  Recomece. [percorra novamente o código acima]

\Etapas para que se compile umas unidades semânticas usando um percorredor:
\Se o detector de erros deste compilador estiver ativado, retorne.
\Se o segmento inicial deste percorredor for algum tipo de unidade semântica string, adicione uma unidade semântica para os unidades semânticas usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação); recomece.
\Se o segmento inicial deste percorredor não for o início of algum tipo de expression, retorne.
\Compile um expression usando o percorredor.
\Se o detector de erros deste compilador estiver ativado, retorne.
\Adicione uma segunda unidade semântica para os unidades semânticas usando o expression.
\Recomece. [percorra novamente o código acima]

Etapas para que se compile a próxima instrução usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor for algum comando condicional, compile a próxima instrução usando o percorredor (if); retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento, compile a próxima instrução usando o percorredor (loop); retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção, compile a próxima instrução usando o percorredor (privatize); retorne.
  Se o segmento inicial deste percorredor não for o início of algum tipo de statement, apresente uma mensagem de erro contendo "Eu esperava uma declaração aqui, mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Compile a próxima instrução usando o percorredor (other).
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Tem um problema nesse comando aqui." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (break):
  Adicione um fragment usando o etiqueta de interrupção.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (Processe - external):
  Atribua o segmento inicial deste percorredor para uma string.
  Remove aspas de a string.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de string literal, apresente uma mensagem de erro contendo "Cara, você precisa colocar os nomes entre aspas, mas você colocou: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Atribua o segmento inicial deste percorredor para uma segunda string.
  Remove aspas de a segunda string.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione um entry para o imports usando a string e a segunda string.
  Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (Processe - cláusula com).
  Se o segmento inicial deste percorredor for "contendo", compile a próxima instrução usando o percorredor (Processe - cláusula com).
  Se o segmento inicial deste percorredor for "usando", compile a próxima instrução usando o percorredor (Processe - cláusula com).
  Se o segmento inicial deste percorredor for "devolvendo", compile a próxima instrução usando o percorredor devolvendo um termo (Processe - cláusula devolvendo).
  \Se o segmento inicial deste percorredor for "entregando", compile a próxima instrução usando o percorredor devolvendo um terceiro termo (Processe - cláusula devolvendo).
  \Se o segmento inicial deste percorredor for "apimorando", compile a próxima instrução usando o percorredor devolvendo um quarto termo (Processe - cláusula devolvendo).
  \Se o segmento inicial deste percorredor for "aperfeiçoando", compile a próxima instrução usando o percorredor devolvendo um quinto termo (Processe - cláusula devolvendo).
  \Se o segmento inicial deste percorredor for "melhorando", compile a próxima instrução usando o percorredor devolvendo um sexto termo (Processe - cláusula devolvendo).
  Adicione um fragment usando a etiqueta de demanda externa e o entry.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Não entendi bem o que é: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um segundo fragment usando o etiqueta de obtenção do registrador EAX e a variável deste termo.

Etapas para que se compile a próxima instrução usando um percorredor (Processe - indirect):
  Compile um expression usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Eu não sei o que é: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
  Se o type desta expression não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "Eu preciso de um ponteiro type nesse CALL statement." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (Processe - cláusula com).
  Se o segmento inicial deste percorredor for "contendo", compile a próxima instrução usando o percorredor (Processe - cláusula com).
  Se o segmento inicial deste percorredor for "devolvendo", compile a próxima instrução usando o percorredor devolvendo um termo (Processe - cláusula devolvendo).
  Adicione um fragment usando a etiqueta de demanda indireta e a variável desta expression.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Acho que essa varíavel é inválida: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um segundo fragment usando o etiqueta de obtenção do registrador EAX e a variável deste termo.

Etapas para que se compile a próxima instrução usando um percorredor (Processe - internal):
  Compile umas unidades semânticas usando o percorredor.
  Encontre uma rotina usando os unidades semânticas.
  Se a rotina não for inexistente, adicione push fragments usando os unidades semânticas.
  Se a rotina não for inexistente, destrua os unidades semânticas; adicione um fragment usando a etiqueta de demanda interna e a rotina; retorne.
  Converta os unidades semânticas para uma representação interna da rotina.
  Destrua os unidades semânticas.
  \Atribua "Eu ainda não aprendi como" ao texto retornado.
  \Say o texto retornado.
  Atribua a representação interna da rotina ao texto retornado.
  \Say o texto retornado.
  Apresente uma mensagem de erro contendo "Eu ainda não aprendi como: " junto com a representação interna da rotina seguido de "." e o percorredor.

Etapas para que se compile a próxima instrução usando um percorredor (Processe - cláusula com):
  \ this routine is recursise so parameters get passed right to  left
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um expression usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Eu não entendi a variável: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
  Se o type desta expression não for value pushable, apresente a mensagem de erro contendo "'" junto com o nome deste type desta expression seguido de "' não pode ser processado corretamente." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum tipo de and, compile a próxima instrução usando o percorredor (Processe - cláusula com).
  Adicione um fragment usando o etiqueta de inserção de valor [na stack] e a variável desta expression.

Etapas para que se compile a próxima instrução usando um percorredor (Processe):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum tipo de string literal, compile a próxima instrução usando o percorredor (Processe - external); retorne.
  Compile a próxima instrução usando o percorredor (Processe - indirect).

Etapas para que se compile a próxima instrução usando um percorredor (exit):
  Se o detector de deliberação desta rotina utilizada atualmente estiver ativo, apresente uma mensagem de erro contendo "O que o comando 'exit' significa aqui? Sim? Não? Talvez?" e o percorredor; retorne.
  \Se o segmento inicial deste percorredor for "a", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for "operação", mova o percorredor (usando diretrizes de compilação).
  Adicione um fragment usando o etiqueta de retorno.
  \Se o segmento inicial deste percorredor for "a", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for "operação", mova o percorredor (usando diretrizes de compilação).
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (if):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile umas unidades semânticas usando o percorredor.
  Remove algum tipo de negatives desde os unidades semânticas devolvendo um detector.
  Encontre uma rotina usando os unidades semânticas.
  Se a rotina não for inexistente, adicione push fragments usando os unidades semânticas.
  Se a rotina for inexistente, converta os unidades semânticas para uma representação interna da rotina.
  Destrua os unidades semânticas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro. A rotina: '" junto com a representação interna da rotina seguido de "' não existe." e o percorredor; retorne.
  Se o detector de deliberação desta rotina não estiver ativo, apresente a mensagem de erro contendo "Cara eu vou precisar de um decider aqui, blz?" e o percorredor; retorne.
  \ Se o segmento inicial deste percorredor não for a vírgula, apresente a mensagem de erro contendo "Acho que você esqueceu de uma vírgula, eu achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Se o segmento inicial deste percorredor não for qualquer if-separador, apresente a mensagem de erro contendo "Acho que você esqueceu de colocar uma vírgula, eu achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um fragment usando a etiqueta de demanda interna e a rotina.
  Se o detector estiver ativo, adicione um segundo fragment usando a etiqueta de negação lógica.
  Adicione um terceiro fragment usando o etiqueta de desvio falso.
  Mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Compile a próxima instrução usando o percorredor (other).
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, mova o percorredor (usando diretrizes de compilação); recomece.
    \Se o segmento inicial deste percorredor for "Senão", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for "Caso", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes de compilação).
    \Se o segmento inicial deste percorredor for a vírgula, mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você precisa usar um ponto ao invés de usar o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione um quarto fragment usando o etiqueta delimitadora de bloco condicional.

Etapas para que se determine se um subtexto é qualquer if-separador:
  Se o subtexto for a vírgula, diga sim.
  Se o subtexto for "então", diga sim.
  [Caso contrário] Diga não.

Etapas para que se compile a próxima instrução usando um percorredor (Decodifique):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de hex literal, apresente uma mensagem de erro contendo "Erro: ao invés de código hexadecimal, foi digitado o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um fragment usando o etiqueta de decodificação.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta o parte da cifra binária para o código deste fragment.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (loop):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um fragment usando o etiqueta de laço.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Parece que alguém esqueceu de colocar um ponto por aí." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (other):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum comando de abandono de rotina, compile a próxima instrução usando o percorredor (exit); retorne.
  Se o segmento inicial deste percorredor for algum comando de repetição, compile a próxima instrução usando o percorredor (repeat); retorne.
  Se o segmento inicial deste percorredor for algum comando de interrupção de repetições, compile a próxima instrução usando o percorredor (break); retorne.
  Se o segmento inicial deste percorredor for algum comando de confirmação ou negação, compile a próxima instrução usando o percorredor (say); retorne.
  Se o segmento inicial deste percorredor for "Decodifique", compile a próxima instrução usando o percorredor (Decodifique); retorne.
  Se o segmento inicial deste percorredor for "push", compile a próxima instrução usando o percorredor (push); retorne.
  Se o segmento inicial deste percorredor for algum chamada de biblioteca externa, compile a próxima instrução usando o percorredor (Processe); retorne.
  Se o segmento inicial deste percorredor for algum tipo de point, compile a próxima instrução usando o percorredor (point); retorne.
  Se o segmento inicial deste percorredor for algum comando condicional, apresente uma mensagem de erro contendo "Colocar vários 'Se' no mesmo comando nunca dá muito certo. Melhor fazer tudo de novo." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção, apresente a mensagem de erro contendo "A sentença 'Isole' não pode ser usada nesse tipo de comando." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento, apresente a mensagem de erro contendo "Usar o comando 'Percorra' dentro de um 'Se' é uma ótima forma de arranjar problemas." e o percorredor; retorne.
  Se o segmento inicial deste percorredor for algum tipo de reutilização de rotina, apresente a mensagem de erro contendo "O comando 'Empregue' deve ser o único comando de uma rotina." e o percorredor; retorne.
  \Se o segmento inicial deste percorredor for "senão", mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o segmento inicial deste percorredor for "caso", mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o segmento inicial deste percorredor for "a", ative um detector; mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o detector estiver ativado e o segmento inicial deste percorredor for "operação", mova o percorredor (usando diretrizes de compilação); retorne.
  \Se o segmento inicial deste percorredor for "operação", desative o detector; mova o percorredor (usando diretrizes de compilação); retorne.
  Compile a próxima instrução usando o percorredor (Processe - internal).

Etapas para que se compile a próxima instrução usando um percorredor (point):
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro. O termo: " junto com a phrase deste termo seguido de "' está vazio." e o percorredor; retorne.
  Se a categoria deste termo for "literal", apresente a mensagem de erro contendo "Você usou o tipo errado de variável aqui (literal)." e o percorredor.
  Se a quantidade de caracteres deste type deste termo não for 4, apresente a mensagem de erro contendo "Você usou uma variável de comprimento errado (<>4)." e o percorredor.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "Faltou um 'para' depois da palavra 'aponte'. Você usou o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "rotina", apresente a mensagem de erro contendo "Acho que faltou a palavra 'rotina'. Você usou o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma rotina reference usando o percorredor.
  Converta a rotina reference para uma representação interna da rotina.
  Destrua a rotina reference.
  Encontre uma rotina usando a representação interna da rotina e o catálogo geral de rotinas.
  Se a rotina for inexistente, apresente a mensagem de erro contendo "Não achei a tarefa: " junto com a representação interna da rotina seguido de "' que você falou." e o percorredor; retorne.
  Adicione um fragment usando a etiqueta de endereço de rotina e a rotina.
  Atribua a variável deste termo à variável deste fragment.

Etapas para que se compile a próxima instrução usando um percorredor (privatize):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Comando 'isole', Inválido. Eu acho que o termo da variável: " junto com a phrase deste termo seguido de "' está vazio." e o percorredor; retorne.
  Se a categoria deste termo não for "parâmetro", apresente a mensagem de erro contendo "Você só pode isolar parâmetros." e o percorredor; retorne.
  Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o nome deste termo ao nome deste local.
  Atribua o nickname deste termo ao nickname deste local.
  Atribua o type nome deste termo ao type nome deste local.
  Resolva o local.
  Anteponha "original " para o nome deste termo.
  Se o nickname deste termo não estiver em branco, Anteponha "original " para o nickname deste termo.
  Adicione several fragments usando "atribua" e a variável deste termo e "para" e o local e o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você vive esquecendo dos pontos né?." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile a próxima instrução usando um percorredor (push):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um expression usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Comando 'push' inválido, um expressão: " junto com a phrase desta expression seguido de "' parece estar vazia." e o percorredor; retorne.
  Se o type desta expression não for value pushable, apresente a mensagem de erro contendo "Valores do tipo: " junto com o nome deste type desta expression seguido de "' não podem ser pushed." e o percorredor; retorne.
  Adicione um fragment usando o etiqueta de inserção de valor [na stack] e a variável desta expression.

Etapas para que se compile a próxima instrução usando um percorredor (repeat):
  Adicione um fragment usando a etiqueta de repetição.
  Mova o percorredor (usando diretrizes de compilação).

\Etapas para que se compile a próxima instrução usando um percorredor (say):
\Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (Processe - internal); retorne.
\Mova o percorredor (usando diretrizes de compilação).
\Compile um expression usando o percorredor.
\Se o detector de erros deste compilador estiver ativado, retorne.
\Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "No es válido este 'diga', no entiendo la variável: " junto com a phrase desta expression seguido de "." e o percorredor; retorne.
\Se o type desta expression não puder ser reduzido para "detector", apresente uma mensagem de erro contendo "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; retorne.
\Adicione um fragment usando o etiqueta de carregamento de registrador EAX e a variável desta expression.
\Adicione um segundo fragment usando o etiqueta de retorno.

Etapas para que se compile a próxima instrução usando um percorredor (say):
  Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (Processe - internal); retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando de deliberaçãor literal, apresente uma mensagem de erro contendo "Você precisa terminar com um yes ou no." e o percorredor; retorne.
  Desative um detector. Se o segmento inicial deste percorredor for algum tipo de positive decider literal, ative o detector.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Faltou um ponto. Você usou o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um fragment usando o etiqueta de carregamento de registrador EAX e o detector.
  Adicione um segundo fragment usando o etiqueta de retorno.

Etapas para que se compile a próxima instrução usando um percorredor devolvendo um termo (Processe - cláusula devolvendo):
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Eu não compreendi o termo da variável: " junto com a phrase deste termo seguido de "'. Ela parece estar vazia." e o percorredor; retorne.
  Se o type deste termo não for value pushable, apresente a mensagem de erro contendo "Uma varíavel de 1, 2, ou 4 bytes é necessária na 'devolvendo' clause." e o percorredor.

Etapas para que se compile uma rotina reference usando um percorredor:
  Se o segmento inicial deste percorredor for "para", mova o percorredor (usando diretrizes de compilação).
  Se o percorredor for o início of algum tipo de function, compile a rotina reference usando o percorredor (função); retorne.
  Se o segmento inicial deste percorredor for algum comando de deliberação, compile a rotina reference usando o percorredor (decide).
  Comece. [a executar o código abaixo]
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for ".", retorne.
  Se o segmento inicial deste percorredor for algum tipo de artigo definido, compile a rotina reference usando o percorredor (artigo definido); recomece.
  Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, compile a rotina reference usando o percorredor (artigo indefinido); recomece.
  Se o percorredor está sobre algum tipo de unidade semântica string, compile a rotina reference usando o percorredor (unidade semântica string); recomece.
  Apresente uma mensagem de erro contendo "'" junto com o segmento inicial deste percorredor seguido de "' não é válido em um employ statement." e o percorredor.

Etapas para que se compile uma rotina reference usando um percorredor (decide):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional, apresente uma mensagem de erro contendo "Sempre use DECIDE IF, ao invés de apenas DECIDE com: " junto com o segmento inicial deste percorredor seguido de "' logo em seguida." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile uma rotina reference usando um percorredor (artigo definido):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para a rotina reference usando o nome.

Etapas para que se compile uma rotina reference usando um percorredor (função):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma unidade semântica para a rotina reference usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile a rotina reference usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile a rotina reference usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum tipo de possessive, apresente uma mensagem de erro contendo "Eu estava esperando un 's, mas apareceu: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para a rotina reference usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "E estava esperando a palavra 'para/into', mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Adicione um terceiro unidade semântica para a rotina reference usando "para".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Eu estava esperando um artigo indefinido mas encontrei isso: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne. \ not translated - no possessives em Spanish
  Compile a rotina reference usando o percorredor (artigo indefinido).

Etapas para que se compile uma rotina reference usando um percorredor (artigo indefinido):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um type e um nickname usando o nome.
  Se o type for inexistente, apresente uma mensagem de erro contendo "Employ statement inválido, Eu não sei o que é: " junto com o nome seguido de "." e o percorredor; retorne.
  Adicione uma unidade semântica para a rotina reference usando o type.

Etapas para que se compile uma rotina reference usando um percorredor (unidade semântica string):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione uma unidade semântica para a rotina reference usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Etapas para que se compile um termo usando um percorredor:
  Limpe o termo.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Compile o termo usando o percorredor (common part).
  Se o percorredor estiver sobre algum tipo de simile, retorne. \ added for invisible turtle project ***
  \Se o segmento inicial deste percorredor for "as", compile o termo usando o percorredor (as part). \preposição
  \Se o segmento inicial deste percorredor for "tão", compile o termo usando o percorredor (as part). \ me parece desnecessário por ser usado apenas em funções.
  Se o segmento inicial deste percorredor for "quão", compile o termo usando o percorredor (as part).
  Se o segmento inicial deste percorredor for "quanto", compile o termo usando o percorredor (as part).
  Se o segmento inicial deste percorredor for "como", compile o termo usando o percorredor (as part).
  \Se o segmento inicial deste percorredor for "que nem", compile o termo usando o percorredor (as part).
  Se o segmento inicial deste percorredor for "/", compile o termo usando o percorredor (runtime proporção).

Etapas para que se compile um termo usando um percorredor (as part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Comando 'as' inválido. Eu acho que a variável: " junto com a phrase deste termo seguido de "' está vaiza." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Tá faltando um artigo indefinido depois do 'como', mas você escreveu: " junto com o segmento inicial deste percorredor seguido de "' no lugar disso." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um type nome usando o percorredor.
  Encontre um type usando o type nome e o catálogo de tipos.
  Se o type for inexistente, apresente a mensagem de erro contendo "Eu não sei em qual tipo o: " junto com o type nome seguido de "' se encaixa." e o percorredor; retorne.
  Adicione um scratch usando o nome deste type e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragment usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Atribua o scratch à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (common part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor for o hífem, compile o termo usando o percorredor (negated termo); retorne.
  Se o segmento inicial deste percorredor for o sinal de adição, compile o termo usando o percorredor (posigated termo); retorne.
  Se o segmento inicial deste percorredor for o início of algum tipo de variável, compile o termo usando o percorredor (variável); retorne.
  Se o segmento inicial deste percorredor for o início of algum tipo de new local, compile o termo usando o percorredor (new local); retorne.
  Se o segmento inicial deste percorredor for algum tipo de literal, compile o termo usando o percorredor (literal); retorne.
  Apresente uma mensagem de erro contendo "Faltou um termo por aqui. Só achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor.

Etapas para que se compile um termo usando um percorredor (dereference - em place):
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro interno na função - compile um termo usando um percorredor (dereference - em place). Termo vazio" e o percorredor; retorne.
  Atribua o nome deste conteúdo type deste type deste termo ao type nome deste termo.
  Atribua o conteúdo type deste type deste termo ao type deste termo.
  Adicione um fragment usando o etiqueta de revogação e a variável deste termo.
  Limpe o phrase deste termo.

Etapas para que se compile um termo usando um percorredor (dereference):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Dereference inválido, um variável: " junto com a phrase deste termo seguido de "' parece estar vazia." e o percorredor; retorne.
  Se o conteúdo type deste type deste termo for inexistente, apresente a mensagem de erro contendo "Não consegui identificar o tipo desse conteúdo." e o percorredor; retorne.
  Se a categoria deste termo for "scratch", compile o termo usando o percorredor (dereference - em place); retorne.
  Adicione um scratch usando o nome deste conteúdo type deste type deste termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragment usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Adicione um segundo fragment usando o etiqueta de revogação e o scratch.
  Atribua o scratch à variável deste termo.
  Limpe o phrase deste termo.

Etapas para que se compile um termo usando um percorredor (literal):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Compile um literal usando o percorredor.
  Atribua o literal à variável deste termo.
  Limpe o phrase deste termo.
  Compile o termo usando o percorredor (possessives).

Etapas para que se compile um termo usando um percorredor (negated termo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma segunda termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável desta segunda termo for inexistente, apresente uma mensagem de erro contendo "Negate inválido, um variável: " junto com o phrase desta segunda termo seguido de "' parece estar vazia." e o percorredor; retorne.
  Adicione um intermediate usando o type nome desta segunda termo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "atribua" e a variável desta segunda termo e "para" e o intermediate e o local de aparição desta segunda termo.
  Adicione two fragments usando "negate" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável deste termo.
  Limpe o phrase deste termo.

Etapas para que se compile um termo usando um percorredor (new local):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e o percorredor; retorne.
  Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste local.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste local.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste local.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste local.
  \CAL
  Se o segmento inicial deste percorredor for "another", atribua "segunda" ao nome deste local.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Extend o nome deste local com o nome.
  Se o segmento inicial deste percorredor for algum called, compile o Processe'd part usando o percorredor e o local.
  Resolva o local.
  Se o local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente a mensagem de erro contendo "o parâmetro: " junto com o nome deste local seguido de "' já está sendo usado como parâmetro." e o local de aparição deste local; retorne.
  Se o local estiver duplicada em os locals desta rotina utilizada atualmente, apresente a mensagem de erro contendo "Já existe uma variável local chamada'" junto com o nome deste local seguido de "'. Você tem que dar um nome diferente." e o local de aparição deste local; retorne.
  Eliminate duplicate nicknames usando o local e o nickname catálogo desta rotina utilizada atualmente.
  Atribua o local à variável deste termo.
  Limpe a phrase deste termo.
  Compile o termo usando o percorredor (possessives).

Etapas para que se compile um termo usando um percorredor (posigated termo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Posigate inválido, o termo da variável'" junto com a phrase deste termo seguido de "' parece estar vazio." e o percorredor; retorne.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (possessivo - magnitude):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Use da magnitude inválido. A variável: " junto com a phrase deste termo seguido de "' parece estar vazia." e o percorredor; retorne.
  Adicione um literal para os literals usando o caractere inicial deste segmento inicial deste percorredor.
  Converta a quantidade de caracteres deste type deste termo para os data deste literal.
  Atribua "número" ao type nome deste literal.
  Resolva o literal.
  Atribua o literal à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (possessivo - conteúdo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou o termo 'conteúdo' de forma errada. O termo da variável: " junto com a phrase deste termo seguido de "' parece estar em branco ou não foi devidamente definido." e o percorredor; retorne.
  Se o type deste termo não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "Você só pode usar a palavra 'conteúdo' com valores do tipo 'ponteiro'." e o percorredor; retorne.
  Compile o termo usando o percorredor (dereference).

Etapas para que se compile um termo usando um percorredor (possessivo - endereçamento):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou endereçamento da forma errada, erro no termo da variável: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando "ponteiro" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragment usando o etiqueta de carregamento de endereço e a variável deste termo e o intermediate.
  Atribua o intermediate à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (possessive):
  \ similar a "compile um termo usando um percorredor (possessivo reverso)
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o nome for algum tipo de magnitude, compile o termo usando o percorredor (possessivo - magnitude); retorne.
  Se o nome for algum tipo de conteúdo, compile o termo usando o percorredor (possessivo - conteúdo); retorne.
  Se o nome for algum tipo de endereçamento, compile o termo usando o percorredor (possessivo - endereçamento); retorne.
  Compile o termo usando o percorredor e o nome (possessive - campo).

Etapas para que se compile um termo usando um percorredor (possessives):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor não for algum tipo de possessive, retorne.
  Compile o termo usando o percorredor (possessive).
  Recomece. [percorra novamente o código acima]

Etapas para que se compile um termo usando um percorredor (runtime proporção):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um segundo termo usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste segundo termo for inexistente, apresente a mensagem de erro contendo "Uso inválido da /, termo vazio da variável: " junto com o phrase deste segundo termo seguido de "." e o percorredor; retorne.
  Adicione um intermediate usando "proporção" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione several fragments usando "atribua" e a variável deste termo e "e" e a variável deste segundo termo e "para" e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor (variável):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Erro de tarefa vazia, nada pra pull da pilha aqui." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum tipo de reverse-possessive, compile o termo usando o percorredor e o nome (possessivo reverso); retorne.
  Encontre uma variável usando o nome.
  Atribua a variável à variável deste termo.
  Atribua "o " à phrase deste termo.
  Posponha o nome para a phrase deste termo.
  Compile o termo usando o percorredor (possessives).

Etapas para que se compile um termo usando um percorredor e um campo nome (possessivo reverso):
  \ função recursiva
  \ Rotina nova criada pelo Dahn para version 2
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ past o reverse-possessive starter
  \Se o segmento inicial deste percorredor não for "del", mova o percorredor (usando diretrizes de compilação). \ past o reverse-possessive starter \ gerry added "if" part
  Se o segmento inicial deste percorredor não for algum tipo de artigo, apresente uma mensagem de erro contendo "O compilador esperava encontrar un artigo, mas encontrou: " junto com o segmento inicial deste percorredor seguido de "."; retorne.
  Atribua o segmento inicial deste percorredor para um article segmento inicial.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum tipo de reverse-possessive, ative um reverse-possessive detector.
  Se o reverse-possessive detector estiver ativo, compile o termo usando o percorredor e o nome (possessivo reverso).
  Se o reverse-possessive detector não estiver ativo, compile o termo usando o percorredor e o nome e o article (reversão de contrações do possessivo).\ não entendi
  Compile o termo usando o campo nome e o percorredor (possessivo reverso).

Etapas para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações do possessivo):
  \ Rotina nova criada pelo Dahn para version 2
  Se o article for o início of algum tipo de variável, compile o termo usando o percorredor e a variável nome e o article (reversão de contrações de variáveis do possessivo); retorne.
  Compile o termo usando o percorredor e a variável nome (decomposição do possessivo reverso - variável local).

Etapas para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações de variáveis do possessivo):
  \ Rotina nova criada pelo Dahn para version 2
  Encontre uma variável usando a variável nome.
  Se a variável for inexistente, apresente uma mensagem de erro contendo "Não foi possível encontrar uma variável com o nome: " junto com a variável nome seguido de ".".
  Atribua a variável à variável deste termo.
  Atribua "o " à phrase deste termo.
  Posponha a variável nome para a phrase deste termo.

Etapas para que se compile um termo usando um percorredor e uma variável nome (decomposição do possessivo reverso - variável local):
  \ Rotina nova criada pelo Dahn para version 2
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste local.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste local.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste local.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste local.
  \CAL
  \Se o segmento inicial deste percorredor for "another", atribua "segunda" ao nome deste local.
  Extend o nome deste local com a variável nome.
  Se o segmento inicial deste percorredor for algum called, compile o Processe'd part usando o percorredor e o local.
  Resolva o local.
  Se o local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente uma mensagem de erro contendo "O termo: " junto com o nome deste local seguido de "' já está sendo usado como parâmetro." e o local de aparição deste local; retorne.
  Se o local estiver duplicada em os locals desta rotina utilizada atualmente, apresente a mensagem de erro contendo "O termo: " junto com o nome deste local seguido de "' já está sendo usado coma variável local." e o local de aparição deste local; retorne.
  Eliminate duplicate nicknames usando o local e o nickname catálogo desta rotina utilizada atualmente.
  Atribua o local à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um campo nome e um percorredor (possessivo reverso):
  \ similar para "compile um termo usando um percorredor (possessive)" \ Rotina nova criada pelo Dahn para
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o campo nome for algum tipo de magnitude, compile o termo usando o percorredor (possessivo - magnitude); retorne.
  Se o campo nome for algum tipo de conteúdo, compile o termo usando o percorredor (possessivo - conteúdo); retorne.
  Se o campo nome for algum tipo de endereçamento, compile o termo usando o percorredor (possessivo - endereçamento); retorne.
  Compile o termo usando o percorredor e o campo nome (possessive - campo).

Etapas para que se compile um termo usando um percorredor e um campo termo:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o dereference detector deste campo termo estiver ativo, compile o termo usando o percorredor (dereference).
  Se o function deste campo termo não for inexistente, compile o termo usando o percorredor e o campo termo (função); retorne.
  Se a categoria deste termo for "scratch", compile o termo usando o percorredor e o campo termo (in place); retorne.
  Atribua o campo deste campo termo para um campo.
  Adicione um scratch usando o nome deste type deste campo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragment usando o etiqueta de carregamento de endereço e a variável deste termo e o scratch.
  Se o offset deste campo não for 0, adicione um terceiro fragment usando a etiqueta de acréscimo e o scratch e o offset deste campo.
  Atribua o scratch à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor e um campo termo (função):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o function deste campo termo para uma rotina.
  Atribua o last parâmetro destes parâmetros desta rotina para um parâmetro.
  Se o parâmetro for inexistente, apresente uma mensagem de erro contendo "Erro interno na função compile um termo usando um percorredor e um campo termo (função) - parâmetro vazio." e o percorredor; retorne.
  Se o type deste parâmetro for inexistente, apresente a mensagem de erro contendo "Erro interno 2 na função compile um termo usando um percorredor e um campo termo (função) - tipo do parâmetro inexistente." e o percorredor; retorne.
  Adicione um intermediate usando o nome deste type deste parâmetro e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragment usando o etiqueta de inserção de endereço [na stack] e o intermediate.
  Se o push detector deste campo termo estiver ativo, adicione um segundo fragment usando o etiqueta de inserção de endereço [na stack] e a variável deste termo.
  Adicione um terceiro fragment usando a etiqueta de demanda interna e a rotina.
  Atribua o intermediate à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor e um campo termo (in place):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o campo deste campo termo para um campo.
  Atribua o nome deste type deste campo ao type nome deste termo.
  Atribua o type deste campo ao type deste termo.
  Se o offset deste campo não for 0, adicione um terceiro fragment usando a etiqueta de acréscimo e a variável deste termo e o offset deste campo.
  Limpe a phrase deste termo.

Etapas para que se compile um termo usando um percorredor e um nome (possessive - campo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável deste termo não for inexistente, atribua o type deste termo para um type.
  Encontre um campo termo usando o phrase deste termo e o type e o nome.
  Se o campo termo não estiver vazio, compile o termo usando o percorredor e o campo termo; retorne.
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro: variável vazia: " junto com a phrase deste termo seguido de "." e o percorredor; retorne.
  Se o type puder ser reduzido para "ponteiro", atribua o conteúdo type deste type ao type.
  Se o type for inexistente, apresente a mensagem de erro contendo "Não existe o campo: " junto com o nome seguido de "' no tipo: " junto com o nome deste type deste termo seguido de "." e o percorredor; retorne.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde os campos deste type.
    Se o campo for inexistente, apresente a mensagem de erro contendo "Não há nenhum campo: " junto com o nome seguido de "' no tipo: " junto com o nome deste type deste termo seguido de "." e o percorredor; retorne.
    Encontre um deep campo termo usando "" e o type deste campo e o nome.
    Se o deep campo termo estiver vazio, recomece.
  Atribua o campo para o campo desse first campo termo.
  Se o type deste termo puder ser reduzido para "ponteiro", ative o dereference detector deste first campo termo.
  Compile o termo usando o percorredor e o first campo termo.
  Compile o termo usando o percorredor e o deep campo termo.

  

Etapas para que se converta umas unidades semânticas para uma representação interna da rotina :
  Converta os unidades semânticas para a representação interna da rotina usando o last unidade semântica destes unidades semânticas.

Etapas para que se converta umas unidades semânticas para uma representação interna da rotina usando uma unidade semântica:
  Limpe a representação interna da rotina.
  Comece. [a executar o código abaixo]
    Obtenha um current unidade semântica desde os unidades semânticas.
    Se o current unidade semântica for inexistente, retorne.
    Posponha o current unidade semântica para a representação interna da rotina.
    Se o current unidade semântica for o unidade semântica, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se converta uma parte da cifra binária para uma string:
  Employ converta uma cifra hexadecimal para um texto hexadecimal.

Etapas para que se converta um termo por concatenation usando um percorredor: \\ concatenação
  \ used for right-side followed by operand
  Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro: a variável do termo '" junto com a phrase deste termo seguido de "' está vazia." e o percorredor; retorne.
  Se o type deste termo puder ser reduzido para "string", retorne.
  Se o type deste termo puder ser reduzido para "texto", retorne.
  Adicione um intermediate usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  \Adicione um intermediate usando "texto" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragments usando a variável deste termo e o intermediate e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o intermediate à variável deste termo.
  Limpe a phrase deste termo.

Etapas para que se copie um campo para um segundo campo:
  Se o campo for inexistente, esvazie o segundo campo; retorne.
  Aloque memória para o segundo campo.
  Atribua o local de aparição deste campo ao local de aparição deste segundo campo.
  Atribua o nome deste campo ao nome deste segundo campo.
  Atribua o nickname deste campo ao nickname deste segundo campo.
  Atribua o type nome deste campo ao type nome deste segundo campo.
  Atribua o type deste campo ao type deste segundo campo.
  Atribua a contagem deste campo à contagem deste segundo campo.
  Atribua o redefinition conteúdo nome deste campo ao redefinition conteúdo nome deste segundo campo.
  Atribua o reference detector deste campo ao reference detector deste segundo campo.
  Atribua o offset deste campo ao offset deste segundo campo.

Etapas para que se copie uns campos para uns segundo campos:
  Obtenha um campo desde o campos.
  Se o campo for inexistente, retorne.
  Copie o campo para um segundo campo.
  Posponha o segundo campo para o segundo campos.
  Recomece. [percorra novamente o código acima]

Etapas para que se copie uns campos para uns segundo campos (data campos only):
  Se a contagem destes campos for menor do que 4, retorne. \ for english next e prev e spanish next e prev redefinitions
  \Se o first destes campos for inexistente, retorne.
  \Se o next deste first destes campos for inexistente, retorne.
  \Se o next deste next deste first destes campos for inexistente, retorne.
  \Atribua o next deste next deste first destes campos para um campo. \ skip next e prev
  \Se o next deste next deste next deste first destes campos for inexistente, retorne.
  \Se o next deste next deste next deste next deste first destes campos for inexistente, retorne.
  \Se o next deste next deste next deste next deste next deste first destes campos for inexistente, retorne.
  \Atribua o next deste next deste next deste next deste first destes campos para um campo.
  Atribua o next deste next deste next deste next deste first destes campos para um campo.\ english next e prev e spanish next e prev redefinitions
  \ talvez mudar isso aqui ajude?
  Comece. [a executar o código abaixo]
    Se o campo for inexistente, retorne.
    Copie o campo para um segundo campo.
    Posponha o segundo campo para o segundo campos.
    Obtenha o campo desde o campos.
  Recomece. [percorra novamente o código acima]

Etapas para que se copie uma unidade semântica para uma segunda unidade semântica:
  Se o unidade semântica for inexistente, esvazie a segunda unidade semântica; retorne.
  Aloque memória para o segunda unidade semântica.
  Atribua a string deste unidade semântica à string desta segunda unidade semântica.
  Atribua o type deste unidade semântica ao type desta segunda unidade semântica.
  Atribua a variável deste unidade semântica à variável desta segunda unidade semântica.
  \ não copia subtexto
  Atribua o type atual deste unidade semântica ao type atual desta segunda unidade semântica.

Etapas para que se copie umas unidades semânticas para uns segunda unidades semânticas:
  Destrua a segunda unidades semânticas.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde os unidades semânticas.
    Se o unidade semântica for inexistente, retorne.
    Copie o unidade semântica para uma segunda unidade semântica.
    Posponha a segunda unidade semântica para a segunda unidades semânticas.
  Recomece. [percorra novamente o código acima]

Etapas para que se crie um entry:
  Aloque memória para o entry.

Etapas para que se crie um fragment usando uma etiqueta:
  Aloque memória para o fragment.
  Atribua a etiqueta à etiqueta deste fragment.

Etapas para que se crie um import:
  Aloque memória para o import.

Etapas para que se crie uma unidade semântica:
  Aloque memória para o unidade semântica.

Etapas para que se crie uma rotina:
  Aloque memória para a rotina.

Etapas para que se crie um source file:
  Aloque memória para o source file.

Etapas para que se crie um type:
  Aloque memória para o type.
  Atribua 0/1 à razão de escala deste type.
  Atribua -1 ao quantidade de caracteres deste type.

Etapas para que se crie uma variável usando um categoria:
  Aloque memória para a variável.
  Atribua a categoria à categoria desta variável.
  Atribua 1 à contagem desta variável.

O endereço do cabeçalho usado atualmente é um endereço.

O endereço do nome usado atualmente é um endereço.

O rotina utilizada atualmente é uma rotina.

O endereço pré-calculado atual é um endereço.

A zona de dados é um zona.

Etapas para que se determine se alguns of umas unidades semânticas são advérbios de negação:
  Obtenha uma unidade semântica desde os unidades semânticas.
  Se o unidade semântica for inexistente, diga não.
  Se a string deste unidade semântica for algum tipo de advérbio de negação, diga sim.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um byte é algum tipo de glom byte:
  Se o byte for algum tipo de letra, diga sim.
  Se o byte for algum tipo de digit, diga sim.
  Se o byte for o acento til, diga sim.
  Se o byte for o sinal de arroba, diga sim.
  Se o byte for o símbolo cardinal, diga sim.
  Se o byte for o sinal de porcentagem, diga sim.
  Se o byte for o & comercial, diga sim.
  Se o byte for o underline, diga sim.
  Se o byte for o single-quote byte, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o slash byte, diga sim.
  Se o byte for o símbolo da Libra Esterlina, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum tipo de mark:
  Se o byte for o ponto final, diga sim.
  Se o byte for o vírgula, diga sim.
  Se o byte for o ponto&vírgula, diga sim.
  Se o byte for o sinal de dois pontos, diga sim.
  Se o byte for o ponto de exclamação, diga sim.
  Se o byte for o ponto de interrogação, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum tipo de stressed vogal:
  Se o byte estiver em "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um byte é algum tipo de symbol: \ deveria estar no cérebro
  Se o byte for o acento circumflexo, diga sim.
  Se o byte for o barra vertical, diga sim.
  Se o byte for o asterisco, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o hífem, diga sim.
  Se o byte for o slash byte, diga sim.
  Se o byte for o símbolo menor do que, diga sim.
  Se o byte for o símbolo maior do que, diga sim.
  Se o byte for a chave esquerda, diga sim.
  Se o byte for a chave direita, diga sim.
  Se o byte for o sinal de igualdade, diga sim.
  Se o byte for 128, diga sim.
  Se o byte for 130, diga sim.
  Se o byte estiver entre 132 e 137, diga sim.
  Se o byte for 139, diga sim.
  Se o byte estiver entre 145 e 153, diga sim.
  Se o byte for 155, diga sim.
  Se o byte estiver entre 161 e 180, diga sim.
  Se o byte estiver entre 183 e 191, diga sim.
  Se o byte for 215, diga sim.
  Se o byte for 247, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma campo termo está vazia;
Etapas para que se determine se umas campo termo estão vazias;
Etapas para que se determine se uns campo termo estão vazios;
Etapas para que se determine se um campo termo está vazio:
  Se o campo deste campo termo não for inexistente, diga não.
  Se a function deste campo termo não for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uns campos deveriam ser finalizados;
Etapas para que se determine se uns campos deveria ser finalizado:
  Obtenha um campo desde o campos.
  Se o campo for inexistente, diga não.
  Se o type deste campo deveria ser finalizado, diga sim.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um item parece ser encadernável:
  Carregue o endereço completo deste item para um trecho.
  Se o trecho começa com "ream cal", diga sim. \ CONFERIR AQUI. "TRECHO" E "COMEÇA COM"
  Se o trecho começa com "Documento produzido pelo Editor de Documentos", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma representação interna da rotina está em um catálogo:
  Encontre um referência usando a representação interna da rotina e o catálogo.
  Se o referência for inexistente, diga não.
  Se o ponteiro deste referência for inexistente, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma unidade semântica é bubbled out:
  Se o unidade semântica for inexistente, diga sim.
  Se o type atual deste unidade semântica não for inexistente, diga não.
  Se o subtexto atual deste unidade semântica não estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um nome é algum tipo de magnitude:
  \PAL
  Se o nome for "magnitude", diga sim.
  \ a magnitude retorna o tamanho em bytes de algo
  \ Exemplo: a magnitude dessa string
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum tipo de conteúdo:
  \PAL
  Se o nome for "conteúdo", diga sim.
  \Se o nome for "alvo", diga sim.
  \CAL
  Se o nome for "target", diga sim.
  \Este comando é usado apenas com ponteiros (endereços de memória). 
  \ Serve pra saber para quais valores o ponteiro está apontando, ou seja, o conteúdo do ponteiro . 
  \"Um ponteiro de byte" ou "ponteiro do byte", por exemplo, refere-se ao endereço de um byte. 
  \"O conteúdo deste ponteiro do byte" refere-se, portanto aos dados no contidos no byte
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum tipo de endereçamento:
  \PAL
  \Se o nome for "paradeiro", diga sim.
  Se o nome for "endereçamento", diga sim.
  \ retorna o endereço do dado
  \CAL
  Se o nome for "whereabouts", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um nome é algum tipo de valid campo nome:
  Se o nome for algum tipo de magnitude, diga não.
  Se o nome for algum tipo de conteúdo, diga não.
  Se o nome for algum tipo de endereçamento, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está acompanhado por algum tipo de unidade de medida:
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o percorredor não estiver sobre algum tipo de nome starter, diga não.
  Examine um nome usando o percorredor.
  Encontre um type usando o nome e o catálogo de tipos.
  Se o type for inexistente, diga não.
  Se o nome não for "times", diga sim. \ special because times é um infix operator e uma unidade de medida
  \Se o nome não for "vezes", diga sim.
  Se o segmento inicial deste percorredor for o início of algum tipo de expression, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum tipo de nested double-quote:
  Se o segmento final deste percorredor começa com """""", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de possessive:
  Se o segmento final deste percorredor estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o single-quote byte, diga não. \ apóstrofo
  Se o percorredor estiver sobre algum tipo de possessive (type 1 - single-quote, s, non-glom-byte), diga sim.
  Se o percorredor estiver sobre algum tipo de possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de possessive (type 1 - single-quote, s, non-glom-byte):
  Se o segmento final deste percorredor não começa com "'s", diga não.
  Isole o percorredor.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for algum tipo de glom byte, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de possessive (type 2 - preceding s, single-quote, non-glom-byte):
  Isole o percorredor.
  Se o caractere inicial deste segmento final deste percorredor for o caractere inicial desta cópia da string original deste percorredor, diga não.
  Subtraia 1 desde o caractere inicial deste segmento final deste percorredor.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o s minúsculo ou o S maiúsculo, diga não.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for algum tipo de glom byte, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de simile:
  \ added for invisible turtle project ***
  Isole o percorredor.
  Se o segmento inicial deste percorredor for "like", diga sim.
  Se o segmento inicial deste percorredor não for "as", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor é o início of algum tipo de function:
  Se o detector de erros deste compilador estiver ativado, diga não.
  Se o segmento inicial deste percorredor for "Ponha", diga sim.
  \Se o segmento inicial deste percorredor não for algum tipo de atribua, diga não.
  Se o segmento inicial deste percorredor não for "atribua", diga não.
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o segmento inicial deste percorredor for algum tipo de possessive, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma espécie de contração usando uma segunda string (strings em português - "no"):
  Se a string não for "no", diga não.
  Se a segunda string for "say", diga não.
  Se a segunda string for "diga", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com alguma consoante e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for alguma consoante, diga não.
  Se a string não termina com a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com algum tipo de vogal e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for algum tipo de vogal, diga não.
  Se a string não termina com a segunda string, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com alguma vogal ou com alguma consoante:
  Se a string termina com algum tipo de vogal, diga sim.
  Se a string termina com alguma consoante, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string termina com alguma consoante:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for alguma consoante, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string termina com algum tipo de vogal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for algum tipo de vogal, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum operator de adição:
  \PAL
  Se a string for "mais", diga sim.
  \CAL
  Se a string for "plus", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de atribua: \ verbo de atribuição?
  \PAL
  \# Não precisa porque está como sinônimo, ver a rotina abaixo: 
  \"Etapas para que se posponha uma string para uma segunda string usando uma terceira string (para expandir contrações)"
  \Se a string for "colocar", diga sim.
  \CAL
  Se a string for "atribua", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operator de subtração:
  \PAL
  Se a string for "menos", diga sim.
  \CAL
  Se a string for "minus", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operator de multiplicação:
  \PAL
  Se a string for "vezes", diga sim.
  \CAL
  Se a string for "times", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operator de divisão:
  \PAL
  Se a string for "dividido", diga sim.
  \CAL
  Se a string for "divided", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum objeto indireto:
  \PAL
  Se a string for "via", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
  Se a string for "por", diga sim.
  \CAL
  Se a string for "by", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de palavra de concatenação:
  \PAL
  Se a string for "com", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
  Se a string for "de", diga sim.
  Se a string for "a", diga sim.
  Se a string for "seguida", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de operador de concatenação:
  \PAL
  \# operador de concatenação de strings tipo: "ABC" junto com "def" = "abcdef"
  \# em português poderia ser: "mais", "depois", "então" ou "em seguida".
  Se a string for "junto", diga sim. \ junto do/da, junto com o ...
  Se a string for "juntamente", diga sim. \ juntamente com o...
  Se a string for "seguido", diga sim. \ seguido do ....
  Se a string for "acompanhado", diga sim. \ acompanhado de... 

  Se a string for "em", diga sim.
  \Se a string for "&", diga sim.
  \CAL
  Se a string for "then", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de operador de atribuição de estruturas compostas:
  \PAL
  Se a string for "tem", diga sim.
  \CAL
  Se a string for "has", diga sim.
  Se a string for "have", diga sim.
  \Se a string for "possui", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de operador de atribuição simples:
  \PAL
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estarem", diga sim.
  Se a string for "possui", diga sim.
  \Se a string for "tem", diga sim.
  \CAL
  Se a string for "is", diga sim.
  Se a string for "are", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de operador de atribuição composto:
  \PAL
  Se a string for "igual", diga sim.
  \CAL
  Se a string for "equal", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de com:
  \PAL
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  Se a string for "que tem", diga sim.
  Se a string for "que têm", diga sim.
  Se a string for "que possui", diga sim.
  Se a string for "que possuem", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de artigo:
  Se a string for algum tipo de artigo indefinido, diga sim.
  Se a string for algum tipo de artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de conjunction:
  \PAL
  \# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  Se a string for "nem", diga sim.
  \CAL
  Se a string for "and", diga sim.
  Se a string for "both", diga sim.
  Se a string for "but", diga sim.
  Se a string for "either", diga sim.
  Se a string for "neither", diga sim.
  Se a string for "nor", diga sim.
  Se a string for "or", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

  \Etapas para que se determine se uma string é algum tipo de detector literal:
  \Se a string for "yes", diga sim.
  \Se a string for "no", diga sim.
  \[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de to:
  \PAL
  Se a string for "a", diga sim. \ this é questionable
  \CAL
  Se a string for "to", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de and:
  \PAL
  Se a string for "e", diga sim.
  \CAL
  Se a string for "and", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não. \repetido?

Etapas para que se determine se uma string é algum tipo de reverse-possessive function into:
  \PAL
  Se a string for "em", diga sim.
  Se a string for "para", diga sim.
  \CAL
  Se a string for "into", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se uma string é algum tipo de detector literal:
\Se a string for "si", diga sim.
\Se a string for "yes", diga sim.
\Se a string for "no", diga sim.
 \[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de deliberaçãor literal:
  \PAL
  Se a string for "sim", diga sim.
  Se a string for "positivo", diga sim.
  Se a string for "positivamente", diga sim.
  Se a string for "afirmativamente", diga sim.
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
  \CAL
  Se a string for "yes", diga sim.
  \Se a string for "yep", diga sim.
  \Se a string for "yea", diga sim.
  Se a string for "no", diga sim.
  \Se a string for "nay", diga sim.
  \Se a string for "nope", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de positive decider literal:
  \PAL
  Se a string for "sim", diga sim.
  Se a string for "positivo", diga sim.
  Se a string for "positivamente", diga sim.
  Se a string for "afirmativamente", diga sim.
  \CAL
  Se a string for "yes", diga sim.
  \Se a string for "yep", diga sim.
  \Se a string for "yea", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de resposta negativa:
  \PAL
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
  \CAL
  Se a string for "no", diga sim.
  \Se a string for "nay", diga sim.
  \Se a string for "nope", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de hex literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o cifrão, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de artigo definido:
  \PAL
  Se a string for "o", diga sim.
  Se a string for "a", diga sim.
  Se a string for "os", diga sim.
  Se a string for "as", diga sim.
  Se a string for algum tipo de pronome demonstrativo adjacente, diga sim.
  \CAL
  Se a string for "the", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de pronome demonstrativo:
  \CEL
  Se a string for algum tipo de pronome demonstrativo adjacente, diga sim.
  Se a string for algum tipo de pronome demonstrativo abrangente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de pronome demonstrativo adjacente:
  \CEL
  Se a string for "este", diga sim.
  Se a string for "esta", diga sim.
  Se a string for "estes", diga sim.
  Se a string for "estas", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de pronome demonstrativo abrangente:
  \CEL
  Se a string for "esse", diga sim.
  Se a string for "essa", diga sim.
  Se a string for "aquele", diga sim.
  Se a string for "aquela", diga sim.
  Se a string for "esses", diga sim.
  Se a string for "essas", diga sim.
  Se a string for "aqueles", diga sim.
  Se a string for "aquelas", diga sim.
  Se a string for "certo", diga sim.
  Se a string for "certa", diga sim.
  Se a string for "certos", diga sim.
  Se a string for "certas", diga sim.
  Se a string for "determinado", diga sim.
  Se a string for "determinada", diga sim.
  Se a string for "determinados", diga sim.
  Se a string for "determinadas", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de artigo definido:
  Se o percorredor estiver sobre algum tipo de preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum tipo de artigo definido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum tipo de artigo indefinido:
  Se o percorredor estiver sobre algum tipo de preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum tipo de preposição conectiva:
  Se o segmento inicial deste percorredor não for "a", diga não.
  Isole o percorredor. 
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum tipo de artigo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de artigo indefinido: \ esse aqui parece que não serve pra muita coisa
  \PAL
  Se a string for algum tipo de artigo indefinido português, diga sim.
  Se a string for algum tipo de pronome demonstrativo abrangente, diga sim.
  \CAL
  Se a string for algum tipo de artigo indefinido inglês, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de artigo indefinido inglês:
  \CAL
  Se a string for "an", diga sim.
  Se a string for "another", diga sim.
  Se a string for "some", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de artigo indefinido português: \ é aqui que se deve colocar o possessivo. descobri.
  \PAL
  Se a string for "um", diga sim.
  Se a string for "uma", diga sim.
  Se a string for "uns", diga sim.
  Se a string for "umas", diga sim.
  \Se a string for "outro", diga sim.
  \Se a string for "outra", diga sim.
  \Se a string for "algum", diga sim.
  \Se a string for "alguma", diga sim.
  \Se a string for "alguns", diga sim.
  \Se a string for "algumas", diga sim.
  Se a string for algum tipo de pronome demonstrativo abrangente, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de literal:
  Se a string for algum tipo de ponteiro literal, diga sim.
  Se a string for algum tipo de numeric literal, diga sim.
  Se a string for algum tipo de string literal, diga sim.
  \Se a string for algum tipo de detector literal, diga sim. ***
  Se a string for algum tipo de hex literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de mark:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum tipo de mark, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se uma string é algum tipo de unidade semântica string:
\Se a string estiver em branco, diga não.
\Se a string for "the", diga não.
\Se a string é algum tipo de artigo indefinido, diga não.
\Se a string é algum tipo de possessive, diga não.
\Se a string é algum tipo de literal, diga não.
\Se a string é algum tipo de mark, diga não.
\Se a string é algum tipo de symbol, diga não.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um percorredor está sobre algum tipo de unidade semântica string:
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Se o percorredor estiver sobre algum tipo de artigo definido, diga não.
  Se o percorredor estiver sobre algum tipo de artigo indefinido, diga não.
  Se o segmento inicial deste percorredor for algum tipo de possessive, diga não.
  Se o segmento inicial deste percorredor for algum tipo de literal, diga não.
  Se o segmento inicial deste percorredor for algum tipo de mark, diga não.
  Se o segmento inicial deste percorredor for algum tipo de symbol, diga não.
  Se o segmento inicial deste percorredor for "então", diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.



Etapas para que se determine se uma string é algum called:
  \PAL
  Se a string for "chamado", diga sim.
  Se a string for "chamada", diga sim.
  Se a string for "denominado", diga sim.
  Se a string for "denominada", diga sim.
  Se a string for "chamados", diga sim.
  Se a string for "chamadas", diga sim.
  Se a string for "denominados", diga sim.
  Se a string for "denominadas", diga sim.
  \Se a string for "conhecido como", diga sim.
  \Se a string for "conhecida como", diga sim.
  \CAL
  Se a string for "called", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de reference:
  \PAL
  Se a string for "(referência)", diga sim.
  \CAL
  Se a string for "(reference)", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de nome ender:
  \ compare com nome starter
  Se o segmento inicial deste percorredor for algum tipo de mark, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de symbol, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de artigo, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de conjunction, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de possessive, diga sim.
  Se o percorredor estiver sobre algum tipo de reverse-possessive, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de verb, diga sim.
  Se o segmento inicial deste percorredor for algum operator aritmético, diga sim.
  Se o percorredor estiver sobre algum tipo de preposition, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de qualifier, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de literal, diga sim.
  Se o segmento inicial deste percorredor for algum called, diga sim.
  \Se o segmento inicial deste percorredor for "equal", diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum tipo de operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga sim.
  \ Portuguese trouble makers
  Se o segmento inicial deste percorredor for algum tipo de advérbio de negação, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de nome starter:
  \ compare com nome ender
  Se o segmento inicial deste percorredor for algum tipo de mark, diga não.
  Se o segmento inicial deste percorredor for algum tipo de symbol, diga não.
  Se o segmento inicial deste percorredor for algum tipo de artigo, diga não.
  Se o segmento inicial deste percorredor for algum tipo de conjunction, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de possessive, diga não.
  Se o segmento inicial deste percorredor for algum tipo de verb, diga sim.
  Se o segmento inicial deste percorredor for algum operator aritmético, diga sim.
  Se o percorredor estiver sobre algum tipo de preposition, diga sim.
  Se o segmento inicial deste percorredor for algum tipo de qualifier, diga não.
  Se o segmento inicial deste percorredor for algum tipo de literal, diga não.
  Se o segmento inicial deste percorredor for algum called, diga sim.
  \Se o segmento inicial deste percorredor for "equal", diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum tipo de operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é algum tipo de advérbio de negação:
  \SAL
  Se a string for "não", diga sim.
  \Se a string for "nada", diga sim.
  \Se a string for "ainda", diga sim.
  \CAL
  \Se a string for "no", diga sim.
  Se a string for "not", diga sim.
  \Se a string for "cannot", diga sim.
  Se a string for "nothing", diga sim.
  Se a string termina com "n't", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum operator aritmético:
  \PAL
  Se a string for "mais", diga sim.
  Se a string for "menos", diga sim.
  Se a string for "vezes", diga sim.
  Se a string for "dividido", diga sim.
  Se a string for "depois", diga sim.
  Se a string for "seguido", diga sim.
  Se a string for "juntamente", diga sim.
  Se a string for "junto", diga sim.
  Se a string for "acompanhado", diga sim.
  \CAL
  Se a string for "plus", diga sim.
  Se a string for "minus", diga sim.
  Se a string for "times", diga sim.
  Se a string for "divided", diga sim.
  Se a string for "then", diga sim.

[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

\Etapas para que se determine se uma string é algum tipo de artigo indefinido inglês:
\Se a string for "a", diga sim.
\Se a string for "an", diga sim.
\Se a string for "another", diga sim.
\Se a string for "some", diga sim.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de pause:
  \PAL
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  \CAL
  Se a string for "and", diga sim.
  Se a string for "or", diga sim.
  \default
  Se a string for ",", diga sim.
  Se a string for ";", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de ponteiro literal:
  \PAL
  Se a string for "nulo", diga sim.
  Se a string for "nula", diga sim.
  Se a string for "nulos", diga sim.
  Se a string for "nulas", diga sim.
  Se a string for "inexistente", diga sim.
  Se a string for "inexistentes", diga sim.
  \CAL
  Se a string for "nil", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de possessive:
  Se a string for "'s", diga sim.
  Se a string for "'", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de preposition:
  Atribua o segmento inicial deste percorredor para um subtexto.
  \PAL
  Se o percorredor estiver sobre algum tipo de preposição conectiva, diga sim. \ "a" followed por um article for "to" em portuguese
  Se o subtexto for "abaixo", diga sim. \ para baixo
  Se o subtexto for "acima", diga sim. \ para cima
  Se o subtexto for "ante", diga sim. \ antes de
  Se o subtexto for "antes", diga sim. \ antes de
  Se o subtexto for "perante", diga sim. \ antes de
  Se o subtexto for "debaixo", diga sim. \ debaixo of
  Se o subtexto for "sob", diga sim. \ debaixo of
  Se o subtexto for "acerca", diga sim. \ near
  Se o subtexto for "próximo", diga sim. \ near
  Se o subtexto for "perto", diga sim. \ near
  Se o subtexto for "com", diga sim. \ com
  \Se o subtexto for "contendo", diga sim. \ com
  Se o subtexto for "como", diga sim. \ as
  Se o subtexto for "contra", diga sim. \ against
  \ Se o subtexto for "de", diga sim. \ reverse-possessive indicator 
  Se o subtexto for "dada", diga sim. \ given
  Se o subtexto for "dado", diga sim. \ given
  Se o subtexto for "dando", diga sim. \ given
  Se o subtexto for "gerando", diga sim. \ usando
  Se o subtexto for "resultando", diga sim. \ usando
  Se o subtexto for "retornando", diga sim. \ usando
  Se o subtexto for "desde", diga sim. \ since
  Se o subtexto for "depois", diga sim. \ after
  Se o subtexto for "durante", diga sim. \ during
  Se o subtexto for "em", diga sim. \ in
  Se o subtexto for "entre", diga sim. \ entre
  Se o subtexto for "até", diga sim. \ até que
  \Se o subtexto for "esquerda", diga sim. \ left
  Se o subtexto for "mediante", diga sim. \ through
  Se o subtexto for "para", diga sim. \ to
  Se o subtexto for "via", diga sim. \ by
  Se o subtexto for "segundo", diga sim. \ according
  Se o subtexto for "sem", diga sim. \ comout
  Se o subtexto for "então", diga sim.
  Se o subtexto for "sobre", diga sim. \ on
  Se o subtexto for "após", diga sim. \ after
  Se o subtexto for "depois", diga sim. \ after
  Se o subtexto for "usando", diga sim. \ using
  \Se o subtexto for "contendo", diga sim. \ using 
  Se o subtexto for "versus", diga sim. \ versus
  Se o subtexto for "via", diga sim. \ by
  Se o subtexto for "enquanto", diga sim. \ while
  Se o subtexto for "redefinindo", diga sim. \# 'sob' na redefinição de campos 
  Se o subtexto for "aproximadamente", diga sim.
  Se o subtexto for "cerca", diga sim.
  \CAL
  Se o subtexto for "aproximadamente", diga sim.
  Se o subtexto for "acima of ", diga sim.
  Se o subtexto for "across", diga sim.
  Se o subtexto for "after", diga sim.
  Se o subtexto for "against", diga sim.
  Se o subtexto for "all", diga sim.
  Se o subtexto for "alone", diga sim.
  Se o subtexto for "along", diga sim.
  Se o subtexto for "among", diga sim.
  Se o subtexto for "algum tipo de", diga sim.
  Se o subtexto for "anywhere", diga sim.
  Se o subtexto for "around", diga sim.
  \Se o subtexto for "as", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "away", diga sim.
  Se o subtexto for "back", diga sim.
  Se o subtexto for "backward", diga sim.
  Se o subtexto for "backwards", diga sim.
  Se o subtexto for "antes de", diga sim.
  Se o subtexto for "beginning", diga sim.
  Se o subtexto for "behind", diga sim.
  Se o subtexto for "debaixo of", diga sim.
  Se o subtexto for "beneath", diga sim.
  Se o subtexto for "beside", diga sim.
  Se o subtexto for "entre", diga sim.
  Se o subtexto for "beyond", diga sim.
  Se o subtexto for "bigger", diga sim.
  Se o subtexto for "by", diga sim.
  Se o subtexto for "close", diga sim.
  Se o subtexto for "deep", diga sim.
  Se o subtexto for "diagonally", diga sim.
  Se o subtexto for "para baixo", diga sim.
  Se o subtexto for "downward", diga sim.
  Se o subtexto for "ending", diga sim.
  Se o subtexto for "everywhere", diga sim.
  Se o subtexto for "except", diga sim.
  Se o subtexto for "finishing", diga sim.
  Se o subtexto for "facing", diga sim.
  \Se o subtexto for "for", diga sim.
  Se o subtexto for "por", diga sim.
  Se o subtexto for "forward", diga sim.
  Se o subtexto for "from", diga sim.
  Se o subtexto for "given", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "high", diga sim.
  Se o subtexto for "in", diga sim.
  Se o subtexto for "inside", diga sim.
  Se o subtexto for "into", diga sim.
  Se o subtexto for "en", diga sim.
  Se o subtexto for "larger", diga sim.
  Se o subtexto for "leaning", diga sim.
  Se o subtexto for "left", diga sim.
  Se o subtexto for "leftward", diga sim.
  Se o subtexto for "leftways", diga sim.
  Se o subtexto for "like", diga sim.
  Se o subtexto for "limiting", diga sim.
  Se o subtexto for "long", diga sim.
  Se o subtexto for "near", diga sim.
  Se o subtexto for "of", diga sim.
  Se o subtexto for "off", diga sim.
  Se o subtexto for "on", diga sim.
  Se o subtexto for "only", diga sim.
  Se o subtexto for "onto", diga sim.
  Se o subtexto for "out", diga sim.
  Se o subtexto for "outside", diga sim.
  Se o subtexto for "over", diga sim.
  Se o subtexto for "past", diga sim.
  Se o subtexto for "pointing", diga sim.
  Se o subtexto for "devolvendo", diga sim.
  Se o subtexto for "right", diga sim.
  Se o subtexto for "rightward", diga sim.
  Se o subtexto for "rightways", diga sim.
  Se o subtexto for "shorter", diga sim.
  Se o subtexto for "sideway", diga sim.
  Se o subtexto for "sideways", diga sim.
  Se o subtexto for "similar", diga sim.
  Se o subtexto for "smaller", diga sim.
  Se o subtexto for "somewhere", diga sim.
  Se o subtexto for "slantwise", diga sim.
  Se o subtexto for "slantway", diga sim.
  Se o subtexto for "slantways", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se o subtexto for "tall", diga sim.
  Se o subtexto for "taller", diga sim.
  Se o subtexto for "thru", diga sim.
  Se o subtexto for "through", diga sim.
  Se o subtexto for "throughout", diga sim.
  Se o subtexto for "to", diga sim.
  Se o subtexto for "toward", diga sim.
  Se o subtexto for "towards", diga sim.
  Se o subtexto for "under", diga sim.
  Se o subtexto for "underneath", diga sim.
  Se o subtexto for "até que", diga sim.
  Se o subtexto for "unto", diga sim.
  Se o subtexto for "para cima", diga sim.
  Se o subtexto for "upward", diga sim.
  Se o subtexto for "upon", diga sim.
  Se o subtexto for "using", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "while", diga sim.
  Se o subtexto for "wide", diga sim.
  Se o subtexto for "com", diga sim.
  Se o subtexto for "within", diga sim.
  Se o subtexto for "without", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de preposition:
  Se a string for "aproximadamente", diga sim.
  Se a string for "acima of ", diga sim.
  Se a string for "across", diga sim.
  Se a string for "after", diga sim.
  Se a string for "against", diga sim.
  Se a string for "all", diga sim.
  Se a string for "alone", diga sim.
  Se a string for "along", diga sim.
  Se a string for "among", diga sim.
  Se a string for "algum tipo de", diga sim.
  Se a string for "anywhere", diga sim.
  Se a string for "around", diga sim.
  \Se a string for "as", diga sim.
  Se a string for "sob", diga sim.
  Se a string for "away", diga sim.
  Se a string for "back", diga sim.
  Se a string for "backward", diga sim.
  Se a string for "backwards", diga sim.
  Se a string for "antes de", diga sim.
  Se a string for "beginning", diga sim.
  Se a string for "behind", diga sim.
  Se a string for "debaixo of", diga sim.
  Se a string for "beneath", diga sim.
  Se a string for "beside", diga sim.
  Se a string for "entre", diga sim.
  Se a string for "beyond", diga sim.
  Se a string for "bigger", diga sim.
  Se a string for "by", diga sim.
  Se a string for "close", diga sim.
  Se a string for "deep", diga sim.
  Se a string for "diagonally", diga sim.
  Se a string for "para baixo", diga sim.
  Se a string for "downward", diga sim.
  Se a string for "ending", diga sim.
  Se a string for "everywhere", diga sim.
  Se a string for "except", diga sim.
  Se a string for "finishing", diga sim.
  Se a string for "facing", diga sim.
  \Se a string for "for", diga sim.
  Se a string for "por", diga sim.
  Se a string for "forward", diga sim.
  Se a string for "from", diga sim.
  Se a string for "given", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "high", diga sim.
  Se a string for "in", diga sim.
  Se a string for "inside", diga sim.
  Se a string for "into", diga sim.
  Se a string for "larger", diga sim.
  Se a string for "leaning", diga sim.
  Se a string for "left", diga sim.
  Se a string for "leftward", diga sim.
  Se a string for "leftways", diga sim.
  Se a string for "like", diga sim.
  Se a string for "limiting", diga sim.
  Se a string for "long", diga sim.
  Se a string for "near", diga sim.
  Se a string for "of", diga sim.
  Se a string for "off", diga sim.
  Se a string for "on", diga sim.
  Se a string for "only", diga sim.
  Se a string for "onto", diga sim.
  Se a string for "out", diga sim.
  Se a string for "outside", diga sim.
  Se a string for "over", diga sim.
  Se a string for "past", diga sim.
  Se a string for "pointing", diga sim.
  Se a string for "devolvendo", diga sim.
  Se a string for "right", diga sim.
  Se a string for "rightward", diga sim.
  Se a string for "rightways", diga sim.
  Se a string for "shorter", diga sim.
  Se a string for "sideway", diga sim.
  Se a string for "sideways", diga sim.
  Se a string for "similar", diga sim.
  Se a string for "smaller", diga sim.
  Se a string for "somewhere", diga sim.
  Se a string for "slantwise", diga sim.
  Se a string for "slantway", diga sim.
  Se a string for "slantways", diga sim.
  Se a string for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se a string for "tall", diga sim.
  Se a string for "taller", diga sim.
  Se a string for "thru", diga sim.
  Se a string for "through", diga sim.
  Se a string for "throughout", diga sim.
  Se a string for "to", diga sim.
  Se a string for "toward", diga sim.
  Se a string for "towards", diga sim.
  Se a string for "under", diga sim.
  Se a string for "underneath", diga sim.
  Se a string for "até que", diga sim.
  Se a string for "unto", diga sim.
  Se a string for "para cima", diga sim.
  Se a string for "upward", diga sim.
  Se a string for "upon", diga sim.
  Se a string for "using", diga sim.
  Se a string for "via", diga sim.
  Se a string for "while", diga sim.
  Se a string for "wide", diga sim.
  Se a string for "com", diga sim.
  Se a string for "within", diga sim.
  Se a string for "without", diga sim.
  Se a string for "depois", diga sim. \ depois de
  Se a string for "desde", diga sim. 
  Se a string for "aproximadamente", diga sim.
  Se a string for "cerca", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de qualifier:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o parênteses esquerdo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de reverse-possessive:
  Se a string for "de", diga sim.
  \Se a string for "do", diga sim. \ short por "de o", expanded em "compile um termo usando um percorredor e um campo nome (possessivo reverso)"
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um percorredor está sobre algum tipo de reverse-possessive:
  Isole o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum tipo de pronome demonstrativo, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de string literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for as aspas duplas, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de symbol:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum tipo de symbol, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de verb:
  \PAL
  Se a string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
  Se a string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
  Se a string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
  Se a string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
  Se a string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" para non-tempora state
  Se a string for "ser", diga sim. \ "be"
  Se a string for "for", diga sim. \ "be"
  Se a string for "forem", diga sim. \ "be"
  Se a string for "estiver", diga sim. \ "be"
  Se a string for "estiverem", diga sim. \ "be"
  Se a string for "estamos", diga sim. \ "be"  
  Se a string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, perm.
  Se a string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, temp.
  Se a string for "são", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, perm.
  Se a string for "estão", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, temp.
  Se a string for "foi", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, perm.
  Se a string for "estava", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, temp.
  Se a string for "foram", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, perm.
  Se a string for "estavam", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, temp.
  Se a string for "será", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, perm.
  Se a string for "estará", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, temp.
  Se a string for "serão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, perm.
  Se a string for "estarão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, temp.
  \Se a string for "seja", diga sim. 
  Se a string for "supera", diga sim. \ beats, exceeds
  Se a string for "superam", diga sim. \ beats, exceeds
  Se a string for "excede", diga sim. \ beats, exceeds
  Se a string for "excedem", diga sim. \ beats, exceeds
  Se a string for "pode", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
  Se a string for "puder", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
  Se a string for "puderem", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
  Se a string for "podem", diga sim. \ they "can" cannot \ can't: not used em CAL (3pp) added just em case 
  Se a string for "poderia", diga sim. \ it "could" could not \ couldn't: not used em CAL (3ps) added just em case
  Se a string for "poderia", diga sim. \ they "could" could not \ couldn't: not used em CAL (3pp) added just em case
  Se a string for "podemos", diga sim. \ we "could" could not \ couldn't: only once em Noodle (1pp) "Etapas para que se determine se we could encontre um ponteiro:"
  Se a string for "tem", diga sim. \ it "has" used em type definitions; (3ps) present
  Se a string for "têm", diga sim. \ they "have" used em type definitions; (3pp) present
  Se a string for "ter", diga sim. \ used em type definitions
  Se a string for "possui", diga sim. \ it "has" used em type definitions; (3ps) present
  Se a string for "possuem", diga sim. \ they "have" used em type definitions; (3pp) present
  Se a string for "possuir", diga sim. \ used em type definitions
  \\ trouble makers
  Se a string for "inicia", diga sim. \ "begins" does not inicie \ doesn't inicie
  Se a string for "iniciar", diga sim. \ "begins" does not inicie \ doesn't inicie
  Se a string for "começa", diga sim. \ "começa" não começa \ doesn't start: I hear um yes
  Se a string for "começar", diga sim. \ "começa" não começa \ doesn't start: I hear um yes
  Se a string for "termina", diga sim. \ "ends" does not end \ doesn't end
  Se a string for "terminar", diga sim. \ "ends" does not end \ doesn't end
  Se a string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
  Se a string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
  Se a string for "parece", diga sim. \ "looks" does not look \ doesn't look
  Se a string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
  Se a string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
  Se a string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
  \CAL
  Se a string for "are", diga sim. \ são not \ aren't
  Se a string for "be", diga sim. \
  Se a string for "can", diga sim. \ cannot \ can't
  \Se a string for "cannot", diga sim.
  \Se a string for "could", diga sim. \ could not \ couldn't
  \Se a string for "do", diga sim. \ does not \ don't
  Se a string for "does", diga sim. \ does not \ doesn't
  Se a string for "is", diga sim. \ não for \ isn't
  Se a string for "may", diga sim. \ may not \ mayn't
  Se a string for "should", diga sim. \ não deveria \ shouldn't
  Se a string for "was", diga sim. \ was not \ wasn't
  Se a string for "will", diga sim. \ will not \ won't
  Se a string for "would", diga sim. \ would not \ wouldn't
  Se a string for "has", diga sim. \ used em type definitions
  Se a string for "have", diga sim. \ used em type definitions
  Se a string termina com "n't", diga sim.
  \\ trouble makers
  Se a string for "begins", diga sim. \ does not inicie \ doesn't inicie
  Se a string for "ends", diga sim. \ does not end \ doesn't end
  Se a string for "looks", diga sim. \ does not look \ doesn't look
  Se a string for "needs", diga sim. \ does not need \ doesn't need
  Se a string for "starts", diga sim. \ não começa \ doesn't start
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o enunciado de alguma rotina ou variável:
  \PAL
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.
  \CAL
  Se a string for "to", diga sim.
  \default
  Se a string for algum tipo de artigo indefinido, diga sim.
  Se a string for algum tipo de artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando condicional:
  \PAL
  Se a string for "se", diga sim.
  Se a string for "quando", diga sim.
  \CAL
  Se a string for "if", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de proteção:
  \PAL
  Se a string for "privatize", diga sim.
  \Se a string for "reserve", diga sim. \-> complicado pois o termo também se refere à reservar (alocar) memória
  \Se a string for "separe", diga sim. \-> separar também é sinônimo de repartir. 
  Se a string for "isole", diga sim.
  Se a string for "conserve", diga sim.
  Se a string for "derive", diga sim.
  \CAL
  \Se a string for "privatize", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de percorrimento:
  \PAL
  Se a string for "percorra", diga sim.
  Se a string for "comece", diga sim.
  \Se a string for "ciclo", diga sim.
  \Se a string for "laço", diga sim. \# muito usado em pseudo-código
  \CAL
  Se a string for "loop", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de interrupção de repetições:
  \PAL
  Se a string for "pare", diga sim.
  Se a string for "termine", diga sim.
  \Se a string for "pare de percorrer", diga sim.
  \Se a string for "saia", diga sim.
  \Se a string for "saia do laço", diga sim.
  \CAL
  Se a string for "break", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de abandono de rotina:
  Se a string for "cancele", diga sim. \ analisar
  Se a string for "saia", diga sim.
  Se a string for "retorne", diga sim.
  Se a string for "desista", diga sim.
  Se a string for "abandone", diga sim.
  Se a string for "fuja", diga sim.
  Se a string for "retire-se", diga sim.
  Se a string for "saia", diga sim.
  \Se a string for "cancele a operação", diga sim.
  \Se a string for "interrompa a operação", diga sim.
  \Se a string for "advirta", diga sim.
  \Se a string for "anuncie", diga sim.
  \Se a string for "avise", diga sim.  
  Se a string for "desconsidere.", diga sim.
  \Se a string for "deixa quieto", diga sim.
  \Se a string for "deixe quieto", diga sim.
  \Se a string for "e mais nada", diga sim.
  \Se a string for "e pronto", diga sim.
  \Se a string for "e só", diga sim.
  Se a string for "fim", diga sim.
  \Se a string for "fimse", diga sim.
  Se a string for "ignore", diga sim.
  \Se a string for "informe", diga sim.
  Se a string for "prossiga", diga sim.
  Se a string for "pronto", diga sim.
  \Se a string for "siga adiante", diga sim.
  Se a string for "terminamos", diga sim.
  \Se a string for "termine", diga sim.
  \CAL
  Se a string for "exit", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de repetição:
  \PAL
  Se a string for "recomece", diga sim. 
  \Se a string for "reinicie", diga sim. 
  Se a string for "recomece", diga sim. 
  \CAL
  Se a string for "repeat", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de confirmação ou negação:
  \PAL
  Se a string for "diga", diga sim. \# modo imperativo
  Se a string for "responda", diga sim. \# modo imperativo
  Se a string for "informe", diga sim. \# modo imperativo
  \Se a string for "decida", diga sim. \ para usar como "decida afirmativamente/FAVORAVELMENTE e decida negativamente/desfavoravelmente"
  \CAL
  Se a string for "say", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum comando de deliberação:
  \PAL
  \Se a string for "decidir", diga sim.
  Se a string for "decida", diga sim. \estou pensando em retirar devido o comentário da rotina anterior
  \Se a string for "escolha", diga sim.
  Se a string for "determine", diga sim.
  Se a string for "conclua", diga sim.
  Se a string for "esclareça", diga sim.
  \Se a string for "descubra", diga sim. \-> termo ruim.  pode ser confundido com "remover a cobertura de algo"
  \Se a string for "mostre", diga sim. \-> termo ruim. Pode ser confundido com "exibir"
  \Se a string for "demonstre", diga sim. \-> pode ser melhorado
  Se a string for "analise", diga sim.
  \CAL
  Se a string for "decide", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum chamada de biblioteca externa:
  \PAL
  Se a string for "chame", diga sim.
  Se a string for "invoque", diga sim.
  Se a string for "acione", diga sim.
  Se a string for "processe", diga sim.
  Se a string for "informe", diga sim.\ no caso de comandos como "informe os parâmetros x e y e z para a função "FunctionName" da biblioteca "MyLibrary.dll"
  \CAL
  Se a string for "Call", diga sim.
  \ Envie o parâmetro "nome" para a função "SetNome". Se a função SetNome produzir um código  diferente de 0, produza um relatório de erros a partir deste código.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de point:
  \PAL
  Se a string for "aponte", diga sim.
  Se a string for "direcione", diga sim.
  Se a string for "redirecione", diga sim.
  \Se a string for "mire", diga sim.
  \Se a string for "dirija-se à", diga sim.
  \Se a string for "refira-se à", diga sim.
  \Se a string for "referencie", diga sim.
  \Se a string for "faça referência à", diga sim.
  \Se a string for "indique", diga sim.
  \Se a string for "realce", diga sim.
  \CAL
  Se a string for "point", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é algum tipo de reutilização de rotina:
  \ Employs servem para usar uma rotina 
  \exemplos:
  \To raise a flag: Employ set a flag.
  \To decide if a flag is raised: Employ decide if a flag is set.
  \ Acho que uma boa tradução seria:
  \ Etapas para que se ative um detector: Faça uso da rotina "defina um detector".
  \ (troquei a palavra "flag" por "detector" e a palavra "raise" por "ativar"
  \ então ao invés de "empregue" usaríamos "faça uso da rotina" ou "lance mão da rotina"
  \Estou pensando em retirar isso já que já temos a sobrecarga de métodos disponível
  \PAL
  Se a string for "empregue", diga sim.
  \CAL
  Se a string for "employ", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é alguma palavra ignorável:
  \Nova rotina 
  Se a string for "already", diga sim.
  Se a string for "still", diga sim.
  Se a string for "yet", diga sim.
  Se a string for "já", diga sim.
  Se a string for "ainda", diga sim.
  \Se a string for "que", diga sim.
  \Se a string for "se", diga sim.
  [more noise palavras here]
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum tipo de expression:
  Se a string for tipo de sinal aritmético, diga sim.
  Se a string for algum tipo de artigo indefinido, diga sim.
  Se a string for algum tipo de artigo definido, diga sim.
  Se a string for algum tipo de literal, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum tipo de global:
  Se a string for algum tipo de artigo definido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum tipo de new local:
  Se a string for algum tipo de artigo indefinido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum tipo de optional info:
  \PAL
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  \CAL
  Se a string for "to", diga sim.
  Se a string for "com", diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum tipo de rotina:
  \PAL
  Se a string for "Passos", diga sim.
  Se a string for "Etapas", diga sim.
  Se a string for "Etapas para que se", diga sim. \verificar depois
  Se a string for "Passos necessários para que se", diga sim.
  \CAL
  Se a string for "to", diga sim. \verificar se pode ser excluído
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum tipo de statement:
  Se a string for o enunciado de alguma rotina ou variável, diga não.
  Se a string for algum tipo de literal, diga não.
  Se a string for algum tipo de mark, diga não.
  Se a string estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se uma string é o início of algum tipo de type:
  Se a string for algum tipo de artigo indefinido, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string é o início of algum tipo de variável:
  Se a string for algum tipo de artigo definido, diga sim.
  \Se a string for "do", diga sim. \ this é iffy, here por reverse-possessives
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se uma string has algum tipo de stressed vogal:
  Isole a string.
  Comece. [a executar o código abaixo]
    Se a string estiver em branco, diga não.
    Se o conteúdo deste caractere final desta string for algum tipo de stressed vogal, diga sim.
    Subtraia 1 desde o caractere final desta string.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se uma termo está vazia;
Etapas para que se determine se uns termo estão vazias;
Etapas para que se determine se uns termo estão vazios;
Etapas para que se determine se um termo está vazio:
  Se a variável deste termo não for inexistente, diga não.
  Se a phrase deste termo não estiver em branco, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

Etapas para que se determine se um type pode ser reduzido para uma string using o base nome:
  Se o type for inexistente, diga não.
  Se o nome deste type for a string, diga sim.
  Se o cooking detector deste type estiver ativo, diga não.
  Ligue o cooking detector deste type.
  Encontre um base type usando o base nome deste type e o catálogo de tipos.
  Se o base type for inexistente, desative o cooking detector deste type; diga não.
  Se o base type puder ser reduzido para a string using o base nome, desative o cooking detector deste type; diga sim.
  Desative o cooking detector deste type.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um type pode ser reduzido para um type nome:
  Se o type for inexistente, diga não.
  Isole o type.
  Comece. [a executar o código abaixo]
    Se o type for inexistente, diga não.
    Se o nome deste type for o type nome, diga sim.
    Se o base type deste type for o type, diga não.
    Atribua o base type deste type ao type.
  Recomece. [percorra novamente o código acima]

Etapas para que se determine se um type é algum tipo pré-definido:
  Se o type for inexistente, diga não.
  Se o type for o base type deste type, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um type é value pushable:
  Se o type for inexistente, diga não.
  Se a quantidade de caracteres deste type for 4, diga sim.
  Se a quantidade de caracteres deste type for 2, diga sim.
  Se a quantidade de caracteres deste type for 1, diga sim.
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um type deveria ser finalizado:[se o compilador deveria liberar a memória alocada para algum tipo]
  \The phrase "should be finalized" means "ought to be/needs to be automatically deallocated".
  Se o type for inexistente, diga não.
  Se o type puder ser reduzido para "subtexto", diga não.\  substrings point to (parts of) real strings that get deallocated elsewhere
  Se o type puder ser reduzido para "string", diga sim.\ the normal case for strings
  Se o type puder ser reduzido para "texto", diga sim.\ the normal case for strings
  Se os campos deste type deveriam ser finalizados, diga sim.\ this is for strings inside records
[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se determine se um type deveria ser ignorado:  [ou seja, o compilador não deveria finalizar esse tipo de forma automática]
  \ ie, can be destroyed/needs a destroy routine generated for it
  \The phrase "should be forgotten" means "ought to be forgotten" which really means "needs to have a destroy routine automatically generated for it". 
  \See page 93 of the manual.
  Se o type for inexistente, diga não.
  \PAL
  \Se o nome deste type for "elemento", diga não.
  \Se o nome deste type for "elementos", diga não.
  \CAL
  Se o nome deste type for "coisa", diga não. \ no, because this is the built-in type which we don't ever allocate or destroy, it exists so we can "magically" add next and previous fields to anything defined as a "thing"
  Se o nome deste type for "coisas", diga não. \ no, because this is the built-in type we "magically" generate to anchor lists of things, same as above of .
  Se o type puder ser reduzido para "coisas", diga sim. \ yes, because (though it seems to contradict the line immediately above of ) this is a an actual list of things that we can destroy, for example "some pages".
  Se o type não puder ser reduzido para "ponteiro", diga não. \ \ no, because a pointer variable is a static variable (it is the address in the variable that is dynamic); the pointer variable itself is not something that can be dynamically allocated, so no destroy is necessary
  Se o conteúdo type deste type for inexistente, diga não. \ no, because it's a pointer to nothing, so there's nothing to destroy.
  Se o conteúdo type deste type não puder ser reduzido para "ponteiro", diga sim.\ yes, because it's a pointer to something allocated, not a pointer to another pointer. Pointers to pointers are handled with the next recursive line
  Se o conteúdo type deste type não deveria ser ignorado, diga não.\ no, because it's a pointer to something that shouldn't be destroyed. For example, a pointer to a thing
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.\ The last condition is the hardest to wrap one's head around since it is recursive.

Etapas para que se determine se uma variável está duplicada em umas variáveis:
  Obtenha uma segunda variável desde as variáveis.
  Se a segunda variável for inexistente, diga não.
  Se o nome desta segunda variável estiver em branco, recomece.
  Se a segunda variável for a variável, recomece.
  Se o nome desta segunda variável for o nome desta variável, diga sim.
  Recomece. [percorra novamente o código acima]

Um DOS header é um estrutura com
  Uma word denominada Signature, \\ Uma Word . Ela contém um "número mágico" que serve pra dizer se esse é realmente um arquivo do MS-DOS;
  \\ O valor desta word deve ser 5A4DH (com o 4DH vindo primeiro).
  \\ Esses dois bytes representam a string "MZ", iniciais de Mark Zibowski, 
  \\ nome de um funcionário da Microsoft na época em que o formato do arquivo foi projetado.
  Uma word denominada NumberOfBytesOnLastPage, \\A última página do cabeçalho DOS pode conter de 1 a 512 bytes
  \\Esta word indica o número de bytes realmente usados na última página,  
  \\ uma página inteira é representada pelo valor 0 (já que a última página nunca estará vazia).
  Uma word denominada NumberOfPages, \\ File Pages.
  \\Esta word contém uma contagem do número de páginas necessárias para armazenar o arquivo.
  \\Por exemplo, se o arquivo contiver 1024 bytes, essa word conterá 0002H;
  \\se o arquivo contiver 1025 bytes, esta word conterá 0003H.
  \\O campo Tamanho da última página é usado para determinar o número de bytes válidos na página final.
  \\Portanto, se o arquivo contiver 1024 bytes, o campo Tamanho da última página conterá 0000H, 
  \\porque nenhum byte poderá ser extrapolado para a página final mesmo que parcialmente usada.
  \\Se o arquivo contiver 1025 bytes, o campo Tamanho da última página conterá 0001H, 
  \\porque a página final contém apenas um byte válido (o 1025º byte).
  Uma word denominada Relocations,\\ Itens de realocação.
  \\ Esta word fornece o número de entradas que existem na tabela de indicadores de realocação.
  \\ É perfeitamente adequado que este valor seja zero, nos casos em que não há entradas de realocação.
  Uma word denominada SizeOfHeaderInParagraphs,\\ Parágrafos do cabeçalho.
  \\ Esta palavra dá o tamanho do cabeçalho .EXE em paragrafos.
  \\ Indica o deslocamento da imagem compilada / montada e vinculada do programa (o módulo de carregamento) dentro do arquivo .EXE.
  \\ O tamanho do módulo de carregamento pode ser deduzido subtraindo este valor (convertido em bytes) 
  \\do tamanho geral do arquivo derivado da combinação dos valores de Páginas de arquivo e Tamanho da última página.
  \\ O cabeçalho sempre abrange um número par de parágrafos.
  Uma word denominada MinimumExtraParagraphsNeeded,
  \\ Esta word indica o número mínimo de parágrafos que o programa requer para iniciar a execução.
   \\ Isso é um acréscimo à memória necessária para armazenar o módulo de carregamento.
   \\ Este valor normalmente representa o tamanho total de algum tipo de dados não inicializados e / ou segmentos de pilha que estão ligados no final de um programa.
   \\ Este espaço não é incluído diretamente no módulo de carregamento, uma vez que não há valores de inicialização particulares e isso simplesmente desperdiçaria espaço em disco.
  Uma word denominada MamixmumExtraParagraphsNeeded,  \\ MAXALLOC.
  \\This word indicates the maximum number of parágrafos that the program would like allocated para it before it begins execution.
  \\This indicates additional memory over and acima of that required by the load module and the value specified by MINALLOC.
  \\If the request cannot be satisfied, the program is allocated as much memory as is available.
  Uma word denominada InitialRelativeSS,  \\ Initial SS value.
  \\This word contains the paragraph address of the stack segment relative para the start of the load module.
  \\At load time, this value is relocated by adding the address of the start segment of the program para it, 
  \\and the resulting value is placed em the SS register before the program is started.
  \\In DOS, the start segment of the program is the first segment boundary em memory after the PSP.
  Uma word denominada InitialSP,  \\ Initial SP value.
  \\This word contains the absolute value that must be loaded para the SP register before the program is given control.
  \\Since the actual stack segment is determined by the loader, and this is merely a value within that segment, it does not need to be relocated.
  Uma word denominada InitialChecksum,  \\ Complemented Checksum.
  \\This word contains a checksum of the contents of the .EXE arquivo.
  \\ Its value is rarely checked, but its purpose is to ensure the integrity of the data within the arquivo.
  \\ Full details of how it is calculated appear em the section sobre checksum calculation.
  Uma word denominada InitialIP,  \\ Initial IP value.
  \\This word contains the absolute value that should be loaded para the IP register in order para transfer control para the program.
  \\Since the actual código segment is determined by the loader, and this is merely a value within that segment, it does not need para be relocated.
  Uma word denominada InitialiRelativeCS,   \\ Pre-relocated initial CS value.
  \\ This word contains the initial value, relative para the start of the load module, that should be placed em the CS register in order to transfer control para the program.
  \\ At load time, this value is relocated by adding the address of the start segment of the program to it, 
  \\ and the resulting value is placed em the CS register when control is transferred.
  Uma word denominada AddressOfRelocationTableInFile, \ 
  \\ O AddressOfRelocationTableInFile é um ponteiro [que aponta] para a tabela de tamanho variável de DLLs necessária para este programa.
  \\ Relocation table offset.
  \\ This word gives the offset desde the start of the arquivo para the relocation pointer table.
  \\ This value must be used para locate the relocation pointer table (rather than assuming a fixed location) 
  \\because variável-length information pertaining para program overlays can occur before this table, causing its position para vary.
  \\A value of 40H em this campo generally indicates a different kind of executable arquivo, not a DOS "MZ" type.
  Uma word denominada OverlyNumber,
  \\ Overlay number.
  \\ This word is normally set para 0000H, because few programs actually have overlays.
  \\It changes only em files containing programs that use overlays; see the note debaixo of.
  8 bytes denominados ReservedBytes, \\ Specifies Reserved words for the program (known em winnt.h as e_res[4]), usually set para zero by the linker.
  \\In this case, just use a single reserved1 set para zero; if not zero create four reserved1 com the correct value.
Uma word denominada OEM_Identifier, \\ Specifies the identifier for the OEM for e_oeminfo.
Uma word denominada OEM_Info, \\ Specifies the OEM information for a specific value of e_oeminfo.
  20 bytes denominados ReservedWords, \\ Specifies Reserved words for the program (known em winnt.h as e_res[10]), usually set para zero by the linker.
  \\In this case, just use a single reserved1 set para zero; if not zero create ten reserved1 com the correct value.
  Um número denominado Address_Of_PE_Header_In_File.   \ O Address_Of_PE_Header_In_File é um ponteiro [que aponta] para o PE Header, 
  \Uma versão revisada e estendida do Cabeçalho DOS introduzida com o advento do Windows.
  \Os outros 16 campos do cabeçalho DOS não são usados.

Etapas para que se eliminate duplicate nicknames desde umas variáveis:
  Crie um catálogo usando 101.
  Eliminate duplicate nicknames desde as variáveis usando o catálogo.
  Destrua o catálogo.

Etapas para que se eliminate duplicate nicknames desde umas variáveis usando um catálogo:
  Se o catálogo for inexistente, retorne.
  Comece. [a executar o código abaixo]
    Obtenha uma variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Eliminate duplicate nicknames usando a variável e o catálogo.
  Recomece. [percorra novamente o código acima]

Etapas para que se eliminate duplicate nicknames usando uma variável e um catálogo:
  Se a variável for inexistente, retorne.
  Se o catálogo for inexistente, retorne.
  Encontre uma segunda variável usando o nickname desta variável e o catálogo.
  Se a segunda variável for inexistente, encontre a segunda variável usando o nome desta variável e o catálogo.
  Se a segunda variável for inexistente, catalogue a variável usando o nickname desta variável e o catálogo; retorne.
  Limpe o nickname desta segunda variável.
  Limpe o nickname desta variável.

  

An entry é uma coisa com
  Um nome endereço,
  Um previamente calculado endereço, \ consulte https://en.wikipedia.org/wiki/Thunk e 
  \http://ftp.informatik.rwth-aachen.de/jargon300/thunk.html para mais informações
  \ Em programação de computador , um previamente calculado é uma sub-rotina usada para injetar um cálculo em outra sub-rotina. 
  \Thunks são usados principalmente para atrasar um cálculo até que seu resultado seja necessário ou para inserir operações no início ou no final de outra sub-rotina. 
  \Eles têm muitos outros usos na geração de código do compilador e em programação modular .
  Um nome,
  Um endereço.

Uma expression é um termo.

Etapas para que se extend uma string com uma segunda string:
  Se a segunda string estiver em branco, retorne.
  Se a string não estiver em branco, posponha o caractere de espaço para a string.
  Posponha a segunda string para a string.

  
Um campo é uma variável.

Um campo termo é um estrutura com
  Um dereference detector,
  Um campo (reference),
  Uma function rotina (reference),
  Um push detector.

Etapas para que se finalize o compilador:
  Destrua o catálogo de rotinas úteis.
  Destrua o catálogo geral de rotinas.
  Destrua o catálogo de variáveis hexadecimais.
  Destrua o catálogo de variáveis globais.
  Destrua o catálogo de tipos.
  Destrua os imports.
  Destrua as rotinas.
  Destrua os literals.
  Destrua os globals.
  Destrua os types.
  Destrua os sources files.

  

Etapas para que se encontre um entry usando uma string e uns entries:
  Esvazie a entry.
  Comece. [a executar o código abaixo]
    Obtenha a entry desde o entries.
    Se a entry for inexistente, retorne.
    Se o nome desta entry for a string, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um campo termo usando um phrase e um type e um nome:
  Limpe o campo termo.
  Encontre o campo termo usando o type e o nome.
  Se o campo deste campo termo não for inexistente, retorne.
  Se a phrase não estiver em branco, encontre uma rotina usando "atribua" e a phrase e "'s " junto com o nome e "para".
  Se a rotina não for inexistente, atribua a rotina à function deste campo termo; retorne.
  Se o type for inexistente, retorne.
  Encontre a rotina usando "atribua" e o type e "'s " junto com o nome e "para".
  Se a rotina não for inexistente, ative o push detector deste campo termo; atribua a rotina ao function deste campo termo; retorne.
  \  code below for looking deep within pointers - a debatable feature
  \ Se o conteúdo type deste type não for inexistente, encontre a rotina usando "atribua" e o conteúdo type deste type e "'s " junto com o nome e "para".
  \ Se a rotina não for inexistente, ative o dereference detector deste campo termo; atribua a rotina à function deste campo termo; retorne.

Etapas para que se encontre um campo termo usando um type e um nome:
  Se o type for inexistente, retorne.
  Encontre um campo usando o nome e os campos deste type.
  Se o campo não for inexistente, atribua o campo ao campo deste campo termo; retorne.
  Se o conteúdo type deste type não for inexistente, encontre o campo usando o nome e os campos deste conteúdo type deste type.
  Se o campo não for inexistente, ative o dereference detector deste campo termo; atribua o campo ao campo deste campo termo; retorne.

Etapas para que se encontre um fragment usando um segundo fragment e uma etiqueta:
  Atribua o segundo fragment ao fragment.
  Comece. [a executar o código abaixo]
    Se o fragment for inexistente, retorne.
    Se a etiqueta deste fragment for a etiqueta, retorne.
    Atribua o next deste fragment ao fragment.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um fragment usando um segundo fragment e uma etiqueta (backwards):
  Atribua o segundo fragment ao fragment.
  Comece. [a executar o código abaixo]
    Se o fragment for inexistente, retorne.
    Se a etiqueta deste fragment for a etiqueta, retorne.
    Atribua o previous deste fragment ao fragment.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um import usando uma string:
  Esvazie o import.
  Comece. [a executar o código abaixo]
    Obtenha o import desde o imports.
    Se o import for inexistente, retorne.
    Se o nome deste import for a string, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um endereço completo e um número da linha usando um ponteiro do byte :
  Limpe o endereço completo.
  Atribua 0 ao número da linha.
  Encontre um source file usando o ponteiro do byte .
  Se o source file for inexistente, retorne.
  Atribua o endereço completo deste source file ao endereço completo.
  Encontre o número da linha usando o source file e o ponteiro do byte .

Etapas para que se encontre uma rotina usando uma representação interna da rotina e uma unidade semântica e um catálogo:
  Se o unidade semântica for inexistente, retorne.
  Esvazie a rotina.
  Isole a representação interna da rotina.
  Atribua o type deste unidade semântica ao type atual deste unidade semântica.
  Lance o subtexto atual deste unidade semântica sobre a string deste unidade semântica.
  Comece. [a executar o código abaixo]
    Posponha o unidade semântica para a representação interna da rotina (while bubbling).
    Encontre uma referência usando a representação interna da rotina e o catálogo.
    Se a referência não for inexistente, atribua o ponteiro deste referência à rotina.
    Se a referência não for inexistente, encontre a rotina usando a representação interna da rotina e o next deste unidade semântica e o catálogo.
    Se a rotina não for inexistente, pare.
    Bubble o unidade semântica.
    Se o unidade semântica estiver bubbled out, pare.
    Atribua o original representação interna da rotina ao representação interna da rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre uma rotina usando umas unidades semânticas:
  Esvazie a rotina.
  Encontre a rotina usando uma representação interna da rotina e o first destes unidades semânticas e o catálogo geral de rotinas.

Etapas para que se encontre uma rotina usando uma string e uma segunda string e uma terceira string e um quarto string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para os unidades semânticas usando a segunda string.
  Adicione um terceiro unidade semântica para os unidades semânticas usando a terceira string.
  Adicione um quarto unidade semântica para os unidades semânticas usando o quarto string.
  Encontre a rotina usando os unidades semânticas.
  Destrua os unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um type:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para os unidades semânticas usando o type.
  Encontre a rotina usando os unidades semânticas.
  Destrua os unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um type e uma segunda string e um segundo type:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para os unidades semânticas usando o type.
  Adicione um terceiro unidade semântica para os unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para os unidades semânticas usando o segundo type.
  Encontre a rotina usando os unidades semânticas.
  Destrua os unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um type e uma segunda string e uma terceira string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para os unidades semânticas usando o type.
  Adicione um terceiro unidade semântica para os unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para os unidades semânticas usando a terceira string.
  Encontre a rotina usando os unidades semânticas.
  Destrua os unidades semânticas.

Etapas para que se encontre uma rotina usando uma string e um type e uma segunda string e uma terceira string e uma quarta string e uma quinta string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para os unidades semânticas usando o type.
  Adicione um terceiro unidade semântica para os unidades semânticas usando a segunda string.
  Adicione um quarto unidade semântica para os unidades semânticas usando a terceira string.
  Adicione um quinto unidade semântica para os unidades semânticas usando a quarta string.
  Adicione um sexto unidade semântica para os unidades semânticas usando a quinta string.
  Encontre a rotina usando os unidades semânticas.
  Destrua os unidades semânticas.

Etapas para que se encontre um número da linha usando um source file e um ponteiro do byte :
  Se o ponteiro do byte for inexistente, atribua 0 ao número da linha; retorne.
  Lance um subtexto sobre o trecho deste source file.
  Atribua 1 ao número da linha.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Se o caractere inicial deste subtexto for o ponteiro do byte , retorne.
    Se o conteúdo deste caractere inicial deste subtexto for o retorno de carro, adicione 1 para o número da linha.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]

Etapas para que se encontre um source file usando um ponteiro do byte :
  Se o ponteiro do byte for inexistente, esvazie o source file; retorne.
  Comece. [a executar o código abaixo]
    Obtenha o source file desde os sources files.
    Se o source file for inexistente, retorne.
    Se o ponteiro do byte for menor do que o caractere inicial deste trecho deste source file, recomece.
    Se o ponteiro do byte for maior do que o caractere final deste trecho deste source file, recomece.

Etapas para que se encontre um type e um nickname usando um nome:
  Esvazie o type.
  Limpe o nickname.
  Encontre o type e o nickname usando o nome (forward).
  Se o type não for inexistente, retorne.
  Encontre o type e o nickname usando o nome (backward).
  \Lance um subtexto sobre o nome.
  \Comece. [a executar o código abaixo]
    \Se o subtexto estiver em branco, retorne.
    \Encontre o type usando o subtexto e o catálogo de tipos.
    \Se o type não for inexistente, pare.
    \Skip para o next palavra no subtexto.
  \Recomece. [percorra novamente o código acima]
  \Atribua o caractere inicial deste nome para caractere inicial deste segundo subtexto. \ está errado
  \Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  \Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao nickname.
  \Se o segundo subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas para que se encontre um type e um nickname usando um nome (backward):
  Esvazie o type.
  Limpe o nickname.
  Lance um subtexto sobre o nome.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Encontre o type usando o subtexto e o catálogo de tipos.
    Se o type não for inexistente, pare.
    Skip para o previous palavra no subtexto. \previous
  Recomece. [percorra novamente o código acima]
  Atribua o caractere final deste nome para o caractere final desse segundo subtexto.
  Atribua o caractere final deste subtexto mais 2 ao caractere inicial deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao nickname.
  Se o segundo subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas para que se encontre um type e um nickname usando um nome (forward):
  \ original - sem alterações
  Esvazie o type.
  Limpe o nickname.
  Lance um subtexto sobre o nome.
  Comece. [a executar o código abaixo]
    Se o subtexto estiver em branco, retorne.
    Encontre o type usando o subtexto e o catálogo de tipos.
    Se o type não for inexistente, pare.
    Skip para o next palavra no subtexto. \next
  Recomece. [percorra novamente o código acima]
  Atribua o caractere inicial deste nome para o caractere inicial desse segundo subtexto.
  Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao nickname.
  Se o segundo subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas para que se encontre uma variável usando um nome:
  Se a rotina utilizada atualmente for inexistente, esvazie a variável; retorne.
  Encontre a variável usando o nome e os locals desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e os parâmetros desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis globais.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis hexadecimais.

Etapas para que se encontre uma variável usando um nome e umas variáveis:
  Esvazie a variável.
  Comece. [a executar o código abaixo]
    Obtenha a variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Se o nome desta variável for o nome, retorne.
    Se o nickname desta variável for o nome, retorne.
  Recomece. [percorra novamente o código acima]

Um fragment é uma coisa com
  \ we have three lists in the compiler memory  types, variables, and rotinas 
  \ each rotina consists of a series of logical instructions called fragments. There are just 22 fragment types:
  Uma etiqueta [break, Demanda Externa, Demanda Indireta, Demanda Interna, dereference, end if, epilog, exit, finalize, increment, Decodifique, jump false, load address, load eax, loop, not, etapa preliminar, push address, push value, salve eax, repeat, rotina address],
  Uma variável (reference) [Demanda Indireta, dereference, increment, load address, load eax, pop, push address, push value, rotina address, salve eax],
  Uma segunda variável (reference) [load address],
  Uma rotina (reference) [Demanda Interna, rotina address],
  Uma entry (reference) [Demanda Externa],
  Um número [increment],
  Um detector [load eax], \SAL
  Um endereço,
  Um texto hexadecimal denominado código.

Etapas para que se gere um nome usando uma string:
  Atribua a string ao nome.
  Adicione 1 para a contagem de nomes deste compilador.
  Converta a contagem de nomes deste compilador para uma segunda string.
  Posponha a segunda string para o nome.

Etapas para que se obtenha um endereço usando uma rotina:
  Se o endereço desta rotina não for 0, atribua o endereço desta rotina ao endereço; retorne.
  Atribua -1 ao endereço desta rotina.
  Encontre uma segunda rotina usando o employs representação interna da rotina desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente, apresente uma mensagem de erro contendo "Eu não consegui encontrar uma tarefa: " junto com o employs representação interna da rotina desta rotina seguido de "' que você está tentando employ." e o local de aparição desta rotina; retorne.
  Se o endereço desta segunda rotina for -1, apresente a mensagem de erro contendo "Referência recursiva na cláusula employ." e o local de aparição desta rotina; retorne. \Bora traduzir
  Obtenha o endereço usando a segunda rotina.
  Atribua o endereço ao endereço desta rotina.

Etapas para que se obtenha uma contagem usando uns imports (all entries mais markers):
  Atribua 0 à contagem.
  Comece. [a executar o código abaixo]
    Obtenha um import desde o imports.
    Se o import for inexistente, retorne.
    Adicione a contagem destas entries deste import para a contagem.
    Adicione 1 para a contagem.
  Recomece. [percorra novamente o código acima]

Um global body é um subtexto.

O catálogo de variáveis globais é um catálogo.

An global é uma variável.

Os globals são uns globals.

A image base é um endereço igual a 4194304 [$00400000].

A import zona é uma zona.

Um import header é um estrutura com
\traduzir isso aqui
  Um endereço denominado original first previamente calculado, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-first-thunkoft-milad-kahsari-alhadi/
  \ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft#:~:caixa de texto=The%20original%20first%20thunk%20is,%2C%20user32%20etc)%20are%20known.
  \ Thunks são as partes definitivas dos códigos em um sistema operacional que manipula as transições entre o código de 16 e 32 bits.
  \ Assim, eles garantem a compatibilidade com versões anteriores entre as chamadas feitas pelo aplicativo.
  \ O OS está sujeito a esta facilidade para compatibilidade com versões anteriores, de modo que os aplicativos de 16 bits possam funcionar sem problemas em ambientes de 32 bits.
  Um número denominado TimeStamp, \ Set para zero até que bound; seguido de this feld is set para the TimeDateStamp of the exporting FileHeader da DLL
  Um endereço denominado forwarder chain, \ Forwarder Chain: O 32-bit catálogo of the frst forwarder em the liste of imported functions
  Um endereço denominado nome memory endereço, 
  \Esse endereço contém o RVA [Endereço Virtual Relativo] da dll a ser carregada na memória. É um valor dword.
  \É composto por: RVA = Base da Imagem + Ordem Endian
  Um endereço denominado first previamente calculado memory endereço.

Um import é uma coisa com
  Um nome endereço,
  Um header endereço,
  Um nome,
  Um import header,
  Some entries.

Os imports são uns imports.

Etapas para que se catalogue um global:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o global for inexistente, retorne.
  Se o nome deste global estiver no catálogo de variáveis globais, apresente uma mensagem de erro contendo "'" junto com o nome deste global seguido de "' é uma variável global duplicada." e o local de aparição deste global; retorne.
  Catalogue o global usando o nome deste global e o catálogo de variáveis globais.

Etapas para que se catalogue um literal:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o literal for inexistente, retorne.
  Se o nome deste literal estiver no catálogo de variáveis hexadecimais, apresente uma mensagem de erro contendo "Erro interno no nome do literal na função catálogo um literal" e o local de aparição deste literal; retorne.
  Catalogue o literal usando o nome deste literal e o catálogo de variáveis hexadecimais.

Etapas para que se catalogue um cabeçalho semi-expandido usando um catálogo (special):
  Encontre uma referência usando o cabeçalho semi-expandido e o catálogo.
  Se a referência não for inexistente, retorne.
  Catalogue o cabeçalho semi-expandido no catálogo.

Etapas para que se catalogue uma rotina por utility use:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina for inexistente, retorne.
  Se o detector de função desta rotina estiver ativo, retorne.
  Se a contagem destes parâmetros desta rotina for 0, retorne.
  Copie os unidades semânticas desta rotina para umas unidades semânticas.
  Reduza os unidades semânticas por utility use.
  Converta os unidades semânticas para uma representação interna da rotina.
  Destrua os unidades semânticas.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Encontre uma referência usando a representação interna da rotina e o catálogo de rotinas úteis.
  Se a referência não for inexistente, atribua nil ao ponteiro deste referência; retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo de rotinas úteis.

Etapas para que se catalogue uma rotina usando uma representação interna da rotina e um catálogo (special):
  Encontre uma referência usando a representação interna da rotina e o catálogo.
  Se a referência não for inexistente, atribua a rotina ao ponteiro deste referência; retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo.

Etapas para que se catalogue uma rotina usando umas unidades semânticas e um catálogo:
  Se a rotina for inexistente, retorne.
  Limpe um cabeçalho semi-expandido.
  Comece. [a executar o código abaixo]
    Obtenha uma unidade semântica desde os unidades semânticas.
    Se o unidade semântica for inexistente, retorne.
    Posponha o unidade semântica para o cabeçalho semi-expandido.
    Se o unidade semântica for o last unidade semântica destes unidades semânticas, pare.
    Catalogue o cabeçalho semi-expandido usando o catálogo (special).
  Recomece. [percorra novamente o código acima]
  Catalogue a rotina usando o cabeçalho semi-expandido como uma representação interna da rotina e o catálogo (special).

Etapas para que se catalogue umas rotinas por utility use:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Catalogue a rotina por utility use.
  Recomece. [percorra novamente o código acima]

Etapas para que se catalogue um type:
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Catalogue o type usando o nome deste type.

Etapas para que se catalogue um type usando um nome: \To index a type given a name:
  Se o type for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Encontre um existing type usando o nome e o catálogo de tipos.
  Se o existing type for inexistente, catalogue o type usando o nome e o catálogo de tipos; retorne.
  [Se o existing type já existir, então:] 
  Atribua o local de aparição deste type para um local de aparição.
  Se o local de aparição for inexistente, atribua o local de aparição deste existing type ao local de aparição. \ point the error to a type in the source code, not a generated type
  Se o local de aparição não for inexistente, Apresente uma mensagem de erro contendo "Acho que já vi o tipo: " junto com o nome seguido de "' em um lugar antes; você deve ter duplicado ele." e o local de aparição.

Etapas para que se inicialize o compilador:
\Sim, essa rotina não tem nada, serve apenas para fazer com que o código fique "simétrico"

Etapas para que se inicialize o compilador usando um endereço da pasta:
  Atribua o endereço da pasta ao endereço da pasta deste compilador.
  Atribua 0 à contagem de nomes deste compilador.
  Desative o detector de erros deste compilador.
  Limpe a mensagem de erro deste compilador.
  Limpe o endereço completo do arquivo de erro deste compilador.
  Atribua 0 ao número da linha de erro deste compilador.
  Esvazie a rotina utilizada atualmente.
  Crie o catálogo de tipos com 13001 [buckets]. \ era 4027
  Crie o catálogo de variáveis globais com 13001 [buckets]. \ era 4027
  Crie o catálogo de variáveis hexadecimais com 13001 [buckets]. \ era 4027
  Crie o catálogo geral de rotinas com 13001 [buckets]. \ era 7919
  Crie o catálogo de rotinas úteis com 13001 [buckets]. \ era 4027

Etapas para que se inicialize um DOS header: \ vou alterar depois
  Atribua 23117 [$5A4D] ao Signature deste DOS header.
  Atribua 64 [$0040] ao addressofrelocationtableinfile deste DOS header. \ O addressofrelocationtableinfile is a pointer para the variável-length de caracteres table of DLLs needed for this program.
  Atribua 256 [$00000100] ao Address_Of_PE_Header_In_File deste DOS header. \O Address_Of_PE_Header_In_File is a pointer para the PE Header, a revised and extended version of the DOS Header introduced com advent of Windows. 
  \O segunda 16 campos of the DOS Header are not used.

Etapas para que se inicialize um PE header:
  Inicialize o PE header (standard header).
  Inicialize o PE header (optional header).
  Inicialize o PE header (version information).
  Inicialize o PE header (directories).
  Inicialize o PE header (import section).
  Inicialize o PE header (data section).
  Inicialize o PE header (Code Section).

Etapas para que se inicialize um PE header (Code Section):
  Atribua "code  " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Code Section deste PE header por 6.
  Atribua a quantidade de caracteres desta zona de código ao SizeInBytes desta Code Section deste PE header.
  Atribua o endereço base desta zona de código ao AddressInMemory desta Code Section deste PE header.
  Atribua a quantidade de caracteres desta zona de código ao SizeInFile desta Code Section deste PE header.
  Atribua o endereço base desta zona de código ao AddressInFile desta Code Section deste PE header.
  Atribua -536870880 [$E0000020 ] para as Characteristics desta Code Section deste PE header. \ executable, readable, writable, code object
  \IMAGE_FILE_LARGE_ADDRESS_ AWARE 0x0020 - Application can handle > 2-GB addresses.

  
Etapas para que se inicialize um PE header (data section):
  Atribua "data " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta data section deste PE header por 6.
  Atribua a quantidade de caracteres desta zona de dados ao SizeInBytes desta data section deste PE header.
  Atribua o endereço base desta zona de dados ao AddressInMemory desta data section deste PE header.
  Atribua a quantidade de caracteres desta zona de dados ao SizeInFile desta data section deste PE header.
  Atribua o endereço base desta zona de dados ao AddressInFile desta data section deste PE header.
  Atribua -1073741760 [$C0000040] para as Characteristics desta data section deste PE header. \ initialized, readable, writable

Etapas para que se inicialize um PE header (directories):
  Atribua 16 [$00000010] ao numberofdirectories deste PE header.
  Atribua o endereço base desta import zona ao imagedirectoryentryimportaddress deste PE header.
  Atribua a quantidade de caracteres desta import zona ao ImageDirectoryEntryImportSize deste PE header.

Etapas para que se inicialize um PE header (import section):
  Atribua "idata " a uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta idata section deste PE header por 6.
  Atribua a quantidade de caracteres desta import zona ao SizeInBytes desta idata section deste PE header.
  Atribua o endereço base desta import zona ao AddressInMemory desta idata section deste PE header.
  Atribua a quantidade de caracteres desta import zona ao SizeInFile desta idata section deste PE header.
  Atribua o endereço base desta import zona ao AddressInFile desta idata section deste PE header.
  Atribua -1073741760 [$C0000040] para as Characteristics desta idata section deste PE header. \ initialized, readable, writable

Etapas para que se inicialize um PE header (optional header):
  Atribua 267 [$010B] ao magicnumber deste PE header.
  Atribua a quantidade de caracteres desta zona de código ao SizeOfCodeInFile deste PE header.
  Atribua a quantidade de caracteres desta zona de dados ao SizeOfInitializedDataInFile deste PE header.
  Atribua 0 ao SizeOfUninitializedDataInFile deste PE header.
  Encontre uma rotina usando "~initialize before run e run e finalize after run" e o catálogo geral de rotinas.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno: não achei a tarefa de inicialização"; retorne.
  Atribua o endereço desta rotina menos o image base ao AddressOfEntryPointInMemory deste PE header.
  Atribua o endereço base desta zona de código ao AddressOfCodeInMemory deste PE header.
  Atribua o endereço base desta zona de dados ao AddressOfInitializedDataInMemory deste PE header.
  Atribua o image base à imagebase deste PE header.
  Atribua 4096 [$00001000] ao MemoryAlignment deste PE header.
  Atribua 4096 [$00001000] ao FileAlignment deste PE header.
  Atribua 0 ao Reserved deste PE header.
  Atribua o exe size deste compilador ao SizeOfImageInMemory deste PE header.
  Atribua 4096 [section base] ao SizeOfAllHeadersInFile deste PE header.
  Atribua 0 ao checksum deste PE header.
  Atribua 0 para as DllCharacteristics deste PE header.
  Atribua 1048576 [$00100000] ao MaxStack deste PE header.
  Atribua 16384 [$00004000] ao MinStack deste PE header.
  Atribua 1048576 [$00100000] ao MaxHeap deste PE header.
  Atribua 16384 [$00004000] ao MinHeap deste PE header.
  Atribua 0 ao loaderflags deste PE header.

Etapas para que se inicialize um PE header (standard header):
  Atribua 17744 [$00004550] ao Signature deste PE header.
  Atribua 332 [$014C] ao MachineType deste PE header.
  Atribua 3 [$0003] ao NumberOfSections deste PE header.
  Atribua 0 ao TimeStamp deste PE header.
  Atribua 0 ao PointerToSymbolTable deste PE header.
  Atribua 0 ao NumberOfSymbols deste PE header.
  Atribua 224 [$00E0] ao SizeOfOptionalHeaderInBytes deste PE header.
  Atribua 33166 [$818E] às Characteristics deste PE header.

Etapas para que se inicialize um PE header (version information):
  Atribua 0 ao MajorLinkerVersion deste PE header.
  Atribua 0 ao MinorLinkerVersion deste PE header.
  Atribua 4 [$0004] ao OS_MajorVersion deste PE header.
  Atribua 0 [$0000] ao OS_MinorVersion deste PE header.
  Atribua 0 ao UserMajorVersion deste PE header.
  Atribua 0 ao UserMinorVersion deste PE header.
  Atribua 4 [$0004] ao SubsystemMajorVersion deste PE header.
  Atribua 0 [$0000] ao SubsystemMinorVersion deste PE header.
  Atribua 2 [$0002] ao Subsystem deste PE header.

  
Um intermediate é um local.

  

Etapas para que se link:
  Arredonde para cima zona sizes.
  Inicialize um DOS header.
  Inicialize um PE header.
  Preencha o exe deste compilador com o caractere null usando o exe size deste compilador.
  Disponibilize o DOS header ao exe deste compilador.
  Disponibilize o PE header ao exe deste compilador.
  Disponibilize os imports ao exe deste compilador.
  Disponibilize os globals ao exe deste compilador.
  Disponibilize os literals ao exe deste compilador.
  Disponibilize as rotinas ao exe deste compilador.

  

Etapas para que se liste tudo:
  Limpe o listagem deste compilador.
  Liste a mensagem de erro deste compilador na listagem deste compilador.
  Liste os types depois de "TIPOS:" na listagem deste compilador.
  Liste os globals depois de "VARIÁVEIS GLOBAIS:" na listagem deste compilador.
  Liste os literals depois de "VALORES LITERAIS:" na listagem deste compilador.
  Liste as rotinas depois de "ROTINAS:" na listagem deste compilador.
  Liste o catálogo de tipos depois de "ÍNDICE DE TIPOS:" na listagem deste compilador.
  Liste o catálogo de variáveis globais depois de "ÍNDICE GLOBAL:" na listagem deste compilador.
  Liste o catálogo de variáveis hexadecimais depois de "ÍNDICE DE VALORES LITERAIS:" na listagem deste compilador.
  Liste o catálogo geral de rotinas depois de "ÍNDICE DE ROTINAS:" na listagem deste compilador.
  Liste o catálogo de rotinas úteis depois de "Catálogo de Rotinas Úteis:" na listagem deste compilador.
  Liste o imports depois de "DLL's:" na listagem deste compilador.
  Liste o sources files depois de "ARQUIVOS FONTE:" na listagem deste compilador.
  Liste os temporizadores depois de "TEMPORIZADORES:" na listagem deste compilador.
  Escreva o listagem deste compilador para o listagem endereço completo deste compilador.

Etapas para que se liste um mensagem de erro em um trecho:
  Se o mensagem de erro estiver em branco, retorne.
  Posponha "COMPILAÇÃO INTERROMPIDA - LISTAGEM INCOMPLETA" para o trecho.
  Advance o trecho (twice).
  Posponha o mensagem de erro para o trecho.
  Advance o trecho (twice).

Etapas para que se liste um bucket em um trecho:
  Se os referências deste bucket estiverem vazios, retorne.
  Posponha "| RECIPIENTE" para o trecho (com separador).
  Advance o trecho.
  Liste os referências deste bucket no trecho.
  Advance o trecho.

Etapas para que se liste umas entries em um trecho:
  Obtenha um entry desde as entries.
  Se a entry for inexistente, retorne.
  Liste a entry no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste um entry em um trecho:
  Se a entry for inexistente, retorne.
  Posponha "| ENTRADA" para o trecho (com separador).
  Posponha o nome desta entry para o trecho (com separador).
  Posponha o endereço desta entry para o trecho (as hex com separador).
  Advance o trecho.

Etapas para que se liste um fragment em um trecho:
  Posponha "| FRAGMENTO" para o trecho (com separador).
  Posponha a etiqueta deste fragment para o trecho (as um fragment etiqueta string com separador).
  Posponha "Variável principal: " para o trecho.
  Posponha a variável deste fragment para o trecho (com separador).
  Posponha "Variável secundária: " para o trecho.
  Posponha a segunda variável deste fragment para o trecho (com separador).
  Posponha "Rotina: " para o trecho.
  Posponha a rotina deste fragment para o trecho (com separador).
  Posponha "Entrada: " para o trecho.
  Posponha a entry desta fragment para o trecho (com separador).
  Posponha "Número hexadecimal: " para o trecho.
  Posponha o número deste fragment para o trecho (as hex com separador).
  Posponha "Endereço: " para o trecho.
  Posponha o endereço deste fragment para o trecho (as hex com separador).
  Converta o código deste fragment para uma cifra hexadecimal.
  Posponha "Código compilado: " para o trecho.
  Posponha a cifra hexadecimal para o trecho (com separador).
  Advance o trecho.

Etapas para que se liste uns fragments em um trecho:
  Obtenha um fragment desde o fragments.
  Se o fragment for inexistente, retorne.
  Liste o fragment no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste um import em um trecho:
  Se o import for inexistente, retorne.
  Posponha "| DLL" para o trecho (com separador).
  Posponha o nome deste import para o trecho (com separador).
  Advance o trecho.
  Liste as entries deste import no trecho.
  Advance o trecho.

Etapas para que se liste uns imports em um trecho:
    Obtenha um import desde o imports.
    Se o import for inexistente, retorne.
    Liste o import no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns imports depois de uma string em um trecho:
  Posponha a string para o trecho.
  Advance o trecho (twice).
  Se o imports estiverem vazios, retorne.
  Liste os imports no trecho.

Etapas para que se liste um catálogo em um trecho:
  Posponha "| " junto com o used contagem de buckets deste catálogo seguido de " recipientes" para o trecho (com separador).
  Posponha a contagem deste catálogo seguido de " referências" para o trecho (com separador).
  Advance o trecho (twice).
  Comece. [a executar o código abaixo]
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, retorne.
    Liste o bucket no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste um catálogo depois de uma string em um trecho:
  Posponha a string para o trecho.
  Advance o trecho (twice).
  Se o catálogo estiver vazio, retorne.
  Liste o catálogo no trecho.

Etapas para que se liste uma referência em um trecho:
  Se a referência for inexistente, retorne.
  Posponha "| REFERÊNCIA" para o trecho (com separador).
  Posponha a string deste referência para o trecho.
  Se o ponteiro deste referência for inexistente, posponha " (ponteiro inexistente) " para o trecho.
  Posponha "| " para o trecho.
  Advance o trecho.

Etapas para que se liste umas referências em um trecho:
  Obtenha uma referência desde as referências.
  Se a referência for inexistente, retorne.
  Liste a referência no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uma rotina em um trecho:
  Se a rotina for inexistente, retorne.
  Posponha "| ROTINA: " para o trecho.
  Posponha a representação interna da rotina desta rotina para o trecho (com separador). \ por exemplo: atribua [matiz] e [saturação] e [luminosidade] para [cor]
  Posponha o texto CRLF para o trecho.
  Posponha "| A rotina foi compilada? " para o trecho .
  Posponha o compiled detector desta rotina para o trecho (com separador). \ A rotina foi compilada? SIM / NÃO
  Posponha o texto CRLF para o trecho.
  Posponha "| A rotina é um callback? " para o trecho.
  Posponha o detector de compatibilidade desta rotina para o trecho (com separador). \ A rotina é um callback? SIM / NÃO
  Posponha o texto CRLF para o trecho.
  Posponha "| A rotina é uma rotina decisora? " para o trecho.
  Posponha o detector de deliberação desta rotina para o trecho (com separador). \ A rotina é uma rotina decisora? SIM / NÃO
  Posponha o texto CRLF para o trecho.
  Posponha "| A rotina é uma função? " para o trecho.
  Posponha o detector de função desta rotina para o trecho (com separador). \ A rotina é uma função ? SIM / NÃO
  Posponha o texto CRLF para o trecho.
  Posponha "| Employs utilizados: |     " para o trecho.
  Posponha o employs representação interna da rotina desta rotina para o trecho (com separador).
  Posponha o texto CRLF para o trecho.
  Posponha "| Tamanho dos parâmetros: " para o trecho.
  Posponha o parâmetro size desta rotina para o trecho (com separador). \ Tamanho dos parâmetros. Exemplo: 16 ( 4 parâmetros)
  Posponha " Tamanho das variáveis: " para o trecho.
  Posponha o local size desta rotina para o trecho (com separador). \Tamanho do local. Exemplo: 28
  Posponha o texto CRLF para o trecho.
  Posponha "| Endereço da Rotina: " para o trecho.
  Posponha o endereço desta rotina para o trecho (as hex com separador). \ Endereço da rotina, Exemplo: 0041D000
  Advance o trecho.
  Liste os parâmetros desta rotina no trecho.
  Liste os locals desta rotina no trecho.
  Liste os fragments desta rotina no trecho.
  Advance o trecho.

Etapas para que se liste umas rotinas em um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Liste a rotina no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste umas rotinas depois de uma string em um trecho:
  Posponha a string para o trecho.
  Advance o trecho (twice).
  Se as rotinas estiverem vazias, retorne.
  Liste as rotinas no trecho.

Etapas para que se liste um source file em um trecho:
  Se o source file for inexistente, retorne.
  Posponha "| ARQUIVO FONTE" para o trecho (com separador).
  Posponha o endereço completo deste source file para o trecho (com separador).
  Advance o trecho.

Etapas para que se liste uns sources files em um trecho:
  Obtenha um source file desde o sources files.
  Se o source file for inexistente, retorne.
  Liste o source file no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns sources files depois de uma string em um trecho:
  Posponha a string para o trecho.
  Advance o trecho (twice).
  Se o sources files estiverem vazios, retorne.
  Liste o sources files no trecho.
  Advance o trecho.

Etapas para que se liste um temporizador usando uma string em um trecho:
  Posponha "| TEMPORIZADOR" para o trecho (com separador).
  Posponha a string para o trecho (com separador).
  Posponha a string deste temporizador para o trecho.
  Posponha " milissegundos" para o trecho (com separador).
  Advance o trecho.

Etapas para que se liste os temporizadores depois de uma string em um trecho:
  Posponha a string para o trecho.
  Advance o trecho (twice).
  Liste o temporizador de operacionalização usando "Tempo de carregamento: " no trecho.
  Liste o temporizador de análise/verificação usando "Tempo de verificação: " no trecho.
  Liste o temporizador de resolução de tipos usando "Resolução de tipos: " no trecho.
  Liste o temporizador de resolução de variáveis globais usando "Resolução de variáveis globais: " no trecho.
  Liste o temporizador de compilação de cabeçalhos de rotina usando "Compilação de cabeçalhos de rotinas: " no trecho.
  Liste o temporizador de etapas de cálculo usando "Cálculos matemáticos: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de mémoria  usando "Inclusão de rotinas pré-definidas: " no trecho.
  Liste o temporizador de ferramentas de catalogação usando "Catalogação de ferramentas: " no trecho.
  Liste o temporizador de compilação do conteúdo das rotinas usando "Compilação de rotinas: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de inicialização usando "Inserção rotina de inicialização:" no trecho.
  Liste o temporizador de deslocamentos usando "Alinhamento de bytes na memória: " no trecho.
  Liste o temporizador de endereçamento usando "Endereçamento: " no trecho.
  Liste o temporizador de transmutação usando "Conversão em binário" no trecho.
  Liste o temporizador de vinculação usando "Vinculação: " no trecho.
  Liste o temporizador de escrita usando "Escrita e gravação no SO: " no trecho.
  Liste o temporizador deste compilador usando "Tempo total: " no trecho.
  Advance o trecho.

Etapas para que se liste um type em um trecho:
  Se o type for inexistente, retorne.
  Posponha "| TIPO" para o trecho (com separador).
  Posponha o nome deste type para o trecho (com separador).
  Posponha " Plural: " para o trecho.
  Posponha o plural nome deste type para o trecho (com separador).
  Posponha " Comprimento: " para o trecho.
  Posponha a quantidade de caracteres deste type para o trecho (as hex com separador).
  Posponha " Tipo: " para o trecho.
  Posponha o base nome deste type para o trecho (com separador).
  Posponha " Tipo base: " para o trecho.
  Posponha o base type deste type para o trecho (com separador).
  Posponha o conteúdo nome deste type para o trecho (com separador).
  Posponha o conteúdo type deste type para o trecho (com separador).
  Posponha " Razão de escala: " para o trecho.
  Posponha a razão de escala deste type para o trecho (com separador).
  Advance o trecho.
  Liste os campos deste type no trecho.
  Advance o trecho.

Etapas para que se liste uns types em um trecho:
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Liste o type no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns types depois de uma string em um trecho:
  Posponha a string para o trecho.
  Advance o trecho (twice).
  Se os types estiverem vazios, retorne.
  Liste os types no trecho.

Etapas para que se liste uma variável em um trecho:
  Se a variável for inexistente, retorne.
  Posponha "| VARIÁVEL" para o trecho (com separador).
  Posponha "Categoria: " para o trecho.
  Posponha a categoria desta variável para o trecho (com separador).
  Posponha "Compilada? " para o trecho.
  Posponha o compiled detector desta variável para o trecho (com separador).
  Posponha "Nome completo: " para o trecho.
  Posponha o nome desta variável para o trecho (com separador).
  Posponha "Nome resumido: " para o trecho.
  Posponha o nickname desta variável para o trecho (com separador).
  Posponha "Nome do tipo: " para o trecho.
  Posponha o type nome desta variável para o trecho (com separador).
  Posponha "Tipo: " para o trecho.
  Posponha o type desta variável para o trecho (com separador).
  Posponha "Endereço (deslocamento): " para o trecho.
  Posponha o endereço desta variável [or offset] para o trecho (as hex com separador).
  Posponha "Passagem por valor? " para o trecho.
  Posponha o by-value detector desta variável para o trecho (com separador).
  Posponha "Contagem: " para o trecho.
  Posponha a contagem desta variável para o trecho (com separador).
  Posponha "Referência somente? " para o trecho.
  Posponha o reference detector desta variável para o trecho (com separador).
  Posponha "Redefinição: " para o trecho.
  Posponha o redefinition conteúdo nome desta variável para o trecho (com separador).
  Posponha "Conteúdo: " para o trecho.
  Posponha o literal desta variável para o trecho (com separador).
  Converta o data desta variável para uma cifra hexadecimal.
  Posponha "Conteúdo (hex): " para o trecho.
  Posponha a cifra hexadecimal para o trecho (com separador).
  Advance o trecho.

Etapas para que se liste uns variáveis em um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Liste a variável no trecho.
  Recomece. [percorra novamente o código acima]

Etapas para que se liste uns variáveis depois de uma string em um trecho:
  Posponha a string para o trecho.
  Advance o trecho (twice).
  Se as variáveis estiverem vazias, retorne.
  Liste as variáveis no trecho.
  Advance o trecho.

O catálogo de variáveis hexadecimais é um catálogo.

An literal é uma variável.

O literals são uns literals.

An local é uma variável.

Um local de aparição é um ponteiro do byte .

Uma representação interna da rotina é uma string.  \ moniker
  \ https://docs.microsoft.com/pt-br/windows/win32/com/monikers
 \ A moniker is the internal representation of a routine header with
\  no articles preceding parameter types,
\  parameter types in square brackets, and
\  expanded prepositions. 
\ Each piece of a moniker is a unidade semântica. For example: 
\ Routine header: To add a number to a count:
\ Moniker: add [number] in/into/to [count]
\ Monikettes: (1) add (2) [number] (3) in/into/to (4) [count] 
\ We use this internal representation because it... 
\  makes it easy reduce types (like [count] to [number]) when looking for an appropriate routine to call;
\  makes it easy to expand prepositions (like "to" into "in/into/to"); and
\  shows how the compiler interpreted various phrases in error messages.
Uma unidade semântica é uma coisa com
  Uma string,
  Um type (reference),
  Um variável (reference),
  \ para bubbling
  Um type atual (reference),
  Um subtexto atual.

Um cabeçalho semi-expandido é uma representação interna da rotina.

Etapas para que se mova um percorredor (ignorando os comentários):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o retorno de carro, recomece.

Etapas para que se mova um percorredor (símbolos conectivos):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o percorredor estiver sobre algum tipo de possessive, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum tipo de glom byte, recomece.

Etapas para que se mova um percorredor (sinais de pontuação):
  Avance o percorredor.

Etapas para que se mova um percorredor (ignorando os caracteres irrelevantes):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, recomece.

Etapas para que se mova um percorredor (possessivo inglês):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o segmento final deste percorredor começa com "s", avance o percorredor.

Etapas para que se mova um percorredor (qualificadores):
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo, adicione 1 para uma contagem.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses direito, subtraia 1 desde a contagem.
  Avance o percorredor.
  Se a contagem for 0, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (ignorando as observações):
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo, adicione 1 para uma contagem.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete direito, subtraia 1 desde a contagem.
  Avance o percorredor.
  Se a contagem for 0, pare.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (conteúdo de texto):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, retorne.
  Se o percorredor estiver sobre algum tipo de nested double-quote, avance o percorredor; recomece.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas, avance o percorredor; retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se mova um percorredor (símbolos):
  Avance o percorredor.

Etapas para que se mova um percorredor (englobando tudo):
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, mova o percorredor (ignorando os caracteres irrelevantes); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for a barra invertida, mova o percorredor (ignorando os comentários); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo, mova o percorredor (ignorando as observações); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas, mova o percorredor (conteúdo de texto); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo, mova o percorredor (qualificadores); retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum tipo de mark, mova o percorredor (sinais de pontuação); retorne.
  Se o percorredor estiver sobre algum tipo de possessive, mova o percorredor (possessivo inglês); retorne.
  Mova o percorredor (símbolos conectivos).

Etapas para que se mova um percorredor (usando diretrizes de compilação): \ talvez aqui conserte o subtraia
  Se o detector de erros deste compilador estiver ativo, limpe o segmento inicial deste percorredor; retorne.
  Mova o percorredor devolvendo um erro string (englobando tudo).
  Se o erro string não estiver em branco, apresente uma mensagem de erro contendo o erro string e o caractere inicial deste segmento inicial deste percorredor; retorne.
  \Se o segmento inicial deste percorredor for "del", recue o percorredor; retorne. \ Spanish contraction "del"; fudged para "de l", short por "de el"
  \Se o segmento inicial deste percorredor for algum tipo de contração de preposição com artigo definido, determine se essa contração precisa ser desfeita usando o percorredor. \ Spanish contraction "al"; fudged para "a l", short por "a el"
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante, recomece.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida, recomece.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, recomece.

Etapas para que se mova um percorredor devolvendo um erro string (diretrizes de validação de qualificadores):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Qualificadores devem terminar com parêntese ')'." ao erro string; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o parênteses direito, atribua "Qualificadores precisam terminar com um parêntese ')'." ao erro string; retorne.

Etapas para que se mova um percorredor devolvendo um erro string (diretrizes de validação de observações):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Observações devem terminar com um colchete ']'." ao erro string; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o colchete direito, atribua "Observações precisam terminar com um colchete ']'." ao erro string; retorne.

Etapas para que se mova um percorredor devolvendo um erro string (diretrizes de validação de conteúdos de texto):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Textos precisam terminar com aspas: ""." ao erro string; retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for as aspas duplas, atribua "Textos devem terminar com aspas: ""." ao erro string; retorne.

Etapas para que se mova um percorredor devolvendo um erro string (englobando tudo):
  Limpe o erro string.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo, mova o percorredor devolvendo o erro string (diretrizes de validação de observações); retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas, mova o percorredor devolvendo o erro string (diretrizes de validação de conteúdos de texto); retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo, mova o percorredor devolvendo o erro string (diretrizes de validação de qualificadores); retorne.

Um parte da cifra binária é um subtexto.

Um nickname é um nome.  

Etapas para que se offset o locals em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a compiled detector desta rotina não estiver ativo, retorne.
  Limpe o local size desta rotina.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um local desde os locals desta rotina.
    Se o local for inexistente, retorne.
    Se o previous deste local não for inexistente, atribua o offset deste previous deste local ao offset deste local.
    Atribua a quantidade de caracteres deste type deste local para uma quantidade de caracteres.
    Se a categoria deste local for "scratch", atribua a magnitude desse ponteiro ao quantidade de caracteres.
    Arredonde a quantidade de caracteres para cima para o múltiplo imediato of 4.
    Subtraia a quantidade de caracteres desde o offset deste local.
    Adicione a quantidade de caracteres para o local size desta rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se offset os locals em umas rotinas:
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Offset os locals na rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se offset o parâmetros em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a compiled detector desta rotina não estiver ativo, retorne.
  Limpe o parâmetro size desta rotina.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um parâmetro desde os parâmetros desta rotina.
    Se o parâmetro for inexistente, retorne.
    Se o detector de compatibilidade desta rotina estiver ativo, ative o by-value detector deste parâmetro.
    Se o previous deste parâmetro for inexistente, atribua 8 ao offset deste parâmetro. \ skip o return address e saved ebp
    Se o previous deste parâmetro não for inexistente, atribua o offset deste previous deste parâmetro mais 4 ao offset deste parâmetro. \ all parâmetros são 4 ponteiro do byte s ou 4 byte values por callbacks
    Adicione 4 para a parâmetro size desta rotina.
  Recomece. [percorra novamente o código acima]

Etapas para que se offset o parâmetros em umas rotinas:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Offset o parâmetros na rotina.
  Recomece. [percorra novamente o código acima]

  

Um parâmetro é uma variável.

Um PE header é um estrutura com
  \ O formato Portable Executable (PE) éum formato de arquivos executáveis / dll files que apareceu no Windows NT. 
  \Ele é baseado na especificação COFF (Common Object File Format).
  \Pra manter a compatibilidade como MS-DOS e Windows, o formato de arquivo PE mantém o antigo cabeçalho MZ do MS-DOS.
  \ Ele é organizado como um fluxo linear de dados.
  \ Começando com um cabçalho do MS-DOS, um real-mode program stub, e uma assinatura de arquivo PE. 
  \ Logo em seguida vem o cabçalho do arquivo PE podendo também haver um cabeçalho opcional.
  \ Além disso temos o cabeçalho de cada seção, seguido pelo corpo de cada seção. 
  \Encerrando o arquivo existem regiões adicionais com informações variadas
  \ por exemplo, informações de relocação, tabela de símbolos, número de linhas e dados da tabela de strings. 
  \ O cabeçalho MS-DOS ocupa os primeiros 64 bytes do arquivo. A estrutura básica está representada abaixo:
  Um número denominado Signature,
  Uma word denominada MachineType, 
  \ O número que identifica o tipo de computador de destino. 
  \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#machine-types
  Uma word denominada NumberOfSections,
  \ O número de seções. Isso indica o tamanho da tabela da seção, que segue imediatamente os cabeçalhos.
  Um número denominado TimeStamp, 
  \ Os 32 low bits do número de segundos que se passaram desde 00:00 horas do dia 01/01/1970. (um valor time_t de tempo de execução do C)
   \ serve pra indicar quando o arquivo foi criado.
  Um número denominado PointerToSymbolTable, 
  \ O número do deslocamento de arquivo da tabela de símbolos COFF ou 
  \ o numero zero se nenhuma tabela de símbolos COFF estiver presente. 
  \ Esse valor deve ser zero para uma imagem porque as informações de depuração de COFF foram descontinuadas.
  Um número denominado NumberOfSymbols, 
  \ O número de entradas na tabela de símbolos.
  \ Esses dados podem ser usados para localizar a tabela de cadeia de caracteres, que segue imediatamente a tabela de símbolos.
  \ Esse valor deve ser zero para uma imagem porque as informações de depuração de COFF foram descontinuadas.
  Uma word denominada SizeOfOptionalHeaderInBytes,
   \ O tamanho do header opcional, que é necessário para arquivos executáveis, mas não para arquivos de objeto.
  \ Esse valor deve ser zero para um arquivo-objeto. Para ver uma descrição do formato do header, consulte:
  \ https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#optional-header-image-only
  Uma word denominada Characteristics, 
  \ Os sinalizadores que indicam os atributos do arquivo. 
  \Para valores de sinalizador específicos, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#Characteristics
  \ optional header
  Uma word denominada MagicNumber, 
  \O número mágico do cabeçalho opcional determina se uma imagem é um PE32 ou PE32 + executável.
  \ As imagens PE32 + permitem um espaço de endereço de 64 bits, limitando o tamanho da imagem a 2 gigabytes. 
  \ Outras modificações PE32 + são abordadas em suas respectivas seções.
  \ É um inteiro sem sinal que identifica o estado do arquivo de imagem. 
  \ O valor mais comum é 0x10B, que o identifica como um arquivo executável normal. 
  \0x107 o identifica como uma imagem de ROM e 0x20B a identifica como um PE32 + executável.
  \ Esse campo é usado para identificar arquivos compatíveis com o tipo de arquivo do MS-DOS. 
  \ Os executáveis compatíveis com MS-DOS usam o valor 0x5A4D, que é o valor das letras MZ na tabela ASCII
  Um byte denominado MajorLinkerVersion, 
  \ Indica a version do linker que vinculou a imagem - O número da versão principal do vinculador.
  Um byte denominado MinorLinkerVersion, 
  \ Indica a version do linker que vinculou a imagem - O número da versão secundária do vinculador.
  Um número denominado SizeOfCodeInFile, 
  \O tamanho da seção de código (texto) ou a soma de todas as seções de código se houver várias seções.
  Um número denominado SizeOfInitializedDataInFile,
   \ O tamanho da seção de dados inicializados ou a soma de todas essas seções, se houver várias seções de dados.
  Um número denominado SizeOfUninitializedDataInFile, 
  \ O tamanho da seção de dados não inicializado (BSS) ou a soma de todas essas seções, se houver várias seções BSS.
  Um número denominado AddressOfEntryPointInMemory, 
  \Esse campo indica a localização do fim da Import Address Table (IAT). 
  \ É um número que contém endereço do ponto de entrada relativo à imagem base quando o arquivo executável é carregado na memória. 
  \Para imagens de programa, esse é o endereço inicial. 
  \Para drivers de dispositivo, esse é o endereço da função de inicialização. 
  \Um ponto de entrada [entry point] é opcional para DLLs. 
  \Quando nenhum ponto de entrada está presente, esse campo deve ser zero.
  Um número denominado AddressOfCodeInMemory,  [BaseOfCode]
  \ O endereço relativo à base da imagem da seção de início de código quando ela é carregada na memória.
  Um número denominado AddressOfInitializedDataInMemory, [BaseOfData]
  \ O endereço relativo à base da imagem da seção de início de dados quando ela é carregada na memória.
  Um número denominado ImageBase, 
  \ O endereço preferencial do primeiro byte de imagem quando carregado na memória; deve ser um múltiplo de 64 K. 
  \O padrão para DLLs é 0x10000000. o padrão para Windows CE EXEs é 0x00010000. 
  \ O padrão para Windows NT, Windows 2000, Windows XP, Windows 95, Windows 98 e Windows Me é 0x00400000.
  Um número denominado MemoryAlignment, [SectionAlignment]
  \ O alinhamento (em bytes) das seções quando elas são carregadas na memória. 
  \Ele deve ser maior ou igual a FileAlignment. 
  \O padrão é o tamanho da página para a arquitetura.
  Um número denominado FileAlignment, 
  \ O fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem. 
  \O valor deve ser uma potência de 2 entre 512 e 64 K, inclusive. O padrão é 512. 
  \Se SectionAlignment for menor que o tamanho da página da arquitetura, FileAlignment deverá corresponder a SectionAlignment.
  Uma word denominada OS_MajorVersion, [MajorOperatingSystemVersion]
  \ O número de versão principal do sistema operacional Windows NT.
  Uma word denominada OS_MinorVersion, [MinorOperatingSystemVersion]
  \ O número de versão secundária do sistema operacional necessário.
  Uma word denominada UserMajorVersion,  [MajorImageVersion]
  \ O número de versão principal do programa.
  Uma word denominada UserMinorVersion, [MinorImageVersion]
  \ O número de versão secundária do programa.
  Uma word denominada SubsystemMajorVersion, [MajorSubsystemVersion]
  \ O número de versão principal do subsistema Win32 do Windows NT.
  Uma word denominada SubsystemMinorVersion, [MinorSubsystemVersion]
  \ O número de secundária principal do subsistema.
  Um número denominado Reserved,  [Win32VersionValue]
  \ Reservado, deve ser zero. Unknown purpose, currently not used by the system and set para zero by the linker.
  Um número denominado SizeOfImageInMemory, [SizeOfImage]
  \ O tamanho (em bytes) da imagem, incluindo todos os headers, pois a imagem é carregada na memória. Ele deve ser um múltiplo de SectionAlignment.
  \ Indicates the amount of address space para reserve em the address space for the loaded executable image. 
  \This number is influenced greatly by SectionAlignment. 
  \For example, consider a system having a fixed page size of 4096 bytes. 
  \If you have an executable com 11 sections, each less than 4096 bytes, aligned sobre a 65,536-byte boundary, the SizeOfImage campo would be set para 11 * 65,536 = 720,896 (176 pages). 
   \The same arquivo linked com 4096-byte alignment would result em 11 * 4096 = 45,056 (11 pages) for the SizeOfImage campo. 
  \This is a simple example em which each section requires less than a page of memory. 
  \In reality, the linker determines the exact SizeOfImage by figuring each section individually. 
  \It first determines how many bytes the section requires, seguido de it rounds para cima para the nearest page boundary, and finally it rounds page count para the nearest SectionAlignment boundary. 
  \O total is seguido de the sum of each individual requirement da section.
  Um número denominado SizeOfAllHeadersInFile, [SizeOfHeaders]
  \ O tamanho combinado de um stub do MS-DOS, o header PE e os headers da seção arredondados para um múltiplo de FileAlignment.
  \ This campo indicates how much space em the arquivo is used for representing all the arquivo headers, 
  \ including the MS-DOS header, PE arquivo header, PE optional header, and PE Section Headers. O section bodies inicie sob this location em the arquivo.
  Um número denominado CheckSum, 
  \ A verificação de arquivo de imagem. 
  \O algoritmo para calcular a verificação é incorporado em IMAGHELP.DLL. 
  \Os seguintes são verificados quanto à validação no tempo de carregamento: 
  \todos os drivers, qualquer DLL carregada no momento da inicialização e qualquer DLL carregada em um processo Windows crítico.
  \ A checksum value is used para validate the executable arquivo sob load time. 
  \ O value is set and verified by the linker. O algorithm used for creating these checksum values is proprietary information and will not be published.
  Uma word denominada Subsystem, 
  \ Field used para identify the target Subsystem for this executable O subsistema necessário para executar esta imagem. 
  \Each of the possible Subsystem values are listed em the WINNT.H arquivo immediately after the IMAGE_OPTIONAL_HEADER structure.
  \Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#windows-Subsystem
  Uma word denominada DllCharacteristics,
  \ Flags used para indicate if a DLL image includes entry points for process and thread initialization and termination.
  \ Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#dll-Characteristics
  Um número denominado MaxStack, [SizeOfStackReserve]
  \These fields control the amount of address space para reserve and commit for the stack and default heap. 
  \ O tamanho da pilha a ser reservada. Somente SizeOfStackCommit está comprometido; 
  \o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.
  Um número denominado MinStack, [SizeOfStackCommit]
  \Both the stack and heap have default values of 1 page committed and 16 pages Reserved. 
  \ O tamanho da pilha a ser confirmada.
  Um número denominado MaxHeap, [SizeOfHeapReserve]
  \These values are set com the linker switches -STACKSIZE: and -HEAPSIZE:. 
  \O tamanho do espaço de heap local a ser reservado. 
  \Somente SizeOfHeapCommit está comprometido; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.
  Um número denominado MinHeap, [SizeOfHeapCommit]
  \ O tamanho do espaço de heap local a ser confirmado.
  Um número denominado LoaderFlags, 
  \ Reservado, deve ser zero. Tells the loader whether para break sobre load, debug over load, or the default, which is para let things run normally.
  \ directories (16 address e size pairs)
  Um número denominado NumberOfDirectories, [NumberOfRvaAndSizes]
  \ O número de entradas de diretório de dados no restante do header opcional. Cada uma descreve uma localização e um tamanho.
  8 bytes denominados Directory0,
  Um número denominado ImageDirectoryEntryImportAddress,
  Um número denominado ImageDirectoryEntryImportSize,
  112 bytes denominados Directories2-15,
  Um PE Section Header denominado Idata Section,
  Um PE Section Header denominado Data Section,
  Um PE Section Header denominado Code Section. \ https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#section-flags

Um PE Section Header é um estrutura com
  8 bytes denominados Nome, \ Each section header has a name fielf up to eight characters long, for which the first character must be a period.
  Um número denominado SizeInBytes,
  Um número denominado AddressInMemory,
  Um número denominado SizeInFile,
  Um número denominado AddressInFile,
  12 bytes denominados Reserved,
  Um número denominado Characteristics. \ Defines the section Characteristics. 
  \These values are encontrado both em WINNT.H and in the Portable Executable Format specification.

Uma phrase é uma string.

\Etapas para que se determine se uma string looks like English:
\Carregue o dicionário léxico.
\Se o dicionário léxico for inexistente, mostre erro "Não foi possível encontrar o dicionário léxico."; diga não.
\Se a string estiver em branco, diga não.
\Lance um subtexto sobre a string.
\Atribua o caractere final deste subtexto ao caractere inicial deste subtexto.
\Comece. [a executar o código abaixo]
  \Se o caractere inicial deste subtexto é o caractere inicial desta string, pare.
  \Se o target deste caractere inicial deste subtexto for o caractere de espaço, adicione 1 para o caractere inicial deste subtexto; pare.
  \Subtraia 1 desde o caractere inicial deste subtexto.
\Recomece. [percorra novamente o código acima]
\Se o subtexto estiver no catálogo deste dicionário léxico, diga sim.
\[Se as condições acima não puderem ser satisfeitas, então:] Diga não.

Etapas para que se pluralize uma string (strings em português):
  Lance um percorredor sobre a string.
  Comece. [a executar o código abaixo]
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Se uma plural string não estiver em branco, posponha " " para o plural string.
    Posponha o segmento inicial deste percorredor para a plural string.
    Se o segmento inicial deste percorredor for "de ", ative um detector; recomece. \ aqui identifica um termo composto. Falta implementar.
    Se o detector não estiver ativo, pluralize o plural string (português - regras comuns) .
    \Se o detector estiver ativo, pluralize o plural string (substantivos compostos).
  Recomece. [percorra novamente o código acima]
  Atribua a plural string à string.

Etapas para que se pluralize uma string (português - regras comuns) :
  \PAL
  \# https://www.normaculta.com.br/singular-e-plural/
  \# palavras que são exceções às regras
  \Se a string for "bit", atribua "bits" à string; retorne.
  Se a string for "caráter", atribua "carateres" à string; retorne.
  Se a string for "de", atribua "de" à string; retorne.
  Se a string for "júnior", atribua "juniores" à string; retorne.
  Se a string for "sênior", atribua "seniores" à string; retorne.
  \# advérbios principais
  Se a string for "muito", retorne.
  Se a string for "pouco", retorne.
  Se a string for "mais", retorne.
  Se a string for "menos", retorne.
  Se a string for "bastante", retorne.
  Se a string for "quase", retorne.
  Se a string for "demais", retorne.
  Se a string for "bem", retorne.
  Se a string for "deveras", retorne.
  Se a string for "mal", retorne.
  Se a string for "melhor", retorne.
  Se a string for "pior", retorne.
  \# palavras terminadas com "ão"
  Se a string termina com "ão", pluralize a string (terminada com "ão"); retorne.
  \# palavras terminadas com "d"
  Se a string termina com "d", pluralize a string (terminada com outras letras); retorne.
  \# palavras terminadas com "l"
  Se a string termina com "l", pluralize a string (terminada com "l"); retorne.
  \# palavra terminadas com "m"
  Se a string termina com "m", remove o last byte desde a string; posponha "ns" para a string; retorne.
  \# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
  Se a string termina com "n", posponha "es" para a string; retorne.
  \# palavras terminadas com "r"
  Se a string termina com "r", pluralize a string (terminada com "r"); retorne.
  \# palavras terminadas com "s"
  Se a string termina com "s", pluralize a string (terminada com "s"); retorne.
  \# palavras terminadas com "t"
  Se a string termina com "t", pluralize a string (terminada com outras letras); retorne.
  \# palavra terminadas com "x"
  Se a string termina com "x", pluralize a string (terminada com "x"); retorne.
  \# palavras terminadas com "z"
  Se a string termina com "z", pluralize a string (terminada com "z"); retorne.
  Se a string termina com "#", posponha "s" para a string; retorne.
  Se a string for "de", atribua "de" à string; retorne.
  Se a string não termina com alguma vogal ou com alguma consoante, posponha "s" para a string; retorne.
  \# regra padrão
  [Se as condições acima não puderem ser satisfeitas, então:] 
  Posponha "s" para a string. \ Só acrescenta o "s" caso nenhuma das condições acima tenha siddo correspondida. 
  \Volte.

Etapas para que se pluralize uma string (terminada com "ão"):
  \A formação do plural dos substantivos terminados -ão pode ser feita de três formas distintas: -ões, -ãos, -ães.
  \Alguns substantivos terminados em -ão admitem duas (ou até três) formas no plural:
  \refrão - refrãos ou refrães;
  \corrimão - corrimões ou corrimãos;
  \guardião - guardiões ou guardiães;
  \vilão - vilões, vilãos ou vilães.
  Se a string for "cidadão", posponha "s" para a string; retorne.
  Se a string for "irmão", posponha "s" para a string; retorne.
  Se a string for "cristão", posponha "s" para a string; retorne.
  Se a string for "refrão", posponha "s" para a string; retorne.
  Se a string for "mão", posponha "s" para a string; retorne.
  Se a string for "são", posponha "s" para a string; retorne.
  \-ão no singular para -ães no plural:
  \Alguns substantivos terminados em -ão formam o plural com -ães.
  Se a string for "pão", remove o last byte desde a string; posponha "es" para a string; retorne.
  Se a string for "capitão", remove o last byte desde a string; posponha "es" para a string; retorne.
  Se a string for "alemão", remove o last byte desde a string; posponha "es" para a string; retorne.
  Se a string for "charlatão", remove o last byte desde a string; posponha "es" para a string; retorne.
  \TODOS os substantivos paroxítonos terminados em -ão formam o plural com -ãos. 
  \ALGUNS substantivos oxítonos também têm o seu plural formado segundo essa regra:
  \órfão - órfãos;
  \sótão - sótãos;
  \órgão - órgãos;
  \cidadão - cidadãos;
  \irmão - irmãos;
  \cristão - cristãos.
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.   \ remove o "ão". Acho que não precisa
  \caso encontre acentos em sílabas prévias, faça o seguinte
  Se o subtexto has algum tipo de stressed vogal, posponha "s" para a string; retorne. \-> exemplo: órgão
  \# regra padrão
  \A maioria dos substantivos terminados em -ão forma o plural com -ões:
  \opinião - opiniões;
  \coração - corações;
  \eleição - eleições.
  Remove os last dois bytes desde a string.
  Posponha "ões" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com outras letras):
  Se a string for "de", atribua "de" à string; retorne.  
  Posponha "s" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "l"):
  \# palavras terminadas com "al"
  Se a string termina com "al", pluralize a string (terminada com "al"); retorne. \ MAL -> MALES
  \# palavras terminadas com "el"
  Se a string termina com "el", pluralize a string (terminada com "el"); retorne. \PASTEL - PASTÉIS
  \# palavras terminadas com "il"
  Se a string termina com "il", pluralize a string (terminada com "il"); retorne. \-> FUZIL -> FUZIS
  \# palavras terminadas com "ol"
  Se a string termina com "ol", pluralize a string (terminada com "ol"); retorne. \- LENÇOL -> LENÇÓIS
  \# palavras terminadas com "ul"
  Se a string termina com "ul", pluralize a string (terminada com "ul"); retorne. \ AZUL -> AZUIS \ Cônsul - cônsules
  [Caso a string seja uma sigla, tipo URL]
  Posponha "s" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "al"):
  Se a string for "mal", atribua "males" para a string; retorne.
  Remove o last byte desde a string. \remove a letra L
  Posponha "is" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "el"):
  \Se a string for "pixel", atribua "pixels" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto. \ remove o el
  Se o subtexto has algum tipo de stressed vogal, remove o last byte desde a string; posponha "is" para a string; retorne.
  Remove os last dois bytes desde a string.
  Posponha "éis" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "il"):
  \Se a string for "canil", atribua "canis" para a string; retorne.
  \Se a string for "covil", atribua "covis" para a string; retorne.
  \Se a string for "funil", atribua "funis" para a string; retorne.
  \Se a string for "barril", atribua "barris" para a string; retorne.
  \Se a string for "fuzil", atribua "fuzis" para a string; retorne.
  \Se a string for "redil", atribua "redis" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum tipo de stressed vogal, remove os last dois bytes desde a string; posponha "eis" para a string; retorne.
  Remove o last byte desde a string. \ remove a letra L
  Posponha "s" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "ol"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum tipo de stressed vogal, remove o last byte desde a string; posponha "is" para a string; retorne.
  Remove os last dois bytes desde a string.
  Posponha "óis" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "ul"):
  Se a string for "cônsul", atribua "cônsules" à string; retorne.
  Remove o last byte desde a string. \ remove o L
  Posponha "is" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "r"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum tipo de stressed vogal, posponha "es" para a string; retorne.
  \# hiatos
  Se a string termina com "air", remove os last dois bytes desde a string; posponha "íres" para a string; retorne.
  Se a string termina com "aur", remove os last dois bytes desde a string; posponha "úres" para a string; retorne.
  \# regra padrão
  Posponha "es" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "s"):
\Quando os substantivos terminados em -s são paroxítonos, a formação do plural fica invariável:.
  \# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
  Se a string for "de", atribua "de" à string; retorne.
  Se a string termina com "as", posponha "es" para a string; retorne. \atlas
  \Se a string termina com "as", posponha "-plural" para a string; retorne. \atlas
  Se a string termina com "es",  posponha "es" para a string; retorne. \atlas
  \Se a string termina com "es", posponha "-plural" para a string; retorne.\pires
  Se a string termina com "os",  posponha "es" para a string; retorne. \atlas
  \Se a string termina com "os", posponha "-plural" para a string; retorne. \óculos
  \# hiatos acentuados
  Se a string termina com "aís", posponha "es" para a string; retorne.
  Se a string termina com "aús", posponha "es" para a string; retorne.
  \# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
  Se a string termina com "ás", remove os last dois bytes desde a string; posponha "ases" para a string; retorne.
  Se a string termina com "âs", remove os last dois bytes desde a string; posponha "ases" para a string; retorne.
  Se a string termina com "és", remove os last dois bytes desde a string; posponha "eses" para a string; retorne.
  Se a string termina com "ês", remove os last dois bytes desde a string; posponha "eses" para a string; retorne.
  Se a string termina com "ís", remove os last dois bytes desde a string; posponha "ises" para a string; retorne.
  Se a string termina com "ós", remove os last dois bytes desde a string; posponha "oses" para a string; retorne.
  Se a string termina com "ôs", remove os last dois bytes desde a string; posponha "oses" para a string; retorne.
  Se a string termina com "ús", remove os last dois bytes desde a string; posponha "uses" para a string; retorne.
  \# palavras terminadas com "is", "us"
  Se a string termina com "is", pluralize a string (terminada com "is" ou com "us"); retorne.
  Se a string termina com "us", pluralize a string (terminada com "is" ou com "us"); retorne. \ônibus / vírus
  \Se a string termina com "ts", exit.
  \# regra padrão
  Posponha "es" para a string.
  \Volte.

Etapas para que se pluralize uma string (terminada com "is" ou com "us"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum tipo de stressed vogal, retorne.
  \# hiatos
  Se a string termina com "ais", remove os last dois bytes desde a string; posponha "íses" para a string; retorne. \cais não varia....
  Se a string termina com "aus", remove os last dois bytes desde a string; posponha "úses" para a string; retorne.
  \# regra padrão
  Posponha "es" para a string.
  \Volte.

Etapas para que se pluralize uma string  (terminada com "x"):
  \Se a string for "px", posponha "pxs" para a string; retorne.
  Se a string for "fax", posponha "es" para a string; retorne.
  Posponha "s" para a string. \ tratamento de exceções
  \Volte.
  

Etapas para que se pluralize uma string (terminada com "z"):
  \# hiatos acentuados
  Se a string termina com "aíz", posponha "es" para a string; retorne.
  Se a string termina com "aúz", posponha "es" para a string; retorne.
  \# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
  Se a string termina com "áz", remove os last dois bytes desde a string; posponha "azes" para a string; retorne.
  Se a string termina com "âz", remove os last dois bytes desde a string; posponha "azes" para a string; retorne.
  Se a string termina com "éz", remove os last dois bytes desde a string; posponha "ezes" para a string; retorne.
  Se a string termina com "êz", remove os last dois bytes desde a string; posponha "ezes" para a string; retorne.
  Se a string termina com "íz", remove os last dois bytes desde a string; posponha "izes" para a string; retorne.
  Se a string termina com "óz", remove os last dois bytes desde a string; posponha "ozes" para a string; retorne.
  Se a string termina com "ôz", remove os last dois bytes desde a string; posponha "ozes" para a string; retorne.
  Se a string termina com "úz", remove os last dois bytes desde a string; posponha "uzes" para a string; retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto has algum tipo de stressed vogal, posponha "es" para a string; retorne.
  \# hiatos
  Se a string termina com "aiz", remove os last dois bytes desde a string; posponha "ízes" para a string; retorne.
  Se a string termina com "auz", remove os last dois bytes desde a string; posponha "úzes" para a string; retorne.
  \# regra padrão
  Posponha "es" para a string.
  \Volte.

Etapas para que se pluralize uma string (english rules); \ plural inglês
Etapas para que se pluralize uma string:
  Se a string for "de", atribua "de" à string; retorne.
  Se a string for "centena", atribua "centenas" à string; retorne.
  Se a string for "milhar", atribua "milhares" à string; retorne.
  Se a string for "entrada", atribua "entradas" à string; retorne.
  Se a string for "campo", atribua "campos" à string; retorne.
  Se a string for "fragmento", atribua "fragmentos" à string; retorne.
  Se a string for "parâmetro", atribua "parâmetros" à string; retorne.
  Se a string for "fonte", atribua "fontes" à string; retorne.
  Se a string for "forma", atribua "formas" à string; retorne.
  Se a string for "contexto", atribua "contextos" à string; retorne.
  Se a string for "evento", atribua "eventos" à string; retorne.
  Se a string for "catálogo", atribua "catálogos" à string; retorne.
  Se a string for "índice", atribua "índices" à string; retorne.
  Se a string for "milhão", atribua "milhões" à string; retorne.
  Se a string for "milissegundo", atribua "milissegundos" à string; retorne.
  Se a string for "ponto", atribua "pontos" à string; retorne.
  Se a string for "polígono", atribua "polígonos" à string; retorne.
  Se a string for "objeto", atribua "objetos" à string; retorne.
  Se a string for "grau", atribua "graus" à string; retorne.
  Se a string for "preciso", atribua "precisos" à string; retorne.
  Se a string for "linha", atribua "linhas" à string; retorne.
  Se a string for "fileira", atribua "fileiras" à string; retorne.
  Se a string for "estrutura", atribua "estruturas" à string; retorne.
  Se a string for "conjunto", atribua "conjuntos" à string; retorne.
  Se a string for "texto", atribua "textos" à string; retorne.
  Se a string for "unidade", atribua "unidades" à string; retorne.
  Se a string for "polegada", atribua "polegadas" à string; retorne.
  Se a string for "endereço", atribua "endereços" à string; retorne.
  Se a string for "ponteiro", atribua "ponteiros" à string; retorne.
  Se a string for "comando", atribua "comandos" à string; retorne.
  Se a string for "tipo", atribua "tipos" à string; retorne.
  Se a string for "nome", atribua "nomes" à string; retorne.
  Se a string for "extensão", atribua "extensões" à string; retorne.
  Se a string for "rotina", atribua "rotinas" à string; retorne.
  Se a string for "imagem", atribua "imagens" à string; retorne.
  Se a string for "figura", atribua "figuras" à string; retorne.
  Se a string for "variável", atribua "variáveis" à string; retorne.
  Se a string for "cabeçalho", atribua "cabeçalhos" à string; retorne.
  Se a string for "rotina", atribua "rotinas" à string; retorne.
  Se a string for "tarefa", atribua "tarefas" à string; retorne.
  Se a string for "procedimento", atribua "procedimentos" à string; retorne.
  Se a string for "função", atribua "funções" à string; retorne.
  Se a string for "redimensionador", atribua "redimensionadores" à string; retorne.
  Se a string for "botão", atribua "botões" à string; retorne.
  Se a string for "segmento", atribua "segmentos" à string; retorne.
  Se a string for "segmento de cabeçalho", atribua "segmentos de cabeçalhos" à string; retorne.
  \ nouns only
  Se a string for "alumnus", atribua "alumni" à string; retorne.
  Se a string for "auto", atribua "autos" à string; retorne.
  Se a string for "botão", atribua "botões" à string; retorne.
  Se a string for "cello", atribua "cellos" à string; retorne.
  Se a string for "dwarf", atribua "dwarfs" à string; retorne.
  Se a string for "foot", atribua "feet" à string; retorne.
  Se a string for "forma", atribua "formas" à string; retorne.
  Se a string for "genus", atribua "genera" à string; retorne.
  Se a string for "goose", atribua "geese" à string; retorne.
  Se a string for "hippo", atribua "hippos" à string; retorne.
  Se a string for "louse", atribua "lice" à string; retorne.
  Se a string for "memo", atribua "memos" à string; retorne.
  Se a string for "mouse", atribua "mice" à string; retorne.
  Se a string for "ox", atribua "oxen" à string; retorne.
  Se a string for "phenomenon", atribua "phenomena" à string; retorne.
  Se a string for "photo", atribua "photos" à string; retorne.
  Se a string for "phylum", atribua "phyla" à string; retorne.
  Se a string for "piano", atribua "pianos" à string; retorne.
  Se a string for "pimento", atribua "pimentos" à string; retorne.
  Se a string for "pro", atribua "pros" à string; retorne.
  Se a string for "proof", atribua "proofs" à string; retorne.
  Se a string for "radius", atribua "radii" à string; retorne.
  Se a string for "rhinoceros", atribua "rhinoceri" à string; retorne.
  Se a string for "roof", atribua "roofs" à string; retorne.
  Se a string for "solo", atribua "solos" à string; retorne.
  Se a string for "soprano", atribua "sopranos" à string; retorne.
  Se a string for "staff", atribua "staffs" à string; retorne.
  Se a string for "tooth", atribua "teeth" à string; retorne.
  Se a string for "torus", atribua "tori" à string; retorne.
  Se a string for "turf", atribua "turfs" à string; retorne.
  Se a string for "virus", atribua "viruses" à string; retorne.
  Se a string termina com "sh", posponha "es" para a string; retorne.
  Se a string termina com "ch", posponha "es" para a string; retorne.
  Se a string termina com "man", remove os last dois bytes desde a string; posponha "en" para a string; retorne.
  Se a string termina com "child", posponha "ren" para a string; retorne.
  Se a string termina com "ex", remove os last dois bytes desde a string; posponha "ices" para a string; retorne. \ ou adicione ES
  Se a string termina com "fe", remove os last dois bytes desde a string; posponha "ves" para a string; retorne.
  Se a string termina com "is", remove os last dois bytes desde a string; posponha "es" para a string; retorne.
  Se a string termina com "ix", remove os last dois bytes desde a string; posponha "ices" para a string; retorne. \ ou adicione ES
  Se a string termina com "ma", posponha "ta" para a string; retorne. \ ou adicione S
  Se a string termina com alguma consoante e "y", remove o last byte desde a string; posponha "ies" para a string; retorne.
  Se a string termina com algum tipo de vogal e "o", posponha "s" para a string; retorne.
  Se a string termina com algum tipo de vogal e "y", posponha "s" para a string; retorne.
  Se a string termina com "f", remove o last byte desde a string; posponha "ves" para a string; retorne.
  Se a string termina com "s", posponha "es" para a string; retorne.
  Se a string termina com "x", posponha "es" para a string; retorne.
  Se a string termina com "z", posponha "es" para a string; retorne.
  Posponha "s" para a string.

Uma prototype string é um estrutura com 
  Um caractere inicial e 
  Um caractere final .

Etapas para que se atribua o endereço exe completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remove algum tipo de trailing barra invertida desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".exe" ao endereço completo.

Etapas para que se atribua o exe size deste compilador para um size:
  Atribua 4096 [section base] ao size.
  Adicione o size desta import zona para o size.
  Adicione o size desta zona de dados para o size.
  Adicione o size desta zona de código para o size.

Etapas para que se atribua o listagem endereço completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remove algum tipo de trailing barra invertida desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".lst" ao endereço completo.

Etapas para que se atribua um termo para um segundo termo:
  Atribua a variável deste termo à variável deste segundo termo.
  Atribua a phrase deste termo ao phrase deste segundo termo.

Etapas para que se carregue um source file:
  Se o source file for inexistente, retorne.
  \Carregue o endereço completo deste source file ao trecho deste source file.
  \Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " junto com o endereço completo deste source file seguido de "."; retorne.
  Carregue o endereço completo deste source file para uma string.
  Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " junto com o endereço completo deste source file seguido de "."; retorne.
  Parse a string para o trecho deste source file (para expandir contrações).

Etapas para que se carregue uns sources files:
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um item desde o endereço da pasta deste compilador.
    Se o item não for encontrado, pare.
    Se a categoria deste item não for "arquivo", recomece.
    Se a extensão deste item não estiver em branco, recomece.
    Se o item parece ser encadernável, recomece.
    Adicione um source file para o sources files usando o endereço completo deste item.
    Carregue o source file.
  Recomece. [percorra novamente o código acima]

O percorredor de contrações é um percorredor.

Etapas para que se parse uma string para uma segunda string (para expandir contrações):
  Limpe a segunda string.
  Limpe uma terceira string.
  Lance o percorredor de contrações sobre a string.
  Comece. [a executar o código abaixo]
    Se o segmento final deste percorredor de contrações estiver em branco, retorne.
    Posicione o segmento inicial deste percorredor de contrações sobre o segmento final deste percorredor de contrações. 
    Mova o percorredor de contrações (englobando tudo).
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor de contrações não for algum tipo de glom byte, posponha o segmento inicial deste percorredor de contrações para a segunda string; recomece.
    Posponha o segmento inicial deste percorredor de contrações para a segunda string usando a terceira string (para expandir contrações).
    Atribua o segmento inicial deste percorredor de contrações à terceira string.
  Recomece. [percorra novamente o código acima]

Etapas para que se reduza umas unidades semânticas por utility use:
  Obtenha uma unidade semântica desde os unidades semânticas.
  Se o unidade semântica for inexistente, retorne.
  Se o type deste unidade semântica for inexistente, recomece.
  Reduza o type deste unidade semântica para um type por utility use.
  Se o type não for inexistente, atribua o type ao type deste unidade semântica.
  Recomece. [percorra novamente o código acima]

Etapas para que se reduza um type para um segundo type por utility use:
  Atribua o type ao segundo type.
  Comece. [a executar o código abaixo]
    Se o segundo type for inexistente, retorne.
    Se o nome deste segundo type for "texto hexadecimal", retorne.
    Se o nome deste segundo type for "string", retorne.
    Se o nome deste segundo type for "texto", retorne.
    Se o nome deste segundo type for "número", retorne.
    Se o nome deste segundo type for "ponteiro", retorne.
    Se o nome deste segundo type for "coisa", esvazie o segundo type; retorne.
    \PAL
    \Se o nome deste segundo type for "elemento", esvazie o segundo type; retorne.
    Se o base type deste segundo type for o segundo type, esvazie o segundo type; retorne.
    Atribua o base type deste segundo type ao segundo type.
  Recomece. [percorra novamente o código acima]

Etapas para que se organize o catálogo de rotinas úteis:
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um bucket usando o catálogo de rotinas úteis.
    Se o bucket for inexistente, retorne.
    Se os referências deste bucket estiverem vazios, recomece.
    Organize o catálogo de rotinas úteis usando os referências deste bucket.
  Recomece. [percorra novamente o código acima]

Etapas para que se organize o catálogo de rotinas úteis usando umas referências:
    Obtenha uma referência desde as referências.
    Se a referência for inexistente, retorne.
    Atribua o ponteiro deste referência para uma rotina.
    Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno na função: organize o catálogo de rotinas úteis usando umas referências"; retorne.
    Copie os unidades semânticas desta rotina para umas unidades semânticas.
    Reduza os unidades semânticas por utility use.
    Catalogue a rotina usando os unidades semânticas e o catálogo geral de rotinas.
    Destrua os unidades semânticas.
  Recomece. [percorra novamente o código acima]

Etapas para que se remove algum tipo de negatives desde umas unidades semânticas devolvendo um detector:
  Desative o detector.
  Permute os unidades semânticas com umas segunda unidades semânticas.
  Comece. [a executar o código abaixo]
    Atribua o first unidade semântica destas segunda unidades semânticas para uma unidade semântica.
    Se o unidade semântica for inexistente, retorne.
    Remove o unidade semântica desde a segunda unidades semânticas.
    \PAL
    Se a string deste unidade semântica for "não", reverse o detector; destrua o unidade semântica; recomece.
    \Se a string deste unidade semântica for "nada", reverse o detector; destrua o unidade semântica; recomece.
    \CAL
    Se a string deste unidade semântica for "not", reverse o detector; destrua o unidade semântica; recomece.
    \Se a string deste unidade semântica for "nothing", reverse o detector; destrua o unidade semântica; recomece.
    Posponha o unidade semântica para os unidades semânticas.
    Se a string deste unidade semântica for "can't", reverse o detector; atribua "can" à string deste unidade semântica; recomece.
    \Se a string deste unidade semântica for "cannot", reverse o detector; atribua "can" à string deste unidade semântica; recomece.
    Se a string deste unidade semântica for "nothing", reverse o detector; atribua "something" à string deste unidade semântica; recomece.
    Se a string deste unidade semântica for "nada", reverse o detector; atribua "something" à string deste unidade semântica; recomece.
    Se a string deste unidade semântica for "won't", reverse o detector; atribua "will" à string deste unidade semântica; recomece.
    Se a string deste unidade semântica termina com "n't", reverse o detector; remove trailing bytes desde a string deste unidade semântica usando 3; recomece.
  Recomece. [percorra novamente o código acima]

  

Etapas para que se resolva um campo:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o campo for inexistente, retorne.
  Resolva o campo como uma variável.
  Se o nickname deste campo não for algum tipo de valid campo nome, limpe o nickname deste campo. \it
  Se o nome deste campo não for algum tipo de valid campo nome, apresente uma mensagem de erro contendo "'" junto com o nome deste campo seguido de "' é um campo nome inválido." e o local de aparição deste campo; retorne.

Etapas para que se resolva um global:
  Se o global for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o global body deste global não estiver em branco, resolva o global (compile body).
  Se o type nome deste global estiver em branco, apresente uma mensagem de erro contendo "Tipo inválido: " junto com o nome deste global seguido de "' . O tipo da variável global está vazio." e o local de aparição deste global; retorne.
  Resolva o global como uma variável.

Etapas para que se resolva um global (compile body):
  Se o global for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Lance um percorredor sobre o global body deste global.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de literal, apresente uma mensagem de erro contendo "Erro de tipo. O tipo: " junto com o segmento inicial deste percorredor seguido de "' deve ser do tipo literal." e o percorredor; retorne.
  Compile um literal usando o percorredor.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Acho que era bom colocar um ponto por aqui, né?" e o percorredor; retorne.
  Se o type nome deste global estiver em branco, atribua o nome deste type deste literal ao type nome deste global.
  Atribua o literal ao literal deste global.
  Catalogue o literal.

Etapas para que se resolva uns globals:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um global desde o globals.
  Se o global for inexistente, retorne.
  Resolva o global.
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva um type (base type):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type for inexistente, retorne.
  Se o base type deste type não for inexistente, retorne.
  Encontre o base type deste type usando o base nome deste type e o catálogo de tipos.
  Se o base type deste type for inexistente, apresente uma mensagem de erro contendo "Erro. Tipo base '" junto com o base nome deste type seguido de "' inválido." e o local de aparição deste type; retorne.
  Ligue o cooking detector deste type.
  Se o cooking detector deste base type deste type estiver ativo, apresente a mensagem de erro contendo "Definição recursiva com: " junto com o base nome deste type seguido de "." e o local de aparição deste type; retorne.
  Resolva o base type deste type (base type).
  Desative o cooking detector deste type.

Etapas para que se resolva um type (expand coisa): \ base type deste type não está resolved yet
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type for inexistente, retorne.
  Se o base type deste type não for inexistente, retorne.
  Se o nome deste type for "coisa", retorne.
  \Se o nome deste type for "elemento", retorne.
  Se o type não puder ser reduzido para "coisa" using o base nome, retorne.
  Encontre um base type usando o base nome deste type e o catálogo de tipos.
  \ adicione coisa estrutura - o número of secret campos é hard coded em two places: search por "du que 4" \ was 6
  Atribua o nome deste type seguido de " estrutura" para um nome.
  Atribua o nome deste type seguido de " estruturas" para um plural nome.
  Atribua o nome deste base type seguido de " estrutura" para um base nome.
  Adicione um conjunto type para os types usando o nome e o plural nome e o base nome.
  Adicione um campo para os campos deste conjunto type usando "next " junto com o nome deste type e "next" e o nome deste type e o detector de ignição.
  \PAL antecedente\anterior\prévio e subseqüente\posterior
  Adicione um portuguese campo para os campos deste conjunto type usando "seguinte " junto com o nome deste type e "seguinte" e o nome deste type e o detector de ignição.
  Atribua "next " junto com o nome deste type ao redefinition conteúdo nome deste portuguese campo.
  \Adicione um portuguese reverse campo para os campos deste conjunto type usando o nome deste type seguido de " seguinte" e "seguinte" e o nome deste type e o detector de ignição.
  \Atribua "next " junto com o nome deste type ao redefinition conteúdo nome deste portuguese reverse campo.
  Adicione um segundo campo para os campos deste conjunto type usando "previous " junto com o nome deste type e "previous" e o nome deste type e o detector de ignição.
  \Adicione uma segunda portuguese campo para os campos deste conjunto type usando "anterior " junto com o nome deste type e "anterior" e o nome deste type e o detector de ignição.
  \Atribua "previous " junto com o nome deste type ao redefinition conteúdo nome desta segunda portuguese campo.
  Adicione um segundo portuguese reverse campo para os campos deste conjunto type usando o nome deste type seguido de " anterior" e "anterior" e o nome deste type e o detector de ignição.
  Atribua "previous " junto com o nome deste type ao redefinition conteúdo nome deste segundo portuguese reverse campo.
  Se os campos deste type não estiverem vazios, posponha os campos deste type para os campos deste conjunto type.
  Catalogue o conjunto type.
  \ fix para cima original type para look like um ponteiro
  Atribua o nome deste conjunto type ao conteúdo nome deste type.
  \ adicione chain type
  Adicione um chain type para os types usando o plural nome deste type e "" e o plural nome deste base type.
  Adicione um terceiro campo para os campos deste chain type usando "first " junto com o nome deste type e "first" e o nome deste type e o detector de ignição.
  Adicione um terceiro portuguese campo para os campos deste chain type usando "primeiro " junto com o nome deste type e "primeiro" e o nome deste type e o detector de ignição.
  Atribua "first " junto com o nome deste type ao redefinition conteúdo nome deste terceiro portuguese campo.
  Adicione um terceiro feminine portuguese campo para os campos deste chain type usando "primeira " junto com o nome deste type e "primeira" e o nome deste type e o detector de ignição.
  Atribua "first " junto com o nome deste type ao redefinition conteúdo nome deste terceiro feminine portuguese campo.
  Adicione um quarto campo para os campos deste chain type usando "last " junto com o nome deste type e "last" e o nome deste type e o detector de ignição.
  Adicione um quarto portuguese campo para os campos deste chain type usando "último " junto com o nome deste type e "último" e o nome deste type e o detector de ignição.
  Atribua "last " junto com o nome deste type ao redefinition conteúdo nome deste quarto portuguese campo.
  Adicione um quarto portuguese feminine campo para os campos deste chain type usando "última " junto com o nome deste type e "última" e o nome deste type e o detector de ignição.
  Atribua "last " junto com o nome deste type ao redefinition conteúdo nome deste quarto portuguese feminine campo.
  Catalogue o chain type.

Etapas para que se resolva um type (registro de plurais):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type for inexistente, retorne.
  Se o plural nome deste type estiver em branco, retorne.
  Se o type puder ser reduzido para "coisa" using o base nome, retorne.
  Catalogue o type usando o plural nome deste type.

Etapas para que se resolva um type (optional info - ponteiro):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o conteúdo type deste type não for inexistente, retorne.
  Se o conteúdo nome deste type estiver em branco, atribua o conteúdo type deste base type deste type ao conteúdo type deste type; retorne.
  Encontre o conteúdo type deste type usando o conteúdo nome deste type e o catálogo de tipos.
  Se o conteúdo type deste type for inexistente, apresente uma mensagem de erro contendo "Não sei bem pra que coisa você está se referindo." e o local de aparição deste type; retorne.

Etapas para que se resolva um type (optional info - conjunto):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se os campos deste type estiverem vazios, copie os campos deste base type deste type aos campos deste type; retorne.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Obtenha um campo desde os campos deste type (backwards).
    Se o campo for inexistente, pare.
    Se o campo estiver duplicada em os campos deste type, apresente uma mensagem de erro contendo "O campo '" junto com o nome deste campo seguido de "' está definido mais de uma vez." e o local de aparição deste campo; retorne.
    Resolva o campo.
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o cooking detector deste type deste campo estiver ativo, apresente a mensagem de erro contendo "Definição recursiva encontrada no '" junto com o nome deste type deste campo seguido de "'." e o local de aparição deste campo; retorne.
    Resolva o type deste campo (optional info). \ de novo
    Se o reference detector deste campo não estiver ativo, recomece.
    Se o type deste campo não puder ser reduzido para "ponteiro", apresente a mensagem de erro contendo "Não entendi o parâmetro '(reference)' nesse campo: " junto com o nome deste campo seguido de "'..." e o local de aparição deste campo; retorne.
  Recomece. [percorra novamente o código acima]
  Eliminate duplicate nicknames desde os campos deste type.
  Se o type não puder ser reduzido para "coisa estrutura", retorne.
  Se a contagem destes campos deste type for maior do que 4, retorne. \ already copied? was 2 por next e prev, now 6 para included Spanish redefiniions
  Copie os campos deste base type deste type aos campos deste type (data campos only).

Etapas para que se resolva um type (optional info - scale):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua o base type deste type para um base type.
  Se a razão de escala deste type for 0, atribua a razão de escala deste base type deste type à razão de escala deste type; retorne.
  Se a razão de escala deste base type for 0, retorne.
  Multiplique a razão de escala deste type pela razão de escala deste base type.
  Atribua o base type deste base type ao base type deste type.

Etapas para que se resolva um type (optional info):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o type for inexistente, retorne.
  Se o optional info resolved detector deste type estiver ativo, retorne.
  Se o base type deste type for o type, retorne. \ por built em types
  Verifique por informações opcionais inválidas em o type.
  Ligue o cooking detector deste type.
  Resolva o base type deste type (optional info).
  Se o type puder ser reduzido para "ponteiro", resolva o type (optional info - ponteiro).
  Se o type puder ser reduzido para "estrutura", resolva o type (optional info - conjunto). \ mudar aqui
  Se o type puder ser reduzido para "número", resolva o type (optional info - scale).
  Desative o cooking detector deste type.
  Ligue o optional info resolved detector deste type.

Etapas para que se resolva uns types (base types):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Resolva o type (base type).
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva uns types (expand coisas):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Resolva o type (expand coisa).
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva uns types (registro de plurais):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Resolva o type (registro de plurais).
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva uns types (optional info):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um type desde o types.
  Se o type for inexistente, retorne.
  Resolva o type (optional info).
  Recomece. [percorra novamente o código acima]

Etapas para que se resolva uma variável:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a variável for inexistente, retorne.
  Se a type desta variável não for inexistente, retorne.
  Se o type nome desta variável não estiver em branco, resolva a variável (explicit type nome); retorne.
  Encontre o type desta variável e o nickname desta variável usando o nome desta variável.
  Se o type desta variável não for inexistente, atribua o nome deste type desta variável ao type nome desta variável; retorne.
  Apresente uma mensagem de erro contendo "Não achei o tipo da variável: " junto com o nome desta variável seguido de "." e o local de aparição desta variável.

Etapas para que se resolva uma variável (explicit type nome):
  Encontre o type desta variável usando o type nome desta variável e o catálogo de tipos.
  Se o type desta variável for inexistente, apresente uma mensagem de erro contendo "Não achei o nome do tipo da variável: " junto com o type nome desta variável seguido de "." e o local de aparição desta variável; retorne.

  

Etapas para que se arredonde para cima zona sizes:
  Atribua a quantidade de caracteres desta import zona ao size desta import zona.
  Arredonde o size desta import zona para cima para o múltiplo imediato of 4096.
  Atribua a quantidade de caracteres desta zona de dados ao size desta zona de dados.
  Arredonde o size desta zona de dados para cima para o múltiplo imediato of 4096.
  Atribua a quantidade de caracteres desta zona de código ao size desta zona de código.
  Arredonde o size desta zona de código para cima para o múltiplo imediato of 4096.

Uma instrução é um subtexto.

Um cabeçalho de rotina é um subtexto.

O catálogo geral de rotinas é um catálogo.

Uma rotina é uma coisa com
  Um local de aparição (reference),
  Um detector de compatibilidade,
  Um detector de deliberação,
  Um detector de função,
  Um compiled detector,
  Um nickname catálogo,
  Um representação interna da rotina , 
  Uns unidades semânticas, 
  Uns parâmetros, 
  Um parâmetro size,
  Um employs representação interna da rotina ,
  Some locals, 
  Um local size,
  Um cabeçalho de rotina, 
  Um header string,
  Umas instruções, 
  Um body string,
  Some fragments,
  Um endereço.

Um rotina reference é umas unidades semânticas.

As rotinas são umas rotinas.

Etapas para que se examine algum tipo de optional info por um type usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor for "to", examine algum tipo de optional info pelo type usando o percorredor (ponteiro); retorne.
  Se o segmento inicial deste percorredor for "para", examine algum tipo de optional info pelo type usando o percorredor (ponteiro); retorne.
  Se o segmento inicial deste percorredor for algum tipo de com, examine algum tipo de optional info pelo type usando o percorredor (conjunto); retorne.

Etapas para que se examine algum tipo de optional info por um type usando um percorredor (ponteiro):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente uma mensagem de erro contendo "A palavra 'to' precisa de um artigo indefinido depois dela, não de um: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o conteúdo nome deste type usando o percorredor.

Etapas para que se examine algum tipo de optional info por um type usando um percorredor (conjunto):
  Mova o percorredor (usando diretrizes de compilação).
  Examine o campos deste type usando o percorredor.

Etapas para que se examine algum tipo de pauses usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor não for algum tipo de pause, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um campo usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Examine o campo usando o percorredor (type part).
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor for algum called, examine o campo usando o percorredor (called part); recomece.
    Se o segmento inicial deste percorredor for "sob", examine o campo usando o percorredor (redefine part); recomece.
    \Se o segmento inicial deste percorredor for "equivalente a", examine o campo usando o percorredor (redefine part); recomece.
    \Se o segmento inicial deste percorredor for "análogo a", examine o campo usando o percorredor (redefine part); recomece.
    \Se o segmento inicial deste percorredor for "análoga a", examine o campo usando o percorredor (redefine part); recomece.
    Se o segmento inicial deste percorredor for "em", examine o campo usando o percorredor (redefine part); recomece.
    Se o segmento inicial deste percorredor for "sob", examine o campo usando o percorredor (redefine part); recomece.
    Se o segmento inicial deste percorredor for "sobre", examine o campo usando o percorredor (redefine part); recomece.
    Se o segmento inicial deste percorredor for "redefinindo", examine o campo usando o percorredor (redefine part); recomece.
    Se o segmento inicial deste percorredor for algum tipo de reference, examine o campo usando o percorredor (reference part); recomece.

Etapas para que se examine um campo usando um percorredor (called part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o type nome deste campo estiver em branco, atribua o nome deste campo ao type nome deste campo. \ byte array type nome already filled in
  Examine o nome deste campo usando o percorredor.

Etapas para que se examine um campo usando um percorredor (redefine part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo definido, apresente uma mensagem de erro contendo "Eu estava esperando o artigo 'the', mas o que encontrei foi: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o redefinition conteúdo nome deste campo usando o percorredor.

Etapas para que se examine um campo usando um percorredor (reference part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ligue o reference detector deste campo.

Etapas para que se examine um campo usando um percorredor (type part - byte array):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Reduza a proporção.
  Se o denominador desta proporção não for 1, apresente uma mensagem de erro contendo "Você precisa especificar um número completo de bytes para um byte array" e o percorredor; retorne.
  Atribua o numerador desta proporção à contagem deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "byte" ou "bytes", apresente a mensagem de erro contendo "Erro. Você precisa adicionar a palavra 'bytes' depois de um número designador." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "byte" ao type nome deste campo.

Etapas para que se examine um campo usando um percorredor (type part - normal):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente uma mensagem de erro contendo "Falta por um artigo idefinido aqui, mas você colocou isso: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  \Se o segmento inicial deste percorredor for "another", atribua "segunda" ao nome deste campo.
  \PAL
  Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outras", atribua "outras" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste campo.
  Se o segmento inicial deste percorredor for "outros", atribua "outros" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundos", atribua "segundos" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste campo.
  Se o segmento inicial deste percorredor for "segundas", atribua "segundas" ao nome deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Extend o nome deste campo com o nome.

Etapas para que se examine um campo usando um percorredor (type part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor for algum tipo de numeric literal, examine o campo usando o percorredor (type part - byte array); retorne.
  Examine o campo usando o percorredor (type part - normal).

Etapas para que se examine uns campos usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione um campo para o campos usando "campo" e o caractere inicial deste segmento inicial deste percorredor.
  Examine o campo usando o percorredor.
  Se o segmento inicial deste percorredor não for algum tipo de pause, retorne.
  Examine algum tipo de pauses usando o percorredor.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um global body usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste global body.
  Atribua -1 ao caractere final deste global body.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne. \ o retorne sai da rotina
    Se o segmento inicial deste percorredor estiver em branco, retorne. \ o comando recomece volta pro começo do loop
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne. \ o comando pare sai do loop, mas não sai da rotina, apenas do loop
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste global body.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um global usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione o global para os globals usando "global" e o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome deste global usando o percorredor.
  Se o segmento inicial deste percorredor for algum tipo de operador de atribuição de estruturas compostas, examine o global usando o percorredor (has ou have); retorne.
  Se o segmento inicial deste percorredor não for algum tipo de operador de atribuição simples, apresente uma mensagem de erro contendo "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, examine o global usando o percorredor (literal termo); retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o type nome deste global usando o percorredor.
  Se o segmento inicial deste percorredor for o início of algum tipo de optional info, examine o global usando o percorredor (optional info); retorne.
  Se o segmento inicial deste percorredor for algum tipo de operador de atribuição composto, examine o global usando o percorredor (data part); retorne.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Toda definição precisa terminar com um ponto. Inclusive essa." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um global usando um percorredor (data part):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de to, apresente uma mensagem de erro contendo "Depois da palavra 'equal' você precisa por um palavra 'to'. Você colocou;: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o global body deste global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Falta terminar um frase com um ponto." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um global usando um percorredor (has ou have):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "~inline " junto com o nome deste global seguido de " type" para um nome.
  Atribua o nome seguido de "s" para um plural nome.
  Adicione um type para os types usando o nome e o plural nome e "estrutura" e o local de aparição deste global. \mudar aqui
  Catalogue o type.
  Atribua o nome deste type ao type nome deste global.
  Examine os campos deste type usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Aprenda a escrever direito. Cadê o ponto?." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um global usando um percorredor (literal termo):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Examine o global body deste global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Aprenda a escrever corretamente. Cadê o ponto final?." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um global usando um percorredor (optional info):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Atribua "~inline " junto com o nome deste global seguido de " type" para um nome.
  Atribua o nome seguido de "s" para um plural nome.
  Adicione um type para os types usando o nome e o plural nome e o type nome deste global e o local de aparição deste global.
  Catalogue o type.
  Atribua o nome deste type ao type nome deste global.
  Examine algum tipo de optional info pelo type usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Tá na hora de aprender a escrever direito. Cadê o ponto?." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o global.

Etapas para que se examine um nome usando um percorredor:
  Limpe o nome.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o percorredor estiver sobre algum tipo de nome starter, extend o nome com o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o percorredor estiver sobre algum tipo de nome ender, pare.
    Extend o nome com o segmento inicial deste percorredor.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]
  Se o nome estiver em branco, apresente uma mensagem de erro contendo "Acho que faltou colocar um nome por aqui. Você escreveu: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.

Etapas para que se examine uma instruções usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial destas instruções.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final destas instruções.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, apresente uma mensagem de erro contendo "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e o percorredor; retorne.
    Se o segmento inicial deste percorredor não for o ponto final, mova o percorredor (usando diretrizes de compilação); recomece.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine uma rotina usando um percorredor:
    \ Define o cabeçalho de rotina.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Adicione a rotina para as rotinas usando o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor for "Etapas", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "Passos", mova o percorredor (usando diretrizes de compilação). \ Pula a palavra  "Passos" ou "Etapas" e obtém o next segmento inicial
  Se o segmento inicial deste percorredor for "necessários", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "necessárias", mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "para", apresente uma mensagem de erro contendo "Você precisa escrever 'para' antes de: " junto com o segmento inicial deste percorredor seguido de "' nesse tipo de rotina." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação). \ skip o "para" e obtenha o next segmento inicial
  Se o segmento inicial deste percorredor for "que", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "que", apresente uma mensagem de erro contendo "Você precisa colocar um 'que' antes da palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ skip o "que" e obtenha o next segmento inicial
  Se o segmento inicial deste percorredor for "se", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor não for "se", apresente uma mensagem de erro contendo "Você precisa colocar um 'se' antes da palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  \Mova o percorredor (usando diretrizes de compilação). \ skip o "se" e obtenha o next segmento inicial
  Examine a cabeçalho de rotina desta rotina usando o percorredor.
  Se o segmento inicial deste percorredor for o ponto&vírgula, examine a rotina usando o percorredor (sobrecarga de métodos); retorne. \ *** usado para nomes alternativos de rotinas
  Se o segmento inicial deste percorredor não for o sinal de dois pontos, apresente a mensagem de erro contendo "O nome dessa função está escrito errado.." e o local de aparição desta rotina; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine as instruções desta rotina usando o percorredor.

Etapas para que se examine uma rotina usando um percorredor (sobrecarga de métodos):
  \ *** para nomes alternativos de rotinas
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o início of algum tipo de rotina, apresente uma mensagem de erro contendo "Esse ponto e vírgula tá no lugar errado." e o original percorredor; retorne.
  Atribua o caractere inicial deste segmento inicial deste original percorredor ao caractere inicial destas instruções desta rotina.
  Atribua o caractere final deste segmento inicial deste original percorredor ao caractere final destas instruções desta rotina.
  Mova o original percorredor (usando diretrizes de compilação).

Etapas para que se examine uma cabeçalho de rotina usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste cabeçalho de rotina.
  Atribua -1 ao caractere final deste cabeçalho de rotina.
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, retorne. \ *** alternate palavraings
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste cabeçalho de rotina.
    Mova o percorredor (usando diretrizes de compilação).
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um source file:
  Se o source file for inexistente, retorne.
  Se o detector de erros deste compilador estiver ativado, retorne.
  Lance um percorredor sobre o trecho deste source file.
  Mova o percorredor (usando diretrizes de compilação).
  Comece. [a executar o código abaixo]
    Se o detector de erros deste compilador estiver ativado, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o início of algum tipo de type, examine um type usando o percorredor; recomece.
    Se o segmento inicial deste percorredor for o início of algum tipo de global, examine um global usando o percorredor; recomece.
    Se o segmento inicial deste percorredor for o início of algum tipo de rotina, examine uma rotina usando o percorredor; recomece.
    Apresente uma mensagem de erro contendo "Faltou definir melhor o que é o: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine uns sources files:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um source file desde o sources files.
  Se o source file for inexistente, retorne.
  Examine o source file.
  Recomece. [percorra novamente o código acima]

Etapas para que se examine um type usando um percorredor:
  Se o detector de erros deste compilador estiver ativado, retorne. 
  Se o segmento inicial deste percorredor for algum tipo de artigo indefinido português, ative um portuguese detector. 
  Se o segmento inicial deste percorredor for algum tipo de artigo indefinido inglês, ative um english detector. 
  Adicione o type para os types usando o caractere inicial deste segmento inicial deste percorredor. 
  Mova o percorredor (usando diretrizes de compilação). 
  Examine o nome deste type usando o percorredor. 
  Atribua o nome deste type ao plural nome deste type. 
  Atribua 0 a uma contagem.  
  Se o english detector não estiver ativo, pluralize o plural nome deste type (strings em português); adicione 1 à contagem.
  Se o english detector estiver ativo, pluralize o plural nome deste type (english rules); adicione 1 à contagem.
  \Se o portuguese detector estiver ativo, pluralize o plural nome deste type (strings em português); adicione 1 à contagem.
  Se a contagem for igual ou maior do que 2, 
    apresente uma mensagem de erro contendo "Erro, não foi possível detectar o idioma desta variável" e o local de aparição deste type; retorne.
  Se o segmento inicial deste percorredor for algum tipo de operador de atribuição de estruturas compostas, examine o type usando o percorredor (has ou have); retorne.
  Se o segmento inicial deste percorredor não for algum tipo de operador de atribuição simples, 
    apresente a mensagem de erro contendo "Eu esperava um 'é' ou um 'são', mas só achei um " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum tipo de numeric literal, examine o type usando o percorredor (unidade de medida); retorne.
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, 
    apresente a mensagem de erro contendo "Faltou um artigo indefinido, lembra?: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o base nome deste type usando o percorredor.
  Examine algum tipo de optional info pelo type usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, 
    apresente a mensagem de erro contendo "Você precisa usar um ponto para definir um tipo, lembra? Você usou: " 
    junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o type.

Etapas para que se examine um type usando um percorredor (has ou have):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "estrutura" ao base nome deste type. \\mudar aqui
  Examine o campos deste type usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Ao invés de usar o ponto para definir tipo, você usou: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o type.

Etapas para que se examine um type usando um percorredor (unidade de medida):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Converta o segmento inicial deste percorredor para a razão de escala deste type.
  Se a razão de escala deste type for 0, apresente uma mensagem de erro contendo "Zero é um tipo de escala inválido." e o local de aparição deste type; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o base nome deste type usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Os tipos precisam terminar com um ponto, não com: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o type.

Um scratch é um local.

Etapas para que se scrub um catálogo:
    Obtenha um bucket usando o catálogo.
    Se o bucket for inexistente, retorne.
      Se os referências deste bucket estiverem vazios, recomece.
    Scrub os referências deste bucket.
  Recomece. [percorra novamente o código acima]

Etapas para que se scrub umas referências:
  Permute as referências com uns segunda referências.
  Comece. [a executar o código abaixo]
    Atribua o first referência destes segunda referências para uma referência.
    Se a referência for inexistente, retorne.
    Remove a referência desde a segunda referências.
    Se o ponteiro deste referência for inexistente, destrua a referência; recomece.
    Posponha a referência para os referências.
  Recomece. [percorra novamente o código acima]

Etapas para que se ative o compiled detector em uma variável;
Etapas para que se ligue o compiled detector em uma variável:
  Se a variável for inexistente, retorne.
  Se o compiled detector desta variável [já] estiver ativo, retorne.
  Ligue o compiled detector desta variável.
  Se a categoria desta variável não for "global", retorne.
  Se o literal desta variável for inexistente, retorne.
  Encontre uma rotina usando "atribua" e o type deste literal desta variável e "para" e o type desta variável.
  Se a rotina for inexistente, encontre a rotina usando "converta" e o type deste literal desta variável e "para" e o type desta variável; ative um detector.
  Se a rotina for inexistente, apresente uma mensagem de erro contendo "O tipo dessa variável global e desse literal não são compatíveis." e o local de aparição desta variável; retorne.
  Compile o body of a rotina.
  Se o detector estiver ativo, atribua "converta o " junto com o nome deste literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao initializer string desta variável.
  Se o detector não estiver ativo, atribua "atribua o " junto com o nome deste literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao initializer string desta variável. \ Era " ao ". NÃO PODIA MUDAR O " ao " não sei o porquê

Etapas para que se skip para o next palavra em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste subtexto for irrelevante, pare.
  Adicione 1 para o caractere inicial deste subtexto.
  Recomece. [percorra novamente o código acima]
  Skip algum tipo de leading noise no subtexto.

Etapas para que se skip para o previous palavra em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere final deste subtexto for irrelevante, pare.
  Subtraia 1 desde o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]
  Skip algum tipo de trailing noise no subtexto.

Um source file é uma coisa com 
  Um endereço completo e 
  Um trecho.

Os sources files são uns sources files.

Uma etiqueta é um número.

Um termo é um estrutura com 
  Uma variável e 
  Uma phrase.

Etapas para que se transforme em código hexadecimal um fragment:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se o fragment for inexistente, retorne.
  Se a etiqueta deste fragment for o etiqueta de inserção de endereço [na stack], transforme em código hexadecimal o fragment (push endereço); retorne.
  Se a etiqueta deste fragment for a etiqueta de demanda interna, transforme em código hexadecimal o fragment (Demanda Interna); retorne.
  Se a etiqueta deste fragment for o etiqueta de carregamento de endereço, transforme em código hexadecimal o fragment (load endereço); retorne.
  Se a etiqueta deste fragment for a etiqueta de acréscimo, transforme em código hexadecimal o fragment (increment); retorne.
  Se a etiqueta deste fragment for o etiqueta de revogação, transforme em código hexadecimal o fragment (dereference); retorne.
  Se a etiqueta deste fragment for o etiqueta de desvio falso, transforme em código hexadecimal o fragment (jump false); retorne.
  Se a etiqueta deste fragment for a etiqueta de negação lógica, transforme em código hexadecimal o fragment (not); retorne.
  Se a etiqueta deste fragment for o etiqueta de retorno, transforme em código hexadecimal o fragment (exit); retorne.
  Se a etiqueta deste fragment for a etiqueta de repetição, transforme em código hexadecimal o fragment (repeat); retorne.
  Se a etiqueta deste fragment for o etiqueta de interrupção, transforme em código hexadecimal o fragment (break); retorne.
  Se a etiqueta deste fragment for o etiqueta preliminar, transforme em código hexadecimal o fragment (etapa preliminar); retorne.
  Se a etiqueta deste fragment for o epilog etiqueta, transforme em código hexadecimal o fragment (epilog); retorne.
  Se a etiqueta deste fragment for o etiqueta de inserção de valor [na stack], transforme em código hexadecimal o fragment (push value); retorne.
  Se a etiqueta deste fragment for a etiqueta de demanda externa, transforme em código hexadecimal o fragment (Demanda Externa); retorne.
  Se a etiqueta deste fragment for o etiqueta de carregamento de registrador EAX, transforme em código hexadecimal o fragment (load eax); retorne.
  Se a etiqueta deste fragment for o etiqueta de obtenção do registrador EAX, transforme em código hexadecimal o fragment (registrador EAX); retorne.
  Se a etiqueta deste fragment for a etiqueta de demanda indireta, transforme em código hexadecimal o fragment (Demanda Indireta); retorne.
  Se a etiqueta deste fragment for a etiqueta de endereço de rotina, transforme em código hexadecimal o fragment (rotina endereço); retorne.

Etapas para que se transforme em código hexadecimal um fragment (break):
  Atribua a etiqueta de repetição para uma etiqueta.
  Encontre um segundo fragment usando o fragment e a etiqueta.
  Se o segundo fragment for inexistente, atribua a etiqueta de finalização ao etiqueta. \ para break sem um loop ou depois de um loop
  Encontre um terceiro fragment usando o last fragment destes fragments desta rotina utilizada atualmente e a etiqueta (backwards).
  Se o terceiro fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (break)"; retorne.
  Se o next deste terceiro fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transforme em código hexadecimal um fragment (break)"; retorne.
  Acrescente $E9 e o endereço deste next deste terceiro fragment para o fragment. \ JMP o endereço da destination

Etapas para que se transforme em código hexadecimal um fragment (Demanda Externa):
  Acrescente $FF15 e o endereço desta entry deste fragment para o código deste fragment. \ Processe [o endereço desta entry deste fragment ]
  \ The acima of rotina generates the machine code for a Processe to the Windows operating system. 
  \The op code is specified, in hexadecimal ($FF15) and the rest of the instruction is the address of the entry address of the target rotina, which is appended to the op code.

Etapas para que se transforme em código hexadecimal um fragment (Demanda Indireta):
  Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ coloca endereço para edx
  Acrescente $FF12 para o código deste fragment. \ Processe [edx]

Etapas para que se transforme em código hexadecimal um fragment (Demanda Interna):
  Obtenha um endereço usando o rotina deste fragment.
  Acrescente $E8 e o endereço para o fragment. \ Processe o address da rotina do fragment 

Etapas para que se transforme em código hexadecimal um fragment (dereference):
  Acrescente $8B95 e o offset desta variável deste fragment para o código deste fragment. \ mov edx,[ebp+ o offset desta variável deste fragment]
  Acrescente $8B12 para o código deste fragment. \ mov edx,[edx]
  Acrescente $8995 e o offset desta variável deste fragment para o código deste fragment. \ mov [ebp+ o offset desta variável deste fragment]

Etapas para que se transforme em código hexadecimal um fragment (epilog):
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, acrescente $5F5E5B para o código deste fragment. \ pop edi; pop esi; pop ebx;
  Acrescente $8BE5 para o código deste fragment. \ mov esp,ebp -> não seria 89EC?
  Acrescente $5D para o código deste fragment. \ pop ebp
  Acrescente $C2 e o parâmetro size desta rotina utilizada atualmente para o código deste fragment. \ ret + o tamanho do parâmetro da rotina utilizada atualmente

Etapas para que se transforme em código hexadecimal um fragment (exit):
  Encontre um segundo fragment usando o fragment e a etiqueta de finalização.
  Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (exit)"; retorne.
  Acrescente $E9 e o endereço deste segundo fragment para o fragment. \ jmp + o address da destination

Etapas para que se transforme em código hexadecimal um fragment (increment):
  Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (increment)"; retorne.
  Se a categoria desta variável deste fragment não for "scratch", apresente a mensagem de erro contendo "Erro interno 2 - transforme em código hexadecimal um fragment (increment)"; retorne.
  Acrescente $8185 e o offset desta variável deste fragment e o número deste fragment para o código deste fragment. \ add [ebp+ o offset desta variável deste fragment], o número deste fragment

Etapas para que se transforme em código hexadecimal um fragment (jump false):
  Encontre um segundo fragment usando o fragment e o etiqueta delimitadora de bloco condicional.
  Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (jump false)"; retorne.
  Acrescente $83F800 para o código deste fragment. \ cmp eax,0
  Acrescente $0F84 e o endereço deste segundo fragment para o fragment. \ je + o address da destination

Etapas para que se transforme em código hexadecimal um fragment (load endereço):
  Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
  Acrescente $8995 e o offset desta segunda variável deste fragment para o código deste fragment. \ mov [ebp+ o offset desta variável deste fragment],edx

\Etapas para que se transforme em código hexadecimal um fragment (load eax):
\Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
\Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro - transforme em código hexadecimal um fragment (load eax)"; retorne.
\Se o type desta variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transforme em código hexadecimal um fragment (load eax)"; retorne.
 \Se a quantidade de caracteres deste type desta variável deste fragment não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transforme em código hexadecimal um fragment (load eax)"; retorne.
\Acrescente $8B02 para o código deste fragment. \ mov eax,[edx]

Etapas para que se transforme em código hexadecimal um fragment (load eax):
  Acrescente $B8 e o detector deste fragment para o código deste fragment. \ mov eax,detector
\Acrescente endereço loading código para o código deste fragment usando a variável do fragment. \ atribua endereço para edx
\Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro - transforme em código hexadecimal um fragment (load eax)"; retorne.
\Se o type desta variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transforme em código hexadecimal um fragment (load eax)"; retorne.
\Se a quantidade de caracteres deste type desta variável deste fragment não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transforme em código hexadecimal um fragment (load eax)"; retorne.
\Acrescente $8B02 para o código deste fragment. \ mov eax,[edx]

Etapas para que se transforme em código hexadecimal um fragment (not):
  Acrescente $83F001 para o código deste fragment. \ xor eax,1

Etapas para que se transforme em código hexadecimal um fragment (etapa preliminar):
  Acrescente $55 para o código deste fragment. \ push ebp -> saves the contents of the EBP register on the stack.
  Acrescente $8BEC para o código deste fragment. \ mov ebp,esp -> puts the contents of the ESP register into the EBP register
  Atribua o local size desta rotina utilizada atualmente dividido por 4 para um número.
  Se o número não for 0, acrescente $B9 \ mov ecx,number;  -> sets up the loop that will clear enough space on the stack for the routine's local variables
    e O número e $6A004975FB \loop: push 0; dec ecx; jnz loop -> a loop that pushes enough zeros onto the stack to initialize the local variables.
  para o código deste fragment. 
  Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, acrescente $535657 para o código deste fragment. \ push ebx, esi, edi ->  save the EBX, ESI, and EDI registers on the stack.

Etapas para que se transforme em código hexadecimal um fragment (push endereço):
  Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
  Acrescente $52 para o código deste fragment. \ push edx -> push the 4-byte value in edx onto the stack

Etapas para que se transforme em código hexadecimal um fragment (push value):
  Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
  Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (push value)"; retorne.
  Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transforme em código hexadecimal um fragment (push value)"; retorne.
  Atribua a quantidade de caracteres deste type desta variável deste fragment para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, acrescente $FF32 para o código deste fragment; retorne. \ push [edx]
  Se a quantidade de caracteres for 2, acrescente $66FF32 para o código deste fragment; retorne. \ push word ptr [edx]
  Se a quantidade de caracteres for 1, acrescente $0FB61252 para o código deste fragment; retorne. \ movzxb edx,[edx]; push edx
  Apresente a mensagem de erro contendo "Erro interno 3 - transforme em código hexadecimal um fragment (push value)".

Etapas para que se transforme em código hexadecimal um fragment (repeat):
  Encontre um segundo fragment usando o fragment e o etiqueta de laço (backwards).
  Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (repeat)"; retorne.
  Acrescente $E9 e o endereço deste segundo fragment para o fragment. \ jmp o address da destination 

Etapas para que se transforme em código hexadecimal um fragment (rotina endereço):
  Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
  Se a rotina deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (rotina endereço)"; retorne.
  Obtenha um endereço usando a rotina deste fragment.
  Acrescente $C702 e o endereço para o código deste fragment. \ mov [edx],the endereço

Etapas para que se transforme em código hexadecimal um fragment (registrador EAX):
  Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
  Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (registrador EAX)"; retorne.
  Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transforme em código hexadecimal um fragment (registrador EAX)"; retorne.
  Atribua a quantidade de caracteres deste type desta variável deste fragment para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4, acrescente $8902 para o código deste fragment; retorne. \ mov [edx],eax
  Se a quantidade de caracteres for 2, acrescente $668902 para o código deste fragment; retorne. \ mov [edx],ax
  Se a quantidade de caracteres for 1, acrescente $8802 para o código deste fragment; retorne. \ mov [edx],al
  Apresente a mensagem de erro contendo "Erro interno 3 - transforme em código hexadecimal um fragment (registrador EAX)".

Etapas para que se transforme em código hexadecimal uns fragments:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha um fragment desde o fragments.
  Se o fragment for inexistente, retorne.
  Transforme em código hexadecimal o fragment.
  Recomece. [percorra novamente o código acima]

Etapas para que se transforme em código hexadecimal uma rotina:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Se a rotina for inexistente, retorne.
  Se o employs representação interna da rotina desta rotina não estiver em branco, retorne.
  Se o compiled detector desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Transforme em código hexadecimal os fragments desta rotina.

Etapas para que se transforme em código hexadecimal umas rotinas:
  Se o detector de erros deste compilador estiver ativado, retorne.
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, pare.
  Transforme em código hexadecimal a rotina.
  Recomece. [percorra novamente o código acima]

O catálogo de tipos é um catálogo.


Um type é uma coisa com
  Um local de aparição (reference),
  Um nome, um plural nome,
  Um cabeçalho semi-expandido,
  Uma quantidade de caracteres,
  Um base nome, um base type (reference),
  Um conteúdo nome, um conteúdo type (reference) [endereço de memórias only],
  Uma razão de escala,
  Some campos [records only],
  Um cooking detector,
  Um optional info resolved detector.

Um type nome é um nome.

Os types são uns types.

O catálogo de rotinas úteis é um catálogo.

Uma variável é uma coisa com
  Um local de aparição (reference),
  Um categoria [literal, global, local, parâmetro, scratch],
  Um compiled detector,
  Um nome, 
  Um nickname, 
  Um type nome,
  Um type (reference), \ actual type sobre literal, global, local; dereferenced type sobre parâmetros e scratches
  Um endereço [globals e literals only] ou 
  Um offset sob o endereço [locals, parâmetros, e campos only],
  Um contagem [campos only],
  Um reference detector [campos only],
  Um redefinition conteúdo nome [campos only],
  Um by-value detector [parâmetros only],
  Um global body [globals only],
  Um initializer string [globals only],
  Um literal (reference) [globals only - constant com which to initalize the global],
  Um texto hexadecimal denominado data [literals only].

Etapas para que se skip algum tipo de trailing noise em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere final deste subtexto não for irrelevante, retorne.
  Subtraia 1 desde o caractere final deste subtexto.
  Recomece. [percorra novamente o código acima]

\ Rotina nova criada pelo Dahn para - reverse functions
\ To put o xxx uv a/the yyy para zzz
\ internally we turn this para "to put a/the yyy's xxx para zzz"
Etapas para que se compile o header of uma rotina usando um percorredor (função do possessivo reverso):
  Se o detector de erros deste compilador estiver ativado, retorne.
  Ligue o detector de função desta rotina.
  Adicione uma unidade semântica para os unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação). \ skip "atribua" ou "poner"
  Mova o percorredor (usando diretrizes de compilação). \ skip "the" ou Portuguese artigo definido
  Examine um nome usando o percorredor. \ campo nome
  Mova o percorredor (usando diretrizes de compilação). \ skip "uv" ou "de"
  Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, ative um detector.
  Se o detector estiver ativo, compile os unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o detector não estiver ativo, compile os unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo definido).
  Adicione uma segunda unidade semântica para os unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for algum tipo de reverse-possessive function into, apresente uma mensagem de erro contendo "Esperava a palavra 'em', mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Adicione um terceiro unidade semântica para os unidades semânticas desta rotina usando "para".
  Converta os unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Já sei como: " junto com a representação interna da rotina seguido de "." e o local de aparição desta rotina; retorne.
  Catalogue a rotina usando os unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Esperava um artigo indefinido, mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; retorne.
  Compile os unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Existem outras coisas no final desta função." e o percorredor; retorne.
  Converta os unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando os unidades semânticas desta rotina e o catálogo geral de rotinas. \ por employs

\ Rotina nova criada pelo Dahn para - reverse functions
\ para atribua o xxx uv a/the yyy para zzz
Etapas para que se determine se um percorredor é o início of algum tipo de reverse-possessive function:
  Se o detector de erros deste compilador estiver ativo, diga não.
  Se o segmento inicial deste percorredor não for algum tipo de atribua, diga não.
  Isole o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum tipo de artigo definido, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor não for sobre algum tipo de reverse-possessive, diga não.
[Se as condições acima não puderem ser satisfeitas, então:] Diga sim.

\finalmente  acabou
