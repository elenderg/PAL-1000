\ o compilador copyright © 2006-2021 a ordem osmosiana

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...


\Plain English stores strings in two parts so it is easy to swap the first and last bytes of a string, and to show that it worked, with a little command like this:
\ Swap the string's first's target with the string's last's target.
\All parameters are passed by reference in Plain English, so the modified string is returned in the passed variable, which is the natural and obvious way to do it. 
\For example, if you pass the salt shaker to someone at the dinner table, and they use some, you get the shaker back with less salt than when you passed it.

Uma mensagem de erro é uma string.
Uma contagem de nomes é uma contagem.

O temporizador de escrita é um temporizador. \ Um temporizador é um conjunto com uma contagem, uns start ticks e uns total ticks. \ An tick é um número.
O temporizador de transmutação é um temporizador.
O temporizador de análise/verificação é um temporizador.
O temporizador de resolução de variáveis globais é um temporizador.
O temporizador de resolução de tipos é um temporizador.
O temporizador de operacionalização é um temporizador.
O temporizador de deslocamentos é um temporizador.
O temporizador de vinculação é um temporizador.
O temporizador de ferramentas de catalogação é um temporizador.
O temporizador de compilação do conteúdo das rotinas é um temporizador.
O temporizador de compilação de cabeçalhos de rotina é um temporizador.
O temporizador de etapas de cálculo é um temporizador.
O temporizador de endereçamento é um temporizador.
O temporizador de adição de rotinas pré-definidas de mémoria é um temporizador.
O temporizador de adição de rotinas pré-definidas de inicialização é um temporizador.

A break etiqueta é uma etiqueta igual a 1.
A etiqueta de demanda externa é uma etiqueta igual a 2.
A etiqueta de demanda indireta é uma etiqueta igual a 3.
A etiqueta de demanda interna é uma etiqueta igual a 4.
A dereference etiqueta é uma etiqueta igual a 5.
O end if etiqueta é uma etiqueta igual a 6.
O epilog etiqueta é uma etiqueta igual a 7.
O exit etiqueta é uma etiqueta igual a 8.
A etiqueta de finalização é uma etiqueta igual a 9.
A etiqueta de acréscimo é uma etiqueta igual a 10.
O Intel etiqueta é uma etiqueta igual a 11.
O jump false etiqueta é uma etiqueta igual a 12.
O load endereço etiqueta é uma etiqueta igual a 13.
O load eax etiqueta é uma etiqueta igual a 14.
O loop etiqueta é uma etiqueta igual a 15.
A etiqueta de negação é uma etiqueta igual a 16.
O prolog etiqueta é uma etiqueta igual a 17.
O push endereço etiqueta é uma etiqueta igual a 18.
O push value etiqueta é uma etiqueta igual a 19.
O save eax etiqueta é uma etiqueta igual a 20.
A etiqueta de repetição é uma etiqueta igual a 21.
A etiqueta de endereço de rotina é uma etiqueta igual a 22.


O compilador é um conjunto com
Um endereço da pasta,
Um temporizador,
Um detector de erros, 
Um mensagem de erro,
Um endereço completo do arquivo de erro,
Um número da linha de erro,
Uma contagem de nomes,
Um trecho exe,
Um listagem trecho.

Etapas necessárias para que se apresente uma mensagem de erro contendo uma string:
Se o detector de erros deste compilador estiver ativado, cancele.
Ligue o detector de erros deste compilador.
Atribua a string à mensagem de erro deste compilador.

Etapas necessárias para que se apresente uma mensagem de erro contendo uma string e um endereço de memória do pedaço:
Se o detector de erros deste compilador estiver ativado, cancele.
Ligue o detector de erros deste compilador.
Atribua a string à mensagem de erro deste compilador.
Encontre o endereço completo do arquivo de erro deste compilador e o número da linha de erro deste compilador usando o endereço de memória do pedaço .
Se o endereço completo do arquivo de erro deste compilador estiver em branco, cancele.
Extraia um nome do arquivo desde o endereço completo do arquivo de erro deste compilador.
Anteponha "Erro no " junto com o nome do arquivo seguido de ". " para a mensagem de erro deste compilador.

Etapas necessárias para que se apresente uma mensagem de erro contendo uma string e um percorredor:
Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo a string e o first deste segmento inicial deste percorredor; exit.
Apresente a mensagem de erro contendo a string e o last deste segmento final deste percorredor.

Etapas necessárias para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Adicione a rotina de finalização pelo type.
Adicione a rotina de alocação para o type.
Adicione a rotina de desalocação para o type.
Adicione a rotina de destruição pelo type.
Repita.

Etapas necessárias para que se adicione o rotina de alocação para um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o conteúdo type deste type for inexistente, cancele.
Adicione uma rotina para as rotinas usando nil.
Posponha "Aloque memória para um " junto com o nome deste type para o header string desta rotina. \ traduzir aqui
Posponha "Assign o " junto com o nome deste type seguido de " usando " para o body string desta rotina. \Nomeie
Posponha a quantidade de caracteres deste conteúdo type deste type seguido de "." para o body string desta rotina.
Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
Lance as instruções desta rotina sobre o body string desta rotina.
Compile o header of a rotina.

Etapas necessárias para que se adicione e compile a rotina de inicialização pré-execução e finalização pós-execução:
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione uma rotina para as rotinas usando nil.
Posponha "~initialize before run e run e finalize after run" para o header string desta rotina.
Posponha "initialize before run. " para o body string desta rotina.
Posponha os global initializers para o body string desta rotina.
Posponha "nosso programa seja executado. " para o body string desta rotina. \ traduzir
Posponha os global finalizers para o body string desta rotina.
Posponha "finalize after run. " para o body string desta rotina.
Posponha "call ""kernel32.dll"" ""ExitProcess"" com 0. " para o body string desta rotina.
Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
Lance as instruções desta rotina sobre o body string desta rotina.
Compile o header of a rotina.
Compile o body of a rotina.

Etapas necessárias para que se adicione os built-in types:
Adicione um built-in type usando "byte" e "bytes" e 1.
Adicione um segundo built-in type usando "record" e "records" e 0.
Adicione um terceiro built-in type usando "pedaço" e "pedaços" e 1.
Adicione um quarto built-in type usando "conjunto" e "conjuntos" e 0.
Adicione um quinto built-in type usando "octeto" e "octetos" e 1.

Etapas necessárias para que se adicione um built-in type usando um nome e um plural nome e uma quantidade de caracteres:
Adicione o built-in type para os types usando o nome e o plural nome e o nome.
Atribua a quantidade de caracteres ao quantidade de caracteres deste built-in type.
Atribua o built-in type ao base type deste built-in type.
Catalogue o built-in type.

Etapas necessárias para que se adicione o rotina de desalocação para um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o conteúdo type deste type for inexistente, cancele.
Adicione uma rotina para as rotinas usando nil.
Posponha "Desaloque um " junto com o nome deste type para o header string desta rotina.
Posponha "Se o " junto com o nome deste type seguido de " for inexistente, cancele. " para o body string desta rotina.
Se o conteúdo type deste type deveria ser finalizado, posponha "~finalize o " junto com o nome deste type seguido de "'s conteúdo. " para o body string desta rotina. \ precisa ter uma rotina de destruição gerada automaticamente para ele "
Posponha "Unassign o " junto com o nome deste type seguido de "." para o body string desta rotina.
Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
Lance as instruções desta rotina sobre o body string desta rotina.
Compile o header of a rotina.

Etapas necessárias para que se adicione o rotina de destruição por um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não deveria ser ignorado, cancele.
Se o type puder ser reduzido para "coisas", adicione o rotina de destruição pelo type (coisas); exit.
Se o type puder ser reduzido para "endereço de memória", adicione o rotina de destruição pelo type (endereço de memória); exit.

Etapas necessárias para que se adicione o rotina de destruição por um type (endereço de memória):
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua "Destrua [" junto com o nome deste type seguido de "]" para um cabeçalho expandido.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, cancele.
Adicione uma rotina para as rotinas usando nil.
Posponha "Destrua um " junto com o nome deste type para o header string desta rotina.
Posponha "Se o " junto com o nome deste type seguido de " for inexistente, cancele. " para o body string desta rotina.
Se o conteúdo type deste type puder ser reduzido para "endereço de memória", posponha "Destrua o " junto com o nome deste type seguido de "'s conteúdo. " para o body string desta rotina.
Se o conteúdo type deste type puder ser reduzido para "coisas", posponha "Destrua o " junto com o nome deste type seguido de "'s conteúdo. " para o body string desta rotina.
Percorra.
Obtenha um campo desde os campos deste conteúdo type deste type.
Se o campo for inexistente, pare.
Se o reference detector deste campo estiver ativo, repita.
Se o type deste campo não deveria ser ignorado, repita.
Posponha "Destrua o " junto com o nome deste type seguido de "'s " junto com o nome deste campo seguido de ". " para o body string desta rotina.
Repita.
Posponha "Desaloque o " junto com o nome deste type seguido de ". " para o body string desta rotina. \ traduzir aqui
Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
Lance as instruções desta rotina sobre o body string desta rotina.
Compile o header of a rotina.

Etapas necessárias para que se adicione o rotina de destruição por um type (coisas):
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
\Atribua "Erro interno na hora de executar a tarefa de destruição de tipos" à reply.
Se o first destes campos deste type for inexistente, apresente uma mensagem de erro contendo "Erro interno no campo do tipo. Veja rotina 'adicione um forget rotina por um type (coisas)'"; [Say o reply;] exit. \Adicionado Say o reply
Se o type deste first destes campos deste type for inexistente, apresente a mensagem de erro contendo "Erro interno no tipo do campo. Consulte a rotina 'adicione o forget rotina por um type (coisas)'"; exit.
Atribua "Destrua [" junto com o nome deste type seguido de "]" para um cabeçalho expandido.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, cancele.
Adicione uma rotina para as rotinas usando nil.
Posponha "Destrua um " junto com o nome deste type para o header string desta rotina.
Posponha "Se o " junto com o nome deste type seguido de "'s first for inexistente, cancele. " para o body string desta rotina.
Atribua o nome deste type deste first destes campos deste type para um nome.
Posponha "Atribua o " junto com o nome deste type seguido de "'s first para um " junto com o nome seguido de ". " para o body string desta rotina.
Posponha "Remove o " junto com o nome seguido de " desde o " junto com o nome deste type seguido de ". " para o body string desta rotina.
Posponha "Destrua o " junto com o nome seguido de ". " para o body string desta rotina.
Posponha "Repeat. " para o body string desta rotina.
Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
Lance as instruções desta rotina sobre o body string desta rotina.
Compile o header of a rotina.

Etapas necessárias para que se adicione um entry para uns imports usando um import nome e um entry nome:
Encontre um import usando o import nome.
Se o import for inexistente, adicione o import para o imports usando o import nome.
Encontre a entry usando a entry nome e as entries deste import.
Se a entry não for inexistente, cancele.
Crie a entry.
Posponha a entry para as entries deste import.
Atribua a entry nome ao nome desta entry.

Etapas necessárias para que se adicione um campo para uns campos usando um nome e um nickname e um type nome e um reference detector:
Adicione o campo para o campos usando "campo" e nil.
Atribua o nome ao nome deste campo.
Atribua o nickname ao nickname deste campo.
Atribua o type nome ao type nome deste campo.
Atribua o reference detector ao reference detector deste campo.

Etapas necessárias para que se adicione a rotina de finalização por um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não deveria ser finalizado, cancele.
Se o nome deste type for "string", adicione a rotina de finalização pelo type (texto); exit.
Se o nome deste type for "texto", adicione a rotina de finalização pelo type (texto); exit.
Se o type puder ser reduzido para "string", cancele. \ prevents generation of finalizer por derived string types
Se o type puder ser reduzido para "texto", cancele.
Adicione a rotina de finalização pelo type (conjunto).

Etapas necessárias para que se adicione a rotina de finalização por um type (conjunto):
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione uma rotina para as rotinas usando nil.
Posponha "~finalize um " junto com o nome deste type para o header string desta rotina.
Posponha "Intel $50. " para o body string desta rotina. \ push eax -> push the 4 bytes at address EAX onto the stack
\The push instruction places its operand onto the top of the hardware supported stack in memory. 
\Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location at address [ESP]. 
\ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde high addresses to lower addresses.
Percorra.
Obtenha um campo desde os campos deste type.
Se o campo for inexistente, pare.
Se o type deste campo não deveria ser finalizado, repita.
Posponha "~finalize o " junto com o nome deste type seguido de "'s " junto com o nome deste campo seguido de ". " para o body string desta rotina.
Repita.
Posponha "Intel $58." para o body string desta rotina. \ pop eax -> pop the top element of the stack into memory at the four bytes starting at location EAX.
\ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location). 
\It first moves the 4 bytes located at memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
Lance as instruções desta rotina sobre o body string desta rotina.
Compile o header of a rotina.

Etapas necessárias para que se adicione a rotina de finalização por um type (texto):
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione uma rotina para as rotinas usando nil.
Posponha "~finalize um " junto com o nome deste type para o header string desta rotina.
Posponha "Intel $50. " para o body string desta rotina. \ push eax -> push the 4 bytes at endereço eax on the stack
\ Specifically, push first decrements ESP by 4, then places its operand into the contents of the 32-bit location at endereço [ESP]. 
\ESP (the stack pointer) is decremented by push since the x86 stack grows para baixo - i.e. the stack grows desde high addresses to lower addresses.
Posponha "unassign a string's first . " para o body string desta rotina. \\ traduzir string aqui
\Posponha "unassign o texto's first. " para o body string desta rotina. \\ traduzir string aqui
Posponha "Intel $58." para o body string desta rotina. \ pop eax -> pop the top element of the stack into memory at the four bytes starting at location EAX.
\ The pop instruction removes the 4-byte data element desde the top of the hardware-supported stack into the specified operand (i.e. register or memory location). 
\ It first moves the 4 bytes located at memory location [SP] into the specified register or memory location, and then increments memory location [SP] by 4.
Lance a cabeçalho de rotina desta rotina sobre o header string desta rotina.
Lance as instruções desta rotina sobre o body string desta rotina.
Compile o header of a rotina.

Etapas necessárias para que se adicione um fragment usando uma etiqueta:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando a etiqueta.
Posponha o fragment para os fragments desta rotina utilizada atualmente.

Etapas necessárias para que se adicione um fragment usando uma etiqueta e um entry:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando a etiqueta.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua a entry à entry deste fragment.

Etapas necessárias para que se adicione um fragment usando uma etiqueta e um detector:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando a etiqueta.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o detector ao detector deste fragment.

Etapas necessárias para que se adicione um fragment usando uma etiqueta e uma rotina:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando a etiqueta.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua a rotina à rotina deste fragment.
Compile o body of a rotina.

Etapas necessárias para que se adicione um fragment usando uma etiqueta e uma variável:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando a etiqueta.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua a variável à variável deste fragment.
Ligue o compiled detector na variável.

Etapas necessárias para que se adicione um fragment usando uma etiqueta e uma variável e uma segunda variável:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando a etiqueta.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua a variável à variável deste fragment.
Atribua a segunda variável ao segunda variável deste fragment.
Ligue o compiled detector na variável.
Ligue o compiled detector no segunda variável.

Etapas necessárias para que se adicione um fragment usando uma etiqueta e uma variável e um número:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando a etiqueta.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua a variável à variável deste fragment.
Atribua o número ao número deste fragment.
Ligue o compiled detector na variável.

Etapas necessárias para que se adicione um import para uns imports usando um import nome:
Crie o import.
Posponha o import para o imports.
Atribua o import nome ao nome deste import.

Etapas necessárias para que se adicione um intermediate usando um type nome e um local de aparição:
Se a rotina utilizada atualmente for inexistente, esvazie o intermediate; exit.
Adicione o intermediate para os locals desta rotina utilizada atualmente usando "local" e o local de aparição.
Gere o nome deste intermediate usando "~I".
Atribua o type nome ao type nome deste intermediate.
Resolva o intermediate.

Etapas necessárias para que se adicione um literal para uns variáveis usando um local de aparição:
Adicione o literal como uma variável para o variáveis usando "literal" e o local de aparição.
Gere o nome deste literal usando "~L".

Etapas necessárias para que se adicione um monikette para uns monikettes usando um expression:
Crie o monikette.
Posponha o monikette para os monikettes.
Atribua a phrase desta expression à string deste monikette.
Atribua a variável desta expression à variável deste monikette.
Se a variável desta expression não for inexistente, atribua o type desta expression ao type deste monikette.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette para uns monikettes usando uma string: \ creio que isso aqui ajude nas funções
Crie o monikette.
Posponha o monikette para os monikettes.
\PAL
\\ conjunctions
Se a string for "e", atribua "e" à string deste monikette; exit. \ and
Se a string for "ou", atribua "ou" à string deste monikette; exit. \ or
\ usando
Se a string for "desde", atribua "usando" à string deste monikette; exit.
Se a string for "a partir de", atribua "usando" à string deste monikette; exit.
Se a string for "partindo de", atribua "usando" à string deste monikette; exit.
\Se a string for "de", atribua "usando" à string deste monikette; exit.
Se a string for "dada", atribua "usando" à string deste monikette; exit.
Se a string for "dado", atribua "usando" à string deste monikette; exit.
Se a string for "dadas", atribua "usando" à string deste monikette; exit.
Se a string for "dados", atribua "usando" à string deste monikette; exit.
Se a string for "com", atribua "usando" à string deste monikette; exit.
Se a string for "usando", atribua "usando" à string deste monikette; exit.
Se a string for "contendo", atribua "usando" à string deste monikette; exit.
\\ para
\Se a string for "em", atribua "para" à string deste monikette; exit. \  ver isso aqui com calma
Se a string for "a", atribua "para" à string deste monikette; exit.
Se a string for "para", atribua "para" à string deste monikette; exit.
\\ é
Se a string for "é", atribua "é" à string deste monikette; exit.
Se a string for "está", atribua "é" à string deste monikette; exit.
Se a string for "for", atribua "é" à string deste monikette; exit.
Se a string for "foi", atribua "é" à string deste monikette; exit.
Se a string for "foram", atribua "é" à string deste monikette; exit.
Se a string for "forem", atribua "é" à string deste monikette; exit.
Se a string for "estiver", atribua "é" à string deste monikette; exit.
Se a string for "estiverem", atribua "é" à string deste monikette; exit.
\Se a string for "seja", atribua "é" à string deste monikette; exit.
\Se a string for "tem", atribua "é" à string deste monikette; exit.
\Se a string for "tiver", atribua "é" à string deste monikette; exit.
Se a string for "are", atribua "é" à string deste monikette; exit.
Se a string for "são", atribua "é" à string deste monikette; exit.
Se a string for "estão", atribua "é" à string deste monikette; exit.
Se a string for "is", atribua "é" à string deste monikette; exit.
Se a string for "forem", atribua "é" à string deste monikette; exit.
Se a string for "estiverem", atribua "é" à string deste monikette; exit.
Se a string for "puder", atribua "pode" à string deste monikette; exit.
Se a string for "puderem", atribua "pode" à string deste monikette; exit.
Se a string for "existir", atribua "existe" à string deste monikette; exit.
\Se a string for "decide", atribua "decidir" à string deste monikette; exit.
\Se a string for "decidiu", atribua "decidir" à string deste monikette; exit.
\Se a string for "decidindo", atribua "decidir" à string deste monikette; exit. \melhor não por gerúndio ou verbos compostos
\Se a string for "decidiu-se", atribua "decidir" à string deste monikette; exit.
Se a string for "existir", atribua "existe" à string deste monikette; exit.
\\ allocates e destroys
\Se a string for "alojar", atribua "allocate" à string deste monikette; exit.
\Se a string for "aloje", atribua "allocate" à string deste monikette; exit.
\Se a string for "alocar", atribua "allocate" à string deste monikette; exit.
\Se a string for "aloque", atribua "allocate" à string deste monikette; exit.
\Se a string for "reservar", atribua "allocate" à string deste monikette; exit.
\Se a string for "reserve", atribua "allocate" à string deste monikette; exit.
\Se a string for "memória", atribua "memória" à string deste monikette; exit.
\Se a string for "for", atribua "por" à string deste monikette; exit. \\servia pra converter o "for" para "por"
Se a string for "pelo", atribua "por o" à string deste monikette; exit.
Se a string for "pela", atribua "por o" à string deste monikette; exit.
\Se a string for "desalocar", atribua "deallocate" à string deste monikette; exit.
\Se a string for "desaloque", atribua "deallocate" à string deste monikette; exit.
\\Se a string for "desalojar", atribua "deallocate" à string deste monikette; exit.
\Se a string for "desaloje", atribua "deallocate" à string deste monikette; exit.
\Se a string for "esvaziar", atribua "deallocate" à string deste monikette; exit.
\Se a string for "esvazie", atribua "deallocate" à string deste monikette; exit.
\Se a string for "destruir", atribua "destroy" à string deste monikette; exit.
\CAL
\\ usando
Se a string for "from", atribua "usando" à string deste monikette; exit.
Se a string for "given", atribua "usando" à string deste monikette; exit.
Se a string for "com", atribua "usando" à string deste monikette; exit.
Se a string for "using", atribua "usando" à string deste monikette; exit.
\ para
Se a string for "in", atribua "para" à string deste monikette; exit.
Se a string for "into", atribua "para" à string deste monikette; exit.
Se a string for "to", atribua "para" à string deste monikette; exit.
\ é
Se a string for "are", atribua "é" à string deste monikette; exit.
Se a string for "is", atribua "é" à string deste monikette; exit.
\ aren't/isn't
Se a string for "isn't", atribua "não é" à string deste monikette; exit.
Se a string for "aren't", atribua "não é" à string deste monikette; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se a string for "backward", atribua "backward" à string deste monikette; exit.
Se a string for "backwards", atribua "backward" à string deste monikette; exit.
Se a string for "counterclockwise", atribua "backward" à string deste monikette; exit.
Se a string for "counter-clockwise", atribua "backward" à string deste monikette; exit.
Se a string for "anticlockwise", atribua "backward" à string deste monikette; exit.
Se a string for "anti-clockwise", atribua "backward" à string deste monikette; exit.
\ sobre
Se a string for "at", atribua "sobre" à string deste monikette; exit.
Se a string for "on", atribua "sobre" à string deste monikette; exit.
Se a string for "sobre", atribua "sobre" à string deste monikette; exit.
\ other
Atribua a string à string deste monikette.

Etapas necessárias para que se adicione um monikette para uns monikettes usando um type:
Crie o monikette.
Posponha o monikette para os monikettes.
Atribua o type ao type deste monikette.

Etapas necessárias para que se adicione push fragments usando uns monikettes:
Se a rotina utilizada atualmente for inexistente, cancele.
Percorra.
Obtenha um monikette desde os monikettes (backwards).
Se o monikette for inexistente, cancele.
Se a variável deste monikette for inexistente, repita.
Se o subtexto atual deste monikette não estiver em branco, repita.
Se o type atual deste monikette for inexistente, repita.
Adicione um fragment usando o push endereço etiqueta e a variável deste monikette.
Repita.

Etapas necessárias para que se adicione o atribua ou converta fragments usando uma variável e uma segunda variável e um local de aparição:
Adicione um fragment usando o push endereço etiqueta e a segunda variável.
Adicione um segundo fragment usando o push endereço etiqueta e a variável.
Encontre uma rotina usando "atribua" e o type desta variável e "para" e o type desta segunda variável.
Se a rotina for inexistente, encontre a rotina usando "converta" e o type desta variável e "para" e o type desta segunda variável.
Se a rotina não for inexistente, adicione um terceiro fragment usando a etiqueta de demanda interna e a rotina; exit.
\ erro message
Adicione um monikette para uns monikettes usando "atribua/converta".
Adicione uma segunda monikette para os monikettes usando o type desta variável.
Adicione um terceiro monikette para os monikettes usando "para/a".
Adicione um quarto monikette para os monikettes usando o type desta segunda variável.
Converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Apresente uma mensagem de erro contendo "Eu não sei como: " junto com o cabeçalho expandido seguido de "." e o local de aparição.

Etapas necessárias para que se adicione uma rotina para uns rotinas usando um local de aparição:
Crie a rotina.
Posponha a rotina para as rotinas.
Atribua o local de aparição ao local de aparição desta rotina.

Etapas necessárias para que se adicione um scratch usando um type nome e um local de aparição:
Se a rotina utilizada atualmente for inexistente, esvazie o scratch; exit.
Adicione o scratch para os locals desta rotina utilizada atualmente usando "scratch" e o local de aparição.
Gere o nome deste scratch usando "~S".
Atribua o type nome ao type nome deste scratch.
Resolva o scratch.

Etapas necessárias para que se adicione several fragments usando uma string e uma variável e uma segunda string e uma segunda variável e um local de aparição:
Adicione um fragment usando o push endereço etiqueta e a segunda variável.
Adicione um segundo fragment usando o push endereço etiqueta e a variável.
Adicione um monikette para uns monikettes usando a string.
Adicione uma segunda monikette para os monikettes usando o type desta variável.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando o type desta segunda variável.
Encontre uma rotina usando os monikettes.
Se a rotina for inexistente, converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se a rotina for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " junto com o cabeçalho expandido seguido de "." e o local de aparição; exit.
Adicione um terceiro fragment usando a etiqueta de demanda interna e a rotina.

Etapas necessárias para que se adicione several fragments usando uma string e uma variável e uma segunda string e uma segunda variável e um terceiro string e um terceira variável e um endereço de memória do pedaço :
Adicione um fragment usando o push endereço etiqueta e o terceira variável.
Adicione um segundo fragment usando o push endereço etiqueta e a segunda variável.
Adicione um terceiro fragment usando o push endereço etiqueta e a variável.
Adicione um monikette para uns monikettes usando a string.
Adicione uma segunda monikette para os monikettes usando o type desta variável.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando o type desta segunda variável.
Adicione um quinto monikette para os monikettes usando o terceiro string.
Adicione um sexto monikette para os monikettes usando o type desta terceira variável.
Encontre uma rotina usando os monikettes.
Se a rotina for inexistente, converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se a rotina for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " junto com o cabeçalho expandido seguido de "." e o endereço de memória do pedaço; exit.
Adicione um quarto fragment usando a etiqueta de demanda interna e a rotina.

Etapas necessárias para que se adicione um source file para uns source files usando um endereço completo:
Crie o source file.
Posponha o source file para o source files.
Atribua o endereço completo ao endereço completo deste source file.

Etapas necessárias para que se adicione two fragments usando uma string e uma variável e um local de aparição:
Adicione um fragment usando o push endereço etiqueta e a variável.
Adicione um monikette para uns monikettes usando a string.
Adicione uma segunda monikette para os monikettes usando o type desta variável.
Encontre uma rotina usando os monikettes.
Se a rotina for inexistente, converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se a rotina for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " junto com o cabeçalho expandido seguido de "." e o local de aparição; exit.
Adicione um segundo fragment usando a etiqueta de demanda interna e a rotina.

Etapas necessárias para que se adicione um type para uns types usando um local de aparição:
Crie o type.
Posponha o type para o types.
Atribua o local de aparição ao local de aparição deste type.

Etapas necessárias para que se adicione um type para uns types usando um nome e um plural nome e um base nome:
Adicione o type para os types usando o nome e o plural nome e o base nome e nil.

Etapas necessárias para que se adicione um type para uns types usando um nome e um plural nome e um base nome e um local de aparição:
Crie o type.
Posponha o type para o types.
Atribua o local de aparição ao local de aparição deste type.
Atribua o nome ao nome deste type.
Atribua o plural nome ao plural nome deste type.
Atribua o base nome ao base nome deste type.

Etapas necessárias para que se adicione uma variável para uns variáveis usando um categoria e um local de aparição:
Crie a variável usando o categoria.
Posponha a variável para o variáveis.
Atribua o local de aparição ao local de aparição desta variável.



Etapas necessárias para que se enderece uns entries:
Obtenha um entry desde o entries.
Se a entry for inexistente, cancele.
Enderece o entry.
Repita.

Etapas necessárias para que se enderece um entry:
Atribua o endereço do nome usado atualmente ao nome endereço desta entry.
Atribua a quantidade de caracteres deste nome deste entry mais 3 para um número.
Arredonde o número para cima para o múltiplo imediato of 2.
Adicione o número para o endereço do nome usado atualmente.
Atribua o current previamente calculado endereço ao previamente calculado endereço desta entry.
Atribua o image base mais o current previamente calculado endereço ao endereço desta entry.
Adicione 4 para o current previamente calculado endereço.

Etapas necessárias para que se enderece um fragment usando um endereço:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Atribua o image base mais o endereço ao endereço deste fragment.
Se a etiqueta deste fragment for a push endereço etiqueta, adicione 7 para o endereço; exit.
Se a etiqueta deste fragment for a etiqueta de demanda interna, adicione 5 para o endereço; exit.
Se a etiqueta deste fragment for a load endereço etiqueta, adicione 12 para o endereço; exit.
Se a etiqueta deste fragment for a etiqueta de acréscimo, adicione 10 para o endereço; exit.
Se a etiqueta deste fragment for a dereference etiqueta, adicione 14 para o endereço; exit.
Se a etiqueta deste fragment for a jump false etiqueta, adicione 9 para o endereço; exit.
Se a etiqueta deste fragment for a etiqueta de negação, adicione 3 para o endereço; exit.
Se a etiqueta deste fragment for a exit etiqueta, adicione 5 para o endereço; exit.
Se a etiqueta deste fragment for a etiqueta de repetição, adicione 5 para o endereço; exit.
Se a etiqueta deste fragment for a break etiqueta, adicione 5 para o endereço; exit.
Se a etiqueta deste fragment for a prolog etiqueta, enderece o fragment usando o endereço (prolog); exit.
Se a etiqueta deste fragment for a epilog etiqueta, enderece o fragment usando o endereço (epilog); exit.
Se a etiqueta deste fragment for a Intel etiqueta, adicione a quantidade de caracteres deste código deste fragment para o endereço; exit.
Se a etiqueta deste fragment for a push value etiqueta, enderece o fragment usando o endereço (push value); exit.
Se a etiqueta deste fragment for a etiqueta de demanda externa, adicione 6 para o endereço; exit.
Se a etiqueta deste fragment for a load eax etiqueta, adicione 5 para o endereço; exit. \ was 8 when "load eax" took em variáveis; now "load eax" only does um immediate value
Se a etiqueta deste fragment for a save eax etiqueta, enderece o fragment usando o endereço (save eax); exit.
Se a etiqueta deste fragment for a etiqueta de demanda indireta, adicione 8 para o endereço; exit.
Se a etiqueta deste fragment for a etiqueta de endereço de rotina, adicione 12 para o endereço; exit.

Etapas necessárias para que se enderece um fragment usando um endereço (epilog):
Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.
Adicione 6 para o endereço.

Etapas necessárias para que se enderece um fragment usando um endereço (prolog):
Adicione 3 para o endereço.
Se o local size desta rotina utilizada atualmente não for 0, adicione 10 para o endereço.
Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o endereço.

Etapas necessárias para que se enderece um fragment usando um endereço (push value):
Adicione 6 para o endereço.
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - endereço um fragment usando um endereço (push value)"; exit.
Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - endereço um fragment usando um endereço (push value)"; exit.
Atribua a quantidade de caracteres deste type desta variável deste fragment para uma quantidade de caracteres.
Se a quantidade de caracteres for 4, adicione 2 para o endereço; exit.
Se a quantidade de caracteres for 2, adicione 3 para o endereço; exit.
Se a quantidade de caracteres for 1, adicione 4 para o endereço; exit.
Apresente a mensagem de erro contendo "Erro interno 3 - endereço um fragment usando um endereço (push value)".

Etapas necessárias para que se enderece um fragment usando um endereço (save eax):
Adicione 6 para o endereço.
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - endereço um fragment usando um endereço (push value)"; exit.
Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - endereço um fragment usando um endereço (push value)"; exit.
Atribua a quantidade de caracteres deste type desta variável deste fragment para uma quantidade de caracteres.
Se a quantidade de caracteres for 4, adicione 2 para o endereço; exit.
Se a quantidade de caracteres for 2, adicione 3 para o endereço; exit.
Se a quantidade de caracteres for 1, adicione 2 para o endereço; exit.
Apresente a mensagem de erro contendo "Erro interno 3 - endereço um fragment usando um endereço (push value)".

Etapas necessárias para que se enderece uns fragments usando um endereço:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um fragment desde o fragments.
Se o fragment for inexistente, cancele.
Enderece o fragment usando o endereço.
Repita.

Etapas necessárias para que se enderece um import:
Atribua o endereço do nome usado atualmente ao nome endereço deste import.
Atribua o endereço do cabeçalho usado atualmente ao header endereço deste import.
Atribua o endereço do nome usado atualmente ao nome memory endereço deste import header deste import.
Atribua a quantidade de caracteres deste nome deste import mais 1 para um número.
Arredonde o número para cima para o múltiplo imediato of 2.
Adicione o número para o endereço do nome usado atualmente.
Adicione a magnitude desse import header para o endereço do cabeçalho usado atualmente. \ tenho que traduzir com calma isso depois
Atribua o current previamente calculado endereço ao first previamente calculado memory endereço deste import header deste import.
Enderece as entries deste import.
Adicione 4 para o current previamente calculado endereço.

Etapas necessárias para que se enderece uns imports usando um endereço:
Atribua o endereço ao endereço do cabeçalho usado atualmente.
Atribua as contagem destes imports para uma contagem.
Adicione 1 para a contagem.
Multiplique a contagem pela magnitude desse import header.
Atribua o endereço mais a contagem ao current previamente calculado endereço.
Obtenha uma segunda contagem usando o imports (all entries mais markers).
Multiplique a segunda contagem por 4.
Atribua o current previamente calculado endereço mais a segunda contagem ao endereço do nome usado atualmente.
Percorra.
Obtenha um import desde o imports.
Se o import for inexistente, pare.
Enderece o import.
Repita.
Atribua o endereço do nome usado atualmente menos o endereço para um número.
Adicione o número para o endereço.

Um endereço é um número.

Etapas necessárias para que se enderece uma rotina usando um endereço:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a rotina for inexistente, cancele.
Se o employs cabeçalho expandido desta rotina não estiver em branco, cancele. \ employs são addressed later
Se o compiled detector desta rotina não estiver ativo, cancele.
Atribua a rotina à rotina utilizada atualmente.
Atribua o image base mais o endereço ao endereço desta rotina.
Enderece os fragments desta rotina usando o endereço.
Arredonde o endereço para cima para o múltiplo imediato of 4.

Etapas necessárias para que se enderece uns rotinas usando um endereço:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma rotina desde as rotinas.
Se a rotina for inexistente, pare.
Enderece a rotina usando o endereço.
Repita.

Etapas necessárias para que se enderece uma variável usando um endereço:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável for inexistente, cancele.
Se o compiled detector desta variável não estiver ativo, cancele.
Atribua o image base mais o endereço ao endereço desta variável.
Adicione a quantidade de caracteres deste type desta variável para o endereço.
Se o type desta variável puder ser reduzido para "string", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
Se o type desta variável puder ser reduzido para "texto", adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
Arredonde o endereço para cima para o múltiplo imediato of 4.

Etapas necessárias para que se enderece uns variáveis usando um endereço:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma variável desde o variáveis.
Se a variável for inexistente, cancele.
Enderece a variável usando o endereço.
Repita.



Etapas necessárias para que se advance um trecho:
Posponha o return pedaço para o trecho.
Posponha o linefeed pedaço para o trecho.

Etapas necessárias para que se advance um trecho (twice):
Advance o trecho.
Advance o trecho.

Etapas necessárias para que se posponha um entry para um trecho (com separator):
Se a entry for inexistente, posponha "" para o trecho (com separator); exit.
Posponha o nome desta entry para o trecho (com separator).

Etapas necessárias para que se posponha um detector para um trecho (com separator):
Converta o detector para uma string.
Posponha a string para o trecho (com separator).

Etapas necessárias para que se posponha o global finalizers para uma string:
Obtenha um global desde o globals.
Se o global for inexistente, cancele.
Se o compiled detector deste global não estiver ativo, repita.
Se o type deste global não deveria ser finalizado, repita.
Posponha "~finalize o " junto com o nome deste global seguido de ". " para a string.
Repita.

Etapas necessárias para que se posponha os global initializers para uma string:
Obtenha um global desde o globals.
Se o global for inexistente, cancele.
Se o literal deste global for inexistente, repita.
Se o compiled detector deste global não estiver ativo, repita.
Desative um detector.
Posponha o initializer string deste global para a string.
Repita.

Etapas necessárias para que se posponha um monikette para um cabeçalho expandido:
Se o monikette for inexistente, cancele.
Se o cabeçalho expandido não estiver em branco, posponha o caractere de espaço para o cabeçalho expandido.
Se o type deste monikette não for inexistente, posponha "[" e o nome deste type deste monikette e "]" para o cabeçalho expandido (fast); exit.
Se a string deste monikette não estiver em branco, posponha a string deste monikette para o cabeçalho expandido; exit.

Etapas necessárias para que se posponha um monikette para um cabeçalho expandido (while bubbling):
Se o monikette for inexistente, cancele.
Se o cabeçalho expandido não estiver em branco, posponha o caractere de espaço para o cabeçalho expandido.
Se o subtexto atual deste monikette não estiver em branco, posponha o subtexto atual deste monikette para o cabeçalho expandido; exit.
Se o type atual deste monikette não for inexistente, posponha "[" e o nome deste type atual deste monikette e "]" para o cabeçalho expandido (fast); exit.

Etapas necessárias para que se posponha um número para um trecho (as hex com separator):
Converta o número para um cifra hexadecimal.
Posponha a cifra hexadecimal para o trecho (com separator).

Etapas necessárias para que se posponha um número para um trecho (com separator):
Converta o número para uma string.
Posponha a string para o trecho (com separator).

Etapas necessárias para que se posponha um ratio para um trecho (com separator):
Converta o ratio para uma string.
Posponha a string para o trecho (com separator).

Etapas necessárias para que se posponha uma rotina para um trecho (com separator):
Se a rotina for inexistente, posponha "" para o trecho (com separator); exit.
Posponha o cabeçalho expandido deste rotina para o trecho (com separator).

Etapas necessárias para que se posponha uma string e uma segunda string e um terceiro string para um quarto string (fast):
Atribua a quantidade de caracteres deste quarto string para uma quantidade de caracteres.
Adicione a quantidade de caracteres desta string para a quantidade de caracteres.
Adicione a quantidade de caracteres desta segunda string para a quantidade de caracteres.
Adicione a quantidade de caracteres deste terceiro string para a quantidade de caracteres.
Reassign um endereço de memória usando a quantidade de caracteres.
Atribua o endereço de memória para um endereço de memória do pedaço .
Copie pedaços desde o first deste quarto string para o endereço de memória do pedaço pelo quantidade de caracteres deste quarto string.
Adicione a quantidade de caracteres deste quarto string para o endereço de memória do pedaço .
Copie pedaços desde o first endereço de memória do pedaço desta string para o endereço de memória do pedaço pelo quantidade de caracteres desta string.
Adicione a quantidade de caracteres desta string para o endereço de memória do pedaço .
Copie pedaços desde o first desta segunda string para o endereço de memória do pedaço pelo quantidade de caracteres desta segunda string.
Adicione a quantidade de caracteres desta segunda string para o endereço de memória do pedaço .
Copie pedaços desde o first deste terceiro string para o endereço de memória do pedaço pelo quantidade de caracteres deste terceiro string.
Unassign o first deste quarto string.
Atribua o endereço de memória ao first deste quarto string.
Atribua o endereço de memória mais a quantidade de caracteres menos 1 ao last deste quarto string.

Etapas necessárias para que se posponha uma string para um trecho (com separator):
Posponha a string para o trecho.
Posponha "/" para o trecho.

Etapas necessárias para que se posponha uma etiqueta para um trecho (as um fragment etiqueta string com separator):
Se a etiqueta for a break etiqueta, posponha "break" para o trecho (com separator); exit.
Se a etiqueta for a etiqueta de demanda externa, posponha "call external" para o trecho (com separator); exit.
Se a etiqueta for a etiqueta de demanda indireta, posponha "call indirect" para o trecho (com separator); exit.
Se a etiqueta for a etiqueta de demanda interna, posponha "call internal" para o trecho (com separator); exit.
Se a etiqueta for a dereference etiqueta, posponha "dereference" para o trecho (com separator); exit.
Se a etiqueta for a end if etiqueta, posponha "end if" para o trecho (com separator); exit.
Se a etiqueta for a epilog etiqueta, posponha "epilog" para o trecho (com separator); exit.
Se a etiqueta for a exit etiqueta, posponha "exit" para o trecho (com separator); exit.
Se a etiqueta for a etiqueta de finalização, posponha "finalize" para o trecho (com separator); exit.
Se a etiqueta for a etiqueta de acréscimo, posponha "increment" para o trecho (com separator); exit.
Se a etiqueta for a Intel etiqueta, posponha "Intel" para o trecho (com separator); exit.
Se a etiqueta for a jump false etiqueta, posponha "jump false" para o trecho (com separator); exit.
Se a etiqueta for a load endereço etiqueta, posponha "load endereço" para o trecho (com separator); exit.
Se a etiqueta for a load eax etiqueta, posponha "load eax" para o trecho (com separator); exit.
Se a etiqueta for a loop etiqueta, posponha "loop" para o trecho (com separator); exit.
Se a etiqueta for a etiqueta de negação, posponha "not" para o trecho (com separator); exit.
Se a etiqueta for a prolog etiqueta, posponha "prolog" para o trecho (com separator); exit.
Se a etiqueta for a push endereço etiqueta, posponha "push endereço" para o trecho (com separator); exit.
Se a etiqueta for a push value etiqueta, posponha "push value" para o trecho (com separator); exit.
Se a etiqueta for a save eax etiqueta, posponha "save eax" para o trecho (com separator); exit.
Se a etiqueta for a etiqueta de repetição, posponha "repeat" para o trecho (com separator); exit.
Se a etiqueta for a etiqueta de endereço de rotina, posponha "rotina endereço" para o trecho (com separator); exit.
Posponha "?" para o trecho (com separator).

Etapas necessárias para que se posponha um type para um trecho (com separator):
Se o type for inexistente, posponha "" para o trecho (com separator); exit.
Posponha o nome deste type para o trecho (com separator).

Etapas necessárias para que se posponha uma variável para um trecho (com separator):
Se a variável for inexistente, posponha "" para o trecho (com separator); exit.
Posponha o nome desta variável para o trecho (com separator).

Etapas necessárias para que se determine se uma string é algum tipo de contração de preposição com artigo definido:
Se a string for "do", diga sim.
Se a string for "da", diga sim.
Se a string for "dos", diga sim.
Se a string for "das", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de operador de concatenação contraído usando um percorredor:
Se o segmento inicial deste percorredor de contrações for "seguido", mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor de contrações for "seguida", mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor de contrações for "junto", mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor de contrações for "acompanhado", mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor for uma variável, recue o percorredor.
Se o segmento inicial deste percorredor de contrações for algum tipo de contração de preposição com artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string está precisando ser decomposta:
Lance um percorredor sobre a string.
Se a string for algum tipo de operador de concatenação contraído usando o percorredor, diga sim.
Diga não.

Etapas necessárias para que se posponha uma string para uma segunda string usando um terceiro string (para expandir contrações):
\# contrações
Se a string for "ao", posponha "a o" para a segunda string; exit.
Se a string for "à", posponha "a a" para a segunda string; exit.
Se a string for "aos", posponha "a os" para a segunda string; exit.
Se a string for "às", posponha "a as" para a segunda string; exit.
\Se a string estiver precisando ser decomposta, posponha "de o" para a segunda string; exit.
\Se a string for "dos", determine se a string precisa ser decomposta.
\Se a string precisa ser decomposta, posponha "de os" para a segunda string; exit
\Se a string for "da", determine se a string precisa ser decomposta.
\Se a string precisa ser decomposta, posponha "de a" para a segunda string; exit
\Se a string for "das", determine se a string precisa ser decomposta.
\Se a string precisa ser decomposta, posponha "de as" para a segunda string; exit
\Se a string for "do", posponha "de o" para a segunda string; exit.
\Se a string for "da", posponha "de a" para a segunda string; exit.
\Se a string for "dos", posponha "de os" para a segunda string; exit.
\Se a string for "das", posponha "de as" para a segunda string; exit.
\Se a string for "dum", posponha "de um" para a segunda string; exit.
\Se a string for "duma", posponha "de uma" para a segunda string; exit.
\Se a string for "dumas", posponha "de umas" para a segunda string; exit.
\Se a string for "duns", posponha "de uns" para a segunda string; exit.
Se a string for "daqui", posponha "de aqui" para a segunda string; exit.
Se a string for "dali", posponha "de ali" para a segunda string; exit.
Se a string for "dele", posponha "de ele" para a segunda string; exit.
Se a string for "dela", posponha "de ela" para a segunda string; exit.
Se a string for "desse", posponha "de esse" para a segunda string; exit.
Se a string for "dessa", posponha "de essa" para a segunda string; exit.
Se a string for "desses", posponha "de esses" para a segunda string; exit.
Se a string for "dessas", posponha "de essas" para a segunda string; exit.
Se a string for "deste", posponha "de este" para a segunda string; exit.
Se a string for "desta", posponha "de esta" para a segunda string; exit.
Se a string for "destes", posponha "de estes" para a segunda string; exit.
Se a string for "destas", posponha "de estas" para a segunda string; exit.
Se a string for "disso", posponha "de isso" para a segunda string; exit.
Se a string for "disto", posponha "de isto" para a segunda string; exit.
Se a string for "nesse", posponha "em esse" para a segunda string; exit.
Se a string for "nesses", posponha "em esses" para a segunda string; exit.
Se a string for "neste", posponha "em este" para a segunda string; exit.
Se a string for "nestes", posponha "em estes" para a segunda string; exit.
Se a string for "nisso", posponha "em isso" para a segunda string; exit.
Se a string for "nisto", posponha "em isto" para a segunda string; exit.
Se a string for "nessa", posponha "em essa" para a segunda string; exit.
Se a string for "nessas", posponha "em essas" para a segunda string; exit.
Se a string for "nesta", posponha "em esta" para a segunda string; exit.
Se a string for "nestas", posponha "em estas" para a segunda string; exit.
Se a string for "donde", posponha "de onde" para a segunda string; exit.
Se a string for "dentre", posponha "de entre" para a segunda string; exit.
Se a string for "dantes", posponha "de antes" para a segunda string; exit.
Se a string for "dalguém", posponha "de alguém" para a segunda string; exit.
Se a string for "dalgum", posponha "de um" para a segunda string; exit.
Se a string for "dalguma", posponha "de uma" para a segunda string; exit.
Se a string for "dalguns", posponha "de uns" para a segunda string; exit.
Se a string for "dalgumas", posponha "de umas" para a segunda string; exit.
Se a string for "nalgum", posponha "em um" para a segunda string; exit.
Se a string for "nalguma", posponha "em uma" para a segunda string; exit.
Se a string for "nalguns", posponha "em uns" para a segunda string; exit.
Se a string for "nalgumas", posponha "em umas" para a segunda string; exit.
Se a string for "doutro", posponha "de outro" para a segunda string; exit.
Se a string for "doutra", posponha "de outra" para a segunda string; exit.
Se a string for "doutros", posponha "de outros" para a segunda string; exit.
Se a string for "doutras", posponha "de outras" para a segunda string; exit.
Se a string for "noutro", posponha "em outro" para a segunda string; exit.
Se a string for "noutra", posponha "em outra" para a segunda string; exit.
Se a string for "noutros", posponha "em outros" para a segunda string; exit.
Se a string for "noutras", posponha "em outras" para a segunda string; exit.
\# "no" pode ser uma negação em inglês.
Se a string for alguma espécie de contração usando o terceiro string (portuguese rules - "no"), posponha "em o" para a segunda string; exit.
Se a string for "na", posponha "em a" para a segunda string; exit.
Se a string for "nos", posponha "em os" para a segunda string; exit.
Se a string for "nas", posponha "em as" para a segunda string; exit.
\Se a string for "noutro", posponha "em outro" para a segunda string; exit.
\Se a string for "noutra", posponha "em outra" para a segunda string; exit.
\Se a string for "noutros", posponha "em outros" para a segunda string; exit.
\Se a string for "noutras", posponha "em outras" para a segunda string; exit.
Se a string for "num", posponha "em um" para a segunda string; exit.
Se a string for "numa", posponha "em uma" para a segunda string; exit.
Se a string for "nuns", posponha "em uns" para a segunda string; exit.
Se a string for "numas", posponha "em umas" para a segunda string; exit.
Se a string for "pelo", posponha "por o" para a segunda string; exit.
Se a string for "pela", posponha "por a" para a segunda string; exit.
Se a string for "pelos", posponha "por os" para a segunda string; exit.
Se a string for "pelas", posponha "por as" para a segunda string; exit.
\# sinônimos
\apagado devido não utilização
Posponha a string para a segunda string.

Etapas necessárias para que se acrescente endereço loading código para um texto hexadecimal usando uma variável:
\ loads para edx
Se a variável for inexistente, acrescente $C7C200000000 para o texto hexadecimal; exit. \ mov edx,0
Se a categoria desta variável for "global", acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; exit. \ mov edx,the endereço da variável
Se a categoria desta variável for "literal", acrescente $C7C2 e o endereço desta variável para o texto hexadecimal; exit. \ mov edx,the endereço da variável
Se a categoria desta variável for "local", acrescente $8D95 e o offset desta variável para o texto hexadecimal; exit. \ lea edx,[ebp+ the offset da variável]
Se a categoria desta variável for "scratch", acrescente $8B95 e o offset desta variável para o texto hexadecimal; exit. \ mov edx, [ebp+ the offset da variável]
Se a categoria desta variável não for "parâmetro", apresente uma mensagem de erro contendo "Erro interno - acrescente endereço loading código para um texto hexadecimal usando uma variável"; exit.
Se o by-value detector desta variável estiver ativo, acrescente $8D95 e o offset desta variável para o texto hexadecimal; exit. \ lea edx,[ebp+the offset da variável]
Acrescente $8B95 e o offset desta variável para o texto hexadecimal. \ mov edx,[ebp+ the offset da variável]

Etapas necessárias para que se acrescente um texto hexadecimal e um endereço para um fragment:
\ call ou jump
Atribua o endereço para um número.
Subtraia o endereço deste fragment desde o número.
Subtraia a quantidade de caracteres deste código deste fragment desde o número.
Subtraia a quantidade de caracteres deste texto hexadecimal desde o número.
Subtraia 4 desde o número.
Acrescente o texto hexadecimal e o número para o código deste fragment.

Etapas necessárias para que se acrescente um texto hexadecimal e um número e um segundo texto hexadecimal para um terceiro texto hexadecimal:
Posponha o texto hexadecimal para o terceiro texto hexadecimal.
Converta o número para um quarto texto hexadecimal.
Posponha o quarto texto hexadecimal para o terceiro texto hexadecimal.
Posponha o segundo texto hexadecimal para o terceiro texto hexadecimal.

Etapas necessárias para que se acrescente um texto hexadecimal e um número e um segundo número para um segundo texto hexadecimal:
Posponha o texto hexadecimal para o segundo texto hexadecimal.
Converta o número para um terceiro texto hexadecimal.
Posponha o terceiro texto hexadecimal para o segundo texto hexadecimal.
Converta o segundo número para um quarto texto hexadecimal.
Posponha o quarto texto hexadecimal para o segundo texto hexadecimal.

Etapas necessárias para que se acrescente um texto hexadecimal e um detector para um segundo texto hexadecimal;
Etapas necessárias para que se acrescente um texto hexadecimal e um número para um segundo texto hexadecimal:
Posponha o texto hexadecimal para o segundo texto hexadecimal.
Converta o número para um terceiro texto hexadecimal.
Posponha o terceiro texto hexadecimal para o segundo texto hexadecimal.

Etapas necessárias para que se acrescente um texto hexadecimal para um segundo texto hexadecimal:
Employ posponha uma string para uma segunda string.

Etapas necessárias para que se disponibilize pedaços usando um endereço de memória e uma quantidade de caracteres e um trecho e um offset:
Atribua o first deste trecho mais o offset para um segundo endereço de memória.
Copie pedaços desde o endereço de memória para o segundo endereço de memória pelo quantidade de caracteres.

Etapas necessárias para que se disponibilize um DOS header para um trecho:
Disponibilize pedaços usando o endereçamento deste DOS header e o magnitude deste DOS header e o trecho e 0.

Etapas necessárias para que se disponibilize umas entries para um trecho:
Obtenha um entry desde o entries.
Se a entry for inexistente, cancele.
Disponibilize a entry ao trecho.
Repita.

Etapas necessárias para que se disponibilize um entry para um trecho:
Disponibilize pedaços usando o endereçamento deste nome endereço desta entry e 4 e o trecho e o previamente calculado endereço desta entry.
Atribua o nome endereço desta entry mais 2 para um endereço.
Disponibilize o nome desta entry ao trecho at o endereço.

Etapas necessárias para que se disponibilize um fragment para um trecho:
Se o código deste fragment estiver em branco, cancele.
Atribua o endereço deste fragment menos o image base para um endereço.
Disponibilize o código deste fragment ao trecho at o endereço.

Etapas necessárias para que se disponibilize uns fragments para um trecho:
Obtenha um fragment desde o fragments.
Se o fragment for inexistente, cancele.
Disponibilize o fragment ao trecho.
Repita.

Etapas necessárias para que se disponibilize um import para um trecho:
Disponibilize pedaços usando o endereçamento deste import header deste import e o magnitude deste import header deste import e o trecho e o header endereço deste import.
Disponibilize o nome deste import ao trecho at o nome endereço deste import.
Disponibilize as entries deste import ao trecho.

Etapas necessárias para que se disponibilize uns imports para um trecho:
Obtenha um import desde o imports.
Se o import for inexistente, cancele.
Disponibilize o import ao trecho.
Repita.

Etapas necessárias para que se disponibilize um PE header para um trecho:
Disponibilize pedaços usando o endereçamento deste PE header e o magnitude deste PE header e o trecho e 256.

Etapas necessárias para que se disponibilize uma rotina para um trecho:
Se o compiled detector desta rotina não estiver ativo, cancele.
Disponibilize os fragments desta rotina ao trecho.

Etapas necessárias para que se disponibilize uns rotinas para um trecho:
Obtenha uma rotina desde as rotinas.
Se a rotina for inexistente, cancele.
Disponibilize a rotina ao trecho.
Repita.

Etapas necessárias para que se disponibilize uma string para um trecho at um endereço:
Disponibilize pedaços usando o first endereço de memória do pedaço desta string e a quantidade de caracteres desta string e o trecho e o endereço.

Etapas necessárias para que se disponibilize uma variável para um trecho:
Se o compiled detector desta variável não estiver ativo, cancele.
Se o type desta variável puder ser reduzido para "string", disponibilize a variável ao trecho (como um texto); exit.
Se o type desta variável puder ser reduzido para "texto", disponibilize a variável ao trecho (como um texto); exit.
Atribua o endereço desta variável menos o image base para um endereço. \ Atribua a diferença entre o endreço da variável e a base da imagem em um endereço.
Disponibilize o data desta variável ao trecho at o endereço.

Etapas necessárias para que se disponibilize uma variável para um trecho (como um texto):
Atribua o endereço desta variável menos o image base para um endereço.
Atribua a quantidade de caracteres deste data desta variável para uma quantidade de caracteres.
Atribua o endereço para um segundo endereço.
Adicione a magnitude desse prototype string para o segundo endereço.
Adicione o image base para o segundo endereço.
Atribua 0 ao first endereço de memória do pedaço desta prototype string.
Atribua -1 ao last endereço de memória do pedaço desta prototype string.
Se a quantidade de caracteres não for 0, atribua o segundo endereço ao first endereço de memória do pedaço desta prototype string.
Se a quantidade de caracteres não for 0, atribua o first endereço de memória do pedaço desta prototype string mais a quantidade de caracteres menos 1 ao last endereço de memória do pedaço desta prototype string.
Disponibilize pedaços usando o endereçamento desta prototype string e a magnitude desta prototype string e o trecho e o endereço.
Adicione a magnitude [tamanho em bytes] desta prototype string para o endereço.
Disponibilize os data desta variável ao trecho at o endereço.

Etapas necessárias para que se disponibilize uns variáveis para um trecho:
Obtenha uma variável desde o variáveis.
Se a variável for inexistente, cancele.
Disponibilize a variável ao trecho.
Repita.

Um endereço base é um endereço.
Uma zona é um conjunto com um endereço base, uma quantidade de caracteres e um size.

Etapas necessárias para que se bubble um monikette:
Se o monikette for inexistente, cancele.
Se o subtexto atual deste monikette não estiver em branco, limpe o subtexto atual deste monikette; exit.
Se o type atual deste monikette for inexistente, cancele.
Se o type atual deste monikette for algum tipo pré-definido, atribua nil ao type atual deste monikette; exit.
Atribua o base type deste type atual deste monikette ao type atual deste monikette.

Um built-in type é um type.

Etapas necessárias para que se calculate a quantidade de caracteres of um type:
Se o type for inexistente, cancele.
Se a quantidade de caracteres deste type não for -1, cancele.
Calculate a quantidade de caracteres of o base type deste type.
Se os campos deste type estiverem vazio, atribua a quantidade de caracteres deste base type deste type ao quantidade de caracteres deste type; exit.
Atribua 0 ao quantidade de caracteres deste type.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo desde o campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition conteúdo nome deste campo não estiver em branco, repita.
Calculate a quantidade de caracteres of o type deste campo.
Adicione a quantidade de caracteres deste type deste campo times a contagem deste campo para a quantidade de caracteres deste type.
Repita.

Etapas necessárias para que se calculate o lengths of uns types:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Calculate a quantidade de caracteres of o type.
Repita.

Etapas necessárias para que se calculate o offsets em um type:
Se o type for inexistente, cancele.
Atribua 0 para um offset.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo desde os campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition conteúdo nome deste campo não estiver em branco, repita.
Atribua o offset ao offset deste campo.
Adicione a quantidade de caracteres deste type deste campo times a contagem deste campo para o offset.
Repita.

Etapas necessárias para que se calculate os offsets em uns types:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Calculate o offsets no type.
Repita.

Etapas necessárias para que se calculate o redefinition offsets em um type:
Se o type for inexistente, cancele.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo desde os campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition conteúdo nome deste campo estiver em branco, repita.
Encontre um segundo campo usando o redefinition conteúdo nome deste campo e os campos deste type.
Se o segundo campo for inexistente, apresente uma mensagem de erro contendo "Redefine inválido. Eu não consigo encontrar o campo: " junto com o redefinition conteúdo nome deste campo seguido de "' campo." e o local de aparição deste campo; exit.
Atribua o offset deste segundo campo ao offset deste campo.
Repita.

Etapas necessárias para que se calculate o redefinition offsets em uns types:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Calculate o redefinition offsets no type.
Repita.



Etapas necessárias para que se check por invalid optional info sobre um type:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o conteúdo nome deste type não estiver em branco, check por invalid optional info sobre o type (conteúdo).
Se o campos deste type não estiverem vazio, check por invalid optional info sobre o type (campos).
Se o scale deste type não for 0, check por invalid optional info sobre o type (scale).

Etapas necessárias para que se check por invalid optional info sobre um type (campos):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "conjunto", apresente uma mensagem de erro contendo "A palavra 'com' só é permitida em conjunto types." e o local de aparição deste type; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info sobre um type (scale):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "número", apresente uma mensagem de erro contendo "Escalas são permitidas apenas em tipos numéricos." e o local de aparição deste type; exit.

Etapas necessárias para que se check por invalid optional info sobre um type (conteúdo):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", apresente uma mensagem de erro contendo "A palavra 'to' só é permitida em endereço de memória types." e o local de aparição deste type; exit.

Etapas necessárias para que se limpe um campo termo:
Fill pedaços com o null pedaço starting at o endereçamento deste campo termo pelo magnitude deste campo termo.

Etapas necessárias para que se limpe um termo:
Esvazie a variável deste termo.
Limpe o phrase deste termo.

Etapas necessárias para que se compile o bodies of as rotinas:
Compile o body of a rotina denominada "initialize before run".
Compile o body of a rotina denominada "nosso programa seja executado".
Compile o body of a rotina denominada "finalize after run".

Etapas necessárias para que se compile o body of uma rotina:
Se a rotina for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o compiled detector desta rotina estiver ativo, cancele.
Ligue o compiled detector desta rotina.
Lance um percorredor sobre as instruções desta rotina.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for o ponto&vírgula, compile o body of a rotina usando o percorredor (sobrecarga de métodos); exit. \ *** alternate palavraing
Se o segmento inicial deste percorredor for algum tipo de employ, compile o body of a rotina usando o percorredor (employ); exit.
Atribua a rotina utilizada atualmente para um saved rotina.
Atribua a rotina à rotina utilizada atualmente.
Crie o nickname catálogo desta rotina usando 101.
Eliminate duplicate nicknames desde os parâmetros desta rotina usando o nickname catálogo desta rotina.
Compile o body of a rotina (prolog).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, pare.
Compile a próxima instrução usando o percorredor.
Repita.
Compile o body of a rotina (epilog).
Atribua o saved rotina à rotina utilizada atualmente.

Etapas necessárias para que se compile o body of uma rotina (epilog):
Se a rotina for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um fragment usando a etiqueta de finalização.
Percorra.
Obtenha uma variável desde os locals desta rotina.
Se a variável for inexistente, pare.
Se a categoria desta variável for "scratch", repita.
Se o type desta variável não deveria ser finalizado, repita.
Adicione um segundo fragment usando o push endereço etiqueta e a variável.
Encontre uma segunda rotina usando "~finalize" e o type desta variável.
Se a segunda rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno - compile o body of uma rotina (epilog)"; exit.
Adicione um terceiro fragment usando a etiqueta de demanda interna e a segunda rotina.
Repita.
Adicione um quarto fragment usando o epilog etiqueta.

Etapas necessárias para que se compile o body of uma rotina (prolog):
Se a rotina for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um fragment usando o prolog etiqueta.
Adicione um segundo fragment usando o loop etiqueta.

Etapas necessárias para que se compile o body of a rotina denominada uma string;
Etapas necessárias para que se compile o body of a rotina denominado uma string:
Se o detector de erros deste compilador estiver ativado, cancele.
Encontre uma rotina usando a string e o catálogo geral de rotinas.
Se a rotina for inexistente, apresente uma mensagem de erro contendo "Não consegui encontrar a rotina ''Etapas necessárias para que se " junto com a string seguido de ":''."; exit.
Compile o body of a rotina.

Etapas necessárias para que se compile o body of uma rotina usando um percorredor (sobrecarga de métodos):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador). \ *** do we need this?
Atribua o next desta rotina para um conteúdo rotina.
Se o conteúdo rotina for inexistente, apresente uma mensagem de erro contendo "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e o percorredor; exit.
Atribua o cabeçalho expandido deste conteúdo rotina ao employs cabeçalho expandido desta rotina.
Compile o body of o conteúdo rotina.

Etapas necessárias para que se compile o body of uma rotina usando um percorredor (employ):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile uma rotina reference usando o percorredor.
Converta a rotina reference para o employs cabeçalho expandido desta rotina.
Destrua a rotina reference.
Se o segmento inicial deste percorredor não for ".", apresente uma mensagem de erro contendo "Employ statments devem terminar com um ponto, não com: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Somente um employ" e o percorredor; exit.
Encontre uma segunda rotina usando o employs cabeçalho expandido desta rotina e o catálogo geral de rotinas.
Se a segunda rotina for inexistente, apresente a mensagem de erro contendo "Não consigo encontrar um rotina: " junto com o employs cabeçalho expandido desta rotina seguido de "' que você está tentando empregar." e o local de aparição desta rotina; exit.
Compile o body of a segunda rotina.

Etapas necessárias para que se compile o call'd part usando um percorredor e uma variável:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável for inexistente, cancele.
Atribua o nome desta variável ao type nome desta variável.
Mova o percorredor (usando diretrizes do compilador).
Examine o nome desta variável usando o percorredor.

Etapas necessárias para que se compile um endereço da pasta:
Compile o endereço da pasta (inicialização).
Compile o endereço da pasta (carregue os source files).
Compile o endereço da pasta (análise dos arquivos fornecidos).
Compile o endereço da pasta (decomponha os tipos das variáveis).
Compile o endereço da pasta (resolva o globals).
Compile o endereço da pasta (compile o headers of as rotinas).
Compile o endereço da pasta (calculate lengths e offsets of types).
Compile o endereço da pasta (Adicione o built-in memory rotinas).
Compile o endereço da pasta (catalogue as rotinas por utility use).
Compile o endereço da pasta (compile o bodies of as rotinas).
Compile o endereço da pasta (Adicione e compile o built-in startup rotina).
Compile o endereço da pasta (offset parâmetros e variáveis).
Compile o endereço da pasta (address).
Compile o endereço da pasta (transmutação).
Compile o endereço da pasta (link).
Compile o endereço da pasta (etapa final).
Compile o endereço da pasta (interrupção).

Etapas necessárias para que se compile um endereço da pasta (Adicione e compile o built-in startup rotina):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando e agrupando as tarefas padrão de inicialização..".
Start o temporizador de adição de rotinas pré-definidas de inicialização.
Adicione e compile a rotina de inicialização pré-execução e finalização pós-execução.
Suspenda o temporizador de adição de rotinas pré-definidas de inicialização.

Etapas necessárias para que se compile um endereço da pasta (Adicione o built-in memory rotinas):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando como tarefas predefinidas na memória...".
Start o temporizador de adição de rotinas pré-definidas de mémoria .
Adicione as rotinas de alocação e desalocação e finalização e destruição.
Suspenda o temporizador de adição de rotinas pré-definidas de mémoria .

A zona de código é um zona.

Etapas necessárias para que se compile um endereço da pasta (address):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Obtendo endereço dos itens...".
Start o temporizador de endereçamento.
Atribua 4096 para um endereço.
Atribua o endereço à endereço base desta import zona.
Enderece o imports usando o endereço.
Atribua o endereço menos a endereço base desta import zona ao quantidade de caracteres desta import zona.
Arredonde o endereço para cima para o múltiplo imediato of 4096.
Atribua o endereço à endereço base desta zona de dados.
Enderece os globals usando o endereço.
Enderece os literals usando o endereço.
Atribua o endereço menos a endereço base desta zona de dados ao quantidade de caracteres desta zona de dados.
Arredonde o endereço para cima para o múltiplo imediato of 4096.
Atribua o endereço à endereço base desta zona de código. \ Uma zona é uma estrutura que contém um endereço base, uma quantidade de caracteres e um tamanho.
Enderece as rotinas usando o endereço.
Atribua o endereço menos a endereço base desta zona de código ao quantidade de caracteres desta zona de código.
Suspenda o temporizador de endereçamento.

Etapas necessárias para que se compile um endereço da pasta (calculate lengths e offsets of types):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Calculando tamanhos e deslocamentos...".
Start o temporizador de etapas de cálculo.
Calculate o lengths of o types.
Calculate o offsets no types.
Calculate o redefinition offsets no types.
Suspenda o temporizador de etapas de cálculo.

Etapas necessárias para que se compile um endereço da pasta (compile o bodies of as rotinas):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando o conteúdo das tarefas...".
Start o temporizador de compilação do conteúdo das rotinas.
Compile o bodies of as rotinas.
Suspenda o temporizador de compilação do conteúdo das rotinas.

Etapas necessárias para que se compile um endereço da pasta (compile o headers of as rotinas):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando os nomes das tarefas...".
Start o temporizador de compilação de cabeçalhos de rotina.
Compile o headers of as rotinas.
Suspenda o temporizador de compilação de cabeçalhos de rotina.

Etapas necessárias para que se compile um endereço da pasta (catalogue as rotinas por utility use):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Catalogando tarefas...".
Start o temporizador de ferramentas de catalogação.
Catalogue as rotinas por utility use.
Scrub o catálogo de rotinas úteis.
Organize o catálogo de rotinas úteis.
Suspenda o temporizador de ferramentas de catalogação.

Etapas necessárias para que se compile um endereço da pasta (link):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Elencando arquivos..".
Start o temporizador de vinculação.
Link.
Suspenda o temporizador de vinculação.

Etapas necessárias para que se compile um endereço da pasta (offset parâmetros e variáveis):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Deslocando parâmetros e variáveis...".
Start o temporizador de deslocamentos.
Offset o parâmetros na rotinas.
Offset o locals na rotinas.
Suspenda o temporizador de deslocamentos.

Etapas necessárias para que se compile um endereço da pasta (carregue os source files):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Carregando arquivos...".
Start o temporizador de operacionalização.
Carregue o source files.
Suspenda o temporizador de operacionalização.

Etapas necessárias para que se compile um endereço da pasta (resolva o globals):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo itens de escopo abrangente...".
Start o temporizador de resolução de variáveis globais.
Resolva o globals.
Suspenda o temporizador de resolução de variáveis globais.

Etapas necessárias para que se compile um endereço da pasta (decomponha os tipos das variáveis):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo tipos...".
Start o temporizador de resolução de tipos.
Resolva os types (expand coisas).
Resolva os types (registro de plurais).
Resolva os types (base types).
Resolva os types (optional info).
Suspenda o temporizador de resolução de tipos.

Etapas necessárias para que se compile um endereço da pasta (análise dos arquivos fornecidos):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Analisando arquivos...".
Start o temporizador de análise/verificação.
Examine o source files.
Suspenda o temporizador de análise/verificação.

Etapas necessárias para que se compile um endereço da pasta (inicialização):
Mostre painel de informações "Iniciando...".
Finalize o compilador.
Start o temporizador deste compilador.
Inicialize o compilador usando o endereço da pasta.
Adicione o built-in types.

Etapas necessárias para que se compile um endereço da pasta (interrupção):
Suspenda o temporizador deste compilador.
Mostre painel de informações "Interrompendo".

Etapas necessárias para que se compile um endereço da pasta (transmutação):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Modificando...".
Start o temporizador de transmutação.
Transforme em código hexadecimal as rotinas.
Suspenda o temporizador de transmutação.

Etapas necessárias para que se compile um endereço da pasta (etapa final):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Gerando arquivo executável...".
Start o temporizador de escrita.
Escreva o exe deste compilador para o endereço exe completo deste compilador.
Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo o erro do fluxo de entrada/saída.
Suspenda o temporizador de escrita.

Etapas necessárias para que se compile um expression usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Compile um termo usando o percorredor.
Atribua o termo ao expression.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor não for algum operator aritmético, cancele.
Se o segmento inicial deste percorredor for algum operator de divisão, compile o expression usando o percorredor (operador de divisão); repita.
Se o segmento inicial deste percorredor for algum operator de subtração, compile o expression usando o percorredor (operador de subtração); repita.
Se o segmento inicial deste percorredor for algum operator de adição, compile o expression usando o percorredor (operador de adição); repita.
Se o segmento inicial deste percorredor for algum tipo de operador de concatenação, compile o expression usando o percorredor (operador de concatenação); repita.
Se o segmento inicial deste percorredor for algum operator de multiplicação, compile o expression usando o percorredor (operador de multiplicação); repita.
Se o segmento inicial deste percorredor for "junto", compile o expression usando o percorredor (operador de concatenação); repita.
Se o segmento inicial deste percorredor for "juntamente", compile o expression usando o percorredor (operador de concatenação); repita.
Se o segmento inicial deste percorredor for "seguido", compile o expression usando o percorredor (operador de concatenação); repita.
Se o segmento inicial deste percorredor for "acompanhado", compile o expression usando o percorredor (operador de concatenação); repita.

Etapas necessárias para que se compile um expression usando um percorredor (operador de divisão):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum objeto indireto, apresente uma mensagem de erro contendo "Você deve usar o termo 'dividido POR'." e o percorredor; exit.
Se a variável desta expression for inexistente, apresente a mensagem de erro contendo "Comando 'dividido por' inválido, há um erro na variável: " junto com a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'dividido por', está errado. Não dá pra dividir por: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando o type nome desta expression e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "divida" e o intermediate e "por" e a variável deste termo e o first deste segmento inicial deste percorredor.
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (operador de subtração):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'minus', está errado. Não consigo subtrair o(a): " junto com a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'minus', está errado. Não consigo diminuir do(a): " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando o type nome desta expression e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "subtraia" e a variável deste termo e "desde" e o intermediate e o first deste segmento inicial deste percorredor.
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (operador de adição):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'plus', está errado. Não consigo somar o: " junto com a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador). \talvez fosse o caso de repetir aqui
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'plus', está errado. Não consigo somar um: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando o type nome desta expression e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o first deste segmento inicial deste percorredor.\aqui muda o atribua
Adicione several fragments usando "adicione" e a variável deste termo e "para" e o intermediate e o first deste segmento inicial deste percorredor. \ aqui muda o add
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (operador de concatenação):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor for "do",  recue/atribua/posponha "de o" ao 
Se o segmento inicial deste percorredor não for algum tipo de palavra de concatenação, apresente uma mensagem de erro contendo "Você deve usar o termo 'junto DE/junto COM/etc'." e o percorredor; exit.
Se a variável desta expression for inexistente, apresente a mensagem de erro contendo "O seu 'then', está errado. Eu não entendi a variável da expressão: " junto com a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor. \\ aqui que deve compilar o termo
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'then', está errado. Eu não achei a variável do termo: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando "string" e o first deste segmento inicial deste percorredor.
\Adicione um intermediate usando "texto" e o first deste segmento inicial deste percorredor.
Adicione o atribua ou converta fragments usando a variável desta expression e o intermediate e o first deste segmento inicial deste percorredor.
Converta o termo por concatenation usando o percorredor. \\ aqui faz a concatenação
Adicione several fragments usando "posponha" e a variável deste termo e "para" e o intermediate e o first deste segmento inicial deste percorredor.
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (operador de multiplicação):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'times', está errado. Eu não sei como multiplicar o: " junto com a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'times', está errado. Eu não sei como multiplicar um: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando o type nome desta expression e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "multiplique" e o intermediate e "por" e a variável deste termo e o first deste segmento inicial deste percorredor.
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile o header of uma rotina:
Se a rotina for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Lance um percorredor sobre a cabeçalho de rotina desta rotina.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for algum tipo de decide, compile o header of a rotina usando o percorredor (rotina deliberativa); exit.
Se o percorredor for o start of algum tipo de reverse-possessive function, compile o header of a rotina usando o percorredor (função do possessivo reverso); exit.
Se o percorredor for o start of algum tipo de function, compile o header of a rotina usando o percorredor (função); exit.
Se o segmento inicial deste percorredor for "compativelmente", compile o header of a rotina usando o percorredor (modo de compatibilidade); exit.
Compile o header of a rotina usando o percorredor (procedimento).

Etapas necessárias para que se compile o header of uma rotina usando um percorredor (modo de compatibilidade):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Ligue o detector de compatibilidade desta rotina.
Compile os monikettes desta rotina e os parâmetros desta rotina usando o percorredor.
Converta os monikettes desta rotina para o cabeçalho expandido desta rotina.
Se o cabeçalho expandido desta rotina estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Você já tinha escrito um função: " junto com o cabeçalho expandido desta rotina seguido de "." e o local de aparição desta rotina; exit.
Catalogue a rotina usando os monikettes desta rotina e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma rotina usando um percorredor (rotina deliberativa):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de comando condicional, apresente uma mensagem de erro contendo "Erro na sintaxe do comando 'Para que se determine se'" e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Ligue o detector de deliberação desta rotina.
Compile os monikettes desta rotina e os parâmetros desta rotina usando o percorredor.
Se alguns of os monikettes desta rotina forem negative palavras, apresente a mensagem de erro contendo "Não consigo me dar bem com palavras negativas em nomes de funções decisoras." e o percorredor; exit.
Converta os monikettes desta rotina para o cabeçalho expandido desta rotina.
Se o cabeçalho expandido desta rotina estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Você já me contou como'" junto com o cabeçalho expandido desta rotina seguido de "." e o local de aparição desta rotina; exit.
Catalogue a rotina usando os monikettes desta rotina e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma rotina usando um percorredor (função):
Se o detector de erros deste compilador estiver ativado, cancele.
Ligue o detector de função desta rotina.
Adicione um monikette para os monikettes desta rotina usando "atribua".
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, acione um detector.
Se o detector estiver ativo, compile os monikettes desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
Se o detector não estiver ativo, compile os monikettes desta rotina e os parâmetros desta rotina usando o percorredor (artigo definido).
Se o segmento inicial deste percorredor não for algum tipo de possessive, apresente uma mensagem de erro contendo "Tá faltando um 's por aqui (ou está no lugar errado)." e o percorredor; exit. \ not translated - no possessives em Spanish
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Adicione uma segunda monikette para os monikettes desta rotina usando "'s " junto com o nome.
Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "Eu estava esperando um palavra 'into/para', mas encontrei a palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Adicione um terceiro monikette para os monikettes desta rotina usando "para".
Converta os monikettes desta rotina para um cabeçalho expandido.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Eu já sei como: " junto com o cabeçalho expandido seguido de "." e o local de aparição desta rotina; exit. \ not translated - no possessives em Spanish
Catalogue a rotina usando os monikettes desta rotina e o catálogo geral de rotinas.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Estava esperando um artigo indefinido, mas achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Compile os monikettes desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Tem comandos extras no fim dessa função." e o percorredor; exit. \ not translated - no possessives em Spanish
Converta os monikettes desta rotina para o cabeçalho expandido desta rotina.
Catalogue a rotina usando os monikettes desta rotina e o catálogo geral de rotinas. \ por employs

Etapas necessárias para que se compile o header of uma rotina usando um percorredor (procedimento):
Se o detector de erros deste compilador estiver ativado, cancele.
Compile os monikettes desta rotina e os parâmetros desta rotina usando o percorredor.
Converta os monikettes desta rotina para o cabeçalho expandido desta rotina.
Se o cabeçalho expandido desta rotina estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Você já escreveu como fazer: " junto com o cabeçalho expandido desta rotina seguido de "." e o local de aparição desta rotinas; exit.
Catalogue a rotina usando os monikettes desta rotina e o catálogo geral de rotinas.

Etapas necessárias para que se compile o headers of uns rotinas:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma rotina desde as rotinas.
Se a rotina for inexistente, cancele.
Compile o header of a rotina.
Repita.

Etapas necessárias para que se compile um literal usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione o literal para os literals usando o first deste segmento inicial deste percorredor .
\Se o segmento inicial deste percorredor for algum tipo de detector literal, compile o literal usando o percorredor (detector); exit.
Se o segmento inicial deste percorredor for algum tipo de hex literal, compile o literal usando o percorredor (hex); exit.
Se o segmento inicial deste percorredor for algum tipo de numeric literal, compile o literal usando o percorredor (numeric); exit.
Se o segmento inicial deste percorredor for algum tipo de endereço de memória literal, compile o literal usando o percorredor (endereço de memória); exit.
Se o segmento inicial deste percorredor for algum tipo de string literal, compile o literal usando o percorredor (texto); exit.
Apresente uma mensagem de erro contendo "Erro interno - compile um termo usando um percorredor (literal)" e o percorredor.

Etapas necessárias para que se compile um literal usando um percorredor (detector):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o segmento inicial deste percorredor para um detector.
Converta o detector para os data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "detector" ao type nome deste literal.
Resolva o literal. \\ Que tal utilizar os termos "decifre", "traduza", "destrinche", "decodifique"?

Etapas necessárias para que se compile um literal usando um percorredor (hex):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o segmento inicial deste percorredor para um parte da cifra binária.
Adicione 1 para o first desta parte da cifra binária.
Converta o parte da cifra binária para o data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "texto hexadecimal" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - integer):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o segmento inicial deste percorredor para um número.
Converta o número para os data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "número" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - ratio):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o segmento inicial deste percorredor para um ratio.
Converta o ratio para o data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "ratio" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - com unidade de medida):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o segmento inicial deste percorredor para um ratio.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Encontre um type usando o nome e o catálogo de tipos.
Se o type for inexistente, apresente uma mensagem de erro contendo "'" junto com o nome seguido de "' é uma unidade de medida inexistente." e o local de aparição deste literal; exit.
Se o type não puder ser reduzido para "número", apresente a mensagem de erro contendo "'" junto com o nome seguido de "' é uma unidade de medida inválida." e o local de aparição deste literal; exit.
Atribua a scale deste type para um final ratio.
Se a scale deste type for 0, atribua 1/1 ao final ratio.
Multiplique o final ratio pelo ratio.
Reduce o final ratio.
Se o denominador deste final ratio for 0, apresente a mensagem de erro contendo "Parece que essa é uma unidade de medida inválida." e o local de aparição deste literal.
Atribua o numerador deste final ratio dividido pelo denominador deste final ratio para um número.
Atribua o nome deste type ao type nome deste literal.
Converta o número para o data deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o percorredor estiver acompanhado por algum tipo de unidade de medida, compile o literal usando o percorredor (numeric - com unidade de medida); exit.
Se o segmento inicial deste percorredor for algum tipo de integer literal, compile o literal usando o percorredor (numeric - integer); exit.
Se o segmento inicial deste percorredor for algum tipo de ratio literal, compile o literal usando o percorredor (numeric - ratio); exit.
Se o segmento inicial deste percorredor for algum tipo de mixed literal, compile o literal usando o percorredor (numeric - ratio); exit.

Etapas necessárias para que se compile um literal usando um percorredor (endereço de memória):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta 0 para os data deste literal. \ was nil
Mova o percorredor (usando diretrizes do compilador).
Atribua "endereço de memória" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (texto):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o segmento inicial deste percorredor aos data deste literal.
Remova aspas de os data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "string" ao type nome deste literal.
\Atribua "texto" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile uns monikettes e uns parâmetros usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o segmento inicial deste percorredor for algum tipo de artigo definido, compile os monikettes e o parâmetros usando o percorredor (artigo definido); repita.
Se o percorredor estiver sobre algum tipo de artigo indefinido, compile os monikettes e o parâmetros usando o percorredor (artigo indefinido); repita.
Se o percorredor estiver sobre algum tipo de monikette string, compile os monikettes e o parâmetros usando o percorredor (monikette string); repita.
Apresente uma mensagem de erro contendo "'" junto com o segmento inicial deste percorredor seguido de "' não é um nome de função que eu conheça." e o percorredor.

Etapas necessárias para que se compile uns monikettes e uns parâmetros usando um percorredor (artigo definido):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Anteponha "o " para o nome.
Adicione um monikette para os monikettes usando o nome.

Etapas necessárias para que se compile uns monikettes e uns parâmetros usando um percorredor (artigo indefinido):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um parâmetro para o parâmetros usando "parâmetro" e o first deste segmento inicial deste percorredor.
\PAL
Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste parâmetro.
Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste parâmetro.
Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste parâmetro.
Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste parâmetro.
\CAL
Se o segmento inicial deste percorredor for "another", atribua "segunda" ao nome deste parâmetro.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Extend o nome destes parâmetro com o nome.
Se o segmento inicial deste percorredor for algum tipo de called, compile o call'd part usando o percorredor e o parâmetro.
Resolva o parâmetro.
Se o parâmetro estiver duplicada no parâmetros, apresente uma mensagem de erro contendo "Cara, você repetiu o parâmetro: " junto com o nome deste parâmetro seguido de "." e o local de aparição deste parâmetro; exit.
Adicione um monikette para os monikettes usando o type deste parâmetro.

Etapas necessárias para que se compile uns monikettes e uns parâmetros usando um percorredor (monikette string):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um monikette para os monikettes usando o segmento inicial deste percorredor.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile uns monikettes usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o percorredor estiver sobre algum tipo de monikette string, adicione um monikette para os monikettes usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes do compilador); repita.
Se o segmento inicial deste percorredor não for o start of algum tipo de expression, cancele.
Compile um expression usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione uma segunda monikette para os monikettes usando o expression.
Repita.

\Etapas necessárias para que se compile uns monikettes usando um percorredor:
\Se o detector de erros deste compilador estiver ativado, cancele.
\Se o segmento inicial deste percorredor for algum tipo de monikette string, adicione um monikette para os monikettes usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes do compilador); repita.
\Se o segmento inicial deste percorredor não for o start of algum tipo de expression, cancele.
\Compile um expression usando o percorredor.
\Se o detector de erros deste compilador estiver ativado, cancele.
\Adicione uma segunda monikette para os monikettes usando o expression.
\Repita.

Etapas necessárias para que se compile a próxima instrução usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor for algum tipo de comando condicional, compile a próxima instrução usando o percorredor (if); exit.
Se o segmento inicial deste percorredor for algum tipo de loop, compile a próxima instrução usando o percorredor (loop); exit.
Se o segmento inicial deste percorredor for algum tipo de privatize, compile a próxima instrução usando o percorredor (privatize); exit.
Se o segmento inicial deste percorredor não for o start of algum tipo de statement, apresente uma mensagem de erro contendo "Eu esperava uma declaração aqui, mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Compile a próxima instrução usando o percorredor (other).
Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Tem um problema nesse comando aqui." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile a próxima instrução usando um percorredor (break):
Adicione um fragment usando o break etiqueta.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile a próxima instrução usando um percorredor (call - external):
Atribua o segmento inicial deste percorredor para uma string.
Remova aspas de a string.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de string literal, apresente uma mensagem de erro contendo "Cara, você precisa colocar os nomes entre aspas, mas você colocou: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Atribua o segmento inicial deste percorredor para uma segunda string.
Remova aspas de a segunda string.
Mova o percorredor (usando diretrizes do compilador).
Adicione um entry para o imports usando a string e a segunda string.
Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (call - cláusula com).
Se o segmento inicial deste percorredor for "contendo", compile a próxima instrução usando o percorredor (call - cláusula com).
Se o segmento inicial deste percorredor for "usando", compile a próxima instrução usando o percorredor (call - cláusula com).
Se o segmento inicial deste percorredor for "devolvendo", compile a próxima instrução usando o percorredor devolvendo um termo (call - cláusula devolvendo).
\\Se o segmento inicial deste percorredor for "entregando", compile a próxima instrução usando o percorredor devolvendo um terceiro termo (call - cláusula devolvendo).
\\Se o segmento inicial deste percorredor for "apimorando", compile a próxima instrução usando o percorredor devolvendo um quarto termo (call - cláusula devolvendo).
\\Se o segmento inicial deste percorredor for "aperfeiçoando", compile a próxima instrução usando o percorredor devolvendo um quinto termo (call - cláusula devolvendo).
\\Se o segmento inicial deste percorredor for "melhorando", compile a próxima instrução usando o percorredor devolvendo um sexto termo (call - cláusula devolvendo).
Adicione um fragment usando a etiqueta de demanda externa e o entry.
Se o termo estiver vazio, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Não entendi bem o que é: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um segundo fragment usando o save eax etiqueta e a variável deste termo.

Etapas necessárias para que se compile a próxima instrução usando um percorredor (call - indirect):
Compile um expression usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Eu não sei o que é: " junto com a phrase desta expression seguido de "." e o percorredor; exit.
Se o type desta expression não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Eu preciso de um endereço de memória type nesse CALL statement." e o percorredor; exit.
Se o segmento inicial deste percorredor for "com", compile a próxima instrução usando o percorredor (call - cláusula com).
Se o segmento inicial deste percorredor for "contendo", compile a próxima instrução usando o percorredor (call - cláusula com).
Se o segmento inicial deste percorredor for "devolvendo", compile a próxima instrução usando o percorredor devolvendo um termo (call - cláusula devolvendo).
Adicione um fragment usando a etiqueta de demanda indireta e a variável desta expression.
Se o termo estiver vazio, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Acho que essa varíavel é inválida: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um segundo fragment usando o save eax etiqueta e a variável deste termo.

Etapas necessárias para que se compile a próxima instrução usando um percorredor (call - internal):
Compile uns monikettes usando o percorredor.
Encontre uma rotina usando os monikettes.
Se a rotina não for inexistente, adicione push fragments usando os monikettes.
Se a rotina não for inexistente, destrua os monikettes; adicione um fragment usando a etiqueta de demanda interna e a rotina; exit.
Converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
\Atribua "Eu ainda não aprendi como" à reply.
\Say o reply.
Atribua o cabeçalho expandido à reply.
\Say o reply.
Apresente uma mensagem de erro contendo "Eu ainda não aprendi como: " junto com o cabeçalho expandido seguido de "." e o percorredor.

Etapas necessárias para que se compile a próxima instrução usando um percorredor (call - cláusula com):
\ this guy é recursise so parâmetros obtenha passed right para left
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile um expression usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Eu não entendi a variável: " junto com a phrase desta expression seguido de "." e o percorredor; exit.
Se o type desta expression não for value pushable, apresente a mensagem de erro contendo "'" junto com o nome deste type desta expression seguido de "' não pode ser processado corretamente." e o percorredor; exit.
Se o segmento inicial deste percorredor for algum tipo de and, compile a próxima instrução usando o percorredor (call - cláusula com).
Adicione um fragment usando o push value etiqueta e a variável desta expression.

Etapas necessárias para que se compile a próxima instrução usando um percorredor (call):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for algum tipo de string literal, compile a próxima instrução usando o percorredor (call - external); exit.
Compile a próxima instrução usando o percorredor (call - indirect).

Etapas necessárias para que se compile a próxima instrução usando um percorredor (exit):
Se o detector de deliberação desta rotina utilizada atualmente estiver ativo, apresente uma mensagem de erro contendo "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" e o percorredor; exit.
\Se o segmento inicial deste percorredor for "a", mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor for "operação", mova o percorredor (usando diretrizes do compilador).
Adicione um fragment usando o exit etiqueta.
\Se o segmento inicial deste percorredor for "a", mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor for "operação", mova o percorredor (usando diretrizes do compilador).
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile a próxima instrução usando um percorredor (if):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile uns monikettes usando o percorredor.
Remove algum tipo de negatives desde os monikettes devolvendo um detector.
Encontre uma rotina usando os monikettes.
Se a rotina não for inexistente, adicione push fragments usando os monikettes.
Se a rotina for inexistente, converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se a rotina for inexistente, apresente uma mensagem de erro contendo "Preciso de um decider que tenha as palavras: " junto com o cabeçalho expandido seguido de "." e o percorredor; exit.
Se o detector de deliberação desta rotina não estiver ativo, apresente a mensagem de erro contendo "Cara eu vou precisar de um decider aqui, blz?" e o percorredor; exit.
Se o segmento inicial deste percorredor não for a vírgula, apresente a mensagem de erro contendo "Acho que você esqueceu de uma vírgula, eu achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Adicione um fragment usando a etiqueta de demanda interna e a rotina.
Se o detector estiver ativo, adicione um segundo fragment usando a etiqueta de negação.
Adicione um terceiro fragment usando o jump false etiqueta.
Mova o percorredor (usando diretrizes do compilador).
Percorra.
Compile a próxima instrução usando o percorredor (other).
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor for o ponto&vírgula, mova o percorredor (usando diretrizes do compilador); repita.
\Se o segmento inicial deste percorredor for "Senão", mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor for "Caso", mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor for a vírgula, mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você precisa usar um ponto ao invés de usar o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Adicione um quarto fragment usando o end if etiqueta.

Etapas necessárias para que se compile a próxima instrução usando um percorredor (Intel):
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de hex literal, apresente uma mensagem de erro contendo "Eu preciso de um pouco de machine código, mas o que eu achei foi: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Adicione um fragment usando o Intel etiqueta.
Atribua o segmento inicial deste percorredor para um parte da cifra binária.
Adicione 1 para o first desta parte da cifra binária.
Converta o parte da cifra binária para o código deste fragment.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile a próxima instrução usando um percorredor (loop):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um fragment usando o loop etiqueta.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Parece que alguém esqueceu de colocar um ponto por aí." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile a próxima instrução usando um percorredor (other):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o segmento inicial deste percorredor for algum tipo de exit, compile a próxima instrução usando o percorredor (exit); exit.
Se o segmento inicial deste percorredor for algum tipo de repeat, compile a próxima instrução usando o percorredor (repeat); exit.
Se o segmento inicial deste percorredor for algum tipo de break, compile a próxima instrução usando o percorredor (break); exit.
Se o segmento inicial deste percorredor for algum tipo de say, compile a próxima instrução usando o percorredor (say); exit.
Se o segmento inicial deste percorredor for "Intel", compile a próxima instrução usando o percorredor (Intel); exit.
Se o segmento inicial deste percorredor for "push", compile a próxima instrução usando o percorredor (push); exit.
Se o segmento inicial deste percorredor for algum tipo de call, compile a próxima instrução usando o percorredor (call); exit.
Se o segmento inicial deste percorredor for algum tipo de point, compile a próxima instrução usando o percorredor (point); exit.
Se o segmento inicial deste percorredor for algum tipo de comando condicional, apresente uma mensagem de erro contendo "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." e o percorredor; exit.
Se o segmento inicial deste percorredor for algum tipo de privatize, apresente a mensagem de erro contendo "A sentença 'privatizar' não pode ser usada aqui." e o percorredor; exit.
Se o segmento inicial deste percorredor for algum tipo de loop, apresente a mensagem de erro contendo "Usar um percorra dentro de um SE for uma ótima forma de arranjar problemas." e o percorredor; exit.
Se o segmento inicial deste percorredor for algum tipo de employ, apresente a mensagem de erro contendo "'Empregue' deve ser o único imperativo em uma rotina." e o percorredor; exit.
\Se o segmento inicial deste percorredor for "senão", mova o percorredor (usando diretrizes do compilador); exit.
\Se o segmento inicial deste percorredor for "caso", mova o percorredor (usando diretrizes do compilador); exit.
\Se o segmento inicial deste percorredor for "contrário", mova o percorredor (usando diretrizes do compilador); exit.
\Se o segmento inicial deste percorredor for "a", ative um detector; mova o percorredor (usando diretrizes do compilador); exit.
\Se o detector estiver ativado e o segmento inicial deste percorredor for "operação", mova o percorredor (usando diretrizes do compilador); exit.
\Se o segmento inicial deste percorredor for "operação", desative o detector; mova o percorredor (usando diretrizes do compilador); exit.
Compile a próxima instrução usando o percorredor (call - internal).

Etapas necessárias para que se compile a próxima instrução usando um percorredor (point):
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Acho que o termo: " junto com a phrase deste termo seguido de "' está vazio." e o percorredor; exit.
Se a categoria deste termo for "literal", apresente a mensagem de erro contendo "Você usou o tipo errado de variável aqui (literal)." e o percorredor.
Se a quantidade de caracteres deste type deste termo não for 4, apresente a mensagem de erro contendo "Você usou uma variável de comprimento errado (<>4)." e o percorredor.
Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "Faltou um 'para' depois da palavra 'aponte'. Você usou o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for "rotina", apresente a mensagem de erro contendo "Acho que faltou a palavra 'rotina'. Você usou o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile uma rotina reference usando o percorredor.
Converta a rotina reference para um cabeçalho expandido.
Destrua a rotina reference.
Encontre uma rotina usando o cabeçalho expandido e o catálogo geral de rotinas.
Se a rotina for inexistente, apresente a mensagem de erro contendo "Não achei a tarefa: " junto com o cabeçalho expandido seguido de "' que você falou." e o percorredor; exit.
Adicione um fragment usando a etiqueta de endereço de rotina e a rotina.
Atribua a variável deste termo à variável deste fragment.

Etapas necessárias para que se compile a próxima instrução usando um percorredor (privatize):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Comando 'privatize', Inválido. Eu acho que o termo da variável: " junto com a phrase deste termo seguido de "' está vazio." e o percorredor; exit.
Se a categoria deste termo não for "parâmetro", apresente a mensagem de erro contendo "Você só pode privatizar parâmetros." e o percorredor; exit.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste segmento inicial deste percorredor.
Atribua o nome deste termo ao nome deste local.
Atribua o nickname deste termo ao nickname deste local.
Atribua o type nome deste termo ao type nome deste local.
Resolva o local.
Anteponha "original " para o nome deste termo.
Se o nickname deste termo não estiver em branco, Anteponha "original " para o nickname deste termo.
Adicione several fragments usando "atribua" e a variável deste termo e "para" e o local e o first deste segmento inicial deste percorredor.
Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você vive esquecendo dos pontos né?." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile a próxima instrução usando um percorredor (push):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile um expression usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Comando 'push' inválido, um expressão: " junto com a phrase desta expression seguido de "' parece estar vazia." e o percorredor; exit.
Se o type desta expression não for value pushable, apresente a mensagem de erro contendo "Valores do tipo: " junto com o nome deste type desta expression seguido de "' não podem ser pushed." e o percorredor; exit.
Adicione um fragment usando o push value etiqueta e a variável desta expression.

Etapas necessárias para que se compile a próxima instrução usando um percorredor (repeat):
Adicione um fragment usando a etiqueta de repetição.
Mova o percorredor (usando diretrizes do compilador).

\Etapas necessárias para que se compile a próxima instrução usando um percorredor (say):
\Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (call - internal); exit.
\Mova o percorredor (usando diretrizes do compilador).
\Compile um expression usando o percorredor.
\Se o detector de erros deste compilador estiver ativado, cancele.
\Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "No es válido este 'diga', no entiendo la variável: " junto com a phrase desta expression seguido de "." e o percorredor; exit.
\Se o type desta expression não puder ser reduzido para "detector", apresente uma mensagem de erro contendo "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; exit.
\Adicione um fragment usando o load eax etiqueta e a variável desta expression.
\Adicione um segundo fragment usando o exit etiqueta.

Etapas necessárias para que se compile a próxima instrução usando um percorredor (say):
Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile a próxima instrução usando o percorredor (call - internal); exit.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de decider literal, apresente uma mensagem de erro contendo "Você precisa terminar com um yes ou no." e o percorredor; exit.
Desative um detector. Se o segmento inicial deste percorredor for algum tipo de positive decider literal, acione o detector.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Faltou um ponto. Você usou o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Adicione um fragment usando o load eax etiqueta e o detector.
Adicione um segundo fragment usando o exit etiqueta.

Etapas necessárias para que se compile a próxima instrução usando um percorredor devolvendo um termo (call - cláusula devolvendo):
Mova o percorredor (usando diretrizes do compilador).
Compile o termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Eu não compreendi o termo da variável: " junto com a phrase deste termo seguido de "'. Ela parece estar vazia." e o percorredor; exit.
Se o type deste termo não for value pushable, apresente a mensagem de erro contendo "Uma varíavel de 1, 2, ou 4 bytes é necessária na 'devolvendo' clause." e o percorredor.

Etapas necessárias para que se compile uma rotina reference usando um percorredor:
Se o segmento inicial deste percorredor for "para", mova o percorredor (usando diretrizes do compilador).
Se o percorredor for o start of algum tipo de function, compile a rotina reference usando o percorredor (função); exit.
Se o segmento inicial deste percorredor for algum tipo de decide, compile a rotina reference usando o percorredor (decide).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o segmento inicial deste percorredor for ".", cancele.
Se o segmento inicial deste percorredor for algum tipo de artigo definido, compile a rotina reference usando o percorredor (artigo definido); repita.
Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, compile a rotina reference usando o percorredor (artigo indefinido); repita.
Se o percorredor está sobre algum tipo de monikette string, compile a rotina reference usando o percorredor (monikette string); repita.
Apresente uma mensagem de erro contendo "'" junto com o segmento inicial deste percorredor seguido de "' não é válido em um employ statement." e o percorredor.

Etapas necessárias para que se compile uma rotina reference usando um percorredor (decide):
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de comando condicional, apresente uma mensagem de erro contendo "Sempre use DECIDE IF, ao invés de apenas DECIDE com: " junto com o segmento inicial deste percorredor seguido de "' logo em seguida." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile uma rotina reference usando um percorredor (artigo definido):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Anteponha "o " para o nome.
Adicione um monikette para a rotina reference usando o nome.

Etapas necessárias para que se compile uma rotina reference usando um percorredor (função):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um monikette para a rotina reference usando "atribua".
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, acione um detector.
Se o detector estiver ativo, compile a rotina reference usando o percorredor (artigo indefinido).
Se o detector não estiver ativo, compile a rotina reference usando o percorredor (artigo definido).
Se o segmento inicial deste percorredor não for algum tipo de possessive, apresente uma mensagem de erro contendo "Eu estava esperando un 's, mas apareceu: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Adicione uma segunda monikette para a rotina reference usando "'s " junto com o nome.
Se o segmento inicial deste percorredor não for "para", apresente a mensagem de erro contendo "E estava esperando a palavra 'para/into', mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Adicione um terceiro monikette para a rotina reference usando "para".
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Eu estava esperando um artigo indefinido mas encontrei isso: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Compile a rotina reference usando o percorredor (artigo indefinido).

Etapas necessárias para que se compile uma rotina reference usando um percorredor (artigo indefinido):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Encontre um type e um nickname usando o nome.
Se o type for inexistente, apresente uma mensagem de erro contendo "Employ statement inválido, Eu não sei o que é: " junto com o nome seguido de "." e o percorredor; exit.
Adicione um monikette para a rotina reference usando o type.

Etapas necessárias para que se compile uma rotina reference usando um percorredor (monikette string):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um monikette para a rotina reference usando o segmento inicial deste percorredor.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile um termo usando um percorredor:
Limpe o termo.
Se o detector de erros deste compilador estiver ativado, cancele.
Compile o termo usando o percorredor (common part).
Se o percorredor estiver sobre algum tipo de simile, cancele. \ added for invisible turtle project ***
\Se o segmento inicial deste percorredor for "as", compile o termo usando o percorredor (as part). \preposição
\Se o segmento inicial deste percorredor for "tão", compile o termo usando o percorredor (as part). \ me parece desnecessário por ser usado apenas em funções.
Se o segmento inicial deste percorredor for "quão", compile o termo usando o percorredor (as part).
Se o segmento inicial deste percorredor for "quanto", compile o termo usando o percorredor (as part).
Se o segmento inicial deste percorredor for "como", compile o termo usando o percorredor (as part).
\Se o segmento inicial deste percorredor for "que nem", compile o termo usando o percorredor (as part).
Se o segmento inicial deste percorredor for "/", compile o termo usando o percorredor (runtime ratio).

Etapas necessárias para que se compile um termo usando um percorredor (as part):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Comando 'as' inválido. Eu acho que um variável: " junto com a phrase deste termo seguido de "' está vaiza." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Tá faltando um artigo indefinido depois do 'como', mas você escreveu: " junto com o segmento inicial deste percorredor seguido de "' no lugar disso." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine um type nome usando o percorredor.
Encontre um type usando o type nome e o catálogo de tipos.
Se o type for inexistente, apresente a mensagem de erro contendo "Eu não sei em qual tipo o: " junto com o type nome seguido de "' se encaixa." e o percorredor; exit.
Adicione um scratch usando o nome deste type e o first deste segmento inicial deste percorredor.
Adicione um fragment usando o load endereço etiqueta e a variável deste termo e o scratch.
Atribua o scratch à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (common part):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor for o hífem, compile o termo usando o percorredor (negated termo); exit.
Se o segmento inicial deste percorredor for o sinal de adição, compile o termo usando o percorredor (posigated termo); exit.
Se o segmento inicial deste percorredor for o start of algum tipo de variável, compile o termo usando o percorredor (variável); exit.
Se o segmento inicial deste percorredor for o start of algum tipo de new local, compile o termo usando o percorredor (new local); exit.
Se o segmento inicial deste percorredor for algum tipo de literal, compile o termo usando o percorredor (literal); exit.
Apresente uma mensagem de erro contendo "Faltou um termo por aqui. Só achei isso aqui: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor.

Etapas necessárias para que se compile um termo usando um percorredor (dereference - em place):
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro interno na função - compile um termo usando um percorredor (dereference - em place). Termo vazio" e o percorredor; exit.
Atribua o nome deste conteúdo type deste type deste termo ao type nome deste termo.
Atribua o conteúdo type deste type deste termo ao type deste termo.
Adicione um fragment usando o dereference etiqueta e a variável deste termo.
Limpe o phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (dereference):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Dereference inválido, um variável: " junto com a phrase deste termo seguido de "' parece estar vazia." e o percorredor; exit.
Se o conteúdo type deste type deste termo for inexistente, apresente a mensagem de erro contendo "Não consegui identificar o tipo desse conteúdo." e o percorredor; exit.
Se a categoria deste termo for "scratch", compile o termo usando o percorredor (dereference - em place); exit.
Adicione um scratch usando o nome deste conteúdo type deste type deste termo e o first deste segmento inicial deste percorredor.
Adicione um fragment usando o load endereço etiqueta e a variável deste termo e o scratch.
Adicione um segundo fragment usando o dereference etiqueta e o scratch.
Atribua o scratch à variável deste termo.
Limpe o phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (literal):
Se o detector de erros deste compilador estiver ativado, cancele.
Compile um literal usando o percorredor.
Atribua o literal à variável deste termo.
Limpe o phrase deste termo.
Compile o termo usando o percorredor (possessives).

Etapas necessárias para que se compile um termo usando um percorredor (negated termo):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile uma segunda termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta segunda termo for inexistente, apresente uma mensagem de erro contendo "Negate inválido, um variável: " junto com o phrase desta segunda termo seguido de "' parece estar vazia." e o percorredor; exit.
Adicione um intermediate usando o type nome desta segunda termo e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "atribua" e a variável desta segunda termo e "para" e o intermediate e o local de aparição desta segunda termo.
Adicione two fragments usando "negate" e o intermediate e o first deste segmento inicial deste percorredor.
Atribua o intermediate à variável deste termo.
Limpe o phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (new local):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e o percorredor; exit.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste segmento inicial deste percorredor.
\PAL
Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste local.
Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste local.
Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste local.
Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste local.
\CAL
Se o segmento inicial deste percorredor for "another", atribua "segunda" ao nome deste local.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Extend o nome deste local com o nome.
Se o segmento inicial deste percorredor for algum tipo de called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente a mensagem de erro contendo "o parâmetro: " junto com o nome deste local seguido de "' já está sendo usado como parâmetro." e o local de aparição deste local; exit.
Se o local estiver duplicada em os locals desta rotina utilizada atualmente, apresente a mensagem de erro contendo "Já existe uma variável local chamada'" junto com o nome deste local seguido de "'. Você tem que dar um nome diferente." e o local de aparição deste local; exit.
Eliminate duplicate nicknames usando o local e o nickname catálogo desta rotina utilizada atualmente.
Atribua o local à variável deste termo.
Limpe a phrase deste termo.
Compile o termo usando o percorredor (possessives).

Etapas necessárias para que se compile um termo usando um percorredor (posigated termo):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile o termo usando o percorredor.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Posigate inválido, o termo da variável'" junto com a phrase deste termo seguido de "' parece estar vazio." e o percorredor; exit.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (possessivo - magnitude):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Use da magnitude inválido. A variável: " junto com a phrase deste termo seguido de "' parece estar vazia." e o percorredor; exit.
Adicione um literal para os literals usando o first deste segmento inicial deste percorredor.
Converta a quantidade de caracteres deste type deste termo para os data deste literal.
Atribua "número" ao type nome deste literal.
Resolva o literal.
Atribua o literal à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (possessivo - conteúdo):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou o termo 'conteúdo' de forma errada. O termo da variável: " junto com a phrase deste termo seguido de "' parece estar em branco ou não foi devidamente definido." e o percorredor; exit.
Se o type deste termo não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Você só pode usar a palavra 'conteúdo' com valores do tipo 'endereço de memória'." e o percorredor; exit.
Compile o termo usando o percorredor (dereference).

Etapas necessárias para que se compile um termo usando um percorredor (possessivo - endereçamento):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou endereçamento da forma errada, erro no termo da variável: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando "endereço de memória" e o first deste segmento inicial deste percorredor.
Adicione um fragment usando o load endereço etiqueta e a variável deste termo e o intermediate.
Atribua o intermediate à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (possessive):
\ similar a "compile um termo usando um percorredor (possessivo reverso)
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o nome for algum tipo de magnitude, compile o termo usando o percorredor (possessivo - magnitude); exit.
Se o nome for algum tipo de conteúdo, compile o termo usando o percorredor (possessivo - conteúdo); exit.
Se o nome for algum tipo de endereçamento, compile o termo usando o percorredor (possessivo - endereçamento); exit.
Compile o termo usando o percorredor e o nome (possessive - campo).

Etapas necessárias para que se compile um termo usando um percorredor (possessives):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor não for algum tipo de possessive, cancele.
Compile o termo usando o percorredor (possessive).
Repita.

Etapas necessárias para que se compile um termo usando um percorredor (runtime ratio):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile uma segunda termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta segunda termo for inexistente, apresente a mensagem de erro contendo "Uso inválido da /, termo vazio da variável: " junto com o phrase desta segunda termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando "ratio" e o first deste segmento inicial deste percorredor.
Adicione several fragments usando "atribua" e a variável deste termo e "e" e a variável desta segunda termo e "para" e o intermediate e o first deste segmento inicial deste percorredor.
Atribua o intermediate à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (variável):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Erro de tarefa vazia, nada pra pull da pilha aqui." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o percorredor estiver sobre algum tipo de reverse-possessive, compile o termo usando o percorredor e o nome (possessivo reverso); exit.
Encontre uma variável usando o nome.
Atribua a variável à variável deste termo.
Atribua "o " à phrase deste termo.
Posponha o nome para a phrase deste termo.
Compile o termo usando o percorredor (possessives).

Etapas necessárias para que se compile um termo usando um percorredor e um campo nome (possessivo reverso):
\ função recursiva
\ dahn version 2
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador). \ past o reverse-possessive starter
\Se o segmento inicial deste percorredor não for "del", mova o percorredor (usando diretrizes do compilador). \ past o reverse-possessive starter \ gerry added "if" part
Se o segmento inicial deste percorredor não for algum tipo de artigo, apresente uma mensagem de erro contendo "O compilador esperava encontrar un artigo, mas encontrou: " junto com o segmento inicial deste percorredor seguido de "."; exit.
Atribua o segmento inicial deste percorredor para um article segmento inicial.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o percorredor está sobre algum tipo de reverse-possessive, acione um reverse-possessive detector.
Se o reverse-possessive detector estiver ativo, compile o termo usando o percorredor e o nome (possessivo reverso).
Se o reverse-possessive detector não estiver ativo, compile o termo usando o percorredor e o nome e o article (reversão de contrações do possessivo).
Compile o termo usando o campo nome e o percorredor (possessivo reverso).

Etapas necessárias para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações do possessivo):
\ dahn version 2
Se o article for o start of algum tipo de variável, compile o termo usando o percorredor e a variável nome e o article (reversão de contrações de variáveis do possessivo); exit.
Compile o termo usando o percorredor e a variável nome (decomposição do possessivo reverso - variável local).

Etapas necessárias para que se compile um termo usando um percorredor e uma variável nome e um article segmento inicial (reversão de contrações de variáveis do possessivo):
\ dahn version 2
Encontre uma variável usando a variável nome.
Se a variável for inexistente, apresente uma mensagem de erro contendo "Não foi possível encontrar uma variável com o nome: " junto com a variável nome seguido de ".".
Atribua a variável à variável deste termo.
Atribua "o " à phrase deste termo.
Posponha a variável nome para a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor e uma variável nome (decomposição do possessivo reverso - variável local):
\ dahn version 2
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste segmento inicial deste percorredor.
\PAL
Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste local.
Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste local.
Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste local.
Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste local.
\CAL
\Se o segmento inicial deste percorredor for "another", atribua "segunda" ao nome deste local.
Extend o nome deste local com a variável nome.
Se o segmento inicial deste percorredor for algum tipo de called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente uma mensagem de erro contendo "O termo: " junto com o nome deste local seguido de "' já está sendo usado como parâmetro." e o local de aparição deste local; exit.
Se o local estiver duplicada em os locals desta rotina utilizada atualmente, apresente a mensagem de erro contendo "O termo: " junto com o nome deste local seguido de "' já está sendo usado coma variável local." e o local de aparição deste local; exit.
Eliminate duplicate nicknames usando o local e o nickname catálogo desta rotina utilizada atualmente.
Atribua o local à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um campo nome e um percorredor (possessivo reverso):
\ similar para "compile um termo usando um percorredor (possessive)" \ dahn
Se o detector de erros deste compilador estiver ativado, cancele.
Se o campo nome for algum tipo de magnitude, compile o termo usando o percorredor (possessivo - magnitude); exit.
Se o campo nome for algum tipo de conteúdo, compile o termo usando o percorredor (possessivo - conteúdo); exit.
Se o campo nome for algum tipo de endereçamento, compile o termo usando o percorredor (possessivo - endereçamento); exit.
Compile o termo usando o percorredor e o campo nome (possessive - campo).

Etapas necessárias para que se compile um termo usando um percorredor e um campo termo:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o dereference detector deste campo termo estiver ativo, compile o termo usando o percorredor (dereference).
Se o function deste campo termo não for inexistente, compile o termo usando o percorredor e o campo termo (função); exit.
Se a categoria deste termo for "scratch", compile o termo usando o percorredor e o campo termo (in place); exit.
Atribua o campo deste campo termo para um campo.
Adicione um scratch usando o nome deste type deste campo e o first deste segmento inicial deste percorredor.
Adicione um fragment usando o load endereço etiqueta e a variável deste termo e o scratch.
Se o offset deste campo não for 0, adicione um terceiro fragment usando a etiqueta de acréscimo e o scratch e o offset deste campo.
Atribua o scratch à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor e um campo termo (função):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o function deste campo termo para uma rotina.
Atribua o last destes parâmetros desta rotina para um parâmetro.
Se o parâmetro for inexistente, apresente uma mensagem de erro contendo "Erro interno na função compile um termo usando um percorredor e um campo termo (função) - parâmetro vazio." e o percorredor; exit.
Se o type deste parâmetro for inexistente, apresente a mensagem de erro contendo "Erro interno 2 na função compile um termo usando um percorredor e um campo termo (função) - tipo do parâmetro inexistente." e o percorredor; exit.
Adicione um intermediate usando o nome deste type deste parâmetro e o first deste segmento inicial deste percorredor.
Adicione um fragment usando o push endereço etiqueta e o intermediate.
Se o push detector deste campo termo estiver ativo, adicione um segundo fragment usando o push endereço etiqueta e a variável deste termo.
Adicione um terceiro fragment usando a etiqueta de demanda interna e a rotina.
Atribua o intermediate à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor e um campo termo (in place):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o campo deste campo termo para um campo.
Atribua o nome deste type deste campo ao type nome deste termo.
Atribua o type deste campo ao type deste termo.
Se o offset deste campo não for 0, adicione um terceiro fragment usando a etiqueta de acréscimo e a variável deste termo e o offset deste campo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor e um nome (possessive - campo):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo não for inexistente, atribua o type deste termo para um type.
Encontre um campo termo usando o phrase deste termo e o type e o nome.
Se o campo termo não for vazio, compile o termo usando o percorredor e o campo termo; exit.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro: variável vazia: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Se o type puder ser reduzido para "endereço de memória", atribua o conteúdo type deste type ao type.
Se o type for inexistente, apresente a mensagem de erro contendo "Não existe o campo: " junto com o nome seguido de "' no tipo: " junto com o nome deste type deste termo seguido de "." e o percorredor; exit.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo desde os campos deste type.
Se o campo for inexistente, apresente a mensagem de erro contendo "Não há nenhum campo: " junto com o nome seguido de "' no tipo: " junto com o nome deste type deste termo seguido de "." e o percorredor; exit.
Encontre um deep campo termo usando "" e o type deste campo e o nome.
Se o deep campo termo estiver vazio, repita.
Atribua o campo para o campo desse first campo termo.
Se o type deste termo puder ser reduzido para "endereço de memória", acione o dereference detector deste first campo termo.
Compile o termo usando o percorredor e o first campo termo.
Compile o termo usando o percorredor e o deep campo termo.



Etapas necessárias para que se converta uns monikettes para um cabeçalho expandido:
Converta os monikettes para o cabeçalho expandido usando o last destes monikettes.

Etapas necessárias para que se converta uns monikettes para um cabeçalho expandido usando um monikette:
Limpe o cabeçalho expandido.
Percorra.
Obtenha um current monikette desde os monikettes.
Se o current monikette for inexistente, cancele.
Posponha o current monikette para o cabeçalho expandido.
Se o current monikette for o monikette, cancele.
Repita.

Etapas necessárias para que se converta uma parte da cifra binária para uma string:
Employ converta um cifra hexadecimal para um texto hexadecimal.

Etapas necessárias para que se converta um termo por concatenation usando um percorredor: \\ concatenação
\ used for right-side seguido de operand
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro: a variável do termo está vazia: " junto com a phrase deste termo seguido de "." e o percorredor; exit.
Se o type deste termo puder ser reduzido para "string", cancele.
Se o type deste termo puder ser reduzido para "texto", cancele.
Adicione um intermediate usando "string" e o first deste segmento inicial deste percorredor.
\Adicione um intermediate usando "texto" e o first deste segmento inicial deste percorredor.
Adicione o atribua ou converta fragments usando a variável deste termo e o intermediate e o first deste segmento inicial deste percorredor.
Atribua o intermediate à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se copie um campo para um segundo campo:
Se o campo for inexistente, esvazie o segundo campo; exit.
Aloque memória para o segundo campo.
Atribua o local de aparição deste campo ao local de aparição deste segundo campo.
Atribua o nome deste campo ao nome deste segundo campo.
Atribua o nickname deste campo ao nickname deste segundo campo.
Atribua o type nome deste campo ao type nome deste segundo campo.
Atribua o type deste campo ao type deste segundo campo.
Atribua a contagem deste campo à contagem deste segundo campo.
Atribua o redefinition conteúdo nome deste campo ao redefinition conteúdo nome deste segundo campo.
Atribua o reference detector deste campo ao reference detector deste segundo campo.
Atribua o offset deste campo ao offset deste segundo campo.

Etapas necessárias para que se copie uns campos para uns segundo campos:
Obtenha um campo desde o campos.
Se o campo for inexistente, cancele.
Copie o campo para um segundo campo.
Posponha o segundo campo para a segundo campos.
Repita.

Etapas necessárias para que se copie uns campos para uns segundo campos (data campos only):
Se a contagem destes campos for menor do que 4, cancele. \ for english next e prev e spanish next e prev redefinitions
\Se o first destes campos for inexistente, cancele.
\Se o next deste first destes campos for inexistente, cancele.
\Se o next deste next deste first destes campos for inexistente, cancele.
\\Atribua o next deste next deste first destes campos para um campo. \ skip next e prev
\Se o next deste next deste next deste first destes campos for inexistente, cancele.
\Se o next deste next deste next deste next deste first destes campos for inexistente, cancele.
\Se o next deste next deste next deste next deste next deste first destes campos for inexistente, cancele.
\Atribua o next deste next deste next deste next deste first destes campos para um campo.
Atribua o next deste next deste next deste next deste first destes campos para um campo.\ english next e prev e spanish next e prev redefinitions
Percorra.
Se o campo for inexistente, cancele.
Copie o campo para um segundo campo.
Posponha o segundo campo para a segundo campos.
Obtenha o campo desde o campos.
Repita.

Etapas necessárias para que se copie um monikette para uma segunda monikette:
Se o monikette for inexistente, esvazie a segunda monikette; exit.
Aloque memória para o segunda monikette.
Atribua a string deste monikette à string desta segunda monikette.
Atribua o type deste monikette ao type desta segunda monikette.
Atribua a variável deste monikette à variável desta segunda monikette.
\ don't copia subtexto
Atribua o type atual deste monikette ao type atual desta segunda monikette.

Etapas necessárias para que se copie uns monikettes para uns segunda monikettes:
Destrua a segunda monikettes.
Percorra.
Obtenha um monikette desde os monikettes.
Se o monikette for inexistente, cancele.
Copie o monikette para uma segunda monikette.
Posponha a segunda monikette para a segunda monikettes.
Repita.

Etapas necessárias para que se crie um entry:
Aloque memória para o entry.

Etapas necessárias para que se crie um fragment usando uma etiqueta:
Aloque memória para o fragment.
Atribua a etiqueta à etiqueta deste fragment.

Etapas necessárias para que se crie um import:
Aloque memória para o import.

Etapas necessárias para que se crie um monikette:
Aloque memória para o monikette.

Etapas necessárias para que se crie uma rotina:
Aloque memória para a rotina.

Etapas necessárias para que se crie um source file:
Aloque memória para o source file.

Etapas necessárias para que se crie um type:
Aloque memória para o type.
Atribua 0/1 ao scale deste type.
Atribua -1 ao quantidade de caracteres deste type.

Etapas necessárias para que se crie uma variável usando um categoria:
Aloque memória para a variável.
Atribua o categoria à categoria desta variável.
Atribua 1 à contagem desta variável.

O endereço do cabeçalho usado atualmente é um endereço.

O endereço do nome usado atualmente é um endereço.

O rotina utilizada atualmente é uma rotina.

O current previamente calculado endereço é um endereço.

O zona de dados é um zona.

Etapas necessárias para que se determine se alguns of uns monikettes são negative palavras:
Obtenha um monikette desde os monikettes.
Se o monikette for inexistente, diga não.
Se a string deste monikette for algum tipo de advérbio de negação, diga sim.
Repita.

Etapas necessárias para que se determine se um pedaço é algum tipo de glom pedaço:
Se o pedaço for algum tipo de letra, diga sim.
Se o pedaço for algum tipo de digit, diga sim.
Se o pedaço for o acento til, diga sim.
Se o pedaço for o sinal de arroba, diga sim.
Se o pedaço for o símbolo cardinal, diga sim.
Se o pedaço for o sinal de porcentagem, diga sim.
Se o pedaço for o & comercial, diga sim.
Se o pedaço for o underline, diga sim.
Se o pedaço for o single-quote pedaço, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Se o pedaço for o símbolo da Libra Esterlina, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de mark:
Se o pedaço for o ponto final, diga sim.
Se o pedaço for o vírgula, diga sim.
Se o pedaço for o ponto&vírgula, diga sim.
Se o pedaço for o sinal de dois pontos, diga sim.
Se o pedaço for o ponto de exclamação, diga sim.
Se o pedaço for o ponto de interrogação, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de stressed vogal:
Se o pedaço estiver em "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
Diga não.

Etapas necessárias para que se determine se um pedaço é algum tipo de symbol: \ deveria estar no cérebro
Se o pedaço for o acento circumflexo, diga sim.
Se o pedaço for o barra vertical, diga sim.
Se o pedaço for o asterisco, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Se o pedaço for o símbolo menor do que, diga sim.
Se o pedaço for o símbolo maior do que, diga sim.
Se o pedaço for a chave esquerda, diga sim.
Se o pedaço for a chave direita, diga sim.
Se o pedaço for o sinal de igualdade, diga sim.
Se o pedaço for 128, diga sim.
Se o pedaço for 130, diga sim.
Se o pedaço estiver entre 132 e 137, diga sim.
Se o pedaço for 139, diga sim.
Se o pedaço estiver entre 145 e 153, diga sim.
Se o pedaço for 155, diga sim.
Se o pedaço estiver entre 161 e 180, diga sim.
Se o pedaço estiver entre 183 e 191, diga sim.
Se o pedaço for 215, diga sim.
Se o pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um campo termo está vazia;
Etapas necessárias para que se determine se um campo termo estão vazias;
Etapas necessárias para que se determine se um campo termo estão vazios;
Etapas necessárias para que se determine se um campo termo está vazio:
Se o campo deste campo termo não for inexistente, diga não.
Se a function deste campo termo não for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se uns campos deveriam ser finalizados;
Etapas necessárias para que se determine se uns campos deveria ser finalizado:
Obtenha um campo desde o campos.
Se o campo for inexistente, diga não.
Se o type deste campo deveria ser finalizado, diga sim.
Repita.

Etapas necessárias para que se determine se um item parece ser encadernável:
Carregue o endereço completo deste item para um trecho.
Se o trecho começa com "ream cal", diga sim.
Se o trecho começa com "Documento produzido pelo Editor de Documentos", diga sim.
Diga não.

Etapas necessárias para que se determine se um cabeçalho expandido está em um catálogo:
Encontre um refer usando o cabeçalho expandido e o catálogo.
Se o refer for inexistente, diga não.
Se o endereço de memória deste refer for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se o monikette for inexistente, diga sim.
Se o type atual deste monikette não for inexistente, diga não.
Se o subtexto atual deste monikette não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um nome é algum tipo de magnitude:
\PAL
Se o nome for "magnitude", diga sim.
\ a magnitude retorna o tamanho em bytes de algo
\ Exemplo: a magnitude dessa string
Diga não.

Etapas necessárias para que se determine se um nome é algum tipo de conteúdo:
\PAL
Se o nome for "conteúdo", diga sim.
\Se o nome for "alvo", diga sim.
\CAL
Se o nome for "target", diga sim.
\Este comando é usado apenas com ponteiros (endereços de memória). 
\ Serve pra saber para quais valores o ponteiro está apontando, ou seja, o conteúdo do endereço de memória . 
\"Um ponteiro de byte" ou "endereço de memória do byte", por exemplo, refere-se ao endereço de um byte. 
\"O conteúdo deste endereço de memória do byte" refere-se, portanto aos dados no byte
Diga não.

Etapas necessárias para que se determine se um nome é algum tipo de endereçamento:
\PAL
\Se o nome for "paradeiro", diga sim.
Se o nome for "endereçamento", diga sim.
\ retorna o endereço do dado
\CAL
Se o nome for "whereabouts", diga sim.
Diga não.

Etapas necessárias para que se determine se um nome é algum tipo de valid campo nome:
Se o nome for algum tipo de magnitude, diga não.
Se o nome for algum tipo de conteúdo, diga não.
Se o nome for algum tipo de endereçamento, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está acompanhado por algum tipo de unidade de medida:
Isole o percorredor.
Mova o percorredor (usando diretrizes do compilador).
Se o percorredor não estiver sobre algum tipo de nome starter, diga não.
Examine um nome usando o percorredor.
Encontre um type usando o nome e o catálogo de tipos.
Se o type for inexistente, diga não.
Se o nome não for "times", diga sim. \ special because times é um infix operator e um unidade de medida
\Se o nome não for "vezes", diga sim.
Se o segmento inicial deste percorredor for o start of algum tipo de expression, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de nested double-quote:
Se o segmento final deste percorredor começa com """""", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de possessive:
Se o segmento final deste percorredor estiver em branco, diga não.
Se o conteúdo deste first deste segmento final deste percorredor não for o single-quote pedaço, diga não.
Se o percorredor estiver sobre algum tipo de possessive (type 1 - single-quote, s, non-glom-byte), diga sim.
Se o percorredor estiver sobre algum tipo de possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de possessive (type 1 - single-quote, s, non-glom-byte):
Se o segmento final deste percorredor não começa com "'s", diga não.
Isole o percorredor.
Adicione 2 para o first deste segmento final deste percorredor.
Se o segmento final deste percorredor estiver em branco, diga sim.
Se o conteúdo deste first deste segmento final deste percorredor não for algum tipo de glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de possessive (type 2 - preceding s, single-quote, non-glom-byte):
Isole o percorredor.
Se o first deste segmento final deste percorredor for o first endereço de memória do pedaço deste subtexto original deste percorredor, diga não.
Subtraia 1 desde o first deste segmento final deste percorredor.
Se o conteúdo deste first deste segmento final deste percorredor não for o s minúsculo ou o S maiúsculo, diga não.
Adicione 2 para o first deste segmento final deste percorredor.
Se o segmento final deste percorredor estiver em branco, diga sim.
Se o conteúdo deste first deste segmento final deste percorredor não for algum tipo de glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de simile:
\ added for invisible turtle project ***
Isole o percorredor.
Se o segmento inicial deste percorredor for "like", diga sim.
Se o segmento inicial deste percorredor não for "as", diga não.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor é o start of algum tipo de function:
Se o detector de erros deste compilador estiver ativado, diga não.
Se o segmento inicial deste percorredor for "Ponha", diga sim.
\Se o segmento inicial deste percorredor não for algum tipo de atribua, diga não.
Se o segmento inicial deste percorredor não for "atribua", diga não.
Isole o percorredor.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo, diga não.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o segmento inicial deste percorredor for algum tipo de possessive, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é alguma espécie de contração usando uma segunda string (portuguese rules - "no"):
Se a string não for "no", diga não.
Se a segunda string for "say", diga não.
Se a segunda string for "diga", diga não.
\Se a segunda string for "dizer", diga não.
Diga sim.

Etapas necessárias para que se determine se uma string termina com alguma consoante e uma segunda string:
Lance um subtexto sobre a string.
Subtraia a quantidade de caracteres desta segunda string desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o conteúdo deste last endereço de memória do pedaço deste subtexto não for alguma consoante, diga não.
Se a string não termina com a segunda string, diga não.
Diga sim.

Etapas necessárias para que se determine se uma string termina com algum tipo de vogal e uma segunda string:
Lance um subtexto sobre a string.
Subtraia a quantidade de caracteres desta segunda string desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o conteúdo deste last endereço de memória do pedaço deste subtexto não for algum tipo de vogal, diga não.
Se a string não termina com a segunda string, diga não.
Diga sim.

Etapas necessárias para que se determine se uma string termina com alguma consoante:
Se a string estiver em branco, diga não.
Se o conteúdo deste last endereço de memória do pedaço desta string não for alguma consoante, diga não.
Diga sim.

Etapas necessárias para que se determine se uma string termina com algum tipo de vogal:
Se a string estiver em branco, diga não.
Se o conteúdo deste last endereço de memória do pedaço desta string não for algum tipo de vogal, diga não.
Diga sim.

Etapas necessárias para que se determine se uma string é algum operator de adição:
\PAL
Se a string for "mais", diga sim.
\CAL
Se a string for "plus", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de atribua:
\PAL
Se a string for "pôr", diga sim.
\# Não precisa porque está como sinônimo, ver a rotina abaixo: 
\"Etapas necessárias para que se posponha uma string para uma segunda string usando um terceiro string (para expandir contrações)"
\Se a string for "colocar", diga sim.
\CAL
Se a string for "atribua", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum operator de subtração:
\PAL
Se a string for "menos", diga sim.
\CAL
Se a string for "minus", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum operator de multiplicação:
\PAL
Se a string for "vezes", diga sim.
\CAL
Se a string for "times", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum operator de divisão:
\PAL
Se a string for "dividido", diga sim.
\CAL
Se a string for "divided", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum objeto indireto:
\PAL
Se a string for "via", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se a string for "por", diga sim.
\CAL
Se a string for "by", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de palavra de concatenação:
\PAL
Se a string for "com", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se a string for "de", diga sim.
Se a string for "a", diga sim.
Se a string for "seguida", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de operador de concatenação:
\PAL
\# operador de concatenação de strings tipo: "abc" junto com "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida".
Se a string for "junto", diga sim. \ junto do/da, junto com o ...
Se a string for "juntamente", diga sim. \ juntamente com o...
Se a string for "seguido", diga sim. \ seguido do ....
Se a string for "acompanhado", diga sim. \ acompanhado de... 

Se a string for "em", diga sim.
\Se a string for "&", diga sim.
\CAL
Se a string for "then", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de operador de atribuição de estruturas compostas:
\PAL
Se a string for "tem", diga sim.
\CAL
Se a string for "has", diga sim.
Se a string for "have", diga sim.
\Se a string for "possui", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de operador de atribuição simples:
\PAL
Se a string for "é", diga sim.
Se a string for "está", diga sim.
Se a string for "são", diga sim.
Se a string for "estão", diga sim.
Se a string for "for", diga sim.
Se a string for "forem", diga sim.
Se a string for "estiverem", diga sim.
Se a string for "estarem", diga sim.
Se a string for "possui", diga sim.
\Se a string for "tem", diga sim.
\CAL
Se a string for "is", diga sim.
Se a string for "are", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de operador de atribuição composto:
\PAL
Se a string for "igual", diga sim.
\CAL
Se a string for "equal", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de com:
\PAL
Se a string for "com", diga sim.
Se a string for "contendo", diga sim.
Se a string for "que tem", diga sim.
Se a string for "que têm", diga sim.
Se a string for "que possui", diga sim.
Se a string for "que possuem", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de artigo:
Se a string for algum tipo de artigo indefinido, diga sim.
Se a string for algum tipo de artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se a string for "e", diga sim.
Se a string for "ou", diga sim.
Se a string for "nem", diga sim.
\CAL
Se a string for "and", diga sim.
Se a string for "both", diga sim.
Se a string for "but", diga sim.
Se a string for "either", diga sim.
Se a string for "neither", diga sim.
Se a string for "nor", diga sim.
Se a string for "or", diga sim.
Diga não.

\Etapas necessárias para que se determine se uma string é algum tipo de detector literal:
\Se a string for "yes", diga sim.
\Se a string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de to:
\PAL
Se a string for "a", diga sim. \ this é questionable
\CAL
Se a string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de and:
\PAL
Se a string for "e", diga sim.
\CAL
Se a string for "and", diga sim.
Diga não. \repetido?

Etapas necessárias para que se determine se uma string é algum tipo de reverse-possessive function into:
\PAL
Se a string for "em", diga sim.
Se a string for "para", diga sim.
\CAL
Se a string for "into", diga sim.
Diga não.

\Etapas necessárias para que se determine se uma string é algum tipo de detector literal:
\Se a string for "si", diga sim.
\Se a string for "yes", diga sim.
\Se a string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de decider literal:
\PAL
Se a string for "sim", diga sim.
Se a string for "positivo", diga sim.
Se a string for "positivamente", diga sim.
Se a string for "afirmativamente", diga sim.
Se a string for "não", diga sim.
Se a string for "negativo", diga sim.
Se a string for "negativamente", diga sim.
\CAL
Se a string for "yes", diga sim.
\Se a string for "yep", diga sim.
\Se a string for "yea", diga sim.
Se a string for "no", diga sim.
\Se a string for "nay", diga sim.
\Se a string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de positive decider literal:
\PAL
Se a string for "sim", diga sim.
Se a string for "positivo", diga sim.
Se a string for "positivamente", diga sim.
Se a string for "afirmativamente", diga sim.
\CAL
Se a string for "yes", diga sim.
\Se a string for "yep", diga sim.
\Se a string for "yea", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de negative decider literal:
\PAL
Se a string for "não", diga sim.
Se a string for "negativo", diga sim.
Se a string for "negativamente", diga sim.
\CAL
Se a string for "no", diga sim.
\Se a string for "nay", diga sim.
\Se a string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de hex literal:
Se a string estiver em branco, diga não.
Se o conteúdo deste first endereço de memória do pedaço desta string for o cifrão, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de artigo definido:
\PAL
Se a string for "o", diga sim.
Se a string for "a", diga sim.
Se a string for "os", diga sim.
Se a string for "as", diga sim.
Se a string for algum tipo de pronome demonstrativo adjacente, diga sim.
\CAL
Se a string for "the", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de pronome demonstrativo:
\CEL
Se a string for algum tipo de pronome demonstrativo adjacente, diga sim.
Se a string for algum tipo de pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de pronome demonstrativo adjacente:
\CEL
Se a string for "este", diga sim.
Se a string for "esta", diga sim.
Se a string for "estes", diga sim.
Se a string for "estas", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de pronome demonstrativo abrangente:
\CEL
Se a string for "esse", diga sim.
Se a string for "essa", diga sim.
Se a string for "aquele", diga sim.
Se a string for "aquela", diga sim.
Se a string for "esses", diga sim.
Se a string for "essas", diga sim.
Se a string for "aqueles", diga sim.
Se a string for "aquelas", diga sim.
Se a string for "certo", diga sim.
Se a string for "certa", diga sim.
Se a string for "certos", diga sim.
Se a string for "certas", diga sim.
Se a string for "determinado", diga sim.
Se a string for "determinada", diga sim.
Se a string for "determinados", diga sim.
Se a string for "determinadas", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de artigo definido:
Se o percorredor estiver sobre algum tipo de preposição conectiva, diga não.
Se o segmento inicial deste percorredor não for algum tipo de artigo definido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de artigo indefinido:
Se o percorredor estiver sobre algum tipo de preposição conectiva, diga não.
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de preposição conectiva:
Se o segmento inicial deste percorredor não for "a", diga não.
Isole o percorredor. Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for algum tipo de artigo, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de artigo indefinido: \ esse aqui parece que não serve pra muita coisa
\PAL
Se a string for algum tipo de artigo indefinido português, diga sim.
Se a string for algum tipo de pronome demonstrativo abrangente, diga sim.
\CAL
Se a string for algum tipo de artigo indefinido inglês, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de artigo indefinido inglês:
\CAL
Se a string for "an", diga sim.
Se a string for "another", diga sim.
Se a string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de artigo indefinido português: \ é aqui que se deve colocar o possessivo. descobri.
\PAL
Se a string for "um", diga sim.
Se a string for "uma", diga sim.
Se a string for "uns", diga sim.
Se a string for "umas", diga sim.
\Se a string for "outro", diga sim.
\Se a string for "outra", diga sim.
\Se a string for "algum", diga sim.
\Se a string for "alguma", diga sim.
\Se a string for "alguns", diga sim.
\Se a string for "algumas", diga sim.
Se a string for algum tipo de pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de literal:
Se a string for algum tipo de endereço de memória literal, diga sim.
Se a string for algum tipo de numeric literal, diga sim.
Se a string for algum tipo de string literal, diga sim.
\Se a string for algum tipo de detector literal, diga sim. ***
Se a string for algum tipo de hex literal, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de mark:
Se a quantidade de caracteres desta string não for 1, diga não.
Se o conteúdo deste first endereço de memória do pedaço desta string for algum tipo de mark, diga sim.
Diga não.

\Etapas necessárias para que se determine se uma string é algum tipo de monikette string:
\Se a string estiver em branco, diga não.
\Se a string for "the", diga não.
\Se a string é algum tipo de artigo indefinido, diga não.
\Se a string é algum tipo de possessive, diga não.
\Se a string é algum tipo de literal, diga não.
\Se a string é algum tipo de mark, diga não.
\Se a string é algum tipo de symbol, diga não.
\Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de monikette string:
Se o segmento inicial deste percorredor estiver em branco, diga não.
Se o percorredor estiver sobre algum tipo de artigo definido, diga não.
Se o percorredor estiver sobre algum tipo de artigo indefinido, diga não.
Se o segmento inicial deste percorredor for algum tipo de possessive, diga não.
Se o segmento inicial deste percorredor for algum tipo de literal, diga não.
Se o segmento inicial deste percorredor for algum tipo de mark, diga não.
Se o segmento inicial deste percorredor for algum tipo de symbol, diga não.
Diga sim.

Etapas necessárias para que se determine se uma string é algum tipo de called:
\PAL
Se a string for "chamado", diga sim.
Se a string for "chamada", diga sim.
Se a string for "denominado", diga sim.
Se a string for "denominada", diga sim.
Se a string for "chamados", diga sim.
Se a string for "chamadas", diga sim.
Se a string for "denominados", diga sim.
Se a string for "denominadas", diga sim.
\Se a string for "conhecido como", diga sim.
\Se a string for "conhecida como", diga sim.
\CAL
Se a string for "called", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de reference:
\PAL
Se a string for "(referência)", diga sim.
\CAL
Se a string for "(reference)", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de nome ender:
\ compare com nome starter
Se o segmento inicial deste percorredor for algum tipo de mark, diga sim.
Se o segmento inicial deste percorredor for algum tipo de symbol, diga sim.
Se o segmento inicial deste percorredor for algum tipo de artigo, diga sim.
Se o segmento inicial deste percorredor for algum tipo de conjunction, diga sim.
Se o segmento inicial deste percorredor for algum tipo de possessive, diga sim.
Se o percorredor estiver sobre algum tipo de reverse-possessive, diga sim.
Se o segmento inicial deste percorredor for algum tipo de verb, diga sim.
Se o segmento inicial deste percorredor for algum operator aritmético, diga sim.
Se o percorredor estiver sobre algum tipo de preposition, diga sim.
Se o segmento inicial deste percorredor for algum tipo de qualifier, diga sim.
Se o segmento inicial deste percorredor for algum tipo de literal, diga sim.
Se o segmento inicial deste percorredor for algum tipo de called, diga sim.
\Se o segmento inicial deste percorredor for "equal", diga sim.
Se o segmento inicial deste percorredor for algum tipo de operador de atribuição composto, diga sim.
Se o segmento inicial deste percorredor estiver em branco, diga sim.
\ Portuguese trouble makers
Se o segmento inicial deste percorredor for algum tipo de advérbio de negação, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de nome starter:
\ compare com nome ender
Se o segmento inicial deste percorredor for algum tipo de mark, diga não.
Se o segmento inicial deste percorredor for algum tipo de symbol, diga não.
Se o segmento inicial deste percorredor for algum tipo de artigo, diga não.
Se o segmento inicial deste percorredor for algum tipo de conjunction, diga sim.
Se o segmento inicial deste percorredor for algum tipo de possessive, diga não.
Se o segmento inicial deste percorredor for algum tipo de verb, diga sim.
Se o segmento inicial deste percorredor for algum operator aritmético, diga sim.
Se o percorredor estiver sobre algum tipo de preposition, diga sim.
Se o segmento inicial deste percorredor for algum tipo de qualifier, diga não.
Se o segmento inicial deste percorredor for algum tipo de literal, diga não.
Se o segmento inicial deste percorredor for algum tipo de called, diga sim.
\Se o segmento inicial deste percorredor for "equal", diga sim.
Se o segmento inicial deste percorredor for algum tipo de operador de atribuição composto, diga sim.
Se o segmento inicial deste percorredor estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se uma string é algum tipo de advérbio de negação:
\SAL
Se a string for "não", diga sim.
\Se a string for "nada", diga sim.
\Se a string for "ainda", diga sim.
\CAL
\Se a string for "no", diga sim.
Se a string for "not", diga sim.
\Se a string for "cannot", diga sim.
Se a string for "nothing", diga sim.
Se a string termina com "n't", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum operator aritmético:
\PAL
Se a string for "mais", diga sim.
Se a string for "menos", diga sim.
Se a string for "vezes", diga sim.
Se a string for "dividido", diga sim.
Se a string for "depois", diga sim.
Se a string for "seguido", diga sim.
Se a string for "juntamente", diga sim.
Se a string for "junto", diga sim.
Se a string for "acompanhado", diga sim.
\CAL
Se a string for "plus", diga sim.
Se a string for "minus", diga sim.
Se a string for "times", diga sim.
Se a string for "divided", diga sim.
Se a string for "then", diga sim.

Diga não.

\Etapas necessárias para que se determine se uma string é algum tipo de artigo indefinido inglês:
\Se a string for "a", diga sim.
\Se a string for "an", diga sim.
\Se a string for "another", diga sim.
\Se a string for "some", diga sim.
\Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de pause:
\PAL
Se a string for "e", diga sim.
Se a string for "ou", diga sim.
\CAL
Se a string for "and", diga sim.
Se a string for "or", diga sim.
\default
Se a string for ",", diga sim.
Se a string for ";", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de endereço de memória literal:
\PAL
Se a string for "nulo", diga sim.
Se a string for "nula", diga sim.
Se a string for "inexistente", diga sim.
\CAL
Se a string for "nil", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de possessive:
Se a string for "'s", diga sim.
Se a string for "'", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de preposition:
Atribua o segmento inicial deste percorredor para um subtexto.
\PAL
Se o percorredor estiver sobre algum tipo de preposição conectiva, diga sim. \ "a" followed por um article for "to" em portuguese
Se o subtexto for "abaixo", diga sim. \ para baixo
Se o subtexto for "acima", diga sim. \ para cima
Se o subtexto for "ante", diga sim. \ antes de
Se o subtexto for "antes", diga sim. \ antes de
Se o subtexto for "perante", diga sim. \ antes de
Se o subtexto for "debaixo", diga sim. \ below
Se o subtexto for "sob", diga sim. \ below
Se o subtexto for "acerca", diga sim. \ near
Se o subtexto for "próximo", diga sim. \ near
Se o subtexto for "perto", diga sim. \ near
Se o subtexto for "com", diga sim. \ com
\Se o subtexto for "contendo", diga sim. \ com
Se o subtexto for "como", diga sim. \ as
Se o subtexto for "contra", diga sim. \ against
\ Se o subtexto for "de", diga sim. \ reverse-possessive indicator 
Se o subtexto for "dada", diga sim. \ given
Se o subtexto for "dado", diga sim. \ given
Se o subtexto for "dando", diga sim. \ given
Se o subtexto for "gerando", diga sim. \ usando
Se o subtexto for "resultando", diga sim. \ usando
Se o subtexto for "retornando", diga sim. \ usando
\Se o subtexto for "direita", diga sim. \ right
Se o subtexto for "desde", diga sim. \ since
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "durante", diga sim. \ during
Se o subtexto for "em", diga sim. \ in
Se o subtexto for "entre", diga sim. \ between
Se o subtexto for "até", diga sim. \ until
\Se o subtexto for "esquerda", diga sim. \ left
Se o subtexto for "mediante", diga sim. \ through
Se o subtexto for "para", diga sim. \ to
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "segundo", diga sim. \ according
Se o subtexto for "sem", diga sim. \ comout
Se o subtexto for "então", diga sim.
Se o subtexto for "sobre", diga sim. \ on
Se o subtexto for "após", diga sim. \ after
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "usando", diga sim. \ using
\Se o subtexto for "contendo", diga sim. \ using 
Se o subtexto for "versus", diga sim. \ versus
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "enquanto", diga sim. \ while
Se o subtexto for "redefinindo", diga sim. \# 'at' na redefinição de campos 
\CAL
Se o subtexto for "about", diga sim.
Se o subtexto for "above", diga sim.
Se o subtexto for "across", diga sim.
Se o subtexto for "after", diga sim.
Se o subtexto for "against", diga sim.
Se o subtexto for "all", diga sim.
Se o subtexto for "alone", diga sim.
Se o subtexto for "along", diga sim.
Se o subtexto for "among", diga sim.
Se o subtexto for "algum tipo de", diga sim.
Se o subtexto for "anywhere", diga sim.
Se o subtexto for "around", diga sim.
\Se o subtexto for "as", diga sim.
Se o subtexto for "at", diga sim.
Se o subtexto for "away", diga sim.
Se o subtexto for "back", diga sim.
Se o subtexto for "backward", diga sim.
Se o subtexto for "backwards", diga sim.
Se o subtexto for "antes de", diga sim.
Se o subtexto for "beginning", diga sim.
Se o subtexto for "behind", diga sim.
Se o subtexto for "below", diga sim.
Se o subtexto for "beneath", diga sim.
Se o subtexto for "beside", diga sim.
Se o subtexto for "between", diga sim.
Se o subtexto for "beyond", diga sim.
Se o subtexto for "bigger", diga sim.
Se o subtexto for "by", diga sim.
Se o subtexto for "close", diga sim.
Se o subtexto for "deep", diga sim.
Se o subtexto for "diagonally", diga sim.
Se o subtexto for "para baixo", diga sim.
Se o subtexto for "downward", diga sim.
Se o subtexto for "ending", diga sim.
Se o subtexto for "everywhere", diga sim.
Se o subtexto for "except", diga sim.
Se o subtexto for "finishing", diga sim.
Se o subtexto for "facing", diga sim.
\Se o subtexto for "for", diga sim.
Se o subtexto for "por", diga sim.
Se o subtexto for "forward", diga sim.
Se o subtexto for "from", diga sim.
Se o subtexto for "given", diga sim.
Se o subtexto for "usando", diga sim.
Se o subtexto for "high", diga sim.
Se o subtexto for "in", diga sim.
Se o subtexto for "inside", diga sim.
Se o subtexto for "into", diga sim.
Se o subtexto for "en", diga sim.
Se o subtexto for "larger", diga sim.
Se o subtexto for "leaning", diga sim.
Se o subtexto for "left", diga sim.
Se o subtexto for "leftward", diga sim.
Se o subtexto for "leftways", diga sim.
Se o subtexto for "like", diga sim.
Se o subtexto for "limiting", diga sim.
Se o subtexto for "long", diga sim.
Se o subtexto for "near", diga sim.
Se o subtexto for "of", diga sim.
Se o subtexto for "off", diga sim.
Se o subtexto for "on", diga sim.
Se o subtexto for "only", diga sim.
Se o subtexto for "onto", diga sim.
Se o subtexto for "out", diga sim.
Se o subtexto for "outside", diga sim.
Se o subtexto for "over", diga sim.
Se o subtexto for "past", diga sim.
Se o subtexto for "pointing", diga sim.
Se o subtexto for "devolvendo", diga sim.
Se o subtexto for "right", diga sim.
Se o subtexto for "rightward", diga sim.
Se o subtexto for "rightways", diga sim.
Se o subtexto for "shorter", diga sim.
Se o subtexto for "sideway", diga sim.
Se o subtexto for "sideways", diga sim.
Se o subtexto for "similar", diga sim.
Se o subtexto for "smaller", diga sim.
Se o subtexto for "somewhere", diga sim.
Se o subtexto for "slantwise", diga sim.
Se o subtexto for "slantway", diga sim.
Se o subtexto for "slantways", diga sim.
Se o subtexto for "starting", diga sim.
Se o subtexto for "tall", diga sim.
Se o subtexto for "taller", diga sim.
Se o subtexto for "thru", diga sim.
Se o subtexto for "through", diga sim.
Se o subtexto for "throughout", diga sim.
Se o subtexto for "to", diga sim.
Se o subtexto for "toward", diga sim.
Se o subtexto for "towards", diga sim.
Se o subtexto for "under", diga sim.
Se o subtexto for "underneath", diga sim.
Se o subtexto for "until", diga sim.
Se o subtexto for "unto", diga sim.
Se o subtexto for "para cima", diga sim.
Se o subtexto for "upward", diga sim.
Se o subtexto for "upon", diga sim.
Se o subtexto for "using", diga sim.
Se o subtexto for "via", diga sim.
Se o subtexto for "while", diga sim.
Se o subtexto for "wide", diga sim.
Se o subtexto for "com", diga sim.
Se o subtexto for "within", diga sim.
Se o subtexto for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de preposition:
Se a string for "about", diga sim.
Se a string for "above", diga sim.
Se a string for "across", diga sim.
Se a string for "after", diga sim.
Se a string for "against", diga sim.
Se a string for "all", diga sim.
Se a string for "alone", diga sim.
Se a string for "along", diga sim.
Se a string for "among", diga sim.
Se a string for "algum tipo de", diga sim.
Se a string for "anywhere", diga sim.
Se a string for "around", diga sim.
\Se a string for "as", diga sim.
Se a string for "at", diga sim.
Se a string for "away", diga sim.
Se a string for "back", diga sim.
Se a string for "backward", diga sim.
Se a string for "backwards", diga sim.
Se a string for "antes de", diga sim.
Se a string for "beginning", diga sim.
Se a string for "behind", diga sim.
Se a string for "below", diga sim.
Se a string for "beneath", diga sim.
Se a string for "beside", diga sim.
Se a string for "between", diga sim.
Se a string for "beyond", diga sim.
Se a string for "bigger", diga sim.
Se a string for "by", diga sim.
Se a string for "close", diga sim.
Se a string for "deep", diga sim.
Se a string for "diagonally", diga sim.
Se a string for "para baixo", diga sim.
Se a string for "downward", diga sim.
Se a string for "ending", diga sim.
Se a string for "everywhere", diga sim.
Se a string for "except", diga sim.
Se a string for "finishing", diga sim.
Se a string for "facing", diga sim.
\Se a string for "for", diga sim.
Se a string for "por", diga sim.
Se a string for "forward", diga sim.
Se a string for "from", diga sim.
Se a string for "given", diga sim.
Se a string for "usando", diga sim.
Se a string for "high", diga sim.
Se a string for "in", diga sim.
Se a string for "inside", diga sim.
Se a string for "into", diga sim.
Se a string for "larger", diga sim.
Se a string for "leaning", diga sim.
Se a string for "left", diga sim.
Se a string for "leftward", diga sim.
Se a string for "leftways", diga sim.
Se a string for "like", diga sim.
Se a string for "limiting", diga sim.
Se a string for "long", diga sim.
Se a string for "near", diga sim.
Se a string for "of", diga sim.
Se a string for "off", diga sim.
Se a string for "on", diga sim.
Se a string for "only", diga sim.
Se a string for "onto", diga sim.
Se a string for "out", diga sim.
Se a string for "outside", diga sim.
Se a string for "over", diga sim.
Se a string for "past", diga sim.
Se a string for "pointing", diga sim.
Se a string for "devolvendo", diga sim.
Se a string for "right", diga sim.
Se a string for "rightward", diga sim.
Se a string for "rightways", diga sim.
Se a string for "shorter", diga sim.
Se a string for "sideway", diga sim.
Se a string for "sideways", diga sim.
Se a string for "similar", diga sim.
Se a string for "smaller", diga sim.
Se a string for "somewhere", diga sim.
Se a string for "slantwise", diga sim.
Se a string for "slantway", diga sim.
Se a string for "slantways", diga sim.
Se a string for "starting", diga sim.
Se a string for "tall", diga sim.
Se a string for "taller", diga sim.
Se a string for "thru", diga sim.
Se a string for "through", diga sim.
Se a string for "throughout", diga sim.
Se a string for "to", diga sim.
Se a string for "toward", diga sim.
Se a string for "towards", diga sim.
Se a string for "under", diga sim.
Se a string for "underneath", diga sim.
Se a string for "until", diga sim.
Se a string for "unto", diga sim.
Se a string for "para cima", diga sim.
Se a string for "upward", diga sim.
Se a string for "upon", diga sim.
Se a string for "using", diga sim.
Se a string for "via", diga sim.
Se a string for "while", diga sim.
Se a string for "wide", diga sim.
Se a string for "com", diga sim.
Se a string for "within", diga sim.
Se a string for "without", diga sim.
Se a string for "depois", diga sim. \ depois de
Se a string for "desde", diga sim. 
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de qualifier:
Se a string estiver em branco, diga não.
Se o conteúdo deste first endereço de memória do pedaço desta string for o parênteses esquerdo, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de reverse-possessive:
Se a string for "de", diga sim.
\Se a string for "do", diga sim. \ short por "de o", expanded em "compile um termo usando um percorredor e um campo nome (possessivo reverso)"
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre algum tipo de reverse-possessive:
Isole o percorredor.
Se o segmento inicial deste percorredor não for "de", diga não.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for algum tipo de pronome demonstrativo, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de string literal:
Se a string estiver em branco, diga não.
Se o conteúdo deste first endereço de memória do pedaço desta string for as aspas duplas, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de symbol:
Se a quantidade de caracteres desta string não for 1, diga não.
Se o conteúdo deste first endereço de memória do pedaço desta string for algum tipo de symbol, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de verb:
\PAL
Se a string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se a string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se a string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se a string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
Se a string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" para non-tempora state
Se a string for "ser", diga sim. \ "be"
Se a string for "for", diga sim. \ "be"
Se a string for "forem", diga sim. \ "be"
Se a string for "estiver", diga sim. \ "be"
Se a string for "estiverem", diga sim. \ "be"
Se a string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, perm.
Se a string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, temp.
Se a string for "são", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, perm.
Se a string for "estão", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, temp.
Se a string for "foi", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, perm.
Se a string for "estava", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, temp.
Se a string for "foram", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, perm.
Se a string for "estavam", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, temp.
Se a string for "será", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, perm.
Se a string for "estará", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, temp.
Se a string for "serão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, perm.
Se a string for "estarão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, temp.
\Se a string for "seja", diga sim. 
Se a string for "supera", diga sim. \ beats, exceeds
Se a string for "superam", diga sim. \ beats, exceeds
Se a string for "excede", diga sim. \ beats, exceeds
Se a string for "excedem", diga sim. \ beats, exceeds
Se a string for "pode", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se a string for "puder", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se a string for "puderem", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se a string for "podem", diga sim. \ they "can" cannot \ can't: not used em CAL (3pp) added just em case 
Se a string for "poderia", diga sim. \ it "could" could not \ couldn't: not used em CAL (3ps) added just em case
Se a string for "poderia", diga sim. \ they "could" could not \ couldn't: not used em CAL (3pp) added just em case
Se a string for "podemos", diga sim. \ we "could" could not \ couldn't: only once em Noodle (1pp) "Etapas necessárias para que se determine se we could encontre um endereço de memória:"
Se a string for "tem", diga sim. \ it "has" used em type definitions; (3ps) present
Se a string for "têm", diga sim. \ they "have" used em type definitions; (3pp) present
Se a string for "ter", diga sim. \ used em type definitions
Se a string for "possui", diga sim. \ it "has" used em type definitions; (3ps) present
Se a string for "possuem", diga sim. \ they "have" used em type definitions; (3pp) present
Se a string for "possuir", diga sim. \ used em type definitions
\\ trouble makers
Se a string for "inicia", diga sim. \ "begins" does not begin \ doesn't begin
Se a string for "iniciar", diga sim. \ "begins" does not begin \ doesn't begin
Se a string for "começa", diga sim. \ "começa" não começa \ doesn't start: I hear um yes
Se a string for "começar", diga sim. \ "começa" não começa \ doesn't start: I hear um yes
Se a string for "termina", diga sim. \ "ends" does not end \ doesn't end
Se a string for "terminar", diga sim. \ "ends" does not end \ doesn't end
Se a string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
Se a string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
Se a string for "parece", diga sim. \ "looks" does not look \ doesn't look
Se a string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
Se a string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
Se a string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
\CAL
Se a string for "are", diga sim. \ são not \ aren't
Se a string for "be", diga sim. \
Se a string for "can", diga sim. \ cannot \ can't
\Se a string for "cannot", diga sim.
\Se a string for "could", diga sim. \ could not \ couldn't
\Se a string for "do", diga sim. \ does not \ don't
Se a string for "does", diga sim. \ does not \ doesn't
Se a string for "is", diga sim. \ não for \ isn't
Se a string for "may", diga sim. \ may not \ mayn't
Se a string for "should", diga sim. \ não deveria \ shouldn't
Se a string for "was", diga sim. \ was not \ wasn't
Se a string for "will", diga sim. \ will not \ won't
Se a string for "would", diga sim. \ would not \ wouldn't
Se a string for "has", diga sim. \ used em type definitions
Se a string for "have", diga sim. \ used em type definitions
Se a string termina com "n't", diga sim.
\\ trouble makers
Se a string for "begins", diga sim. \ does not begin \ doesn't begin
Se a string for "ends", diga sim. \ does not end \ doesn't end
Se a string for "looks", diga sim. \ does not look \ doesn't look
Se a string for "needs", diga sim. \ does not need \ doesn't need
Se a string for "starts", diga sim. \ não começa \ doesn't start
Diga não.

Etapas necessárias para que se determine se uma string é o enunciado de alguma rotina ou variável:
\PAL
Se a string for "Passos", diga sim.
Se a string for "Etapas", diga sim.
\CAL
Se a string for "to", diga sim.
\default
Se a string for algum tipo de artigo indefinido, diga sim.
Se a string for algum tipo de artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de comando condicional:
\PAL
Se a string for "se", diga sim.
Se a string for "quando", diga sim.
\CAL
Se a string for "if", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de privatize:
\PAL
Se a string for "privatize", diga sim.
\Se a string for "reserve", diga sim.
Se a string for "separe", diga sim.
Se a string for "isole", diga sim.
Se a string for "Isole", diga sim.
Se a string for "conserve", diga sim.
Se a string for "derive", diga sim.
\CAL
\Se a string for "privatize", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de loop:
\PAL
Se a string for "percorra", diga sim.
\Se a string for "ciclo", diga sim.
\Se a string for "laço", diga sim. \# muito usado em pseudo-codigo
\CAL
Se a string for "loop", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de break:
\PAL
Se a string for "pare", diga sim.
Se a string for "pare de percorrer", diga sim.
Se a string for "saia", diga sim.
Se a string for "saia do laço", diga sim.
\CAL
Se a string for "break", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de exit:
\PAL
Se a string for "cancele a operação", diga sim.
Se a string for "interrompa a operação", diga sim.
\Se a string for "advirta", diga sim.
\Se a string for "anuncie", diga sim.
\Se a string for "avise", diga sim.
Se a string for "cancele", diga sim.
Se a string for "desconsidere.", diga sim.
Se a string for "deixa quieto", diga sim.
Se a string for "deixe quieto", diga sim.
Se a string for "e mais nada", diga sim.
Se a string for "e pronto", diga sim.
Se a string for "e só", diga sim.
Se a string for "fim", diga sim.
Se a string for "fimse", diga sim.
Se a string for "ignore", diga sim.
\Se a string for "informe", diga sim.
Se a string for "prossiga", diga sim.
Se a string for "pronto", diga sim.
Se a string for "retorne", diga sim.
Se a string for "siga adiante", diga sim.
Se a string for "terminamos", diga sim.
Se a string for "termine", diga sim.
\CAL
Se a string for "exit", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de repeat:
\PAL
Se a string for "repita", diga sim. 
\CAL
Se a string for "repeat", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de say:
\PAL
Se a string for "diga", diga sim. \# modo imperativo
Se a string for "responda", diga sim. \# modo imperativo
Se a string for "informe", diga sim. \# modo imperativo
\Se a string for "decida", diga sim. \ para usar como "decida afirmativamente e decida negativamente"
\Se a string for "dizer", diga sim. \# modo infinitivo opcional.
\CAL
Se a string for "say", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de decide:
\PAL
\Se a string for "decidir", diga sim.
Se a string for "decida", diga sim. \estou pensando em retirar devido o comentário da rotina anterior
\Se a string for "escolha", diga sim.
Se a string for "determine", diga sim.
Se a string for "conclua", diga sim.
Se a string for "esclareça", diga sim.
\Se a string for "descubra", diga sim.
\Se a string for "mostre", diga sim.
\Se a string for "mostre", diga sim.
Se a string for "analise", diga sim.
\CAL
Se a string for "decide", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de call:
\PAL
Se a string for "chame", diga sim.
Se a string for "invoque", diga sim.
Se a string for "repasse", diga sim.
Se a string for "informe", diga sim.\ no caso de comandos como "informe os parâmetros x e y e z para a função "FunctionName" da biblioteca "MyLibrary.dll"
\CAL
Se a string for "call", diga sim.
\ Envie o parâmetro "nome" para a função "SetNome". Se a função SetNome produzir um código  diferente de 0, produza um relatório de erros a partir deste código.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de point:
\PAL
Se a string for "aponte", diga sim.
Se a string for "direcione", diga sim.
\Se a string for "redirecione", diga sim.
\Se a string for "mire", diga sim.
\Se a string for "dirija-se à", diga sim.
\Se a string for "refira-se à", diga sim.
\Se a string for "referencie", diga sim.
\Se a string for "faça referência à", diga sim.
\Se a string for "indique", diga sim.
\Se a string for "realce", diga sim.
\CAL
Se a string for "point", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de employ:
\ Employs servem para usar uma rotina 
\exemplos:
\To raise a flag: Employ set a flag.
\To decide if a flag is raised: Employ decide if a flag is set.
\ Acho que uma boa tradução seria:
\ Etapas necessárias para que se ative um detector: Faça uso da rotina "defina um detector".
\ (troquei a palavra "flag" por "detector" e a palavra "raise" por "ativar"
\ então ao invés de "empregue" usaríamos "faça uso da rotina" ou "lance mão da rotina"
\Estou pensando em retirar isso já que já temos a sobrecarga demétodos disponível
\PAL
Se a string for "empregue", diga sim.
\CAL
Se a string for "employ", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é algum tipo de noise palavra:
\Nova rotina 
Se a string for "already", diga sim.
Se a string for "still", diga sim.
Se a string for "yet", diga sim.
Se a string for "já", diga sim.
Se a string for "ainda", diga sim.
\Se a string for "que", diga sim.
\Se a string for "se", diga sim.
[more noise palavras here]
Diga não.

Etapas necessárias para que se determine se uma string é o start of algum tipo de expression:
Se a string for tipo de sinal aritmético, diga sim.
Se a string for algum tipo de artigo indefinido, diga sim.
Se a string for algum tipo de artigo definido, diga sim.
Se a string for algum tipo de literal, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é o start of algum tipo de global:
Se a string for algum tipo de artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é o start of algum tipo de new local:
Se a string for algum tipo de artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é o start of algum tipo de optional info:
\PAL
Se a string for "com", diga sim.
Se a string for "contendo", diga sim.
\CAL
Se a string for "to", diga sim.
Se a string for "com", diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é o start of algum tipo de rotina:
\PAL
Se a string for "Passos", diga sim.
Se a string for "Etapas", diga sim.
Se a string for "Etapas necessárias para que se", diga sim. \verificar depois
Se a string for "Passos necessários para que se", diga sim.
\CAL
Se a string for "to", diga sim. \verificar se pode ser excluído
Diga não.

Etapas necessárias para que se determine se uma string é o start of algum tipo de statement:
Se a string for o enunciado de alguma rotina ou variável, diga não.
Se a string for algum tipo de literal, diga não.
Se a string for algum tipo de mark, diga não.
Se a string estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se uma string é o start of algum tipo de type:
Se a string for algum tipo de artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se uma string é o start of algum tipo de variável:
Se a string for algum tipo de artigo definido, diga sim.
\Se a string for "do", diga sim. \ this é iffy, here por reverse-possessives
Diga não.

Etapas necessárias para que se determine se uma string has algum tipo de stressed vogal:
Isole a string.
Percorra.
Se a string estiver em branco, diga não.
Se o conteúdo deste last endereço de memória do pedaço desta string for algum tipo de stressed vogal, diga sim.
Subtraia 1 desde o last endereço de memória do pedaço desta string.
Repita.

Etapas necessárias para que se determine se uma termo está vazia;
Etapas necessárias para que se determine se uns termo estão vazias;
Etapas necessárias para que se determine se uns termo estão vazios;
Etapas necessárias para que se determine se um termo está vazio:
Se a variável deste termo não for inexistente, diga não.
Se a phrase deste termo não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um type pode ser reduzido para uma string using o base nome:
Se o type for inexistente, diga não.
Se o nome deste type for a string, diga sim.
Se o cooking detector deste type estiver ativo, diga não.
Ligue o cooking detector deste type.
Encontre um base type usando o base nome deste type e o catálogo de tipos.
Se o base type for inexistente, desative o cooking detector deste type; diga não.
Se o base type puder ser reduzido para a string using o base nome, desative o cooking detector deste type; diga sim.
Desative o cooking detector deste type.
Diga não.

Etapas necessárias para que se determine se um type pode ser reduzido para um type nome:
Se o type for inexistente, diga não.
Isole o type.
Percorra.
Se o type for inexistente, diga não.
Se o nome deste type for o type nome, diga sim.
Se o base type deste type for o type, diga não.
Atribua o base type deste type ao type.
Repita.

Etapas necessárias para que se determine se um type é algum tipo pré-definido:
Se o type for inexistente, diga não.
Se o type for o base type deste type, diga sim.
Diga não.

Etapas necessárias para que se determine se um type é value pushable:
Se o type for inexistente, diga não.
Se o type for inexistente, diga não. \\ repetido?
Se a quantidade de caracteres deste type for 4, diga sim.
Se a quantidade de caracteres deste type for 2, diga sim.
Se a quantidade de caracteres deste type for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser  finalizado: \The phrase "should be finalized" means "ought to be/needs to be automatically deallocated".
\The phrase "should be finalized" means "ought to be/needs to be automatically deallocated".
Se o type for inexistente, diga não.
Se o type puder ser reduzido para "subtexto", diga não.\  substrings point to (parts of) real strings that get deallocated elsewhere
Se o type puder ser reduzido para "string", diga sim.\ the normal case for strings
Se o type puder ser reduzido para "texto", diga sim.\ the normal case for strings
Se os campos deste type deveriam ser finalizados, diga sim.\ this is for strings inside records
Diga não.

Etapas necessárias para que se determine se um type deveria ser ignorado:  \ ie, can be destroyed/needs a destroy routine generated for it
\The phrase "should be forgotten" means "ought to be forgotten" which really means "needs to have a destroy routine automatically generated for it". See page 93 of the manual.
Se o type for inexistente, diga não.
\PAL
\Se o nome deste type for "elemento", diga não.
\Se o nome deste type for "elementos", diga não.
\CAL
Se o nome deste type for "coisa", diga não. \ no, because this is the built-in type which we don't ever allocate or destroy, it exists so we can "magically" add next and previous fields to anything defined as a "thing"
Se o nome deste type for "coisas", diga não. \ no, because this is the built-in type we "magically" generate to anchor lists of things, same as above.
Se o type puder ser reduzido para "coisas", diga sim. \ yes, because (though it seems to contradict the line immediately above) this is a an actual list of things that we can destroy, for example "some pages".
Se o type não puder ser reduzido para "endereço de memória", diga não. \ \ no, because a pointer variable is a static variable (it is the address in the variable that is dynamic); the pointer variable itself is not something that can be dynamically allocated, so no destroy is necessary
Se o conteúdo type deste type for inexistente, diga não. \ no, because it's a pointer to nothing, so there's nothing to destroy.
Se o conteúdo type deste type não puder ser reduzido para "endereço de memória", diga sim.\ yes, because it's a pointer to something allocated, not a pointer to another pointer. Pointers to pointers are handled with the next recursive line
Se o conteúdo type deste type não deveria ser ignorado, diga não.\ no, because it's a pointer to something that shouldn't be destroyed. For example, a pointer to a thing
Diga sim.\ The last condition is the hardest to wrap one's head around since it is recursive.



Etapas necessárias para que se determine se uma variável está duplicada em umas variáveis:
Obtenha uma segunda variável desde o variáveis.
Se a segunda variável for inexistente, diga não.
Se o nome desta segunda variável estiver em branco, repita.
Se a segunda variável for a variável, repita.
Se o nome desta segunda variável for o nome desta variável, diga sim.
Repita.



Um DOS header é um conjunto com
Um wyrd denominado Signature, 
\\ Signature Word. This contains a "magic number" which provides a simple check that the file really is a DOS .EXE file;
\\ it follows that the filename extension does not in fact have to be .EXE, as long as programs check this word.
\\The value of this word is 5A4DH (com the 4DH coming first).
\\These two bytes represent the character string "MZ", the initials of Mark Zibowski, a Microsoft employee at the time the file format was designed.
Um wyrd denominado NumberOfBytesOnLastPage, \\ O last page may contain between 1 and 512 bytes
\\Last Page Size.
\\O file occupies a number of 512 byte pages.
\\O last page may contain between 1 and 512 bytes.
\\This word indicates the number of bytes actually used em the last page, 
\\com the special case of a full page being represented by a value of zero (since the last page is never empty).
Um wyrd denominado NumberOfPages,
\\ File Pages.
\\This word contains a count of the number of pages required para hold the file.
\\For example, if the file contains 1024 bytes, this word would contain 0002H; 
\\if the file contains 1025 bytes, this word would contain 0003H.
\\O Last Page Size campo is used para determine the number of valid bytes em the final page.
\\Thus, if the file contains 1024 bytes, the Last Page Size campo contains 0000H, because no bytes overflow à final partly used page.
\\If the file contains 1025 bytes, seguido de the Last Page Size campo contains 0001H, because the final page contains only one valid byte (the 1025th byte).
Um wyrd denominado Relocations,
\\ Relocation Items.
\\ This word gives the number of entries that exist em the relocation pointer table.
\\It is quite em order for this value para be zero, em which case there are no relocation entries.
Um wyrd denominado SizeOfHeaderInParagraphs,
\\ Header Paragraphs.
\\This word gives the size of the .EXE header em parágrafos.
\\It indicates the offset of the compiled/assembled and linked image do program (the load module) within the .EXE file.
\\O size of the load module can be deduced by subtracting this value (converted para bytes) desde the overall file size 
\\derived desde combining the File Pages and Last Page Size values.
\\O header always spans an even number of parágrafos.
Um wyrd denominado MinimumExtraParagraphsNeeded,
\\ MINALLOC.
\\This word indicates the minimum number of parágrafos the program requires para begin execution.
\\This is em addition para the memory required para hold the load module.
\\This value normally represents the total size of algum tipo de uninitialised data and/or stack segments that are linked at the end of a program.
\\This space is not directly included em the load module, since there are no particular initialising values and it would simply waste disk space.
Um wyrd denominado MamixmumExtraParagraphsNeeded,
\\ MAXALLOC.
\\This word indicates the maximum number of parágrafos that the program would like allocated para it before it begins execution.
\\This indicates additional memory over and above that required by the load module and the value specified by MINALLOC.
\\If the request cannot be satisfied, the program is allocated as much memory as is available.
Um wyrd denominado InitialRelativeSS,
\\ Initial SS value.
\\This word contains the paragraph address of the stack segment relative para the start of the load module.
\\At load time, this value is relocated by adding the address of the start segment of the program para it, 
\\and the resulting value is placed em the SS register before the program is started.
\\In DOS, the start segment of the program is the first segment boundary em memory after the PSP.
Um wyrd denominado InitialSP,
\\ Initial SP value.
\\This word contains the absolute value that must be loaded para the SP register before the program is given control.
\\Since the actual stack segment is determined by the loader, and this is merely a value within that segment, it does not need para be relocated.
Um wyrd denominado InitialChecksum,
\\ Complemented Checksum.
\\This word contains a checksum of the contents of the .EXE file.
\\ Its value is rarely checked, but its purpose is para ensure the integrity of the data within the file.
\\ Full details of how it is calculated appear em the section sobre checksum calculation.
Um wyrd denominado InitialIP,
\\ Initial IP value.
\\This word contains the absolute value that should be loaded para the IP register em order para transfer control para the program.
\\Since the actual código segment is determined by the loader, and this is merely a value within that segment, it does not need para be relocated.
Um wyrd denominado InitialiRelativeCS, 
\\ Pre-relocated initial CS value.
\\ This word contains the initial value, relative para the start of the load module, that should be placed em the CS register em order para transfer control para the program.
\\ At load time, this value is relocated by adding the address of the start segment of the program para it, and the resulting value is placed em the CS register
\\ when control is transferred.
Um wyrd denominado AddressOfRelocationTableInFile, \ 
\\ O addressofrelocationtableinfile é um ponteiro para a tabela de tamanha variável de DLLs necessária para este programa.
\\ Relocation table offset.
\\ This word gives the offset desde the start of the file para the relocation pointer table.
\\ This value must be used para locate the relocation pointer table (rather than assuming a fixed location) 
\\because variável-length information pertaining para program overlays can occur before this table, causing its position para vary.
\\A value of 40H em this campo generally indicates a different kind of executable file, not a DOS "MZ" type.
Um wyrd denominado OverlyNumber,
\\ Overlay number.
\\ This word is normally set para 0000H, because few programs actually have overlays.
\\It changes only em files containing programs that use overlays; see the note below.
8 pedaços denominado ReservedBytes, \\ Specifies Reserved words for the program (known em winnt.h as e_res[4]), usually set para zero by the linker.
\\In this case, just use a single reserved1 set para zero; if not zero create four reserved1 com the correct value.
Um wyrd denominado OEM_Identifier, \\ Specifies the identifier for the OEM for e_oeminfo.
Um wyrd denominado OEM_Info, \\ Specifies the OEM information for a specific value of e_oeminfo.
20 pedaços denominado ReservedWords, \\ Specifies Reserved words for the program (known em winnt.h as e_res[10]), usually set para zero by the linker.
\\In this case, just use a single reserved1 set para zero; if not zero create ten reserved1 com the correct value.
Um número denominado Address_Of_PE_Header_In_File. \\ O addressofpeheaderinfile é um ponteiro para o PE Header, uma versão revisada e estendida do Cabeçalho DOS introduzida com o advento do Windows. Os outros 16 campos do cabeçalho DOS não são usados.

Etapas necessárias para que se eliminate duplicate nicknames desde umas variáveis:
Crie um catálogo usando 101.
Eliminate duplicate nicknames desde o variáveis usando o catálogo.
Destrua o catálogo.

Etapas necessárias para que se eliminate duplicate nicknames desde umas variáveis usando um catálogo:
Se o catálogo for inexistente, cancele.
Percorra.
Obtenha uma variável desde o variáveis.
Se a variável for inexistente, cancele.
Eliminate duplicate nicknames usando a variável e o catálogo.
Repita.

Etapas necessárias para que se eliminate duplicate nicknames usando uma variável e um catálogo:
Se a variável for inexistente, cancele.
Se o catálogo for inexistente, cancele.
Encontre uma segunda variável usando o nickname desta variável e o catálogo.
Se a segunda variável for inexistente, encontre a segunda variável usando o nome desta variável e o catálogo.
Se a segunda variável for inexistente, catalogue a variável usando o nickname desta variável e o catálogo; exit.
Limpe o nickname desta segunda variável.
Limpe o nickname desta variável.



An entry é uma coisa com
Um nome endereço,
Um previamente calculado endereço, \ consulte https://en.wikipedia.org/wiki/Thunk e http://ftp.informatik.rwth-aachen.de/jargon300/previamente calculado.html para mais informações
\ Em programação de computador , um previamente calculado é uma sub-rotina usada para injetar um cálculo em outra sub-rotina. 
\Thunks são usados principalmente para atrasar um cálculo até que seu resultado seja necessário ou para inserir operações no início ou no final de outra sub-rotina. 
\Eles têm muitos outros usos na geração de código do compilador e em programação modular .
Um nome,
Um endereço.

Uma expression é um termo.

Etapas necessárias para que se extend uma string com uma segunda string:
Se a segunda string estiver em branco, cancele.
Se a string não estiver em branco, posponha o caractere de espaço para a string.
Posponha a segunda string para a string.


Um campo é uma variável.

Um campo termo é um conjunto com
Um dereference detector,
Um campo (reference),
Um function rotina (reference),
Um push detector.

Etapas necessárias para que se finalize o compilador:
Destrua o catálogo de rotinas úteis.
Destrua o catálogo geral de rotinas.
Destrua o catálogo de variáveis hexadecimais.
Destrua o catálogo de variáveis globais.
Destrua o catálogo de tipos.
Destrua os imports.
Destrua as rotinas.
Destrua os literals.
Destrua os globals.
Destrua os types.
Destrua os source files.



Etapas necessárias para que se encontre um entry usando uma string e uns entries:
Esvazie a entry.
Percorra.
Obtenha a entry desde o entries.
Se a entry for inexistente, cancele.
Se o nome desta entry for a string, cancele.
Repita.

Etapas necessárias para que se encontre um campo termo usando um phrase e um type e um nome:
Limpe o campo termo.
Encontre o campo termo usando o type e o nome.
Se o campo deste campo termo não for inexistente, cancele.
Se a phrase não estiver em branco, encontre uma rotina usando "atribua" e a phrase e "'s " junto com o nome e "para".
Se a rotina não for inexistente, atribua a rotina à function deste campo termo; exit.
Se o type for inexistente, cancele.
Encontre a rotina usando "atribua" e o type e "'s " junto com o nome e "para".
Se a rotina não for inexistente, acione o push detector deste campo termo; atribua a rotina ao function deste campo termo; exit.
\ código below for looking deep within endereço de memórias - a debatable feature
\ Se o conteúdo type deste type não for inexistente, encontre a rotina usando "atribua" e o conteúdo type deste type e "'s " junto com o nome e "para".
\ Se a rotina não for inexistente, acione o dereference detector deste campo termo; atribua a rotina à function deste campo termo; exit.

Etapas necessárias para que se encontre um campo termo usando um type e um nome:
Se o type for inexistente, cancele.
Encontre um campo usando o nome e os campos deste type.
Se o campo não for inexistente, atribua o campo ao campo deste campo termo; exit.
Se o conteúdo type deste type não for inexistente, encontre o campo usando o nome e os campos deste conteúdo type deste type.
Se o campo não for inexistente, acione o dereference detector deste campo termo; atribua o campo ao campo deste campo termo; exit.

Etapas necessárias para que se encontre um fragment usando um segundo fragment e uma etiqueta:
Atribua o segundo fragment ao fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se a etiqueta deste fragment for a etiqueta, cancele.
Atribua o next deste fragment ao fragment.
Repita.

Etapas necessárias para que se encontre um fragment usando um segundo fragment e uma etiqueta (backwards):
Atribua o segundo fragment ao fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se a etiqueta deste fragment for a etiqueta, cancele.
Atribua o previous deste fragment ao fragment.
Repita.

Etapas necessárias para que se encontre um import usando uma string:
Esvazie o import.
Percorra.
Obtenha o import desde o imports.
Se o import for inexistente, cancele.
Se o nome deste import for a string, cancele.
Repita.

Etapas necessárias para que se encontre um endereço completo e um número da linha usando um endereço de memória do pedaço :
Limpe o endereço completo.
Atribua 0 ao número da linha.
Encontre um source file usando o endereço de memória do pedaço .
Se o source file for inexistente, cancele.
Atribua o endereço completo deste source file ao endereço completo.
Encontre o número da linha usando o source file e o endereço de memória do pedaço .

Etapas necessárias para que se encontre uma rotina usando um cabeçalho expandido e um monikette e um catálogo:
Se o monikette for inexistente, cancele.
Esvazie a rotina.
Isole o cabeçalho expandido.
Atribua o type deste monikette ao type atual deste monikette.
Lance o subtexto atual deste monikette sobre a string deste monikette.
Percorra.
Posponha o monikette para o cabeçalho expandido (while bubbling).
Encontre um refer usando o cabeçalho expandido e o catálogo.
Se o refer não for inexistente, atribua o endereço de memória deste refer à rotina.
Se o refer não for inexistente, encontre a rotina usando o cabeçalho expandido e o next deste monikette e o catálogo.
Se a rotina não for inexistente, pare.
Bubble o monikette.
Se o monikette estiver bubbled out, pare.
Atribua o original cabeçalho expandido ao cabeçalho expandido.
Repita.

Etapas necessárias para que se encontre uma rotina usando uns monikettes:
Esvazie a rotina.
Encontre a rotina usando um cabeçalho expandido e o first destes monikettes e o catálogo geral de rotinas.

Etapas necessárias para que se encontre uma rotina usando uma string e uma segunda string e um terceiro string e um quarto string:
Adicione um monikette para uns monikettes usando a string.
Adicione uma segunda monikette para os monikettes usando a segunda string.
Adicione um terceiro monikette para os monikettes usando o terceiro string.
Adicione um quarto monikette para os monikettes usando o quarto string.
Encontre a rotina usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre uma rotina usando uma string e um type:
Adicione um monikette para uns monikettes usando a string.
Adicione uma segunda monikette para os monikettes usando o type.
Encontre a rotina usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre uma rotina usando uma string e um type e uma segunda string e uma segunda type:
Adicione um monikette para uns monikettes usando a string.
Adicione uma segunda monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando a segunda type.
Encontre a rotina usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre uma rotina usando uma string e um type e uma segunda string e um terceiro string:
Adicione um monikette para uns monikettes usando a string.
Adicione uma segunda monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando o terceiro string.
Encontre a rotina usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre uma rotina usando uma string e um type e uma segunda string e um terceiro string e um quarto string e um quinto string:
Adicione um monikette para uns monikettes usando a string.
Adicione uma segunda monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando o terceiro string.
Adicione um quinto monikette para os monikettes usando o quarto string.
Adicione um sexto monikette para os monikettes usando o quinto string.
Encontre a rotina usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre um número da linha usando um source file e um endereço de memória do pedaço :
Se o endereço de memória do pedaço for inexistente, atribua 0 ao número da linha; exit.
Lance um subtexto sobre o trecho deste source file.
Atribua 1 ao número da linha.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o first endereço de memória do pedaço deste subtexto for o endereço de memória do pedaço , cancele.
Se o conteúdo deste first endereço de memória do pedaço deste subtexto for o return pedaço, adicione 1 para o número da linha.
Adicione 1 para o first endereço de memória do pedaço deste subtexto.
Repita.

Etapas necessárias para que se encontre um source file usando um endereço de memória do pedaço :
Se o endereço de memória do pedaço for inexistente, esvazie o source file; exit.
Percorra.
Obtenha o source file desde o source files.
Se o source file for inexistente, cancele.
Se o endereço de memória do pedaço for menor do que o first deste trecho deste source file, repita.
Se o endereço de memória do pedaço for maior do que o last deste trecho deste source file, repita.

Etapas necessárias para que se encontre um type e um nickname usando um nome:
Esvazie o type.
Limpe o nickname.
Encontre o type e o nickname usando o nome (forward).
Se o type não for inexistente, cancele.
Encontre o type e o nickname usando o nome (backward).
\Lance um subtexto sobre o nome.
\Percorra.
\Se o subtexto estiver em branco, cancele.
\Encontre o type usando o subtexto e o catálogo de tipos.
\Se o type não for inexistente, pare.
\Skip para o next palavra no subtexto.
\Repita.
\Atribua o first deste nome para first deste uma segunda subtexto. \ pode estar errado
\Atribua o first endereço de memória do pedaço deste subtexto menos 2 ao last desta segunda subtexto.
\Se a segunda subtexto não estiver em branco, atribua a segunda subtexto ao nickname.
\Se a segunda subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre um type e um nickname usando um nome (backward):
Esvazie o type.
Limpe o nickname.
Lance um subtexto sobre o nome.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip para o previous palavra no subtexto.
Repita.
Atribua o last deste nome para o last desse segunda subtexto.
Atribua o last endereço de memória do pedaço deste subtexto mais 2 ao first desta segunda subtexto.
Se a segunda subtexto não estiver em branco, atribua a segunda subtexto ao nickname.
Se a segunda subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre um type e um nickname usando um nome (forward):
\ original - no mude
Esvazie o type.
Limpe o nickname.
Lance um subtexto sobre o nome.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip para o next palavra no subtexto.
Repita.
Atribua o first deste nome para o first desse segunda subtexto.
Atribua o first endereço de memória do pedaço deste subtexto menos 2 ao last desta segunda subtexto.
Se a segunda subtexto não estiver em branco, atribua a segunda subtexto ao nickname.
Se a segunda subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre uma variável usando um nome:
Se a rotina utilizada atualmente for inexistente, esvazie a variável; exit.
Encontre a variável usando o nome e os locals desta rotina utilizada atualmente.
Se a variável não for inexistente, cancele.
Encontre a variável usando o nome e os parâmetros desta rotina utilizada atualmente.
Se a variável não for inexistente, cancele.
Encontre a variável usando o nome e o catálogo de variáveis globais.
Se a variável não for inexistente, cancele.
Encontre a variável usando o nome e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se encontre uma variável usando um nome e umas variáveis:
Esvazie a variável.
Percorra.
Obtenha a variável desde o variáveis.
Se a variável for inexistente, cancele.
Se o nome desta variável for o nome, cancele.
Se o nickname desta variável for o nome, cancele.
Repita.

\Etapas necessárias para que se encontre uma variável usando um nome:
\Se a rotina utilizada atualmente for inexistente, esvazie a variável; exit.
\Encontre a variável usando o nome e os locals desta rotina utilizada atualmente.
\Se a variável não for inexistente, cancele.
\Encontre a variável usando o nome e os parâmetros desta rotina utilizada atualmente.
\Se a variável não for inexistente, cancele.
\Encontre a variável usando o nome e o catálogo de variáveis globais.
\Se a variável não for inexistente, cancele.
\ Encontre a variável usando o nome e o catálogo de variáveis hexadecimais.

\Etapas necessárias para que se encontre uma variável usando um nome e uns variáveis:
\esvazie a variável.
\Percorra.
\Obtenha a variável desde o variáveis.
\Se a variável for inexistente, cancele.
\Se o nome desta variável for o nome, cancele.
\Se o nickname desta variável for o nome, cancele.
\Repita.

An fragment é uma coisa com
\ we have three lists in the compiler memory  types, variables, and rotinas 
\ each rotina consists of a series of logical instructions called fragments. There are just 22 fragment types:
Uma etiqueta [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, Intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, rotina address],
Uma variável (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, rotina address, save eax],
Uma segunda variável (reference) [load address],
Uma rotina (reference) [call internal, rotina address],
Uma entry (reference) [call external],
Um número [increment],
Um detector [load eax], \SAL
Um endereço,
Um texto hexadecimal denominado código.

Etapas necessárias para que se gere um nome usando uma string:
Atribua a string ao nome.
Adicione 1 para a contagem de nomes deste compilador.
Converta a contagem de nomes deste compilador para uma segunda string.
Posponha a segunda string para o nome.

Etapas necessárias para que se obtenha um endereço usando uma rotina:
Se o endereço desta rotina não for 0, atribua o endereço desta rotina ao endereço; exit.
Atribua -1 ao endereço desta rotina.
Encontre uma segunda rotina usando o employs cabeçalho expandido desta rotina e o catálogo geral de rotinas.
Se a segunda rotina for inexistente, apresente uma mensagem de erro contendo "Eu não consegui encontrar uma tarefa: " junto com o employs cabeçalho expandido desta rotina seguido de "' que você está tentando employ." e o local de aparição desta rotina; exit.
Se o endereço desta segunda rotina for -1, apresente a mensagem de erro contendo "Referência recursiva na cláusula employ." e o local de aparição desta rotina; exit. \Bora traduzir
Obtenha o endereço usando a segunda rotina.
Atribua o endereço ao endereço desta rotina.

Etapas necessárias para que se obtenha uma contagem usando uns imports (all entries mais markers):
Atribua 0 à contagem.
Percorra.
Obtenha um import desde o imports.
Se o import for inexistente, cancele.
Adicione a contagem destas entries deste import para a contagem.
Adicione 1 para a contagem.
Repita.

Um global body é um subtexto.

O catálogo de variáveis globais é um catálogo.

An global é uma variável.

O globals são uns globals.

O image base é um endereço igual a 4194304 [$00400000].

O import zona é um zona.

Um import header é um conjunto com
Um endereço denominado original first previamente calculado, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-first-thunkoft-milad-kahsari-alhadi/
\ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft#:~:text=The%20original%20first%20thunk%20is,%2C%20user32%20etc)%20are%20known.
\Thunks are the defnitive pieces of codes em an operating system that handle the transitions between 16 and 32-bit código.
\ Thus they ensure backward compatibility between the calls made by the application.
\ O OS is subjected com this facility for backward compatibility, so that the 16 bit applications can run smoothly em 32 bit environment.
\ O original first thunk is needed if the imports are bound but the imported .DLL does not match.
\ On a fresh unpatched version of Windows, all addresses of all functions em the base .DLLs (ntdll, kernel32, user32 etc) are known.
\Take shell32 for example, it links para kernel32!CreateProcess and the true address of CreateProcess can be stored directly em shell32.
\This is denominado import binding and lets the loader skip the step where it looks para cima all the addresses of the imported functions.
\This does not work if the imported .DLL has not been loaded at its preferred address nor if the .DLL has changed (security update etc).
\If this happens seguido de the loader has para look para cima the functions "the normal way" and the original first thunk array has para be used
\ because that is the only place where the RVAs of the function names are stored.
\ If import binding is not used seguido de the original first thunk array is optional and might not be present.
\ ASLR has probably made this optimization irrelevant.
Um número denominado TimeStamp, \ Set para zero until bound; seguido de this feld is set para the TimeDateStamp of the exporting FileHeader da DLL
Um endereço denominado forwarder chain, \ Forwarder Chain: O 32-bit catálogo of the frst forwarder em the liste of imported functions
Um endereço denominado nome memory endereço, 
\It holds the RVA [Relative Virtual Address] of the dll para be loaded para memory. It is a dword value.
\It is comprised of : RVA = Image Base + Endian Order 
\Note: As we know OllyDbg gives the result em the Big Endian order where as the x86 architecture holds the endereço em the Little Endian order, 
\ so the Address gets exchanged reversibly em the di tuples
Um endereço denominado first previamente calculado memory endereço.
\ Once the API is linked and gets loaded para memory the frst previamente calculado which is a RVA points para the Import Enderece Table [IAT]

An import é uma coisa com
Um nome endereço,
Um header endereço,
Um nome,
Um import header,
Some entries.

O imports são uns imports.



Etapas necessárias para que se catalogue um global:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o global for inexistente, cancele.
Se o nome deste global estiver no catálogo de variáveis globais, apresente uma mensagem de erro contendo "'" junto com o nome deste global seguido de "' é uma variável global duplicada." e o local de aparição deste global; exit.
Catalogue o global usando o nome deste global e o catálogo de variáveis globais.

Etapas necessárias para que se catalogue um literal:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o literal for inexistente, cancele.
Se o nome deste literal estiver no catálogo de variáveis hexadecimais, apresente uma mensagem de erro contendo "Erro interno no nome do literal na função catálogo um literal" e o local de aparição deste literal; exit.
Catalogue o literal usando o nome deste literal e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se catalogue um cabeçalho semi-expandido usando um catálogo (special):
Encontre um refer usando o cabeçalho semi-expandido e o catálogo.
Se o refer não for inexistente, cancele.
Catalogue o cabeçalho semi-expandido no catálogo.

Etapas necessárias para que se catalogue uma rotina por utility use:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a rotina for inexistente, cancele.
Se o detector de função desta rotina estiver ativo, cancele.
Se a contagem destes parâmetros desta rotina for 0, cancele.
Copie os monikettes desta rotina para uns monikettes.
Reduce os monikettes por utility use.
Converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, cancele.
Encontre um refer usando o cabeçalho expandido e o catálogo de rotinas úteis.
Se o refer não for inexistente, atribua nil ao endereço de memória deste refer; exit.
Catalogue a rotina usando o cabeçalho expandido e o catálogo de rotinas úteis.

Etapas necessárias para que se catalogue uma rotina usando um cabeçalho expandido e um catálogo (special):
Encontre um refer usando o cabeçalho expandido e o catálogo.
Se o refer não for inexistente, atribua a rotina ao endereço de memória deste refer; exit.
Catalogue a rotina usando o cabeçalho expandido e o catálogo.

Etapas necessárias para que se catalogue uma rotina usando uns monikettes e um catálogo:
Se a rotina for inexistente, cancele.
Limpe um cabeçalho semi-expandido.
Percorra.
Obtenha um monikette desde os monikettes.
Se o monikette for inexistente, cancele.
Posponha o monikette para o cabeçalho semi-expandido.
Se o monikette for o last destes monikettes, pare.
Catalogue o cabeçalho semi-expandido usando o catálogo (special).
Repita.
Catalogue a rotina usando o cabeçalho semi-expandido como um cabeçalho expandido e o catálogo (special).

Etapas necessárias para que se catalogue uns rotinas por utility use:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma rotina desde as rotinas.
Se a rotina for inexistente, cancele.
Catalogue a rotina por utility use.
Repita.

Etapas necessárias para que se catalogue um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Catalogue o type usando o nome deste type.

Etapas necessárias para que se catalogue um type usando um nome:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Encontre um existing type usando o nome e o catálogo de tipos.
Se o existing type for inexistente, catalogue o type usando o nome e o catálogo de tipos; exit.
Atribua o local de aparição deste type para um local de aparição.
Se o local de aparição for inexistente, atribua o local de aparição deste existing type ao local de aparição. \ point o erro para um type no source código, not um generated type
Apresente uma mensagem de erro contendo "Acho que já vi o tipo: " junto com o nome seguido de "' em um lugar antes; você deve ter duplicado ele." e o local de aparição.



Etapas necessárias para que se inicialize o compilador:
\Sim, essa rotina é vazia, apenas para ficar "simétrico" nas chamadas de rotina

Etapas necessárias para que se inicialize o compilador usando um endereço da pasta:
Atribua o endereço da pasta ao endereço da pasta deste compilador.
Atribua 0 à contagem de nomes deste compilador.
Desative o detector de erros deste compilador.
Limpe a mensagem de erro deste compilador.
Limpe o endereço completo do arquivo de erro deste compilador.
Atribua 0 ao número da linha de erro deste compilador.
Esvazie a rotina utilizada atualmente.
Crie o catálogo de tipos com 13001 [buckets]. \ era 4027
Crie o catálogo de variáveis globais com 13001 [buckets]. \ era 4027
Crie o catálogo de variáveis hexadecimais com 13001 [buckets]. \ era 4027
Crie o catálogo geral de rotinas com 13001 [buckets]. \ era 7919
Crie o catálogo de rotinas úteis com 13001 [buckets]. \ era 4027

Etapas necessárias para que se inicialize um DOS header: \ vou alterar depois
Atribua 23117 [$5A4D] ao Signature deste DOS header.
Atribua 64 [$0040] ao addressofrelocationtableinfile deste DOS header. \ O ?addressofrelocationtableinfile? is a pointer para the variável-length de caracteres table of DLLs needed for this program.
Atribua 256 [$00000100] ao Address_Of_PE_Header_In_File deste DOS header. \O ?Address_Of_PE_Header_In_File? is a pointer para the ?PE Header?, a revised and extended version of the DOS Header introduced com advent of Windows. 
\O segunda 16 campos of the DOS Header are not used.

Etapas necessárias para que se inicialize um PE header:
Inicialize o PE header (standard header).
Inicialize o PE header (optional header).
Inicialize o PE header (version information).
Inicialize o PE header (directories).
Inicialize o PE header (import section).
Inicialize o PE header (data section).
Inicialize o PE header (Code Section).

Etapas necessárias para que se inicialize um PE header (Code Section):
Copie pedaços desde "código "'s first para o endereçamento deste nome desta Code Section deste PE header por 6.
Atribua a quantidade de caracteres desta zona de código ao SizeInBytes desta Code Section deste PE header.
Atribua o endereço base desta zona de código ao AddressInMemory desta Code Section deste PE header.
Atribua a quantidade de caracteres desta zona de código ao SizeInFile desta Code Section deste PE header.
Atribua o endereço base desta zona de código ao AddressInFile desta Code Section deste PE header.
Atribua -536870880 [$E0000020 ] para as Characteristics desta Code Section deste PE header. \ executable, readable, writable, code object
\IMAGE_FILE_LARGE_ADDRESS_ AWARE 0x0020 - Application can handle > 2-GB addresses.


Etapas necessárias para que se inicialize um PE header (data section):
Copie pedaços desde "data "'s first para o endereçamento deste nome desta data section deste PE header por 6.
Atribua a quantidade de caracteres desta zona de dados ao SizeInBytes desta data section deste PE header.
Atribua o endereço base desta zona de dados ao AddressInMemory desta data section deste PE header.
Atribua a quantidade de caracteres desta zona de dados ao SizeInFile desta data section deste PE header.
Atribua o endereço base desta zona de dados ao AddressInFile desta data section deste PE header.
Atribua -1073741760 [$C0000040] para as Characteristics desta data section deste PE header. \ initialized, readable, writable

Etapas necessárias para que se inicialize um PE header (directories):
Atribua 16 [$00000010] ao numberofdirectories deste PE header.
Atribua o endereço base desta import zona ao imagedirectoryentryimportaddress deste PE header.
Atribua a quantidade de caracteres desta import zona ao ImageDirectoryEntryImportSize deste PE header.

Etapas necessárias para que se inicialize um PE header (import section):
Copie pedaços desde "idata "'s first para o endereçamento deste nome desta idata section deste PE header por 6.
Atribua a quantidade de caracteres desta import zona ao SizeInBytes desta idata section deste PE header.
Atribua o endereço base desta import zona ao AddressInMemory desta idata section deste PE header.
Atribua a quantidade de caracteres desta import zona ao SizeInFile desta idata section deste PE header.
Atribua o endereço base desta import zona ao AddressInFile desta idata section deste PE header.
Atribua -1073741760 [$C0000040] para as Characteristics desta idata section deste PE header. \ initialized, readable, writable

Etapas necessárias para que se inicialize um PE header (optional header):
Atribua 267 [$010B] ao magicnumber deste PE header.
Atribua a quantidade de caracteres desta zona de código ao SizeOfCodeInFile deste PE header.
Atribua a quantidade de caracteres desta zona de dados ao SizeOfInitializedDataInFile deste PE header.
Atribua 0 ao SizeOfUninitializedDataInFile deste PE header.
Encontre uma rotina usando "~initialize before run e run e finalize after run" e o catálogo geral de rotinas.
Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno: não achei a tarefa de inicialização"; exit.
Atribua o endereço desta rotina menos o image base ao AddressOfEntryPointInMemory deste PE header.
Atribua o endereço base desta zona de código ao AddressOfCodeInMemory deste PE header.
Atribua o endereço base desta zona de dados ao AddressOfInitializedDataInMemory deste PE header.
Atribua o image base à imagebase deste PE header.
Atribua 4096 [$00001000] ao MemoryAlignment deste PE header.
Atribua 4096 [$00001000] ao FileAlignment deste PE header.
Atribua 0 ao Reserved deste PE header.
Atribua o exe size deste compilador ao SizeOfImageInMemory deste PE header.
Atribua 4096 [section base] ao SizeOfAllHeadersInFile deste PE header.
Atribua 0 ao checksum deste PE header.
Atribua 0 para as DllCharacteristics deste PE header.
Atribua 1048576 [$00100000] ao MaxStack deste PE header.
Atribua 16384 [$00004000] ao MinStack deste PE header.
Atribua 1048576 [$00100000] ao MaxHeap deste PE header.
Atribua 16384 [$00004000] ao MinHeap deste PE header.
Atribua 0 ao loaderflags deste PE header.

Etapas necessárias para que se inicialize um PE header (standard header):
Atribua 17744 [$00004550] ao Signature deste PE header.
Atribua 332 [$014C] ao MachineType deste PE header.
Atribua 3 [$0003] ao NumberOfSections deste PE header.
Atribua 0 ao TimeStamp deste PE header.
Atribua 0 ao PointerToSymbolTable deste PE header.
Atribua 0 ao NumberOfSymbols deste PE header.
Atribua 224 [$00E0] ao SizeOfOptionalHeaderInBytes deste PE header.
Atribua 33166 [$818E] às Characteristics deste PE header.

Etapas necessárias para que se inicialize um PE header (version information):
Atribua 0 ao MajorLinkerVersion deste PE header.
Atribua 0 ao MinorLinkerVersion deste PE header.
Atribua 4 [$0004] ao OS_MajorVersion deste PE header.
Atribua 0 [$0000] ao OS_MinorVersion deste PE header.
Atribua 0 ao UserMajorVersion deste PE header.
Atribua 0 ao UserMinorVersion deste PE header.
Atribua 4 [$0004] ao SubsystemMajorVersion deste PE header.
Atribua 0 [$0000] ao SubsystemMinorVersion deste PE header.
Atribua 2 [$0002] ao Subsystem deste PE header.


Um intermediate é um local.



Etapas necessárias para que se link:
Arredonde para cima zona sizes.
Inicialize um DOS header.
Inicialize um PE header.
Fill o exe deste compilador com o null pedaço usando o exe size deste compilador.
Disponibilize o DOS header ao exe deste compilador.
Disponibilize o PE header ao exe deste compilador.
Disponibilize os imports ao exe deste compilador.
Disponibilize os globals ao exe deste compilador.
Disponibilize os literals ao exe deste compilador.
Disponibilize as rotinas ao exe deste compilador.



Etapas necessárias para que se liste tudo:
Limpe o listagem deste compilador.
Liste a mensagem de erro deste compilador na listagem deste compilador.
Liste os types depois de "TYPES:" na listagem deste compilador.
Liste os globals depois de "GLOBALS:" na listagem deste compilador.
Liste os literals depois de "LITERALS:" na listagem deste compilador.
Liste as rotinas depois de "rotinas:" na listagem deste compilador.
Liste o catálogo de tipos depois de "TYPE INDEX:" na listagem deste compilador.
Liste o catálogo de variáveis globais depois de "GLOBAL INDEX:" na listagem deste compilador.
Liste o catálogo de variáveis hexadecimais depois de "LITERAL INDEX:" na listagem deste compilador.
Liste o catálogo geral de rotinas depois de "rotina INDEX:" na listagem deste compilador.
Liste o catálogo de rotinas úteis depois de "Catálogo de Rotinas Úteis:" na listagem deste compilador.
Liste o imports depois de "IMPORTS:" na listagem deste compilador.
Liste o source files depois de "SOURCE FILES:" na listagem deste compilador.
Liste os temporizadores depois de "TIMERS:" na listagem deste compilador.
Escreva o listagem deste compilador para o listagem endereço completo deste compilador.

Etapas necessárias para que se liste um mensagem de erro em um trecho:
Se o mensagem de erro estiver em branco, cancele.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" para o trecho.
Advance o trecho (twice).
Posponha o mensagem de erro para o trecho.
Advance o trecho (twice).

Etapas necessárias para que se liste um bucket em um trecho:
Se os refers deste bucket estiverem vazio, cancele.
Posponha "/bucket" para o trecho (com separator).
Advance o trecho.
Liste os refers deste bucket no trecho.
Advance o trecho.

Etapas necessárias para que se liste uns entries em um trecho:
Obtenha um entry desde as entries.
Se a entry for inexistente, cancele.
Liste a entry no trecho.
Repita.

Etapas necessárias para que se liste um entry em um trecho:
Se a entry for inexistente, cancele.
Posponha "/entry" para o trecho (com separator).
Posponha o nome desta entry para o trecho (com separator).
Posponha o endereço desta entry para o trecho (as hex com separator).
Advance o trecho.

Etapas necessárias para que se liste um fragment em um trecho:
Posponha "/fragment" para o trecho (com separator).
Posponha a etiqueta deste fragment para o trecho (as um fragment etiqueta string com separator).
Posponha a variável deste fragment para o trecho (com separator).
Posponha a segunda variável deste fragment para o trecho (com separator).
Posponha a rotina deste fragment para o trecho (com separator).
Posponha a entry desta fragment para o trecho (com separator).
Posponha o número deste fragment para o trecho (as hex com separator).
Posponha o endereço deste fragment para o trecho (as hex com separator).
Converta o código deste fragment para um cifra hexadecimal.
Posponha a cifra hexadecimal para o trecho (com separator).
Advance o trecho.

Etapas necessárias para que se liste uns fragments em um trecho:
Obtenha um fragment desde o fragments.
Se o fragment for inexistente, cancele.
Liste o fragment no trecho.
Repita.

Etapas necessárias para que se liste um import em um trecho:
Se o import for inexistente, cancele.
Posponha "/import" para o trecho (com separator).
Posponha o nome deste import para o trecho (com separator).
Advance o trecho.
Liste as entries deste import no trecho.
Advance o trecho.

Etapas necessárias para que se liste uns imports em um trecho:
Obtenha um import desde o imports.
Se o import for inexistente, cancele.
Liste o import no trecho.
Repita.

Etapas necessárias para que se liste uns imports depois de uma string em um trecho:
Posponha a string para o trecho.
Advance o trecho (twice).
Se o imports estiverem vazio, cancele.
Liste o imports no trecho.

Etapas necessárias para que se liste um catálogo em um trecho:
Posponha "/" junto com o used contagem de buckets deste catálogo seguido de " buckets" para o trecho (com separator).
Posponha a contagem deste catálogo seguido de " refers" para o trecho (com separator).
Advance o trecho (twice).
Percorra.
Obtenha um bucket usando o catálogo.
Se o bucket for inexistente, cancele.
Liste o bucket no trecho.
Repita.

Etapas necessárias para que se liste um catálogo depois de uma string em um trecho:
Posponha a string para o trecho.
Advance o trecho (twice).
Se o catálogo estiver vazio, cancele.
Liste o catálogo no trecho.

Etapas necessárias para que se liste um refer em um trecho:
Se o refer for inexistente, cancele.
Posponha "/refer" para o trecho (com separator).
Posponha a string deste refer para o trecho.
Se o endereço de memória deste refer for inexistente, posponha "..." para o trecho.
Posponha "/" para o trecho.
Advance o trecho.

Etapas necessárias para que se liste uns refers em um trecho:
Obtenha um refer desde o refers.
Se o refer for inexistente, cancele.
Liste o refer no trecho.
Repita.

Etapas necessárias para que se liste uma rotina em um trecho:
Se a rotina for inexistente, cancele.
Posponha "/rotina" para o trecho (com separator).
Posponha o cabeçalho expandido desta rotina para o trecho (com separator).
Posponha o compiled detector desta rotina para o trecho (com separator).
Posponha o detector de compatibilidade desta rotina para o trecho (com separator).
Posponha o detector de deliberação desta rotina para o trecho (com separator).
Posponha o detector de função desta rotina para o trecho (com separator).
Posponha o employs cabeçalho expandido desta rotina para o trecho (com separator).
Posponha o parâmetro size desta rotina para o trecho (com separator).
Posponha o local size desta rotina para o trecho (com separator).
Posponha o endereço desta rotina para o trecho (as hex com separator).
Advance o trecho.
Liste os parâmetros desta rotina no trecho.
Liste os locals desta rotina no trecho.
Liste os fragments desta rotina no trecho.
Advance o trecho.

Etapas necessárias para que se liste uns rotinas em um trecho:
Obtenha uma rotina desde as rotinas.
Se a rotina for inexistente, cancele.
Liste a rotina no trecho.
Repita.

Etapas necessárias para que se liste uns rotinas depois de uma string em um trecho:
Posponha a string para o trecho.
Advance o trecho (twice).
Se as rotinas estiverem vazio, cancele.
Liste as rotinas no trecho.

Etapas necessárias para que se liste um source file em um trecho:
Se o source file for inexistente, cancele.
Posponha "/source file" para o trecho (com separator).
Posponha o endereço completo deste source file para o trecho (com separator).
Advance o trecho.

Etapas necessárias para que se liste uns source files em um trecho:
Obtenha um source file desde o source files.
Se o source file for inexistente, cancele.
Liste o source file no trecho.
Repita.

Etapas necessárias para que se liste uns source files depois de uma string em um trecho:
Posponha a string para o trecho.
Advance o trecho (twice).
Se o source files estiverem vazio, cancele.
Liste o source files no trecho.
Advance o trecho.

Etapas necessárias para que se liste um temporizador usando uma string em um trecho:
Posponha "/timer" para o trecho (com separator).
Posponha a string para o trecho (com separator).
Posponha a string deste temporizador para o trecho (com separator).
Advance o trecho.

Etapas necessárias para que se liste os temporizadores depois de uma string em um trecho:
Posponha a string para o trecho.
Advance o trecho (twice).
Liste o temporizador de operacionalização usando "carregando" no trecho.
Liste o temporizador de análise/verificação usando "examinando" no trecho.
Liste o temporizador de resolução de tipos usando "resolvendo tipos" no trecho.
Liste o temporizador de resolução de variáveis globais usando "resolvendo globais" no trecho.
Liste o temporizador de compilação de cabeçalhos de rotina usando "compilando cabeçalhos de rotinas" no trecho.
Liste o temporizador de etapas de cálculo usando "calculando" no trecho.
Liste o temporizador de adição de rotinas pré-definidas de mémoria  usando "adding built-in memory rotinas" no trecho.
Liste o temporizador de ferramentas de catalogação usando "indexing utilities" no trecho.
Liste o temporizador de compilação do conteúdo das rotinas usando "compiling rotina bodies" no trecho.
Liste o temporizador de adição de rotinas pré-definidas de inicialização usando "adding built-in startup rotina" no trecho.
Liste o temporizador de deslocamentos usando "offsetting" no trecho.
Liste o temporizador de endereçamento usando "addressing" no trecho.
Liste o temporizador de transmutação usando "transmogrifying" no trecho.
Liste o temporizador de vinculação usando "linking" no trecho.
Liste o temporizador de escrita usando "gravando" no trecho.
Liste o temporizador deste compilador usando "total" no trecho.
Advance o trecho.

Etapas necessárias para que se liste um type em um trecho:
Se o type for inexistente, cancele.
Posponha "/type" para o trecho (com separator).
Posponha o nome deste type para o trecho (com separator).
Posponha o plural nome deste type para o trecho (com separator).
Posponha a quantidade de caracteres deste type para o trecho (as hex com separator).
Posponha o base nome deste type para o trecho (com separator).
Posponha o base type deste type para o trecho (com separator).
Posponha o conteúdo nome deste type para o trecho (com separator).
Posponha o conteúdo type deste type para o trecho (com separator).
Posponha a scale deste type para o trecho (com separator).
Advance o trecho.
Liste os campos deste type no trecho.
Advance o trecho.

Etapas necessárias para que se liste uns types em um trecho:
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Liste o type no trecho.
Repita.

Etapas necessárias para que se liste uns types depois de uma string em um trecho:
Posponha a string para o trecho.
Advance o trecho (twice).
Se os types estiverem vazio, cancele.
Liste os types no trecho.

Etapas necessárias para que se liste uma variável em um trecho:
Se a variável for inexistente, cancele.
Posponha "/variável" para o trecho (com separator).
Posponha o categoria desta variável para o trecho (com separator).
Posponha o compiled detector desta variável para o trecho (com separator).
Posponha o nome desta variável para o trecho (com separator).
Posponha o nickname desta variável para o trecho (com separator).
Posponha o type nome desta variável para o trecho (com separator).
Posponha o type desta variável para o trecho (com separator).
Posponha o endereço desta variável [or offset] para o trecho (as hex com separator).
Posponha o by-value detector desta variável para o trecho (com separator).
Posponha a contagem desta variável para o trecho (com separator).
Posponha o reference detector desta variável para o trecho (com separator).
Posponha o redefinition conteúdo nome desta variável para o trecho (com separator).
Posponha o literal desta variável para o trecho (com separator).
Converta o data desta variável para um cifra hexadecimal.
Posponha a cifra hexadecimal para o trecho (com separator).
Advance o trecho.

Etapas necessárias para que se liste uns variáveis em um trecho:
Obtenha uma variável desde o variáveis.
Se a variável for inexistente, cancele.
Liste a variável no trecho.
Repita.

Etapas necessárias para que se liste uns variáveis depois de uma string em um trecho:
Posponha a string para o trecho.
Advance o trecho (twice).
Se o variáveis estiverem vazio, cancele.
Liste o variáveis no trecho.
Advance o trecho.

O catálogo de variáveis hexadecimais é um catálogo.

An literal é uma variável.

O literals são uns literals.

An local é uma variável.

Um local de aparição é um endereço de memória do pedaço .

Um cabeçalho expandido é uma string.  \ moniker
\https://docs.microsoft.com/en-us/windows/win32/com/monikers
\ A cabeçalho expandido is the internal representation of a cabeçalho de rotina com
\ ? no articles preceding parameter types,
\ ? parameter types in square brackets, and
\ ? expanded prepositions.
\ Each piece of a cabeçalho expandido is a monikette. For example:
\ cabeçalho de rotina: To add a number to a count:
\ Moniker: add [number] para [count]
\ Monikettes: (1) add (2) [number] (3) para (4) [count]
 \ We use this internal representation because it...
\ ? makes it easy reduce types (like [count] to [number]) when looking for an appropriate rotina to call;
\ ? makes it easy to expand prepositions (like "to" para "para"); and
\ ? shows how the compiler interpreted various phrases in error messages.
Um monikette é uma coisa com
Um string,
Um type (reference),
Um variável (reference),
\ por bubbling
Um type atual (reference),
Um subtexto atual.

Um cabeçalho semi-expandido é um cabeçalho expandido.

Etapas necessárias para que se mova um percorredor (comentários):
Avance o percorredor.
Se o segmento final deste percorredor estiver em branco, cancele.
Se o conteúdo deste first deste segmento final deste percorredor não for o return pedaço, repita.

Etapas necessárias para que se mova um percorredor (símbolos conectivos):
Avance o percorredor.
Se o segmento final deste percorredor estiver em branco, cancele.
Se o percorredor estiver sobre algum tipo de possessive, cancele.
Se o conteúdo deste first deste segmento final deste percorredor for algum tipo de glom pedaço, repita.

Etapas necessárias para que se mova um percorredor (código rules - mark):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (caracteres irrelevantes):
Avance o percorredor.
Se o segmento final deste percorredor estiver em branco, cancele.
Se o conteúdo deste first deste segmento final deste percorredor for irrelevante, repita.

Etapas necessárias para que se mova um percorredor (possessivo inglês):
Avance o percorredor.
Se o segmento final deste percorredor estiver em branco, cancele.
Se o segmento final deste percorredor começa com "s", avance o percorredor.

Etapas necessárias para que se mova um percorredor (qualificadores):
Se o segmento final deste percorredor estiver em branco, cancele.
Se o conteúdo deste first deste segmento final deste percorredor for o return pedaço, pare.
Se o conteúdo deste first deste segmento final deste percorredor for o parênteses esquerdo, adicione 1 para uma contagem.
Se o conteúdo deste first deste segmento final deste percorredor for o parênteses direito, subtraia 1 desde a contagem.
Avance o percorredor.
Se a contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (observações):
Se o segmento final deste percorredor estiver em branco, cancele.
Se o conteúdo deste first deste segmento final deste percorredor for o return pedaço, pare.
Se o conteúdo deste first deste segmento final deste percorredor for o colchete esquerdo, adicione 1 para uma contagem.
Se o conteúdo deste first deste segmento final deste percorredor for o colchete direito, subtraia 1 desde a contagem.
Avance o percorredor.
Se a contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (conteúdo de texto):
Avance o percorredor.
Se o segmento final deste percorredor estiver em branco, cancele.
Se o conteúdo deste first deste segmento final deste percorredor for o return pedaço, cancele.
Se o percorredor estiver sobre algum tipo de nested double-quote, avance o percorredor; repita.
Se o conteúdo deste first deste segmento final deste percorredor for as aspas duplas, avance o percorredor; exit.
Repita.

Etapas necessárias para que se mova um percorredor (símbolos):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (englobando tudo):
Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
Se o segmento final deste percorredor estiver em branco, cancele.
Se o conteúdo deste first deste segmento final deste percorredor for irrelevante, mova o percorredor (caracteres irrelevantes); exit.
Se o conteúdo deste first deste segmento final deste percorredor for a barra invertida, mova o percorredor (comentários); exit.
Se o conteúdo deste first deste segmento final deste percorredor for o colchete esquerdo, mova o percorredor (observações); exit.
Se o conteúdo deste first deste segmento final deste percorredor for as aspas duplas, mova o percorredor (conteúdo de texto); exit.
Se o conteúdo deste first deste segmento final deste percorredor for o parênteses esquerdo, mova o percorredor (qualificadores); exit.
Se o conteúdo deste first deste segmento final deste percorredor for algum tipo de mark, mova o percorredor (código rules - mark); exit.
Se o percorredor estiver sobre algum tipo de possessive, mova o percorredor (possessivo inglês); exit.
Mova o percorredor (símbolos conectivos).

Etapas necessárias para que se mova um percorredor (usando diretrizes do compilador): \ talvez aqui conserte o subtraia
Se o detector de erros deste compilador estiver ativo, limpe o segmento inicial deste percorredor; exit.
Mova o percorredor devolvendo um erro string (englobando tudo).
Se o erro string não estiver em branco, apresente uma mensagem de erro contendo o erro string e o first deste segmento inicial deste percorredor; exit.
\Se o segmento inicial deste percorredor for "del", recue o percorredor; exit. \ Spanish contraction "del"; fudged para "de l", short por "de el"
\Se o segmento inicial deste percorredor for algum tipo de contração de preposição com artigo definido, determine se essa contração precisa ser desfeita usando o percorredor. \ Spanish contraction "al"; fudged para "a l", short por "a el"
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o conteúdo deste first deste segmento inicial deste percorredor for irrelevante, repita.
Se o conteúdo deste first deste segmento inicial deste percorredor for a barra invertida, repita.
Se o conteúdo deste first deste segmento inicial deste percorredor for o colchete esquerdo, repita.

Etapas necessárias para que se mova um percorredor devolvendo um erro string (diretrizes de validação de qualificadores):
Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Qualificadores devem terminar com parêntese ')'." ao erro string; exit.
Se o conteúdo deste last deste segmento inicial deste percorredor não for o parênteses direito, atribua "Qualificadores precisam terminar com um parêntese ')'." ao erro string; exit.

Etapas necessárias para que se mova um percorredor devolvendo um erro string (diretrizes de validação de observações):
Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Observações devem terminar com um colchete ']'." ao erro string; exit.
Se o conteúdo deste last deste segmento inicial deste percorredor não for o colchete direito, atribua "Observações precisam terminar com um colchete ']'." ao erro string; exit.

Etapas necessárias para que se mova um percorredor devolvendo um erro string (diretrizes de validação de conteúdos de texto):
Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2, atribua "Textos precisam terminar com aspas: ""." ao erro string; exit.
Se o conteúdo deste last deste segmento inicial deste percorredor não for as aspas duplas, atribua "Textos devem terminar com aspas: ""." ao erro string; exit.

Etapas necessárias para que se mova um percorredor devolvendo um erro string (englobando tudo):
Limpe o erro string.
Mova o percorredor (englobando tudo).
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o conteúdo deste first deste segmento inicial deste percorredor for o colchete esquerdo, mova o percorredor devolvendo o erro string (diretrizes de validação de observações); exit.
Se o conteúdo deste first deste segmento inicial deste percorredor for as aspas duplas, mova o percorredor devolvendo o erro string (diretrizes de validação de conteúdos de texto); exit.
Se o conteúdo deste first deste segmento inicial deste percorredor for o parênteses esquerdo, mova o percorredor devolvendo o erro string (diretrizes de validação de qualificadores); exit.

Um parte da cifra binária é um subtexto.

Um nickname é um nome.



Etapas necessárias para que se offset o locals em uma rotina:
Se a rotina for inexistente, cancele.
Se a compiled detector desta rotina não estiver ativo, cancele.
Limpe o local size desta rotina.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um local desde os locals desta rotina.
Se o local for inexistente, cancele.
Se o previous deste local não for inexistente, atribua o offset deste previous deste local ao offset deste local.
Atribua a quantidade de caracteres deste type deste local para uma quantidade de caracteres.
Se a categoria deste local for "scratch", atribua a magnitude desse endereço de memória ao quantidade de caracteres.
Arredonde a quantidade de caracteres para cima para o múltiplo imediato of 4.
Subtraia a quantidade de caracteres desde o offset deste local.
Adicione a quantidade de caracteres para o local size desta rotina.
Repita.

Etapas necessárias para que se offset os locals em uns rotinas:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma rotina desde as rotinas.
Se a rotina for inexistente, cancele.
Offset os locals na rotina.
Repita.

Etapas necessárias para que se offset o parâmetros em uma rotina:
Se a rotina for inexistente, cancele.
Se a compiled detector desta rotina não estiver ativo, cancele.
Limpe o parâmetro size desta rotina.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um parâmetro desde os parâmetros desta rotina.
Se o parâmetro for inexistente, cancele.
Se o detector de compatibilidade desta rotina estiver ativo, acione o by-value detector deste parâmetro.
Se o previous deste parâmetro for inexistente, atribua 8 ao offset deste parâmetro. \ skip o return address e saved ebp
Se o previous deste parâmetro não for inexistente, atribua o offset deste previous deste parâmetro mais 4 ao offset deste parâmetro. \ all parâmetros são 4 endereço de memória do pedaço s ou 4 pedaço values por callbacks
Adicione 4 para a parâmetro size desta rotina.
Repita.

Etapas necessárias para que se offset o parâmetros em umas rotinas:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma rotina desde as rotinas.
Se a rotina for inexistente, cancele.
Offset o parâmetros na rotina.
Repita.



Um parâmetro é uma variável.

Um PE header é um conjunto com
\ O formato Portable Executable (PE) éum formato de arquivos executáveis / dll files que apareceu no Windows NT. 
\ELe é baseado na especificação COFF (Common Object File Format).
\Pra manter a compatibilidade como MS-DOS e Windows, o formato de arquivo PE mantém o antigo cabeçalho MZ do MS-DOS.
\ Ele é organizado como um fluxo linear de dados.
\ Começando com um cabçalho do MS-DOS, um real-mode program stub, e uma assinatura de arquivo PE. 
\ Logo em seguida vem o cabçalho do arquivo PE podendo também haver um cabeçalho opcional.
\ Além disso temos o cabeçalho de cada seção, seguido pelo corpo de cada seção. 
\Encerrando o arquivo existem regiões adicionais com informações variadas
\ tipo informações de relocação, tabela de símbolos, número de linhas e dados da tabela de strings. 
\ O cabeçalho MS-DOS ocupa os primeiros 64 bytes do arquivo. A estrutura básica está representada abaixo:
Um número denominado Signature,
Um wyrd denominado MachineType, 
\ O número que identifica o tipo de computador de destino. 
\Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#machine-types
Um wyrd denominado NumberOfSections,
\ O número de seções. Isso indica o tamanho da tabela da seção, que segue imediatamente os cabeçalhos.
Um número denominado TimeStamp, 
\ Os 32 low bits do número de segundos que se passaram desde 00:00 horas do dia 01/01/1970. (um valor time_t de tempo de execução do C)
\ serve pra indicar quando o arquivo foi criado.
Um número denominado PointerToSymbolTable, 
\ O número do deslocamento de arquivo da tabela de símbolos COFF ou 
\ o numero zero se nenhuma tabela de símbolos COFF estiver presente. 
\ Esse valor deve ser zero para uma imagem porque as informações de depuração de COFF foram descontinuadas.
Um número denominado NumberOfSymbols, 
\ O número de entradas na tabela de símbolos.
\ Esses dados podem ser usados para localizar a tabela de cadeia de caracteres, que segue imediatamente a tabela de símbolos.
\ Esse valor deve ser zero para uma imagem porque as informações de depuração de COFF foram descontinuadas.
Um wyrd denominado SizeOfOptionalHeaderInBytes,
 \ O tamanho do header opcional, que é necessário para arquivos executáveis, mas não para arquivos de objeto.
\ Esse valor deve ser zero para um arquivo-objeto. Para ver uma descrição do formato do header, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#optional-header-image-only
Um wyrd denominado Characteristics, 
\ Os sinalizadores que indicam os atributos do arquivo. 
\Para valores de sinalizador específicos, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#Characteristics
\ optional header
Um wyrd denominado MagicNumber, 
\O número mágico do cabeçalho opcional determina se uma imagem é um PE32 ou PE32 + executável.
\ As imagens PE32 + permitem um espaço de endereço de 64 bits, limitando o tamanho da imagem a 2 gigabytes. 
\ Outras modificações PE32 + são abordadas em suas respectivas seções.
\ É um inteiro sem sinal que identifica o estado do arquivo de imagem. 
\ O valor mais comum é 0x10B, que o identifica como um arquivo executável normal. 
\0x107 o identifica como uma imagem de ROM e 0x20B a identifica como um PE32 + executável.
\ Esse campo é usado para identificar arquivos compatíveis com o tipo de arquivo do MS-DOS. 
\ Os executáveis compatíveis com MS-DOS usam o valor 0x5A4D, que é o valor das letras MZ na tabela ASCII
Um pedaço denominado MajorLinkerVersion, 
\ Indica a version do linker que vinculou a imagem - O número da versão principal do vinculador.
Um pedaço denominado MinorLinkerVersion, 
\ Indica a version do linker que vinculou a imagem - O número da versão secundária do vinculador.
Um número denominado SizeOfCodeInFile, 
\O tamanho da seção de código (texto) ou a soma de todas as seções de código se houver várias seções.
Um número denominado SizeOfInitializedDataInFile,
 \ O tamanho da seção de dados inicializados ou a soma de todas essas seções, se houver várias seções de dados.
Um número denominado SizeOfUninitializedDataInFile, 
\ O tamanho da seção de dados não inicializado (BSS) ou a soma de todas essas seções, se houver várias seções BSS.
Um número denominado AddressOfEntryPointInMemory, 
\Esse campo indica a localização do fim da Import Address Table (IAT). 
\ É um número que contém endereço do ponto de entrada relativo à imagem base quando o arquivo executável é carregado na memória. 
\Para imagens de programa, esse é o endereço inicial. 
\Para drivers de dispositivo, esse é o endereço da função de inicialização. 
\Um ponto de entrada [entry point] é opcional para DLLs. 
\Quando nenhum ponto de entrada está presente, esse campo deve ser zero.
Um número denominado AddressOfCodeInMemory,  [BaseOfCode]
\ O endereço relativo à base da imagem da seção de início de código quando ela é carregada na memória.
Um número denominado AddressOfInitializedDataInMemory, [BaseOfData]
\ O endereço relativo à base da imagem da seção de início de dados quando ela é carregada na memória.
Um número denominado ImageBase, 
\ O endereço preferencial do primeiro byte de imagem quando carregado na memória; deve ser um múltiplo de 64 K. 
\O padrão para DLLs é 0x10000000. o padrão para Windows CE EXEs é 0x00010000. 
\ O padrão para Windows NT, Windows 2000, Windows XP, Windows 95, Windows 98 e Windows Me é 0x00400000.
Um número denominado MemoryAlignment, [SectionAlignment]
\ O alinhamento (em bytes) das seções quando elas são carregadas na memória. 
\Ele deve ser maior ou igual a FileAlignment. 
\O padrão é o tamanho da página para a arquitetura.
Um número denominado FileAlignment, 
\ O fator de alinhamento (em bytes) usado para alinhar os dados brutos das seções no arquivo de imagem. 
\O valor deve ser uma potência de 2 entre 512 e 64 K, inclusive. O padrão é 512. 
\Se SectionAlignment for menor que o tamanho da página da arquitetura, FileAlignment deverá corresponder a SectionAlignment.
Um wyrd denominado OS_MajorVersion, [MajorOperatingSystemVersion]
\ O número de versão principal do sistema operacional Windows NT.
Um wyrd denominado OS_MinorVersion, [MinorOperatingSystemVersion]
\ O número de versão secundária do sistema operacional necessário.
Um wyrd denominado UserMajorVersion,  [MajorImageVersion]
\ O número de versão principal do programa.
Um wyrd denominado UserMinorVersion, [MinorImageVersion]
 \ O número de versão secundária do programa.
Um wyrd denominado SubsystemMajorVersion, [MajorSubsystemVersion]
\ O número de versão principal do subsistema Win32 do Windows NT.
Um wyrd denominado SubsystemMinorVersion, [MinorSubsystemVersion]
\ O número de secundária principal do subsistema.
Um número denominado Reserved,  [Win32VersionValue]
\ Reservado, deve ser zero. Unknown purpose, currently not used by the system and set para zero by the linker.
Um número denominado SizeOfImageInMemory, [SizeOfImage]
\ O tamanho (em bytes) da imagem, incluindo todos os headers, pois a imagem é carregada na memória. Ele deve ser um múltiplo de SectionAlignment.
\ Indicates the amount of address space para reserve em the address space for the loaded executable image. 
\This number is influenced greatly by SectionAlignment. 
\For example, consider a system having a fixed page size of 4096 bytes. 
\If you have an executable com 11 sections, each less than 4096 bytes, aligned sobre a 65,536-byte boundary, the SizeOfImage campo would be set para 11 * 65,536 = 720,896 (176 pages). 
\O same file linked com 4096-byte alignment would result em 11 * 4096 = 45,056 (11 pages) for the SizeOfImage campo. 
\This is a simple example em which each section requires less than a page of memory. 
\In reality, the linker determines the exact SizeOfImage by figuring each section individually. 
\It first determines how many bytes the section requires, seguido de it rounds para cima para the nearest page boundary, and finally it rounds page count para the nearest SectionAlignment boundary. 
\O total is seguido de the sum of each individual requirement da section.
Um número denominado SizeOfAllHeadersInFile, [SizeOfHeaders]
\ O tamanho combinado de um stub do MS-DOS, o header PE e os headers da seção arredondados para um múltiplo de FileAlignment.
\ This campo indicates how much space em the file is used for representing all the file headers, 
\ including the MS-DOS header, PE file header, PE optional header, and PE Section Headers. O section bodies begin at this location em the file.
Um número denominado CheckSum, 
\ A verificação de arquivo de imagem. 
\O algoritmo para calcular a verificação é incorporado em IMAGHELP.DLL. 
\Os seguintes são verificados quanto à validação no tempo de carregamento: 
\todos os drivers, qualquer DLL carregada no momento da inicialização e qualquer DLL carregada em um processo Windows crítico.
\ A checksum value is used para validate the executable file at load time. 
\ O value is set and verified by the linker. O algorithm used for creating these checksum values is proprietary information and will not be published.
Um wyrd denominado Subsystem, 
\ Field used para identify the target Subsystem for this executable O subsistema necessário para executar esta imagem. 
\Each of the possible Subsystem values are listed em the WINNT.H file immediately after the IMAGE_OPTIONAL_HEADER structure.
\Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#windows-Subsystem
Um wyrd denominado DllCharacteristics,
 \ Flags used para indicate if a DLL image includes entry points for process and thread initialization and termination.
\ Para obter mais informações, consulte https://docs.microsoft.com/pt-br/windows/win32/debug/pe-format#dll-Characteristics
Um número denominado MaxStack, [SizeOfStackReserve]
\These fields control the amount of address space para reserve and commit for the stack and default heap. 
\ O tamanho da pilha a ser reservada. Somente SizeOfStackCommit está comprometido; 
\o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.
Um número denominado MinStack, [SizeOfStackCommit]
\Both the stack and heap have default values of 1 page committed and 16 pages Reserved. 
\ O tamanho da pilha a ser confirmada.
Um número denominado MaxHeap, [SizeOfHeapReserve]
\These values are set com the linker switches -STACKSIZE: and -HEAPSIZE:. 
\O tamanho do espaço de heap local a ser reservado. 
\Somente SizeOfHeapCommit está comprometido; o restante é disponibilizado uma página por vez até que o tamanho da reserva seja atingido.
Um número denominado MinHeap, [SizeOfHeapCommit]
\ O tamanho do espaço de heap local a ser confirmado.
Um número denominado LoaderFlags, 
\ Reservado, deve ser zero. Tells the loader whether para break sobre load, debug over load, or the default, which is para let things run normally.
\ directories (16 address e size pairs)
Um número denominado NumberOfDirectories, [NumberOfRvaAndSizes]
\ O número de entradas de diretório de dados no restante do header opcional. Cada uma descreve uma localização e um tamanho.
8 pedaços denominado Directory0,
Um número denominado ImageDirectoryEntryImportAddress,
Um número denominado ImageDirectoryEntryImportSize,
112 pedaços denominado Directories2-15,
Um PE Section Header denominado Idata Section,
Um PE Section Header denominado Data Section,
Um PE Section Header denominado Code Section. \ https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags

Um PE Section Header é um conjunto com
\ Section headers are located sequentially right after the optional header em the PE file format. Each section header is 40 bytes com no padding between them. 
\O PE file specification consists of the headers defined so far and a generic object denominado a section. 
\Sections contain the content of the file, including código, data, resources, and segunda executable information. 
\Each section has a header and a body (the raw data). Section headers are described below, but section bodies lack a rigid file structure. 
\They can be organized em almost algum tipo de way a linker wishes para organize them, as long as the header is filled com enough information para be able para decipher the data.
8 pedaços denominado Nome, \ Each section header has a nome campo para cima para eight characters long, for which the first character must be a period.
Um número denominado SizeInBytes,
Um número denominado AddressInMemory,
Um número denominado SizeInFile,
Um número denominado AddressInFile,
12 pedaços denominado Reserved,
Um número denominado Characteristics. \ Defines the section Characteristics. 
\These values are found both em WINNT.H and in the Portable Executable Format specification.
\Value	Definition
\0x00000020	Code Section
\0x00000040	Initialized data section
\0x00000080	Uninitialized data section
\0x04000000	Section cannot be cached
\0x08000000	Section is not pageable
\0x10000000	Section is shared
\0x20000000	Executable section
\0x40000000	Readable section
\0x80000000	Writable section

Um phrase é uma string.

\Etapas necessárias para que se determine se uma string looks like English:
\Carregue o dicionário léxico.
\Se o dicionário léxico for inexistente, mostre erro "Não foi possível encontrar o dicionário léxico."; diga não.
\Se a string estiver em branco, diga não.
\Lance um subtexto sobre a string.
\Atribua o last endereço de memória do pedaço deste subtexto ao first endereço de memória do pedaço deste subtexto.
\Percorra.
\Se o first endereço de memória do pedaço deste subtexto é o first endereço de memória do pedaço desta string, pare.
\Se o target deste first endereço de memória do pedaço deste subtexto for o caractere de espaço, adicione 1 para o first endereço de memória do pedaço deste subtexto; break.
\Subtraia 1 desde o first endereço de memória do pedaço deste subtexto.
\Repita.
\Se o subtexto estiver no catálogo deste dicionário léxico, diga sim.
\Diga não.

Etapas necessárias para que se pluralize uma string (portuguese rules):
Lance um percorredor sobre a string.
Percorra.
Mova o percorredor (spell checking rules).
Se o segmento inicial deste percorredor estiver em branco, pare.
Se um plural string não estiver em branco, posponha " " para o plural string.
Posponha o segmento inicial deste percorredor para o plural string.
Se o segmento inicial deste percorredor for "de", acione um detector; repita. \ aqui identifica um termo composto. Falta implementar.
Se o detector não estiver ativo, pluralize o plural string (português - regras comuns) .
\ Se o detector estiver ativo, pluralize o plural string (substantivos compostos).
Repita.
Atribua o plural string à string.

Etapas necessárias para que se pluralize uma string (português - regras comuns) :
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se a string for "bit", atribua "bits" à string; exit.
Se a string for "cidadão", posponha "s" para a string; exit.
Se a string for "irmão", posponha "s" para a string; exit.
Se a string for "cristão", posponha "s" para a string; exit.
Se a string for "refrão", posponha "s" para a string; exit.
Se a string for "pão", remove o last pedaço desde a string; posponha "es" para a string; exit.
Se a string for "capitão", remove o last pedaço desde a string; posponha "es" para a string; exit.
Se a string for "alemão", remove o last pedaço desde a string; posponha "es" para a string; exit.
Se a string for "charlatão", remove o last pedaço desde a string; posponha "es" para a string; exit.
Se a string for "caráter", atribua "carateres" à string; exit.
Se a string for "júnior", atribua "juniores" à string; exit.
Se a string for "sênior", atribua "seniores" à string; exit.
Se a string for "mão", atribua "mãos" à string; exit.
Se a string for "são", atribua "sãos" à string; exit.
\# advérbios principais
Se a string for "muito", cancele.
Se a string for "pouco", cancele.
Se a string for "mais", cancele.
Se a string for "menos", cancele.
Se a string for "bastante", cancele.
Se a string for "quase", cancele.
Se a string for "demais", cancele.
Se a string for "bem", cancele.
Se a string for "deveras", cancele.
Se a string for "mal", cancele.
Se a string for "melhor", cancele.
Se a string for "pior", cancele.
\# palavras terminadas com "ão"
Se a string termina com "ão", pluralize a string (portuguese rules - palavras terminadas com "ão"); exit.
\# palavras terminadas com "d"
Se a string termina com "d", pluralize a string (portuguese rules - palavras terminadas com outras consoantes); exit.
\# palavras terminadas com "l"
Se a string termina com "l", pluralize a string (portuguese rules - palavras terminadas com "l"); exit.
\# palavra terminadas com "m"
Se a string termina com "m", remove o last pedaço desde a string; posponha "ns" para a string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se a string termina com "n", posponha "es" para a string; exit.
\# palavras terminadas com "r"
Se a string termina com "r", pluralize a string (portuguese rules - palavras terminadas com "r"); exit.
\# palavras terminadas com "s"
Se a string termina com "s", pluralize a string (portuguese rules - palavras terminadas com "s"); exit.
\# palavras terminadas com "t"
Se a string termina com "t", pluralize a string (portuguese rules - palavras terminadas com outras consoantes); exit.
\# palavra terminadas com "x"
Se a string termina com "x", pluralize a string (portuguese rules - palavras terminadas com "x"); exit.
\# palavras terminadas com "z"
Se a string termina com "z", pluralize a string (portuguese rules - palavras terminadas com "z"); exit.
\# regra padrão
Posponha "s" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "ão"):
\# acentos em sílabas prévias
Lance um subtexto sobre a string.
Subtraia 2 desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto has algum tipo de stressed vogal, posponha "s" para a string; exit.
\# regra padrão
Remove os last dois pedaços desde a string.
Posponha "ões" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com outras consoantes):
Posponha "s" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "l"):
\# palavras terminadas com "al"
Se a string termina com "al", remove o last pedaço desde a string; posponha "is" para a string; exit.
\# palavras terminadas com "el"
Se a string termina com "el", pluralize a string (portuguese rules - palavras terminadas com "el"); exit.
\# palavras terminadas com "il"
Se a string termina com "il", pluralize a string (portuguese rules - palavras terminadas com "il"); exit.
\# palavras terminadas com "ol"
Se a string termina com "ol", pluralize a string (portuguese rules - palavras terminadas com "ol"); exit.
\# palavras terminadas com "ul"
Se a string termina com "ul", remove o last pedaço desde a string; posponha "is" para a string; exit.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "el"):
\# acentos em sílabas prévias
Se a string for "pixel", posponha "pixels" para a string; exit.
Lance um subtexto sobre a string.
Subtraia 2 desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto has algum tipo de stressed vogal, remove o last pedaço desde a string; posponha "is" para a string; exit.
Remove os last dois pedaços desde a string.
Posponha "éis" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "il"):
\# acentos em sílabas prévias
Lance um subtexto sobre a string.
Subtraia 2 desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto has algum tipo de stressed vogal, remove os last dois pedaços desde a string; posponha "eis" para a string; exit.
Remove o last pedaço desde a string.
Posponha "s" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "ol"):
\# acentos em sílabas prévias
Lance um subtexto sobre a string.
Subtraia 2 desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto has algum tipo de stressed vogal, remove o last pedaço desde a string; posponha "is" para a string; exit.
Remove os last dois pedaços desde a string.
Posponha "óis" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "r"):
\# hiatos acentuados
\Se a string termina com "aír", posponha "es" para a string; exit.
\Se a string termina com "aúr", posponha "es" para a string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se a string termina com "ár", remove os last dois pedaços desde a string; posponha "ares" para a string; exit.
\Se a string termina com "âr", remove os last dois pedaços desde a string; posponha "ares" para a string; exit.
\Se a string termina com "ér", remove os last dois pedaços desde a string; posponha "eres" para a string; exit.
\Se a string termina com "êr", remove os last dois pedaços desde a string; posponha "eres" para a string; exit.
\Se a string termina com "ír", remove os last dois pedaços desde a string; posponha "ires" para a string; exit.
\Se a string termina com "ór", remove os last dois pedaços desde a string; posponha "ores" para a string; exit.
\Se a string termina com "ôr", remove os last dois pedaços desde a string; posponha "ores" para a string; exit.
\Se a string termina com "úr", remove os last dois pedaços desde a string; posponha "ures" para a string; exit.
\# acentos em sílabas prévias
Lance um subtexto sobre a string.
Subtraia 2 desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto has algum tipo de stressed vogal, posponha "es" para a string; exit.
\# hiatos
Se a string termina com "air", remove os last dois pedaços desde a string; posponha "íres" para a string; exit.
Se a string termina com "aur", remove os last dois pedaços desde a string; posponha "úres" para a string; exit.
\# regra padrão
Posponha "es" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se a string termina com "as", cancele.
Se a string termina com "es", cancele.
Se a string termina com "os", cancele.
\# hiatos acentuados
Se a string termina com "aís", posponha "es" para a string; exit.
Se a string termina com "aús", posponha "es" para a string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se a string termina com "ás", remove os last dois pedaços desde a string; posponha "ases" para a string; exit.
Se a string termina com "âs", remove os last dois pedaços desde a string; posponha "ases" para a string; exit.
Se a string termina com "és", remove os last dois pedaços desde a string; posponha "eses" para a string; exit.
Se a string termina com "ês", remove os last dois pedaços desde a string; posponha "eses" para a string; exit.
Se a string termina com "ís", remove os last dois pedaços desde a string; posponha "ises" para a string; exit.
Se a string termina com "ós", remove os last dois pedaços desde a string; posponha "oses" para a string; exit.
Se a string termina com "ôs", remove os last dois pedaços desde a string; posponha "oses" para a string; exit.
Se a string termina com "ús", remove os last dois pedaços desde a string; posponha "uses" para a string; exit.
\# palavras terminadas com "is", "us"
Se a string termina com "is", pluralize a string (portuguese rules - palavras terminadas com "is/us"); exit.
Se a string termina com "us", pluralize a string (portuguese rules - palavras terminadas com "is/us"); exit.
\Se a string termina com "ts", exit.
\# regra padrão
Posponha "es" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "is/us"):
\# acentos em sílabas prévias
Lance um subtexto sobre a string.
Subtraia 2 desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto has algum tipo de stressed vogal, cancele.
\# hiatos
Se a string termina com "ais", remove os last dois pedaços desde a string; posponha "íses" para a string; exit.
Se a string termina com "aus", remove os last dois pedaços desde a string; posponha "úses" para a string; exit.
\# regra padrão
Posponha "es" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "x"):
Se a string for "px", posponha "pxs" para a string; exit.
Se a string for "fax", posponha "faxes" para a string; exit.
Cancele.
\Posponha "es" para a string.

Etapas necessárias para que se pluralize uma string (portuguese rules - palavras terminadas com "z"):
\# hiatos acentuados
Se a string termina com "aíz", posponha "es" para a string; exit.
Se a string termina com "aúz", posponha "es" para a string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se a string termina com "áz", remove os last dois pedaços desde a string; posponha "azes" para a string; exit.
Se a string termina com "âz", remove os last dois pedaços desde a string; posponha "azes" para a string; exit.
Se a string termina com "éz", remove os last dois pedaços desde a string; posponha "ezes" para a string; exit.
Se a string termina com "êz", remove os last dois pedaços desde a string; posponha "ezes" para a string; exit.
Se a string termina com "íz", remove os last dois pedaços desde a string; posponha "izes" para a string; exit.
Se a string termina com "óz", remove os last dois pedaços desde a string; posponha "ozes" para a string; exit.
Se a string termina com "ôz", remove os last dois pedaços desde a string; posponha "ozes" para a string; exit.
Se a string termina com "úz", remove os last dois pedaços desde a string; posponha "uzes" para a string; exit.
\# acentos em sílabas prévias
Lance um subtexto sobre a string.
Subtraia 2 desde o last endereço de memória do pedaço deste subtexto.
Se o subtexto has algum tipo de stressed vogal, posponha "es" para a string; exit.
\# hiatos
Se a string termina com "aiz", remove os last dois pedaços desde a string; posponha "ízes" para a string; exit.
Se a string termina com "auz", remove os last dois pedaços desde a string; posponha "úzes" para a string; exit.
\# regra padrão
Posponha "es" para a string.

Etapas necessárias para que se pluralize uma string (english rules); \ plural inglês
Etapas necessárias para que se pluralize uma string:
Se a string for "centena", atribua "centenas" à string; exit.
Se a string for "milhar", atribua "milhares" à string; exit.
Se a string for "entrada", atribua "entradas" à string; exit.
Se a string for "campo", atribua "campos" à string; exit.
Se a string for "fragmento", atribua "fragmentos" à string; exit.
Se a string for "parâmetro", atribua "parâmetros" à string; exit.
Se a string for "fonte", atribua "fontes" à string; exit.
Se a string for "forma", atribua "formas" à string; exit.
Se a string for "contexto", atribua "contextos" à string; exit.
Se a string for "evento", atribua "eventos" à string; exit.
Se a string for "catálogo", atribua "catálogos" à string; exit.
Se a string for "índice", atribua "índices" à string; exit.
Se a string for "milhão", atribua "milhões" à string; exit.
Se a string for "milissegundo", atribua "milissegundos" à string; exit.
Se a string for "ponto", atribua "pontos" à string; exit.
Se a string for "polígono", atribua "polígonos" à string; exit.
Se a string for "objeto", atribua "objetos" à string; exit.
Se a string for "grau", atribua "graus" à string; exit.
Se a string for "preciso", atribua "precisos" à string; exit.
Se a string for "linha", atribua "linhas" à string; exit.
Se a string for "fileira", atribua "fileiras" à string; exit.
Se a string for "conjunto", atribua "conjuntos" à string; exit.
Se a string for "texto", atribua "textos" à string; exit.
Se a string for "unidade", atribua "unidades" à string; exit.
Se a string for "polegada", atribua "polegadas" à string; exit.
Se a string for "endereço", atribua "endereços" à string; exit.
Se a string for "comando", atribua "comandos" à string; exit.
Se a string for "tipo", atribua "tipos" à string; exit.
Se a string for "nome", atribua "nomes" à string; exit.
Se a string for "extensão", atribua "extensões" à string; exit.
Se a string for "rotina", atribua "rotinas" à string; exit.
Se a string for "imagem", atribua "imagens" à string; exit.
Se a string for "figura", atribua "figuras" à string; exit.
Se a string for "variável", atribua "variáveis" à string; exit.
Se a string for "cabeçalho", atribua "cabeçalhos" à string; exit.
Se a string for "rotina", atribua "rotinas" à string; exit.
Se a string for "tarefa", atribua "tarefas" à string; exit.
Se a string for "procedimento", atribua "procedimentos" à string; exit.
Se a string for "função", atribua "funções" à string; exit.
Se a string for "redimensionador", atribua "redimensionadores" à string; exit.
Se a string for "botão", atribua "botões" à string; exit.
Se a string for "segmento", atribua "segmentos" à string; exit.
Se a string for "segmento de cabeçalho", atribua "segmentos de cabeçalhos" à string; exit.
\ nouns only
Se a string for "alumnus", atribua "alumni" à string; exit.
Se a string for "auto", atribua "autos" à string; exit.
Se a string for "botão", atribua "botões" à string; exit.
Se a string for "cello", atribua "cellos" à string; exit.
Se a string for "dwarf", atribua "dwarfs" à string; exit.
Se a string for "foot", atribua "feet" à string; exit.
Se a string for "forma", atribua "formas" à string; exit.
Se a string for "genus", atribua "genera" à string; exit.
Se a string for "goose", atribua "geese" à string; exit.
Se a string for "hippo", atribua "hippos" à string; exit.
Se a string for "louse", atribua "lice" à string; exit.
Se a string for "memo", atribua "memos" à string; exit.
Se a string for "mouse", atribua "mice" à string; exit.
Se a string for "ox", atribua "oxen" à string; exit.
Se a string for "phenomenon", atribua "phenomena" à string; exit.
Se a string for "photo", atribua "photos" à string; exit.
Se a string for "phylum", atribua "phyla" à string; exit.
Se a string for "piano", atribua "pianos" à string; exit.
Se a string for "pimento", atribua "pimentos" à string; exit.
Se a string for "pro", atribua "pros" à string; exit.
Se a string for "proof", atribua "proofs" à string; exit.
Se a string for "radius", atribua "radii" à string; exit.
Se a string for "rhinoceros", atribua "rhinoceri" à string; exit.
Se a string for "roof", atribua "roofs" à string; exit.
Se a string for "solo", atribua "solos" à string; exit.
Se a string for "soprano", atribua "sopranos" à string; exit.
Se a string for "staff", atribua "staffs" à string; exit.
Se a string for "tooth", atribua "teeth" à string; exit.
Se a string for "torus", atribua "tori" à string; exit.
Se a string for "turf", atribua "turfs" à string; exit.
Se a string for "virus", atribua "viruses" à string; exit.
Se a string termina com "sh", posponha "es" para a string; exit.
Se a string termina com "ch", posponha "es" para a string; exit.
Se a string termina com "man", remove os last dois pedaços desde a string; posponha "en" para a string; exit.
Se a string termina com "child", posponha "ren" para a string; exit.
Se a string termina com "ex", remove os last dois pedaços desde a string; posponha "ices" para a string; exit. \ ou adicione ES
Se a string termina com "fe", remove os last dois pedaços desde a string; posponha "ves" para a string; exit.
Se a string termina com "is", remove os last dois pedaços desde a string; posponha "es" para a string; exit.
Se a string termina com "ix", remove os last dois pedaços desde a string; posponha "ices" para a string; exit. \ ou adicione ES
Se a string termina com "ma", posponha "ta" para a string; exit. \ ou adicione S
Se a string termina com alguma consoante e "y", remove o last pedaço desde a string; posponha "ies" para a string; exit.
Se a string termina com algum tipo de vogal e "o", posponha "s" para a string; exit.
Se a string termina com algum tipo de vogal e "y", posponha "s" para a string; exit.
Se a string termina com "f", remove o last pedaço desde a string; posponha "ves" para a string; exit.
Se a string termina com "s", posponha "es" para a string; exit.
Se a string termina com "x", posponha "es" para a string; exit.
Se a string termina com "z", posponha "es" para a string; exit.
Posponha "s" para a string.



Um prototype string é um conjunto com um first endereço de memória do pedaço e um last endereço de memória do pedaço .





Etapas necessárias para que se atribua o endereço exe completo deste compilador para um endereço completo:
Extraia um designador desde o endereço da pasta deste compilador.
Remove algum tipo de trailing barra invertida desde o designador.
Atribua o endereço da pasta deste compilador junto com o designador seguido de ".exe" ao endereço completo.

Etapas necessárias para que se atribua o exe size deste compilador para um size:
Atribua 4096 [section base] ao size.
Adicione o size desta import zona para o size.
Adicione o size desta zona de dados para o size.
Adicione o size desta zona de código para o size.

Etapas necessárias para que se atribua o listagem endereço completo deste compilador para um endereço completo:
Extraia um designador desde o endereço da pasta deste compilador.
Remove algum tipo de trailing barra invertida desde o designador.
Atribua o endereço da pasta deste compilador junto com o designador seguido de ".lst" ao endereço completo.

Etapas necessárias para que se atribua um termo para uma segunda termo:
Atribua a variável deste termo à variável desta segunda termo.
Atribua a phrase deste termo ao phrase desta segunda termo.

Etapas necessárias para que se carregue um source file:
Se o source file for inexistente, cancele.
\Carregue o endereço completo deste source file ao trecho deste source file.
\Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " junto com o endereço completo deste source file seguido de "."; exit.
Carregue o endereço completo deste source file para uma string.
Se o erro do fluxo de entrada/saída não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " junto com o endereço completo deste source file seguido de "."; exit.
Parse a string para o trecho deste source file (para expandir contrações).

Etapas necessárias para que se carregue uns source files:
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um item desde o endereço da pasta deste compilador.
Se o item não for found, pare.
Se a categoria deste item não for "arquivo", repita.
Se a extensão deste item não estiver em branco, repita.
Se o item parece ser encadernável, repita.
Adicione um source file para o source files usando o endereço completo deste item.
Carregue o source file.
Repita.

O percorredor de contrações é um percorredor.

Etapas necessárias para que se parse uma string para uma segunda string (para expandir contrações):
Limpe a segunda string.
Limpe uma terceira string.
Lance o percorredor de contrações sobre a string.
Percorra.
Se o segmento final deste percorredor de contrações estiver em branco, cancele.
Posicione o segmento inicial deste percorredor de contrações sobre o segmento final deste percorredor de contrações. 
Mova o percorredor de contrações (englobando tudo).
Se o conteúdo deste first deste segmento inicial deste percorredor de contrações não for algum tipo de glom pedaço, posponha o segmento inicial deste percorredor de contrações para a segunda string; repita.
Posponha o segmento inicial deste percorredor de contrações para a segunda string usando a terceira string (para expandir contrações).
Atribua o segmento inicial deste percorredor de contrações à terceira string.
Repita.

Etapas necessárias para que se reduce uns monikettes por utility use:
Obtenha um monikette desde os monikettes.
Se o monikette for inexistente, cancele.
Se o type deste monikette for inexistente, repita.
Reduce o type deste monikette para um type por utility use.
Se o type não for inexistente, atribua o type ao type deste monikette.
Repita.

Etapas necessárias para que se reduce um type para uma segunda type por utility use:
Atribua o type ao segunda type.
Percorra.
Se a segunda type for inexistente, cancele.
Se o nome desta segunda type for "texto hexadecimal", cancele.
Se o nome desta segunda type for "string", cancele.
Se o nome desta segunda type for "texto", cancele.
Se o nome desta segunda type for "número", cancele.
Se o nome desta segunda type for "endereço de memória", cancele.
Se o nome desta segunda type for "coisa", esvazie a segunda type; exit.
\PAL
\Se o nome desta segunda type for "elemento", esvazie a segunda type; exit.
Se o base type desta segunda type for a segunda type, esvazie a segunda type; exit.
Atribua o base type desta segunda type ao segunda type.
Repita.

Etapas necessárias para que se organize o catálogo de rotinas úteis:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um bucket usando o catálogo de rotinas úteis.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Organize o catálogo de rotinas úteis usando os refers deste bucket.
Repita.

Etapas necessárias para que se organize o catálogo de rotinas úteis usando uns refers:
Obtenha um refer desde o refers.
Se o refer for inexistente, cancele.
Atribua o endereço de memória deste refer para uma rotina.
Se a rotina for inexistente, apresente uma mensagem de erro contendo "Erro interno na função: organize o catálogo de rotinas úteis usando uns refers"; exit.
Copie os monikettes desta rotina para uns monikettes.
Reduce os monikettes por utility use.
Catalogue a rotina usando os monikettes e o catálogo geral de rotinas.
Destrua os monikettes.
Repita.

Etapas necessárias para que se remove algum tipo de negatives desde uns monikettes devolvendo um detector:
Desative o detector.
Permute os monikettes com uns segunda monikettes.
Percorra.
Atribua o first destes segunda monikettes para um monikette.
Se o monikette for inexistente, cancele.
Remove o monikette desde a segunda monikettes.
\PAL
Se a string deste monikette for "não", reverse o detector; destrua o monikette; repita.
\Se a string deste monikette for "nada", reverse o detector; destrua o monikette; repita.
\CAL
Se a string deste monikette for "not", reverse o detector; destrua o monikette; repita.
\Se a string deste monikette for "nothing", reverse o detector; destrua o monikette; repita.
Posponha o monikette para os monikettes.
Se a string deste monikette for "can't", reverse o detector; atribua "can" à string deste monikette; repita.
\Se a string deste monikette for "cannot", reverse o detector; atribua "can" à string deste monikette; repita.
Se a string deste monikette for "nothing", reverse o detector; atribua "something" à string deste monikette; repita.
Se a string deste monikette for "nada", reverse o detector; atribua "something" à string deste monikette; repita.
Se a string deste monikette for "won't", reverse o detector; atribua "will" à string deste monikette; repita.
Se a string deste monikette termina com "n't", reverse o detector; remove trailing pedaços desde a string deste monikette usando 3; repita.
Repita.



Etapas necessárias para que se resolva um campo:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o campo for inexistente, cancele.
Resolva o campo como uma variável.
Se o nickname deste campo não for algum tipo de valid campo nome, limpe o nickname deste campo. \it
Se o nome deste campo não for algum tipo de valid campo nome, apresente uma mensagem de erro contendo "'" junto com o nome deste campo seguido de "' é um campo nome inválido." e o local de aparição deste campo; exit.

Etapas necessárias para que se resolva um global:
Se o global for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o global body deste global não estiver em branco, resolva o global (compile body).
Se o type nome deste global estiver em branco, apresente uma mensagem de erro contendo "Tipo inválido: " junto com o nome deste global seguido de "' . O tipo da variável global está vazio." e o local de aparição deste global; exit.
Resolva o global como uma variável.

Etapas necessárias para que se resolva um global (compile body):
Se o global for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Lance um percorredor sobre o global body deste global.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de literal, apresente uma mensagem de erro contendo "Erro de tipo. O tipo: " junto com o segmento inicial deste percorredor seguido de "' deve ser do tipo literal." e o percorredor; exit.
Compile um literal usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Acho que era bom colocar um ponto por aqui, né?" e o percorredor; exit.
Se o type nome deste global estiver em branco, atribua o nome deste type deste literal ao type nome deste global.
Atribua o literal ao literal deste global.
Catalogue o literal.

Etapas necessárias para que se resolva uns globals:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um global desde o globals.
Se o global for inexistente, cancele.
Resolva o global.
Repita.

Etapas necessárias para que se resolva um type (base type):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o base type deste type não for inexistente, cancele.
Encontre o base type deste type usando o base nome deste type e o catálogo de tipos.
Se o base type deste type for inexistente, apresente uma mensagem de erro contendo "Base type inválido:'" junto com o base nome deste type seguido de "." e o local de aparição deste type; exit.
Ligue o cooking detector deste type.
Se o cooking detector deste base type deste type estiver ativo, apresente a mensagem de erro contendo "Definição recursiva com: " junto com o base nome deste type seguido de "." e o local de aparição deste type; exit.
Resolva o base type deste type (base type).
Desative o cooking detector deste type.

Etapas necessárias para que se resolva um type (expand coisa): \ base type deste type não está resolved yet
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o base type deste type não for inexistente, cancele.
Se o nome deste type for "coisa", cancele.
\Se o nome deste type for "elemento", cancele.
Se o type não puder ser reduzido para "coisa" using o base nome, cancele.
Encontre um base type usando o base nome deste type e o catálogo de tipos.
\ adicione coisa conjunto - o número of secret campos é hard coded em two places: search por "du que 4" \ was 6
Atribua o nome deste type seguido de " conjunto" para um nome.
Atribua o nome deste type seguido de " conjuntos" para um plural nome.
Atribua o nome deste base type seguido de " conjunto" para um base nome.
Adicione um conjunto type para os types usando o nome e o plural nome e o base nome.
Adicione um campo para os campos deste conjunto type usando "next " junto com o nome deste type e "next" e o nome deste type e o detector de ignição.
\PAL
Adicione um portuguese campo para os campos deste conjunto type usando "seguinte " junto com o nome deste type e "seguinte" e o nome deste type e o detector de ignição.
Atribua "next " junto com o nome deste type ao redefinition conteúdo nome deste portuguese campo.
\Adicione um portuguese reverse campo para os campos deste conjunto type usando o nome deste type seguido de " seguinte" e "seguinte" e o nome deste type e o detector de ignição.
\Atribua "next " junto com o nome deste type ao redefinition conteúdo nome deste portuguese reverse campo.
Adicione um segundo campo para os campos deste conjunto type usando "previous " junto com o nome deste type e "previous" e o nome deste type e o detector de ignição.
\Adicione uma segunda portuguese campo para os campos deste conjunto type usando "anterior " junto com o nome deste type e "anterior" e o nome deste type e o detector de ignição.
\Atribua "previous " junto com o nome deste type ao redefinition conteúdo nome desta segunda portuguese campo.
Adicione uma segunda portuguese reverse campo para os campos deste conjunto type usando o nome deste type seguido de " anterior" e "anterior" e o nome deste type e o detector de ignição.
Atribua "previous " junto com o nome deste type ao redefinition conteúdo nome desta segunda portuguese reverse campo.
Se os campos deste type não estiverem vazio, posponha os campos deste type para os campos deste conjunto type.
Catalogue o conjunto type.
\ fix para cima original type para look like um endereço de memória
Atribua o nome deste conjunto type ao conteúdo nome deste type.
\ adicione chain type
Adicione um chain type para os types usando o plural nome deste type e "" e o plural nome deste base type.
Adicione um terceiro campo para os campos deste chain type usando "first " junto com o nome deste type e "first" e o nome deste type e o detector de ignição.
Adicione um terceiro portuguese campo para os campos deste chain type usando "primeiro " junto com o nome deste type e "primeiro" e o nome deste type e o detector de ignição.
Atribua "first " junto com o nome deste type ao redefinition conteúdo nome deste terceiro portuguese campo.
Adicione um terceiro feminine portuguese campo para os campos deste chain type usando "primeira " junto com o nome deste type e "primeira" e o nome deste type e o detector de ignição.
Atribua "first " junto com o nome deste type ao redefinition conteúdo nome deste terceiro feminine portuguese campo.
Adicione um quarto campo para os campos deste chain type usando "last " junto com o nome deste type e "last" e o nome deste type e o detector de ignição.
Adicione um quarto portuguese campo para os campos deste chain type usando "último " junto com o nome deste type e "último" e o nome deste type e o detector de ignição.
Atribua "last " junto com o nome deste type ao redefinition conteúdo nome deste quarto portuguese campo.
Adicione um quarto portuguese feminine campo para os campos deste chain type usando "última " junto com o nome deste type e "última" e o nome deste type e o detector de ignição.
Atribua "last " junto com o nome deste type ao redefinition conteúdo nome deste quarto portuguese feminine campo.
Catalogue o chain type.

Etapas necessárias para que se resolva um type (registro de plurais):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o plural nome deste type estiver em branco, cancele.
Se o type puder ser reduzido para "coisa" using o base nome, cancele.
Catalogue o type usando o plural nome deste type.

Etapas necessárias para que se resolva um type (optional info - endereço de memória):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o conteúdo type deste type não for inexistente, cancele.
Se o conteúdo nome deste type estiver em branco, atribua o conteúdo type deste base type deste type ao conteúdo type deste type; exit.
Encontre o conteúdo type deste type usando o conteúdo nome deste type e o catálogo de tipos.
Se o conteúdo type deste type for inexistente, apresente uma mensagem de erro contendo "Não sei bem pra que coisa você está se referindo." e o local de aparição deste type; exit.

Etapas necessárias para que se resolva um type (optional info - conjunto):
Se o detector de erros deste compilador estiver ativado, cancele.
Se os campos deste type estiverem vazio, copie os campos deste base type deste type aos campos deste type; exit.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo desde os campos deste type (backwards).
Se o campo for inexistente, pare.
Se o campo estiver duplicada em os campos deste type, apresente uma mensagem de erro contendo "O campo: " junto com o nome deste campo seguido de "' está definido mais de uma vez." e o local de aparição deste campo; exit.
Resolva o campo.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o cooking detector deste type deste campo estiver ativo, apresente a mensagem de erro contendo "Recursive definition no: " junto com o nome deste type deste campo seguido de "." e o local de aparição deste campo; exit.
Resolva o type deste campo (optional info). \ de novo
Se o reference detector deste campo não estiver ativo, repita.
Se o type deste campo não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Não entendi o parâmetro '(reference)' nesse campo: " junto com o nome deste campo seguido de "'..." e o local de aparição deste campo; exit.
Repita.
Eliminate duplicate nicknames desde os campos deste type.
Se o type não puder ser reduzido para "coisa conjunto", cancele.
Se a contagem destes campos deste type for maior do que 4, cancele. \ already copied? was 2 por next e prev, now 6 para included Spanish redefiniions
Copie os campos deste base type deste type aos campos deste type (data campos only).

Etapas necessárias para que se resolva um type (optional info - scale):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o base type deste type para um base type.
Se a scale deste type for 0, atribua o scale deste base type deste type ao scale deste type; exit.
Se a scale deste base type for 0, cancele.
Multiplique o scale deste type pela scale deste base type.
Atribua o base type deste base type ao base type deste type.

Etapas necessárias para que se resolva um type (optional info):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o optional info resolved detector deste type estiver ativo, cancele.
Se o base type deste type for o type, cancele. \ por built em types
Check por invalid optional info sobre o type.
Ligue o cooking detector deste type.
Resolva o base type deste type (optional info).
Se o type puder ser reduzido para "endereço de memória", resolva o type (optional info - endereço de memória).
Se o type puder ser reduzido para "conjunto", resolva o type (optional info - conjunto). \ mudar aqui
Se o type puder ser reduzido para "número", resolva o type (optional info - scale).
Desative o cooking detector deste type.
Ligue o optional info resolved detector deste type.

Etapas necessárias para que se resolva uns types (base types):
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Resolva o type (base type).
Repita.

Etapas necessárias para que se resolva uns types (expand coisas):
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Resolva o type (expand coisa).
Repita.

Etapas necessárias para que se resolva uns types (registro de plurais):
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Resolva o type (registro de plurais).
Repita.

Etapas necessárias para que se resolva uns types (optional info):
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type desde o types.
Se o type for inexistente, cancele.
Resolva o type (optional info).
Repita.

Etapas necessárias para que se resolva uma variável:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável for inexistente, cancele.
Se a type desta variável não for inexistente, cancele.
Se o type nome desta variável não estiver em branco, resolva a variável (explicit type nome); exit.
Encontre o type desta variável e o nickname desta variável usando o nome desta variável.
Se o type desta variável não for inexistente, atribua o nome deste type desta variável ao type nome desta variável; exit.
Apresente uma mensagem de erro contendo "Não achei o tipo da variável: " junto com o nome desta variável seguido de "." e o local de aparição desta variável.

Etapas necessárias para que se resolva uma variável (explicit type nome):
Encontre o type desta variável usando o type nome desta variável e o catálogo de tipos.
Se o type desta variável for inexistente, apresente uma mensagem de erro contendo "Não achei o nome do tipo da variável: " junto com o type nome desta variável seguido de "." e o local de aparição desta variável; exit.



Etapas necessárias para que se arredonde para cima zona sizes:
Atribua a quantidade de caracteres desta import zona ao size desta import zona.
Arredonde o size desta import zona para cima para o múltiplo imediato of 4096.
Atribua a quantidade de caracteres desta zona de dados ao size desta zona de dados.
Arredonde o size desta zona de dados para cima para o múltiplo imediato of 4096.
Atribua a quantidade de caracteres desta zona de código ao size desta zona de código.
Arredonde o size desta zona de código para cima para o múltiplo imediato of 4096.

Uma instrução é um subtexto.
\Umas instruções são umas instruções.

Um cabeçalho de rotina é um subtexto.

O catálogo geral de rotinas é um catálogo.

Uma rotina é uma coisa com
Um local de aparição (reference),
Um detector de compatibilidade,
Um detector de deliberação,
Um detector de função,
Um compiled detector,
Um nickname catálogo,
Um cabeçalho expandido, 
Uns monikettes, 
Uns parâmetros, 
Um parâmetro size,
Um employs cabeçalho expandido,
Some locals, 
Um local size,
Um cabeçalho de rotina, 
Um header string,
Umas instruções, 
Um body string,
Some fragments,
Um endereço.

Um rotina reference é uns monikettes.

As rotinas são umas rotinas.

Etapas necessárias para que se examine algum tipo de optional info por um type usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor for "to", examine algum tipo de optional info pelo type usando o percorredor (endereço de memória); exit.
Se o segmento inicial deste percorredor for "para", examine algum tipo de optional info pelo type usando o percorredor (endereço de memória); exit.
Se o segmento inicial deste percorredor for algum tipo de com, examine algum tipo de optional info pelo type usando o percorredor (conjunto); exit.

Etapas necessárias para que se examine algum tipo de optional info por um type usando um percorredor (endereço de memória):
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente uma mensagem de erro contendo "A palavra 'to' precisa de um artigo indefinido depois dela, não de um: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o conteúdo nome deste type usando o percorredor.

Etapas necessárias para que se examine algum tipo de optional info por um type usando um percorredor (conjunto):
Mova o percorredor (usando diretrizes do compilador).
Examine o campos deste type usando o percorredor.

Etapas necessárias para que se examine algum tipo de pauses usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor não for algum tipo de pause, cancele.
Mova o percorredor (usando diretrizes do compilador).
Repita.

Etapas necessárias para que se examine um campo usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Examine o campo usando o percorredor (type part).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor for algum tipo de called, examine o campo usando o percorredor (called part); repita.
Se o segmento inicial deste percorredor for "at", examine o campo usando o percorredor (redefine part); repita.
Se o segmento inicial deste percorredor for "em", examine o campo usando o percorredor (redefine part); repita.
Se o segmento inicial deste percorredor for "redefinindo", examine o campo usando o percorredor (redefine part); repita.
Se o segmento inicial deste percorredor for algum tipo de reference, examine o campo usando o percorredor (reference part); repita.

Etapas necessárias para que se examine um campo usando um percorredor (called part):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o type nome deste campo estiver em branco, atribua o nome deste campo ao type nome deste campo. \ pedaço array type nome already filled in
Examine o nome deste campo usando o percorredor.

Etapas necessárias para que se examine um campo usando um percorredor (redefine part):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo definido, apresente uma mensagem de erro contendo "Eu estava esperando o artigo 'the', mas o que encontrei foi: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o redefinition conteúdo nome deste campo usando o percorredor.

Etapas necessárias para que se examine um campo usando um percorredor (reference part):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Ligue o reference detector deste campo.

Etapas necessárias para que se examine um campo usando um percorredor (type part - pedaço array):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o segmento inicial deste percorredor para um ratio.
Reduce o ratio.
Se o denominador desta ratio não for 1, apresente uma mensagem de erro contendo "Você precisa especificar um número completo de pedaços para um pedaço array" e o percorredor; exit.
Atribua o numerador desta ratio à contagem deste campo.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for "pedaço" ou "pedaços", apresente a mensagem de erro contendo "Você precisa usar a palavra 'pedaços' depois de um counted campo designador." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Atribua "pedaço" ao type nome deste campo.

Etapas necessárias para que se examine um campo usando um percorredor (type part - normal):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente uma mensagem de erro contendo "Falta por um artigo idefinido aqui, mas você colocou isso: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
\Se o segmento inicial deste percorredor for "another", atribua "segunda" ao nome deste campo.
\PAL
Se o segmento inicial deste percorredor for "outra", atribua "outra" ao nome deste campo.
Se o segmento inicial deste percorredor for "outro", atribua "outro" ao nome deste campo.
Se o segmento inicial deste percorredor for "segundo", atribua "segundo" ao nome deste campo.
Se o segmento inicial deste percorredor for "segunda", atribua "segunda" ao nome deste campo.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Extend o nome deste campo com o nome.

Etapas necessárias para que se examine um campo usando um percorredor (type part):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor for algum tipo de numeric literal, examine o campo usando o percorredor (type part - pedaço array); exit.
Examine o campo usando o percorredor (type part - normal).

Etapas necessárias para que se examine uns campos usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um campo para o campos usando "campo" e o first deste segmento inicial deste percorredor.
Examine o campo usando o percorredor.
Se o segmento inicial deste percorredor não for algum tipo de pause, cancele.
Examine algum tipo de pauses usando o percorredor.
Repita.

Etapas necessárias para que se examine um global body usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Atribua o first deste segmento inicial deste percorredor ao first deste global body.
Atribua -1 ao last deste global body.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o segmento inicial deste percorredor for o sinal de dois pontos, cancele.
Se o segmento inicial deste percorredor for o ponto final, cancele.
Atribua o last deste segmento inicial deste percorredor ao last deste global body.
Mova o percorredor (usando diretrizes do compilador).
Repita.

Etapas necessárias para que se examine um global usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione o global para os globals usando "global" e o first deste segmento inicial deste percorredor.
Mova o percorredor (usando diretrizes do compilador).
Examine o nome deste global usando o percorredor.
Se o segmento inicial deste percorredor for algum tipo de operador de atribuição de estruturas compostas, examine o global usando o percorredor (has ou have); exit.
Se o segmento inicial deste percorredor não for algum tipo de operador de atribuição simples, apresente uma mensagem de erro contendo "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, examine o global usando o percorredor (literal termo); exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o type nome deste global usando o percorredor.
Se o segmento inicial deste percorredor for o start of algum tipo de optional info, examine o global usando o percorredor (optional info); exit.
Se o segmento inicial deste percorredor for algum tipo de operador de atribuição composto, examine o global usando o percorredor (data part); exit.
Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Toda definição precisa terminar com um ponto. Inclusive essa." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (data part):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de to, apresente uma mensagem de erro contendo "Depois da palavra 'equal' você precisa por um palavra 'to'. Você colocou;: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o global body deste global usando o percorredor.
Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Falta terminar um frase com um ponto." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (has ou have):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Atribua "~inline " junto com o nome deste global seguido de " type" para um nome.
Atribua o nome seguido de "s" para um plural nome.
Adicione um type para os types usando o nome e o plural nome e "conjunto" e o local de aparição deste global. \mudar aqui
Catalogue o type.
Atribua o nome deste type ao type nome deste global.
Examine os campos deste type usando o percorredor.
Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Aprenda a escrever direito. Cadê o ponto?." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (literal termo):
Se o detector de erros deste compilador estiver ativado, cancele.
Examine o global body deste global usando o percorredor.
Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Aprenda a escrever corretamente. Cadê o ponto final?." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (optional info):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua "~inline " junto com o nome deste global seguido de " type" para um nome.
Atribua o nome seguido de "s" para um plural nome.
Adicione um type para os types usando o nome e o plural nome e o type nome deste global e o local de aparição deste global.
Catalogue o type.
Atribua o nome deste type ao type nome deste global.
Examine algum tipo de optional info pelo type usando o percorredor.
Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Tá na hora de aprender a escrever direito. Cadê o ponto?." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um nome usando um percorredor:
Limpe o nome.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o percorredor estiver sobre algum tipo de nome starter, extend o nome com o segmento inicial deste percorredor; mova o percorredor (usando diretrizes do compilador).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o percorredor estiver sobre algum tipo de nome ender, pare.
Extend o nome com o segmento inicial deste percorredor.
Mova o percorredor (usando diretrizes do compilador).
Repita.
Se o nome estiver em branco, apresente uma mensagem de erro contendo "Acho que faltou colocar um nome por aqui. Você escreveu: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.

Etapas necessárias para que se examine uma instruções usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, cancele.
Atribua o first deste segmento inicial deste percorredor ao first destas instruções.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Atribua o last deste segmento inicial deste percorredor ao last destas instruções.
Se o segmento inicial deste percorredor for o sinal de dois pontos, apresente uma mensagem de erro contendo "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e o percorredor; exit.
Se o segmento inicial deste percorredor não for o ponto final, mova o percorredor (usando diretrizes do compilador); repita.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, cancele.
Repita.

Etapas necessárias para que se examine uma rotina usando um percorredor:
\ Define o cabeçalho de rotina.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione a rotina para as rotinas usando o first deste segmento inicial deste percorredor.
Se o segmento inicial deste percorredor for "Etapas", mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for "Passos", mova o percorredor (usando diretrizes do compilador). \ Pula a palavra  "Passos" ou "Etapas" e obtém o next segmento inicial
Se o segmento inicial deste percorredor for "necessários", mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for "necessárias", mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for "para", apresente uma mensagem de erro contendo "Você precisa escrever 'para' antes de: " junto com o segmento inicial deste percorredor seguido de "' nesse tipo de rotina." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador). \ skip o "para" e obtenha o next segmento inicial
Se o segmento inicial deste percorredor for "que", mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor não for "que", apresente uma mensagem de erro contendo "Você precisa colocar um 'que' antes da palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
\Mova o percorredor (usando diretrizes do compilador). \ skip o "que" e obtenha o next segmento inicial
Se o segmento inicial deste percorredor for "se", mova o percorredor (usando diretrizes do compilador).
\Se o segmento inicial deste percorredor não for "se", apresente uma mensagem de erro contendo "Você precisa colocar um 'se' antes da palavra: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
\Mova o percorredor (usando diretrizes do compilador). \ skip o "se" e obtenha o next segmento inicial
Examine a cabeçalho de rotina desta rotina usando o percorredor.
Se o segmento inicial deste percorredor for o ponto&vírgula, examine a rotina usando o percorredor (sobrecarga de métodos); exit. \ *** usado para nomes alternativos de rotinas
Se o segmento inicial deste percorredor não for o sinal de dois pontos, apresente a mensagem de erro contendo "O nome dessa função está escrito errado.." e o local de aparição desta rotina; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine as instruções desta rotina usando o percorredor.

Etapas necessárias para que se examine uma rotina usando um percorredor (sobrecarga de métodos):
\ *** para nomes alternativos de rotinas
Isole o percorredor.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for o start of algum tipo de rotina, apresente uma mensagem de erro contendo "Esse ponto e vírgula tá no lugar errado." e o original percorredor; exit.
Atribua o first deste segmento inicial deste original percorredor ao first destas instruções desta rotina.
Atribua o last deste segmento inicial deste original percorredor ao last destas instruções desta rotina.
Mova o original percorredor (usando diretrizes do compilador).

Etapas necessárias para que se examine uma cabeçalho de rotina usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Atribua o first deste segmento inicial deste percorredor ao first deste cabeçalho de rotina.
Atribua -1 ao last deste cabeçalho de rotina.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o segmento inicial deste percorredor for o ponto&vírgula, cancele. \ *** alternate palavraings
Se o segmento inicial deste percorredor for o sinal de dois pontos, cancele.
Se o segmento inicial deste percorredor for o ponto final, cancele.
Atribua o last deste segmento inicial deste percorredor ao last deste cabeçalho de rotina.
Mova o percorredor (usando diretrizes do compilador).
Repita.

Etapas necessárias para que se examine um source file:
Se o source file for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Lance um percorredor sobre o trecho deste source file.
Mova o percorredor (usando diretrizes do compilador).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor estiver em branco, cancele.
Se o segmento inicial deste percorredor for o start of algum tipo de type, examine um type usando o percorredor; repita.
Se o segmento inicial deste percorredor for o start of algum tipo de global, examine um global usando o percorredor; repita.
Se o segmento inicial deste percorredor for o start of algum tipo de rotina, examine uma rotina usando o percorredor; repita.
Apresente uma mensagem de erro contendo "Faltou definir melhor o que é o: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor.
Repita.

Etapas necessárias para que se examine uns source files:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um source file desde o source files.
Se o source file for inexistente, cancele.
Examine o source file.
Repita.

Etapas necessárias para que se examine um type usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o segmento inicial deste percorredor for algum tipo de artigo indefinido português, acione um portuguese detector.
Se o segmento inicial deste percorredor for algum tipo de artigo indefinido inglês, acione um english detector.
Adicione o type para os types usando o first deste segmento inicial deste percorredor.
Mova o percorredor (usando diretrizes do compilador).
Examine o nome deste type usando o percorredor.
Atribua o nome deste type ao plural nome deste type.
Se o portuguese detector estiver ativo, pluralize o plural nome deste type (portuguese rules).
Se o english detector estiver ativo, pluralize o plural nome deste type (english rules).
Se o english detector não estiver ativo, pluralize o plural nome deste type (portuguese rules).
Se o segmento inicial deste percorredor for algum tipo de operador de atribuição de estruturas compostas, examine o type usando o percorredor (has ou have); exit.
Se o segmento inicial deste percorredor não for algum tipo de operador de atribuição simples, apresente uma mensagem de erro contendo "Eu esperava um 'is' ou um 'are', mas só achei um " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
\Pluralize o plural nome deste type.
\Se o segmento inicial deste percorredor for "has" ou "have", examine o type usando o percorredor (has ou have); exit.
\Se o segmento inicial deste percorredor não for "is" ou "are", apresente uma mensagem de erro contendo "I was expecting um 'is' ou 'are', but I found: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.

Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor for algum tipo de numeric literal, examine o type usando o percorredor (unidade de medida); exit.
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Faltou um artigo indefinido, lembra?: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o base nome deste type usando o percorredor.
Examine algum tipo de optional info pelo type usando o percorredor.
Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você precisa usar um ponto para definir um tipo, lembra? Você usou: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (has ou have):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Atribua "conjunto" ao base nome deste type. \\mudar aqui
Examine o campos deste type usando o percorredor.
Se o segmento inicial deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Ao invés de usar o ponto para definir tipo, você usou: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (unidade de medida):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o segmento inicial deste percorredor para o scale deste type.
Se o scale deste type for 0, apresente uma mensagem de erro contendo "Zero é um tipo de escala inválido." e o local de aparição deste type; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o base nome deste type usando o percorredor.
Se o segmento inicial deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Os tipos precisam terminar com um ponto, não com: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o type.



Um scratch é um local.

Etapas necessárias para que se scrub um catálogo:
Obtenha um bucket usando o catálogo.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Scrub os refers deste bucket.
Repita.

Etapas necessárias para que se scrub uns refers:
Permute o refers com uns segunda refers.
Percorra.
Atribua o first destes segunda refers para um refer.
Se o refer for inexistente, cancele.
Remove o refer desde a segunda refers.
Se o endereço de memória deste refer for inexistente, destrua o refer; repita.
Posponha o refer para os refers.
Repita.

Etapas necessárias para que se ative o compiled detector em uma variável;
Etapas necessárias para que se ligue o compiled detector em uma variável:
Se a variável for inexistente, cancele.
Se o compiled detector desta variável [já] estiver ativo, cancele.
Ligue o compiled detector desta variável.
Se a categoria desta variável não for "global", cancele.
Se o literal desta variável for inexistente, cancele.
Encontre uma rotina usando "atribua" e o type deste literal desta variável e "para" e o type desta variável.
Se a rotina for inexistente, encontre a rotina usando "converta" e o type deste literal desta variável e "para" e o type desta variável; acione um detector.
Se a rotina for inexistente, apresente uma mensagem de erro contendo "O tipo dessa variável global e desse literal não são compatíveis." e o local de aparição desta variável; exit.
Compile o body of a rotina.
Se o detector estiver ativo, atribua "converta o " junto com o nome deste literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao initializer string desta variável.
Se o detector não estiver ativo, atribua "atribua o " junto com o nome deste literal desta variável seguido de " para o " junto com o nome desta variável seguido de ". " ao initializer string desta variável. \ Era " ao ". NÃO PODIA MUDAR O " ao " não sei o porquê

Etapas necessárias para que se skip para o next palavra em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o conteúdo deste first endereço de memória do pedaço deste subtexto for irrelevante, pare.
Adicione 1 para o first endereço de memória do pedaço deste subtexto.
Repita.
Skip algum tipo de leading noise no subtexto.

Etapas necessárias para que se skip para o previous palavra em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o conteúdo deste last endereço de memória do pedaço deste subtexto for irrelevante, pare.
Subtraia 1 desde o last endereço de memória do pedaço deste subtexto.
Repita.
Skip algum tipo de trailing noise no subtexto.

An source file é uma coisa com um endereço completo e um trecho.

Os source files são uns source files.

Uma etiqueta é um número.

Um termo é um conjunto com 
Uma variável e 
Uma phrase.

Etapas necessárias para que se transforme em código hexadecimal um fragment:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Se a etiqueta deste fragment for o push endereço etiqueta, transforme em código hexadecimal o fragment (push endereço); exit.
Se a etiqueta deste fragment for a etiqueta de demanda interna, transforme em código hexadecimal o fragment (call internal); exit.
Se a etiqueta deste fragment for o load endereço etiqueta, transforme em código hexadecimal o fragment (load endereço); exit.
Se a etiqueta deste fragment for a etiqueta de acréscimo, transforme em código hexadecimal o fragment (increment); exit.
Se a etiqueta deste fragment for o dereference etiqueta, transforme em código hexadecimal o fragment (dereference); exit.
Se a etiqueta deste fragment for o jump false etiqueta, transforme em código hexadecimal o fragment (jump false); exit.
Se a etiqueta deste fragment for a etiqueta de negação, transforme em código hexadecimal o fragment (not); exit.
Se a etiqueta deste fragment for o exit etiqueta, transforme em código hexadecimal o fragment (exit); exit.
Se a etiqueta deste fragment for a etiqueta de repetição, transforme em código hexadecimal o fragment (repeat); exit.
Se a etiqueta deste fragment for o break etiqueta, transforme em código hexadecimal o fragment (break); exit.
Se a etiqueta deste fragment for o prolog etiqueta, transforme em código hexadecimal o fragment (prolog); exit.
Se a etiqueta deste fragment for o epilog etiqueta, transforme em código hexadecimal o fragment (epilog); exit.
Se a etiqueta deste fragment for o push value etiqueta, transforme em código hexadecimal o fragment (push value); exit.
Se a etiqueta deste fragment for a etiqueta de demanda externa, transforme em código hexadecimal o fragment (call external); exit.
Se a etiqueta deste fragment for o load eax etiqueta, transforme em código hexadecimal o fragment (load eax); exit.
Se a etiqueta deste fragment for o save eax etiqueta, transforme em código hexadecimal o fragment (save eax); exit.
Se a etiqueta deste fragment for a etiqueta de demanda indireta, transforme em código hexadecimal o fragment (call indirect); exit.
Se a etiqueta deste fragment for a etiqueta de endereço de rotina, transforme em código hexadecimal o fragment (rotina endereço); exit.

Etapas necessárias para que se transforme em código hexadecimal um fragment (break):
Atribua a etiqueta de repetição para uma etiqueta.
Encontre um segundo fragment usando o fragment e a etiqueta.
Se o segundo fragment for inexistente, atribua a etiqueta de finalização ao etiqueta. \ para break sem um loop ou depois de um loop
Encontre um terceiro fragment usando o last deste fragments desta rotina utilizada atualmente e a etiqueta (backwards).
Se o terceiro fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (break)"; exit.
Se o next deste terceiro fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transforme em código hexadecimal um fragment (break)"; exit.
Acrescente $E9 e o endereço deste next deste terceiro fragment para o fragment. \ JMP o endereço da destination

Etapas necessárias para que se transforme em código hexadecimal um fragment (call external):
Acrescente $FF15 e o endereço desta entry deste fragment para o código deste fragment. \ call [o endereço desta entry deste fragment ]
\ The above rotina generates the machine code for a call to the Windows operating system. 
\The op code is specified, in hexadecimal ($FF15) and the rest of the instruction is the address of the entry address of the target rotina, which is appended to the op code.

Etapas necessárias para que se transforme em código hexadecimal um fragment (call indirect):
Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ coloca endereço para edx
Acrescente $FF12 para o código deste fragment. \ call [edx]

Etapas necessárias para que se transforme em código hexadecimal um fragment (call internal):
Obtenha um endereço usando o rotina deste fragment.
Acrescente $E8 e o endereço para o fragment. \ call o address da rotina do fragment 

Etapas necessárias para que se transforme em código hexadecimal um fragment (dereference):
Acrescente $8B95 e o offset desta variável deste fragment para o código deste fragment. \ mov edx,[ebp+ o offset desta variável deste fragment]
Acrescente $8B12 para o código deste fragment. \ mov edx,[edx]
Acrescente $8995 e o offset desta variável deste fragment para o código deste fragment. \ mov [ebp+ o offset desta variável deste fragment]

Etapas necessárias para que se transforme em código hexadecimal um fragment (epilog):
Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, acrescente $5F5E5B para o código deste fragment. \ pop edi, esi, ebx
Acrescente $8BE5 para o código deste fragment. \ mov esp,ebp
Acrescente $5D para o código deste fragment. \ pop ebp
Acrescente $C2 e o parâmetro size desta rotina utilizada atualmente para o código deste fragment. \ ret o parâmetro size da rotina utilizada atualmente

Etapas necessárias para que se transforme em código hexadecimal um fragment (exit):
Encontre um segundo fragment usando o fragment e a etiqueta de finalização.
Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (exit)"; exit.
Acrescente $E9 e o endereço deste segundo fragment para o fragment. \ jmp o address da destination

Etapas necessárias para que se transforme em código hexadecimal um fragment (increment):
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (increment)"; exit.
Se a categoria desta variável deste fragment não for "scratch", apresente a mensagem de erro contendo "Erro interno 2 - transforme em código hexadecimal um fragment (increment)"; exit.
Acrescente $8185 e o offset desta variável deste fragment e o número deste fragment para o código deste fragment. \ add [ebp+ o offset desta variável deste fragment], o número deste fragment

Etapas necessárias para que se transforme em código hexadecimal um fragment (jump false):
Encontre um segundo fragment usando o fragment e o end if etiqueta.
Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (jump false)"; exit.
Acrescente $83F800 para o código deste fragment. \ cmp eax,0
Acrescente $0F84 e o endereço deste segundo fragment para o fragment. \ je o address da destination

Etapas necessárias para que se transforme em código hexadecimal um fragment (load endereço):
Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
Acrescente $8995 e o offset desta segunda variável deste fragment para o código deste fragment. \ mov [ebp+ o offset desta variável deste fragment],edx

\Etapas necessárias para que se transforme em código hexadecimal um fragment (load eax):
\Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
\Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro - transforme em código hexadecimal um fragment (load eax)"; exit.
\Se o type desta variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transforme em código hexadecimal um fragment (load eax)"; exit.
\Se a quantidade de caracteres deste type desta variável deste fragment não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transforme em código hexadecimal um fragment (load eax)"; exit.
\Acrescente $8B02 para o código deste fragment. \ mov eax,[edx]

Etapas necessárias para que se transforme em código hexadecimal um fragment (load eax):
Acrescente $B8 e o detector deste fragment para o código deste fragment. \ mov eax,detector
\Acrescente endereço loading código para o código deste fragment usando a variável do fragment. \ atribua endereço para edx
\Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro - transforme em código hexadecimal um fragment (load eax)"; exit.
\Se o type desta variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transforme em código hexadecimal um fragment (load eax)"; exit.
\Se a quantidade de caracteres deste type desta variável deste fragment não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transforme em código hexadecimal um fragment (load eax)"; exit.
\Acrescente $8B02 para o código deste fragment. \ mov eax,[edx]

Etapas necessárias para que se transforme em código hexadecimal um fragment (not):
Acrescente $83F001 para o código deste fragment. \ xor eax,1

Etapas necessárias para que se transforme em código hexadecimal um fragment (prolog):
Acrescente $55 para o código deste fragment. \ push ebp -> saves the contents of the EBP register on the stack.
Acrescente $8BEC para o código deste fragment. \ mov ebp,esp -> puts the contents of the ESP register into the EBP register
Atribua o local size desta rotina utilizada atualmente dividido por 4 para um número.
Se o número não for 0, acrescente $B9 \ mov ecx,number;  -> sets up the loop that will clear enough space on the stack for the routine's local variables
e o número e $6A004975FB \loop: push 0; dec ecx; jnz loop -> a loop that pushes enough zeros onto the stack to initialize the local variables.
para o código deste fragment. 
Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, acrescente $535657 para o código deste fragment. \ push ebx, esi, edi ->  save the EBX, ESI, and EDI registers on the stack.

Etapas necessárias para que se transforme em código hexadecimal um fragment (push endereço):
Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
Acrescente $52 para o código deste fragment. \ push edx

Etapas necessárias para que se transforme em código hexadecimal um fragment (push value):
Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (push value)"; exit.
Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transforme em código hexadecimal um fragment (push value)"; exit.
Atribua a quantidade de caracteres deste type desta variável deste fragment para uma quantidade de caracteres.
Se a quantidade de caracteres for 4, acrescente $FF32 para o código deste fragment; exit. \ push [edx]
Se a quantidade de caracteres for 2, acrescente $66FF32 para o código deste fragment; exit. \ push word ptr [edx]
Se a quantidade de caracteres for 1, acrescente $0FB61252 para o código deste fragment; exit. \ movzxb edx,[edx]; push edx
Apresente a mensagem de erro contendo "Erro interno 3 - transforme em código hexadecimal um fragment (push value)".

Etapas necessárias para que se transforme em código hexadecimal um fragment (repeat):
Encontre um segundo fragment usando o fragment e o loop etiqueta (backwards).
Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (repeat)"; exit.
Acrescente $E9 e o endereço deste segundo fragment para o fragment. \ jmp o address da destination 

Etapas necessárias para que se transforme em código hexadecimal um fragment (rotina endereço):
Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
Se a rotina deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (rotina endereço)"; exit.
Obtenha um endereço usando a rotina deste fragment.
Acrescente $C702 e o endereço para o código deste fragment. \ mov [edx],the endereço

Etapas necessárias para que se transforme em código hexadecimal um fragment (save eax):
Acrescente endereço loading código para o código deste fragment usando a variável deste fragment. \ atribua endereço para edx
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transforme em código hexadecimal um fragment (save eax)"; exit.
Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transforme em código hexadecimal um fragment (save eax)"; exit.
Atribua a quantidade de caracteres deste type desta variável deste fragment para uma quantidade de caracteres.
Se a quantidade de caracteres for 4, acrescente $8902 para o código deste fragment; exit. \ mov [edx],eax
Se a quantidade de caracteres for 2, acrescente $668902 para o código deste fragment; exit. \ mov [edx],ax
Se a quantidade de caracteres for 1, acrescente $8802 para o código deste fragment; exit. \ mov [edx],al
Apresente a mensagem de erro contendo "Erro interno 3 - transforme em código hexadecimal um fragment (save eax)".

Etapas necessárias para que se transforme em código hexadecimal uns fragments:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um fragment desde o fragments.
Se o fragment for inexistente, cancele.
Transforme em código hexadecimal o fragment.
Repita.

Etapas necessárias para que se transforme em código hexadecimal uma rotina:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a rotina for inexistente, cancele.
Se o employs cabeçalho expandido desta rotina não estiver em branco, cancele.
Se o compiled detector desta rotina não estiver ativo, cancele.
Atribua a rotina à rotina utilizada atualmente.
Transforme em código hexadecimal os fragments desta rotina.

Etapas necessárias para que se transforme em código hexadecimal umas rotinas:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma rotina desde as rotinas.
Se a rotina for inexistente, pare.
Transforme em código hexadecimal a rotina.
Repita.



O catálogo de tipos é um catálogo.

Um type é uma coisa com
Um local de aparição (reference),
Um nome, um plural nome,
Um cabeçalho semi-expandido,
uma quantidade de caracteres,
Um base nome, um base type (reference),
Um conteúdo nome, um conteúdo type (reference) [endereço de memórias only],
Um scale ratio,
Some campos [records only],
Um cooking detector,
Um optional info resolved detector.

Um type nome é um nome.

Os types são uns types.

O catálogo de rotinas úteis é um catálogo.

Um variável é uma coisa com
Um local de aparição (reference),
Um categoria [literal, global, local, parâmetro, scratch],
Um compiled detector,
Um nome, um nickname, um type nome,
Um type (reference), \ actual type sobre literal, global, local; dereferenced type sobre parâmetros e scratches
Um endereço [globals e literals only] ou 
Um offset at o endereço [locals, parâmetros, e campos only],
Um contagem [campos only],
Um reference detector [campos only],
Um redefinition conteúdo nome [campos only],
Um by-value detector [parâmetros only],
Um global body [globals only],
Um initializer string [globals only],
Um literal (reference) [globals only - constant com which to initalize the global],
Um texto hexadecimal denominado data [literals only].



Etapas necessárias para que se skip algum tipo de trailing noise em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o conteúdo deste last endereço de memória do pedaço deste subtexto não for irrelevante, cancele.
Subtraia 1 desde o last endereço de memória do pedaço deste subtexto.
Repita.

\ dahn - reverse functions
\ To put o xxx uv a/the yyy para zzz
\ internally we turn this para "to put a/the yyy's xxx para zzz"
Etapas necessárias para que se compile o header of uma rotina usando um percorredor (função do possessivo reverso):
Se o detector de erros deste compilador estiver ativado, cancele.
Ligue o detector de função desta rotina.
Adicione um monikette para os monikettes desta rotina usando "atribua".
Mova o percorredor (usando diretrizes do compilador). \ skip "atribua" ou "poner"
Mova o percorredor (usando diretrizes do compilador). \ skip "the" ou Portuguese artigo definido
Examine um nome usando o percorredor. \ campo nome
Mova o percorredor (usando diretrizes do compilador). \ skip "uv" ou "de"
Se o segmento inicial deste percorredor for algum tipo de artigo indefinido, acione um detector.
Se o detector estiver ativo, compile os monikettes desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
Se o detector não estiver ativo, compile os monikettes desta rotina e o parâmetros desta rotina usando o percorredor (artigo definido).
Adicione uma segunda monikette para os monikettes desta rotina usando "'s " junto com o nome.
Se o segmento inicial deste percorredor não for algum tipo de reverse-possessive function into, apresente uma mensagem de erro contendo "Esperava a palavra 'em', mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Adicione um terceiro monikette para os monikettes desta rotina usando "para".
Converta os monikettes desta rotina para um cabeçalho expandido.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Já sei como: " junto com o cabeçalho expandido seguido de "." e o local de aparição desta rotina; exit.
Catalogue a rotina usando os monikettes desta rotina e o catálogo geral de rotinas.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo indefinido, apresente a mensagem de erro contendo "Esperava um artigo indefinido, mas encontrei: " junto com o segmento inicial deste percorredor seguido de "." e o percorredor; exit.
Compile os monikettes desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
Se o segmento inicial deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Existem outras coisas no final desta função." e o percorredor; exit.
Converta os monikettes desta rotina para o cabeçalho expandido desta rotina.
Catalogue a rotina usando os monikettes desta rotina e o catálogo geral de rotinas. \ por employs

\ dahn - reverse functions
\ para atribua o xxx uv a/the yyy para zzz
Etapas necessárias para que se determine se um percorredor é o start of algum tipo de reverse-possessive function:
Se o detector de erros deste compilador estiver ativo, diga não.
Se o segmento inicial deste percorredor não for algum tipo de atribua, diga não.
Isole o percorredor.
Mova o percorredor (usando diretrizes do compilador).
Se o segmento inicial deste percorredor não for algum tipo de artigo definido, diga não.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o percorredor não for sobre algum tipo de reverse-possessive, diga não.
Diga sim.
\finalmente
