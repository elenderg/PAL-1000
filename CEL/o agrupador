\ o compilador (el compilador) copyright © 2006-2021 o osmosiana order

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

Uma mensagem de erro é um string.

Etapas necessárias para que se apresente uma mensagem de erro contendo um string:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o alarme de alerta deste compilador.
Atribua o string à mensagem de erro deste compilador.

Etapas necessárias para que se apresente uma mensagem de erro contendo um string e um endereço de memória do pedaço :
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o alarme de alerta deste compilador.
Atribua o string à mensagem de erro deste compilador.
Encontre o abort endereço completo deste compilador e o abort número da linha deste compilador usando o endereço de memória do pedaço .
Se o abort endereço completo deste compilador estiver em branco, cancele.
Extract um nome do arquivo from o abort endereço completo deste compilador.
Anteponha "Erro no " then o nome do arquivo then ". " into a mensagem de erro deste compilador.

Etapas necessárias para que se apresente uma mensagem de erro contendo um string e um percorredor:
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo o string e o first deste token deste percorredor; exit.
Apresente a mensagem de erro contendo o string e o last deste source deste percorredor.

Etapas necessárias para que se adicione o allocate e deallocate e finalize e destroy routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Adicione a finalize routine pelo type.
Adicione a allocate routine pelo type.
Adicione a deallocate routine pelo type.
Adicione a destroy routine pelo type.
Repita.

Etapas necessárias para que se adicione o allocate routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o target type deste type for inexistente, cancele.
Adicione uma routine para a routines usando nil.
Posponha "Allocate memory por um " then o name deste type para o header string desta routine. \ traduzir aqui
Posponha "Assign o " then o name deste type then " usando " para o body string desta routine.
Posponha o length deste target type deste type then "." para o body string desta routine.
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione e compile o initialize before run e run e finalize after run routine:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine para a routines usando nil.
Posponha "~initialize before run e run e finalize after run" para o header string desta routine.
Posponha "initialize before run. " para o body string desta routine.
Posponha o global initializers para o body string desta routine.
Posponha "nosso programa seja executado. " para o body string desta routine. \ traduzir
Posponha o global finalizers para o body string desta routine.
Posponha "finalize after run. " para o body string desta routine.
Posponha "call ""kernel32.dll"" ""ExitProcess"" with 0. " para o body string desta routine.
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.
Compile o body of a routine.

Etapas necessárias para que se adicione o built-in types:
Adicione um built-in type usando "byte" e "bytes" e 1. \ que tal octeto?
Adicione another built-in type usando "record" e "records" e 0.
Adicione um terceiro built-in type usando "pedaço" e "pedaços" e 1.
Adicione um fourth built-in type usando "conjunto" e "conjuntos" e 0.

Etapas necessárias para que se adicione um built-in type usando um name e um plural name e um length:
Adicione o built-in type para o types usando o name e o plural name e o name.
Atribua o length ao length deste built-in type.
Atribua o built-in type ao base type deste built-in type.
Catalogue o built-in type.

Etapas necessárias para que se adicione o deallocate routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o target type deste type for inexistente, cancele.
Adicione uma routine para a routines usando nil.
Posponha "Deallocate um " then o name deste type para o header string desta routine.
Posponha "Se o " then o name deste type then " for inexistente, cancele. " para o body string desta routine.
Se o target type deste type deveria ser [estar] finalizado, posponha "~finalize o " then o name deste type then "'s target. " para o body string desta routine.
Posponha "Unassign o " then o name deste type then "." para o body string desta routine.
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione o destroy routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não deveria ser ignorado, cancele.
Se o type puder ser reduzido para "coisas", adicione o destroy routine pelo type (coisas); exit.
Se o type puder ser reduzido para "endereço de memória", adicione o destroy routine pelo type (endereço de memória); exit.

Etapas necessárias para que se adicione o destroy routine por um type (endereço de memória):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Atribua "Destroy [" then o name deste type then "]" into um moniker.
Se o moniker estiver no catálogo geral de rotinas, cancele.
Adicione uma routine para a routines usando nil.
Posponha "Destroy um " then o name deste type para o header string desta routine.
Posponha "Se o " then o name deste type then " for inexistente, cancele. " para o body string desta routine.
Se o target type deste type puder ser reduzido para "endereço de memória", posponha "Destroy o " then o name deste type then "'s target. " para o body string desta routine.
Se o target type deste type puder ser reduzido para "coisas", posponha "Destroy o " then o name deste type then "'s target. " para o body string desta routine.
Percorra.
Obtenha um campo from os campos deste target type deste type.
Se o campo for inexistente, pare.
Se o reference alarme deste campo estiver ativo, repita.
Se o type deste campo não deveria ser ignorado, repita.
Posponha "Destroy o " then o name deste type then "'s " then o name deste campo then ". " para o body string desta routine.
Repita.
Posponha "Deallocate o " then o name deste type then ". " para o body string desta routine. \ traduzir aqui
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione o destroy routine por um type (coisas):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
\Atribua "Erro interno na hora de executar a tarefa de destruição de tipos" à reply.
Se o first destes campos deste type for inexistente, apresente uma mensagem de erro contendo "Erro interno na rotina 'adicione um forget routine por um type (coisas)'"; [Say o reply;] exit. \Adicionado Say o reply
Se o type deste first destes campos deste type for inexistente, apresente a mensagem de erro contendo "Erro interno 2 na rotina 'adicione o forget routine por um type (coisas)'"; exit.
Atribua "Destroy [" then o name deste type then "]" into um moniker.
Se o moniker estiver no catálogo geral de rotinas, cancele.
Adicione uma routine para a routines usando nil.
Posponha "Destroy um " then o name deste type para o header string desta routine.
Posponha "Se o " then o name deste type then "'s first for inexistente, cancele. " para o body string desta routine.
Atribua o name deste type deste first destes campos deste type into um name.
Posponha "Atribua o " then o name deste type then "'s first into um " then o name then ". " para o body string desta routine.
Posponha "Remove o " then o name then " from o " then o name deste type then ". " para o body string desta routine.
Posponha "Destroy o " then o name then ". " para o body string desta routine.
Posponha "Repeat. " para o body string desta routine.
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione um entry para alguns imports usando um import name e um entry name:
Encontre um import usando o import name.
Se o import for inexistente, adicione o import para o imports usando o import name.
Encontre o entry usando o entry name e as entries deste import.
Se o entry não for inexistente, cancele.
Crie o entry.
Posponha o entry para as entries deste import.
Atribua o entry name ao name desta entry.

Etapas necessárias para que se adicione um campo para alguns campos usando um name e um nickname e um type name e um reference alarme:
Adicione o campo para o campos usando "campo" e nil.
Atribua o name ao name deste campo.
Atribua o nickname ao nickname deste campo.
Atribua o type name ao type name deste campo.
Atribua o reference alarme ao reference alarme deste campo.

Etapas necessárias para que se adicione o finalize routine por um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não deveria ser finalizado, cancele.
Se o name deste type for "string", adicione o finalize routine pelo type (string); exit.
Se o type puder ser reduzido para "string", cancele. \ prevents generation of finalizer por derived string types
Adicione o finalize routine pelo type (conjunto).

Etapas necessárias para que se adicione o finalize routine por um type (conjunto):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine para a routines usando nil.
Posponha "~finalize um " then o name deste type para o header string desta routine.
Posponha "intel $50. " para o body string desta routine. \ push eax
Percorra.
Obtenha um campo from os campos deste type.
Se o campo for inexistente, pare.
Se o type deste campo não deveria ser finalizado, repita.
Posponha "~finalize o " then o name deste type then "'s " then o name deste campo then ". " para o body string desta routine.
Repita.
Posponha "intel $58." para o body string desta routine. \ pop eax
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione o finalize routine por um type (string):
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione uma routine para a routines usando nil.
Posponha "~finalize um " then o name deste type para o header string desta routine.
Posponha "intel $50. " para o body string desta routine. \ push eax
Posponha "unassign o string's first. " para o body string desta routine. \\ traduzir string aqui
Posponha "intel $58." para o body string desta routine. \ pop eax
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione um fragment usando uma tag:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.

Etapas necessárias para que se adicione um fragment usando uma tag e um entry:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o entry à entry deste fragment.

Etapas necessárias para que se adicione um fragment usando uma tag e um alarme:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o alarme ao alarme deste fragment.

Etapas necessárias para que se adicione um fragment usando uma tag e uma routine:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua a routine à routine deste fragment.
Compile o body of a routine.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o variable ao variable deste fragment.
Ligue o compiled alarme no variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e another variable:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o variable à variable deste fragment.
Atribua o other variable ao other variable deste fragment.
Ligue o compiled alarme no variable.
Ligue o compiled alarme no other variable.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variable e um número:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o variable à variable deste fragment.
Atribua o número ao número deste fragment.
Ligue o compiled alarme no variable.

Etapas necessárias para que se adicione um import para alguns imports usando um import name:
Crie o import.
Posponha o import para o imports.
Atribua o import name ao name deste import.

Etapas necessárias para que se adicione um intermediate usando um type name e um locus:
Se a rotina utilizada atualmente for inexistente, esvazie o intermediate; exit.
Adicione o intermediate para os locals desta rotina utilizada atualmente usando "local" e o locus.
Gere o name deste intermediate usando "~I".
Atribua o type name ao type name deste intermediate.
Resolva o intermediate.

Etapas necessárias para que se adicione um literal para alguns variables usando um locus:
Adicione o literal como uma variable para o variables usando "literal" e o locus.
Gere o name deste literal usando "~L".

Etapas necessárias para que se adicione um monikette para alguns monikettes usando um expression:
Crie o monikette.
Posponha o monikette para os monikettes.
Atribua a phrase desta expression ao string deste monikette.
Atribua a variable desta expression à variable deste monikette.
Se a variable desta expression não for inexistente, atribua o type desta expression ao type deste monikette.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette para alguns monikettes usando um string: \ creio que isso aqui ajude nas funções
Crie o monikette.
Posponha o monikette para os monikettes.
\PAL
\\ conjunctions
Se o string for "e", atribua "e" ao string deste monikette; exit. \ and
Se o string for "ou", atribua "or" ao string deste monikette; exit. \ or
\ from/given/with/using
Se o string for "desde", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "a partir de", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "partindo de", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "de", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "dada", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "dado", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "dadas", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "dados", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "com", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "usando", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "contendo", atribua "from/given/with/using" ao string deste monikette; exit.
\\ in/into/to
\Se o string for "em", atribua "in/into/to" ao string deste monikette; exit. \ tem que ver isso aqui com calma
Se o string for "a", atribua "in/into/to" ao string deste monikette; exit.
Se o string for "para", atribua "in/into/to" ao string deste monikette; exit.
\\ is/are
Se o string for "é", atribua "is/are" ao string deste monikette; exit.
Se o string for "está", atribua "is/are" ao string deste monikette; exit.
Se o string for "for", atribua "is/are" ao string deste monikette; exit.
Se o string for "foi", atribua "is/are" ao string deste monikette; exit.
Se o string for "foram", atribua "is/are" ao string deste monikette; exit.
Se o string for "forem", atribua "is/are" ao string deste monikette; exit.
Se o string for "estiver", atribua "is/are" ao string deste monikette; exit.
Se o string for "estiverem", atribua "is/are" ao string deste monikette; exit.
\Se o string for "tem", atribua "is/are" ao string deste monikette; exit.
\Se o string for "tiver", atribua "is/are" ao string deste monikette; exit.
Se o string for "are", atribua "is/are" ao string deste monikette; exit.
Se o string for "são", atribua "is/are" ao string deste monikette; exit.
Se o string for "estão", atribua "is/are" ao string deste monikette; exit.
Se o string for "is", atribua "is/are" ao string deste monikette; exit.
Se o string for "forem", atribua "is/are" ao string deste monikette; exit.
Se o string for "estiverem", atribua "is/are" ao string deste monikette; exit.
Se o string for "puder", atribua "pode" ao string deste monikette; exit.
Se o string for "puderem", atribua "pode" ao string deste monikette; exit.
Se o string for "existir", atribua "existe" ao string deste monikette; exit.
\Se o string for "decide", atribua "decidir" ao string deste monikette; exit.
\Se o string for "decidiu", atribua "decidir" ao string deste monikette; exit.
\Se o string for "decidindo", atribua "decidir" ao string deste monikette; exit. \melhor não por gerúndio ou verbos compostos
\Se o string for "decidiu-se", atribua "decidir" ao string deste monikette; exit.
Se o string for "existir", atribua "existe" ao string deste monikette; exit.
\\ allocates e destroys
\Se o string for "alojar", atribua "allocate" ao string deste monikette; exit.
Se o string for "aloje", atribua "allocate" ao string deste monikette; exit.
\Se o string for "alocar", atribua "allocate" ao string deste monikette; exit.
Se o string for "aloque", atribua "allocate" ao string deste monikette; exit.
\Se o string for "reservar", atribua "allocate" ao string deste monikette; exit.
Se o string for "reserve", atribua "allocate" ao string deste monikette; exit.
Se o string for "memória", atribua "memory" ao string deste monikette; exit.
\Se o string for "for", atribua "por" ao string deste monikette; exit. \\servia pra converter o "for" para "por"
Se o string for "pelo", atribua "por o" ao string deste monikette; exit.
Se o string for "pela", atribua "por o" ao string deste monikette; exit.
\Se o string for "desalocar", atribua "deallocate" ao string deste monikette; exit.
Se o string for "desaloque", atribua "deallocate" ao string deste monikette; exit.
\Se o string for "desalojar", atribua "deallocate" ao string deste monikette; exit.
Se o string for "desaloje", atribua "deallocate" ao string deste monikette; exit.
\Se o string for "esvaziar", atribua "deallocate" ao string deste monikette; exit.
\Se o string for "esvazie", atribua "deallocate" ao string deste monikette; exit.
Se o string for "destruir", atribua "destroy" ao string deste monikette; exit.
\CAL
\\ from/given/with/using
Se o string for "from", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "given", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "with", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "using", atribua "from/given/with/using" ao string deste monikette; exit.
\ in/into/to
Se o string for "in", atribua "in/into/to" ao string deste monikette; exit.
Se o string for "into", atribua "in/into/to" ao string deste monikette; exit.
Se o string for "to", atribua "in/into/to" ao string deste monikette; exit.
\ is/are
Se o string for "are", atribua "is/are" ao string deste monikette; exit.
Se o string for "is", atribua "is/are" ao string deste monikette; exit.
\ aren't/isn't
Se o string for "isn't", atribua "is/aren't" ao string deste monikette; exit.
Se o string for "aren't", atribua "is/aren't" ao string deste monikette; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se o string for "backward", atribua "backward" ao string deste monikette; exit.
Se o string for "backwards", atribua "backward" ao string deste monikette; exit.
Se o string for "counterclockwise", atribua "backward" ao string deste monikette; exit.
Se o string for "counter-clockwise", atribua "backward" ao string deste monikette; exit.
Se o string for "anticlockwise", atribua "backward" ao string deste monikette; exit.
Se o string for "anti-clockwise", atribua "backward" ao string deste monikette; exit.
\ at/on
Se o string for "at", atribua "at/on" ao string deste monikette; exit.
Se o string for "on", atribua "at/on" ao string deste monikette; exit.
Se o string for "sobre", atribua "at/on" ao string deste monikette; exit.
\ other
Atribua o string ao string deste monikette.

Etapas necessárias para que se adicione um monikette para alguns monikettes usando um type:
Crie o monikette.
Posponha o monikette para os monikettes.
Atribua o type ao type deste monikette.

Etapas necessárias para que se adicione push fragments usando alguns monikettes:
Se a rotina utilizada atualmente for inexistente, cancele.
Percorra.
Obtenha um monikette from os monikettes (backwards).
Se o monikette for inexistente, cancele.
Se a variable deste monikette for inexistente, repita.
Se o subtexto atual deste monikette não estiver em branco, repita.
Se o type atual deste monikette for inexistente, repita.
Adicione um fragment usando o push address tag e a variable deste monikette.
Repita.

Etapas necessárias para que se adicione o atribua ou convert fragments usando uma variable e another variable e um locus:
Adicione um fragment usando o push address tag e o other variable.
Adicione another fragment usando o push address tag e o variable.
Encontre uma routine usando "atribua" e o type desta variable e "into" e o type desta other variable.
Se a routine for inexistente, encontre a routine usando "convert" e o type desta variable e "to" e o type desta other variable.
Se a routine não for inexistente, adicione um terceiro fragment usando o call internal tag e a routine; exit.
\ erro message
Adicione um monikette para alguns monikettes usando "atribua/convert".
Adicione another monikette para os monikettes usando o type desta variable.
Adicione um terceiro monikette para os monikettes usando "into/to".
Adicione um fourth monikette para os monikettes usando o type desta other variable.
Convert os monikettes para um moniker.
Destroy os monikettes.
Apresente uma mensagem de erro contendo "Eu não sei como: " then o moniker then "." e o locus.

Etapas necessárias para que se adicione uma routine para alguns routines usando um locus:
Crie a routine.
Posponha a routine para a routines.
Atribua o locus ao locus desta routine.

Etapas necessárias para que se adicione um scratch usando um type name e um locus:
Se a rotina utilizada atualmente for inexistente, esvazie o scratch; exit.
Adicione o scratch para os locals desta rotina utilizada atualmente usando "scratch" e o locus.
Gere o name deste scratch usando "~S".
Atribua o type name ao type name deste scratch.
Resolva o scratch.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um locus:
Adicione um fragment usando o push address tag e o other variable.
Adicione another fragment usando o push address tag e o variable.
Adicione um monikette para alguns monikettes usando o string.
Adicione another monikette para os monikettes usando o type desta variable.
Adicione um terceiro monikette para os monikettes usando o other string.
Adicione um fourth monikette para os monikettes usando o type desta other variable.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, convert os monikettes para um moniker.
Destroy os monikettes.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " then o moniker then "." e o locus; exit.
Adicione um terceiro fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione several fragments usando um string e uma variable e another string e another variable e um terceiro string e um terceiro variable e um endereço de memória do pedaço :
Adicione um fragment usando o push address tag e o terceiro variable.
Adicione another fragment usando o push address tag e o other variable.
Adicione um terceiro fragment usando o push address tag e o variable.
Adicione um monikette para alguns monikettes usando o string.
Adicione another monikette para os monikettes usando o type desta variable.
Adicione um terceiro monikette para os monikettes usando o other string.
Adicione um fourth monikette para os monikettes usando o type desta other variable.
Adicione um fifth monikette para os monikettes usando o terceiro string.
Adicione um sixth monikette para os monikettes usando o type desta terceiro variable.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, convert os monikettes para um moniker.
Destroy os monikettes.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " then o moniker then "." e o endereço de memória do pedaço; exit.
Adicione um fourth fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione um source file para alguns source files usando um endereço completo:
Crie o source file.
Posponha o source file para o source files.
Atribua o endereço completo ao endereço completo deste source file.

Etapas necessárias para que se adicione two fragments usando um string e uma variable e um locus:
Adicione um fragment usando o push address tag e o variable.
Adicione um monikette para alguns monikettes usando o string.
Adicione another monikette para os monikettes usando o type desta variable.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, convert os monikettes para um moniker.
Destroy os monikettes.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " then o moniker then "." e o locus; exit.
Adicione another fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione um type para alguns types usando um locus:
Crie o type.
Posponha o type para o types.
Atribua o locus ao locus deste type.

Etapas necessárias para que se adicione um type para alguns types usando um name e um plural name e um base name:
Adicione o type para o types usando o name e o plural name e o base name e nil.

Etapas necessárias para que se adicione um type para alguns types usando um name e um plural name e um base name e um locus:
Crie o type.
Posponha o type para o types.
Atribua o locus ao locus deste type.
Atribua o name ao name deste type.
Atribua o plural name ao plural name deste type.
Atribua o base name ao base name deste type.

Etapas necessárias para que se adicione uma variable para alguns variables usando um categoria e um locus:
Crie o variable usando o categoria.
Posponha o variable para o variables.
Atribua o locus ao locus desta variable.

O adding built-in memory routines cronômetro é um cronômetro.

O adding built-in startup routine cronômetro é um cronômetro.

Etapas necessárias para que se address alguns entries:
Obtenha um entry from o entries.
Se o entry for inexistente, cancele.
Address o entry.
Repita.

Etapas necessárias para que se address um entry:
Atribua o endereço do nome usado atualmente ao name address desta entry.
Atribua o length deste name deste entry mais 3 into um número.
Round o número up para o nearest multiple of 2.
Adicione o número para o endereço do nome usado atualmente.
Atribua o current thunk address ao thunk address desta entry.
Atribua o image base mais o current thunk address ao address desta entry.
Adicione 4 para o current thunk address.

Etapas necessárias para que se address um fragment usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Atribua o image base mais o address ao address deste fragment.
Se a tag deste fragment for a push address tag, adicione 7 para o address; exit.
Se a tag deste fragment for a call internal tag, adicione 5 para o address; exit.
Se a tag deste fragment for a load address tag, adicione 12 para o address; exit.
Se a tag deste fragment for a increment tag, adicione 10 para o address; exit.
Se a tag deste fragment for a dereference tag, adicione 14 para o address; exit.
Se a tag deste fragment for a jump false tag, adicione 9 para o address; exit.
Se a tag deste fragment for a not tag, adicione 3 para o address; exit.
Se a tag deste fragment for a exit tag, adicione 5 para o address; exit.
Se a tag deste fragment for a repeat tag, adicione 5 para o address; exit.
Se a tag deste fragment for a break tag, adicione 5 para o address; exit.
Se a tag deste fragment for a prolog tag, address o fragment usando o address (prolog); exit.
Se a tag deste fragment for a epilog tag, address o fragment usando o address (epilog); exit.
Se a tag deste fragment for a intel tag, adicione o length deste code deste fragment para o address; exit.
Se a tag deste fragment for a push value tag, address o fragment usando o address (push value); exit.
Se a tag deste fragment for a call external tag, adicione 6 para o address; exit.
Se a tag deste fragment for a load eax tag, adicione 5 para o address; exit. \ was 8 when "load eax" took em variables; now "load eax" only does um immediate value
Se a tag deste fragment for a save eax tag, address o fragment usando o address (save eax); exit.
Se a tag deste fragment for a call indirect tag, adicione 8 para o address; exit.
Se a tag deste fragment for a routine address tag, adicione 12 para o address; exit.

Etapas necessárias para que se address um fragment usando um address (epilog):
Se o callback alarme desta rotina utilizada atualmente estiver ativo, adicione 3 para o address.
Adicione 6 para o address.

Etapas necessárias para que se address um fragment usando um address (prolog):
Adicione 3 para o address.
Se o local size desta rotina utilizada atualmente não for 0, adicione 10 para o address.
Se o callback alarme desta rotina utilizada atualmente estiver ativo, adicione 3 para o address.

Etapas necessárias para que se address um fragment usando um address (push value):
Adicione 6 para o address.
Se a variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - address um fragment usando um address (push value)"; exit.
Se o type desta variable deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Atribua o length deste type desta variable deste fragment into um length.
Se o length for 4, adicione 2 para o address; exit.
Se o length for 2, adicione 3 para o address; exit.
Se o length for 1, adicione 4 para o address; exit.
Apresente a mensagem de erro contendo "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address um fragment usando um address (save eax):
Adicione 6 para o address.
Se o variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - address um fragment usando um address (push value)"; exit.
Se o type desta variable deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Atribua o length deste type desta variable deste fragment into um length.
Se o length for 4, adicione 2 para o address; exit.
Se o length for 2, adicione 3 para o address; exit.
Se o length for 1, adicione 2 para o address; exit.
Apresente a mensagem de erro contendo "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address alguns fragments usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Address o fragment usando o address.
Repita.

Etapas necessárias para que se address um import:
Atribua o endereço do nome usado atualmente ao name address deste import.
Atribua o endereço do cabeçalho usado atualmente ao header address deste import.
Atribua o endereço do nome usado atualmente ao name memory address deste import header deste import.
Atribua o length deste name deste import mais 1 into um número.
Round o número up para o nearest multiple of 2.
Adicione o número para o endereço do nome usado atualmente.
Adicione um import header's magnitude para o endereço do cabeçalho usado atualmente. \ tenho que traduzir com calma isso depois
Atribua o current thunk address ao first thunk memory address deste import header deste import.
Address as entries deste import.
Adicione 4 para o current thunk address.

Etapas necessárias para que se address alguns imports usando um address:
Atribua o address ao endereço do cabeçalho usado atualmente.
Atribua as contagem destes imports into um contagem.
Adicione 1 para a contagem.
Multiplique a contagem por um import header's magnitude.
Atribua o address mais o contagem ao current thunk address.
Obtenha another contagem usando o imports (all entries mais markers).
Multiplique o other contagem por 4.
Atribua o current thunk address mais o other contagem ao endereço do nome usado atualmente.
Percorra.
Obtenha um import from o imports.
Se o import for inexistente, pare.
Address o import.
Repita.
Atribua o endereço do nome usado atualmente menos o address into um número.
Adicione o número para o address.

Um address é um número.

Etapas necessárias para que se address uma routine usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o employs moniker desta routine não estiver em branco, cancele. \ employs são addressed later
Se o compiled alarme desta routine não estiver ativo, cancele.
Atribua a routine à rotina utilizada atualmente.
Atribua o image base mais o address ao address desta routine.
Address os fragments desta routine usando o address.
Round o address up para o nearest multiple of 4.

Etapas necessárias para que se address alguns routines usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, pare.
Address a routine usando o address.
Repita.

Etapas necessárias para que se address uma variable usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Se o compiled alarme desta variable não estiver ativo, cancele.
Atribua o image base mais o address ao address desta variable.
Adicione o length deste type desta variable para o address.
Se o type desta variable puder ser reduzido para "string", adicione o length deste data desta variable mais 1 para o address.
Round o address up para o nearest multiple of 4.

Etapas necessárias para que se address alguns variables usando um address:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Address o variable usando o address.
Repita.

O addressing cronômetro é um cronômetro.

Etapas necessárias para que se advance um trecho:
Posponha o return pedaço para o trecho.
Posponha o linefeed pedaço para o trecho.

Etapas necessárias para que se advance um trecho (twice):
Advance o trecho.
Advance o trecho.

Etapas necessárias para que se posponha um entry para um trecho (with separator):
Se o entry for inexistente, posponha "" para o trecho (with separator); exit.
Posponha o name desta entry para o trecho (with separator).

Etapas necessárias para que se posponha um alarme para um trecho (with separator):
Convert o alarme para um string.
Posponha o string para o trecho (with separator).

Etapas necessárias para que se posponha o global finalizers para um string:
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Se o compiled alarme deste global não estiver ativo, repita.
Se o type deste global não deveria ser [estar] finalizado, repita.
Posponha "~finalize o " then o name deste global then ". " para o string.
Repita.

Etapas necessárias para que se posponha o global initializers para um string:
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Se o literal deste global for inexistente, repita.
Se o compiled alarme deste global não estiver ativo, repita.
Desative um alarme.
Posponha o initializer string deste global para o string.
Repita.

Etapas necessárias para que se posponha um monikette para um moniker:
Se o monikette for inexistente, cancele.
Se o moniker não estiver em branco, posponha o caractere de espaço para o moniker.
Se o type deste monikette não for inexistente, posponha "[" e o name deste type deste monikette e "]" para o moniker (fast); exit.
Se o string deste monikette não estiver em branco, posponha o string deste monikette para o moniker; exit.

Etapas necessárias para que se posponha um monikette para um moniker (while bubbling):
Se o monikette for inexistente, cancele.
Se o moniker não estiver em branco, posponha o caractere de espaço para o moniker.
Se o subtexto atual deste monikette não estiver em branco, posponha o subtexto atual deste monikette para o moniker; exit.
Se o type atual deste monikette não for inexistente, posponha "[" e o name deste type atual deste monikette e "]" para o moniker (fast); exit.

Etapas necessárias para que se posponha um número para um trecho (as hex with separator):
Convert o número para um texto da cifra binária.
Posponha o texto da cifra binária para o trecho (with separator).

Etapas necessárias para que se posponha um número para um trecho (with separator):
Convert o número para um string.
Posponha o string para o trecho (with separator).

Etapas necessárias para que se posponha um ratio para um trecho (with separator):
Convert o ratio para um string.
Posponha o string para o trecho (with separator).

Etapas necessárias para que se posponha uma routine para um trecho (with separator):
Se a routine for inexistente, posponha "" para o trecho (with separator); exit.
Posponha o moniker deste routine para o trecho (with separator).

Etapas necessárias para que se posponha um string e another string e um terceiro string para um fourth string (fast):
Atribua o length deste fourth string into um length.
Adicione o length deste string para o length.
Adicione o length deste other string para o length.
Adicione o length deste terceiro string para o length.
Reassign um endereço de memória usando o length.
Atribua o endereço de memória into um endereço de memória do pedaço .
Copy pedaços from o first deste fourth string para o endereço de memória do pedaço pelo length deste fourth string.
Adicione o length deste fourth string para o endereço de memória do pedaço .
Copy pedaços from o first deste string para o endereço de memória do pedaço pelo length deste string.
Adicione o length deste string para o endereço de memória do pedaço .
Copy pedaços from o first deste other string para o endereço de memória do pedaço pelo length deste other string.
Adicione o length deste other string para o endereço de memória do pedaço .
Copy pedaços from o first deste terceiro string para o endereço de memória do pedaço pelo length deste terceiro string.
Unassign o first deste fourth string.
Atribua o endereço de memória ao first deste fourth string.
Atribua o endereço de memória mais o length menos 1 ao last deste fourth string.

Etapas necessárias para que se posponha um string para um trecho (with separator):
Posponha o string para o trecho.
Posponha "/" para o trecho.

Etapas necessárias para que se posponha uma tag para um trecho (as um fragment tag string with separator):
Se a tag for a break tag, posponha "break" para o trecho (with separator); exit.
Se a tag for a call external tag, posponha "call external" para o trecho (with separator); exit.
Se a tag for a call indirect tag, posponha "call indirect" para o trecho (with separator); exit.
Se a tag for a call internal tag, posponha "call internal" para o trecho (with separator); exit.
Se a tag for a dereference tag, posponha "dereference" para o trecho (with separator); exit.
Se a tag for a end if tag, posponha "end if" para o trecho (with separator); exit.
Se a tag for a epilog tag, posponha "epilog" para o trecho (with separator); exit.
Se a tag for a exit tag, posponha "exit" para o trecho (with separator); exit.
Se a tag for a finalize tag, posponha "finalize" para o trecho (with separator); exit.
Se a tag for a increment tag, posponha "increment" para o trecho (with separator); exit.
Se a tag for a intel tag, posponha "intel" para o trecho (with separator); exit.
Se a tag for a jump false tag, posponha "jump false" para o trecho (with separator); exit.
Se a tag for a load address tag, posponha "load address" para o trecho (with separator); exit.
Se a tag for a load eax tag, posponha "load eax" para o trecho (with separator); exit.
Se a tag for a loop tag, posponha "loop" para o trecho (with separator); exit.
Se a tag for a not tag, posponha "not" para o trecho (with separator); exit.
Se a tag for a prolog tag, posponha "prolog" para o trecho (with separator); exit.
Se a tag for a push address tag, posponha "push address" para o trecho (with separator); exit.
Se a tag for a push value tag, posponha "push value" para o trecho (with separator); exit.
Se a tag for a save eax tag, posponha "save eax" para o trecho (with separator); exit.
Se a tag for a repeat tag, posponha "repeat" para o trecho (with separator); exit.
Se a tag for a routine address tag, posponha "routine address" para o trecho (with separator); exit.
Posponha "?" para o trecho (with separator).

Etapas necessárias para que se posponha um type para um trecho (with separator):
Se o type for inexistente, posponha "" para o trecho (with separator); exit.
Posponha o name deste type para o trecho (with separator).

Etapas necessárias para que se posponha uma variable para um trecho (with separator):
Se o variable for inexistente, posponha "" para o trecho (with separator); exit.
Posponha o name desta variable para o trecho (with separator).

Etapas necessárias para que se posponha um string para another string giving um terceiro string (portuguese contractions e synonyms rules):
\# contrações
Se o string for "ao", posponha "para o" para o other string; exit.
Se o string for "à", posponha "para a" para o other string; exit.
Se o string for "aos", posponha "para os" para o other string; exit.
Se o string for "às", posponha "para as" para o other string; exit.
\Se o string for "do", posponha "de o" para o other string; exit.
\Se o string for "da", posponha "de a" para o other string; exit.
\Se o string for "dos", posponha "de os" para o other string; exit.
\Se o string for "das", posponha "de as" para o other string; exit.
\Se o string for "dum", posponha "de um" para o other string; exit.
\Se o string for "duma", posponha "de uma" para o other string; exit.
\Se o string for "dumas", posponha "de umas" para o other string; exit.
\Se o string for "duns", posponha "de uns" para o other string; exit.
Se o string for "daqui", posponha "de aqui" para o other string; exit.
Se o string for "dali", posponha "de ali" para o other string; exit.
Se o string for "dele", posponha "de ele" para o other string; exit.
Se o string for "dela", posponha "de ela" para o other string; exit.
Se o string for "desse", posponha "de esse" para o other string; exit.
Se o string for "dessa", posponha "de essa" para o other string; exit.
Se o string for "desses", posponha "de esses" para o other string; exit.
Se o string for "dessas", posponha "de essas" para o other string; exit.
Se o string for "deste", posponha "de este" para o other string; exit.
Se o string for "desta", posponha "de esta" para o other string; exit.
Se o string for "destes", posponha "de estes" para o other string; exit.
Se o string for "destas", posponha "de estas" para o other string; exit.
Se o string for "disso", posponha "de isso" para o other string; exit.
Se o string for "disto", posponha "de isto" para o other string; exit.
Se o string for "nesse", posponha "em esse" para o other string; exit.
Se o string for "nesses", posponha "em esses" para o other string; exit.
Se o string for "neste", posponha "em este" para o other string; exit.
Se o string for "nestes", posponha "em estes" para o other string; exit.
Se o string for "nisso", posponha "em isso" para o other string; exit.
Se o string for "nisto", posponha "em isto" para o other string; exit.
Se o string for "nessa", posponha "em essa" para o other string; exit.
Se o string for "nessas", posponha "em essas" para o other string; exit.
Se o string for "nesta", posponha "em esta" para o other string; exit.
Se o string for "nestas", posponha "em estas" para o other string; exit.
Se o string for "donde", posponha "de onde" para o other string; exit.
Se o string for "dentre", posponha "de entre" para o other string; exit.
Se o string for "dantes", posponha "de antes" para o other string; exit.
Se o string for "dalguém", posponha "de alguém" para o other string; exit.
Se o string for "dalgum", posponha "de algum" para o other string; exit.
Se o string for "dalguma", posponha "de alguma" para o other string; exit.
Se o string for "dalguns", posponha "de alguns" para o other string; exit.
Se o string for "dalgumas", posponha "de algumas" para o other string; exit.
Se o string for "nalgum", posponha "em algum" para o other string; exit.
Se o string for "nalguma", posponha "em alguma" para o other string; exit.
Se o string for "nalguns", posponha "em alguns" para o other string; exit.
Se o string for "nalgumas", posponha "em algumas" para o other string; exit.
Se o string for "doutro", posponha "de outro" para o other string; exit.
Se o string for "doutra", posponha "de outra" para o other string; exit.
Se o string for "doutros", posponha "de outros" para o other string; exit.
Se o string for "doutras", posponha "de outras" para o other string; exit.
Se o string for "noutro", posponha "em outro" para o other string; exit.
Se o string for "noutra", posponha "em outra" para o other string; exit.
Se o string for "noutros", posponha "em outros" para o other string; exit.
Se o string for "noutras", posponha "em outras" para o other string; exit.
\# "no" pode ser uma negação em inglês.
Se o string for any contraction giving o terceiro string (portuguese rules - "no"), posponha "em o" para o other string; exit.
Se o string for "na", posponha "em a" para o other string; exit.
Se o string for "nos", posponha "em os" para o other string; exit.
Se o string for "nas", posponha "em as" para o other string; exit.
\Se o string for "noutro", posponha "em outro" para o other string; exit.
\Se o string for "noutra", posponha "em outra" para o other string; exit.
\Se o string for "noutros", posponha "em outros" para o other string; exit.
\Se o string for "noutras", posponha "em outras" para o other string; exit.
Se o string for "num", posponha "em um" para o other string; exit.
Se o string for "numa", posponha "em uma" para o other string; exit.
Se o string for "nuns", posponha "em uns" para o other string; exit.
Se o string for "numas", posponha "em umas" para o other string; exit.
Se o string for "pelo", posponha "por o" para o other string; exit.
Se o string for "pela", posponha "por a" para o other string; exit.
Se o string for "pelos", posponha "por os" para o other string; exit.
Se o string for "pelas", posponha "por as" para o other string; exit.
\# sinônimos
Se o string for "adir", posponha "adicionar" para o other string; exit.
Se o string for "agregar", posponha "adicionar" para o other string; exit.
Se o string for "acrescentar", posponha "adicionar" para o other string; exit.
Se o string for "somar", posponha "adicionar" para o other string; exit.
Se o string for "começar", posponha "iniciar" para o other string; exit.
Se o string for "terminar", posponha "finalizar" para o other string; exit.
Se o string for "acabar", posponha "finalizar" para o other string; exit.
Se o string for "completar", posponha "finalizar" para o other string; exit.
Se o string for "colocar", posponha "pôr" para o other string; exit.
Se o string for "mudar", posponha "alterar" para o other string; exit.
Se o string for "limpar", posponha "apagar" para o other string; exit.
Se o string for "ampliar", posponha "aumentar" para o other string; exit.
Se o string for "expandir", posponha "aumentar" para o other string; exit.
Se o string for "alargar", posponha "aumentar" para o other string; exit.
Se o string for "dilatar", posponha "aumentar" para o other string; exit.
Se o string for "estender", posponha "aumentar" para o other string; exit.
Se o string for "prolongar", posponha "aumentar" para o other string; exit.
Se o string for "ampliar", posponha "aumentar" para o other string; exit.
Se o string for "achar", posponha "encontrar" para o other string; exit.
Se o string for "descobrir", posponha "encontrar" para o other string; exit.
Se o string for "buscar", posponha "encontrar" para o other string; exit.
Se o string for "manusear", posponha "manejar" para o other string; exit.
Se o string for "manipular", posponha "manejar" para o other string; exit.
Se o string for "enumerar", posponha "listar" para o other string; exit.
Se o string for "elencar", posponha "listar" para o other string; exit.
Se o string for "selecionar", posponha "escolher" para o other string; exit.
Se o string for "eliminar", posponha "remover" para o other string; exit.
Se o string for "excluir", posponha "remover" para o other string; exit.
Se o string for "retirar", posponha "remover" para o other string; exit.
Se o string for "rodar", posponha "girar" para o other string; exit.
Se o string for "começar", posponha "iniciar" para o other string; exit.
Se o string for "permutar", posponha "trocar" para o other string; exit.
Se o string for "esperar", posponha "aguardar" para o other string; exit.
Se o string for "rascunhar", posponha "esboçar" para o other string; exit.
Se o string for "antepor", posponha "prepor" para o other string; exit.
Posponha o string para o other string.

Etapas necessárias para que se attach address loading code para um texto hexadecimal usando uma variable:
\ loads into edx
Se o variable for inexistente, attach $C7C200000000 para o texto hexadecimal; exit. \ mov edx,0
Se a categoria desta variable for "global", attach $C7C2 e o address desta variable para o texto hexadecimal; exit. \ mov edx,the address da variable
Se a categoria desta variable for "literal", attach $C7C2 e o address desta variable para o texto hexadecimal; exit. \ mov edx,the address da variable
Se a categoria desta variable for "local", attach $8D95 e o offset desta variable para o texto hexadecimal; exit. \ lea edx,[ebp+ the offset da variable]
Se a categoria desta variable for "scratch", attach $8B95 e o offset desta variable para o texto hexadecimal; exit. \ mov edx,[ebp+ the offset da variable]
Se a categoria desta variable não for "parameter", apresente uma mensagem de erro contendo "Erro interno - attach address loading code para um texto hexadecimal usando uma variable"; exit.
Se o by-value alarme desta variable estiver ativo, attach $8D95 e o offset desta variable para o texto hexadecimal; exit. \ lea edx,[ebp+the offset da variable]
Attach $8B95 e o offset desta variable para o texto hexadecimal. \ mov edx,[ebp+ the offset da variable]

Etapas necessárias para que se attach um texto hexadecimal e um address para um fragment:
\ call ou jump
Atribua o address into um número.
Subtraia o address deste fragment from o número.
Subtraia o length deste code deste fragment from o número.
Subtraia o length deste texto hexadecimal from o número.
Subtraia 4 from o número.
Attach o texto hexadecimal e o número para o code deste fragment.

Etapas necessárias para que se attach um texto hexadecimal e um número e another texto hexadecimal para um terceiro texto hexadecimal:
Posponha o texto hexadecimal para o terceiro texto hexadecimal.
Convert o número para um fourth texto hexadecimal.
Posponha o fourth texto hexadecimal para o terceiro texto hexadecimal.
Posponha o other texto hexadecimal para o terceiro texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um número e another número para another texto hexadecimal:
Posponha o texto hexadecimal para o other texto hexadecimal.
Convert o número para um terceiro texto hexadecimal.
Posponha o terceiro texto hexadecimal para o other texto hexadecimal.
Convert o other número para um fourth texto hexadecimal.
Posponha o fourth texto hexadecimal para o other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um alarme para another texto hexadecimal;
Etapas necessárias para que se attach um texto hexadecimal e um número para another texto hexadecimal:
Posponha o texto hexadecimal para o other texto hexadecimal.
Convert o número para um terceiro texto hexadecimal.
Posponha o terceiro texto hexadecimal para o other texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal para another texto hexadecimal:
Employ posponha um string para another string.

Etapas necessárias para que se blurt pedaços usando um endereço de memória e um length e um trecho e um offset:
Atribua o first deste trecho mais o offset into another endereço de memória.
Copy pedaços from o endereço de memória para o other endereço de memória pelo length.

Etapas necessárias para que se blurt um DOS header into um trecho:
Blurt pedaços usando o whereabouts deste DOS header e o magnitude deste DOS header e o trecho e 0.

Etapas necessárias para que se blurt alguns entries into um trecho:
Obtenha um entry from o entries.
Se o entry for inexistente, cancele.
Blurt o entry ao trecho.
Repita.

Etapas necessárias para que se blurt um entry into um trecho:
Blurt pedaços usando o whereabouts deste name address desta entry e 4 e o trecho e o thunk address desta entry.
Atribua o name address desta entry mais 2 into um address.
Blurt o name desta entry ao trecho at o address.

Etapas necessárias para que se blurt um fragment into um trecho:
Se o code deste fragment estiver em branco, cancele.
Atribua o address deste fragment menos o image base into um address.
Blurt o code deste fragment ao trecho at o address.

Etapas necessárias para que se blurt alguns fragments into um trecho:
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Blurt o fragment ao trecho.
Repita.

Etapas necessárias para que se blurt um import into um trecho:
Blurt pedaços usando o whereabouts deste import header deste import e o magnitude deste import header deste import e o trecho e o header address deste import.
Blurt o name deste import ao trecho at o name address deste import.
Blurt as entries deste import ao trecho.

Etapas necessárias para que se blurt alguns imports into um trecho:
Obtenha um import from o imports.
Se o import for inexistente, cancele.
Blurt o import ao trecho.
Repita.

Etapas necessárias para que se blurt um PE header into um trecho:
Blurt pedaços usando o whereabouts deste PE header e o magnitude deste PE header e o trecho e 256.

Etapas necessárias para que se blurt uma routine into um trecho:
Se o compiled alarme desta routine não estiver ativo, cancele.
Blurt os fragments desta routine ao trecho.

Etapas necessárias para que se blurt alguns routines into um trecho:
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Blurt a routine ao trecho.
Repita.

Etapas necessárias para que se blurt um string into um trecho at um address:
Blurt pedaços usando o first deste string e o length deste string e o trecho e o address.

Etapas necessárias para que se blurt uma variable into um trecho:
Se o compiled alarme desta variable não estiver ativo, cancele.
Se o type desta variable puder ser reduzido para "string", blurt o variable ao trecho (as um string); exit.
Atribua o address desta variable menos o image base into um address. \ Atribua a diferença entre o endreço da variável e a base da imagem em um endereço.
Blurt o data desta variable ao trecho at o address.

Etapas necessárias para que se blurt uma variable into um trecho (as um string):
Atribua o address desta variable menos o image base into um address.
Atribua o length deste data desta variable into um length.
Atribua o address into another address.
Adicione uma prototype string's magnitude para o other address.
Adicione o image base para o other address.
Atribua 0 ao first deste prototype string.
Atribua -1 ao last deste prototype string.
Se o length não for 0, atribua o other address ao first deste prototype string.
Se o length não for 0, atribua o first deste prototype string mais o length menos 1 ao last deste prototype string.
Blurt pedaços usando o whereabouts deste prototype string e a magnitude deste prototype string e o trecho e o address.
Adicione a magnitude deste prototype string para o address.
Blurt os data desta variable ao trecho at o address.

Etapas necessárias para que se blurt alguns variables into um trecho:
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Blurt o variable ao trecho.
Repita.

Um zona é um conjunto with um base address, um length e um size.

O break tag é uma tag igual a 1.

Etapas necessárias para que se bubble um monikette:
Se o monikette for inexistente, cancele.
Se o subtexto atual deste monikette não estiver em branco, limpe o subtexto atual deste monikette; exit.
Se o type atual deste monikette for inexistente, cancele.
Se o type atual deste monikette for any built-in type, atribua nil ao type atual deste monikette; exit.
Atribua o base type deste type atual deste monikette ao type atual deste monikette.

Um built-in type é um type.

Etapas necessárias para que se calculate o length of um type:
Se o type for inexistente, cancele.
Se o length deste type não for -1, cancele.
Calculate o length of o base type deste type.
Se os campos deste type estiverem vazio, atribua o length deste base type deste type ao length deste type; exit.
Atribua 0 ao length deste type.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um campo from o campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition target name deste campo não estiver em branco, repita.
Calculate o length of o type deste campo.
Adicione o length deste type deste campo times a contagem deste campo para o length deste type.
Repita.

Etapas necessárias para que se calculate o lengths of alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o length of o type.
Repita.

Etapas necessárias para que se calculate o offsets em um type:
Se o type for inexistente, cancele.
Atribua 0 into um offset.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um campo from os campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition target name deste campo não estiver em branco, repita.
Atribua o offset ao offset deste campo.
Adicione o length deste type deste campo times o contagem deste campo para o offset.
Repita.

Etapas necessárias para que se calculate o offsets em alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o offsets no type.
Repita.

Etapas necessárias para que se calculate o redefinition offsets em um type:
Se o type for inexistente, cancele.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um campo from os campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition target name deste campo estiver em branco, repita.
Encontre another campo usando o redefinition target name deste campo e os campos deste type.
Se o other campo for inexistente, apresente uma mensagem de erro contendo "Redefine inválido. Eu não consigo encontrar o campo: " then o redefinition target name deste campo then "' campo." e o locus deste campo; exit.
Atribua o offset deste other campo ao offset deste campo.
Repita.

Etapas necessárias para que se calculate o redefinition offsets em alguns types:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o redefinition offsets no type.
Repita.

O calculating cronômetro é um cronômetro.

O call external tag é uma tag igual a 2.

O call indirect tag é uma tag igual a 3.

O call internal tag é uma tag igual a 4.

Etapas necessárias para que se check por invalid optional info sobre um type:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o target name deste type não estiver em branco, check por invalid optional info sobre o type (target).
Se o campos deste type não estiverem vazio, check por invalid optional info sobre o type (campos).
Se o scale deste type não for 0, check por invalid optional info sobre o type (scale).

Etapas necessárias para que se check por invalid optional info sobre um type (campos):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "conjunto", apresente uma mensagem de erro contendo "A palavra 'with' só é permitida em conjunto types." e o locus deste type; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info sobre um type (scale):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "número", apresente uma mensagem de erro contendo "Escalas são permitidas apenas em tipos numéricos." e o locus deste type; exit.

Etapas necessárias para que se check por invalid optional info sobre um type (target):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", apresente uma mensagem de erro contendo "A palavra 'to' só é permitida em endereço de memória types." e o locus deste type; exit.

Etapas necessárias para que se limpe um campo term:
Fill pedaços with o null pedaço starting at o whereabouts deste campo term pelo magnitude deste campo term.

Etapas necessárias para que se limpe um term:
Esvazie o variable deste term.
Limpe o phrase deste term.

O code zona é um zona.

Etapas necessárias para que se compile o bodies of a routines:
Compile o body of a routine called "initialize before run".
Compile o body of a routine called "nosso programa seja executado".
Compile o body of a routine called "finalize after run".

Etapas necessárias para que se compile o body of uma routine:
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o compiled alarme desta routine estiver ativo, cancele.
Ligue o compiled alarme desta routine.
Lance um percorredor sobre o instruções desta routine.
Mova o percorredor (compilador rules).
Se o token deste percorredor for o ponto&vírgula, compile o body of a routine usando o percorredor (alternate palavraing); exit. \ *** alternate palavraing
Se o token deste percorredor for any employ, compile o body of a routine usando o percorredor (employ); exit.
Atribua a rotina utilizada atualmente into um saved routine.
Atribua a routine à rotina utilizada atualmente.
Crie o nickname index desta routine usando 101.
Eliminate duplicate nicknames from os parameters desta routine usando o nickname index desta routine.
Compile o body of a routine (prolog).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, pare.
Compile o next statement usando o percorredor.
Repita.
Compile o body of a routine (epilog).
Atribua o saved routine à rotina utilizada atualmente.

Etapas necessárias para que se compile o body of uma routine (epilog):
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o finalize tag.
Percorra.
Obtenha uma variable from os locals desta routine.
Se o variable for inexistente, pare.
Se o categoria desta variable for "scratch", repita.
Se o type desta variable não deveria ser finalizado, repita.
Adicione another fragment usando o push address tag e o variable.
Encontre another routine usando "~finalize" e o type desta variable.
Se o other routine for inexistente, apresente uma mensagem de erro contendo "Erro interno - compile o body of uma routine (epilog)"; exit.
Adicione um terceiro fragment usando o call internal tag e o other routine.
Repita.
Adicione um fourth fragment usando o epilog tag.

Etapas necessárias para que se compile o body of uma routine (prolog):
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o prolog tag.
Adicione another fragment usando o loop tag.

Etapas necessárias para que se compile o body of a routine called um string:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Encontre uma routine usando o string e o catálogo geral de rotinas.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Eu preciso de uma função para fazer: " then o string then "."; exit.
Compile o body of a routine.

Etapas necessárias para que se compile o body of uma routine usando um percorredor (alternate palavraing):
\ *** alternate palavraing
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules). \ *** do we need this?
Atribua o next desta routine into um target routine.
Se o target routine for inexistente, apresente uma mensagem de erro contendo "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e o percorredor; exit.
Atribua o moniker deste target routine ao employs moniker desta routine.
Compile o body of o target routine.

Etapas necessárias para que se compile o body of uma routine usando um percorredor (employ):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile uma routine reference usando o percorredor.
Convert a routine reference para o employs moniker desta routine.
Destroy a routine reference.
Se o token deste percorredor não for ".", apresente uma mensagem de erro contendo "Employ statments devem terminar com um ponto, não com: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Somente um employ" e o percorredor; exit.
Encontre another routine usando o employs moniker desta routine e o catálogo geral de rotinas.
Se o other routine for inexistente, apresente a mensagem de erro contendo "Não consigo encontrar um rotina: " then o employs moniker desta routine then "' que você está tentando empregar." e o locus desta routine; exit.
Compile o body of o other routine.

Etapas necessárias para que se compile o call'd part usando um percorredor e uma variable:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Atribua o name desta variable ao type name desta variable.
Mova o percorredor (compilador rules).
Examine o name desta variable usando o percorredor.

Etapas necessárias para que se compile um endereço da pasta:
Compile o endereço da pasta (start).
Compile o endereço da pasta (load o source files).
Compile o endereço da pasta (examine o source files).
Compile o endereço da pasta (resolva o types).
Compile o endereço da pasta (resolva o globals).
Compile o endereço da pasta (compile o headers of a routines).
Compile o endereço da pasta (calculate lengths e offsets of types).
Compile o endereço da pasta (Adicione o built-in memory routines).
Compile o endereço da pasta (catalogue a routines por utility use).
Compile o endereço da pasta (compile o bodies of a routines).
Compile o endereço da pasta (Adicione e compile o built-in startup routine).
Compile o endereço da pasta (offset parameters e variables).
Compile o endereço da pasta (address).
Compile o endereço da pasta (transmogrify).
Compile o endereço da pasta (link).
Compile o endereço da pasta (write o exe).
Compile o endereço da pasta (stop).

Etapas necessárias para que se compile um endereço da pasta (Adicione e compile o built-in startup routine):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando e agrupando um tarefa de inicialização padrão...".
Start o adding built-in startup routine cronômetro.
Adicione e compile o initialize before run e run e finalize after run routine.
Suspenda o adding built-in startup routine cronômetro.

Etapas necessárias para que se compile um endereço da pasta (Adicione o built-in memory routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando como tarefas predefinidas na memória...".
Start o adding built-in memory routines cronômetro.
Adicione o allocate e deallocate e finalize e destroy routines.
Suspenda o adding built-in memory routines cronômetro.

Etapas necessárias para que se compile um endereço da pasta (address):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Obtendo endereço dos itens...".
Start o addressing cronômetro.
Atribua 4096 into um address.
Atribua o address à base desta import zona.
Address o imports usando o address.
Atribua o address menos a base desta import zona ao length desta import zona.
Round o address up para o nearest multiple of 4096.
Atribua o address à base desta zona de dados.
Address o globals usando o address.
Address o literals usando o address.
Atribua o address menos a base desta zona de dados ao length desta zona de dados.
Round o address up para o nearest multiple of 4096.
Atribua o address à base desta code zona.
Address a routines usando o address.
Atribua o address menos a base desta code zona ao length desta code zona.
Suspenda o addressing cronômetro.

Etapas necessárias para que se compile um endereço da pasta (calculate lengths e offsets of types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Calculando tamanhos e deslocamentos...".
Start o calculating cronômetro.
Calculate o lengths of o types.
Calculate o offsets no types.
Calculate o redefinition offsets no types.
Suspenda o calculating cronômetro.

Etapas necessárias para que se compile um endereço da pasta (compile o bodies of a routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando o conteúdo das tarefas...".
Start o compiling routine bodies cronômetro.
Compile o bodies of a routines.
Suspenda o compiling routine bodies cronômetro.

Etapas necessárias para que se compile um endereço da pasta (compile o headers of a routines):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando os nomes das tarefas...".
Start o compiling routine headers cronômetro.
Compile o headers of a routines.
Suspenda o compiling routine headers cronômetro.

Etapas necessárias para que se compile um endereço da pasta (catalogue a routines por utility use):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Catalogando tarefas...".
Start o indexing utilities cronômetro.
Catalogue a routines por utility use.
Scrub o catálogo de rotinas úteis.
Catalogue novamente o catálogo de rotinas úteis.
Suspenda o indexing utilities cronômetro.

Etapas necessárias para que se compile um endereço da pasta (link):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Elencando arquivos..".
Start o linking cronômetro.
Link.
Suspenda o linking cronômetro.

Etapas necessárias para que se compile um endereço da pasta (offset parameters e variables):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Deslocando parâmetros e variáveis...".
Start o offsetting cronômetro.
Offset o parameters na routines.
Offset o locals na routines.
Suspenda o offsetting cronômetro.

Etapas necessárias para que se compile um endereço da pasta (load o source files):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Carregando arquivos...".
Start o loading cronômetro.
Load o source files.
Suspenda o loading cronômetro.

Etapas necessárias para que se compile um endereço da pasta (resolva o globals):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo itens de escopo abrangente...".
Start o resolving globals cronômetro.
Resolva o globals.
Suspenda o resolving globals cronômetro.

Etapas necessárias para que se compile um endereço da pasta (resolva o types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo tipos...".
Start o resolving types cronômetro.
Resolva o types (expand coisas).
Resolva o types (registro de plurais).
Resolva o types (base types).
Resolva o types (optional info).
Suspenda o resolving types cronômetro.

Etapas necessárias para que se compile um endereço da pasta (examine o source files):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Analisando arquivos...".
Start o scanning cronômetro.
Examine o source files.
Suspenda o scanning cronômetro.

Etapas necessárias para que se compile um endereço da pasta (start):
Mostre painel de informações "Iniciando...".
Finalize o compilador.
Start o cronômetro deste compilador.
Initialize o compilador usando o endereço da pasta.
Adicione o built-in types.

Etapas necessárias para que se compile um endereço da pasta (stop):
Suspenda o cronômetro deste compilador.
Mostre painel de informações "Interrompendo".

Etapas necessárias para que se compile um endereço da pasta (transmogrify):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Modificando...".
Start o transmogrifying cronômetro.
Transmogrify a routines.
Suspenda o transmogrifying cronômetro.

Etapas necessárias para que se compile um endereço da pasta (write o exe):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mostre painel de informações "Gerando arquivo executável...".
Start o writing cronômetro.
Escreva o exe deste compilador para o endereço exe completo deste compilador.
Se o i/o erro não estiver em branco, apresente uma mensagem de erro contendo o i/o erro.
Suspenda o writing cronômetro.

Etapas necessárias para que se compile um expression usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile um term usando o percorredor.
Atribua o term ao expression.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any operator, cancele.
Se o token deste percorredor for any divided, compile o expression usando o percorredor (divided); repita.
Se o token deste percorredor for any minus, compile o expression usando o percorredor (menos); repita.
Se o token deste percorredor for any plus, compile o expression usando o percorredor (mais); repita.
Se o token deste percorredor for any then, compile o expression usando o percorredor (then); repita.
Se o token deste percorredor for any times, compile o expression usando o percorredor (times); repita.

Etapas necessárias para que se compile um expression usando um percorredor (divided):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any by, apresente uma mensagem de erro contendo "Você deve usar o termo 'divided BY'." e o percorredor; exit.
Se a variable desta expression for inexistente, apresente a mensagem de erro contendo "Termo 'divided by' inválido, há um erro na variável:: " then a phrase desta expression then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente a mensagem de erro contendo "O seu 'divided by',está errado. Não dá pra dividir por: " then a phrase deste term then "." e o percorredor; exit.
Adicione um intermediate usando o type name desta expression e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variable desta expression e "into" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "divida" e o intermediate e "por" e a variable deste term e o first deste token deste percorredor.
Atribua o intermediate à variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (menos):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'minus', está errado. Não consigo subtrair o(a): " then a phrase desta expression then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente a mensagem de erro contendo "O seu 'minus', está errado. Não consigo diminuir do(a): " then a phrase deste term then "." e o percorredor; exit.
Adicione um intermediate usando o type name desta expression e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variable desta expression e "into" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "subtraia" e a variable deste term e "from" e o intermediate e o first deste token deste percorredor.
Atribua o intermediate à variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (mais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'plus', está errado. Não consigo somar o: " then a phrase desta expression then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente a mensagem de erro contendo "O seu 'plus', está errado. Não consigo somar um: " then a phrase deste term then "." e o percorredor; exit.
Adicione um intermediate usando o type name desta expression e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variable desta expression e "into" e o intermediate e o first deste token deste percorredor.\aqui muda o atribua
Adicione several fragments usando "adicione" e a variable deste term e "to" e o intermediate e o first deste token deste percorredor. \ aqui muda o add
Atribua o intermediate à variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (then):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'then', está errado. Eu não entendi o que é o(a): " then a phrase desta expression then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente a mensagem de erro contendo "O seu 'then', está errado. Eu não sei o que é o(a): " then a phrase deste term then "." e o percorredor; exit.
Adicione um intermediate usando "string" e o first deste token deste percorredor.
Adicione o atribua ou convert fragments usando a variable desta expression e o intermediate e o first deste token deste percorredor.
Convert o term por concatenation usando o percorredor.
Adicione several fragments usando "posponha" e a variable deste term e "to" e o intermediate e o first deste token deste percorredor.
Atribua o intermediate à variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (times):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'times', está errado. Eu não sei como multiplicar o: " then a phrase desta expression then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente a mensagem de erro contendo "O seu 'times', está errado. Eu não sei como multiplicar um: " then a phrase deste term then "." e o percorredor; exit.
Adicione um intermediate usando o type name desta expression e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variable desta expression e "into" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "multiplique" e o intermediate e "por" e a variable deste term e o first deste token deste percorredor.
Atribua o intermediate à variable desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile o header of uma routine:
Se a routine for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor sobre a routine header desta routine.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any decide, compile o header of a routine usando o percorredor (decider); exit.
Se o percorredor for o start of any reverse-possessive function, compile o header of a routine usando o percorredor (reverse-possessive function); exit.
Se o percorredor for o start of any function, compile o header of a routine usando o percorredor (function); exit.
Se o token deste percorredor for "compativelmente", compile o header of a routine usando o percorredor (callback); exit.
Compile o header of a routine usando o percorredor (procedure).

Etapas necessárias para que se compile o header of uma routine usando um percorredor (callback):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Ligue o callback alarme desta routine.
Compile os monikettes desta routine e os parameters desta routine usando o percorredor.
Convert os monikettes desta routine para o moniker desta routine.
Se o moniker desta routine estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Você já tinha escrito um função: " then o moniker desta routine then "." e o locus desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma routine usando um percorredor (decider):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any conditional, apresente uma mensagem de erro contendo "Erro na sintaxe do comando 'Para que se determine se'" e o percorredor; exit.
Mova o percorredor (compilador rules).
Ligue o decider alarme desta routine.
Compile os monikettes desta routine e os parameters desta routine usando o percorredor.
Se any of os monikettes desta routine forem negative palavras, apresente a mensagem de erro contendo "Não consigo me dar bem com palavras negativas em nomes de funções decisoras." e o percorredor; exit.
Convert os monikettes desta routine para o moniker desta routine.
Se o moniker desta routine estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Você já me contou como'" then o moniker desta routine then "." e o locus desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma routine usando um percorredor (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o function alarme desta routine.
Adicione um monikette para os monikettes desta routine usando "atribua".
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile os monikettes desta routine e os parameters desta routine usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile os monikettes desta routine e os parameters desta routine usando o percorredor (artigo definido).
Se o token deste percorredor não for any possessive, apresente uma mensagem de erro contendo "Tá faltando um 's por aqui (ou está no lugar errado)." e o percorredor; exit. \ not translated - no possessives em Spanish
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Adicione another monikette para os monikettes desta routine usando "'s " then o name.
Se o token deste percorredor não for "into", apresente a mensagem de erro contendo "Eu estava esperando um palavra 'into', mas encontrei uma palavra: " then o token deste percorredor then "." e o percorredor; exit. \ not translated - no possessives em Spanish
Adicione um terceiro monikette para os monikettes desta routine usando "into".
Convert os monikettes desta routine para um moniker.
Se o moniker estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Eu já sei como: " then o moniker then "." e o locus desta routine; exit. \ not translated - no possessives em Spanish
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Estava esperando um artigo indefinido, mas achei isso aqui:: " then o token deste percorredor then "." e o percorredor; exit. \ not translated - no possessives em Spanish
Compile os monikettes desta routine e os parameters desta routine usando o percorredor (artigo indefinido).
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Tem comandos extras no fim dessa função." e o percorredor; exit. \ not translated - no possessives em Spanish
Convert os monikettes desta routine para o moniker desta routine.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas. \ por employs

Etapas necessárias para que se compile o header of uma routine usando um percorredor (procedure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile os monikettes desta routine e os parameters desta routine usando o percorredor.
Convert os monikettes desta routine para o moniker desta routine.
Se o moniker desta routine estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Você já escreveu como fazer: " then o moniker desta routine then "." e o locus desta routines; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o headers of alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Compile o header of a routine.
Repita.

Etapas necessárias para que se compile um literal usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione o literal para o literals usando o first deste token deste percorredor .
\Se o token deste percorredor for any alarme literal, compile o literal usando o percorredor (alarme); exit.
Se o token deste percorredor for any hex literal, compile o literal usando o percorredor (hex); exit.
Se o token deste percorredor for any numeric literal, compile o literal usando o percorredor (numeric); exit.
Se o token deste percorredor for any endereço de memória literal, compile o literal usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for any string literal, compile o literal usando o percorredor (string); exit.
Apresente uma mensagem de erro contendo "Erro interno - compile um term usando um percorredor (literal)" e o percorredor.

Etapas necessárias para que se compile um literal usando um percorredor (alarme):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor para um alarme.
Convert o alarme para os data deste literal.
Mova o percorredor (compilador rules).
Atribua "alarme" ao type name deste literal.
Resolva o literal. \\ Que tal utilizar os termos "decifre", "traduza", "destrinche", "decodifique"?

Etapas necessárias para que se compile um literal usando um percorredor (hex):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Atribua o token deste percorredor into um parte da cifra binária.
Adicione 1 para o first desta parte da cifra binária.
Convert o parte da cifra binária para o data deste literal.
Mova o percorredor (compilador rules).
Atribua "texto hexadecimal" ao type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - integer):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor para um número.
Convert o número para os data deste literal.
Mova o percorredor (compilador rules).
Atribua "número" ao type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - ratio):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor para um ratio.
Convert o ratio para o data deste literal.
Mova o percorredor (compilador rules).
Atribua "ratio" ao type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - with unit of measure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor para um ratio.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Encontre um type usando o name e o catálogo de tipos.
Se o type for inexistente, apresente uma mensagem de erro contendo "'" then o name then "' é uma unidade de medida inexistente." e o locus deste literal; exit.
Se o type não puder ser reduzido para "número", apresente a mensagem de erro contendo "'" then o name then "' é uma unidade de medida inválida." e o locus deste literal; exit.
Atribua a scale deste type into um final ratio.
Se a scale deste type for 0, atribua 1/1 ao final ratio.
Multiplique o final ratio pelo ratio.
Reduce o final ratio.
Se o denominador deste final ratio for 0, apresente a mensagem de erro contendo "Parece que essa é uma unidade de medida inválida." e o locus deste literal.
Atribua o numerador deste final ratio dividido pelo denominador deste final ratio into um número.
Atribua o name deste type ao type name deste literal.
Convert o número para o data deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor estiver followed por any unit of measure, compile o literal usando o percorredor (numeric - with unit of measure); exit.
Se o token deste percorredor for any integer literal, compile o literal usando o percorredor (numeric - integer); exit.
Se o token deste percorredor for any ratio literal, compile o literal usando o percorredor (numeric - ratio); exit.
Se o token deste percorredor for any mixed literal, compile o literal usando o percorredor (numeric - ratio); exit.

Etapas necessárias para que se compile um literal usando um percorredor (endereço de memória):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert 0 para os data deste literal. \ was nil
Mova o percorredor (compilador rules).
Atribua "endereço de memória" ao type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Atribua o token deste percorredor a os data deste literal.
Unquote os data deste literal.
Mova o percorredor (compilador rules).
Atribua "string" ao type name deste literal.
Resolva o literal.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for any artigo definido, compile os monikettes e o parameters usando o percorredor (artigo definido); repita.
Se o percorredor estiver sobre any artigo indefinido, compile os monikettes e o parameters usando o percorredor (artigo indefinido); repita.
Se o percorredor estiver sobre any monikette string, compile os monikettes e o parameters usando o percorredor (monikette string); repita.
Apresente uma mensagem de erro contendo "'" then o token deste percorredor then "' não é um nome de função que eu conheça." e o percorredor.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (artigo definido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Anteponha "the " para o name.
Adicione um monikette para os monikettes usando o name.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (artigo indefinido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um parameter para o parameters usando "parameter" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", atribua "segunda" ao name deste parameter.
Se o token deste percorredor for "outro", atribua "segundo" ao name deste parameter.
\CAL
Se o token deste percorredor for "another", atribua "other" ao name deste parameter.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o name destes parameter with o name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o parameter.
Resolva o parameter.
Se o parameter estiver duplicated no parameters, apresente uma mensagem de erro contendo "Cara, você repetiu o parâmetro: " then o name deste parameter then "." e o locus deste parameter; exit.
Adicione um monikette para os monikettes usando o type deste parameter.

Etapas necessárias para que se compile alguns monikettes e alguns parameters usando um percorredor (monikette string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette para os monikettes usando o token deste percorredor.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile alguns monikettes usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor está sobre any monikette string, adicione um monikette para os monikettes usando o token deste percorredor; mova o percorredor (compilador rules); repita.
Se o token deste percorredor não for o start of any expression, cancele.
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione another monikette para os monikettes usando o expression.
Repita.

\Etapas necessárias para que se compile alguns monikettes usando um percorredor:
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Se o token deste percorredor for any monikette string, adicione um monikette para os monikettes usando o token deste percorredor; mova o percorredor (compilador rules); repita.
\Se o token deste percorredor não for o start of any expression, cancele.
\Compile um expression usando o percorredor.
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Adicione another monikette para os monikettes usando o expression.
\Repita.

Etapas necessárias para que se compile o next statement usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any conditional, compile o next statement usando o percorredor (if); exit.
Se o token deste percorredor for any loop, compile o next statement usando o percorredor (loop); exit.
Se o token deste percorredor for any privatize, compile o next statement usando o percorredor (privatize); exit.
Se o token deste percorredor não for o start of any statement, apresente uma mensagem de erro contendo "Eu esperava uma declaração aqui, mas encontrei: " then o token deste percorredor then "." e o percorredor; exit.
Compile o next statement usando o percorredor (other).
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Tem algum problema nesse comando aqui." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (break):
Adicione um fragment usando o break tag.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (call - external):
Atribua o token deste percorredor into um string.
Unquote o string.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any string literal, apresente uma mensagem de erro contendo "Cara, você precisa colocar os nomes entre aspas, mas você colocou: " then o token deste percorredor then "." e o percorredor; exit.
Atribua o token deste percorredor into another string.
Unquote o other string.
Mova o percorredor (compilador rules).
Adicione um entry para o imports usando o string e o other string.
Se o token deste percorredor for "with", compile o next statement usando o percorredor (call - with clause).
Se o token deste percorredor for "returning", compile o next statement usando o percorredor returning um term (call - returning part).
Adicione um fragment usando o call external tag e o entry.
Se o term estiver vazio, cancele.
Se a variable deste term for inexistente, apresente a mensagem de erro contendo "Não entendi bem o que é: " then a phrase deste term then "." e o percorredor; exit.
Adicione another fragment usando o save eax tag e a variable deste term.

Etapas necessárias para que se compile o next statement usando um percorredor (call - indirect):
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, apresente uma mensagem de erro contendo "Eu não sei o que é: " then a phrase desta expression then "." e o percorredor; exit.
Se o type desta expression não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Eu preciso de um endereço de memória type nesse CALL statement." e o percorredor; exit.
Se o token deste percorredor for "with", compile o next statement usando o percorredor (call - with clause).
Se o token deste percorredor for "returning", compile o next statement usando o percorredor returning um term (call - returning part).
Adicione um fragment usando o call indirect tag e a variable desta expression.
Se o term estiver vazio, cancele.
Se a variable deste term for inexistente, apresente a mensagem de erro contendo "Acho que essa varíavel é inválida:: " then a phrase deste term then "." e o percorredor; exit.
Adicione another fragment usando o save eax tag e a variable deste term.

Etapas necessárias para que se compile o next statement usando um percorredor (call - internal):
Compile alguns monikettes usando o percorredor.
Encontre uma routine usando os monikettes.
Se a routine não for inexistente, adicione push fragments usando os monikettes.
Se a routine não for inexistente, destroy os monikettes; adicione um fragment usando o call internal tag e a routine; exit.
Convert os monikettes para um moniker.
Destroy os monikettes.
\Atribua "Eu ainda não aprendi como" à reply.
\Say o reply.
Atribua o moniker à reply.
\Say o reply.
Apresente uma mensagem de erro contendo "Eu ainda não aprendi como: " then o moniker then "." e o percorredor.

Etapas necessárias para que se compile o next statement usando um percorredor (call - with clause):
\ this guy é recursise so parameters obtenha passed right para left
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, apresente uma mensagem de erro contendo "Eu não entendo um variável:: " then a phrase desta expression then "." e o percorredor; exit.
Se o type desta expression não for value pushable, apresente a mensagem de erro contendo "'" then o name deste type desta expression then "' não pode ser processado corretamente." e o percorredor; exit.
Se o token deste percorredor for any and, compile o next statement usando o percorredor (call - with clause).
Adicione um fragment usando o push value tag e a variable desta expression.

Etapas necessárias para que se compile o next statement usando um percorredor (call):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any string literal, compile o next statement usando o percorredor (call - external); exit.
Compile o next statement usando o percorredor (call - indirect).

Etapas necessárias para que se compile o next statement usando um percorredor (exit):
Se o decider alarme desta rotina utilizada atualmente estiver ativo, apresente uma mensagem de erro contendo "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" e o percorredor; exit.
Adicione um fragment usando o exit tag.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (if):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile alguns monikettes usando o percorredor.
Remove any negatives from os monikettes returning um alarme.
Encontre uma routine usando os monikettes.
Se a routine não for inexistente, adicione push fragments usando os monikettes.
Se a routine for inexistente, convert os monikettes para um moniker.
Destroy os monikettes.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Preciso de um decider que tenha como palavras:: " then o moniker then "." e o percorredor; exit.
Se o decider alarme desta routine não estiver ativo, apresente a mensagem de erro contendo "Cara eu vou precisar de um decider aqui, blz?" e o percorredor; exit.
Se o token deste percorredor não for a vírgula, apresente a mensagem de erro contendo "Acho que você esqueceu de uma vírgula, eu achei isso aqui:: " then o token deste percorredor then "." e o percorredor; exit.
Adicione um fragment usando o call internal tag e a routine.
Se o alarme estiver ativo, adicione another fragment usando o not tag.
Adicione um terceiro fragment usando o jump false tag.
Mova o percorredor (compilador rules).
Percorra.
Compile o next statement usando o percorredor (other).
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for o ponto&vírgula, mova o percorredor (compilador rules); repita.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você precisa usar um ponto ao invés de usar o termo: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Adicione um fourth fragment usando o end if tag.

Etapas necessárias para que se compile o next statement usando um percorredor (intel):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any hex literal, apresente uma mensagem de erro contendo "Eu preciso de um pouco de machine code, mas o que eu achei foi: " then o token deste percorredor then "." e o percorredor; exit.
Adicione um fragment usando o intel tag.
Atribua o token deste percorredor into um parte da cifra binária.
Adicione 1 para o first desta parte da cifra binária.
Convert o parte da cifra binária para o code deste fragment.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (loop):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um fragment usando o loop tag.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Parece que alguém esqueceu de colocar um ponto por aí." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (other):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for any exit, compile o next statement usando o percorredor (exit); exit.
Se o token deste percorredor for any repeat, compile o next statement usando o percorredor (repeat); exit.
Se o token deste percorredor for any break, compile o next statement usando o percorredor (break); exit.
Se o token deste percorredor for any say, compile o next statement usando o percorredor (say); exit.
Se o token deste percorredor for "intel", compile o next statement usando o percorredor (intel); exit.
Se o token deste percorredor for "push", compile o next statement usando o percorredor (push); exit.
Se o token deste percorredor for any call, compile o next statement usando o percorredor (call); exit.
Se o token deste percorredor for any point, compile o next statement usando o percorredor (point); exit.
Se o token deste percorredor for any conditional, apresente uma mensagem de erro contendo "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." e o percorredor; exit.
Se o token deste percorredor for any privatize, apresente a mensagem de erro contendo "A sentença 'privatizar' não pode ser usada aqui." e o percorredor; exit.
Se o token deste percorredor for any loop, apresente a mensagem de erro contendo "Usar um percorra dentro de um SE for uma ótima forma de arranjar problemas." e o percorredor; exit.
Se o token deste percorredor for any employ, apresente a mensagem de erro contendo "'Empregue' deve ser o único imperativo em uma rotina." e o percorredor; exit.
Compile o next statement usando o percorredor (call - internal).

Etapas necessárias para que se compile o next statement usando um percorredor (point):
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Acho que o termo: " then a phrase deste term then "' está vazio." e o percorredor; exit.
Se o categoria deste term for "literal", apresente a mensagem de erro contendo "Você usou o tipo errado de variável aqui (literal)." e o percorredor.
Se o length deste type deste term não for 4, apresente a mensagem de erro contendo "Você usou uma variável de comprimento errado (<>4)." e o percorredor.
Se o token deste percorredor não for "to", apresente a mensagem de erro contendo "Acho que faltou um 'to', mas você usou: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for "routine", apresente a mensagem de erro contendo "Acho que faltou a palavra 'routine'. Você usou o termo: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile uma routine reference usando o percorredor.
Convert a routine reference para um moniker.
Destroy a routine reference.
Encontre uma routine usando o moniker e o catálogo geral de rotinas.
Se a routine for inexistente, apresente a mensagem de erro contendo "Não achei a tarefa: " then o moniker then "' que você falou." e o percorredor; exit.
Adicione um fragment usando a routine address tag e a routine.
Atribua a variable deste term à variable deste fragment.

Etapas necessárias para que se compile o next statement usando um percorredor (privatize):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Comando 'privatize', Inválido. Eu acho que o termo da variável: " then a phrase deste term then "' está vazio." e o percorredor; exit.
Se o categoria deste term não for "parameter", apresente a mensagem de erro contendo "Você só pode privatizar parâmetros." e o percorredor; exit.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
Atribua o name deste term ao name deste local.
Atribua o nickname deste term ao nickname deste local.
Atribua o type name deste term ao type name deste local.
Resolva o local.
Anteponha "original " para o name deste term.
Se o nickname deste term não estiver em branco, Anteponha "original " para o nickname deste term.
Adicione several fragments usando "atribua" e a variable deste term e "into" e o local e o first deste token deste percorredor.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você vive esquecendo dos pontos né?." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile o next statement usando um percorredor (push):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile um expression usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable desta expression for inexistente, apresente uma mensagem de erro contendo "Comando 'push' inválido, um expressão: " then a phrase desta expression then "' parece estar vazia." e o percorredor; exit.
Se o type desta expression não for value pushable, apresente a mensagem de erro contendo "Valores do tipo: " then o name deste type desta expression then "' não podem ser pushed." e o percorredor; exit.
Adicione um fragment usando o push value tag e a variable desta expression.

Etapas necessárias para que se compile o next statement usando um percorredor (repeat):
Adicione um fragment usando o repeat tag.
Mova o percorredor (compilador rules).

\Etapas necessárias para que se compile o next statement usando um percorredor (say):
\Se o decider alarme desta rotina utilizada atualmente não estiver ativo, compile o next statement usando o percorredor (call - internal); exit.
\Mova o percorredor (compilador rules).
\Compile um expression usando o percorredor.
\Se o alarme de alerta deste compilador estiver ativado, cancele.
\Se a variable desta expression for inexistente, apresente uma mensagem de erro contendo "No es válido este 'diga', no entiendo la variable: " then a phrase desta expression then "." e o percorredor; exit.
\Se o type desta expression não puder ser reduzido para "alarme", apresente uma mensagem de erro contendo "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; exit.
\Adicione um fragment usando o load eax tag e a variable desta expression.
\Adicione another fragment usando o exit tag.

Etapas necessárias para que se compile o next statement usando um percorredor (say):
Se o decider alarme desta rotina utilizada atualmente não estiver ativo, compile o next statement usando o percorredor (call - internal); exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any decider literal, apresente uma mensagem de erro contendo "Você precisa terminar com um yes ou no." e o percorredor; exit.
Desative um alarme. Se o token deste percorredor for any positive decider literal, acione o alarme.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Faltou um ponto. Você usou o termo:: " then o token deste percorredor then "." e o percorredor; exit.
Adicione um fragment usando o load eax tag e o alarme.
Adicione another fragment usando o exit tag.

Etapas necessárias para que se compile o next statement usando um percorredor returning um term (call - returning part):
Mova o percorredor (compilador rules).
Compile o term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Eu não compreendi o termo da variável: " then a phrase deste term then "'. Ela parece estar vazia." e o percorredor; exit.
Se o type deste term não for value pushable, apresente a mensagem de erro contendo "Uma varíavel de 1, 2, ou 4-pedaços é necessária na 'returning' clause." e o percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor:
Se o token deste percorredor for "to", mova o percorredor (compilador rules).
Se o percorredor for o start of any function, compile a routine reference usando o percorredor (function); exit.
Se o token deste percorredor for any decide, compile a routine reference usando o percorredor (decide).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for ".", cancele.
Se o token deste percorredor for any artigo definido, compile a routine reference usando o percorredor (artigo definido); repita.
Se o token deste percorredor for any artigo indefinido, compile a routine reference usando o percorredor (artigo indefinido); repita.
Se o percorredor está sobre any monikette string, compile a routine reference usando o percorredor (monikette string); repita.
Apresente uma mensagem de erro contendo "'" then o token deste percorredor then "' não é válido em um employ statement." e o percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor (decide):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any conditional, apresente uma mensagem de erro contendo "Sempre use DECIDE IF, ao invés de apenas DECIDE com: " then o token deste percorredor then "' logo em seguida." e o percorredor; exit.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile uma routine reference usando um percorredor (artigo definido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Anteponha "the " para o name.
Adicione um monikette para a routine reference usando o name.

Etapas necessárias para que se compile uma routine reference usando um percorredor (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette para a routine reference usando "atribua".
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile a routine reference usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile a routine reference usando o percorredor (artigo definido).
Se o token deste percorredor não for any possessive, apresente uma mensagem de erro contendo "Eu estava esperando un 's, mas apareceu: " then o token deste percorredor then "." e o percorredor; exit. \ not translated - no possessives em Spanish
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Adicione another monikette para a routine reference usando "'s " then o name.
Se o token deste percorredor não for "into", apresente a mensagem de erro contendo "E estava esperando um palavra 'into', mas encontrei: " then o token deste percorredor then "." e o percorredor; exit. \ not translated - no possessives em Spanish
Adicione um terceiro monikette para a routine reference usando "into".
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Eu estava esperando um artigo indefinido mas encontrei isso:: " then o token deste percorredor then "." e o percorredor; exit. \ not translated - no possessives em Spanish
Compile a routine reference usando o percorredor (artigo indefinido).

Etapas necessárias para que se compile uma routine reference usando um percorredor (artigo indefinido):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Encontre um type e um nickname usando o name.
Se o type for inexistente, apresente uma mensagem de erro contendo "Employ statement inválido, Eu não sei o que é: " then o name then "." e o percorredor; exit.
Adicione um monikette para a routine reference usando o type.

Etapas necessárias para que se compile uma routine reference usando um percorredor (monikette string):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um monikette para a routine reference usando o token deste percorredor.
Mova o percorredor (compilador rules).

Etapas necessárias para que se compile um term usando um percorredor:
Limpe o term.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile o term usando o percorredor (common part).
Se o percorredor está sobre any simile, cancele. \ added for invisible turtle project ***
\Se o token deste percorredor for "as", compile o term usando o percorredor (as part). \preposição
\Se o token deste percorredor for "tão", compile o term usando o percorredor (as part). \ me parece desnecessário por ser usado apenas em funções.
Se o token deste percorredor for "quão", compile o term usando o percorredor (as part).
Se o token deste percorredor for "quanto", compile o term usando o percorredor (as part).
Se o token deste percorredor for "como", compile o term usando o percorredor (as part).
\Se o token deste percorredor for "que nem", compile o term usando o percorredor (as part).
Se o token deste percorredor for "/", compile o term usando o percorredor (runtime ratio).

Etapas necessárias para que se compile um term usando um percorredor (as part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Comando 'as'inválido. Eu acho que um variável: " then a phrase deste term then "' está vaiza." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Tá faltando um artigo indefinido depois do 'como', mas você escreveu: " then o token deste percorredor then "' no lugar disso." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine um type name usando o percorredor.
Encontre um type usando o type name e o catálogo de tipos.
Se o type for inexistente, apresente a mensagem de erro contendo "Eu não sei em qual tipo o: " then o type name then "' se encaixa." e o percorredor; exit.
Adicione um scratch usando o name deste type e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variable deste term e o scratch.
Atribua o scratch à variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (common part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for o hífem, compile o term usando o percorredor (negated term); exit.
Se o token deste percorredor for o sinal de adição, compile o term usando o percorredor (posigated term); exit.
Se o token deste percorredor for o start of any variable, compile o term usando o percorredor (variable); exit.
Se o token deste percorredor for o start of any new local, compile o term usando o percorredor (new local); exit.
Se o token deste percorredor for any literal, compile o term usando o percorredor (literal); exit.
Apresente uma mensagem de erro contendo "Faltou um termo por aqui. Só achei isso aqui:: " then o token deste percorredor then "." e o percorredor.

Etapas necessárias para que se compile um term usando um percorredor (dereference - em place):
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Erro interno na função - compile um term usando um percorredor (dereference - em place). Termo vazio" e o percorredor; exit.
Atribua o name deste target type deste type deste term ao type name deste term.
Atribua o target type deste type deste term ao type deste term.
Adicione um fragment usando o dereference tag e a variable deste term.
Limpe o phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (dereference):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Dereference inválido, um variável: " then a phrase deste term then "' parece estar vazia." e o percorredor; exit.
Se o target type deste type deste term for inexistente, apresente a mensagem de erro contendo "Não consegui identificar o tipo desse target." e o percorredor; exit.
Se a categoria deste term for "scratch", compile o term usando o percorredor (dereference - em place); exit.
Adicione um scratch usando o name deste target type deste type deste term e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variable deste term e o scratch.
Adicione another fragment usando o dereference tag e o scratch.
Atribua o scratch ao variable deste term.
Limpe o phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (literal):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Compile um literal usando o percorredor.
Atribua o literal ao variable deste term.
Limpe o phrase deste term.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor (negated term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile another term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste other term for inexistente, apresente uma mensagem de erro contendo "Negate inválido, um variável: " then o phrase deste other term then "' parece estar vazia." e o percorredor; exit.
Adicione um intermediate usando o type name deste other term e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e o variable deste other term e "into" e o intermediate e o locus deste other term.
Adicione two fragments usando "negate" e o intermediate e o first deste token deste percorredor.
Atribua o intermediate ao variable deste term.
Limpe o phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (new local):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e o percorredor; exit.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", atribua "segunda" ao name deste local.
Se o token deste percorredor for "outro", atribua "segundo" ao name deste local.
\CAL
Se o token deste percorredor for "another", atribua "other" ao name deste local.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o name deste local with o name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicated em os parameters desta rotina utilizada atualmente, apresente a mensagem de erro contendo "o parâmetro: " then o name deste local then "' já está sendo usado como parâmetro." e o locus deste local; exit.
Se o local estiver duplicated em os locals desta rotina utilizada atualmente, apresente a mensagem de erro contendo "Já existe uma variável local chamada'" then o name deste local then "'. Você tem que dar um nome diferente." e o locus deste local; exit.
Eliminate duplicate nicknames usando o local e o nickname index desta rotina utilizada atualmente.
Atribua o local à variable deste term.
Limpe a phrase deste term.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor (posigated term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Compile o term usando o percorredor.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Posigate inválido, o termo da variável'" then a phrase deste term then "' parece estar vazio." e o percorredor; exit.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (possessive - magnitude):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Use da magnitude inválido. A variável: " then a phrase deste term then "' parece estar vazia." e o percorredor; exit.
Adicione um literal para o literals usando o first deste token deste percorredor.
Convert o length deste type deste term para os data deste literal.
Atribua "número" ao type name deste literal.
Resolva o literal.
Atribua o literal à variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (possessive - target):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Você usou o target de forma errada. O termo da variável: " then a phrase deste term then "' parece estar vazio." e o percorredor; exit.
Se o type deste term não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Você só pode usar target com tipos endereço de memória." e o percorredor; exit.
Compile o term usando o percorredor (dereference).

Etapas necessárias para que se compile um term usando um percorredor (possessive - whereabouts):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Você usou whereabouts da forma errada, erro no termo da variável: " then a phrase deste term then "." e o percorredor; exit.
Adicione um intermediate usando "endereço de memória" e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variable deste term e o intermediate.
Atribua o intermediate à variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (possessive):
\ similar para "compile um term usando um percorredor (reverse-possessive)
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o name for any magnitude, compile o term usando o percorredor (possessive - magnitude); exit.
Se o name for any target, compile o term usando o percorredor (possessive - target); exit.
Se o name for any whereabouts, compile o term usando o percorredor (possessive - whereabouts); exit.
Compile o term usando o percorredor e o name (possessive - campo).

Etapas necessárias para que se compile um term usando um percorredor (possessives):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any possessive, cancele.
Compile o term usando o percorredor (possessive).
Repita.

Etapas necessárias para que se compile um term usando um percorredor (runtime ratio):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável: " then a phrase deste term then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Compile another term usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable deste other term for inexistente, apresente a mensagem de erro contendo "Uso inválido da /, termo vazio da variável:: " then o phrase deste other term then "." e o percorredor; exit.
Adicione um intermediate usando "ratio" e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variable deste term e "e" e a variable deste other term e "into" e o intermediate e o first deste token deste percorredor.
Atribua o intermediate à variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor (variable):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Erro de tarefa vazia, nada pra pull da pilha aqui." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o percorredor está sobre any reverse-possessive, compile o term usando o percorredor e o name (reverse-possessive); exit.
Encontre uma variable usando o name.
Atribua o variable à variable deste term.
Atribua "the " à phrase deste term.
Posponha o name para a phrase deste term.
Compile o term usando o percorredor (possessives).

Etapas necessárias para que se compile um term usando um percorredor e um campo name (reverse-possessive):
\ this é recursive \ dahn version 2
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules). \ past o reverse-possessive starter
\Se o token deste percorredor não for "del", Mova o percorredor (compilador rules). \ past o reverse-possessive starter \ gerry added "if" part
\Se o token deste percorredor for "del", adicione 1 para o first deste token deste percorredor. \ makes "del" look like "de el"
Se o token deste percorredor não for any article, apresente uma mensagem de erro contendo "Esperaba un artículo, pero encontré: " then o token deste percorredor then "."; exit.
Atribua o token deste percorredor into um article token.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o percorredor está sobre any reverse-possessive, acione um reverse-possessive alarme.
Se o reverse-possessive alarme estiver ativo, compile o term usando o percorredor e o name (reverse-possessive).
Se o reverse-possessive alarme não estiver ativo, compile o term usando o percorredor e o name e o article (reverse-possessive prepare para unwind).
Compile o term usando o campo name e o percorredor (reverse-possessive).

Etapas necessárias para que se compile um term usando um percorredor e uma variable name e um article token (reverse-possessive prepare para unwind):
\ dahn version 2
Se o article for o start of any variable, compile o term usando o percorredor e o variable name e o article (reverse-possessive prepare para unwind existing variable); exit.
Compile o term usando o percorredor e o variable name (reverse-possessive prepare para unwind new local).

Etapas necessárias para que se compile um term usando um percorredor e uma variable name e um article token (reverse-possessive prepare para unwind existing variable):
\ dahn version 2
Encontre uma variable usando o variable name.
Se o variable for inexistente, apresente uma mensagem de erro contendo "No se pudo encontrar una variable con el nombre: " then o variable name then ".".
Atribua o variable à variable deste term.
Atribua "the " à phrase deste term.
Posponha o variable name para a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor e uma variable name (reverse-possessive prepare para unwind new local):
\ dahn version 2
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", atribua "segunda" ao name deste local.
Se o token deste percorredor for "outro", atribua "segundo" ao name deste local.
\CAL
Se o token deste percorredor for "another", atribua "other" ao name deste local.
Extend o name deste local with o variable name.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicated em os parameters desta rotina utilizada atualmente, apresente uma mensagem de erro contendo "O termo: " then o name deste local then "' já está sendo usado como parâmetro." e o locus deste local; exit.
Se o local estiver duplicated em os locals desta rotina utilizada atualmente, apresente a mensagem de erro contendo "O termo: " then o name deste local then "' já está sendo usado como variável local." e o locus deste local; exit.
Eliminate duplicate nicknames usando o local e o nickname index desta rotina utilizada atualmente.
Atribua o local à variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um campo name e um percorredor (reverse-possessive):
\ similar para "compile um term usando um percorredor (possessive)" \ dahn
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o campo name for any magnitude, compile o term usando o percorredor (possessive - magnitude); exit.
Se o campo name for any target, compile o term usando o percorredor (possessive - target); exit.
Se o campo name for any whereabouts, compile o term usando o percorredor (possessive - whereabouts); exit.
Compile o term usando o percorredor e o campo name (possessive - campo).

Etapas necessárias para que se compile um term usando um percorredor e um campo term:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o dereference alarme deste campo term estiver ativo, compile o term usando o percorredor (dereference).
Se o function deste campo term não for inexistente, compile o term usando o percorredor e o campo term (function); exit.
Se o categoria deste term for "scratch", compile o term usando o percorredor e o campo term (in place); exit.
Atribua o campo deste campo term into um campo.
Adicione um scratch usando o name deste type deste campo e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variable deste term e o scratch.
Se o offset deste campo não for 0, adicione um terceiro fragment usando o increment tag e o scratch e o offset deste campo.
Atribua o scratch à variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor e um campo term (function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Atribua o function deste campo term into uma routine.
Atribua o last destes parameters desta routine into um parameter.
Se o parameter for inexistente, apresente uma mensagem de erro contendo "Erro interno na função compile um term usando um percorredor e um campo term (function) - parâmetro vazio." e o percorredor; exit.
Se o type deste parameter for inexistente, apresente a mensagem de erro contendo "Erro interno 2 na função compile um term usando um percorredor e um campo term (function) - tipo do parâmetro inexistente." e o percorredor; exit.
Adicione um intermediate usando o name deste type deste parameter e o first deste token deste percorredor.
Adicione um fragment usando o push address tag e o intermediate.
Se o push alarme deste campo term estiver ativo, adicione another fragment usando o push address tag e a variable deste term.
Adicione um terceiro fragment usando o call internal tag e a routine.
Atribua o intermediate à variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor e um campo term (in place):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Atribua o campo deste campo term into um campo.
Atribua o name deste type deste campo ao type name deste term.
Atribua o type deste campo ao type deste term.
Se o offset deste campo não for 0, adicione um terceiro fragment usando o increment tag e a variable deste term e o offset deste campo.
Limpe a phrase deste term.

Etapas necessárias para que se compile um term usando um percorredor e um name (possessive - campo):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a variable deste term não for inexistente, atribua o type deste term into um type.
Encontre um campo term usando o phrase deste term e o type e o name.
Se o campo term não for vazio, compile o term usando o percorredor e o campo term; exit.
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Erro: variável vazia: " then a phrase deste term then "." e o percorredor; exit.
Se o type puder ser reduzido para "endereço de memória", atribua o target type deste type ao type.
Se o type for inexistente, apresente a mensagem de erro contendo "Não existe o campo: " then o name then "' no tipo: " then o name deste type deste term then "." e o percorredor; exit.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um campo from os campos deste type.
Se o campo for inexistente, apresente a mensagem de erro contendo "Não tem nenhum campo: " then o name then "' no tipo: " then o name deste type deste term then "." e o percorredor; exit.
Encontre um deep campo term usando "" e o type deste campo e o name.
Se o deep campo term estiver vazio, repita.
Atribua o campo into um first campo term's campo.
Se o type deste term puder ser reduzido para "endereço de memória", acione o dereference alarme deste first campo term.
Compile o term usando o percorredor e o first campo term.
Compile o term usando o percorredor e o deep campo term.

O compilador é um conjunto with
Um endereço da pasta,
Um cronômetro,
Um abort alarme,
Um alarme de alerta, \new line
Um mensagem de erro,
Um abort endereço completo,
Um abort número da linha,
Um name contagem,
Um exe trecho,
Um listing trecho.

O compiling routine bodies cronômetro é um cronômetro.

O compiling routine headers cronômetro é um cronômetro.

Etapas necessárias para que se convert alguns monikettes para um moniker:
Convert os monikettes para o moniker usando o last destes monikettes.

Etapas necessárias para que se convert alguns monikettes para um moniker usando um monikette:
Limpe o moniker.
Percorra.
Obtenha um current monikette from os monikettes.
Se o current monikette for inexistente, cancele.
Posponha o current monikette para o moniker.
Se o current monikette for o monikette, cancele.
Repita.

Etapas necessárias para que se convert uma parte da cifra binária para um string:
Employ convert um texto da cifra binária para um texto hexadecimal.

Etapas necessárias para que se convert um term por concatenation usando um percorredor:
\ used for right-side THEN operand
Se a variable deste term for inexistente, apresente uma mensagem de erro contendo "Erro: variável do termo está vazia: " then a phrase deste term then "." e o percorredor; exit.
Se o type deste term puder ser reduzido para "string", cancele.
Adicione um intermediate usando "string" e o first deste token deste percorredor.
Adicione o atribua ou convert fragments usando a variable deste term e o intermediate e o first deste token deste percorredor.
Atribua o intermediate à variable deste term.
Limpe a phrase deste term.

Etapas necessárias para que se copy um campo into another campo:
Se o campo for inexistente, esvazie o other campo; exit.
Allocate memory pelo other campo.
Atribua o locus deste campo ao locus deste other campo.
Atribua o name deste campo ao name deste other campo.
Atribua o nickname deste campo ao nickname deste other campo.
Atribua o type name deste campo ao type name deste other campo.
Atribua o type deste campo ao type deste other campo.
Atribua a contagem deste campo à contagem deste other campo.
Atribua o redefinition target name deste campo ao redefinition target name deste other campo.
Atribua o reference alarme deste campo ao reference alarme deste other campo.
Atribua o offset deste campo ao offset deste other campo.

Etapas necessárias para que se copy alguns campos into alguns other campos:
Obtenha um campo from o campos.
Se o campo for inexistente, cancele.
Copy o campo into another campo.
Posponha o other campo para o other campos.
Repita.

Etapas necessárias para que se copy alguns campos into alguns other campos (data campos only):
Se a contagem destes campos for menor do que 4, cancele. \ for english next e prev e spanish next e prev redefinitions
\Se o first destes campos for inexistente, cancele.
\Se o next deste first destes campos for inexistente, cancele.
\Se o next deste next deste first destes campos for inexistente, cancele.
\\Atribua o next deste next deste first destes campos into um campo. \ skip next e prev
\Se o next deste next deste next deste first destes campos for inexistente, cancele.
\Se o next deste next deste next deste next deste first destes campos for inexistente, cancele.
\Se o next deste next deste next deste next deste next deste first destes campos for inexistente, cancele.
\Atribua o next deste next deste next deste next deste first destes campos into um campo.
Atribua o next deste next deste next deste next deste first destes campos into um campo.\ english next e prev e spanish next e prev redefinitions
Percorra.
Se o campo for inexistente, cancele.
Copy o campo into another campo.
Posponha o other campo para o other campos.
Obtenha o campo from o campos.
Repita.

Etapas necessárias para que se copy um monikette into another monikette:
Se o monikette for inexistente, esvazie o other monikette; exit.
Allocate memory pelo other monikette.
Atribua o string deste monikette ao string deste other monikette.
Atribua o type deste monikette ao type deste other monikette.
Atribua a variable deste monikette ao variable deste other monikette.
\ don't copy subtexto
Atribua o type atual deste monikette ao type atual deste other monikette.

Etapas necessárias para que se copy alguns monikettes into alguns other monikettes:
Destroy o other monikettes.
Percorra.
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Copy o monikette into another monikette.
Posponha o other monikette para o other monikettes.
Repita.

Etapas necessárias para que se crie um entry:
Allocate memory pelo entry.

Etapas necessárias para que se crie um fragment usando uma tag:
Allocate memory pelo fragment.
Atribua o tag à tag deste fragment.

Etapas necessárias para que se crie um import:
Allocate memory pelo import.

Etapas necessárias para que se crie um monikette:
Allocate memory pelo monikette.

Etapas necessárias para que se crie uma routine:
Allocate memory pela routine.

Etapas necessárias para que se crie um source file:
Allocate memory pelo source file.

Etapas necessárias para que se crie um type:
Allocate memory pelo type.
Atribua 0/1 ao scale deste type.
Atribua -1 ao length deste type.

Etapas necessárias para que se crie uma variable usando um categoria:
Allocate memory pelo variable.
Atribua o categoria à categoria desta variable.
Atribua 1 ao contagem desta variable.

O endereço do cabeçalho usado atualmente é um address.

O endereço do nome usado atualmente é um address.

O rotina utilizada atualmente é uma routine.

O current thunk address é um address.

O zona de dados é um zona.

Etapas necessárias para que se determine se any of alguns monikettes são negative palavras:
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, diga não.
Se o string deste monikette for any negative palavra, diga sim.
Repita.

Etapas necessárias para que se determine se um pedaço é any glom pedaço:
Se o pedaço for any letra, diga sim.
Se o pedaço for any digit, diga sim.
Se o pedaço for o acento til, diga sim.
Se o pedaço for o sinal de arroba, diga sim.
Se o pedaço for o número-sign pedaço, diga sim.
Se o pedaço for o sinal de porcentagem, diga sim.
Se o pedaço for o & comercial, diga sim.
Se o pedaço for o underscore pedaço, diga sim.
Se o pedaço for o single-quote pedaço, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any mark:
Se o pedaço for o ponto final, diga sim.
Se o pedaço for o vírgula, diga sim.
Se o pedaço for o ponto&vírgula, diga sim.
Se o pedaço for o sinal de dois pontos, diga sim.
Se o pedaço for o exclamation pedaço, diga sim.
Se o pedaço for o question-mark pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any stressed vowel:
Se o pedaço estiver em "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
Diga não.

Etapas necessárias para que se determine se um pedaço é any symbol:
Se o pedaço for o caret pedaço, diga sim.
Se o pedaço for o barra vertical, diga sim.
Se o pedaço for o asterisco, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Se o pedaço for o left-alligator pedaço, diga sim.
Se o pedaço for o right-alligator pedaço, diga sim.
Se o pedaço for o left-brace pedaço, diga sim.
Se o pedaço for o right-brace pedaço, diga sim.
Se o pedaço for o sinal de igualdade, diga sim.
Se o pedaço for 128, diga sim.
Se o pedaço for 130, diga sim.
Se o pedaço estiver entre 132 e 137, diga sim.
Se o pedaço for 139, diga sim.
Se o pedaço estiver entre 145 e 153, diga sim.
Se o pedaço for 155, diga sim.
Se o pedaço estiver entre 161 e 180, diga sim.
Se o pedaço estiver entre 183 e 191, diga sim.
Se o pedaço for 215, diga sim.
Se o pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um campo term está vazia;
Etapas necessárias para que se determine se um campo term estão vazias;
Etapas necessárias para que se determine se um campo term estão vazios;
Etapas necessárias para que se determine se um campo term está vazio:
Se o campo deste campo term não for inexistente, diga não.
Se a function deste campo term não for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se alguns campos deveriam ser finalizados;
Etapas necessárias para que se determine se alguns campos deveria ser finalizado:
Obtenha um campo from o campos.
Se o campo for inexistente, diga não.
Se o type deste campo deveria ser finalizado, diga sim.
Repita.

Etapas necessárias para que se determine se um item looks reamish:
Load o endereço completo deste item into um trecho.
Se o trecho starts with "ream cal", diga sim.
Diga não.

Etapas necessárias para que se determine se um moniker estiver em um index:
Encontre um refer usando o moniker e o index.
Se o refer for inexistente, diga não.
Se o endereço de memória deste refer for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se o monikette for inexistente, diga sim.
Se o type atual deste monikette não for inexistente, diga não.
Se o subtexto atual deste monikette não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um name é any magnitude:
\PAL
Se o name for "magnitude", diga sim.
\CAL
Se o name for "magnitud", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any target:
\PAL
Se o name for "conteúdo", diga sim.
Se o name for "alvo", diga sim.
\CAL
Se o name for "target", diga sim.
Se o name for "objetivo", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any whereabouts:
\PAL
Se o name for "paradeiro", diga sim.
\CAL
Se o name for "whereabouts", diga sim.
Diga não.

Etapas necessárias para que se determine se um name é any valid campo name:
Se o name for any magnitude, diga não.
Se o name for any target, diga não.
Se o name for any whereabouts, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está followed por any unit of measure:
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o percorredor não for sobre any name starter, diga não.
Examine um name usando o percorredor.
Encontre um type usando o name e o catálogo de tipos.
Se o type for inexistente, diga não.
Se o name não for "times", diga sim. \ special because times é um infix operator e um unit of measure
\Se o name não for "vezes", diga sim.
Se o token deste percorredor for o start of any expression, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre any nested double-quote:
Se o source deste percorredor starts with """""", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any possessive:
Se o source deste percorredor estiver em branco, diga não.
Se o target deste first deste source deste percorredor não for o single-quote pedaço, diga não.
Se o percorredor estiver sobre any possessive (type 1 - single-quote, s, non-glom-byte), diga sim.
Se o percorredor estiver sobre any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any possessive (type 1 - single-quote, s, non-glom-byte):
Se o source deste percorredor does not start with "'s", diga não.
Isole o percorredor.
Adicione 2 para o first deste source deste percorredor.
Se o source deste percorredor estiver em branco, diga sim.
Se o target deste first deste source deste percorredor não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Isole o percorredor.
Se o first deste source deste percorredor for o first deste subtexto original deste percorredor, diga não.
Subtraia 1 from o first deste source deste percorredor.
Se o target deste first deste source deste percorredor não for o little-s pedaço ou o S maiúsculo, diga não.
Adicione 2 para o first deste source deste percorredor.
Se o source deste percorredor estiver em branco, diga sim.
Se o target deste first deste source deste percorredor não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any simile:
\ added for invisible turtle project ***
Isole o percorredor.
Se o token deste percorredor for "LIKE", diga sim.
Se o token deste percorredor não for "AS", diga não.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor é o start of any function:
Se o alarme de alerta deste compilador estiver ativado, diga não.
Se o token deste percorredor for "Ponha", diga sim.
\Se o token deste percorredor não for any atribua, diga não.
Se o token deste percorredor não for "atribua", diga não.
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any article, diga não.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o token deste percorredor for any possessive, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any contraction giving another string (portuguese rules - "no"):
Se o string não for "no", diga não.
Se o other string for "say", diga não.
Se o other string for "diga", diga não.
\Se o other string for "dizer", diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant e another string:
Lance um subtexto sobre o string.
Subtraia o length deste other string from o last deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o target deste last deste subtexto não for any consonant, diga não.
Se o string does not end with o other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel e another string:
Lance um subtexto sobre o string.
Subtraia o length deste other string from o last deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o target deste last deste subtexto não for any vowel, diga não.
Se o string does not end with o other string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any consonant:
Se o string estiver em branco, diga não.
Se o target deste last deste string não for any consonant, diga não.
Diga sim.

Etapas necessárias para que se determine se um string ends with any vowel:
Se o string estiver em branco, diga não.
Se o target deste last deste string não for any vowel, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any plus:
\PAL
Se o string for "mais", diga sim.
\CAL
Se o string for "plus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any atribua:
\PAL
Se o string for "pôr", diga sim.
\# Não precisa porque está como sinônimo: ver "Etapas necessárias para que se posponha um string para another string giving um terceiro string (portuguese contractions e synonyms rules)"
\Se o string for "colocar", diga sim.
\CAL
Se o string for "atribua", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any minus:
\PAL
Se o string for "menos", diga sim.
\CAL
Se o string for "minus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any times:
\PAL
Se o string for "vezes", diga sim.
\CAL
Se o string for "times", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any divided:
\PAL
Se o string for "dividido", diga sim.
\CAL
Se o string for "divided", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any by:
\PAL
Se o string for "via", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se o string for "por", diga sim.
\CAL
Se o string for "by", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any then:
\PAL
\# operador de concatenação de strings tipo: "abc" then "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida".
Se o string for "junto com", diga sim.
Se o string for "junto de", diga sim.
Se o string for "conjuntamente", diga sim.
Se o string for "juntamente com", diga sim.
Se o string for "concomitantemente com", diga sim.
Se o string for "seguido de", diga sim.
Se o string for "acompanhado de", diga sim.
Se o string for "em seguida", diga sim.
Se o string for "&", diga sim.
\CAL
Se o string for "then", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any has:
\PAL
Se o string for "que tem", diga sim.
Se o string for "contendo", diga sim.
Se o string for "tem", diga sim.
Se o string for "que têm", diga sim.
Se o string for "que possui", diga sim.
Se o string for "que possuem", diga sim.
\CAL
Se o string for "has", diga sim.
Se o string for "have", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any is:
\PAL
Se o string for "é", diga sim.
Se o string for "está", diga sim.
Se o string for "são", diga sim.
Se o string for "estão", diga sim.
Se o string for "for", diga sim.
Se o string for "forem", diga sim.
Se o string for "estiverem", diga sim.
Se o string for "estarem", diga sim.
\CAL
Se o string for "is", diga sim.
Se o string for "are", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operador de atribuição:
\PAL
Se o string for "igual", diga sim.
\CAL
Se o string for "equal", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any with:
\PAL
Se o string for "com", diga sim.
\CAL
Se o string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any article:
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se o string for "e", diga sim.
Se o string for "ou", diga sim.
Se o string for "nem", diga sim.
\CAL
Se o string for "and", diga sim.
Se o string for "both", diga sim.
Se o string for "but", diga sim.
Se o string for "either", diga sim.
Se o string for "neither", diga sim.
Se o string for "nor", diga sim.
Se o string for "or", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any alarme literal:
\Se o string for "yes", diga sim.
\Se o string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any to:
\PAL
Se o string for "a", diga sim. \ this é questionable
\CAL
Se o string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any and:
\PAL
Se o string for "e", diga sim.
\CAL
Se o string for "and", diga sim.
Diga não. \repetido?

Etapas necessárias para que se determine se um string é any reverse-possessive function into:
\PAL
Se o string for "em", diga sim.
\CAL
Se o string for "into", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any alarme literal:
\Se o string for "si", diga sim.
\Se o string for "yes", diga sim.
\Se o string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any decider literal:
\PAL
Se o string for "sim", diga sim.
Se o string for "positivo", diga sim.
Se o string for "positivamente", diga sim.
Se o string for "afirmativamente", diga sim.
Se o string for "não", diga sim.
Se o string for "negativo", diga sim.
Se o string for "negativamente", diga sim.
\CAL
Se o string for "yes", diga sim.
\Se o string for "yep", diga sim.
\Se o string for "yea", diga sim.
Se o string for "no", diga sim.
\Se o string for "nay", diga sim.
\Se o string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any positive decider literal:
\PAL
Se o string for "sim", diga sim.
Se o string for "positivo", diga sim.
Se o string for "positivamente", diga sim.
Se o string for "afirmativamente", diga sim.
\CAL
Se o string for "yes", diga sim.
\Se o string for "yep", diga sim.
\Se o string for "yea", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any negative decider literal:
\PAL
Se o string for "não", diga sim.
Se o string for "negativo", diga sim.
Se o string for "negativamente", diga sim.
\CAL
Se o string for "no", diga sim.
\Se o string for "nay", diga sim.
\Se o string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any hex literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string for o cifrão, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo definido:
\PAL
Se o string for "o", diga sim.
Se o string for "a", diga sim.
Se o string for "os", diga sim.
Se o string for "as", diga sim.
Se o string for any pronome demonstrativo adjacente, diga sim.
\CAL
Se o string for "the", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo:
\CEL
Se o string for any pronome demonstrativo adjacente, diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo adjacente:
\CEL
Se o string for "este", diga sim.
Se o string for "esta", diga sim.
Se o string for "estes", diga sim.
Se o string for "estas", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo abrangente:
\CEL
Se o string for "esse", diga sim.
Se o string for "essa", diga sim.
Se o string for "aquele", diga sim.
Se o string for "aquela", diga sim.
Se o string for "esses", diga sim.
Se o string for "essas", diga sim.
Se o string for "aqueles", diga sim.
Se o string for "aquelas", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any artigo definido:
Se o percorredor estiver sobre any preposição conectiva, diga não.
Se o token deste percorredor não for any artigo definido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre any artigo indefinido:
Se o percorredor estiver sobre any preposição conectiva, diga não.
Se o token deste percorredor não for any artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre any preposição conectiva:
Se o token deste percorredor não for "a", diga não.
Isole o percorredor. Mova o percorredor (compilador rules).
Se o token deste percorredor for any article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo indefinido: \ esse aqui parece que não serve pra muita coisa
\PAL
Se o string for any artigo indefinido português, diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
\CAL
Se o string for any artigo indefinido inglês, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo indefinido inglês:
\CAL
Se o string for "an", diga sim.
Se o string for "another", diga sim.
Se o string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo indefinido português: \ é aqui que tem que pelo possessivo. descobri.
\PAL
Se o string for "um", diga sim.
Se o string for "uma", diga sim.
Se o string for "outro", diga sim.
Se o string for "outra", diga sim.
Se o string for "algum", diga sim.
Se o string for "alguma", diga sim.
Se o string for "alguns", diga sim.
Se o string for "algumas", diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any literal:
Se o string for any endereço de memória literal, diga sim.
Se o string for any numeric literal, diga sim.
Se o string for any string literal, diga sim.
\Se o string for any alarme literal, diga sim. ***
Se o string for any hex literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any mark:
Se o length deste string não for 1, diga não.
Se o target deste first deste string for any mark, diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any monikette string:
\Se o string estiver em branco, diga não.
\Se o string for "the", diga não.
\Se o string é any artigo indefinido, diga não.
\Se o string é any possessive, diga não.
\Se o string é any literal, diga não.
\Se o string é any mark, diga não.
\Se o string é any symbol, diga não.
\Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre any monikette string:
Se o token deste percorredor estiver em branco, diga não.
Se o percorredor estiver sobre any artigo definido, diga não.
Se o percorredor estiver sobre any artigo indefinido, diga não.
Se o token deste percorredor for any possessive, diga não.
Se o token deste percorredor for any literal, diga não.
Se o token deste percorredor for any mark, diga não.
Se o token deste percorredor for any symbol, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any called:
\PAL
Se o string for "chamado", diga sim.
Se o string for "chamada", diga sim.
\CAL
Se o string for "called", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name ender:
\ compare with name starter
Se o string for any mark, diga sim.
Se o string for any symbol, diga sim.
Se o string for any article, diga sim.
Se o string for any conjunction, diga sim.
Se o string for any possessive, diga sim.
Se o string for any verb, diga sim.
Se o string for any operator, diga sim.
Se o string for any preposition, diga sim.
Se o string for any qualifier, diga sim.
Se o string for any literal, diga sim.
Se o string for "called", diga sim.
Se o string for "equal", diga sim.
Se o string estiver em branco, diga sim.
Diga não.
Etapas necessárias para que se determine se um string é any reference:
\PAL
Se o string for "(referência)", diga sim.
\CAL
Se o string for "(reference)", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any name ender:
\ compare with name starter
Se o token deste percorredor for any mark, diga sim.
Se o token deste percorredor for any symbol, diga sim.
Se o token deste percorredor for any article, diga sim.
Se o token deste percorredor for any conjunction, diga sim.
Se o token deste percorredor for any possessive, diga sim.
Se o percorredor estiver sobre any reverse-possessive, diga sim.
Se o token deste percorredor for any verb, diga sim.
Se o token deste percorredor for any operator, diga sim.
Se o percorredor estiver sobre any preposition, diga sim.
Se o token deste percorredor for any qualifier, diga sim.
Se o token deste percorredor for any literal, diga sim.
Se o token deste percorredor for any called, diga sim.
Se o token deste percorredor for any operador de atribuição, diga sim.
Se o token deste percorredor estiver em branco, diga sim.
\ Portuguese trouble makers
Se o token deste percorredor for any negative palavra, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any name starter:
\ compare with name ender
Se o string for any mark, diga não.
Se o string for any symbol, diga não.
Se o string for any article, diga não.
Se o string for any conjunction, diga sim.
Se o string for any possessive, diga não.
Se o string for any verb, diga sim.
Se o string for any operator, diga sim.
Se o string for any preposition, diga sim.
Se o string for any qualifier, diga não.
Se o string for any literal, diga não.
Se o string for "called", diga sim.
Se o string for "equal", diga sim.
Se o string estiver em branco, diga não.
Diga sim.
Etapas necessárias para que se determine se um percorredor está sobre any name starter:
\ compare with name ender
Se o token deste percorredor for any mark, diga não.
Se o token deste percorredor for any symbol, diga não.
Se o token deste percorredor for any article, diga não.
Se o token deste percorredor for any conjunction, diga sim.
Se o token deste percorredor for any possessive, diga não.
Se o token deste percorredor for any verb, diga sim.
Se o token deste percorredor for any operator, diga sim.
Se o percorredor estiver sobre any preposition, diga sim.
Se o token deste percorredor for any qualifier, diga não.
Se o token deste percorredor for any literal, diga não.
Se o token deste percorredor for any called, diga sim.
Se o token deste percorredor for any operador de atribuição, diga sim.
Se o token deste percorredor estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any negative palavra:
\SAL
Se o string for "não", diga sim.
\Se o string for "nada", diga sim.
\Se o string for "ainda", diga sim.
\CAL
\Se o string for "no", diga sim.
Se o string for "not", diga sim.
Se o string for "cannot", diga sim.
Se o string for "nothing", diga sim.
Se o string ends with "n't", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operator:
\PAL
Se o string for "mais", diga sim.
Se o string for "menos", diga sim.
Se o string for "vezes", diga sim.
Se o string for "dividido", diga sim.
Se o string for "depois", diga sim.
Se o string for "então", diga sim.
\CAL
Se o string for "plus", diga sim.
Se o string for "minus", diga sim.
Se o string for "times", diga sim.
Se o string for "divided", diga sim.
Se o string for "then", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any artigo indefinido inglês:
\Se o string for "a", diga sim.
\Se o string for "an", diga sim.
\Se o string for "another", diga sim.
\Se o string for "some", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any pause:
\PAL
Se o string for "e", diga sim.
Se o string for "ou", diga sim.
\CAL
Se o string for "and", diga sim.
Se o string for "or", diga sim.
\default
Se o string for ",", diga sim.
Se o string for ";", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any endereço de memória literal:
\PAL
Se o string for "nulo", diga sim.
Se o string for "nula", diga sim.
Se o string for "inexistente", diga sim.
\CAL
Se o string for "nil", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any possessive:
Se o string for "'s", diga sim.
Se o string for "'", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any preposition:
Atribua o token deste percorredor into um subtexto.
\PAL
Se o percorredor estiver sobre any preposição conectiva, diga sim. \ "a" followed por um article for "to" em portuguese
Se o subtexto for "abaixo", diga sim. \ down
Se o subtexto for "acima", diga sim. \ up
Se o subtexto for "ante", diga sim. \ antes de
Se o subtexto for "antes", diga sim. \ antes de
Se o subtexto for "perante", diga sim. \ antes de
Se o subtexto for "debaixo", diga sim. \ below
Se o subtexto for "sob", diga sim. \ below
Se o subtexto for "acerca", diga sim. \ near
Se o subtexto for "próximo", diga sim. \ near
Se o subtexto for "perto", diga sim. \ near
Se o subtexto for "com", diga sim. \ with
Se o subtexto for "como", diga sim. \ as
Se o subtexto for "contra", diga sim. \ against
\ Se o subtexto for "de", diga sim. \ reverse-possessive indicator 
Se o subtexto for "dada", diga sim. \ given
Se o subtexto for "dado", diga sim. \ given
Se o subtexto for "dando", diga sim. \ given
Se o subtexto for "gerando", diga sim. \ giving
Se o subtexto for "resultando", diga sim. \ giving
Se o subtexto for "retornando", diga sim. \ giving
Se o subtexto for "direita", diga sim. \ right
Se o subtexto for "desde", diga sim. \ since
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "durante", diga sim. \ during
Se o subtexto for "em", diga sim. \ in
Se o subtexto for "entre", diga sim. \ between
Se o subtexto for "até", diga sim. \ until
Se o subtexto for "esquerda", diga sim. \ left
Se o subtexto for "mediante", diga sim. \ through
Se o subtexto for "para", diga sim. \ to
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "segundo", diga sim. \ according
Se o subtexto for "sem", diga sim. \ without
Se o subtexto for "então", diga sim.
Se o subtexto for "sobre", diga sim. \ on
Se o subtexto for "após", diga sim. \ after
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "usando", diga sim. \ using
Se o subtexto for "versus", diga sim. \ versus
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "enquanto", diga sim. \ while
Se o subtexto for "redefinindo", diga sim. \# 'at' na redefinição de campos 
\CAL
Se o subtexto for "about", diga sim.
Se o subtexto for "above", diga sim.
Se o subtexto for "across", diga sim.
Se o subtexto for "after", diga sim.
Se o subtexto for "against", diga sim.
Se o subtexto for "all", diga sim.
Se o subtexto for "alone", diga sim.
Se o subtexto for "along", diga sim.
Se o subtexto for "among", diga sim.
Se o subtexto for "any", diga sim.
Se o subtexto for "anywhere", diga sim.
Se o subtexto for "around", diga sim.
\Se o subtexto for "as", diga sim.
Se o subtexto for "at", diga sim.
Se o subtexto for "away", diga sim.
Se o subtexto for "back", diga sim.
Se o subtexto for "backward", diga sim.
Se o subtexto for "backwards", diga sim.
Se o subtexto for "antes de", diga sim.
Se o subtexto for "beginning", diga sim.
Se o subtexto for "behind", diga sim.
Se o subtexto for "below", diga sim.
Se o subtexto for "beneath", diga sim.
Se o subtexto for "beside", diga sim.
Se o subtexto for "between", diga sim.
Se o subtexto for "beyond", diga sim.
Se o subtexto for "bigger", diga sim.
Se o subtexto for "by", diga sim.
Se o subtexto for "close", diga sim.
Se o subtexto for "deep", diga sim.
Se o subtexto for "diagonally", diga sim.
Se o subtexto for "down", diga sim.
Se o subtexto for "downward", diga sim.
Se o subtexto for "ending", diga sim.
Se o subtexto for "everywhere", diga sim.
Se o subtexto for "except", diga sim.
Se o subtexto for "finishing", diga sim.
Se o subtexto for "facing", diga sim.
\Se o subtexto for "for", diga sim.
Se o subtexto for "por", diga sim.
Se o subtexto for "forward", diga sim.
Se o subtexto for "from", diga sim.
Se o subtexto for "given", diga sim.
Se o subtexto for "giving", diga sim.
Se o subtexto for "high", diga sim.
Se o subtexto for "in", diga sim.
Se o subtexto for "inside", diga sim.
Se o subtexto for "into", diga sim.
Se o subtexto for "en", diga sim.
Se o subtexto for "larger", diga sim.
Se o subtexto for "leaning", diga sim.
Se o subtexto for "left", diga sim.
Se o subtexto for "leftward", diga sim.
Se o subtexto for "leftways", diga sim.
Se o subtexto for "like", diga sim.
Se o subtexto for "limiting", diga sim.
Se o subtexto for "long", diga sim.
Se o subtexto for "near", diga sim.
Se o subtexto for "of", diga sim.
Se o subtexto for "off", diga sim.
Se o subtexto for "on", diga sim.
Se o subtexto for "only", diga sim.
Se o subtexto for "onto", diga sim.
Se o subtexto for "out", diga sim.
Se o subtexto for "outside", diga sim.
Se o subtexto for "over", diga sim.
Se o subtexto for "past", diga sim.
Se o subtexto for "pointing", diga sim.
Se o subtexto for "returning", diga sim.
Se o subtexto for "right", diga sim.
Se o subtexto for "rightward", diga sim.
Se o subtexto for "rightways", diga sim.
Se o subtexto for "shorter", diga sim.
Se o subtexto for "sideway", diga sim.
Se o subtexto for "sideways", diga sim.
Se o subtexto for "similar", diga sim.
Se o subtexto for "smaller", diga sim.
Se o subtexto for "somewhere", diga sim.
Se o subtexto for "slantwise", diga sim.
Se o subtexto for "slantway", diga sim.
Se o subtexto for "slantways", diga sim.
Se o subtexto for "starting", diga sim.
Se o subtexto for "tall", diga sim.
Se o subtexto for "taller", diga sim.
Se o subtexto for "thru", diga sim.
Se o subtexto for "through", diga sim.
Se o subtexto for "throughout", diga sim.
Se o subtexto for "to", diga sim.
Se o subtexto for "toward", diga sim.
Se o subtexto for "towards", diga sim.
Se o subtexto for "under", diga sim.
Se o subtexto for "underneath", diga sim.
Se o subtexto for "until", diga sim.
Se o subtexto for "unto", diga sim.
Se o subtexto for "up", diga sim.
Se o subtexto for "upward", diga sim.
Se o subtexto for "upon", diga sim.
Se o subtexto for "using", diga sim.
Se o subtexto for "via", diga sim.
Se o subtexto for "while", diga sim.
Se o subtexto for "wide", diga sim.
Se o subtexto for "with", diga sim.
Se o subtexto for "within", diga sim.
Se o subtexto for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any preposition:
Se o string for "about", diga sim.
Se o string for "above", diga sim.
Se o string for "across", diga sim.
Se o string for "after", diga sim.
Se o string for "against", diga sim.
Se o string for "all", diga sim.
Se o string for "alone", diga sim.
Se o string for "along", diga sim.
Se o string for "among", diga sim.
Se o string for "any", diga sim.
Se o string for "anywhere", diga sim.
Se o string for "around", diga sim.
\Se o string for "as", diga sim.
Se o string for "at", diga sim.
Se o string for "away", diga sim.
Se o string for "back", diga sim.
Se o string for "backward", diga sim.
Se o string for "backwards", diga sim.
Se o string for "antes de", diga sim.
Se o string for "beginning", diga sim.
Se o string for "behind", diga sim.
Se o string for "below", diga sim.
Se o string for "beneath", diga sim.
Se o string for "beside", diga sim.
Se o string for "between", diga sim.
Se o string for "beyond", diga sim.
Se o string for "bigger", diga sim.
Se o string for "by", diga sim.
Se o string for "close", diga sim.
Se o string for "deep", diga sim.
Se o string for "diagonally", diga sim.
Se o string for "down", diga sim.
Se o string for "downward", diga sim.
Se o string for "ending", diga sim.
Se o string for "everywhere", diga sim.
Se o string for "except", diga sim.
Se o string for "finishing", diga sim.
Se o string for "facing", diga sim.
\Se o string for "for", diga sim.
Se o string for "por", diga sim.
Se o string for "forward", diga sim.
Se o string for "from", diga sim.
Se o string for "given", diga sim.
Se o string for "giving", diga sim.
Se o string for "high", diga sim.
Se o string for "in", diga sim.
Se o string for "inside", diga sim.
Se o string for "into", diga sim.
Se o string for "larger", diga sim.
Se o string for "leaning", diga sim.
Se o string for "left", diga sim.
Se o string for "leftward", diga sim.
Se o string for "leftways", diga sim.
Se o string for "like", diga sim.
Se o string for "limiting", diga sim.
Se o string for "long", diga sim.
Se o string for "near", diga sim.
Se o string for "of", diga sim.
Se o string for "off", diga sim.
Se o string for "on", diga sim.
Se o string for "only", diga sim.
Se o string for "onto", diga sim.
Se o string for "out", diga sim.
Se o string for "outside", diga sim.
Se o string for "over", diga sim.
Se o string for "past", diga sim.
Se o string for "pointing", diga sim.
Se o string for "returning", diga sim.
Se o string for "right", diga sim.
Se o string for "rightward", diga sim.
Se o string for "rightways", diga sim.
Se o string for "shorter", diga sim.
Se o string for "sideway", diga sim.
Se o string for "sideways", diga sim.
Se o string for "similar", diga sim.
Se o string for "smaller", diga sim.
Se o string for "somewhere", diga sim.
Se o string for "slantwise", diga sim.
Se o string for "slantway", diga sim.
Se o string for "slantways", diga sim.
Se o string for "starting", diga sim.
Se o string for "tall", diga sim.
Se o string for "taller", diga sim.
Se o string for "thru", diga sim.
Se o string for "through", diga sim.
Se o string for "throughout", diga sim.
Se o string for "to", diga sim.
Se o string for "toward", diga sim.
Se o string for "towards", diga sim.
Se o string for "under", diga sim.
Se o string for "underneath", diga sim.
Se o string for "until", diga sim.
Se o string for "unto", diga sim.
Se o string for "up", diga sim.
Se o string for "upward", diga sim.
Se o string for "upon", diga sim.
Se o string for "using", diga sim.
Se o string for "via", diga sim.
Se o string for "while", diga sim.
Se o string for "wide", diga sim.
Se o string for "with", diga sim.
Se o string for "within", diga sim.
Se o string for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any qualifier:
Se o string estiver em branco, diga não.
Se o target deste first deste string for o left-paren pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any reverse-possessive:
\Se o string for "uv", diga sim.
Se o string for "de", diga sim.
\Se o string for "pertencente", diga sim.
\Se o string for "que pertence", diga sim.
\Se o string for "del", diga sim. \ short por "de el", expanded em "compile um term usando um percorredor e um campo name (reverse-possessive)"
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any reverse-possessive:
Isole o percorredor.
\CAL
\Se o token deste percorredor for "uv", diga sim.
\PAL
\Se o string for "pertencente a", diga sim.
\Se o string for "pertencente ao", diga sim.
\Se o string for "que pertence a", diga sim.
\Se o string for "que pertence ao", diga sim.
\que consta
\que figura
\incorporada
\inerente
\Se o token deste percorredor não for "integrada de", diga não.
\Se o token deste percorredor não for "interna de", diga não.
\Se o token deste percorredor não for "interno de", diga não.
\Se o token deste percorredor não for "do registro de", diga não.
\Se o token deste percorredor não for "que está dentro de", diga não.
\Se o token deste percorredor não for "de dentro do registro de", diga não.
\Se o token deste percorredor não for "de dentro de", diga não.
\Se o token deste percorredor não for "que faz parte de", diga não.
Se o token deste percorredor não for "de", diga não.
Mova o percorredor (compilador rules).
Se o token deste percorredor for any pronome demonstrativo, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any string literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string for as aspas duplas, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any symbol:
Se o length deste string não for 1, diga não.
Se o target deste first deste string for any symbol, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any verb:
\PAL
Se o string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
Se o string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" para non-tempora state
Se o string for "ser", diga sim. \ "be"
Se o string for "for", diga sim. \ "be"
Se o string for "forem", diga sim. \ "be"
Se o string for "estiver", diga sim. \ "be"
Se o string for "estiverem", diga sim. \ "be"
Se o string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, perm.
Se o string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, temp.
Se o string for "são", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, perm.
Se o string for "estão", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, temp.
Se o string for "foi", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, perm.
Se o string for "estava", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, temp.
Se o string for "foram", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, perm.
Se o string for "estavam", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, temp.
Se o string for "será", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, perm.
Se o string for "estará", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, temp.
Se o string for "serão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, perm.
Se o string for "estarão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, temp.
Se o string for "supera", diga sim. \ beats, exceeds
Se o string for "superam", diga sim. \ beats, exceeds
Se o string for "excede", diga sim. \ beats, exceeds
Se o string for "excedem", diga sim. \ beats, exceeds
Se o string for "pode", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se o string for "puder", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se o string for "puderem", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se o string for "podem", diga sim. \ they "can" cannot \ can't: not used em CAL (3pp) added just em case 
Se o string for "poderia", diga sim. \ it "could" could not \ couldn't: not used em CAL (3ps) added just em case
Se o string for "poderia", diga sim. \ they "could" could not \ couldn't: not used em CAL (3pp) added just em case
Se o string for "podemos", diga sim. \ we "could" could not \ couldn't: only once em Noodle (1pp) "Etapas necessárias para que se determine se we could encontre um endereço de memória:"
Se o string for "tem", diga sim. \ it "has" used em type definitions; (3ps) present
Se o string for "têm", diga sim. \ they "have" used em type definitions; (3pp) present
Se o string for "ter", diga sim. \ used em type definitions
Se o string for "possui", diga sim. \ it "has" used em type definitions; (3ps) present
Se o string for "possuem", diga sim. \ they "have" used em type definitions; (3pp) present
Se o string for "possuir", diga sim. \ used em type definitions
\\ trouble makers
Se o string for "inicia", diga sim. \ "begins" does not begin \ doesn't begin
Se o string for "começa", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se o string for "começar", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se o string for "termina", diga sim. \ "ends" does not end \ doesn't end
Se o string for "terminar", diga sim. \ "ends" does not end \ doesn't end
Se o string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
Se o string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
Se o string for "parece", diga sim. \ "looks" does not look \ doesn't look
Se o string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
Se o string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
Se o string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
\CAL
Se o string for "are", diga sim. \ são not \ aren't
Se o string for "be", diga sim. \
Se o string for "can", diga sim. \ cannot \ can't
Se o string for "cannot", diga sim.
\Se o string for "could", diga sim. \ could not \ couldn't
\Se o string for "do", diga sim. \ does not \ don't
Se o string for "does", diga sim. \ does not \ doesn't
Se o string for "is", diga sim. \ não for \ isn't
Se o string for "may", diga sim. \ may not \ mayn't
Se o string for "should", diga sim. \ não deveria \ shouldn't
Se o string for "was", diga sim. \ was not \ wasn't
Se o string for "will", diga sim. \ will not \ won't
Se o string for "would", diga sim. \ would not \ wouldn't
Se o string for "has", diga sim. \ used em type definitions
Se o string for "have", diga sim. \ used em type definitions
Se o string ends with "n't", diga sim.
\\ trouble makers
Se o string for "begins", diga sim. \ does not begin \ doesn't begin
Se o string for "ends", diga sim. \ does not end \ doesn't end
Se o string for "looks", diga sim. \ does not look \ doesn't look
Se o string for "needs", diga sim. \ does not need \ doesn't need
Se o string for "starts", diga sim. \ does not start \ doesn't start
Diga não.

Etapas necessárias para que se determine se um string é o start of any definition:
\PAL
Se o string for "Passos", diga sim.
Se o string for "Etapas", diga sim.
\CAL
Se o string for "to", diga sim.
\default
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conditional:
\PAL
Se o string for "se", diga sim.
Se o string for "quando", diga sim.
\CAL
Se o string for "if", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any privatize:
\PAL
Se o string for "privatize", diga sim.
\Se o string for "reserve", diga sim.
Se o string for "separe", diga sim.
Se o string for "isole", diga sim.
Se o string for "Isole", diga sim.
Se o string for "conserve", diga sim.
Se o string for "derive", diga sim.
\CAL
\Se o string for "privatize", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any loop:
\PAL
Se o string for "percorra", diga sim.
\Se o string for "ciclo", diga sim.
\Se o string for "laço", diga sim. \# muito usado em pseudo-codigo
\CAL
Se o string for "loop", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any break:
\PAL
Se o string for "pare", diga sim.
Se o string for "pare de percorrer", diga sim.
Se o string for "pare de repetir", diga sim.
Se o string for "cancele a operação", diga sim.
Se o string for "interrompa a operação", diga sim.
\CAL
Se o string for "break", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any exit:
\PAL
Se o string for "acabe", diga sim.
Se o string for "acabou", diga sim.
Se o string for "acabou-se", diga sim.
\Se o string for "advirta", diga sim.
\Se o string for "anuncie", diga sim.
\Se o string for "avise", diga sim.
Se o string for "cancele", diga sim.
Se o string for "desconsidere.", diga sim.
Se o string for "deixa quieto", diga sim.
Se o string for "deixe quieto", diga sim.
Se o string for "e mais nada", diga sim.
Se o string for "e pronto", diga sim.
Se o string for "e só", diga sim.
Se o string for "fim", diga sim.
Se o string for "fimse", diga sim.
Se o string for "ignore", diga sim.
\Se o string for "informe", diga sim.
Se o string for "prossiga", diga sim.
Se o string for "pronto", diga sim.
Se o string for "retorne", diga sim.
Se o string for "saia", diga sim.
Se o string for "siga adiante", diga sim.
Se o string for "terminamos", diga sim.
Se o string for "termine", diga sim.
\CAL
Se o string for "exit", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any repeat:
\PAL
\Se o string for "repetir", diga sim. \# muito usado em pseudo-codigo
Se o string for "repita", diga sim. \# muito usado em pseudo-codigo
\CAL
Se o string for "repeat", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any say:
\PAL
Se o string for "diga", diga sim. \# modo imperativo
Se o string for "responda", diga sim. \# modo imperativo
Se o string for "informe", diga sim. \# modo imperativo
\Se o string for "decida", diga sim. \ para usar como "decida afirmativamente e decida negativamente"
\Se o string for "dizer", diga sim. \# modo infinitivo opcional.
\CAL
Se o string for "say", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any decide:
\PAL
\Se o string for "decidir", diga sim.
Se o string for "decida", diga sim. \estou pensando em retirar devido o comentário da rotina anterior
\Se o string for "escolha", diga sim.
Se o string for "determine", diga sim.
Se o string for "conclua", diga sim.
Se o string for "esclareça", diga sim.
Se o string for "descubra", diga sim.
Se o string for "analise", diga sim.
\CAL
Se o string for "decide", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any call:
\PAL
Se o string for "chame", diga sim.
\Se o string for "repasse", diga sim.
\Se o string for "informe", diga sim.
\CAL
Se o string for "call", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any point:
\PAL
Se o string for "aponte", diga sim.
\CAL
Se o string for "point", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any employ:
\PAL
Se o string for "empregue", diga sim.
\CAL
Se o string for "employ", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any noise palavra:
\Nova rotina 
Se o string for "already", diga sim.
Se o string for "still", diga sim.
Se o string for "yet", diga sim.
Se o string for "já", diga sim.
Se o string for "ainda", diga sim.
\Se o string for "que", diga sim.
\Se o string for "se", diga sim.
[more noise palavras here]
Diga não.

Etapas necessárias para que se determine se um string é o start of any expression:
Se o string for any sign, diga sim.
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Se o string for any literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any global:
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any new local:
Se o string for any artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any optional info:
\PAL
Se o string for "com", diga sim.
\CAL
Se o string for "to", diga sim.
Se o string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any routine:
\PAL
Se o string for "Passos", diga sim.
Se o string for "Etapas", diga sim.
Se o string for "Etapas necessárias para que se", diga sim. \verificar depois
Se o string for "Passos necessários para que se", diga sim.
\CAL
Se o string for "to", diga sim. \verificar se pode ser excluído
Diga não.

Etapas necessárias para que se determine se um string é o start of any statement:
Se o string for o start of any definition, diga não.
Se o string for any literal, diga não.
Se o string for any mark, diga não.
Se o string estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é o start of any type:
Se o string for any artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any variable:
Se o string for any artigo definido, diga sim.
\Se o string for "do", diga sim. \ this é iffy, here por reverse-possessives
Diga não.

Etapas necessárias para que se determine se um string has any stressed vowel:
Isole o string.
Percorra.
Se o string estiver em branco, diga não.
Se o target deste last deste string for any stressed vowel, diga sim.
Subtraia 1 from o last deste string.
Repita.

Etapas necessárias para que se determine se um term está vazia;
Etapas necessárias para que se determine se um term estão vazias;
Etapas necessárias para que se determine se um term estão vazios;
Etapas necessárias para que se determine se um term está vazio:
Se a variable deste term não for inexistente, diga não.
Se a phrase deste term não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um type pode ser reduzido para um string using o base name:
Se o type for inexistente, diga não.
Se o name deste type for o string, diga sim.
Se o cooking alarme deste type estiver ativo, diga não.
Ligue o cooking alarme deste type.
Encontre um base type usando o base name deste type e o catálogo de tipos.
Se o base type for inexistente, desative o cooking alarme deste type; diga não.
Se o base type puder ser reduzido para o string using o base name, desative o cooking alarme deste type; diga sim.
Desative o cooking alarme deste type.
Diga não.

Etapas necessárias para que se determine se um type pode ser reduzido para um type name:
Se o type for inexistente, diga não.
Isole o type.
Percorra.
Se o type for inexistente, diga não.
Se o name deste type for o type name, diga sim.
Se o base type deste type for o type, diga não.
Atribua o base type deste type ao type.
Repita.

Etapas necessárias para que se determine se um type é any built-in type:
Se o type for inexistente, diga não.
Se o type for o base type deste type, diga sim.
Diga não.

Etapas necessárias para que se determine se um type é value pushable:
Se o type for inexistente, diga não.
Se o type for inexistente, diga não. \\ repetido?
Se o length deste type for 4, diga sim.
Se o length deste type for 2, diga sim.
Se o length deste type for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser finalizado:
Se o type for inexistente, diga não.
Se o type puder ser reduzido para "subtexto", diga não.
Se o type puder ser reduzido para "string", diga sim.
Se os campos deste type deveriam ser finalizados, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser ignorado:
Se o type for inexistente, diga não.
\PAL
\Se o name deste type for "elemento", diga não.
\Se o name deste type for "elementos", diga não.
\CAL
Se o name deste type for "coisa", diga não.
Se o name deste type for "coisas", diga não.
Se o type puder ser reduzido para "coisas", diga sim.
Se o type não puder ser reduzido para "endereço de memória", diga não.
Se o target type deste type for inexistente, diga não.
Se o target type deste type não puder ser reduzido para "endereço de memória", diga sim.
Se o target type deste type não deveria ser ignorado, diga não.
Diga sim.

Etapas necessárias para que se determine se uma variable é duplicated em alguns variables:
Obtenha another variable from o variables.
Se o other variable for inexistente, diga não.
Se o name desta other variable estiver em branco, repita.
Se o other variable for o variable, repita.
Se o name desta other variable for o name desta variable, diga sim.
Repita.

O dereference tag é uma tag igual a 5.

Um DOS header é um conjunto with
Um wyrd called signature, \\ O value of this word is 5A4DH (with the 4DH coming first).
\\ Signature Word. This contains a "magic number" which provides a simple check that the file really is a DOS .EXE file;
\\ it follows that the filename extension does not em fact have para be .EXE, as long as programs check this word.
\\O value of this word is 5A4DH (with the 4DH coming first).
\\These two bytes represent the character string "MZ", the initials of Mark Zibowski, a Microsoft employee at the time the file format was designed.
Um wyrd called numberofbytesonlastpage, \\ O last page may contain between 1 and 512 bytes
\\Last Page Size.
\\O file occupies a number of 512 byte pages.
\\O last page may contain between 1 and 512 bytes.
\\This word indicates the number of bytes actually used em the last page, 
\\with the special case of a full page being represented by a value of zero (since the last page is never empty).
Um wyrd called numberofpages,
\\ File Pages.
\\This word contains a count of the number of pages required para hold the file.
\\For example, if the file contains 1024 bytes, this word would contain 0002H; 
\\if the file contains 1025 bytes, this word would contain 0003H.
\\O Last Page Size campo is used para determine the number of valid bytes em the final page.
\\Thus, if the file contains 1024 bytes, the Last Page Size campo contains 0000H, because no bytes overflow à final partly used page.
\\If the file contains 1025 bytes, then the Last Page Size campo contains 0001H, because the final page contains only one valid byte (the 1025th byte).
Um wyrd called relocuss,
\\ Relocation Items.
\\ This word gives the number of entries that exist em the relocation pointer table.
\\It is quite em order for this value para be zero, em which case there are no relocation entries.
Um wyrd called sizeofheaderinparágrafos,
\\ Header Paragraphs.
\\This word gives the size of the .EXE header em parágrafos.
\\It indicates the offset of the compiled/assembled and linked image do program (the load module) within the .EXE file.
\\O size of the load module can be deduced by subtracting this value (converted para bytes) from the overall file size 
\\derived from combining the File Pages and Last Page Size values.
\\O header always spans an even number of parágrafos.
Um wyrd called minimumextraparágrafos,
\\ MINALLOC.
\\This word indicates the minimum number of parágrafos the program requires para begin execution.
\\This is em addition para the memory required para hold the load module.
\\This value normally represents the total size of any uninitialised data and/or stack segments that are linked at the end of a program.
\\This space is not directly included em the load module, since there are no particular initialising values and it would simply waste disk space.
Um wyrd called maximumextraparágrafos,
\\ MAXALLOC.
\\This word indicates the maximum number of parágrafos that the program would like allocated para it before it begins execution.
\\This indicates additional memory over and above that required by the load module and the value specified by MINALLOC.
\\If the request cannot be satisfied, the program is allocated as much memory as is available.
Um wyrd called initialrelativess,
\\ Initial SS value.
\\This word contains the parágrafo address of the stack segment relative para the start of the load module.
\\At load time, this value is relocated by adding the address of the start segment of the program para it, 
\\and the resulting value is placed em the SS register before the program is started.
\\In DOS, the start segment of the program is the first segment boundary em memory after the PSP.
Um wyrd called initialsp,
\\ Initial SP value.
\\This word contains the absolute value that must be loaded into the SP register before the program is given control.
\\Since the actual stack segment is determined by the loader, and this is merely a value within that segment, it does not need para be relocated.
Um wyrd called initialchecksum,
\\ Complemented Checksum.
\\This word contains a checksum of the contents of the .EXE file.
\\ Its value is rarely checked, but its purpose is para ensure the integrity of the data within the file.
\\ Full details of how it is calculated appear em the section sobre checksum calculation.
Um wyrd called initialip,
\\ Initial IP value.
\\This word contains the absolute value that should be loaded into the IP register em order para transfer control para the program.
\\Since the actual code segment is determined by the loader, and this is merely a value within that segment, it does not need para be relocated.
Um wyrd called initialirelativecs, 
\\ Pre-relocated initial CS value.
\\ This word contains the initial value, relative para the start of the load module, that should be placed em the CS register em order para transfer control para the program.
\\ At load time, this value is relocated by adding the address of the start segment of the program para it, and the resulting value is placed em the CS register
\\ when control is transferred.
Um wyrd called addressofrelocationtableinfile,
\\ Relocation table offset.
\\ This word gives the offset from the start of the file para the relocation pointer table.
\\ This value must be used para locate the relocation pointer table (rather than assuming a fixed location) 
\\because variable-length information pertaining para program overlays can occur before this table, causing its position para vary.
\\A value of 40H em this campo generally indicates a different kind of executable file, not a DOS "MZ" type.
Um wyrd called overlynumber,
\\ Overlay number.
\\ This word is normally set para 0000H, because few programs actually have overlays.
\\It changes only em files containing programs that use overlays; see the note below.
8 pedaços called resveredbytes, \\ Specifies reserved words for the program (known em winnt.h as e_res[4]), usually set para zero by the linker.
\\In this case, just use a single reserved1 set para zero; if not zero create four reserved1 with the correct value.
Um wyrd called oemidentifier, \\ Specifies the identifier for the OEM for e_oeminfo.
Um wyrd called oeminfo, \\ Specifies the OEM information for a specific value of e_oeminfo.
20 pedaços called reservedwords, \\ Specifies reserved words for the program (known em winnt.h as e_res[10]), usually set para zero by the linker.
\\In this case, just use a single reserved1 set para zero; if not zero create ten reserved1 with the correct value.
Um número called addressofpeheaderinfile.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variables:
Crie um index usando 101.
Eliminate duplicate nicknames from o variables usando o index.
Destroy o index.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variables usando um index:
Se o index for inexistente, cancele.
Percorra.
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
Eliminate duplicate nicknames usando o variable e o index.
Repita.

Etapas necessárias para que se eliminate duplicate nicknames usando uma variable e um index:
Se o variable for inexistente, cancele.
Se o index for inexistente, cancele.
Encontre another variable usando o nickname desta variable e o index.
Se o other variable for inexistente, encontre o other variable usando o name desta variable e o index.
Se o other variable for inexistente, catalogue o variable usando o nickname desta variable e o index; exit.
Limpe o nickname desta other variable.
Limpe o nickname desta variable.

O end if tag é uma tag igual a 6.

An entry é uma coisa with
Um name address,
Um thunk address,
Um name,
Um address.

O epilog tag é uma tag igual a 7.

O exit tag é uma tag igual a 8.

Um expression é um term.

Etapas necessárias para que se extend um string with another string:
Se o other string estiver em branco, cancele.
Se o string não estiver em branco, posponha o caractere de espaço para o string.
Posponha o other string para o string.

\An campo é uma variable.
Um campo é uma variable.

Um campo term é um conjunto with
Um dereference alarme,
Um campo (reference),
Um function routine (reference),
Um push alarme.

Etapas necessárias para que se finalize o compilador:
Destroy o catálogo de rotinas úteis.
Destroy o catálogo geral de rotinas.
Destroy o catálogo de variáveis hexadecimais.
Destroy o catálogo de variáveis globais.
Destroy o catálogo de tipos.
Destroy o imports.
Destroy a routines.
Destroy o literals.
Destroy o globals.
Destroy o types.
Destroy o source files.

O finalize tag é uma tag igual a 9.

Etapas necessárias para que se encontre um entry usando um string e alguns entries:
Esvazie o entry.
Percorra.
Obtenha o entry from o entries.
Se o entry for inexistente, cancele.
Se o name desta entry for o string, cancele.
Repita.

Etapas necessárias para que se encontre um campo term usando um phrase e um type e um name:
Limpe o campo term.
Encontre o campo term usando o type e o name.
Se o campo deste campo term não for inexistente, cancele.
Se a phrase não estiver em branco, encontre uma routine usando "atribua" e a phrase e "'s " then o name e "into".
Se a routine não for inexistente, atribua a routine à function deste campo term; exit.
Se o type for inexistente, cancele.
Encontre a routine usando "atribua" e o type e "'s " then o name e "into".
Se a routine não for inexistente, acione o push alarme deste campo term; atribua a routine ao function deste campo term; exit.
\ code below for looking deep within endereço de memórias - a debatable feature
\ Se o target type deste type não for inexistente, encontre a routine usando "atribua" e o target type deste type e "'s " then o name e "into".
\ Se a routine não for inexistente, acione o dereference alarme deste campo term; atribua a routine à function deste campo term; exit.

Etapas necessárias para que se encontre um campo term usando um type e um name:
Se o type for inexistente, cancele.
Encontre um campo usando o name e os campos deste type.
Se o campo não for inexistente, atribua o campo ao campo deste campo term; exit.
Se o target type deste type não for inexistente, encontre o campo usando o name e os campos deste target type deste type.
Se o campo não for inexistente, acione o dereference alarme deste campo term; atribua o campo ao campo deste campo term; exit.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag:
Atribua o other fragment ao fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se o tag deste fragment for o tag, cancele.
Atribua o next deste fragment ao fragment.
Repita.

Etapas necessárias para que se encontre um fragment usando another fragment e uma tag (backwards):
Atribua o other fragment ao fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se o tag deste fragment for o tag, cancele.
Atribua o previous deste fragment ao fragment.
Repita.

Etapas necessárias para que se encontre um import usando um string:
Esvazie o import.
Percorra.
Obtenha o import from o imports.
Se o import for inexistente, cancele.
Se o name deste import for o string, cancele.
Repita.

Etapas necessárias para que se encontre um endereço completo e um número da linha usando um endereço de memória do pedaço :
Limpe o endereço completo.
Atribua 0 ao número da linha.
Encontre um source file usando o endereço de memória do pedaço .
Se o source file for inexistente, cancele.
Atribua o endereço completo deste source file ao endereço completo.
Encontre o número da linha usando o source file e o endereço de memória do pedaço .

Etapas necessárias para que se encontre uma routine usando um moniker e um monikette e um index:
Se o monikette for inexistente, cancele.
Esvazie a routine.
Isole o moniker.
Atribua o type deste monikette ao type atual deste monikette.
Lance o subtexto atual deste monikette sobre o string deste monikette.
Percorra.
Posponha o monikette para o moniker (while bubbling).
Encontre um refer usando o moniker e o index.
Se o refer não for inexistente, atribua o endereço de memória deste refer à routine.
Se o refer não for inexistente, encontre a routine usando o moniker e o next deste monikette e o index.
Se a routine não for inexistente, pare.
Bubble o monikette.
Se o monikette estiver bubbled out, pare.
Atribua o original moniker ao moniker.
Repita.

Etapas necessárias para que se encontre uma routine usando alguns monikettes:
Esvazie a routine.
Encontre a routine usando um moniker e o first destes monikettes e o catálogo geral de rotinas.

Etapas necessárias para que se encontre uma routine usando um string e another string e um terceiro string e um fourth string:
Adicione um monikette para alguns monikettes usando o string.
Adicione another monikette para os monikettes usando o other string.
Adicione um terceiro monikette para os monikettes usando o terceiro string.
Adicione um fourth monikette para os monikettes usando o fourth string.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type:
Adicione um monikette para alguns monikettes usando o string.
Adicione another monikette para os monikettes usando o type.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e another type:
Adicione um monikette para alguns monikettes usando o string.
Adicione another monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando o other string.
Adicione um fourth monikette para os monikettes usando o other type.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um terceiro string:
Adicione um monikette para alguns monikettes usando o string.
Adicione another monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando o other string.
Adicione um fourth monikette para os monikettes usando o terceiro string.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e another string e um terceiro string e um fourth string e um fifth string:
Adicione um monikette para alguns monikettes usando o string.
Adicione another monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando o other string.
Adicione um fourth monikette para os monikettes usando o terceiro string.
Adicione um fifth monikette para os monikettes usando o fourth string.
Adicione um sixth monikette para os monikettes usando o fifth string.
Encontre a routine usando os monikettes.
Destroy os monikettes.

Etapas necessárias para que se encontre um número da linha usando um source file e um endereço de memória do pedaço :
Se o endereço de memória do pedaço for inexistente, atribua 0 ao número da linha; exit.
Lance um subtexto sobre o trecho deste source file.
Atribua 1 ao número da linha.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o first deste subtexto for o endereço de memória do pedaço , cancele.
Se o target deste first deste subtexto for o return pedaço, adicione 1 para o número da linha.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se encontre um source file usando um endereço de memória do pedaço :
Se o endereço de memória do pedaço for inexistente, esvazie o source file; exit.
Percorra.
Obtenha o source file from o source files.
Se o source file for inexistente, cancele.
Se o endereço de memória do pedaço for menor do que o first deste trecho deste source file, repita.
Se o endereço de memória do pedaço for maior do que o last deste trecho deste source file, repita.

Etapas necessárias para que se encontre um type e um nickname usando um name:
Esvazie o type.
Limpe o nickname.
Encontre o type e o nickname usando o name (forward).
Se o type não for inexistente, cancele.
Encontre o type e o nickname usando o name (backward).
\Lance um subtexto sobre o name.
\Percorra.
\Se o subtexto estiver em branco, cancele.
\Encontre o type usando o subtexto e o catálogo de tipos.
\Se o type não for inexistente, pare.
\Skip para o next palavra no subtexto.
\Repita.
\Atribua o first deste name into first deste another subtexto. \ pode estar errado
\Atribua o first deste subtexto menos 2 ao last deste other subtexto.
\Se o other subtexto não estiver em branco, atribua o other subtexto ao nickname.
\Se o other subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (backward):
Esvazie o type.
Limpe o nickname.
Lance um subtexto sobre o name.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip para o previous palavra no subtexto.
Repita.
Atribua o last deste name into another subtexto's last .
Atribua o last deste subtexto mais 2 ao first deste other subtexto.
Se o other subtexto não estiver em branco, atribua o other subtexto ao nickname.
Se o other subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre um type e um nickname usando um name (forward):
\ original - no mude
Esvazie o type.
Limpe o nickname.
Lance um subtexto sobre o name.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip para o next palavra no subtexto.
Repita.
Atribua o first deste name into another subtexto's first.
Atribua o first deste subtexto menos 2 ao last deste other subtexto.
Se o other subtexto não estiver em branco, atribua o other subtexto ao nickname.
Se o other subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre uma variable usando um name:
Se a rotina utilizada atualmente for inexistente, esvazie o variable; exit.
Encontre o variable usando o name e os locals desta rotina utilizada atualmente.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e os parameters desta rotina utilizada atualmente.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e o catálogo de variáveis globais.
Se o variable não for inexistente, cancele.
Encontre o variable usando o name e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se encontre uma variable usando um name e algumas variables:
Esvazie o variable.
Percorra.
Obtenha o variable from o variables.
Se o variable for inexistente, cancele.
Se o name desta variable for o name, cancele.
Se o nickname desta variable for o name, cancele.
Repita.


\Etapas necessárias para que se encontre uma variable usando um name:
\Se a rotina utilizada atualmente for inexistente, esvazie o variable; exit.
\Encontre o variable usando o name e os locals desta rotina utilizada atualmente.
\Se o variable não for inexistente, cancele.
\Encontre o variable usando o name e os parameters desta rotina utilizada atualmente.
\Se o variable não for inexistente, cancele.
\Encontre o variable usando o name e o catálogo de variáveis globais.
\Se o variable não for inexistente, cancele.
\ Encontre o variable usando o name e o catálogo de variáveis hexadecimais.

\Etapas necessárias para que se encontre uma variable usando um name e alguns variables:
\esvazie o variable.
\Percorra.
\Obtenha o variable from o variables.
\Se o variable for inexistente, cancele.
\Se o name desta variable for o name, cancele.
\Se o nickname desta variable for o name, cancele.
\Repita.

An fragment é uma coisa with
Um tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
Um variable (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Another variable (reference) [load address],
Um routine (reference) [call internal, routine address],
Um entry (reference) [call external],
Um número [increment],
Um alarme [load eax], \SAL
Um address,
Um texto hexadecimal called code.

Etapas necessárias para que se gere um name usando um string:
Atribua o string ao name.
Adicione 1 para o name contagem deste compilador.
Convert o name contagem deste compilador para another string.
Posponha o other string para o name.

Etapas necessárias para que se obtenha um address usando uma routine:
Se o address desta routine não for 0, atribua o address desta routine ao address; exit.
Atribua -1 ao address desta routine.
Encontre another routine usando o employs moniker desta routine e o catálogo geral de rotinas.
Se o other routine for inexistente, apresente uma mensagem de erro contendo "Eu não consegui encontrar uma tarefa: " then o employs moniker desta routine then "' que você está tentando employ." e o locus desta routine; exit.
Se o address desta other routine for -1, apresente a mensagem de erro contendo "Referência recursiva na cláusula employ." e o locus desta routine; exit. \Bora traduzir
Obtenha o address usando o other routine.
Atribua o address ao address desta routine.

Etapas necessárias para que se obtenha um contagem usando alguns imports (all entries mais markers):
Atribua 0 à contagem.
Percorra.
Obtenha um import from o imports.
Se o import for inexistente, cancele.
Adicione a contagem destas entries deste import para a contagem.
Adicione 1 para a contagem.
Repita.

Um global body é um subtexto.

O catálogo de variáveis globais é um index.

An global é uma variable.

O globals são alguns globals.

O image base é um address igual a 4194304 [$00400000].

O import zona é um zona.

Um import header é um conjunto with
Um address called original first thunk, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-first-thunkoft-milad-kahsari-alhadi/
\ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft#:~:text=The%20original%20first%20thunk%20is,%2C%20user32%20etc)%20are%20known.
\Thunks are the defnitive pieces of codes em an operating system that handle the transitions between 16 and 32-bit code.
\ Thus they ensure backward compatibility between the calls made by the application.
\ O OS is subjected with this facility for backward compatibility, so that the 16 bit applications can run smoothly em 32 bit environment.
\ O original first thunk is needed if the imports are bound but the imported .DLL does not match.
\ On a fresh unpatched version of Windows, all addresses of all functions em the base .DLLs (ntdll, kernel32, user32 etc) are known.
\Take shell32 for example, it links para kernel32!CreateProcess and the true address of CreateProcess can be stored directly em shell32.
\This is called import binding and lets the loader skip the step where it looks up all the addresses of the imported functions.
\This does not work if the imported .DLL has not been loaded at its preferred address nor if the .DLL has changed (security update etc).
\If this happens then the loader has para look up the functions "the normal way" and the original first thunk array has para be used
\ because that is the only place where the RVAs of the function names are stored.
\ If import binding is not used then the original first thunk array is optional and might not be present.
\ ASLR has probably made this optimization irrelevant.
Um número called timestamp, \ Set para zero until bound; then this feld is set para the TimeDateStamp of the exporting FileHeader da DLL
Um address called forwarder chain, \ Forwarder Chain: O 32-bit index of the frst forwarder em the list of imported functions
Um address called name memory address, 
\It holds the RVA [Relative Virtual Address] of the dll para be loaded into memory. It is a dword value.
\It is comprised of : RVA = Image Base + Endian Order 
\Note: As we know OllyDbg gives the result em the Big Endian order where as the x86 architecture holds the address em the Little Endian order, 
\ so the address gets exchanged reversibly em the di tuples
Um address called first thunk memory address.
\ Once the API is linked and gets loaded into memory the frst thunk which is a RVA points para the Import Address Table [IAT]

An import é uma coisa with
Um name address,
Um header address,
Um name,
Um import header,
Some entries.

O imports são alguns imports.

O increment tag é uma tag igual a 10.

Etapas necessárias para que se catalogue um global:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o global for inexistente, cancele.
Se o name deste global estiver no catálogo de variáveis globais, apresente uma mensagem de erro contendo "'" then o name deste global then "' é uma variável global duplicada." e o locus deste global; exit.
Catalogue o global usando o name deste global e o catálogo de variáveis globais.

Etapas necessárias para que se catalogue um literal:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o literal for inexistente, cancele.
Se o name deste literal estiver no catálogo de variáveis hexadecimais, apresente uma mensagem de erro contendo "Erro interno no nome do literal na função index um literal" e o locus deste literal; exit.
Catalogue o literal usando o name deste literal e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se catalogue um partial moniker usando um index (special):
Encontre um refer usando o partial moniker e o index.
Se o refer não for inexistente, cancele.
Catalogue o partial moniker no index.

Etapas necessárias para que se catalogue uma routine por utility use:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o function alarme desta routine estiver ativo, cancele.
Se o contagem destes parameters desta routine for 0, cancele.
Copy os monikettes desta routine into alguns monikettes.
Reduce os monikettes por utility use.
Convert os monikettes para um moniker.
Destroy os monikettes.
Se o moniker estiver no catálogo geral de rotinas, cancele.
Encontre um refer usando o moniker e o catálogo de rotinas úteis.
Se o refer não for inexistente, atribua nil ao endereço de memória deste refer; exit.
Catalogue a routine usando o moniker e o catálogo de rotinas úteis.

Etapas necessárias para que se catalogue uma routine usando um moniker e um index (special):
Encontre um refer usando o moniker e o index.
Se o refer não for inexistente, atribua a routine ao endereço de memória deste refer; exit.
Catalogue a routine usando o moniker e o index.

Etapas necessárias para que se catalogue uma routine usando alguns monikettes e um index:
Se a routine for inexistente, cancele.
Limpe um partial moniker.
Percorra.
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Posponha o monikette para o partial moniker.
Se o monikette for o last destes monikettes, pare.
Catalogue o partial moniker usando o index (special).
Repita.
Catalogue a routine usando o partial moniker como um moniker e o index (special).

Etapas necessárias para que se catalogue alguns routines por utility use:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Catalogue a routine por utility use.
Repita.

Etapas necessárias para que se catalogue um type:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Catalogue o type usando o name deste type.

Etapas necessárias para que se catalogue um type usando um name:
Se o type for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Encontre um existing type usando o name e o catálogo de tipos.
Se o existing type for inexistente, catalogue o type usando o name e o catálogo de tipos; exit.
Atribua o locus deste type into um locus.
Se o locus for inexistente, atribua o locus deste existing type ao locus. \ point o erro para um type no source code, not um generated type
Apresente uma mensagem de erro contendo "Acho que já vi o tipo: " then o name then "' em algum lugar antes; você deve ter duplicado ele." e o locus.

O indexing utilities cronômetro é um cronômetro.

Etapas necessárias para que se initialize o compilador:

Etapas necessárias para que se initialize o compilador usando um endereço da pasta:
Atribua o endereço da pasta ao endereço da pasta deste compilador.
Atribua 0 ao name contagem deste compilador.
Desative o alarme de alerta deste compilador.
Limpe a mensagem de erro deste compilador.
Limpe o abort endereço completo deste compilador.
Atribua 0 ao abort número da linha deste compilador.
Esvazie a rotina utilizada atualmente.
Crie o catálogo de tipos with 13001 [buckets]. \ was 4027
Crie o catálogo de variáveis globais with 13001 [buckets]. \ was 4027
Crie o catálogo de variáveis hexadecimais with 13001 [buckets]. \ was 4027
Crie o catálogo geral de rotinas with 13001 [buckets]. \ was 7919
Crie o catálogo de rotinas úteis with 13001 [buckets]. \ was 4027

Etapas necessárias para que se initialize um DOS header: \ vou alterar depois
Atribua 23117 [$5A4D] ao signature deste DOS header.
Atribua 64 [$0040] ao addressofrelocationtableinfile deste DOS header. \ O ?addressofrelocationtableinfile? is a pointer para the variable-length table of DLLs needed for this program.
Atribua 256 [$00000100] ao addressofpeheaderinfile deste DOS header. \O ?addressofpeheaderinfile? is a pointer para the ?PE Header?, a revised and extended version of the DOS Header introduced with advent of Windows. 
\O other 16 campos of the DOS Header are not used.

Etapas necessárias para que se initialize um PE header:
Initialize o PE header (standard header).
Initialize o PE header (optional header).
Initialize o PE header (version information).
Initialize o PE header (directories).
Initialize o PE header (import section).
Initialize o PE header (data section).
Initialize o PE header (code section).

Etapas necessárias para que se initialize um PE header (code section):
Copy pedaços from "code "'s first para o whereabouts deste name desta code section deste PE header por 6.
Atribua o length desta code zona ao sizeinbytes desta code section deste PE header.
Atribua a base desta code zona ao addressinmemory desta code section deste PE header.
Atribua o length desta code zona ao sizeinfile desta code section deste PE header.
Atribua a base desta code zona ao addressinfile desta code section deste PE header.
Atribua -536870880 [$E0000020] into as characteristics desta code section deste PE header. \ executable, readable, writable, code object

Etapas necessárias para que se initialize um PE header (data section):
Copy pedaços from "data "'s first para o whereabouts deste name desta data section deste PE header por 6.
Atribua o length desta zona de dados ao sizeinbytes desta data section deste PE header.
Atribua a base desta zona de dados ao addressinmemory desta data section deste PE header.
Atribua o length desta zona de dados ao sizeinfile desta data section deste PE header.
Atribua a base desta zona de dados ao addressinfile desta data section deste PE header.
Atribua -1073741760 [$C0000040] into as characteristics desta data section deste PE header. \ initialized, readable, writable

Etapas necessárias para que se initialize um PE header (directories):
Atribua 16 [$00000010] ao numberofdirectories deste PE header.
Atribua a base desta import zona ao imagedirectoryentryimportaddress deste PE header.
Atribua o length desta import zona ao imagedirectoryentryimportsize deste PE header.

Etapas necessárias para que se initialize um PE header (import section):
Copy pedaços from "idata "'s first para o whereabouts deste name desta idata section deste PE header por 6.
Atribua o length desta import zona ao sizeinbytes desta idata section deste PE header.
Atribua a base desta import zona ao addressinmemory desta idata section deste PE header.
Atribua o length desta import zona ao sizeinfile desta idata section deste PE header.
Atribua a base desta import zona ao addressinfile desta idata section deste PE header.
Atribua -1073741760 [$C0000040] into as characteristics desta idata section deste PE header. \ initialized, readable, writable

Etapas necessárias para que se initialize um PE header (optional header):
Atribua 267 [$010B] ao magicnumber deste PE header.
Atribua o length desta code zona ao sizeofcodeinfile deste PE header.
Atribua o length desta zona de dados ao sizeofinitializeddatainfile deste PE header.
Atribua 0 ao sizeofuninitializeddatainfile deste PE header.
Encontre uma routine usando "~initialize before run e run e finalize after run" e o catálogo geral de rotinas.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Erro interno: não achei a tarefa de inicialização"; exit.
Atribua o address desta routine menos o image base ao addressofentrypointinmemory deste PE header.
Atribua a base desta code zona ao addressofcodeinmemory deste PE header.
Atribua a base desta zona de dados ao addressofinitializeddatainmemory deste PE header.
Atribua o image base à imagebase deste PE header.
Atribua 4096 [$00001000] ao memoryalignment deste PE header.
Atribua 4096 [$00001000] ao filealignment deste PE header.
Atribua 0 ao reserved deste PE header.
Atribua o exe size deste compilador ao sizeofimageinmemory deste PE header.
Atribua 4096 [section base] ao sizeofallheadersinfile deste PE header.
Atribua 0 ao checksum deste PE header.
Atribua 0 into as dllcharacteristics deste PE header.
Atribua 1048576 [$00100000] ao maxstack deste PE header.
Atribua 16384 [$00004000] ao minstack deste PE header.
Atribua 1048576 [$00100000] ao maxheap deste PE header.
Atribua 16384 [$00004000] ao minheap deste PE header.
Atribua 0 ao loaderflags deste PE header.

Etapas necessárias para que se initialize um PE header (standard header):
Atribua 17744 [$00004550] ao signature deste PE header.
Atribua 332 [$014C] ao machinetype deste PE header.
Atribua 3 [$0003] ao numberofsections deste PE header.
Atribua 0 ao timestamp deste PE header.
Atribua 0 ao pointertosymboltable deste PE header.
Atribua 0 ao numberofsymbols deste PE header.
Atribua 224 [$00E0] ao sizeofoptionalheaderinbytes deste PE header.
Atribua 33166 [$818E] ao characteristics deste PE header.

Etapas necessárias para que se initialize um PE header (version information):
Atribua 0 ao majorlinkerversion deste PE header.
Atribua 0 ao minorlinkerversion deste PE header.
Atribua 4 [$0004] ao osmajorversion deste PE header.
Atribua 0 [$0000] ao osminorversion deste PE header.
Atribua 0 ao usermajorversion deste PE header.
Atribua 0 ao userminorversion deste PE header.
Atribua 4 [$0004] ao subsystemmajorversion deste PE header.
Atribua 0 [$0000] ao subsystemminorversion deste PE header.
Atribua 2 [$0002] ao subsystem deste PE header.

O intel tag é uma tag igual a 11.

Um intermediate é um local.

O jump false tag é uma tag igual a 12.

Etapas necessárias para que se link:
Round up zona sizes.
Initialize um DOS header.
Initialize um PE header.
Fill o exe deste compilador with o null pedaço usando o exe size deste compilador.
Blurt o DOS header ao exe deste compilador.
Blurt o PE header ao exe deste compilador.
Blurt o imports ao exe deste compilador.
Blurt o globals ao exe deste compilador.
Blurt o literals ao exe deste compilador.
Blurt a routines ao exe deste compilador.

O linking cronômetro é um cronômetro.

Etapas necessárias para que se list:
Limpe o listing deste compilador.
List a mensagem de erro deste compilador no listing deste compilador.
List o types under "TYPES:" no listing deste compilador.
List o globals under "GLOBALS:" no listing deste compilador.
List o literals under "LITERALS:" no listing deste compilador.
List a routines under "ROUTINES:" no listing deste compilador.
List o catálogo de tipos under "TYPE INDEX:" no listing deste compilador.
List o catálogo de variáveis globais under "GLOBAL INDEX:" no listing deste compilador.
List o catálogo de variáveis hexadecimais under "LITERAL INDEX:" no listing deste compilador.
List o catálogo geral de rotinas under "ROUTINE INDEX:" no listing deste compilador.
List o catálogo de rotinas úteis under "catálogo de rotinas úteis:" no listing deste compilador.
List o imports under "IMPORTS:" no listing deste compilador.
List o source files under "SOURCE FILES:" no listing deste compilador.
List o cronômetros under "TIMERS:" no listing deste compilador.
Escreva o listing deste compilador para o listing endereço completo deste compilador.

Etapas necessárias para que se list um mensagem de erro em um trecho:
Se o mensagem de erro estiver em branco, cancele.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" para o trecho.
Advance o trecho (twice).
Posponha o mensagem de erro para o trecho.
Advance o trecho (twice).

Etapas necessárias para que se list um bucket em um trecho:
Se os refers deste bucket estiverem vazio, cancele.
Posponha "/bucket" para o trecho (with separator).
Advance o trecho.
List os refers deste bucket no trecho.
Advance o trecho.

Etapas necessárias para que se list alguns entries em um trecho:
Obtenha um entry from as entries.
Se o entry for inexistente, cancele.
List o entry no trecho.
Repita.

Etapas necessárias para que se list um entry em um trecho:
Se o entry for inexistente, cancele.
Posponha "/entry" para o trecho (with separator).
Posponha o name desta entry para o trecho (with separator).
Posponha o address desta entry para o trecho (as hex with separator).
Advance o trecho.

Etapas necessárias para que se list um fragment em um trecho:
Posponha "/fragment" para o trecho (with separator).
Posponha a tag deste fragment para o trecho (as um fragment tag string with separator).
Posponha a variable deste fragment para o trecho (with separator).
Posponha a other variable deste fragment para o trecho (with separator).
Posponha a routine deste fragment para o trecho (with separator).
Posponha a entry desta fragment para o trecho (with separator).
Posponha o número deste fragment para o trecho (as hex with separator).
Posponha o address deste fragment para o trecho (as hex with separator).
Convert o code deste fragment para um texto da cifra binária.
Posponha o texto da cifra binária para o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns fragments em um trecho:
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
List o fragment no trecho.
Repita.

Etapas necessárias para que se list um import em um trecho:
Se o import for inexistente, cancele.
Posponha "/import" para o trecho (with separator).
Posponha o name deste import para o trecho (with separator).
Advance o trecho.
List as entries deste import no trecho.
Advance o trecho.

Etapas necessárias para que se list alguns imports em um trecho:
Obtenha um import from o imports.
Se o import for inexistente, cancele.
List o import no trecho.
Repita.

Etapas necessárias para que se list alguns imports under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o imports estiverem vazio, cancele.
List o imports no trecho.

Etapas necessárias para que se list um index em um trecho:
Posponha "/" then o used bucket contagem deste index then " buckets" para o trecho (with separator).
Posponha a contagem deste index then " refers" para o trecho (with separator).
Advance o trecho (twice).
Percorra.
Obtenha um bucket usando o index.
Se o bucket for inexistente, cancele.
List o bucket no trecho.
Repita.

Etapas necessárias para que se list um index under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o index estiver vazio, cancele.
List o index no trecho.

Etapas necessárias para que se list um refer em um trecho:
Se o refer for inexistente, cancele.
Posponha "/refer" para o trecho (with separator).
Posponha o string deste refer para o trecho.
Se o endereço de memória deste refer for inexistente, posponha "..." para o trecho.
Posponha "/" para o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns refers em um trecho:
Obtenha um refer from o refers.
Se o refer for inexistente, cancele.
List o refer no trecho.
Repita.

Etapas necessárias para que se list uma routine em um trecho:
Se a routine for inexistente, cancele.
Posponha "/routine" para o trecho (with separator).
Posponha o moniker desta routine para o trecho (with separator).
Posponha o compiled alarme desta routine para o trecho (with separator).
Posponha o callback alarme desta routine para o trecho (with separator).
Posponha o decider alarme desta routine para o trecho (with separator).
Posponha o function alarme desta routine para o trecho (with separator).
Posponha o employs moniker desta routine para o trecho (with separator).
Posponha o parameter size desta routine para o trecho (with separator).
Posponha o local size desta routine para o trecho (with separator).
Posponha o address desta routine para o trecho (as hex with separator).
Advance o trecho.
List os parameters desta routine no trecho.
List os locals desta routine no trecho.
List os fragments desta routine no trecho.
Advance o trecho.

Etapas necessárias para que se list alguns routines em um trecho:
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
List a routine no trecho.
Repita.

Etapas necessárias para que se list alguns routines under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se a routines estiverem vazio, cancele.
List a routines no trecho.

Etapas necessárias para que se list um source file em um trecho:
Se o source file for inexistente, cancele.
Posponha "/source file" para o trecho (with separator).
Posponha o endereço completo deste source file para o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns source files em um trecho:
Obtenha um source file from o source files.
Se o source file for inexistente, cancele.
List o source file no trecho.
Repita.

Etapas necessárias para que se list alguns source files under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o source files estiverem vazio, cancele.
List o source files no trecho.
Advance o trecho.

Etapas necessárias para que se list um cronômetro usando um string em um trecho:
Posponha "/timer" para o trecho (with separator).
Posponha o string para o trecho (with separator).
Posponha o string deste cronômetro para o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list o cronômetros under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
List o loading cronômetro usando "loading" no trecho.
List o scanning cronômetro usando "scanning" no trecho.
List o resolving types cronômetro usando "resolving types" no trecho.
List o resolving globals cronômetro usando "resolving globals" no trecho.
List o compiling routine headers cronômetro usando "compiling routine headers" no trecho.
List o calculating cronômetro usando "calculating" no trecho.
List o adding built-in memory routines cronômetro usando "adding built-in memory routines" no trecho.
List o indexing utilities cronômetro usando "indexing utilities" no trecho.
List o compiling routine bodies cronômetro usando "compiling routine bodies" no trecho.
List o adding built-in startup routine cronômetro usando "adding built-in startup routine" no trecho.
List o offsetting cronômetro usando "offsetting" no trecho.
List o addressing cronômetro usando "addressing" no trecho.
List o transmogrifying cronômetro usando "transmogrifying" no trecho.
List o linking cronômetro usando "linking" no trecho.
List o writing cronômetro usando "writing" no trecho.
List o cronômetro deste compilador usando "total" no trecho.
Advance o trecho.

Etapas necessárias para que se list um type em um trecho:
Se o type for inexistente, cancele.
Posponha "/type" para o trecho (with separator).
Posponha o name deste type para o trecho (with separator).
Posponha o plural name deste type para o trecho (with separator).
Posponha o length deste type para o trecho (as hex with separator).
Posponha o base name deste type para o trecho (with separator).
Posponha o base type deste type para o trecho (with separator).
Posponha o target name deste type para o trecho (with separator).
Posponha o target type deste type para o trecho (with separator).
Posponha a scale deste type para o trecho (with separator).
Advance o trecho.
List os campos deste type no trecho.
Advance o trecho.

Etapas necessárias para que se list alguns types em um trecho:
Obtenha um type from o types.
Se o type for inexistente, cancele.
List o type no trecho.
Repita.

Etapas necessárias para que se list alguns types under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o types estiverem vazio, cancele.
List o types no trecho.

Etapas necessárias para que se list uma variable em um trecho:
Se o variable for inexistente, cancele.
Posponha "/variable" para o trecho (with separator).
Posponha o categoria desta variable para o trecho (with separator).
Posponha o compiled alarme desta variable para o trecho (with separator).
Posponha o name desta variable para o trecho (with separator).
Posponha o nickname desta variable para o trecho (with separator).
Posponha o type name desta variable para o trecho (with separator).
Posponha o type desta variable para o trecho (with separator).
Posponha o address desta variable [or offset] para o trecho (as hex with separator).
Posponha o by-value alarme desta variable para o trecho (with separator).
Posponha o contagem desta variable para o trecho (with separator).
Posponha o reference alarme desta variable para o trecho (with separator).
Posponha o redefinition target name desta variable para o trecho (with separator).
Posponha o literal desta variable para o trecho (with separator).
Convert o data desta variable para um texto da cifra binária.
Posponha o texto da cifra binária para o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns variables em um trecho:
Obtenha uma variable from o variables.
Se o variable for inexistente, cancele.
List o variable no trecho.
Repita.

Etapas necessárias para que se list alguns variables under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o variables estiverem vazio, cancele.
List o variables no trecho.
Advance o trecho.

O catálogo de variáveis hexadecimais é um index.

An literal é uma variable.

O literals são alguns literals.

O load address tag é uma tag igual a 13.

O load eax tag é uma tag igual a 14.

An local é uma variable.

Um locus é um endereço de memória do pedaço .

O loop tag é uma tag igual a 15.

Um moniker é um string.

Um monikette é uma coisa with
Um string,
Um type (reference),
Um variable (reference),
\ por bubbling
Um type atual (reference),
Um subtexto atual.

Etapas necessárias para que se mova um percorredor (code rules - comment):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor não for o return pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - glom):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o percorredor estiver sobre any possessive, cancele.
Se o target deste first deste source deste percorredor for any glom pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - mark):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules - noise):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for noise, repita.

Etapas necessárias para que se mova um percorredor (code rules - possessive):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o source deste percorredor starts with "s", avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules - qualifier):
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, pare.
Se o target deste first deste source deste percorredor for o left-paren pedaço, adicione 1 para um contagem.
Se o target deste first deste source deste percorredor for o right-paren pedaço, subtraia 1 from a contagem.
Avance o percorredor.
Se o contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - remark):
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, pare.
Se o target deste first deste source deste percorredor for o left-bracket pedaço, adicione 1 para um contagem.
Se o target deste first deste source deste percorredor for o right-bracket pedaço, subtraia 1 from a contagem.
Avance o percorredor.
Se o contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - string):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, cancele.
Se o percorredor estiver sobre any nested double-quote, avance o percorredor; repita.
Se o target deste first deste source deste percorredor for as aspas duplas, avance o percorredor; exit.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - symbol):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules):
Position o token deste percorredor sobre o source deste percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for noise, mova o percorredor (code rules - noise); exit.
Se o target deste first deste source deste percorredor for a barra invertida, mova o percorredor (code rules - comment); exit.
Se o target deste first deste source deste percorredor for o left-bracket pedaço, mova o percorredor (code rules - remark); exit.
Se o target deste first deste source deste percorredor for as aspas duplas, mova o percorredor (code rules - string); exit.
Se o target deste first deste source deste percorredor for o left-paren pedaço, mova o percorredor (code rules - qualifier); exit.
Se o target deste first deste source deste percorredor for any mark, mova o percorredor (code rules - mark); exit.
Se o percorredor estiver sobre any possessive, mova o percorredor (code rules - possessive); exit.
Mova o percorredor (code rules - glom).

Etapas necessárias para que se mova um percorredor (compilador rules):
Se o alarme de alerta deste compilador estiver ativo, limpe o token deste percorredor; exit.
Mova o percorredor returning um erro string (code rules).
Se o erro string não estiver em branco, apresente uma mensagem de erro contendo o erro string e o first deste token deste percorredor; exit.
\Se o token deste percorredor for "del", recue o percorredor; exit. \ Spanish contraction "del"; fudged para "de l", short por "de el"
\Se o token deste percorredor for "al", recue o percorredor; exit. \ Spanish contraction "al"; fudged para "a l", short por "a el"
Se o token deste percorredor estiver em branco, cancele.
Se o target deste first deste token deste percorredor for noise, repita.
Se o target deste first deste token deste percorredor for a barra invertida, repita.
Se o target deste first deste token deste percorredor for o left-bracket pedaço, repita.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate qualifier):
Se o length deste token deste percorredor for menor do que 2, atribua "Qualificadores devem terminar com parêntese ')'." ao erro string; exit.
Se o target deste last deste token deste percorredor não for o right-paren pedaço, atribua "Qualificadores precisam terminar com um parêntese ')'." ao erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate remark):
Se o length deste token deste percorredor for menor do que 2, atribua "Observações devem terminar com um colchete ']'." ao erro string; exit.
Se o target deste last deste token deste percorredor não for o right-bracket pedaço, atribua "Observações precisam terminar com um colchete ']'." ao erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules - validate string):
Se o length deste token deste percorredor for menor do que 2, atribua "Textos precisam terminar com aspas: ""." ao erro string; exit.
Se o target deste last deste token deste percorredor não for as aspas duplas, atribua "Textos tem que terminar com aspas: ""." ao erro string; exit.

Etapas necessárias para que se mova um percorredor returning um erro string (code rules):
Limpe o erro string.
Mova o percorredor (code rules).
Se o token deste percorredor estiver em branco, cancele.
Se o target deste first deste token deste percorredor for o left-bracket pedaço, mova o percorredor returning o erro string (code rules - validate remark); exit.
Se o target deste first deste token deste percorredor for as aspas duplas, mova o percorredor returning o erro string (code rules - validate string); exit.
Se o target deste first deste token deste percorredor for o left-paren pedaço, mova o percorredor returning o erro string (code rules - validate qualifier); exit.

Um parte da cifra binária é um subtexto.

Um nickname é um name.

O not tag é uma tag igual a 16.

Etapas necessárias para que se offset o locals em uma routine:
Se a routine for inexistente, cancele.
Se a compiled alarme desta routine não estiver ativo, cancele.
Limpe o local size desta routine.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um local from os locals desta routine.
Se o local for inexistente, cancele.
Se o previous deste local não for inexistente, atribua o offset deste previous deste local ao offset deste local.
Atribua o length deste type deste local into um length.
Se a categoria deste local for "scratch", atribua um endereço de memória's magnitude ao length.
Round o length up para o nearest multiple of 4.
Subtraia o length from o offset deste local.
Adicione o length para o local size desta routine.
Repita.

Etapas necessárias para que se offset os locals em alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Offset os locals na routine.
Repita.

Etapas necessárias para que se offset o parameters em uma routine:
Se a routine for inexistente, cancele.
Se a compiled alarme desta routine não estiver ativo, cancele.
Limpe o parameter size desta routine.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um parameter from os parameters desta routine.
Se o parameter for inexistente, cancele.
Se o callback alarme desta routine estiver ativo, acione o by-value alarme deste parameter.
Se o previous deste parameter for inexistente, atribua 8 ao offset deste parameter. \ skip o return address e saved ebp
Se o previous deste parameter não for inexistente, atribua o offset deste previous deste parameter mais 4 ao offset deste parameter. \ all parameters são 4 endereço de memória do pedaço s ou 4 pedaço values por callbacks
Adicione 4 para a parameter size desta routine.
Repita.

Etapas necessárias para que se offset o parameters em alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, cancele.
Offset o parameters na routine.
Repita.

O offsetting cronômetro é um cronômetro.

An parameter é uma variable.

Um partial moniker é um moniker.

Um PE header é um conjunto with
\ Portable Executable (PE) file format is a file format for executable / dll files introduced em Windows NT. It is based sobre COFF (Common Object File Format) specification.
\To remain compatible with previous versions of the MS-DOS and Windows, the PE file format retains the old MZ header from MS-DOS.
\O PE file format is organized as a linear stream of data. 
\It begins with an MS-DOS header, a real-mode program stub, and a PE file signature. 
\Immediately following is a PE file header and optional header. Beyond that, all the section headers appear, followed by all of the section bodies. 
\Closing out the file are a few other regions of miscellaneous information, including relocation information, symbol table information, line number information, and string table data. 
\ O MS-DOS header occupies the first 64 bytes of the PE file. A structure representing its content is described below:
Um número called signature,
Um wyrd called machinetype, \ O number that identifies the type of target machine. For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types
Um wyrd called numberofsections, \ O number of sections. This indicates the size of the section table, which immediately follows the headers.
Um número called timestamp, \ O low 32 bits of the number of seconds since 00:00 January 1, 1970 (a C run-time time_t value), which indicates when the file was created.
Um número called pointertosymboltable, \ O file offset of the COFF symbol table, or zero if no COFF symbol table is present. 
\This value should be zero for an image because COFF debugging information is deprecated.
Um número called numberofsymbols, \ O number of entries em the symbol table. 
\This data can be used para locate the string table, which immediately follows the symbol table. 
\This value should be zero for an image because COFF debugging information is deprecated.
Um wyrd called sizeofoptionalheaderinbytes, \ O size of the optional header, which is required for executable files but not for object files. 
\This value should be zero for an object file. For a description of the header format, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-image-only
Um wyrd called characteristics, \ O flags that indicate the attributes of the file. For specific flag values, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics
\ optional header
Um wyrd called magicnumber, \ O optional header magic number determines whether an image is a PE32 or PE32+ executable.
\PE32+ images allow for a 64-bit address space while limiting the image size para 2 gigabytes. Other PE32+ modifications are addressed em their respective sections.
\ O unsigned integer that identifies the state of the image file. 
\O most common number is 0x10B, which identifies it as a normal executable file. 0x107 identifies it as a ROM image, and 0x20B identifies it as a PE32+ executable.
\ O first campo, e_magic, is the so-called magic number. 
\This campo is used para identify an MS-DOS-compatible file type. 
\All MS-DOS-compatible executable files set this value para 0x5A4D, which represents the ASCII characters MZ. 
\MS-DOS headers are sometimes referred para as MZ headers for this reason. 
\Many other campos are important para MS-DOS operating systems, but for Windows NT, there is really one more important campo em this structure. 
\O final campo, e_lfanew, is a 4-byte offset into the file where the PE file header is located. 
\It is necessary para use this offset para locate the PE header em the file. 
\For PE files em Windows NT, the PE file header occurs soon after the MS-DOS header with only the real-mode stub program between them.
Um pedaço called majorlinkerversion, \ Indicates version of the linker that linked this image.
Um pedaço called minorlinkerversion, \ Indicates version of the linker that linked this image.
Um número called sizeofcodeinfile, \ Size of executable code. O size of the code (text) section, or the sum of all code sections if there are multiple sections.
Um número called sizeofinitializeddatainfile, \ Size of initialized data. O size of the initialized data section, or the sum of all such sections if there are multiple data sections.
Um número called sizeofuninitializeddatainfile, \ Size of uninitialized data. O size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.
Um número called addressofentrypointinmemory, \ Of the standard campos, the AddressOfEntryPoint campo is the most interesting for the PE file format. 
\This campo indicates the location of the entry point for the application and, perhaps more importantly para system hackers, the location of the end of the Import Address Table (IAT). 
\O address of the entry point relative para the image base when the executable file is loaded into memory. 
\For program images, this is the starting address. For device drivers, this is the address of the initialization function. 
\Um entry point is optional for DLLs. When no entry point is present, this campo must be zero.
Um número called addressofcodeinmemory, \ O address that is relative para the image base of the beginning-of-code section when it is loaded into memory.
Um número called addressofinitializeddatainmemory, \ O address that is relative para the image base of the beginning-of-data section when it is loaded into memory.
Um número called imagebase, \ O preferred address of the first byte of image when loaded into memory; must be a multiple of 64 K. 
\O default for DLLs is 0x10000000. O default for Windows CE EXEs is 0x00010000. 
\O default for Windows NT, Windows 2000, Windows XP, Windows 95, Windows 98, and Windows Me is 0x00400000.
\Preferred base address em the address space of a process para map the executable image to. O linker defaults para 0x00400000, but you can override the default.
Um número called memoryalignment, \ O alignment (in bytes) of sections when they are loaded into memory. 
\It must be greater than or equal para FileAlignment. 
\O default is the page size for the architecture.
Um número called filealignment, \ O alignment factor (in bytes) that is used para align the raw data of sections em the image file. 
\O value should be a power of 2 between 512 and 64 K (65535) , inclusive. O default is 512. 
\If the SectionAlignment is less than the page size da architecture, then FileAlignment must match SectionAlignment.
Um wyrd called osmajorversion, \ Indicates the major version of the Windows NT operating system.
Um wyrd called osminorversion, \ Indicates the minor version of the Windows NT operating system.
Um wyrd called usermajorversion, \ Used para indicate the major version number of the application.
Um wyrd called userminorversion, \ Used para indicate the minor version number of the application.
Um wyrd called subsystemmajorversion, \ Indicates the Windows NT Win32 subsystem major version number.
Um wyrd called subsystemminorversion, \ Indicates the Windows NT Win32 subsystem minor version number.
Um número called reserved, \ Reserved, must be zero. Unknown purpose, currently not used by the system and set para zero by the linker.
Um número called sizeofimageinmemory, \ O size (in bytes) of the image, including all headers, as the image is loaded em memory. It must be a multiple of SectionAlignment.
\ Indicates the amount of address space para reserve em the address space for the loaded executable image. 
\This number is influenced greatly by SectionAlignment. 
\For example, consider a system having a fixed page size of 4096 bytes. 
\If you have an executable with 11 sections, each less than 4096 bytes, aligned sobre a 65,536-byte boundary, the SizeOfImage campo would be set para 11 * 65,536 = 720,896 (176 pages). 
\O same file linked with 4096-byte alignment would result em 11 * 4096 = 45,056 (11 pages) for the SizeOfImage campo. 
\This is a simple example em which each section requires less than a page of memory. 
\In reality, the linker determines the exact SizeOfImage by figuring each section individually. 
\It first determines how many bytes the section requires, then it rounds up para the nearest page boundary, and finally it rounds page count para the nearest SectionAlignment boundary. 
\O total is then the sum of each individual requirement da section.
Um número called sizeofallheadersinfile, \ O combined size of an MS-DOS stub, PE header, and section headers rounded up para a multiple of FileAlignment.
\ This campo indicates how much space em the file is used for representing all the file headers, 
\ including the MS-DOS header, PE file header, PE optional header, and PE section headers. O section bodies begin at this location em the file.
Um número called checksum, \ O image file checksum. 
\ O algorithm for computing the checksum is incorporated into IMAGHELP.DLL. 
\ O following are checked for validation at load time: all drivers, any DLL loaded at boot time, and any DLL that is loaded à critical Windows process.
\ A checksum value is used para validate the executable file at load time. 
\ O value is set and verified by the linker. O algorithm used for creating these checksum values is proprietary information and will not be published.
Um wyrd called subsystem, \ Field used para identify the target subsystem for this executable (O subsystem that is required para run this image). 
\Each of the possible subsystem values are listed em the WINNT.H file immediately after the IMAGE_OPTIONAL_HEADER structure.
\For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#windows-subsystem
Um wyrd called dllcharacteristics, \ Flags used para indicate if a DLL image includes entry points for process and thread initialization and termination.
\ For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics
Um número called maxstack, \These campos control the amount of address space para reserve and commit for the stack and default heap. 
Um número called minstack, \Both the stack and heap have default values of 1 page committed and 16 pages reserved. 
Um número called maxheap, \These values are set with the linker switches -STACKSIZE: and -HEAPSIZE:. 
Um número called minheap, 
Um número called loaderflags, \ TReserved, must be zero. Tells the loader whether para break sobre load, debug sobre load, or the default, which is para let things run normally.
\ directories (16 address e size pairs)
Um número called numberofdirectories,
8 pedaços called directory0,
Um número called imagedirectoryentryimportaddress,
Um número called imagedirectoryentryimportsize,
112 pedaços called directories2-15,
Um PE section header called idata section,
Um PE section header called data section,
Um PE section header called code section. \ https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags

Um PE section header é um conjunto with
\ Section headers are located sequentially right after the optional header em the PE file format. Each section header is 40 bytes with no padding between them. 
\O PE file specification consists of the headers defined so far and a generic object called a section. 
\Sections contain the content of the file, including code, data, resources, and other executable information. 
\Each section has a header and a body (the raw data). Section headers are described below, but section bodies lack a rigid file structure. 
\They can be organized em almost any way a linker wishes para organize them, as long as the header is filled with enough information para be able para decipher the data.
8 pedaços called name, \ Each section header has a name campo up para eight characters long, for which the first character must be a period.
Um número called sizeinbytes,
Um número called addressinmemory,
Um número called sizeinfile,
Um número called addressinfile,
12 pedaços called reserved,
Um número called characteristics. \ Defines the section characteristics. These values are found both em WINNT.H and em the Portable Executable Format specification.
\Value	Definition
\0x00000020	Code section
\0x00000040	Initialized data section
\0x00000080	Uninitialized data section
\0x04000000	Section cannot be cached
\0x08000000	Section is not pageable
\0x10000000	Section is shared
\0x20000000	Executable section
\0x40000000	Readable section
\0x80000000	Writable section

Um phrase é um string.

\Etapas necessárias para que se determine se um string looks like English:
\Load o lexicon.
\Se o lexicon for inexistente, mostre erro "I can't find any lecksicon."; diga não.
\Se o string estiver em branco, diga não.
\Lance um subtexto sobre o string.
\Atribua o last deste subtexto ao first deste subtexto.
\Percorra.
\Se o first deste subtexto é o first deste string, pare.
\Se o target deste first deste subtexto for o caractere de espaço, adicione 1 para o first deste subtexto; break.
\Subtraia 1 from o first deste subtexto.
\Repita.
\Se o subtexto estiver no index deste lexicon, diga sim.
\Diga não.

Etapas necessárias para que se pluralize um string (portuguese rules):
Lance um percorredor sobre o string.
Percorra.
Mova o percorredor (spell checking rules).
Se o token deste percorredor estiver em branco, pare.
Se um plural string não estiver em branco, posponha " " para o plural string.
Posponha o token deste percorredor para o plural string.
Se o token deste percorredor for "de", acione um alarme; repita. \ aqui identifica um termo composto. Falta implementar.
Se o alarme não estiver ativo, pluralize o plural string (portuguese rules - each palavra).
\ Se o alarme estiver ativo, pluralize o plural string (substantivos compostos).
Repita.
Atribua o plural string ao string.

Etapas necessárias para que se pluralize um string (portuguese rules - each palavra):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se o string for "bit", atribua "bits" ao string; exit.
Se o string for "cidadão", posponha "s" para o string; exit.
Se o string for "irmão", posponha "s" para o string; exit.
Se o string for "cristão", posponha "s" para o string; exit.
Se o string for "refrão", posponha "s" para o string; exit.
Se o string for "pão", remove o last pedaço from o string; posponha "es" para o string; exit.
Se o string for "capitão", remove o last pedaço from o string; posponha "es" para o string; exit.
Se o string for "alemão", remove o last pedaço from o string; posponha "es" para o string; exit.
Se o string for "charlatão", remove o last pedaço from o string; posponha "es" para o string; exit.
Se o string for "caráter", atribua "carateres" ao string; exit.
Se o string for "júnior", atribua "juniores" ao string; exit.
Se o string for "sênior", atribua "seniores" ao string; exit.
Se o string for "mão", atribua "mãos" ao string; exit.
Se o string for "são", atribua "sãos" ao string; exit.
\# advérbios principais
Se o string for "muito", cancele.
Se o string for "pouco", cancele.
Se o string for "mais", cancele.
Se o string for "menos", cancele.
Se o string for "bastante", cancele.
Se o string for "quase", cancele.
Se o string for "demais", cancele.
Se o string for "bem", cancele.
Se o string for "deveras", cancele.
Se o string for "mal", cancele.
Se o string for "melhor", cancele.
Se o string for "pior", cancele.
\# palavras terminadas com "ão"
Se o string ends with "ão", pluralize o string (portuguese rules - ending palavras with "ão"); exit.
\# palavras terminadas com "l"
Se o string ends with "l", pluralize o string (portuguese rules - ending palavras with "l"); exit.
\# palavra terminadas com "m"
Se o string ends with "m", remove o last pedaço from o string; posponha "ns" para o string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se o string ends with "n", posponha "es" para o string; exit.
\# palavras terminadas com "r"
Se o string ends with "r", pluralize o string (portuguese rules - ending palavras with "r"); exit.
\# palavras terminadas com "s"
Se o string ends with "s", pluralize o string (portuguese rules - ending palavras with "s"); exit.
\# palavra terminadas com "x"
Se o string ends with "x", posponha "es" para o string; exit.
\# palavras terminadas com "z"
Se o string ends with "z", pluralize o string (portuguese rules - ending palavras with "z"); exit.
\# regra padrão
Posponha "s" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "ão"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "s" para o string; exit.
\# regra padrão
Remove os last dois pedaços from o string.
Posponha "ões" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "l"):
\# palavras terminadas com "al"
Se o string ends with "al", remove o last pedaço from o string; posponha "is" para o string; exit.
\# palavras terminadas com "el"
Se o string ends with "el", pluralize o string (portuguese rules - ending palavras with "el"); exit.
\# palavras terminadas com "il"
Se o string ends with "il", pluralize o string (portuguese rules - ending palavras with "il"); exit.
\# palavras terminadas com "ol"
Se o string ends with "ol", pluralize o string (portuguese rules - ending palavras with "ol"); exit.
\# palavras terminadas com "ul"
Se o string ends with "ul", remove o last pedaço from o string; posponha "is" para o string; exit.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "el"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last pedaço from o string; posponha "is" para o string; exit.
Remove os last dois pedaços from o string.
Posponha "éis" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "il"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove os last dois pedaços from o string; posponha "eis" para o string; exit.
Remove o last pedaço from o string.
Posponha "s" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "ol"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last pedaço from o string; posponha "is" para o string; exit.
Remove os last dois pedaços from o string.
Posponha "óis" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "r"):
\# hiatos acentuados
\Se o string ends with "aír", posponha "es" para o string; exit.
\Se o string ends with "aúr", posponha "es" para o string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se o string ends with "ár", remove os last dois pedaços from o string; posponha "ares" para o string; exit.
\Se o string ends with "âr", remove os last dois pedaços from o string; posponha "ares" para o string; exit.
\Se o string ends with "ér", remove os last dois pedaços from o string; posponha "eres" para o string; exit.
\Se o string ends with "êr", remove os last dois pedaços from o string; posponha "eres" para o string; exit.
\Se o string ends with "ír", remove os last dois pedaços from o string; posponha "ires" para o string; exit.
\Se o string ends with "ór", remove os last dois pedaços from o string; posponha "ores" para o string; exit.
\Se o string ends with "ôr", remove os last dois pedaços from o string; posponha "ores" para o string; exit.
\Se o string ends with "úr", remove os last dois pedaços from o string; posponha "ures" para o string; exit.
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "es" para o string; exit.
\# hiatos
Se o string ends with "air", remove os last dois pedaços from o string; posponha "íres" para o string; exit.
Se o string ends with "aur", remove os last dois pedaços from o string; posponha "úres" para o string; exit.
\# regra padrão
Posponha "es" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se o string ends with "as", cancele.
Se o string ends with "es", cancele.
Se o string ends with "os", cancele.
\# hiatos acentuados
Se o string ends with "aís", posponha "es" para o string; exit.
Se o string ends with "aús", posponha "es" para o string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se o string ends with "ás", remove os last dois pedaços from o string; posponha "ases" para o string; exit.
Se o string ends with "âs", remove os last dois pedaços from o string; posponha "ases" para o string; exit.
Se o string ends with "és", remove os last dois pedaços from o string; posponha "eses" para o string; exit.
Se o string ends with "ês", remove os last dois pedaços from o string; posponha "eses" para o string; exit.
Se o string ends with "ís", remove os last dois pedaços from o string; posponha "ises" para o string; exit.
Se o string ends with "ós", remove os last dois pedaços from o string; posponha "oses" para o string; exit.
Se o string ends with "ôs", remove os last dois pedaços from o string; posponha "oses" para o string; exit.
Se o string ends with "ús", remove os last dois pedaços from o string; posponha "uses" para o string; exit.
\# palavras terminadas com "is", "us"
Se o string ends with "is", pluralize o string (portuguese rules - ending palavras with "is/us"); exit.
Se o string ends with "us", pluralize o string (portuguese rules - ending palavras with "is/us"); exit.
\# regra padrão
Posponha "es" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "is/us"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, cancele.
\# hiatos
Se o string ends with "ais", remove os last dois pedaços from o string; posponha "íses" para o string; exit.
Se o string ends with "aus", remove os last dois pedaços from o string; posponha "úses" para o string; exit.
\# regra padrão
Posponha "es" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras with "z"):
\# hiatos acentuados
Se o string ends with "aíz", posponha "es" para o string; exit.
Se o string ends with "aúz", posponha "es" para o string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se o string ends with "áz", remove os last dois pedaços from o string; posponha "azes" para o string; exit.
Se o string ends with "âz", remove os last dois pedaços from o string; posponha "azes" para o string; exit.
Se o string ends with "éz", remove os last dois pedaços from o string; posponha "ezes" para o string; exit.
Se o string ends with "êz", remove os last dois pedaços from o string; posponha "ezes" para o string; exit.
Se o string ends with "íz", remove os last dois pedaços from o string; posponha "izes" para o string; exit.
Se o string ends with "óz", remove os last dois pedaços from o string; posponha "ozes" para o string; exit.
Se o string ends with "ôz", remove os last dois pedaços from o string; posponha "ozes" para o string; exit.
Se o string ends with "úz", remove os last dois pedaços from o string; posponha "uzes" para o string; exit.
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "es" para o string; exit.
\# hiatos
Se o string ends with "aiz", remove os last dois pedaços from o string; posponha "ízes" para o string; exit.
Se o string ends with "auz", remove os last dois pedaços from o string; posponha "úzes" para o string; exit.
\# regra padrão
Posponha "es" para o string.

Etapas necessárias para que se pluralize um string (english rules);
Etapas necessárias para que se pluralize um string:
Se o string for "centena", atribua "centenas" ao string; exit.
Se o string for "milhar", atribua "milhares" ao string; exit.
Se o string for "entrada", atribua "entradas" ao string; exit.
Se o string for "campo", atribua "campos" ao string; exit.
Se o string for "fragmento", atribua "fragmentos" ao string; exit.
Se o string for "parâmetro", atribua "parâmetros" ao string; exit.
Se o string for "fonte", atribua "fontes" ao string; exit.
Se o string for "forma", atribua "formas" ao string; exit.
Se o string for "contexto", atribua "contextos" ao string; exit.
Se o string for "evento", atribua "eventos" ao string; exit.
Se o string for "catálogo", atribua "catálogos" ao string; exit.
Se o string for "índice", atribua "índices" ao string; exit.
Se o string for "milhão", atribua "milhões" ao string; exit.
Se o string for "milissegundo", atribua "milissegundos" ao string; exit.
Se o string for "ponto", atribua "pontos" ao string; exit.
Se o string for "polígono", atribua "polígonos" ao string; exit.
Se o string for "objeto", atribua "objetos" ao string; exit.
Se o string for "grau", atribua "graus" ao string; exit.
Se o string for "preciso", atribua "precisos" ao string; exit.
Se o string for "linha", atribua "linhas" ao string; exit.
Se o string for "fileira", atribua "fileiras" ao string; exit.
Se o string for "conjunto", atribua "conjuntos" ao string; exit.
Se o string for "texto", atribua "textos" ao string; exit.
Se o string for "unidade", atribua "unidades" ao string; exit.
Se o string for "polegada", atribua "polegadas" ao string; exit.
Se o string for "endereço", atribua "endereços" ao string; exit.
Se o string for "comando", atribua "comandos" ao string; exit.
Se o string for "tipo", atribua "tipos" ao string; exit.
Se o string for "nome", atribua "nomes" ao string; exit.
Se o string for "extensão", atribua "extensões" ao string; exit.
Se o string for "rotina", atribua "rotinas" ao string; exit.
Se o string for "imagem", atribua "imagens" ao string; exit.
Se o string for "figura", atribua "figuras" ao string; exit.
\ nouns only
Se o string for "alumnus", atribua "alumni" ao string; exit.
Se o string for "auto", atribua "autos" ao string; exit.
Se o string for "botão", atribua "botões" ao string; exit.
Se o string for "cello", atribua "cellos" ao string; exit.
Se o string for "dwarf", atribua "dwarfs" ao string; exit.
Se o string for "foot", atribua "feet" ao string; exit.
Se o string for "forma", atribua "formas" ao string; exit.
Se o string for "genus", atribua "genera" ao string; exit.
Se o string for "goose", atribua "geese" ao string; exit.
Se o string for "hippo", atribua "hippos" ao string; exit.
Se o string for "louse", atribua "lice" ao string; exit.
Se o string for "memo", atribua "memos" ao string; exit.
Se o string for "mouse", atribua "mice" ao string; exit.
Se o string for "ox", atribua "oxen" ao string; exit.
Se o string for "phenomenon", atribua "phenomena" ao string; exit.
Se o string for "photo", atribua "photos" ao string; exit.
Se o string for "phylum", atribua "phyla" ao string; exit.
Se o string for "piano", atribua "pianos" ao string; exit.
Se o string for "pimento", atribua "pimentos" ao string; exit.
Se o string for "pro", atribua "pros" ao string; exit.
Se o string for "proof", atribua "proofs" ao string; exit.
Se o string for "radius", atribua "radii" ao string; exit.
Se o string for "rhinoceros", atribua "rhinoceri" ao string; exit.
Se o string for "roof", atribua "roofs" ao string; exit.
Se o string for "solo", atribua "solos" ao string; exit.
Se o string for "soprano", atribua "sopranos" ao string; exit.
Se o string for "staff", atribua "staffs" ao string; exit.
Se o string for "tooth", atribua "teeth" ao string; exit.
Se o string for "torus", atribua "tori" ao string; exit.
Se o string for "turf", atribua "turfs" ao string; exit.
Se o string for "virus", atribua "viruses" ao string; exit.
Se o string ends with "sh", posponha "es" para o string; exit.
Se o string ends with "ch", posponha "es" para o string; exit.
Se o string ends with "man", remove os last dois pedaços from o string; posponha "en" para o string; exit.
Se o string ends with "child", posponha "ren" para o string; exit.
Se o string ends with "ex", remove os last dois pedaços from o string; posponha "ices" para o string; exit. \ ou adicione ES
Se o string ends with "fe", remove os last dois pedaços from o string; posponha "ves" para o string; exit.
Se o string ends with "is", remove os last dois pedaços from o string; posponha "es" para o string; exit.
Se o string ends with "ix", remove os last dois pedaços from o string; posponha "ices" para o string; exit. \ ou adicione ES
Se o string ends with "ma", posponha "ta" para o string; exit. \ ou adicione S
Se o string ends with any consonant e "y", remove o last pedaço from o string; posponha "ies" para o string; exit.
Se o string ends with any vowel e "o", posponha "s" para o string; exit.
Se o string ends with any vowel e "y", posponha "s" para o string; exit.
Se o string ends with "f", remove o last pedaço from o string; posponha "ves" para o string; exit.
Se o string ends with "s", posponha "es" para o string; exit.
Se o string ends with "x", posponha "es" para o string; exit.
Se o string ends with "z", posponha "es" para o string; exit.
Posponha "s" para o string.

O prolog tag é uma tag igual a 17.

Um prototype string é um conjunto with um first endereço de memória do pedaço e um last endereço de memória do pedaço .

O push address tag é uma tag igual a 18.

O push value tag é uma tag igual a 19.

Etapas necessárias para que se atribua o endereço exe completo deste compilador into um endereço completo:
Extract um designador from o endereço da pasta deste compilador.
Remove any trailing barra invertida from o designador.
Atribua o endereço da pasta deste compilador then o designador then ".exe" ao endereço completo.

Etapas necessárias para que se atribua o exe size deste compilador into um size:
Atribua 4096 [section base] ao size.
Adicione o size desta import zona para o size.
Adicione o size desta zona de dados para o size.
Adicione o size desta code zona para o size.

Etapas necessárias para que se atribua o listing endereço completo deste compilador into um endereço completo:
Extract um designador from o endereço da pasta deste compilador.
Remove any trailing barra invertida from o designador.
Atribua o endereço da pasta deste compilador then o designador then ".lst" ao endereço completo.

Etapas necessárias para que se atribua um term into another term:
Atribua a variable deste term ao variable deste other term.
Atribua a phrase deste term ao phrase deste other term.

Etapas necessárias para que se load um source file:
Se o source file for inexistente, cancele.
\Load o endereço completo deste source file ao trecho deste source file.
\Se o i/o erro não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo:: " then o endereço completo deste source file then "."; exit.
Load o endereço completo deste source file into um string.
Se o i/o erro não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " then o endereço completo deste source file then "."; exit.
Parse o string para o trecho deste source file (portuguese contractions e synonyms rules).

Etapas necessárias para que se load alguns source files:
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um item from o endereço da pasta deste compilador.
Se o item não for found, pare.
Se a categoria deste item não for "file", repita.
Se a extensão deste item não estiver em branco, repita.
Se o item looks reamish, repita.
Adicione um source file para o source files usando o endereço completo deste item.
Load o source file.
Repita.

O loading cronômetro é um cronômetro.

Etapas necessárias para que se parse um string para another string (portuguese contractions e synonyms rules):
Limpe o other string.
Limpe um terceiro string.
Lance um percorredor sobre o string.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Position o token deste percorredor sobre o source deste percorredor.
Mova o percorredor (code rules).
Se o target deste first deste token deste percorredor não for any glom pedaço, posponha o token deste percorredor para o other string; repita.
Posponha o token deste percorredor para o other string giving o terceiro string (portuguese contractions e synonyms rules).
Atribua o token deste percorredor ao terceiro string.
Repita.

Etapas necessárias para que se reduce alguns monikettes por utility use:
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Se o type deste monikette for inexistente, repita.
Reduce o type deste monikette para um type por utility use.
Se o type não for inexistente, atribua o type ao type deste monikette.
Repita.

Etapas necessárias para que se reduce um type para another type por utility use:
Atribua o type ao other type.
Percorra.
Se o other type for inexistente, cancele.
Se o name deste other type for "texto hexadecimal", cancele.
Se o name deste other type for "string", cancele.
Se o name deste other type for "número", cancele.
Se o name deste other type for "endereço de memória", cancele.
Se o name deste other type for "coisa", esvazie o other type; exit.
\PAL
\Se o name deste other type for "elemento", esvazie o other type; exit.
Se o base type deste other type for o other type, esvazie o other type; exit.
Atribua o base type deste other type ao other type.
Repita.

Etapas necessárias para que se catalogue novamente o catálogo de rotinas úteis:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um bucket usando o catálogo de rotinas úteis.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Catalogue novamente o catálogo de rotinas úteis usando os refers deste bucket.
Repita.

Etapas necessárias para que se catalogue novamente o catálogo de rotinas úteis usando alguns refers:
Obtenha um refer from o refers.
Se o refer for inexistente, cancele.
Atribua o endereço de memória deste refer into uma routine.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Erro interno na função: index o utility routines usando alguns refers"; exit.
Copy os monikettes desta routine into alguns monikettes.
Reduce os monikettes por utility use.
Catalogue a routine usando os monikettes e o catálogo geral de rotinas.
Destroy os monikettes.
Repita.

Etapas necessárias para que se remove any negatives from alguns monikettes returning um alarme:
Desative o alarme.
Swap os monikettes with alguns other monikettes.
Percorra.
Atribua o first destes other monikettes into um monikette.
Se o monikette for inexistente, cancele.
Remove o monikette from o other monikettes.
\PAL
Se o string deste monikette for "não", reverse o alarme; destroy o monikette; repita.
Se o string deste monikette for "nada", reverse o alarme; destroy o monikette; repita.
\CAL
Se o string deste monikette for "not", reverse o alarme; destroy o monikette; repita.
Se o string deste monikette for "nada", reverse o alarme; destroy o monikette; repita.
Posponha o monikette para os monikettes.
Se o string deste monikette for "can't", reverse o alarme; atribua "can" ao string deste monikette; repita.
Se o string deste monikette for "cannot", reverse o alarme; atribua "can" ao string deste monikette; repita.
Se o string deste monikette for "nothing", reverse o alarme; atribua "something" ao string deste monikette; repita.
Se o string deste monikette for "won't", reverse o alarme; atribua "will" ao string deste monikette; repita.
Se o string deste monikette ends with "n't", reverse o alarme; remove trailing pedaços from o string deste monikette usando 3; repita.
Repita.

O repeat tag é uma tag igual a 21.

Etapas necessárias para que se resolva um campo:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o campo for inexistente, cancele.
Resolva o campo como uma variable.
Se o nickname deste campo não for any valid campo name, limpe o nickname deste campo. \it
Se o name deste campo não for any valid campo name, apresente uma mensagem de erro contendo "'" then o name deste campo then "' é um campo name inválido." e o locus deste campo; exit.

Etapas necessárias para que se resolva um global:
Se o global for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o global body deste global não estiver em branco, resolva o global (compile body).
Se o type name deste global estiver em branco, apresente uma mensagem de erro contendo "Tipo inválido:: " then o name deste global then "' . O tipo da variável global está vazio." e o locus deste global; exit.
Resolva o global como uma variable.

Etapas necessárias para que se resolva um global (compile body):
Se o global for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor sobre o global body deste global.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any literal, apresente uma mensagem de erro contendo "Erro de tipo. O tipo:: " then o token deste percorredor then "' tem que ser do tipo literal." e o percorredor; exit.
Compile um literal usando o percorredor.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Acho que era bom colocar um ponto por aqui, né?" e o percorredor; exit.
Se o type name deste global estiver em branco, atribua o name deste type deste literal ao type name deste global.
Atribua o literal ao literal deste global.
Catalogue o literal.

Etapas necessárias para que se resolva alguns globals:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Resolva o global.
Repita.

Etapas necessárias para que se resolva um type (base type):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o base type deste type não for inexistente, cancele.
Encontre o base type deste type usando o base name deste type e o catálogo de tipos.
Se o base type deste type for inexistente, apresente uma mensagem de erro contendo "Base type inválido:'" then o base name deste type then "." e o locus deste type; exit.
Ligue o cooking alarme deste type.
Se o cooking alarme deste base type deste type estiver ativo, apresente a mensagem de erro contendo "Definição recursiva com: " then o base name deste type then "." e o locus deste type; exit.
Resolva o base type deste type (base type).
Desative o cooking alarme deste type.

Etapas necessárias para que se resolva um type (expand coisa): \ base type deste type não está resolved yet
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o base type deste type não for inexistente, cancele.
Se o name deste type for "coisa", cancele.
\Se o name deste type for "elemento", cancele.
Se o type não puder ser reduzido para "coisa" using o base name, cancele.
Encontre um base type usando o base name deste type e o catálogo de tipos.
\ adicione coisa conjunto - o número of secret campos é hard coded em two places: search por "du que 4" \ was 6
Atribua o name deste type then " conjunto" into um name.
Atribua o name deste type then " conjuntos" into um plural name.
Atribua o name deste base type then " conjunto" into um base name.
Adicione um conjunto type para o types usando o name e o plural name e o base name.
Adicione um campo para os campos deste conjunto type usando "next " then o name deste type e "next" e o name deste type e o alarme de ignição.
\PAL
Adicione um portuguese campo para os campos deste conjunto type usando "seguinte " then o name deste type e "seguinte" e o name deste type e o alarme de ignição.
Atribua "next " then o name deste type ao redefinition target name deste portuguese campo.
\Adicione um portuguese reverse campo para os campos deste conjunto type usando o name deste type then " seguinte" e "seguinte" e o name deste type e o alarme de ignição.
\Atribua "next " then o name deste type ao redefinition target name deste portuguese reverse campo.
Adicione another campo para os campos deste conjunto type usando "previous " then o name deste type e "previous" e o name deste type e o alarme de ignição.
\Adicione another portuguese campo para os campos deste conjunto type usando "anterior " then o name deste type e "anterior" e o name deste type e o alarme de ignição.
\Atribua "previous " then o name deste type ao redefinition target name deste other portuguese campo.
Adicione another portuguese reverse campo para os campos deste conjunto type usando o name deste type then " anterior" e "anterior" e o name deste type e o alarme de ignição.
Atribua "previous " then o name deste type ao redefinition target name deste other portuguese reverse campo.
Se os campos deste type não estiverem vazio, posponha os campos deste type para os campos deste conjunto type.
Catalogue o conjunto type.
\ fix up original type para look like um endereço de memória
Atribua o name deste conjunto type ao target name deste type.
\ adicione chain type
Adicione um chain type para o types usando o plural name deste type e "" e o plural name deste base type.
Adicione um terceiro campo para os campos deste chain type usando "first " then o name deste type e "first" e o name deste type e o alarme de ignição.
Adicione um terceiro portuguese campo para os campos deste chain type usando "primeiro " then o name deste type e "primeiro" e o name deste type e o alarme de ignição.
Atribua "first " then o name deste type ao redefinition target name deste terceiro portuguese campo.
Adicione um terceiro feminine portuguese campo para os campos deste chain type usando "primeira " then o name deste type e "primeira" e o name deste type e o alarme de ignição.
Atribua "first " then o name deste type ao redefinition target name deste terceiro feminine portuguese campo.
Adicione um fourth campo para os campos deste chain type usando "last " then o name deste type e "last" e o name deste type e o alarme de ignição.
Adicione um fourth portuguese campo para os campos deste chain type usando "último " then o name deste type e "último" e o name deste type e o alarme de ignição.
Atribua "last " then o name deste type ao redefinition target name deste fourth portuguese campo.
Adicione um fourth portuguese feminine campo para os campos deste chain type usando "última " then o name deste type e "última" e o name deste type e o alarme de ignição.
Atribua "last " then o name deste type ao redefinition target name deste fourth portuguese feminine campo.
Catalogue o chain type.

Etapas necessárias para que se resolva um type (registro de plurais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o plural name deste type estiver em branco, cancele.
Se o type puder ser reduzido para "coisa" using o base name, cancele.
Catalogue o type usando o plural name deste type.

Etapas necessárias para que se resolva um type (optional info - endereço de memória):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o target type deste type não for inexistente, cancele.
Se o target name deste type estiver em branco, atribua o target type deste base type deste type ao target type deste type; exit.
Encontre o target type deste type usando o target name deste type e o catálogo de tipos.
Se o target type deste type for inexistente, apresente uma mensagem de erro contendo "Não sei bem pra que coisa você está pointing at." e o locus deste type; exit.

Etapas necessárias para que se resolva um type (optional info - conjunto):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se os campos deste type estiverem vazio, copy os campos deste base type deste type a os campos deste type; exit.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um campo from os campos deste type (backwards).
Se o campo for inexistente, pare.
Se o campo estiver duplicated em os campos deste type, apresente uma mensagem de erro contendo "O campo: " then o name deste campo then "' está definido mais de uma vez." e o locus deste campo; exit.
Resolva o campo.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o cooking alarme deste type deste campo estiver ativo, apresente a mensagem de erro contendo "Recursive definition no: " then o name deste type deste campo then "." e o locus deste campo; exit.
Resolva o type deste campo (optional info). \ de novo
Se o reference alarme deste campo não estiver ativo, repita.
Se o type deste campo não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Não entendi o parâmetro '(reference)' nesse campo: " then o name deste campo then "'..." e o locus deste campo; exit.
Repita.
Eliminate duplicate nicknames from os campos deste type.
Se o type não puder ser reduzido para "coisa conjunto", cancele.
Se a contagem destes campos deste type for maior do que 4, cancele. \ already copied? was 2 por next e prev, now 6 para included Spanish redefiniions
Copy os campos deste base type deste type a os campos deste type (data campos only).

Etapas necessárias para que se resolva um type (optional info - scale):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Atribua o base type deste type into um base type.
Se a scale deste type for 0, atribua o scale deste base type deste type ao scale deste type; exit.
Se a scale deste base type for 0, cancele.
Multiplique o scale deste type pela scale deste base type.
Atribua o base type deste base type ao base type deste type.

Etapas necessárias para que se resolva um type (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o optional info resolved alarme deste type estiver ativo, cancele.
Se o base type deste type for o type, cancele. \ por built em types
Check por invalid optional info sobre o type.
Ligue o cooking alarme deste type.
Resolva o base type deste type (optional info).
Se o type puder ser reduzido para "endereço de memória", resolva o type (optional info - endereço de memória).
Se o type puder ser reduzido para "conjunto", resolva o type (optional info - conjunto). \ mudar aqui
Se o type puder ser reduzido para "número", resolva o type (optional info - scale).
Desative o cooking alarme deste type.
Ligue o optional info resolved alarme deste type.

Etapas necessárias para que se resolva alguns types (base types):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (base type).
Repita.

Etapas necessárias para que se resolva alguns types (expand coisas):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (expand coisa).
Repita.

Etapas necessárias para que se resolva alguns types (registro de plurais):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (registro de plurais).
Repita.

Etapas necessárias para que se resolva alguns types (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (optional info).
Repita.

Etapas necessárias para que se resolva uma variable:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o variable for inexistente, cancele.
Se a type desta variable não for inexistente, cancele.
Se o type name desta variable não estiver em branco, resolva o variable (explicit type name); exit.
Encontre o type desta variable e o nickname desta variable usando o name desta variable.
Se o type desta variable não for inexistente, atribua o name deste type desta variable ao type name desta variable; exit.
Apresente uma mensagem de erro contendo "Não achei o tipo da variável: " then o name desta variable then "." e o locus desta variable.

Etapas necessárias para que se resolva uma variable (explicit type name):
Encontre o type desta variable usando o type name desta variable e o catálogo de tipos.
Se o type desta variable for inexistente, apresente uma mensagem de erro contendo "Não achei o nome do tipo da variável: " then o type name desta variable then "." e o locus desta variable; exit.

O resolving globals cronômetro é um cronômetro.

O resolving types cronômetro é um cronômetro.

Etapas necessárias para que se round up zona sizes:
Atribua o length desta import zona ao size desta import zona.
Round o size desta import zona up para o nearest multiple of 4096.
Atribua o length desta zona de dados ao size desta zona de dados.
Round o size desta zona de dados up para o nearest multiple of 4096.
Atribua o length desta code zona ao size desta code zona.
Round o size desta code zona up para o nearest multiple of 4096.

O routine address tag é uma tag igual a 22.

An instruções é um subtexto.

Um routine header é um subtexto.

O catálogo geral de rotinas é um index.

Um routine é uma coisa with
Um locus (reference),
Um callback alarme,
Um decider alarme,
Um function alarme,
Um compiled alarme,
Um nickname index,
Um moniker, alguns monikettes, alguns parameters, um parameter size,
Um employs moniker,
Some locals, um local size,
Um routine header, um header string,
Um instruções, um body string,
Some fragments,
Um address.

Um routine reference é alguns monikettes.

O routines são algumas routines.

O save eax tag é uma tag igual a 20.

Etapas necessárias para que se examine any optional info por um type usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for "to", examine any optional info pelo type usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for "para", examine any optional info pelo type usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for any with, examine any optional info pelo type usando o percorredor (conjunto); exit.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (endereço de memória):
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, apresente uma mensagem de erro contendo "A palavra 'to' precisa de um artigo indefinido depois dela, não de um: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o target name deste type usando o percorredor.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (conjunto):
Mova o percorredor (compilador rules).
Examine o campos deste type usando o percorredor.

Etapas necessárias para que se examine any pauses usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any pause, cancele.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um campo usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Examine o campo usando o percorredor (type part).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any called, examine o campo usando o percorredor (called part); repita.
Se o token deste percorredor for "at", examine o campo usando o percorredor (redefine part); repita.
Se o token deste percorredor for "em", examine o campo usando o percorredor (redefine part); repita.
Se o token deste percorredor for "redefinindo", examine o campo usando o percorredor (redefine part); repita.
Se o token deste percorredor for any reference, examine o campo usando o percorredor (reference part); repita.

Etapas necessárias para que se examine um campo usando um percorredor (called part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o type name deste campo estiver em branco, atribua o name deste campo ao type name deste campo. \ pedaço array type name already filled in
Examine o name deste campo usando o percorredor.

Etapas necessárias para que se examine um campo usando um percorredor (redefine part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo definido, apresente uma mensagem de erro contendo "Eu estava esperando o artigo 'the', mas o que encontrei foi: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o redefinition target name deste campo usando o percorredor.

Etapas necessárias para que se examine um campo usando um percorredor (reference part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Ligue o reference alarme deste campo.

Etapas necessárias para que se examine um campo usando um percorredor (type part - pedaço array):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor para um ratio.
Reduce o ratio.
Se o denominador desta ratio não for 1, apresente uma mensagem de erro contendo "Você tem que especificar um número completo de pedaços para um pedaço array" e o percorredor; exit.
Atribua o numerador desta ratio ao contagem deste campo.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for "pedaço" ou "pedaços", apresente a mensagem de erro contendo "Você precisa usar a palavra 'pedaços' depois de um counted campo designador." e o percorredor; exit.
Mova o percorredor (compilador rules).
Atribua "pedaço" ao type name deste campo.

Etapas necessárias para que se examine um campo usando um percorredor (type part - normal):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any artigo indefinido, apresente uma mensagem de erro contendo "Falta por um artigo idefinido aqui, mas você colocou isso:: " then o token deste percorredor then "." e o percorredor; exit.
Se o token deste percorredor for "another", atribua "other" ao name deste campo.
\PAL
Se o token deste percorredor for "outra", atribua "segunda" ao name deste campo.
Se o token deste percorredor for "outro", atribua "segundo" ao name deste campo.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Extend o name deste campo with o name.

Etapas necessárias para que se examine um campo usando um percorredor (type part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any numeric literal, examine o campo usando o percorredor (type part - pedaço array); exit.
Examine o campo usando o percorredor (type part - normal).

Etapas necessárias para que se examine alguns campos usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione um campo para o campos usando "campo" e o first deste token deste percorredor.
Examine o campo usando o percorredor.
Se o token deste percorredor não for any pause, cancele.
Examine any pauses usando o percorredor.
Repita.

Etapas necessárias para que se examine um global body usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Atribua o first deste token deste percorredor ao first deste global body.
Atribua -1 ao last deste global body.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o sinal de dois pontos, cancele.
Se o token deste percorredor for o ponto final, cancele.
Atribua o last deste token deste percorredor ao last deste global body.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um global usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione o global para o globals usando "global" e o first deste token deste percorredor.
Mova o percorredor (compilador rules).
Examine o name deste global usando o percorredor.
Se o token deste percorredor for any has, examine o global usando o percorredor (has ou have); exit.
Se o token deste percorredor não for any is, apresente uma mensagem de erro contendo "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, examine o global usando o percorredor (literal term); exit.
Mova o percorredor (compilador rules).
Examine o type name deste global usando o percorredor.
Se o token deste percorredor for o start of any optional info, examine o global usando o percorredor (optional info); exit.
Se o token deste percorredor for any operador de atribuição, examine o global usando o percorredor (data part); exit.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Toda definição precisa terminar com um ponto. Inclusive essa." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (data part):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any to, apresente uma mensagem de erro contendo "Depois da palavra 'equal' você precisa por um palavra 'to'. Você colocou;: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o global body deste global usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Falta terminar um frase com um ponto." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (has ou have):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Atribua "~inline " then o name deste global then " type" into um name.
Atribua o name then "s" into um plural name.
Adicione um type para os types usando o name e o plural name e "conjunto" e o locus deste global. \mudar aqui
Catalogue o type.
Atribua o name deste type ao type name deste global.
Examine os campos deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Aprenda a escrever direito. Cadê o ponto?." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (literal term):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Examine o global body deste global usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Aprenda a escrever corretamente. Cadê o ponto final?." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (optional info):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Atribua "~inline " then o name deste global then " type" into um name.
Atribua o name then "s" into um plural name.
Adicione um type para o types usando o name e o plural name e o type name deste global e o locus deste global.
Catalogue o type.
Atribua o name deste type ao type name deste global.
Examine any optional info pelo type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Tá na hora de aprender a escrever direito. Cadê o ponto?." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o global.

Etapas necessárias para que se examine um name usando um percorredor:
Limpe o name.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor estiver sobre any name starter, extend o name with o token deste percorredor; mova o percorredor (compilador rules).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o percorredor estiver sobre any name ender, pare.
Extend o name with o token deste percorredor.
Mova o percorredor (compilador rules).
Repita.
Se o name estiver em branco, apresente uma mensagem de erro contendo "Acho que faltou colocar um nome por aqui. Você escreveu: " then o token deste percorredor then "." e o percorredor; exit.

Etapas necessárias para que se examine uma instruções usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o start of any definition, cancele.
Atribua o first deste token deste percorredor ao first destas instruções.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Atribua o last deste token deste percorredor ao last destas instruções.
Se o token deste percorredor for o sinal de dois pontos, apresente uma mensagem de erro contendo "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e o percorredor; exit.
Se o token deste percorredor não for o ponto final, mova o percorredor (compilador rules); repita.
Mova o percorredor (compilador rules).
Se o token deste percorredor for o start of any definition, cancele.
Repita.

Etapas necessárias para que se examine uma routine usando um percorredor:
\ Define o cabeçalho de rotina.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Adicione a routine para a routines usando o first deste token deste percorredor.
Mova o percorredor (compilador rules). \ skip o "Passos" e obtenha o next token
Se o token deste percorredor for "necessários" ou "necessárias", mova o percorredor (compilador rules).
Se o token deste percorredor não for "para", apresente uma mensagem de erro contendo "Você precisa escrever 'para' antes de: " then o token deste percorredor then "' nesse tipo de rotina." e o percorredor; exit.
Mova o percorredor (compilador rules). \ skip o "para" e obtenha o next token
Se o token deste percorredor for "que", mova o percorredor (compilador rules).
\Se o token deste percorredor não for "que", apresente uma mensagem de erro contendo "Você precisa colocar um 'que' antes da palavra: " then o token deste percorredor then "." e o percorredor; exit.
\Mova o percorredor (compilador rules). \ skip o "que" e obtenha o next token
Se o token deste percorredor for "se", mova o percorredor (compilador rules).
\Se o token deste percorredor não for "se", apresente uma mensagem de erro contendo "Você precisa colocar um 'se' antes da palavra: " then o token deste percorredor then "." e o percorredor; exit.
\Mova o percorredor (compilador rules). \ skip o "se" e obtenha o next token
Examine a routine header desta routine usando o percorredor.
Se o token deste percorredor for o ponto&vírgula, examine a routine usando o percorredor (alternate palavraing); exit. \ *** por alternate palavraings
Se o token deste percorredor não for o sinal de dois pontos, apresente a mensagem de erro contendo "O nome dessa função está escrito errado.." e o locus desta routine; exit.
Mova o percorredor (compilador rules).
Examine as instruções desta routine usando o percorredor.

Etapas necessárias para que se examine uma routine usando um percorredor (alternate palavraing):
\ *** por alternate palavraings
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for o start of any routine, apresente uma mensagem de erro contendo "Esse ponto e vírgula tá no lugar errado." e o original percorredor; exit.
Atribua o first deste token deste original percorredor ao first destas instruções desta routine.
Atribua o last deste token deste original percorredor ao last destas instruções desta routine.
Mova o original percorredor (compilador rules).

Etapas necessárias para que se examine uma routine header usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Atribua o first deste token deste percorredor ao first deste routine header.
Atribua -1 ao last deste routine header.
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o ponto&vírgula, cancele. \ *** alternate palavraings
Se o token deste percorredor for o sinal de dois pontos, cancele.
Se o token deste percorredor for o ponto final, cancele.
Atribua o last deste token deste percorredor ao last deste routine header.
Mova o percorredor (compilador rules).
Repita.

Etapas necessárias para que se examine um source file:
Se o source file for inexistente, cancele.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Lance um percorredor sobre o trecho deste source file.
Mova o percorredor (compilador rules).
Percorra.
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o start of any type, examine um type usando o percorredor; repita.
Se o token deste percorredor for o start of any global, examine um global usando o percorredor; repita.
Se o token deste percorredor for o start of any routine, examine uma routine usando o percorredor; repita.
Apresente uma mensagem de erro contendo "Faltou definir melhor o que é o: " then o token deste percorredor then "." e o percorredor.
Repita.

Etapas necessárias para que se examine alguns source files:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um source file from o source files.
Se o source file for inexistente, cancele.
Examine o source file.
Repita.

Etapas necessárias para que se examine um type usando um percorredor:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o token deste percorredor for any artigo indefinido português, acione um portuguese alarme.
Se o token deste percorredor for any artigo indefinido inglês, acione um english alarme.
Adicione o type para o types usando o first deste token deste percorredor.
Mova o percorredor (compilador rules).
Examine o name deste type usando o percorredor.
Atribua o name deste type ao plural name deste type.
Se o portuguese alarme estiver ativo, pluralize o plural name deste type (portuguese rules).
Se o english alarme estiver ativo, pluralize o plural name deste type (english rules).
Se o english alarme não estiver ativo, pluralize o plural name deste type (portuguese rules).
Se o token deste percorredor for any has, examine o type usando o percorredor (has ou have); exit.
Se o token deste percorredor não for any is, apresente uma mensagem de erro contendo "Eu esperava um 'is' ou um 'are', mas só achei um :: " then o token deste percorredor then "." e o percorredor; exit.
\Pluralize o plural name deste type.
\Se o token deste percorredor for "has" ou "have", examine o type usando o percorredor (has ou have); exit.
\Se o token deste percorredor não for "is" ou "are", apresente uma mensagem de erro contendo "I was expecting um 'is' ou 'are', but I found: " then o token deste percorredor then "." e o percorredor; exit.

Mova o percorredor (compilador rules).
Se o token deste percorredor for any numeric literal, examine o type usando o percorredor (unit of measure); exit.
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Faltou um artigo indefinido, lembra?: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Examine o base name deste type usando o percorredor.
Examine any optional info pelo type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você precisa usar um ponto para definir um tipo, lembra? Você usou: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (has ou have):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Mova o percorredor (compilador rules).
Atribua "conjunto" ao base name deste type. \\mudar aqui
Examine o campos deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Ao invés de usar o ponto para definir tipo, você usou: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (unit of measure):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Convert o token deste percorredor para o scale deste type.
Se o scale deste type for 0, apresente uma mensagem de erro contendo "Zero é um tipo de escala inválido." e o locus deste type; exit.
Mova o percorredor (compilador rules).
Examine o base name deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Os tipos precisam terminar com um ponto, não com: " then o token deste percorredor then "." e o percorredor; exit.
Mova o percorredor (compilador rules).
Catalogue o type.

O scanning cronômetro é um cronômetro.

Um scratch é um local.

Etapas necessárias para que se scrub um index:
Obtenha um bucket usando o index.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Scrub os refers deste bucket.
Repita.

Etapas necessárias para que se scrub alguns refers:
Swap o refers with alguns other refers.
Percorra.
Atribua o first destes other refers into um refer.
Se o refer for inexistente, cancele.
Remove o refer from o other refers.
Se o endereço de memória deste refer for inexistente, destroy o refer; repita.
Posponha o refer para os refers.
Repita.

Etapas necessárias para que se ative o compiled alarme em uma variable;
Etapas necessárias para que se ligue o compiled alarme em uma variable:
Se o variable for inexistente, cancele.
Se o compiled alarme desta variable [já] estiver ativo, cancele.
Ligue o compiled alarme desta variable.
Se a categoria desta variable não for "global", cancele.
Se o literal desta variable for inexistente, cancele.
Encontre uma routine usando "atribua" e o type deste literal desta variable e "into" e o type desta variable.
Se a routine for inexistente, encontre a routine usando "convert" e o type deste literal desta variable e "to" e o type desta variable; acione um alarme.
Se a routine for inexistente, apresente uma mensagem de erro contendo "O tipo dessa variável global e desse literal não são compatíveis." e o locus desta variable; exit.
Compile o body of a routine.
Se o alarme estiver ativo, atribua "convert o " then o name deste literal desta variable then " para o " then o name desta variable then ". " ao initializer string desta variable.
Se o alarme não estiver ativo, atribua "atribua o " then o name deste literal desta variable then " a o " then o name desta variable then ". " ao initializer string desta variable. \ NÃO PODE MUDAR O " a o " não sei o porquê

Etapas necessárias para que se skip para o next palavra em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for noise, pare.
Adicione 1 para o first deste subtexto.
Repita.
Skip any leading noise no subtexto.

Etapas necessárias para que se skip para o previous palavra em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste last deste subtexto for noise, pare.
Subtraia 1 from o last deste subtexto.
Repita.
Skip any trailing noise no subtexto.

An source file é uma coisa with um endereço completo e um trecho.

O source files são alguns source files.

Um tag é um número.

Um term é um conjunto with uma variable e um phrase.

Etapas necessárias para que se transmogrify um fragment:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Se a tag deste fragment for o push address tag, transmogrify o fragment (push address); exit.
Se a tag deste fragment for o call internal tag, transmogrify o fragment (call internal); exit.
Se a tag deste fragment for o load address tag, transmogrify o fragment (load address); exit.
Se a tag deste fragment for o increment tag, transmogrify o fragment (increment); exit.
Se a tag deste fragment for o dereference tag, transmogrify o fragment (dereference); exit.
Se a tag deste fragment for o jump false tag, transmogrify o fragment (jump false); exit.
Se a tag deste fragment for o not tag, transmogrify o fragment (not); exit.
Se a tag deste fragment for o exit tag, transmogrify o fragment (exit); exit.
Se a tag deste fragment for o repeat tag, transmogrify o fragment (repeat); exit.
Se a tag deste fragment for o break tag, transmogrify o fragment (break); exit.
Se a tag deste fragment for o prolog tag, transmogrify o fragment (prolog); exit.
Se a tag deste fragment for o epilog tag, transmogrify o fragment (epilog); exit.
Se a tag deste fragment for o push value tag, transmogrify o fragment (push value); exit.
Se a tag deste fragment for o call external tag, transmogrify o fragment (call external); exit.
Se a tag deste fragment for o load eax tag, transmogrify o fragment (load eax); exit.
Se a tag deste fragment for o save eax tag, transmogrify o fragment (save eax); exit.
Se a tag deste fragment for o call indirect tag, transmogrify o fragment (call indirect); exit.
Se a tag deste fragment for a routine address tag, transmogrify o fragment (routine address); exit.

Etapas necessárias para que se transmogrify um fragment (break):
Atribua o repeat tag into uma tag.
Encontre another fragment usando o fragment e o tag.
Se o other fragment for inexistente, atribua o finalize tag ao tag. \ por break sem um loop ou after um loop
Encontre um terceiro fragment usando o last deste fragments desta rotina utilizada atualmente e o tag (backwards).
Se o terceiro fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (break)"; exit.
Se o next deste terceiro fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 e o address deste next deste terceiro fragment para o fragment. \ JMP o address da destination

Etapas necessárias para que se transmogrify um fragment (call external):
Attach $FF15 e o address desta entry deste fragment para o code deste fragment. \ call [o address desta entry deste fragment ]

Etapas necessárias para que se transmogrify um fragment (call indirect):
Attach address loading code para o code deste fragment usando o variable deste fragment. \ coloca address into edx
Attach $FF12 para o code deste fragment. \ call [edx]

Etapas necessárias para que se transmogrify um fragment (call internal):
Obtenha um address usando o routine deste fragment.
Attach $E8 e o address para o fragment. \ call o address da routine do fragment 

Etapas necessárias para que se transmogrify um fragment (dereference):
Attach $8B95 e o offset desta variable deste fragment para o code deste fragment. \ mov edx,[ebp+ o offset desta variable deste fragment]
Attach $8B12 para o code deste fragment. \ mov edx,[edx]
Attach $8995 e o offset desta variable deste fragment para o code deste fragment. \ mov [ebp+ o offset desta variable deste fragment]

Etapas necessárias para que se transmogrify um fragment (epilog):
Se o callback alarme desta rotina utilizada atualmente estiver ativo, attach $5F5E5B para o code deste fragment. \ pop edi, esi, ebx
Attach $8BE5 para o code deste fragment. \ mov esp,ebp
Attach $5D para o code deste fragment. \ pop ebp
Attach $C2 e o parameter size desta rotina utilizada atualmente para o code deste fragment. \ ret o parameter size da rotina utilizada atualmente

Etapas necessárias para que se transmogrify um fragment (exit):
Encontre another fragment usando o fragment e o finalize tag.
Se o other fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 e o address deste other fragment para o fragment. \ jmp o address da destination

Etapas necessárias para que se transmogrify um fragment (increment):
Se a variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (increment)"; exit.
Se a categoria desta variable deste fragment não for "scratch", apresente a mensagem de erro contendo "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 e o offset desta variable deste fragment e o número deste fragment para o code deste fragment. \ add [ebp+ o offset desta variable deste fragment], o número deste fragment

Etapas necessárias para que se transmogrify um fragment (jump false):
Encontre another fragment usando o fragment e o end if tag.
Se o other fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 para o code deste fragment. \ cmp eax,0
Attach $0F84 e o address deste other fragment para o fragment. \ je o address da destination

Etapas necessárias para que se transmogrify um fragment (load address):
Attach address loading code para o code deste fragment usando a variable deste fragment. \ atribua address into edx
Attach $8995 e o offset desta other variable deste fragment para o code deste fragment. \ mov [ebp+ o offset desta variable deste fragment],edx

\Etapas necessárias para que se transmogrify um fragment (load eax):
\Attach address loading code para o code deste fragment usando a variable deste fragment. \ atribua address into edx
\Se a variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro - transmogrify um fragment (load eax)"; exit.
\Se o type desta variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transmogrify um fragment (load eax)"; exit.
\Se o length deste type desta variable deste fragment não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 para o code deste fragment. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (load eax):
Attach $B8 e o alarme deste fragment para o code deste fragment. \ mov eax,alarme
\Attach address loading code para o code deste fragment usando a variable do fragment. \ atribua address into edx
\Se a variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro - transmogrify um fragment (load eax)"; exit.
\Se o type desta variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transmogrify um fragment (load eax)"; exit.
\Se o length deste type desta variable deste fragment não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 para o code deste fragment. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (not):
Attach $83F001 para o code deste fragment. \ xor eax,1

Etapas necessárias para que se transmogrify um fragment (prolog):
Attach $55 para o code deste fragment. \ push ebp
Attach $8BEC para o code deste fragment. \ mov ebp,esp
Atribua o local size desta rotina utilizada atualmente dividido por 4 into um número.
Se o número não for 0, attach $B9 e o número e $6A004975FB para o code deste fragment. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
Se o callback alarme desta rotina utilizada atualmente estiver ativo, attach $535657 para o code deste fragment. \ push ebx, esi, edi

Etapas necessárias para que se transmogrify um fragment (push address):
Attach address loading code para o code deste fragment usando a variable deste fragment. \ atribua address into edx
Attach $52 para o code deste fragment. \ push edx

Etapas necessárias para que se transmogrify um fragment (push value):
Attach address loading code para o code deste fragment usando a variable deste fragment. \ atribua address into edx
Se a variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (push value)"; exit.
Se o type desta variable deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Atribua o length deste type desta variable deste fragment into um length.
Se o length for 4, attach $FF32 para o code deste fragment; exit. \ push [edx]
Se o length for 2, attach $66FF32 para o code deste fragment; exit. \ push palavra ptr [edx]
Se o length for 1, attach $0FB61252 para o code deste fragment; exit. \ movzxb edx,[edx]; push edx
Apresente a mensagem de erro contendo "Erro interno 3 - transmogrify um fragment (push value)".

Etapas necessárias para que se transmogrify um fragment (repeat):
Encontre another fragment usando o fragment e o loop tag (backwards).
Se o other fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 e o address deste other fragment para o fragment. \ jmp o address da destination 

Etapas necessárias para que se transmogrify um fragment (routine address):
Attach address loading code para o code deste fragment usando a variable deste fragment. \ atribua address into edx
Se a routine deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (routine address)"; exit.
Obtenha um address usando a routine deste fragment.
Attach $C702 e o address para o code deste fragment. \ mov [edx],the address

Etapas necessárias para que se transmogrify um fragment (save eax):
Attach address loading code para o code deste fragment usando a variable deste fragment. \ atribua address into edx
Se a variable deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (save eax)"; exit.
Se o type desta variable deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Atribua o length deste type desta variable deste fragment into um length.
Se o length for 4, attach $8902 para o code deste fragment; exit. \ mov [edx],eax
Se o length for 2, attach $668902 para o code deste fragment; exit. \ mov [edx],ax
Se o length for 1, attach $8802 para o code deste fragment; exit. \ mov [edx],al
Apresente a mensagem de erro contendo "Erro interno 3 - transmogrify um fragment (save eax)".

Etapas necessárias para que se transmogrify alguns fragments:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Transmogrify o fragment.
Repita.

Etapas necessárias para que se transmogrify uma routine:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o employs moniker desta routine não estiver em branco, cancele.
Se o compiled alarme desta routine não estiver ativo, cancele.
Atribua a routine à rotina utilizada atualmente.
Transmogrify os fragments desta routine.

Etapas necessárias para que se transmogrify alguns routines:
Se o alarme de alerta deste compilador estiver ativado, cancele.
Obtenha uma routine from a routines.
Se a routine for inexistente, pare.
Transmogrify a routine.
Repita.

O transmogrifying cronômetro é um cronômetro.

O catálogo de tipos é um index.

Um type é uma coisa with
Um locus (reference),
Um name, um plural name,
Um partial moniker,
Um length,
Um base name, um base type (reference),
Um target name, um target type (reference) [endereço de memórias only],
Um scale ratio,
Some campos [records only],
Um cooking alarme,
Um optional info resolved alarme.

Um type name é um name.

O types são alguns types.

O catálogo de rotinas úteis é um index.

Um variable é uma coisa with
Um locus (reference),
Um categoria [literal, global, local, parameter, scratch],
Um compiled alarme,
Um name, um nickname, um type name,
Um type (reference), \ actual type sobre literal, global, local; dereferenced type sobre parameters e scratches
Um address [globals e literals only] ou 
Um offset at o address [locals, parameters, e campos only],
Um contagem [campos only],
Um reference alarme [campos only],
Um redefinition target name [campos only],
Um by-value alarme [parameters only],
Um global body [globals only],
Um initializer string [globals only],
Um literal (reference) [globals only - constant with which para initalize o global],
Um texto hexadecimal called data [literals only].

O writing cronômetro é um cronômetro.

Etapas necessárias para que se skip any trailing noise em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste last deste subtexto não for noise, cancele.
Subtraia 1 from o last deste subtexto.
Repita.

\ dahn - reverse functions
\ para put o xxx uv a/the yyy into zzz
\ internally we turn this into "to put a/the yyy's xxx into zzz"
Etapas necessárias para que se compile o header of uma routine usando um percorredor (reverse-possessive function):
Se o alarme de alerta deste compilador estiver ativado, cancele.
Ligue o function alarme desta routine.
Adicione um monikette para os monikettes desta routine usando "atribua".
Mova o percorredor (compilador rules). \ skip "atribua" ou "poner"
Mova o percorredor (compilador rules). \ skip "the" ou Portuguese artigo definido
Examine um name usando o percorredor. \ campo name
Mova o percorredor (compilador rules). \ skip "uv" ou "de"
Se o token deste percorredor for any artigo indefinido, acione um alarme.
Se o alarme estiver ativo, compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo indefinido).
Se o alarme não estiver ativo, compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo definido).
Adicione another monikette para os monikettes desta routine usando "'s " then o name.
Se o token deste percorredor não for any reverse-possessive function into, apresente uma mensagem de erro contendo "Esperava a palavra 'em', mas encontrei: " then o token deste percorredor then "." e o percorredor; exit.
Adicione um terceiro monikette para os monikettes desta routine usando "into".
Convert os monikettes desta routine para um moniker.
Se o moniker estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Já sei como: " then o moniker then "." e o locus desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Esperava um artigo indefinido, mas encontrei: " then o token deste percorredor then "." e o percorredor; exit.
Compile os monikettes desta routine e o parameters desta routine usando o percorredor (artigo indefinido).
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Existem outras coisas no final desta função." e o percorredor; exit.
Convert os monikettes desta routine para o moniker desta routine.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas. \ por employs

\ dahn - reverse functions
\ para atribua o xxx uv a/the yyy into zzz
Etapas necessárias para que se determine se um percorredor é o start of any reverse-possessive function:
Se o alarme de alerta deste compilador estiver ativo, diga não.
Se o token deste percorredor não for any atribua, diga não.
Isole o percorredor.
Mova o percorredor (compilador rules).
Se o token deste percorredor não for any artigo definido, diga não.
Mova o percorredor (compilador rules).
Examine um name usando o percorredor.
Se o percorredor não for sobre any reverse-possessive, diga não.
Diga sim.
\finalmente