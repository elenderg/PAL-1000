\ (o cérebro) copyright © 2019, 2020, 2021 the osmosian order, Ramon Dellaqia, Elender Gois e Walter Júnior.

\ aqui estão as regras de texto:
\ em um texto não quebrado, as linhas terminam com um byte de retorno.
\ em um texto quebrado, as linhas terminam com um byte de retorno ou um espaço.
\ quando o texto é convertido em uma string, bytes de alimentação de linha são adicionados após os bytes de retorno.
\ quando uma string é convertida em texto, os bytes de alimentação de linha são removidos.
\ sempre há pelo menos uma linha.
\ há sempre um byte de retorno no final da última linha.

The on flag is a_ flag equal to 1.

The off flag is a_ flag equal to 0.

The a-key is a_ key equal to 65.

An abc is a_ record with a_ number called abca, a_ number called abcb, a_ number called abcc.

An abc pointer is a_ pointer to an abc.

An abca is a_ number.  

An abcc is a_ number.

An absolute position is a_ number.

The accent byte is a_ byte equal to 96.

The accent key is a_ key equal to 192.

The acknowledge byte is a_ byte equal to 6.

The acute-accent byte is a_ byte equal to 180.

\PAL
Para adicionar um byte a outro byte;
\CAL
To add a_ byte to another byte:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other byte
Intel $0003. \ add [ebx],al

\PAL
Para adicionar um byte a um número;
\CAL
To add a_ byte to a_ number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
Intel $0103. \ add [ebx],eax

\PAL
Para adicionar uma fração a outra fração;
\CAL
To add a_ fraction to another fraction:
Privatize the fraction.
Normalize the fraction and the other fraction.
Add the fraction's numerator to the other fraction's numerator.
Reduce the other fraction.

\PAL
Para adicionar alguns twips horizontais e alguns twips verticais ao loco atual;
\CAL
To add some horizontal twips and some vertical twips to the current spot:
Add the horizontal twips to the context's spot's x-coord.
Add the vertical twips to the context's spot's y-coord.

\PAL
Para adicionar uma reta a uma figura;
\CAL
To add a_ line to a_ figure:
If the figure is nil, create the figure; append the figure to the figures.
Add the line's start to the figure.
Add the line's end to the figure.

\PAL
Para adicionar um nome a algumas escolhas;
\CAL
To add a_ name to some choices:
Allocate memory for_ a_ choice.
Put the name into the choice's name.
Put the choice at the end of the choices.

\PAL
Para adicionar um número e outro número a um par;
\CAL
To add a_ number and another number to a_ pair:
Add the number to the pair's x-number.
Add the other number to the pair's y-number.

\PAL
Para adicionar um número a outro número e um terceiro número a um quarto número;
\CAL
To add a_ number to another number and a_ third number to a_ fourth number:
Add the number to the other number.
Add the third number to the fourth number.

\PAL
Para adicionar um número a um byte;
\CAL
To add a_ number to a_ byte:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
Intel $0FB60B. \ movzx ecx,[ebx]
Intel $03C8. \ add ecx,eax
Intel $880B. \ mov [ebx],cl

\PAL
Para adicionar um número a uma fração;
\CAL
To add a_ number to a_ fraction:
Add the number / 1 to the fraction.

\PAL
Para adicionar um número a um par;
\CAL
To add a_ number to a_ pair:
Add the number to the pair's x-number.
Add the number to the pair's y-number.

\PAL
Para adicionar um número a um ponteiro;
Para adicionar um número a outro número;
\CAL
To add a_ number to a_ pointer;
To add a_ number to another number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
Intel $0103. \ add [ebx],eax

\PAL
Para adicionar um par a outro par;
\CAL
To add a_ pair to another pair:
Add the pair's x-number to the other pair's x-number.
Add the pair's y-number to the other pair's y-number.

To add a_ pdf object given a_ kind:
Create the pdf object given the kind.
Append the pdf object to the pdf state's objects.
Add 1 to the pdf state's object number.
Put the pdf state's object number into the pdf object's number.

\PAL
Para adicionar uma quora a um terminal;
\CAL
To add a_ quora to a_ terminal:
Create the quora.
Append the quora to the terminal's quoras.
If the terminal is not full, exit.
Put the terminal's quoras' first into a_ doomed quora.
Remove the doomed quora from the terminal's quoras.
Destroy the doomed quora.

\PAL
Para adicionar um loco a uma figura;
\CAL
To add a_ spot to a_ figure:
append the spot to the figure.

\PAL
Para adicionar uma sequência a alguns elementos de sequências;
\CAL
To add a_ string to some string things:
Create a_ string thing given the string.
Append the string thing to the string things.

An addrinfo is a_ record with
a_ number called ai_flags,
a_ number called ai_family,
a_ number called ai_sockettype,
a_ number called ai_protocol,
a_ number called ai_addrlen,
a_ pchar called ai_canonname,
a_ sockaddrptr called ai_addr,
a_ addrinfoptr called ai_next.

Some addrinfo routines is a_ record with
a_ getaddrinfo pointer,
a_ freeaddrinfo pointer.

An addrinfoptr is a_ pointer to an addrinfo.

\PAL
Para ajustar uma caixa dado um número e outro número e um terceiro número e um quarto número;
\CAL
To adjust a_ box given a_ number and another number and a_ third number and a_ fourth number:
Add the number to the box's left.
Add the other number to the box's top.
Add the third number to the box's right.
Add the fourth number to the box's bottom.

\PAL
Para ajustar um item;
\CAL
To adjust an item:
Put the item's win32finddata's dwfileattributes into a_ number.
Bitwise and the number with 16 [file_attribute_directory].
If the number is 0, put "file" into the item's kind; put "arquivo" into the item's tipo.
If the number is not 0, put "directory" into the item's kind; put "pasta" into the item's tipo.
Convert the item's win32finddata's ftcreationtime to the item's creation date/time string. \ added for email sorting
Put the item's win32finddata's cfilename's whereabouts into a_ pchar.
Convert the pchar to the item's designator.
If the item's kind is "directory", append "\" to the item's designator.
Put the item's directory then the item's designator into the item's path.
Extract the item's extension from the item's designator as_ a_ path.
Put the item's win32finddata's nfilesizelow into the item's size.
If the item's designator's first's target is not the period byte, exit.
Get the item (not first time).

\PAL
Para ajustar uma reta com um número e outro número e um terceiro número e um quarto número;
\CAL
To adjust a_ line with a_ number and another number and a_ third number and a_ fourth number:
Add the number to the line's start's x-coord.
Add the other number to the line's start's y-coord.
Add the third number to the line's end's x-coord.
Add the fourth number to the line's end's y-coord.

\PAL
Para ajustar uma imagem (extraindo caixas do gpbitmap);
\CAL
To adjust a_ picture (extract boxes from gpbitmap):
If the picture is nil, exit.
Put 0 into the picture's box's left.
Put 0 into the picture's box's top.
Put the picture's gpbitmap's width minus 1 times the tpp into the picture's box's right.
Put the picture's gpbitmap's height minus 1 times the tpp into the picture's box's bottom.
Put the picture's box into the picture's uncropped box.

\PAL
Para ajustar o espaçamento dada uma sequência;
Para ajustar o espacejamento dada uma sequência;
\CAL
To adjust spacing given a_ string:
If the current canvas is not the printer canvas, exit.
Call "gdi32.dll" "SetTextCharacterExtra" with the printer canvas and 0.
Call "gdi32.dll" "GetCurrentObject" with the printer canvas and 6 [obj_font] returning a_ handle.
Call "gdi32.dll" "SelectObject" with the memory canvas and the handle.
Get a_ width given the string and the memory canvas.
Call "gdi32.dll" "SelectObject" with the memory canvas and the null hfont.
Get another width given the string and the printer canvas.
Put the width minus the other width divided by the string's length into a_ number.
Call "gdi32.dll" "SetTextCharacterExtra" with the printer canvas and the number.

\PAL
Para alinhar um texto dado um alinhamento;
\CAL
To align a_ text given an alignment:
Put the alignment into the text's alignment.

An alignment is a_ string [center, left, or right].

The alt key is a_ key equal to 18.

An amount is a_ number.

The ampersand byte is a_ byte equal to 38.

An anchor is a_ position.

An and-mask is a_ mask.

An angle is some precise degrees [0 to 3599].

\PAL
Para pospor um depósito a um arquivo;
\CAL
To append a_ buffer to a_ file:
Clear o erro de e/s.
Call "kernel32.dll" "SetFilePointer" with the file and 0 and 0 and 2 [file_end] returning a_ result number.
If the result number is -1, put "Error posicionando puntero de archivo." into o erro de e/s; exit.
Call "kernel32.dll" "WriteFile" with the file and the buffer's first and the buffer's length and a_ number's whereabouts and 0 returning the result number.
If the result number is 0, put "Error escribiendo archivo." into o erro de e/s; exit.

\PAL
Para pospor um byte a uma sequência;
\CAL
To append a_ byte to a_ string:
Put the string's length into a_ saved length.
Reassign the string's first given the string's length plus 1.
Put the string's first plus the saved length into the string's last.
Put the byte into the string's last's target.

\PAL
Para pospor um byte a uma sequência dado um contador;
\CAL
To append a_ byte to a_ string given a_ count:
Privatize the count.
Loop.
If the count is less than 1, exit.
Append the byte to the string.
Subtract 1 from the count.
Repeat.

\PAL
Para pospor uma signa a uma sequência;
\CAL
To append a_ flag to a_ string:
Convert the flag to another string.
Append the other string to the string.

\PAL
Para pospor uma fração a uma sequência;
\CAL
To append a_ fraction to a_ string:
Convert the fraction to another string.
Append the other string to the string.

\PAL
Para pospor um número a uma sequência;
\CAL
To append a_ number to a_ string:
Convert the number to another string.
Append the other string to the string.

\PAL
Para pospor um ponteiro a uma sequência;
\CAL
To append a_ pointer to a_ string:
Convert the pointer to another string.
Append the other string to the string.

\PAL
Para pospor um loco a um polígono;
\CAL
To append a_ spot to a_ polygon:
If the polygon is nil, exit.
Create a_ vertex given the spot.
Append the vertex to the polygon's vertices.

\PAL
Para pospor uma sequência a outra sequência;
\CAL
To append a_ string to another string:
If the string is blank, exit.
Put the string's length into a_ combined length.
Put the other string's length into a_ saved length.
Add the saved length to the combined length.
Reassign the other string's first given the combined length.
Put the other string's first plus the saved length into a_ pointer.
Copy bytes from the string's first to the pointer for_ the string's length.
Put the other string's first plus the combined length minus 1 into the other string's last.

\PAL
Para pospor uma sequência a outra sequência (manejando transparência de e-mail);
\CAL
To append a_ string to another string (handling email transparency):
If the string is blank, exit.
Slap a_ rider on the string.
Loop.
Move the rider (text file rules).
If the rider's token is blank, exit.
If the rider's token starts with ".", append "." to the other string.
Append the rider's token to the other string.
Repeat.

\PAL
Para pospor uma sequência a outra sequência dado um contador;
\CAL
To append a_ string to another string given a_ count:
Privatize the count.
Loop.
If the count is less than 1, exit.
Append the string to the other string.
Subtract 1 from the count.
Repeat.

To append a_ string to a_ pdf object: \ this guys adds CRLF
Append the string to the pdf object's data.
Append the crlf string to the pdf object's data.

To append a_ string to a_ pdf object without advancing:
Append the string to the pdf object's data.

\PAL
Para pospor alguns elementos a alguns outros elementos;
\CAL
To append some things to some other things:
Put the things' first into a_ thing.
If the thing is nil, exit.
Remove the thing from the things.
Append the thing to the other things.
Repeat.

\PAL
Para pospor um temporizador a uma sequência;
\CAL
To append a_ timer to a_ string:
Convert the timer to another string.
Append the other string to the string.

\PAL
Para pospor um vértice a um polígono;
\CAL
To append a_ vertex to a_ polygon:
If the polygon is nil, exit.
Append the vertex to the polygon's vertices.

\PAL
Para pospor uma coord-x e uma coord-y a um polígono;
Para pospor uma coordenada-x e uma coordenada-y a um polígono;
\CAL
To append an x-coord and a_ y-coord to a_ polygon:
If the polygon is nil, exit.
Create a_ vertex given the x-coord and the y-coord.
Append the vertex to the polygon's vertices.

\PAL
Para pospor zeros a uma sequência até que seu tamanho seja um número;
\CAL
To append zeros to a_ string until its length is a_ number:
If the string's length is greater than or equal to the number, exit.
Append "0" to the string.
Repeat.

The arrow cursor is a_ cursor.

\PAL
Para atribuir um ponteiro dado um contador de bytes;
\CAL
To assign a_ pointer given a_ byte count:
If the byte count is 0, void the pointer; exit.
Privatize the byte count.
Round the byte count up to the nearest power of two.
Call "kernel32.dll" "HeapAlloc" with the heap pointer and 8 [heap_zero_memory] and the byte count returning the pointer.
If the pointer is not nil, add 1 to the heap count; exit.

The asterisk byte is a_ byte equal to 42.

The at-sign byte is a_ byte equal to 64.

\PAL
Para auto rolar um texto dado um loco e uma signa;
\CAL
To autoscroll a_ text given a_ spot and a_ flag:
If the text is nil, clear the flag; exit.
Put the text's font's height into a_ number.
Clear a_ difference.
Put the text's box into a_ box.
Indent the box given the tpp.
If the spot's y-coord is less than the box's top, put the number into the difference's y-number.
If the spot's y-coord is greater than the box's bottom, put the number into the difference's y-number; negate the difference's y-number.
If the spot's x-coord is less than the box's left, put the number into the difference's x-number.
If the spot's x-coord is greater than the box's right, put the number into the difference's x-number; negate the difference's x-number.
If the text's horizontal scroll flag is not set, put 0 into the difference's x-number.
If the text's vertical scroll flag is not set, put 0 into the difference's y-number.
If the difference is 0, clear the flag; exit.
Set the flag.
Scroll the text given the difference.
Wait for_ 50 milliseconds.

The b-key is a_ key equal to 66.

The backslash byte is a_ byte equal to 92.

The backspace key is a_ key equal to 8.

The bar byte is a_ byte equal to 124.

a_ baseline is a_ number.

\PAL
Para apitar;
\CAL
To beep: 
Call "user32.dll" "MessageBeep" with 0.

\PAL
Para iniciar uma folha horizontal;
\CAL
To begin a_ landscape sheet:
Make the landscape sheet 11 inches by 8-1/2 inches.
Begin a_ sheet with the landscape sheet.

\PAL
Para iniciar uma folha horizontal dada uma sequência de título;
\CAL
To begin a_ landscape sheet given a_ title string:
If the pdf document flag is not set, clear the landscape sheet; exit.
Make the landscape sheet 11 inches by 8-1/2 inches.
Begin the sheet given the box and the title (pdf style).

\PAL
Para iniciar uma folha vertical;
\CAL
To begin a_ portrait sheet:
Make the portrait sheet 8-1/2 inches by 11 inches.
Begin a_ sheet with the portrait sheet.

\PAL
Para iniciar uma folha vertical dada uma sequência de título;
\CAL
To begin a_ portrait sheet given a_ title string:
If the pdf document flag is not set, clear the portrait sheet; exit.
Make the portrait sheet 8-1/2 inches by 11 inches.
Begin the sheet given the box and the title (pdf style).

\PAL
Para começar a imprimir;
Para iniciar a impressão;
\CAL
To begin printing:
Initialize the printer canvas.
Put a_ docinfo's magnitude into the docinfo's cbsize.
Put the module's name's first into the docinfo's lpszdocname.
Call "gdi32.dll" "StartDocA" with the printer canvas and the docinfo's whereabouts.

To begin printing a_ pdf:
Set the pdf state's document flag.
Put 0 into the pdf state's object number.
Create the pdf state's font index given 113.
Begin printing the pdf (start the root).
Begin printing the pdf (start the parent).

To begin printing a_ pdf (start the parent):
Add a_ parent pdf object given "parent".
Put the parent into the pdf state's parent.
Append the parent's number then " 0 obj" to the parent.
Append "<<" to the parent.
Append "/Type /Pages" to the parent.

To begin printing a_ pdf (start the root):
Add a_ root pdf object given "root".
Put the root into the pdf state's root.
Append the root's number then " 0 obj" to the root.
Append "<<" to the root.
Append "/Type /Catalog" to the root.

\PAL
Para iniciar uma folha;
\CAL
To begin a_ sheet:
Begin the sheet as_ a_ portrait sheet.

\PAL
Para iniciar uma folha dada uma caixa;
\CAL
To begin a_ sheet given a_ box:
If the pdf state's document flag is set, begin the sheet given the box (pdf style); exit.
Call "kernel32.dll" "GlobalLock" with the printer device mode handle returning a_ pdevmode.
If the pdevmode is nil, exit.
Bitwise or the pdevmode's dmfields with 1 [dm_orientation].
Put 1 [dmorient_portrait] into the pdevmode's dmorientation.
If the box's width is greater than the box's height, put 2 [dmorient_landscape] into the pdevmode's dmorientation.
Call "gdi32.dll" "ResetDCA" with the printer canvas and the pdevmode.
Call "kernel32.dll" "GlobalUnlock" with the printer device mode handle.
Call "gdi32.dll" "SetGraphicsMode" with the printer canvas and 2 [gm_advanced].
Call "gdi32.dll" "SetBkMode" with the printer canvas and 1 [transparent].
Call "gdi32.dll" "SetMapMode" with the printer canvas and 8 [mm_anisotropic].
Call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 112 [physicaloffsetx] returning a_ pair's x-number.
Call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 113 [physicaloffsety] returning the pair's y-number.
Negate the pair.
Call "gdi32.dll" "SetViewportOrgEx" with the printer canvas and the pair's x-number and the pair's y-number and nil.
Call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 88 [logpixelsx] returning the pair's x-number.
Call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 90 [logpixelsy] returning the pair's y-number.
Call "gdi32.dll" "SetViewportExtEx" with the printer canvas and the pair's x-number and the pair's y-number and nil. 
Call "gdi32.dll" "SetWindowOrgEx" with the printer canvas and 0 and 0 and nil.
Call "gdi32.dll" "SetWindowExtEx" with the printer canvas and the tpi and the tpi and nil.
Call "gdi32.dll" "StartPage" with the printer canvas.
Put the printer canvas into the current canvas.
Call "gdi32.dll" "GetDeviceCaps" with the printer canvas and 88 [logpixelsx] returning a_ number.
Put the tpp into the saved tpp.
Put the tpi divided by the number into the tpp.

To begin a_ sheet given a_ box (pdf style):
Begin the sheet given the box and "" (pdf style).

\PAL
Para iniciar uma folha dada uma caixa e uma sequência de título;
\CAL
To begin a_ sheet given a_ box and a_ title string:
Begin the sheet given the box and the title (pdf style).

To begin a_ sheet given a_ box and a_ title string (pdf style - start the current page):
Add the pdf state's current page given "page".
Append the pdf state's current page's number then " 0 obj" to the pdf state's current page.
Append "<<" to the pdf state's current page.  
Append "/Type /Page" to the pdf state's current page.
Append "/Parent " then the pdf state's parent's number then " 0 R" to the pdf state's current page.
Put the box's width minus the tpp times 72 / the tpi into a_ width.
Put the box's height minus the tpp times 72 / the tpi into a_ height.
Append "/MediaBox [0 0 " then the width then " " then the height then "]" to the pdf state's current page.
Put the box's height minus the tpp into the pdf state's current height.
Add the pdf state's current contents given "contents".
Append "/Contents " then the pdf state's current contents' number then " 0 R" to the pdf state's current page.
Append "0.05 0 0 0.05 1 1 cm" to the pdf state's current contents. \ set matrix to scale 72/1440
Append "13 w 0 J 0 j 0 i" to the pdf state's current contents. \ penwidth, linecap, linejoin, flatness \ 15 w on penwidth comes out to wide

To begin a_ sheet given a_ box and a_ title string (pdf style):
Set the pdf state's page flag.
Put the clear color into the pdf state's current border.
Put the clear color into the pdf state's current fill.
Begin the sheet given the box and the title (pdf style - start the current page).
If the title is blank, exit.
Create a_ pdf outline entry given the title and the pdf state's current height and the pdf state's current page's number.
Append the pdf outline entry to the pdf state's outline entries.

\PAL
Para iniciar uma folha dada uma sequência de título;
\CAL
To begin a_ sheet given a_ title string:
Begin a_ portrait sheet given the title.

The bell byte is a_ byte equal to 7.

The Bible is a_ thing with some verses.

a_ verse is a_ thing with a_ string.

The big-a byte is a_ byte equal to 65.

The big-a-acute byte is a_ byte equal to 193.

The big-a-circumflex byte is a_ byte equal to 194.

The big-a-diaeresis byte is a_ byte equal to 196.

The big-a-grave byte is a_ byte equal to 192.

The big-a-ring byte is a_ byte equal to 197.

The big-a-tilde byte is a_ byte equal to 195.

The big-ae byte is a_ byte equal to 198.

The big-b byte is a_ byte equal to 66.

The big-c byte is a_ byte equal to 67.

The big-c-cedilla byte is a_ byte equal to 199.

The big-d byte is a_ byte equal to 68.

The big-e byte is a_ byte equal to 69.

The big-e-acute byte is a_ byte equal to 201.

The big-e-circumflex byte is a_ byte equal to 202.

The big-e-diaeresis byte is a_ byte equal to 203.

The big-e-grave byte is a_ byte equal to 200.

a_ big-endian unsigned wyrd is a_ record with 2 bytes.

The big-eth byte is a_ byte equal to 208.

The big-f byte is a_ byte equal to 70.

The big-g byte is a_ byte equal to 71.

The big-h byte is a_ byte equal to 72.

The big-i byte is a_ byte equal to 73.

The big-i-acute byte is a_ byte equal to 205.

The big-i-circumflex byte is a_ byte equal to 206.

The big-i-diaeresis byte is a_ byte equal to 207.

The big-i-grave byte is a_ byte equal to 204.

The big-j byte is a_ byte equal to 74.

The big-k byte is a_ byte equal to 75.

The big-l byte is a_ byte equal to 76.

The big-m byte is a_ byte equal to 77.

The big-n byte is a_ byte equal to 78.

The big-n-tilde byte is a_ byte equal to 209.

The big-o byte is a_ byte equal to 79.

The big-o-acute byte is a_ byte equal to 211.

The big-o-circumflex byte is a_ byte equal to 212.

The big-o-diaeresis byte is a_ byte equal to 214.

The big-o-grave byte is a_ byte equal to 210.

The big-o-stroke byte is a_ byte equal to 216.

The big-o-tilde byte is a_ byte equal to 213.

The big-oe byte is a_ byte equal to 140.

The big-p byte is a_ byte equal to 80.

The big-q byte is a_ byte equal to 81.

The big-r byte is a_ byte equal to 82.

The big-s byte is a_ byte equal to 83.

The big-s-caron byte is a_ byte equal to 138.

The big-t byte is a_ byte equal to 84.

The big-thorn byte is a_ byte equal to 222.

The big-u byte is a_ byte equal to 85.

The big-u-acute byte is a_ byte equal to 218.

The big-u-circumflex byte is a_ byte equal to 219.

The big-u-diaeresis byte is a_ byte equal to 220.

The big-u-grave byte is a_ byte equal to 217.

The big-v byte is a_ byte equal to 86.

The big-w byte is a_ byte equal to 87.

The big-x byte is a_ byte equal to 88.

The big-y byte is a_ byte equal to 89.

The big-y-acute byte is a_ byte equal to 221.

The big-y-diaeresis byte is a_ byte equal to 159.

The big-z byte is a_ byte equal to 90.

The big-z-caron byte is a_ byte equal to 142.

a_ billion is 1000 millions.

a_ binary string is a_ string.

a_ bit is a_ unit.

a_ bitmapdata is a_ record with
a_ width,
a_ height,
a_ number called stride,
a_ number called pixelformat,
a_ pointer called scan0,
a_ number called reserved.

\PAL
Para rebitar-e um byte com outro byte;
Para bit a bit e um byte com outro byte;
\CAL
To bitwise and a_ byte with another byte:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the other byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $2003. \ and [ebx],al

\PAL
Para rebitar-e um byte com um número;
Para bit a bit e um byte com um número;
\CAL
To bitwise and a_ byte with a_ number:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $2003. \ and [ebx],al

\PAL
Para rebitar-e um número com outro número;
Para bit a bit e um número com outro número;
\CAL
To bitwise and a_ number with another number:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $2103. \ and [ebx],eax

\PAL
Para rebitar-ou um byte com outro byte;
Para bit a bit ou um byte com outro byte;
\CAL
To bitwise or a_ byte with another byte:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the other byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $0803. \ or [ebx],al

\PAL
Para rebitar-ou um byte com um número;
Para bit a bit ou um byte com um número;
\CAL
To bitwise or a_ byte with a_ number:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $0803. \ or [ebx],al

\PAL
Para rebitar-ou um número com outro número;
Para bit a bit ou um número com outro número;
\CAL
To bitwise or a_ number with another number:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $0903. \ or [ebx],eax

\PAL
Para rebitar-xor um byte com outro byte;
Para bit a bit xor um byte com outro byte;
\CAL
To bitwise xor a_ byte with another byte:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the other byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $3003. \ xor [ebx],al

\PAL
Para rebitar-xor um byte com um número;
Para bit a bit xor um byte com um número;
\CAL
To bitwise xor a_ byte with a_ number:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $3003. \ or [ebx],al

\PAL
Para rebitar-xor um número com outro número;
Para bit a bit xor um número com outro número;
\CAL
To bitwise xor a_ number with another number:
Intel $8B850C000000. \ mov eax,[ebp+12] \ the other number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $3103. \ xor [ebx],eax

The black color is a_ color.

The black pen is a_ pen.

The blue color is a_ color.

The blue pen is a_ pen.

a_ box has
\CAL
a_ left coord, a_ top coord, a_ right coord, a_ bottom coord,
a_ left-top spot at the left, and a_ right-bottom spot at the right,
a_ top-left spot at the left, and a_ bottom-right spot at the right,
\PAL
uma coordenada chamada esquerda redefinindo a left coord,
uma coordenada chamada topo redefinindo a top coord,
uma coordenada chamada direita redefinindo a right coord,
uma coordenada chamada base redefinindo a bottom coord,
um loco esquerdo-superior redefinindo a left,
um loco direito-inferior redefinindo a right.

a_ brightness is a_ lightness.

The broken-bar byte is a_ byte equal to 166.

The brown color is a_ color.

The brown pen is a_ pen.

a_ brownish color is a_ color.

a_ bucket count is a_ count.

a_ bucket is a_ pointer to a_ bucket record.

a_ bucket record has some refers.

a_ bucket# is a_ number.

a_ buffer is a_ string.

The bullet byte is a_ byte equal to 149.

\PAL
Para incrementar um byte limitando-o a outro byte e um terceiro byte;
\CAL
To bump a_ byte limiting it to another byte and a_ third byte:
Add 1 to the byte.
If the byte is greater than the third byte, put the other byte into the byte.

\PAL
Para incrementar um número;
\CAL
To bump a_ number:
add 1 to the number.

\PAL
Para incrementar um número limitando-o a outro número e um terceiro número;
\CAL
To bump a_ number limiting it to another number and a_ third number:
Add 1 to the number.
If the number is greater than the third number, put the other number into the number.

\PAL
Para incrementar um iterador;
Para avançar um iterador;
\CAL
To bump a_ rider:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the rider
Intel $FF8314000000. \ inc [ebx+20] \ the rider's token's last
Intel $FF8308000000. \ inc [ebx+8] \ the rider's source's first

\PAL
Para retroagir um iterador;
Para retroceder um iterador;
\CAL
To unbump a_ rider:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the rider
Intel $FF8B14000000. \ dec [ebx+20] \ the rider's token's last
Intel $FF8B08000000. \ dec [ebx+8] \ the rider's source's first

\PAL
Para avançar um iterador dado um número;
Para avançar um iterador por um número;
\CAL
To bump a_ rider by a_ number:
Add the number to the rider's token's last.
Add the number to the rider's source's first.  

\PAL
Para zumbir;
\CAL
To buzz: 
Call "kernel32.dll" "Beep" with 220 and 200.

a_ byte count is a_ count.

a_ byte pointer is a_ pointer to a_ byte.

a_ byte# is a_ number.

The c-key is a_ key equal to 67.

The cancel byte is a_ byte equal to 24.

a_ canvas is an hdc.

\PAL
Para capitalizar as linhas selecionadas em um texto;
Para capitalizar as linhas selecionadas de um texto;
\CAL
To capitalize any selected rows in a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row of the text is not selected, repeat.
If the row is blank, repeat.
Capitalize the row's string.
Repeat.

\PAL
Para capitalizar uma sequência;
\CAL
To capitalize a_ string:
Slap a_ substring on the string.
Loop.
If the substring is blank, exit.
If the substring's first's target is not noise, break.
Add 1 to the substring's first.
Repeat.
Uppercase the substring's first's target.

\PAL
Para capitalizar um texto;
\CAL
To capitalize a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, break.
Capitalize the row's string.
Repeat.
Wrap the text.

The caps key is a_ key equal to 20.

The caret byte is a_ byte equal to 94.

a_ caret is a_ position.

The cedilla byte is a_ byte equal to 184.

The cent-sign byte is a_ byte equal to 162.

\PAL
Para centralizar uma caixa na parte inferior de outra caixa;
\CAL
To center a_ box at the bottom of another box:
Center the box in the other box (horizontally).
Put the box's height into a_ height.
Put the other box's bottom into the box's bottom.
Put the box's bottom minus the height into the box's top.

\PAL
Para centralizar uma caixa em outra caixa (horizontalmente);
\CAL
To center a_ box in another box (horizontally):
Put the other box's center's x-coord minus the box's center's x-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the box given the number and 0.

\PAL
Para centralizar uma caixa em outra caixa (verticalmente);
\CAL
To center a_ box in another box (vertically):
Put the other box's center's y-coord minus the box's center's y-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the box given 0 and the number.

\PAL
Para centralizar um ponto no loco corrente;
\CAL
To center a_ dot on the current spot: \ need Spanish word for "dot"
Center the dot on the context's spot.

\PAL
Para centralizar uma elipse em uma caixa (horizontalmente);
\CAL
To center an ellipse in a_ box (horizontally):
Center the ellipse's box in the box (horizontally).

\PAL
Para centralizar uma elipse em uma caixa (verticalmente);
\CAL
To center an ellipse in a_ box (vertically):
Center the ellipse's box in the box (vertically).

\PAL
Para centralizar uma reta em uma caixa (horizontalmente);
\CAL
To center a_ line in a_ box (horizontally):
Put the box's center's x-coord minus the line's center's x-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the line given the number and 0.

\PAL
Para centralizar uma reta em uma caixa (verticalmente);
\CAL
To center a_ line in a_ box (vertically):
Put the box's center's y-coord minus the line's center's y-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the line given 0 and the number.

\PAL
Para centralizar uma imagem em uma caixa (horizontalmente);
\CAL
To center a_ picture in a_ box (horizontally):
If the picture is nil, exit.
Put the box's center's x-coord minus the picture's box's center's x-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the picture given the number and 0.

\PAL
Para centralizar uma imagem em uma caixa (verticalmente);
\CAL
To center a_ picture in a_ box (vertically):
If the picture is nil, exit.
Put the box's center's y-coord minus the picture's box's center's y-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the picture given 0 and the number.

\PAL
Para centralizar um polígono em uma caixa (horizontalmente);
\CAL
To center a_ polygon in a_ box (horizontally):
If the polygon is nil, exit.
Put the box's center's x-coord minus the polygon's box's center's x-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the polygon given the number and 0.

\PAL
Para centralizar um polígono em uma caixa (verticalmente);
\CAL
To center a_ polygon in a_ box (vertically):
If the polygon is nil, exit.
Put the box's center's y-coord minus the polygon's box's center's y-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the polygon given 0 and the number.

\PAL
Para centralizar um loco em uma caixa (horizontalmente);
\CAL
To center a_ spot in a_ box (horizontally):
Put the box's center's x-coord minus the spot's x-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the spot given the number and 0.

\PAL
Para centralizar um loco em uma caixa (verticalmente);
\CAL
To center a_ spot in a_ box (vertically):
Put the box's center's y-coord minus the spot's y-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the spot given 0 and the number.

\PAL
Para centralizar um texto em uma caixa (horizontalmente);
\CAL
To center a_ text in a_ box (horizontally):
If the text is nil, exit.
Put the box's center's x-coord minus the text's box's center's x-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the text given the number and 0.

\PAL
Para centralizar um texto em uma caixa (verticalmente);
\CAL
To center a_ text in a_ box (vertically):
If the text is nil, exit.
Put the box's center's y-coord minus the text's box's center's y-coord into a_ number.
Round the number to the nearest multiple of the tpp.
Move the text given 0 and the number.

\PAL
Para alterar a matiz atual em alguns degraus;
Para alterar a matiz atual por alguns degraus;
\CAL
To change the current hue by some points:
Change the context's hue by the points.

\PAL
Para alterar uma matiz atual em alguns degraus;
Para alterar uma matiz atual por alguns degraus;
\CAL
To change a_ hue by some points:
Add the points to the hue.

\PAL
Para alterar uma caixa arredondada dado um raio;
\CAL
To change a_ roundy box given a_ radius:
Put the radius into the roundy box's radius.

\PAL
Para alterar um texto dado uma caixa;
\CAL
To change a_ text given a_ box:
If the text is nil, exit.
Put the box into the text's box.
Wrap the text.

\PAL
Para alterar um texto dada uma altura de fonte;
\CAL
To change a_ text given a_ font height:
If the text is nil, exit.
Subtract the text's margin from the text's x-coord.
Put the text's origin divided by the text's grid into a_ pair.
Put the font height into the text's font's height.
Scale the text's font's height given the text's scale.
Put the pair times the text's grid into the text's origin.
Add the text's margin to the text's x-coord.
Limit the origin of the text.
Wrap the text.

\PAL
Para alterar um texto dado um nome de fonte;
\CAL
To change a_ text given a_ font name:
If the text is nil, exit.
Put the font name into the text's font's name.
Wrap the text.

a_ character is a_ byte.

a_ choice is a_ thing with a_ name and a_ box.

The choices are some choices.

The circumflex byte is a_ byte equal to 136.

\PAL
Para apagar uma caixa;
\CAL
To clear a_ box:
Put 0 and 0 and 0 and 0 into the box. \ writer depends on this

\PAL
Para apagar um byte;
\CAL
To clear a_ byte:
Put the null byte into the byte.

\PAL
Para apagar uma cor;
\CAL
To clear a_ color:
Put 0 and 0 and 0 into the color.

The clear color is a_ color.

\PAL
Para apagar uma elipse;
\CAL
To clear an ellipse:
Clear the ellipse's box.

\PAL
Para desligar uma signa;
Para negativar uma signa;
\CAL
To clear a_ flag:
Put 0 into the flag. \ was "Put no into the flag." Value of "no" inherited from the CAL-1000 according to Dan.

\PAL
Para apagar uma fonte;
\CAL
To clear a_ font:
Put "" and 0 into the font.

\PAL
Para apagar uma fração;
\CAL
To clear a_ fraction:
Put 0 and 1 into the fraction.

\PAL
Para apagar um endereço ip;
\CAL
To clear an ip address:
Clear the ip address' number.
Clear the ip address' string.

The clear key is a_ key equal to 12.

\PAL
Para apagar uma reta;
\CAL
To clear a_ line:
Clear the line's start.
Clear the line's end.

\PAL
Para apagar um número;
\CAL
To clear a_ number:
Put 0 into the number.

\PAL
Para apagar um par;
\CAL
To clear a_ pair:
Put 0 and 0 into the pair.

The clear pen is a_ pen.

\PAL
Para apagar um iterador;
\CAL
To clear a_ rider:
Clear the rider's original.
Clear the rider's source.
Clear the rider's token.

\PAL
Para apagar a tela;
\CAL
To erase the screen;
To blank out the screen;
To wipe off the screen;
To clear the screen:
Unmask everything.
Draw the screen's box with the black color and the black color.
Refresh the screen.
Put the screen's box into the context's box.

\PAL
Para apagar a tela com uma cor;
\CAL
To clear the screen to a_ color:
Unmask everything.
Draw the screen's box with the color and the color.
Refresh the screen.
Put the screen's box into the context's box.

\PAL
Para apagar a tela com branco;
\CAL
To clear the screen to white: \ Para borrar la pantalla a blanco; \ needs special handling
Unmask everything.
Draw the screen's box with the white color and the white color.
Refresh the screen.
Put the screen's box into the context's box.

\PAL
Para apagar a tela sem refrescá-la;
Para apagar a tela sem atualizá-la;
\CAL
To clear the screen without refreshing it:
Unmask everything.
Draw the screen's box with the black color and the black color.
Put the screen's box into the context's box.

\PAL
Para apagar uma seleção;
\CAL
To clear a_ selection:
Clear the selection's anchor.
Clear the selection's caret.

To clear the stack: \ stack needs work
Destroy the stack.

\PAL
Para apagar uma sequência;
Para esvaziar uma sequência;
\CAL
To clear a_ string:
Unassign the string's first.
Void the string's last.

\PAL
Para apagar um segmento;
Para esvaziar um segmento;
\CAL
To clear a_ substring:
Void the substring's first.
Void the substring's last.

\PAL
Para apagar um terminal;
\CAL
To clear a_ terminal:
Destroy the terminal's quoras.

\PAL
Para apagar alguns elementos;
\CAL
To clear some things:
Void the things' first.
Void the things' last.

\PAL
Para apagar uma wyrd;
\CAL
To clear a_ wyrd:
Put 0 into the wyrd.

\PAL
Para fechar um arquivo;
\CAL
To close a_ file:
Call "kernel32.dll" "CloseHandle" with the file.

a_ clsid is a_ uuid.

\PAL
Para reclamar;
\CAL
To cluck:
Play the cluck sound.

The cluck sound is a_ wave equal to $524946463A02000057415645666D74201200000001000100401F0000401F000001000800000066616374040000000702000064617461070200007F7F807F7F807F7F808080807F807F7F80817F81817E7E827E7D847C79877D5F6D99B2A25D608269A5979869667F7D8D738C7D8C5E7E878F767A75868D84797278829A7D7E857A73929271657492907D7E7D787E8B887C758388827E817F7C7B89897C7A7E84838183827E7A8488877D7E8181808484817C7F84838181807E7F8283807E8081808182807F7F81818081807F7F8081818080807F7F808180807F80808080807F8080807F8080808080807F7F7F7F7F8080807F7F7F7C7B8182817C7B7D7E8082807D7D7C7F8281807F7C7D808082807E7E7E7D7E807D7B7C7B7D7D7B7A7979797875727269797A490F4571FFF4FF0C001297FBF492525BB0F5B26A001C69BEE5BA76476F9EBD953C3757BAC9BB705C7F9AA883645D7897AA9B806977959588696976999B83766F828C907F7375828E91877B757D868B837A757C858D8880787B8187847B7A7D8788807B79808486817D7C7F8384817D7C7F8484817B7B7D83847F7C7B7E8182827D7C7C8082817D7C7D7F81807F7D7D7F82817F7B7B7E8081807E7D7D7F80807E7D7D7E80807E7D7D7E7F807F7D7D7E7F807F7E7D7E7E80807F7E7D7E80807F7E7E7E7F7F7E7E7E7F7F7F7F7E7E7F7F807F7F7E7E7E7F8080807E7E7E80807F7E7E7F8081807F7F7E7F7F80807F7E7F8081807F7E7E7E80808080807F807F7F7F7F7F7F7F80808080807F7F7F808080807F80808180807F80808100.

The colon byte is a_ byte equal to 58.

a_ color has a_ hue, a_ saturation, a_ lightness, a_ brightness at the lightness,
\PAL
uma matiz at the hue,
uma saturação at the saturation,
uma luminosidade at the lightness,
um brilho at the lightness.

a_ colorref is a_ number [like $00BBGGRR].

a_ column# is a_ number.

The comma byte is a_ byte equal to 44.

To compare a_ string to another string given a_ length and another length and a_ translation table (equal only):
Intel $8BB508000000. \ mov esi,[ebp+8] \ the string
Intel $8B36. \ mov esi,[esi] \ the string's first
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other string
Intel $8B3F. \ mov edi,[edi] \ the other string's first
Intel $8B8510000000. \ mov eax,[ebp+16] \ the string's length
Intel $8B00. \ mov eax,[eax]
Intel $8B9514000000. \ mov edx,[ebp+20] \ the other string's length
Intel $8B12. \ mov edx,[edx]
Intel $3BD0. \ cmp eax,edx \ if the length's differ, say no
Intel $0F852B000000. \ jne say no \ ************************************ was 2C
Intel $8BC8. \ mov ecx,eax \ put length into ecx  
Intel $8B9D18000000. \ mov ebx,[ebp+24] \ the translation table
Intel $8B1B. \ mov ebx,[ebx] the translation table's first
\ loop:
Intel $85C9. \ test ecx,ecx
Intel $0F8424000000. \ jz say yes \ ************************************ was 25
 \ fetch and translate the  current byte in the other string
Intel $8A07. \ mov al,[edi]
Intel $D7. \ xlat al,[ebx]
Intel $C1E008. \ shl eax,8
\ fetch and translate the current byte in the string
Intel $8A06. \ mov al,[esi]
Intel $D7. \ xlat al,[ebx]
 \ compare the two translated  bytes
Intel $38E0. \ cmp al,ah
Intel $0F8508000000. \ jne say no \ ************************************
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $E9DFFFFFFF. \ jmp loop \ ************************************ was DE
\SAY NO:
Intel $C7C000000000. \ mov eax,0
Intel $E906000000. \ jmp end
\SAY YES:
Intel $C7C001000000. \ mov eax,1

\ dahn - portuguese strings 2 - which table to use?
To compare a_ string to another string given a_ length and another length returning a_ number:
Compare the string to the other string given the length and the other length and the lowercase ascii table returning the number.
\Compare the string to the other string given the length and the other length and the lowercase accent-free ascii table returning the number.

To compare a_ string to another string given a_ length and another length and a_ translation table returning a_ number:
Intel $8BB508000000. \ mov esi,[ebp+8] \ the string
Intel $8B36. \ mov esi,[esi] \ the string's first
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other string
Intel $8B3F. \ mov edi,[edi] \ the other string's first
Intel $8B8510000000. \ mov eax,[ebp+16] \ the string's length
Intel $8B00. \ mov eax,[eax]
Intel $8B9514000000. \ mov edx,[ebp+20] \ the other string's length
Intel $8B12. \ mov edx,[edx]
Intel $8B9D18000000. \ mov ebx,[ebp+24] \ the translation table
Intel $8B1B. \ mov ebx,[ebx] the translation table's first
\ get the minimum length
Intel $8BC8. \ mov ecx,eax
Intel $3BCA. \ cmp ecx,edx
Intel $0F8602000000. \ jbe L2
Intel $8BCA. \ mov ecx,edx
\ if the minimum length is 0, jump to L5
Intel $85C9. \ test ecx,ecx
Intel $0F8428000000.  \ jz L5
\L2: \ loop:
\ fetch and translate the current byte in the string
Intel $8A06. \ mov al,[esi]
Intel $D7. \ xlat al,[ebx]
Intel $88C2. \ mov dl,al
\ fetch and translate the  current byte in the other string
Intel $8A07. \ mov al,[edi]
Intel $D7. \ xlat al,[ebx]
Intel $88C6. \ mov dh,al
\L3: \ compare the two translated bytes
Intel $38F2. \ cmp dl,dh
Intel $0F8510000000. \ jne L4
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $85C9. \ test ecx,ecx
Intel $0F8405000000. \ jz L4
Intel $E9DEFFFFFF. \ jmp L2
\L4: \ load bytes into eax and edx for final compare
Intel $0FB6C2. \ movzx eax,dl
Intel $0FB6D6. \ movzx edx,dh
\L5: \ subtract either the lengths or the last two bytes to set the eax to <0, =0, >0
Intel $2BC2. \ sub eax,edx
Intel $8B9D1C000000. \ mov ebx,[ebp+28] \ the number
Intel $8903. \ mov [ebx],eax

To compatibly handle any message with a_ window a_ message number a_ w-param and an l-param:
If the message is 006, handle any wm-activate with the w-param; put 0 into eax; exit.
If the message is 258, handle any wm-char with the w-param and the l-param; put 0 into eax; exit.
If the message is 001, handle any wm-create with the window; put 0 into eax; exit.
If the message is 002, handle any wm-destroy; put 0 into eax; exit.
If the message is 256, handle any wm-keydown with the w-param and the l-param; put 0 into eax; exit.
If the message is 513, handle any wm-lbuttondown with the l-param; put 0 into eax; exit.
If the message is 515, handle any wm-lbuttondblclk with the l-param; put 0 into eax; exit.
If the message is 015, handle any wm-paint with the window; put 0 into eax; exit.
If the message is 516, handle any wm-rbuttondown with the l-param; put 0 into eax; exit.
If the message is 518, handle any wm-rbuttondblclk with the l-param; put 0 into eax; exit.
If the message is 032, handle any wm-setcursor; put 1 into eax; exit.
If the message is 260, handle any wm-syskeydown with the w-param and the l-param; put 0 into eax; exit.
Call "user32.dll" "DefWindowProcA" with the window and the message and the w-param and the l-param.

To compatibly wait for_ a_ process pointer:
Call "kernel32.dll" "WaitForSingleObject" with the process pointer's target and -1 [infinite].
Call "kernel32.dll" "CloseHandle" with the process pointer's target.
Put 0 into the process pointer's target.
Call "user32.dll" "GetForegroundWindow" returning a_ window.
If the window is the main window, put 0 into eax; exit.
Call "user32.dll" "ShowWindow" with the main window and 6 [sw_minimize].
Call "user32.dll" "ShowWindow" with the main window and 9 [sw_restore].
Put 0 into eax. \ set return value of thread

\a_ console is a_ thing with 
\a_ box,
\a_ border color,
\a_ fill color,
\a_ text,
\a_ grid,
\a_ reply string.

a_ console is a_ thing with 
a_ box,
a_ border color,
a_ fill color,
a_ text,
a_ grid,
a_ reply string,
\PAL
uma caixa at the box,
uma cor chamada borda at the border color,
uma cor chamada preenchimento at the fill color,
um texto at the text,
uma grade at the grid,
uma sequência chamada resposta at the reply string.

The context is a_ context.

a_ context is a_ thing with
a_ spot,
a_ box,
a_ heading,
a_ letter height,
a_ color,
a_ number, \ pen width? ***
and a_ letter size at the letter height,
and a_ pen at the color.

The context stack is some contexts.

To convert an absolute position to a_ position given a_ text:
If the text is nil, clear the position; exit.
Privatize the absolute position.
Loop.
Get a_ row from the text's rows.
If the row is nil, clear the position; exit.
Put the row's row# into the position's row#.
Put the absolute position into the position's column#.
Subtract the row's string's length from the absolute position.
If the absolute position is less than 1, exit.
Repeat.

\PAL
Para converter uma sequência binária em um número;
\CAL
To convert a_ binary string into a_ number:
Put 0 into the number.
Put 1 into a_ value number.
Loop.
If the binary string is blank, exit.
Get a_ character from the binary string (backwards). \ was backwards
If the character is "1", add the value to the number.
Double the value.
Repeat.

\PAL
Para converter uma caixa em uma sequência;
\CAL
To convert a_ box to a_ string:
Clear the string.
Append the box's left to the string.
Append " " to the string.
Append the box's top to the string.
Append " " to the string.
Append the box's right to the string.
Append " " to the string.
Append the box's bottom to the string.

\PAL
Para converter um byte em um nibble;
\CAL
To convert a_ byte to a_ nibble:
Put the byte into the nibble as_ a_ byte.
Uppercase the nibble.
If the nibble is greater than the nine byte, subtract 7 from the nibble.
Subtract 48 from the nibble.

\PAL
Para converter um byte em um nibble string;
\CAL
To convert a_ byte to a_ nibble string:
Split the byte into a_ nibble and another nibble.
Convert the nibble to the nibble string.
Convert the other nibble to another nibble string.
Append the other nibble string to the nibble string.

\PAL
Para converter um byte em um byte de consulta;
\CAL
To convert a_ byte to a_ query byte:
If the byte is between 48 and 57, put the byte into the query byte; exit. \ 0-9
If the byte is between 65 and 90, put the byte into the query byte; exit. \ A-Z
If the byte is between 97 and 122, put the byte into the query byte; exit. \ a-z
If the byte is 32, put "+" into the query byte; exit. \ space
Convert the byte to a_ nibble string.
Put "%" then the nibble string into the query byte.

To convert a_ color to a_ colorref:
If the color is clear, put 16777215 [$00FFFFFF] into the colorref; exit. \ clear pen becomes white
Privatize the color.
Scale the color's saturation given 240/1000.
Limit the color's saturation to 1 and 239.
Scale the color's lightness given 240/1000.
Limit the color's lightness to 1 and 239.
Scale the color's hue given 240/3600.
Limit the color's hue to 1 and 239.
Call "shlwapi.dll" "ColorHLSToRGB" with the color's hue and the color's lightness and the color's saturation returning the colorref.

To convert a_ color to a_ rgb:
Convert the color to a_ colorref.
Convert the colorref to the rgb. 

To convert a_ colorref to a_ color:
Call "shlwapi.dll" "ColorRGBToHLS" with the colorref and a_ wyrd's whereabouts and another wyrd's whereabouts and a_ third wyrd's whereabouts.
Put the wyrd into the color's hue.
Put the other wyrd into the color's  lightness.
Put the third wyrd into the color's saturation.
Scale the color's hue given 3600/240.
Limit the color's hue to 0 and 3600.
Scale the color's saturation given 1000/240.
Limit the color's saturation to 0 and 1000.
Scale the color's lightness given 1000/240.
Limit the color's lightness to 0 and 1000.

To convert a_ colorref to a_ rgb:
Privatize the colorref.
Shift the colorref right 0 bits.
Put the colorref into the rgb's red byte.
Shift the colorref right 8 bits.
Put the colorref into the rgb's green byte.
Shift the colorref right 8 bits.
Put the colorref into the rgb's blue byte.

To convert a_ filetime to a_ string:
Clear the string.
Call "kernel32.dll" "FileTimeToSystemTime" with the filetime's whereabouts and a_ systemtime's whereabouts returning a_ number.
If the number is 0, exit.
Put the systemtime's wyear into a_ date/time's year.
Put the systemtime's wmonth into the date/time's month.
Put the systemtime's wdayofweek into the date/time's week day.
Put the systemtime's wday into the date/time's day.
Put the systemtime's whour into the date/time's hour.
Put the systemtime's wminute into the date/time's minute.
Put the systemtime's wsecond into the date/time's second.
Put the systemtime's wmilliseconds into the date/time's millisecond.
Put the date/time's string into the string.

To convert a_ flag to a_ hex string:
Reassign the hex string's first given the flag's magnitude.
Copy bytes from the flag's whereabouts to the hex string's first for_ the flag's magnitude.
Put the hex string's first plus the flag's magnitude minus 1 into the hex string's last.

To convert a_ font to an hfont:
Privatize the font.
Null terminate the font's name.
Call "gdi32.dll" "CreateFontA" with - the font's height times 3 divided by 4 and 0 and 0 and 0 and 0 and 0 and 0 and 0 
And 1 [default_charset] and 0 and 0 and 5 [cleartype_quality] and 4 [truetype_fonttype] and the font's name's first returning the hfont.

To convert a_ font info to pdf em units:
If the font info is nil, exit.
Convert the font info's internal leading to pdf em units given the font info's emsquare and the font info's font.
Convert the font info's ascent to pdf em units given the font info's emsquare and the font info's font.
Convert the font info's descent to pdf em units given the font info's emsquare and the font info's font.
Convert the font info's capheight to pdf em units given the font info's emsquare and the font info's font.
\  convert the font info's italicangle to pdf em units given the font info's emsquare and the font info's font.
Convert the font info's stemv to pdf em units given the font info's emsquare and the font info's font.
Convert the font info's font box's left to pdf em units given the font info's emsquare and the font info's font.
Convert the font info's font box's top to pdf em units given the font info's emsquare and the font info's font.
Convert the font info's font box's right to pdf em units given the font info's emsquare and the font info's font.
Convert the font info's font box's bottom to pdf em units given the font info's emsquare and the font info's font.
Swap the font info's font box's top with the font info's font box's bottom.
Convert the font info's font widths to pdf em units.

To convert some font widths to pdf em units:
Get an outlinetextmetric given the font widths' font.
Put the font widths' data into a_ number pointer.
Loop.
If a_ counter is past the font widths' count, break.
Convert the number pointer's target to pdf em units given the outlinetextmetric's otmemsquare and the font widths' font.
Add a_ number's magnitude to the number pointer.
Repeat.

To convert a_ fraction to a_ hex string:
Reassign the hex string's first given the fraction's magnitude.
Copy bytes from the fraction's whereabouts to the hex string's first for_ the fraction's magnitude.
Put the hex string's first plus the fraction's magnitude minus 1 into the hex string's last.

To convert a_ fraction to a_ mixed:
If the fraction's denominator is 0, put 0 into the mixed's whole number; put 0 into the mixed's ratio; exit.
Divide the fraction's numerator by the fraction's denominator giving the mixed's whole number and a_ remainder.
Put the remainder and the fraction's denominator into the mixed's fraction.

\PAL
Para converter uma fração em uma sequência dado um número;
\CAL
To convert a_ fraction to a_ string given a_ number: \ converts to a decimal representation with "the number" of places
Clear the string.
If the number is less than 1, exit.
Put 10 into a_ value number.
Raise the value to the number.
Privatize the fraction.
If the fraction is negative, set a_ flag; de-sign the fraction.
Multiply the value by the fraction.
Zero fill the value given the number and append it to the string.
Put the string's length minus the number plus 1 into a_ byte#.
Insert "." into the string before the byte#.
If the string's first's target is the period byte, prepend "0" to the string.
If the flag is set, prepend "-" to the string.

To convert a_ gpbitmap to a_ buffer (pdf style):
Clear the buffer.
If the gpbitmap is nil, exit.
Lock the gpbitmap given a_ bitmapdata (24-bit rgb).
Put 1 into a_ row#.
Put 1 into a_ column#.
Loop.
If the column# is greater than the bitmapdata's width, put 1 into the column#; add 1 to the row#.
If the row# is greater than the bitmapdata's height, break.
Get a_ rgb pointer from the bitmapdata at the row# and the column#.
Append the rgb pointer's red byte to the buffer.
Append the rgb pointer's green byte to the buffer.
Append the rgb pointer's blue byte to the buffer.
Add 1 to the column#.
Repeat.
Unlock the gpbitmap given the bitmapdata.

\PAL
Para converter um hex string em uma fração;
\CAL
To convert a_ hex string to a_ fraction:
If the hex string's length is not the fraction's magnitude, put 0 and 1 into the ratio; exit.
Copy bytes from the hex string's first to the fraction's whereabouts for_ the fraction's magnitude.

\PAL
Para converter um hex string em um número;
\CAL
To convert a_ hex string to a_ number:
If the hex string's length is not the number's magnitude, clear the number; exit.
Copy bytes from the hex string's first to the number's whereabouts for_ the number's magnitude.

To convert an l-param to a_ key: \ assumes l-param from wm_char message
Put the l-param into the key.
Shift the key right 16 bits.
Bitwise and the key with 255.
Call "user32.dll" "MapVirtualKeyA" with the key and 1 returning the key.
If the numlock key was not toggled, exit.
If the key is the insert key, put the numpad-zero key into the key; exit.
If the key is the delete key, put the numpad-period key into the key; exit.
If the key is the home key, put the numpad-seven key into the key; exit.
If the key is the end key, put the numpad-one key into the key; exit.
If the key is the page-up key, put the numpad-nine key into the key; exit.
If the key is the page-down key, put the numpad-three key into the key; exit.
If the key is the left-arrow key, put the numpad-four key into the key; exit.
If the key is the up-arrow key, put the numpad-eight key into the key; exit.
If the key is the right-arrow key, put the numpad-six key into the key; exit.
If the key is the down-arrow key, put the numpad-two key into the key; exit.
If the key is the clear key, put the numpad-five key into the key; exit.

To convert an l-param to a_ spot:
Split the l-param into a_ wyrd and another wyrd.
Put the wyrd into the spot's y-coord.
Put the other wyrd into the spot's x-coord.
Multiply the spot by the tpp.

To convert a_ mixed to a_ fraction:
Put the mixed's fraction into the fraction.
Add the mixed's whole number times the fraction's denominator to the fraction's numerator.

To convert a_ nibble to a_ nibble string:
Privatize the nibble.
If the nibble is greater than 9, add 7 to the nibble.
Add 48 to the nibble.
Put the nibble into the nibble string.

To convert a_ nibble string to a_ hex string:
Privatize the nibble string.
Clear the hex string.
If the nibble string's length is odd, prepend the zero byte to the nibble string.
Slap a_ substring on the nibble string.
Loop.
If the substring is blank, exit.
Convert the substring's first's target to a_ nibble.
Shift the nibble left 4 bits.
Add 1 to the substring's first.
Convert the substring's first's target to another nibble.
Bitwise or the nibble with the other nibble.
Append the nibble to the hex string.
Add 1 to the substring's first.
Repeat.

\PAL
Para converter um número em um byte;
\CAL
To convert a_ number to a_ byte:
Put the number into the byte.

To convert a_ number to pdf em units given an emsquare number and a_ font:
Multiply the number by the emsquare / the font's adjusted height.
Multiply the number by 1000 / the emsquare.

To convert a_ pchar to a_ string:
Clear the string.
If the pchar is nil, exit.
Privatize the pchar.
Loop.
If the pchar's target is the null byte, exit.
Append the pchar's target to the string.
Add 1 to the pchar.
Repeat.

\PAL
Para converter um ponteiro e um tamanho em uma sequência;
\CAL
To convert a_ pointer and a_ length to a_ string:
Clear the string.
If the pointer is nil, exit.
If the length is 0, exit.
Reassign the string's first given the length.
Copy bytes from the pointer to the string's first for_ the length.
Put the string's first plus the length minus 1 into the string's last.

To convert a_ pointer to a_ hex string;
To convert a_ number to a_ hex string:
Reassign the hex string's first given the number's magnitude.
Copy bytes from the number's whereabouts to the hex string's first for_ the number's magnitude.
Put the hex string's first plus the number's magnitude minus 1 into the hex string's last.

To convert a_ pointer to a_ nibble string;
To convert a_ number to a_ nibble string:
Split the number into a_ wyrd and another wyrd.
Convert the wyrd to the nibble string.
Convert the other wyrd to another nibble string.
Append the other nibble string to the nibble string.

\PAL
Para converter um ponteiro em uma sequência;
\CAL
To convert a_ pointer to a_ string:
Convert the pointer to the string as_ a_ nibble string.

\PAL
Para converter alguns degraus em alguns graus precisos;
\CAL
To convert some points to some precise degrees:
Put the points times 3840 divided by 3600 into the precise degrees.

To convert a_ position to an absolute position given a_ text:
If the text is nil, clear the absolute position; exit.
Put 0 into the absolute position.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row's row# is less than the position's row#, add the row's string's length to the absolute position; repeat.
Add the position's column# to the absolute position.

\PAL
Para converter alguns graus precisos em alguns degraus;
\CAL
To convert some precise degrees to some points:
Put the precise degrees times 3600 divided by 3840 into the points.

\PAL
Para converter uma sequência de consulta em uma sequência;
\CAL
To convert a_ query string to a_ string:
Clear the string.
If the query string is blank, exit.
Slap a_ substring on the query string.
Loop.
If the substring is blank, exit.
If the substring's first's target is the cross byte, append " " to the string; add 1 to the substring's first; repeat.
If the substring's first's target is not the percent-sign byte, append the substring's first's target to the string; add 1 to the substring's first; repeat.
If the substring's length is less than 3, exit.
Add 1 to the substring's first.
Convert the substring's first's target to a_ nibble.
Shift the nibble left 4 bits.
Add 1 to the substring's first.
Convert the substring's first's target to another nibble.
Bitwise or the nibble with the other nibble.
Add 1 to the substring's first.
Append the nibble to the string.
Repeat.

To convert some rows to a_ string:
Clear the string.
Loop.
Get a_ row from the rows.
If the row is nil, exit.
Append the row's string to the string.
If the string's last's target is the return byte, append the linefeed byte to the string; repeat.
Repeat.

To convert some rows to a_ string (no linefeed additions):
Clear the string.
Loop.
Get a_ row from the rows.
If the row is nil, exit.
Append the row's string to the string.
Repeat.

To convert a_ string and an actual font info and an original font info into a_ buffer for_ pdf output:
Clear the buffer.
Put 0 into a_ current byte#.
Slap a_ substring on the first byte of the string.
Loop.
If the substring's first is greater than the string's last, break.
If the substring's last is the string's last, break.
Get a_ current width given the current byte# and the actual font info's font widths.
Get an original width given the substring's last's target and the original font info's font widths.
Put the original width minus the current width into an offset.
If the offset is 0, add 1 to the substring's last; add 1 to the current byte#; repeat.
Convert the substring to a_ pdf string.
Append the pdf string then " " then the offset then " " to the buffer.
Put the substring's last plus 1 into the substring's last.
Put the substring's last into the substring's first.
Add 1 to the current byte#.
Repeat.
If the substring's first is greater than the string's last, exit.
Convert the substring to another pdf string.
Append the other pdf string to the buffer.

\PAL
Para converter uma sequência em uma signa;
\CAL
To convert a_ string to a_ flag:
\PAL
If the string is "sim", set the flag; exit.
\CAL
If the string is "yes", set the flag; exit.
Clear the flag.

\PAL
Para converter uma sequência em uma fração;
\CAL
To convert a_ string to a_ fraction:
Clear the fraction.
If the string is blank, exit.
If the string is any integer, convert the string to the fraction's numerator; exit.
Slap a_ substring on the string.
If the substring's first's target is any sign, add 1 to the substring's first.
If the substring is blank, exit.
Split the substring into an integer substring and a_ fraction substring given the dash byte.
If the integer substring is blank, put the substring into the fraction substring.
Split the fraction substring into a_ numerator substring and a_ denominator substring given the slash byte.
Convert the integer substring to a_ whole number.
Convert the numerator substring to a_ numerator number.
Convert the denominator substring to a_ denominator number.
If the whole number is negative, exit.
If the numerator number is negative, exit.
If the denominator number is negative, exit.
If the denominator number is 0, exit.
If the whole number is not 0, add the denominator number times the whole number to the numerator number.
Put the numerator number into the fraction's numerator.
Put the denominator number into the fraction's denominator.
If the string's first's target is the dash byte, negate the fraction.

To convert a_ string to a_ nibble string:
Clear the nibble string.
Slap a_ substring on the string.
Loop.
If the substring is blank, exit.
Convert the substring's first's target to another nibble string.
Append the other nibble string to the nibble string.
Add 1 to the substring's first.
Repeat.

\PAL
Para converter uma sequência em um número;
\CAL
To convert a_ string to a_ number:
Put 0 into the number.
Slap a_ substring on the string.
If the substring is blank, exit.
If the substring's first's target is any sign, add 1 to the substring's first.
Loop.
If the substring is blank, break.
Multiply the number by 10.
Put the substring's first's target into another number.
Subtract 48 from the other number.
Add the other number to the number.
Add 1 to the substring's first.
Repeat.
If the string's first's target is the dash byte, negate the number.

\PAL
Para converter uma sequência em um número entre outro número e um terceiro número;
\CAL
To convert a_ string to a_ number between another number and a_ third number:
Convert the string to the number.
Limit the number to the other number and the third number.

To convert a_ string to a_ pdf string:
Put "(" into the pdf string.
Slap a_ substring on the string.
Subtract 1 from the substring's first.
Loop.
Add 1 to the substring's first.
If the substring is blank, break.
If the substring's first's target is the left-paren byte, append "\(" to the pdf string; repeat.
If the substring's first's target is the right-paren byte, append "\)" to the pdf string; repeat.
If the substring's first's target is the backslash byte, append "\\" to the pdf string; repeat.
Append the substring's first's target to the pdf string.
Repeat.
Append ")" to the pdf string.

\PAL
Para converter uma sequência em um ponteiro;
\CAL
To convert a_ string to a_ pointer: \ assumes pointer is in nibble format
Convert the string as_ a_ nibble string to a_ hex string.
Void the pointer.
Slap a_ substring on the hex string.
Put 24 into a_ shift count.
Loop.
If the substring is blank, exit.
If the shift count is less than 0, exit.
Put the substring's first's target into a_ number.
Shift the number left the shift count.
Bitwise or the pointer as_ a_ number with the number.
Add 1 to the substring's first.
Subtract 8 from the shift count.
Repeat.

\PAL
Para converter uma sequência em uma consulta;
\CAL
To convert a_ string to a_ query string:
Clear the query string.
Slap a_ substring on the string.
Loop.
If the substring is blank, break.
Convert the substring's first's target to a_ query byte.
Append the query byte to the query string.
Add 1 to the substring's first.
Repeat.

\PAL
Para converter uma sequência em algumas linhas;
\CAL
To convert a_ string to some rows:
Slap a_ rider on the string.
Loop.
Move the rider (text file rules).
If the rider's token is blank, break.
Create a_ row given the rider's token.
Append the row to the rows.
If the row's string's last's target is the linefeed byte, put the return byte into the row's string's last's target. \ *dahn new to handle lines terminated by just linefeed
Repeat.
Renumber the rows.

To convert a_ string to a_ uuid:
Convert the string to a_ wide string and null terminate.
Call "ole32.dll" "CLSIDFromString" with the wide string's first and the uuid's whereabouts.

To convert a_ string to a_ wide string:
Clear the wide string.
Slap a_ substring on the string.
Loop.
If the substring is blank, exit.
Append the substring's first's target to the wide string.
Append the null byte to the wide string.
Add 1 to the substring's first.
Repeat.

To convert a_ string to a_ wide string and null terminate:
Convert the string to the wide string.
Null terminate the wide string.

To convert a_ url to a_ url record:
Privatize the url.
Null terminate the url.
Put a_ urlcomponents' magnitude into the urlcomponents' dwstructsize.
Put 1 into the urlcomponents' dwschemelength.
Put 1 into the urlcomponents' dwhostnamelength.
Put 1 into the urlcomponents' dwurlpathlength.
Put 1 into the urlcomponents' dwextrainfolength.
Call "wininet.dll" "InternetCrackUrlA" with the url's first and 0 and 0 and the urlcomponents' whereabouts returning a_ number.
Convert the urlcomponents' lpszscheme and the urlcomponents' dwschemelength to the url record's scheme.
Convert the urlcomponents' lpszhostname and the urlcomponents' dwhostnamelength to the url record's host name.
Convert the urlcomponents' lpszurlpath and the urlcomponents' dwurlpathlength to the url record's path.
Convert the urlcomponents' lpszextrainfo and the urlcomponents' dwextrainfolength to the url record's extra.
Put the urlcomponents' nport into the url record's port number.

To convert a_ wyrd to a_ nibble string:
Split the wyrd into a_ byte and another byte.
Convert the byte to the nibble string.
Convert the other byte to another nibble string.
Append the other nibble string to the nibble string.

a_ coord is some twips.

\PAL
Para copiar bytes de um ponteiro para outro ponteiro dado um contador de bytes;
\CAL
To copy bytes from a_ pointer to another pointer for_ a_ byte count: \ copy handling overlap with 1 byte moves
Intel $8BB508000000. \ mov esi,[ebp+8] \ the pointer
Intel $8B36. \ mov esi,[esi]
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ the other pointer
Intel $8B3F. \ mov edi,[edi]
Intel $8B8D10000000. \ mov ecx,[ebp+16] \ the number
Intel $8B09. \ mov ecx,[ecx]
\ check for something to copy
Intel $81F900000000. \ cmp ecx,0
Intel $0F8E39000000. \ jle end
\ check for no overlap
Intel $3BF7. \ cmp esi,edi
Intel $0F8D24000000. \ jge forward
Intel $8BC6. \ mov eax,esi
Intel $03C1. \ add eax,ecx
Intel $3BC7. \ cmp eax,edi
Intel $0F8E18000000. \ jle forward
\ copy backward
Intel $03F1. \ add esi,ecx
Intel $4E. \ dec esi
Intel $03F9. \ add edi,ecx
Intel $4F. \ dec esi
\ backward
Intel $8A16. \ mov dl,[esi]
Intel $8817. \ mov [edi],dl
Intel $4E. \ dec esi
Intel $4F. \ dec edi
Intel $49. \ dec ecx
Intel $0F85F3FFFFFF. \ jnz backward
Intel $E90D000000. \ jmp end
\ forward: copy forward
Intel $8A16. \ mov dl,[esi]
Intel $8817. \ mov [edi],dl
Intel $46. \ inc esi
Intel $47. \ inc edi
Intel $49. \ dec ecx
Intel $0F85F3FFFFFF. \ jnz forward

\PAL
Para copiar um evento em outro evento;
Para copiar um evento para outro evento;
\CAL
To copy an event into another event:
If the event is nil, void the other event; exit.
Create the other event.
Put the event's kind into the other event's kind.
Put the event's shift flag into the other event's shift flag.
Put the event's ctrl flag into the other event's ctrl flag.
Put the event's alt flag into the other event's alt flag.
Put the event's spot into the other event's spot.
Put the event's key into the other event's key.
Put the event's byte into the other event's byte.

To copy a_ gpbitmap into another gpbitmap:
If the gpbitmap is nil, void the other gpbitmap; exit.
Call "gdiplus.dll" "GdipCloneBitmapAreaI" with 0 and 0 and the gpbitmap's width and the gpbitmap's height and 0 [pixelformatdontcare] and
The gpbitmap and the other gpbitmap's whereabouts.

To copy the guts of a_ text into another text:
If the text is nil, exit.
If the other text is nil, exit.
Put the text's box into the other text's box.
Put the text's origin into the other text's origin.
Put the text's pen into the other text's pen.
Put the text's font into the other text's font.
Put the text's alignment into the other text's alignment.
Copy the text's rows into the other text's rows.
Put the text's margin into the other text's margin.
Put the text's scale into the other text's scale.
Put the text's wrap flag into the other text's wrap flag.
Put the text's horizontal scroll flag into the other text's horizontal scroll flag.
Put the text's vertical scroll flag into the other text's vertical scroll flag.
Put the text's selection into the other text's selection.
Put the text's modified flag into the other text's modified flag.
Put the text's last operation into the other text's last operation.
\ don't copy undos and redos

a_ copy is a_ number.

\PAL
Para copiar uma imagem em outra imagem;
Para copiar uma imagem para outra imagem;
\CAL
To copy a_ picture into another picture:
If the picture is nil, void the other picture; exit.
Allocate memory for_ the other picture.
Put the picture's box into the other picture's box.
Put the picture's uncropped box into the other picture's uncropped box.
Put the picture's grayscale flag into the other picture's grayscale flag.
Put the picture's mirror flag into the other picture's mirror flag.
Put the picture's rotate angle into the other picture's rotate angle.
Put the picture's data into the other picture's data.
Copy the picture's gpbitmap into the other picture's gpbitmap.

\PAL
Para copiar um polígono em outro polígono;
Para copiar um polígono para outro polígono;
\CAL
To copy a_ polygon into another polygon:
If the polygon is nil, void the other polygon; exit.
Allocate memory for_ the other polygon.
Copy the polygon's vertices into the other polygon's vertices.

To copy a_ row into another row:
If the row is nil, void the other row; exit.
Allocate memory for_ the other row.
Put the row's row# into the other row's row#.
Put the row's string into the other row's string.

To copy some rows into some other rows:
Destroy the other rows.
Loop.
Get a_ row from the rows.
If the row is nil, exit.
Copy the row into another row.
Append the other row to the other rows.
Repeat.

\PAL
Para copiar um texto em outro texto;
Para copiar um texto para outro texto;
\CAL
To copy a_ text into another text:
If the text is nil, void the other text; exit.
Allocate memory for_ the other text.
Copy the guts of the text into the other text.

\PAL
Para copiar um vértice em outro vértice;
Para copiar um vértice para outro vértice;
\CAL
To copy a_ vertex into another vertex:
If the vertex is nil, void the other vertex; exit.
Allocate memory for_ the other vertex.
Put the vertex's x-coord into the other vertex's x-coord.
Put the vertex's y-coord into the other vertex's y-coord.

\PAL
Para copiar alguns vértices em alguns outros vértices;
Para copiar alguns vértices para alguns outros vértices;
\CAL
To copy some vertices into some other vertices:
Destroy the other vertices.
Loop.
Get a_ vertex from the vertices.
If the vertex is nil, exit.
Copy the vertex into another vertex.
Append the other vertex to the other vertices.
Repeat.

The copyright byte is a_ byte equal to 169.

a_ count is a_ number.

a_ counter is an number.

To create the connect handle of a_ winhttp request using  a_ url record:
If the winhttp request is nil, exit.
Convert the url record's host name into a_ wide string called wide host name and null terminate.
Call "winhttp.dll" "WinHttpConnect"
With the winhttp request's session
And the wide host name's first
And the url record's port
And 0
Returning the winhttp request's connection.
If the winhttp request's connection is 0, put "No se pudo conectar." into o erro de e/s; exit.

\PAL
Para criar um console;
\CAL
To create a_ console:
Allocate memory for_ the console.
Put the lighter gray color into the console's border.
Put the lighter gray color into the console's fill.
Put the screen's box into the console's box.
Put the screen's box into a_ box.
Subtract the default font's height from the box's bottom.
Put the box's height divided by the default font's height times the default font's height into a_ height.
Put the box's top plus the height into the box's bottom.
Center the box in the screen's box (vertically).
Put the box's top into the box's left.
Subtract the box's top from the box's right.
Create the console's text.
Put the box into the console's text's box.
Set the console's text's wrap flag.
Clear the console's text's horizontal scroll flag.
Set the console's text's vertical scroll flag.
Put the default font's height into the console's grid.
Multiply the console's grid's x-number by 2.

To create a_ crypt session with a_ passphrase string: \ sets i/o error if failure
Clear o erro de e/s.
Allocate memory for_ the crypt session.
\ acquire context
Call "advapi32.dll" "CryptAcquireContextA" with the crypt session's hcryptprov's whereabouts and 0 and "Microsoft Enhanced Cryptographic Provider v1.0"'s first 
And 1 [prov_rsa_full] and -268435456 [crypt_verifycontext] returning a_ result number.
If the result is 0, put "Não consegui adquirir o contexto." into o erro de e/s; destroy the crypt session; exit.
\ create hash
Call "advapi32.dll" "CryptCreateHash" with the crypt session's hcryptprov and 32771 [calg_md5] and 0 and 0 
And the crypt session's hcrypthash's whereabouts returning the result number.
If the result is 0, put "Não consegui criar o hash." into o erro de e/s; destroy the crypt session; exit.
\ hash passphrase
Call "advapi32.dll" "CryptHashData" with the crypt session's hcrypthash and the passphrase's first and the passphrase's length and 0 returning the result number.
If the result is 0, put "No pude hacer hash de la contraseña." into o erro de e/s; destroy the crypt session; exit.
\ derive session key
Call "advapi32.dll" "CryptDeriveKey" with the crypt session's hcryptprov and 26625 [calg_rc4 stream cipher] and the crypt session's hcrypthash 
And 8388608 [128 bit] and the crypt session's hcryptkey's whereabouts returning the result number.
If the result is 0, put "No pude derivar la clave de sesión." into o erro de e/s; destroy the crypt session; exit.

To create a_ dyad:
Allocate memory for_ the dyad.

\PAL
Para criar um evento;
\CAL
To create an event:
Allocate memory for_ the event.

To create a_ font info given a_ font:
Create the font info given the font (basic data).
Create the font info's font widths given the font.

To create a_ font info given a_ font (basic data):
Allocate memory for_ the font info.
Put the font into the font info's font.
Get an outlinetextmetric given the font.
Put 32 into the font info's flags. \ could be updated with a more information
Put the outlinetextmetric's otmtextmetrics' tminternalleading into the font info's internal leading.
Put the outlinetextmetric's otmemsquare into the font info's emsquare.
Put the outlinetextmetric's otmtextmetrics' tmascent into the font info's ascent.
Put - the outlinetextmetric's otmtextmetrics' tmdescent into the font info's descent.
Put the outlinetextmetric's otmscapemheight into the font info's capheight.
Put the outlinetextmetric's otmitalicangle into the font info's italicangle.
Put 0 into the font info's stemv. \ don't know where to get this from
Put the outlinetextmetric's otmrcfontbox into the font info's font box.

To create a_ font info given a_ font and a_ string: \ creates widths based on characters in string
Create the font info given the font (basic data).
Create the font info's font widths given the font and the string.

To create some font widths given a_ font:
Allocate memory for_ the font widths.
Put the font into the font widths' font.
Put 256 into the font widths' count.
Assign the font widths' data given the font widths' count times a_ number's magnitude.
Create the hfont of the memory canvas given the font.
Assign an original abc pointer given 256 times an abc's magnitude.
Call "gdi32.dll" "GetCharABCWidthsA" with the memory canvas and 0 and 255 and the original abc pointer.
Destroy the hfont of the memory canvas.
Put the original abc pointer into an abc pointer.
Put the font widths' data into a_ number pointer.
Loop.
If a_ counter is past 256, break.
Put the abc pointer's abca into the number pointer's target.
Add the abc pointer's abcb to the number pointer's target.
Add the abc pointer's abcc to the number pointer's target.
Add the abc's magnitude to the abc pointer.
Add the number's magnitude to the number pointer.
Repeat.
Unassign the original abc pointer.

To create some font widths given a_ font and a_ string:
Allocate memory for_ the font widths.
Put the font into the font widths' font.
Put the string's length into the font widths' count.
If the string is blank, exit.
Put a_ gcpresults' magnitude into the gcpresults' lstructsize.
Put the string's length into the gcpresults' nglyphs.
Assign the gcpresults' lpdx given the string's length times a_ number's magnitude.
Create the hfont of the memory canvas given the font.
Call "gdi32.dll" "GetCharacterPlacementA" with the memory canvas and the string's first
And the string's length and 0 and the gcpresults' whereabouts and 0.
Destroy the hfont of the memory canvas.
Put the gcpresults' lpdx into the font widths' data.

To create a_ gpbitmap given a_ buffer:
Clear o erro de e/s.
Call "kernel32.dll" "GlobalAlloc" with 2 [gmem_moveable] and the buffer's length returning a_ handle.
Call "kernel32.dll" "GlobalLock" with the handle returning a_ pointer.
Copy bytes from the buffer's first to the pointer for_ the buffer's length.
Call "kernel32.dll" "GlobalUnlock" with the handle.
Call "ole32.dll" "CreateStreamOnHGlobal" with the handle and 1 [true] and an istream's whereabouts.
Call "gdiplus.dll" "GdipCreateBitmapFromStream" with the istream and the gpbitmap's whereabouts returning a_ number.
If the number is not 0, put "No sé como procesar este tipo de imagen." into o erro de e/s; void the gpbitmap.
Call the istream's vtable's release with the istream.

To create a_ gpimageattributes (grayscale):
Call "gdiplus.dll" "GdipCreateImageAttributes" with the gpimageattributes' whereabouts.
Call "gdiplus.dll" "GdipSetImageAttributesColorMatrix" with the gpimageattributes and 0 [coloradjusttypedefault] and 1 
And the grayscale color matrix's first and 0 and 0 [colormatrixflagsdefault].

To create the hbrush of a_ canvas given a_ color:
Convert the color to a_ colorref.
If the color is clear, put the null hbrush into an hbrush. 
If the color is not clear, call "gdi32.dll" "CreateSolidBrush" with the colorref returning the hbrush.
Call "gdi32.dll" "SelectObject" with the canvas and the hbrush.

To create the hfont of a_ canvas given a_ font:
Convert the font to an hfont.
Call "gdi32.dll" "SelectObject" with the canvas and the hfont.

To create the hpen of a_ canvas given a_ color:
Convert the color to a_ colorref.
If the color is clear, put the null hpen into an hpen.
Put the tpp times the pen size into a_ number.
If the canvas is the printer canvas, put 1/96 inch times the pen size into the number.
If the color is not clear, call "gdi32.dll" "CreatePen" with 0 [ps_solid] and the number and the colorref returning the hpen. 
Call "gdi32.dll" "SelectObject" with the canvas and the hpen.

To create an hrgn given a_ box:
Privatize the box.
Add the tpp to the box's right-bottom.
Call "gdi32.dll" "BeginPath" with the current canvas.
Call "gdi32.dll" "Rectangle" with the current canvas and the box's left and the box's top and the box's right and the box's bottom.
Call "gdi32.dll" "EndPath" with the current canvas.
Call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

To create an hrgn given an ellipse:
Put the ellipse's box into a_ box.
Call "gdi32.dll" "BeginPath" with the current canvas.
Call "gdi32.dll" "Ellipse" with the current canvas and the box's left and the box's top and the box's right and the box's bottom.
Call "gdi32.dll" "EndPath" with the current canvas.
Call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

To create an hrgn given a_ polygon:
If the polygon is nil, put 0 into the hrgn; exit.
Create a_ vertex array given the polygon's vertices.
Call "gdi32.dll" "LPtoDP" with the current canvas and the vertex array's spot pointer and the vertex array's count.
Call "gdi32.dll" "CreatePolygonRgn" with the vertex array's spot pointer and the vertex array's count and 2 [winding] returning the hrgn.
Destroy the vertex array.

To create an hrgn given a_ roundy box:
If the roundy box's radius is 0, create the hrgn given the roundy box as_ a_ box; exit.
Put the roundy box into a_ box.
Put the roundy box's radius times 2 into a_ diameter number.
Call "gdi32.dll" "BeginPath" with the current canvas.
Call "gdi32.dll" "RoundRect" with the current canvas and the box's left and the box's top and the box's right and the box's bottom and the diameter and the diameter.
Call "gdi32.dll" "EndPath" with the current canvas.
Call "gdi32.dll" "PathToRegion" with the current canvas returning the hrgn.

\PAL
Para criar um índice dado um contador de cubos;
\CAL
To create an index given a_ bucket count:
Allocate memory for_ the index.
Put the bucket count into the index's bucket count.
Put a_ bucket record's magnitude into a_ width.
Put the index's bucket count times the width into a_ number.
Assign the index's first bucket given the number.
Put the index's first bucket plus the number minus the width into the index's last bucket.

\PAL
Para criar o léxico;
\CAL
To create the lexicon:
Allocate memory for_ the lexicon.
Create the lexicon's index given 4027.

To create the open handle of a_ winhttp request:
If the winhttp request is nil, exit.
Convert the module's name to a_ wide string called wide module name and null terminate.
Call "winhttp.dll" "WinHttpOpen"
With the wide module name's first
And 0 [winhttp_access_type_default_proxy] 
And 0 [winhttp_no_proxy_name] 
And 0 [winhttp_no_proxy_bypass] 
And 0 
Returning the winhttp request's session.
If the winhttp request's session is 0, put "No pude abrir la conexión." into o erro de e/s; exit.

\PAL
Para criar uma rota no sistema;
\CAL
To create a_ path in the file system:
If the path is directory-format, create the path in the file system (directory); exit.
If the path is file-format, create the path in the file system (file); exit.

\PAL
Para criar uma rota no sistema (pasta);
\CAL
To create a_ path in the file system (directory):
Privatize the path.
Remove any trailing backslash from the path.
Null terminate the path.
Call "kernel32.dll" "CreateDirectoryA" with the path's first and 0 returning a_ number.
Clear o erro de e/s.
If the number is not 0, exit.
Put "Error creando directorio '" then the path then "'." into o erro de e/s.

\PAL
Para criar uma rota no sistema (arquivo);
\CAL
To create a_ path in the file system (file):
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "CreateFileA" with the path's first and 1073741824 [generic_write] and 0 and 0 and 1 [create_new] and 128 [file_attribute_normal] and 0 returning a_ handle.
Call "kernel32.dll" "CloseHandle" with the handle.
Clear o erro de e/s.
If the handle is not -1 [invalid_handle_value], exit.
Put "Error creando archivo '" then the path then "'." into o erro de e/s.

To create a_ pdf object given a_ kind:
Allocate memory for_ the pdf object.
Put the kind into the pdf object's kind.

To create a_ pdf outline entry given a_ title string and a_ page height and a_ destination number:
Allocate memory for_ the pdf outline entry.
Put the title string into the pdf outline entry's title.
Put the page height into the pdf outline entry's page height.
Put the destination into the pdf outline entry's destination.

\PAL
Para criar uma imagem;
\CAL
To create a_ picture:
Allocate memory for_ the picture.

\PAL
Para criar uma imagem dado um depósito;
\CAL
To create a_ picture given a_ buffer:
Create a_ gpbitmap given the buffer.
If the gpbitmap is nil, void the picture; exit.
Allocate memory for_ the picture.
Put the buffer into the picture's data.
Put the gpbitmap into the picture's gpbitmap.
Adjust the picture (extract boxes from gpbitmap).

To create a_ picture given a_ gpbitmap:
If the gpbitmap is nil, void the picture; exit.
Allocate memory for_ the picture.
Put the gpbitmap into the picture's gpbitmap.
Adjust the picture (extract boxes from gpbitmap).

\PAL
Para criar uma imagem dada uma URL;
\CAL
To create a_ picture given a_ url:
Read the url into a_ buffer.
Create the picture given the buffer.

\PAL
Para criar um polígono;
\CAL
To create a_ polygon:
Allocate memory for_ the polygon.

\PAL
Para criar uma quora;
\CAL
To create a_ quora:
Allocate memory for_ the quora.

\PAL
Para criar uma referência;
\CAL
To create a_ refer:
Allocate memory for_ the refer.

To create the request handle of a_ winhttp request using a_ url record:
If the winhttp request is nil, exit.
Convert the url record's path into a_ wide string called wide path and null terminate.
Convert "POST" to a_ wide string called wide post string and null terminate.
If the url record's scheme is "https", put 8388608 [winhttp_flag_secure] into a_ secure number.
Call "winhttp.dll" "WinHttpOpenRequest"
With the winhttp request's connection
And the wide post string's first
And the wide path's first
And 0 [L"HTTP/1.1"] 
And 0 [winhttp_no_referer]
And 0 [winhttp_default_accept_types]
And the secure number
Returning the winhttp request's request.
If the winhttp request's request is 0, put "No pude abrir el pedido." into o erro de e/s; exit.

To create a_ row given a_ byte:
Allocate memory for_ the row.
Put the byte into the row's string.

To create a_ row given a_ string:
Allocate memory for_ the row.
Put the string into the row's string.

To create a_ socket given a_ host string and a_ port number: \ this guy creates and connects, sets i/o error if there is a problem
Clear o erro de e/s.
\ get sockaddr
Get a_ sockaddr given the host.
If o erro de e/s is not blank, exit.
Put 2 [af_inet] into the sockaddr's sin_family.
Put the port into the sockaddr's sin_port.
\ create socket  
Call "ws2_32.dll" "socket" with 2 [af_inet] and 1 [sock_stream] and 0 [ipproto_ip] returning the socket.
If the socket is -1, put "No pude crear socket." into o erro de e/s; exit.
\ connect socket
Call "ws2_32.dll" "connect" with the socket and the sockaddr's whereabouts and the sockaddr's magnitude returning a_ result number.
If the result is not 0, put "No pude conectar al socket." into o erro de e/s; exit.
\ set send timeout 30 seconds
Call "ws2_32.dll" "setsockopt" with the socket and 65535 and 4101 [so_sndtimo] and 30 seconds' whereabouts and 4 returning the result number.
If the result is not 0, put "No pudo configurar el tiempo de espera de recepción." into o erro de e/s; exit.
\ set receive timeout 30 seconds
Call "ws2_32.dll" "setsockopt" with the socket and 65535 and 4102 [so_rcvtimeo] and 30 seconds' whereabouts and 4 returning the result number.
If the result is not 0, put "No pudo configurar el tiempo de espera de recepción." into o erro de e/s; exit.

\PAL
Para criar um elemento de sequência dada uma sequência;
\CAL
To create a_ string thing given a_ string:
Allocate memory for_ the string thing.
Put the string into the string thing's string.

\PAL
Para criar um terminal em uma caixa;
\CAL
To create a_ terminal in a_ box:
Allocate memory for_ the terminal.
Put the box into the terminal's box.
Put the green color into the terminal's output color.
Put the lightest green color into the terminal's input color.

\PAL
Para criar um texto;
\CAL
To create a_ text:
Allocate memory for_ the text.
Put the black color into the text's pen.
Put the default font into the text's font.
Put "left" into the text's alignment.
Put 1/1 into the text's scale.
Guarantee one row in the text.
Reset the origin of the text.
Reset the caret of the text.
Deselect the text.

\PAL
Para criar um vértice;
\CAL
To create a_ vertex:
Allocate memory for_ the vertex.

To create a_ vertex array given a_ count:
Privatize the count.
Allocate memory for_ the vertex array.
Put the count into the vertex array's count.
Multiply the count by a_ spot's magnitude.
Assign the vertex array's spot pointer given the count.

To create a_ vertex array given some vertices:
Create the vertex array given the vertices' count.
Put the vertex array's spot pointer into a_ spot pointer.
Loop.
Get a_ vertex from the vertices.
If the vertex is nil, exit.
Put the vertex's spot into the spot pointer's target.
Add the vertex's spot's magnitude to the spot pointer.
Repeat.

\PAL
Para criar um vértice dado um loco;
\CAL
To create a_ vertex given a_ spot:
Allocate memory for_ the vertex.
Put the spot into the vertex's spot.

\PAL
Para criar um vértice dado uma coordenada-x e uma coordenada-y;
\CAL
To create a_ vertex given an x-coord and a_ y-coord:
Allocate memory for_ the vertex.
Put the x-coord into the vertex's x-coord.
Put the y-coord into the vertex's y-coord.

To create a_ winhttp request for_ posting to a_ url:
Allocate memory for_ the winhttp request.
Convert the url to a_ url record.
Create the open handle of the winhttp request.
If o erro de e/s is not blank, destroy the winhttp request; exit.
Create the connect handle of the winhttp request using the url record.
If o erro de e/s is not blank, destroy the winhttp request; exit.
Create the request handle of the winhttp request using the url record.
If o erro de e/s is not blank, destroy the winhttp request; exit.

The console is a_ console.

The crlf string is a_ string equal to $0D0A.

The cross byte is a_ byte equal to 43.

a_ crypt session is a_ thing with
An hcryptprov pointer,
An hcrypthash pointer,
An hcryptkey pointer.

The ctrl key is a_ key equal to 17.

The currency-sign byte is a_ byte equal to 164.

The current canvas is a_ canvas.

The current event is an event.

The current rainbow color number is a_ number [1 to 6 indicating, respectively, red, orange, yellow, green, blue, purple].

a_ cursor is a_ handle.

To cut a_ number in half:
Divide the number by 2.

The cyan color is a_ color.

The cyan pen is a_ pen.

The d-key is a_ key equal to 68.

The dagger byte is a_ byte equal to 134.

The dark blue color is a_ color.

The dark blue pen is a_ pen.

The dark brown color is a_ color.

The dark brown pen is a_ pen.

a_ dark color is a_ color.

The dark cyan color is a_ color.

The dark cyan pen is a_ pen.

The dark gray color is a_ color.

The dark gray pen is a_ pen.

The dark green color is a_ color.

The dark green pen is a_ pen.

The dark lime color is a_ color.

The dark lime pen is a_ pen.

The dark magenta color is a_ color.

The dark magenta pen is a_ pen.

The dark orange color is a_ color.

The dark orange pen is a_ pen.

The dark pink color is a_ color.

The dark pink pen is a_ pen.

The dark purple color is a_ color.

The dark purple pen is a_ pen.

The dark red color is a_ color.

The dark red pen is a_ pen.

The dark sky blue color is a_ color.

The dark sky blue pen is a_ pen.

The dark sky color is a_ color.

The dark sky pen is a_ pen.

The dark teal color is a_ color.

The dark teal pen is a_ pen.

The dark violet color is a_ color.

The dark violet pen is a_ pen.

The dark yellow color is a_ color.

The dark yellow pen is a_ pen.

\PAL
Para escurecer uma cor em uma quantidade;
\CAL
To darken a_ color by an amount:
Subtract the amount from the color's lightness.
Limit the color's lightness to 0 and 1000.

\PAL
Para escurecer uma cor em uma porcentagem;
\CAL
To darken a_ color by some percent;
To darken a_ color about some percent;
To darken a_ color by about some percent;
To darken a_ color some percent:
Put the color's lightness minus the percent into the color's lightness.
Limit the color's lightness to 0 and 1000.

\PAL
Para escurecer a cor atual em uma porcentagem;
\CAL
To darken the current color about some percent:
Darken the context's color by the percent.

The darker blue color is a_ color.

The darker blue pen is a_ pen.

The darker brown color is a_ color.

The darker brown pen is a_ pen.

The darker cyan color is a_ color.

The darker cyan pen is a_ pen.

The darker gray color is a_ color.

The darker gray pen is a_ pen.

The darker green color is a_ color.

The darker green pen is a_ pen.

The darker lime color is a_ color.

The darker lime pen is a_ pen.

The darker magenta color is a_ color.

The darker magenta pen is a_ pen.

The darker orange color is a_ color.

The darker orange pen is a_ pen.

The darker purple color is a_ color.

The darker purple pen is a_ pen.

The darker red color is a_ color.

The darker red pen is a_ pen.

The darker sky blue color is a_ color.

The darker sky blue pen is a_ pen.

The darker sky color is a_ color.

The darker sky pen is a_ pen.

The darker teal color is a_ color.

The darker teal pen is a_ pen.

The darker violet color is a_ color.

The darker violet pen is a_ pen.

The darker yellow color is a_ color.

The darker yellow pen is a_ pen.

The darkest blue color is a_ color.

The darkest blue pen is a_ pen.

The darkest brown color is a_ color.

The darkest brown pen is a_ pen.

The darkest cyan color is a_ color.

The darkest cyan pen is a_ pen.

The darkest gray color is a_ color.

The darkest gray pen is a_ pen.

The darkest green color is a_ color.

The darkest green pen is a_ pen.

The darkest lime color is a_ color.

The darkest lime pen is a_ pen.

The darkest magenta color is a_ color.

The darkest magenta pen is a_ pen.

The darkest orange color is a_ color.

The darkest orange pen is a_ pen.

The darkest purple color is a_ color.

The darkest purple pen is a_ pen.

The darkest red color is a_ color.

The darkest red pen is a_ pen.

The darkest sky blue color is a_ color.

The darkest sky blue pen is a_ pen.

The darkest sky color is a_ color.

The darkest sky pen is a_ pen.

The darkest teal color is a_ color.

The darkest teal pen is a_ pen.

The darkest violet color is a_ color.

The darkest violet pen is a_ pen.

The darkest yellow color is a_ color.

The darkest yellow pen is a_ pen.

The dash byte is a_ byte equal to 45.

The dash key is a_ key equal to 189.

The data-link-escape byte is a_ byte equal to 16.

a_ date/time has
a_ year number,
a_ month number,
a_ week day number,
a_ day number,
An hour number,
a_ minute number,
a_ second number,
a_ millisecond number.

\PAL
Para dessinalar uma fração;
Para eliminar o sinal de uma fração;
\CAL
To de-sign a_ fraction:
De-sign the fraction's numerator.
De-sign the fraction's denominator.

\PAL
Para dessinalar um número;
Para eliminar o sinal de um número;
\CAL
To de-sign a_ number:
If the number is the smallest number, put the largest number into the number; exit.
If the number is less than 0, negate the number.

\PAL
Para dessinalar um par;
Para eliminar o sinal de um par;
\CAL
To de-sign a_ pair:
De-sign the pair's x-number.
De-sign the pair's y-number.

\PAL
Para dessinalar uma sequência;
Para eliminar o sinal de uma sequência;
Para eliminar o sinal em uma sequência;
\CAL
To de-sign a_ string:
If the string is blank, exit.
If the string's first's target is any sign, remove the first byte from the string.

\PAL
Para depurar uma caixa;
\CAL
To debug a_ box:
Clear a_ string.
Append "izquierda=" to the string.
Append the box's left to the string.
Append ", superior=" to the string.
Append the box's top to the string.
Append ", derecho=" to the string.
Append the box's right to the string.
Append ", inferior=" to the string.
Append the box's bottom to the string.
Debug the string.

\PAL
Para depurar um byte;
\CAL
To debug a_ byte:
Put the byte into a_ number.
Convert the number to a_ string.
Debug the string.

\PAL
Para depurar uma cor;
\CAL
To debug a_ color:
Clear a_ string.
Append "matiz=" to the string.
Append the color's hue to the string.
Append ", saturación=" to the string.
Append the color's saturation to the string.
Append ", luminosidade=" to the string.
Append the color's lightness to the string.
Debug the string.

\PAL
Para depurar uma signa;
\CAL
To debug a_ flag:
Convert the flag to a_ string.
Debug the string.

\PAL
Para depurar uma fonte;
\CAL
To debug a_ font:
Clear a_ string.
Append "nombre='" to the string then "'".
Append the font's name to the string.
Append ", altura=" to the string.
Append the font's height to the string.
Debug the string.

\PAL
Para depurar uma fração;
\CAL
To debug a_ fraction:
Clear a_ string.
Append "numerador=" to the string.
Append the fraction's numerator to the string.
Append ", denominador=" to the string.
Append the fraction's denominator to the string.
Debug the string.

\PAL
Para depurar uma reta;
\CAL
To debug a_ line:
Clear a_ string.
Append "começo=" to the string.
Append the line's start's x-coord to the string.
Append "," to the string.
Append the line's start's y-coord to the string.
Append " fim=" to the string.
Append the line's end's x-coord to the string.
Append "," to the string.
Append the line's end's y-coord to the string.
Debug the string.

\PAL
Para depurar um número;
\CAL
To debug a_ number:
Convert the number to a_ string.
Debug the string.

\PAL
Para depurar um número e outro número;
\CAL
To debug a_ number and another number:
Debug the number then ", " then the other number.

\PAL
Para depurar um par;
\CAL
To debug a_ pair:
Clear a_ string.
Append "x=" to the string.
Append the pair's x-number to the string.
Append ", y=" to the string.
Append the pair's y-number to the string.
Debug the string.

\PAL
Para depurar um ponteiro;
\CAL
To debug a_ pointer:
Convert the pointer to a_ nibble string.
Debug "$" then the nibble string.

To debug a_ rgb:
Clear a_ string.
Append "red=" to the string.
Put the rgb's red byte into a_ number.
Append the number to the string.
Append ", green=" to the string.
Put the rgb's green byte into the number.
Append the number to the string.
Append ", blue=" to the string.
Put the rgb's blue byte into the number.
Append the number to the string.
Debug the string.

\PAL
Para depurar uma sequência;
\CAL
To debug a_ string:
Privatize the string.
Null terminate the string.
Call "user32.dll" "MessageBoxA" with 0 and the string's first and "debug"'s first and 0.

\PAL
Para depurar uma sequência (entre aspas);
\CAL
To debug a_ string (quoted):
Privatize the string.
Prepend the double-quote byte to the string.
Append the double-quote byte to the string.
Debug the string.

\PAL
Para depurar uma wyrd;
\CAL
To debug a_ wyrd:
Put the wyrd into a_ number.
Convert the number to a_ string.
Debug the string.

\PAL
Para decidir se uma caixa é outra caixa;
\CAL
To decide if a_ box is another box:
If the box's left is not the other box's left, say no.
If the box's top is not the other box's top, say no.
If the box's right is not the other box's right, say no.
If the box's bottom is not the other box's bottom, say no.
Say yes.

\PAL
Para decidir se uma caixa está dentro de outra caixa;
\CAL
To decide if a_ box is still in another box;
To decide if a_ box is in another box;
To decide if a_ box is inside another box:
If the box's left is less than the other box's left, say no.
If the box's top is less than the other box's top, say no.
If the box's right is greater than the other box's right, say no.
If the box's bottom is greater than the other box's bottom, say no.
Say yes.

\PAL
Para decidir se uma caixa está tocando outra caixa;
\CAL
To decide if a_ box is touching another box:
If the other box's right is less than the box's left, say no.
If the other box's bottom is less than the box's top, say no.
If the other box's left is greater than the box's right, say no.
If the other box's top is greater than the box's bottom, say no.
Say yes.

\PAL
Para decidir se um byte é alfanumérico;
\CAL
To decide if a_ byte is alphanumeric:
If the byte is any letter, say yes.
If the byte is any digit, say yes.
Say no.

\PAL
\Para decidir se um byte é outro byte;
\CAL
To decide if a_ byte is another byte:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8406000000. \ je over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
\Para decidir se um byte é outro byte ou um terceiro byte;
\CAL
To decide if a_ byte is another byte or a_ third byte:
If the byte is the other byte, say yes.
If the byte is the third byte, say yes.
Say no.

\PAL
Para decidir se um byte é qualquer consoante;
\CAL
To decide if a_ byte is any consonant:
If the byte is in "bcdfghjklmnpqrstvwxyzç", say yes.
Say no.

\PAL
Para decidir se um byte é qualquer dígito;
\CAL
To decide if a_ byte is any digit:
If the byte is less than the zero byte, say no.
If the byte is greater than the nine byte, say no.
Say yes.

\PAL
Para decidir se um byte é qualquer letra;
\CAL
To decide if a_ byte is any letter:
If the byte is between the big-a byte and the big-z byte, say yes.
If the byte is between the little-a byte and the little-z byte, say yes.
If the byte is 131 or 138, say yes. 
If the byte is 140 or 142, say yes. 
If the byte is 154 or 156, say yes. 
If the byte is between 158 and 159, say yes.
If the byte is between 192 and 214, say yes.
If the byte is between 216 and 246, say yes.
If the byte is between 248 and 255, say yes.
Say no.

\PAL
Para decidir se um byte é qualquer iniciador numérico;
Para decidir se um byte é qualquer início numérico;
\CAL
To decide if a_ byte is any numeric starter:
If the byte is any digit, say yes.
If the byte is any sign, say yes.
Say no.

\PAL
Para decidir se um byte é qualquer pontuação;
\CAL
To decide if a_ byte is any punctuation mark: \ *** questionable?
If the byte is the space byte, say no.
If the byte is not alphanumeric, say yes.
Say no.

\PAL
Para decidir se um byte é qualquer sinal;
\CAL
To decide if a_ byte is any sign:
If the byte is the dash byte, say yes.
If the byte is the cross byte, say yes.
Say no.

\PAL
Para decidir se um byte é qualquer disco válido;
\CAL
To decide if a_ byte is any valid drive:
Put the byte into a_ path.
Append ":\" to the path.
Get a_ drive kind for_ the path.
If the drive kind is "", say no.
Say yes.

\PAL
Para decidir se um byte é qualquer vogal;
\CAL
To decide if a_ byte is any vowel:
If the byte is in "aeiou", say yes.
\  if the byte is "y", say sometimes. \ ha ha ha
Say no.

\PAL
Para decidir se um byte está entre outro bye e um terceiro byte;
Para decidir se um byte se encontra entre outro bye e um terceiro byte;
\CAL
To decide if a_ byte is between another byte and a_ third byte:
If the byte is less than the other byte, say no.
If the byte is greater than the third byte, say no.
Say yes.

\PAL
Para decidir se um byte está entre um número e outro número;
Para decidir se um byte se encontra entre um número e outro número;
\CAL
To decide if a_ byte is between a_ number and another number:
If the byte is less than the number, say no.
If the byte is greater than the other number, say no.
Say yes.

\PAL
Para decidir se um byte é maior que outro byte;
\CAL
To decide if a_ byte is greater than another byte:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8706000000. \ ja over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's falseS

\PAL
Para decidir se um byte é maior que um número;
\CAL
To decide if a_ byte is greater than a_ number:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the number
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8F06000000. \ jg over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um byte é maior ou igual a outro byte;
Para decidir se um byte é outro byte ou maior;
Para decidir se um byte é outro byte ou mais;
\CAL
To decide if a_ byte is greater than or equal to another byte:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8306000000. \ ja over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um byte está numa sequência;
Para decidir se um byte se encontra em uma sequência;
\CAL
To decide if a_ byte is in a_ string:
Privatize the byte.
Lowercase the byte.
Slap a_ substring on the string.
Loop.
If the substring is blank, say no.
Put the substring's first's target into another byte.
Lowercase the other byte.
If the other byte is the byte, say yes.
Add 1 to the substring's first.
Repeat.

\PAL
Para decidir se um byte é menor que outro byte;
\CAL
To decide if a_ byte is less than another byte:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8206000000. \ jb over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um byte é menor que um número;
\CAL
To decide if a_ byte is less than a_ number:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the number
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8C06000000. \ jl over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um byte é menor ou igual a outro byte;
Para decidir se um byte é outro byte ou menor;
Para decidir se um byte é outro byte ou menos;
\CAL
To decide if a_ byte is less than or equal to another byte:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $8A1B. \ mov bl,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other byte
Intel $3A19. \ cmp bl,[ecx]
Intel $0F8606000000. \ jbe over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um byte é parecido com outro byte;
Para decidir se um byte se parece com outro byte;
\CAL
To decide if a_ byte is like another byte: \ used internally for word wrap
If the byte is whitespace, set a_ flag.
If the other byte is whitespace, set another flag.
If the flag is the other flag, say yes.
Say no.

\PAL
Para decidir se um byte é ruído;
\CAL
To decide if a_ byte is noise:
If the byte is less than or equal to the space byte, say yes.
If the byte is the delete byte, say yes.
If the byte is the non-breaking-space byte, say yes.
If the byte is 129, say yes.
If the byte is 141, say  yes.
If the byte is 143, say yes.
If the byte is 144, say yes.
If the byte is 157, say yes.
Say no.

\PAL
Para decidir se um byte é um número;
\CAL
To decide if a_ byte is a_ number:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $0FB61B. \ movzx ebx,byte ptr [ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the number
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8406000000. \ je over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um byte é um número ou outro número;
\CAL
To decide if a_ byte is a_ number or another number:
If the byte is the number, say yes.
If the byte is the other number, say yes.
Say no.

\PAL
Para decidir se um byte é imprimível;
Para decidir se um byte pode ser impresso;
\CAL
To decide if a_ byte is printable:
If the byte is less than the space byte, say no.
If the byte is the delete byte, say no.
If the byte is 129, say no.
If the byte is 141, say no.
If the byte is 143, say no.
If the byte is 144, say no.
If the byte is 157, say no.
Say yes.

\PAL
Para decidir se um byte é uma sequência;
\CAL
To decide if a_ byte is a_ string:
If the string's length is not 1, say no.
Privatize the byte.
Lowercase the byte.
Put the string's first's target into another byte.
Lowercase the other byte.
If the byte is the other byte, say yes.
Say no.

\PAL
Para decidir se um byte é simbólico;
\CAL
To decide if a_ byte is symbolic:
If the byte is between the exclamation byte and the slash byte, say yes.
If the byte is between the colon byte and the at-sign byte, say yes.
If the byte is between the left-bracket byte and the accent byte, say yes.
If the byte is between the left-brace byte and the tilde byte, say yes.
If the byte is 128, say yes.
If the byte is 130, say yes.
If the byte is between 132 and 137, say yes.
If the byte is 139, say yes.
If the byte is between 145 and 153, say yes.
If the byte is 155, say yes.
If the byte is between 161 and 180, say yes.
If the byte is between 183 and 191, say yes.
If the byte is 215, say yes.
If the byte is 247, say yes.
Say no.

\PAL
Para decidir se um byte é espaço em branco;
\CAL
To decide if a_ byte is whitespace:
If the byte is the space byte, say yes.
If the byte is the tab byte, say yes.
If the byte is the return byte, say yes.
If the byte is the linefeed byte, say yes.
Say no.

To decide if the caret of a_ text is at the beginning:
If the text is nil, say no.
If the text's caret row# is not 1, say no.
If the text's caret column# is not 1, say no.
Say yes.

To decide if the caret of a_ text is at the end:
If the text is nil, say no.
If the text's caret row# is not the text's rows' count, say no.
Get a_ row given the text's caret row# and the text.
If the text's caret column# is not the row's string's length, say no.
Say yes.

To decide if the caret of a_ text is on the first line:
If the text is nil, say no.
If the text's caret row# is not 1, say no.
Say yes.

To decide if the caret of a_ text is on the last line:
If the text is nil, say  no.
If the text's rows are empty, say no.
If the text's caret row# is not the text's last row's row#, say no.
Say yes.

\PAL
Para decidir se uma escolha é uma sequência;
\CAL
To decide if a_ choice is a_ string:
If the choice is nil, say no.
If the choice's name is the string, say yes.
Say no.

\PAL
Para decidir se uma cor e outra cor estão limpas;
Para decidir se uma cor e outra cor estão apagadas;
Para decidir se um tom e outro tom estão limpos;
Para decidir se um tom e outro tom estão apagados;
\CAL
To decide if a_ color and another color are clear:
If the color is not clear, say no.
If the other color is not clear, say no.
Say yes.

\PAL
Para decidir se uma cor é outra cor;
\CAL
To decide if a_ color is another color:
If the color's hue is not the other color's hue, say no.
If the color's saturation is not the other color's saturation, say no.
If the color's lightness is not the other color's lightness, say no.
Say yes.

\PAL
Para decidir se uma cor está limpa;
Para decidir se uma cor está apagada;
Para decidir se um tom está limpo;
Para decidir se um tom está apagado;
\CAL
To decide if a_ color is clear:
If the color's hue is less than 0, say yes.
Say no.

\PAL
Para decidir se uma cor é escura;
Para decidir se um tom é escuro;
\CAL
To decide if a_ color is dark:
If the color's lightness is between 250 and 374, say yes.
Say no.

\PAL
Para decidir se uma cor é clara;
Para decidir se um tom é claro;
\CAL
To decide if a_ color is light:
If the color's lightness is between 625 and 749, say yes.
Say no.

\PAL
Para decidir se uma cor é normal;
Para decidir se uma cor é média;
Para decidir se uma cor é mediana;
Para decidir se uma cor é regular;
Para decidir se um tom é médio;
Para decidir se um tom é mediano;
\CAL
To decide if a_ color is normal:
If the color's lightness is between 375 and 624, say yes.
Say no.

\PAL
Para decidir se uma cor é muito escura;
Para decidir se um tom é muito escuro;
\CAL
To decide if a_ color is very dark:
If the color's lightness is between 125 and 249, say yes.
Say no.

\PAL
Para decidir se uma cor é muito clara;
Para decidir se um tom é muito claro;
\CAL
To decide if a_ color is very light:
If the color's lightness is between 750 and 874, say yes.
Say no.

\PAL
Para decidir se uma cor é escuríssima;
Para decidir se um tom é escuríssimo;
\CAL
To decide if a_ color is very very dark:
If the color's lightness is less than or equal to 124, say yes.
Say no.

\PAL
Para decidir se uma cor é claríssima;
Para decidir se um tom é claríssimo;
\CAL
To decide if a_ color is very very light:
If the color's lightness is greater than or equal to 875, say yes.
Say no.

\PAL
Para decidir se um contador supera um número;
Para decidir se um contador passa de um número;
Para decidir se um contador ultrapassa um número;
\CAL
To decide if a_ counter is past a_ number:
Add 1 to the counter.
If the counter is greater than the number, say yes.
Say no.

\PAL
Para decidir se o loco atual está acima ou abaixo de uma caixa;
\CAL
To decide if the current spot is above or below a_ box:
If the context's spot is above or below the box, say yes.
Say no.

\PAL
Para decidir se o loco atual está à esquerda ou à direita de uma caixa;
\CAL
To decide if the current spot is left or right of a_ box:
If the context's spot is left or right of the box, say yes.
Say no.

\PAL
Para decidir se o loco atual está à direita de uma caixa;
\CAL
To decide if the current spot is to the right of a_ box:
If the context's spot's x-coord is greater than the box's right, say yes.
Say no.

\PAL
Para decidir se o loco atual está dentro de alguns twips de uma caixa;
\CAL
To decide if the current spot is within some twips of a_ box:
If the context's spot is within the twips of the box, say yes.
Say no.

\PAL
Para decidir se uma diferença está dentro de uma grade;
\CAL
To decide if a_ difference is within a_ grid:
Privatize the difference.
De-sign the difference.
If the difference's x-number is greater than or equal to the grid's x-number, say no.
If the difference's y-number is greater than or equal to the grid's y-number, say no.
Say yes.

\PAL
Para decidir se um evento é qualquer atalho;
\CAL
To decide if an event is any shortcut:
If the event is nil, say no.
If the event's kind is not "key down", say no.
If the event is not modified, say no.
If the event's key is between the a-key and the z-key, say yes.
Say no.

\PAL
Para decidir se um evento está modificado;
\CAL
To decide if an event is modified:
If the event's ctrl flag is set, say yes.
If the event's alt flag is set, say yes.
Say no.

To decide if a_ finger is past the end of a_ string:
If the finger is nil, say yes.
If the finger is greater than the string's last, say yes.
Say no.

\PAL
Para decidir se uma signa é um número;
Para decidir se uma signa é outra signa;
Para decidir se um ponteiro é um número;
Para decidir se um ponteiro é outro ponteiro;
Para decidir se um número é outro número;
\CAL
To decide if a_ flag is a_ number;
To decide if a_ flag is another flag;
To decide if a_ pointer is a_ number;
To decide if a_ pointer is another pointer;
To decide if a_ number is another number:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8406000000. \ je over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\To decide if a_ flag is on: \ switch as another name for flag also ?  ***
\If the flag is set, say yes.
\Say no.

\PAL
Para decidir se uma signa está ligada;
Para decidir se um sinalizador está ligado;
\CAL
To decide if a_ flag is set:
If the flag is 1, say yes.
Say no.

\PAL
Para decidir se uma fração é outra fração;
\CAL
To decide if a_ fraction is another fraction:
Privatize the fraction.
Privatize the other fraction.
Normalize the fraction and the other fraction.
If the fraction's numerator is the other fraction's numerator, say yes.
Say no.

\PAL
Para decidir se uma fração é maior que outra fração;
\CAL
To decide if a_ fraction is greater than another fraction:
Privatize the fraction.
Privatize the other fraction.
Normalize the fraction and the other fraction.
If the fraction's numerator is greater than the other fraction's numerator, say yes.
Say no.

\PAL
Para decidir se uma fração é maior ou igual a outra fração;
\CAL
To decide if a_ fraction is greater than or equal to another fraction:
Privatize the fraction.
Privatize the other fraction.
Normalize the fraction and the other fraction.
If the fraction's numerator is greater than or equal to the other fraction's numerator, say yes.
Say no.

\PAL
Para decidir se uma fração é menor que outra fração;
\CAL
To decide if a_ fraction is less than another fraction:
Privatize the fraction.
Privatize the other fraction.
Normalize the fraction and the other fraction.
If the fraction's numerator is less than the other fraction's numerator, say yes.
Say no.

\PAL
Para decidir se uma fração é menor ou igual a outra fração;
\CAL
To decide if a_ fraction is less than or equal to another fraction:
Privatize the fraction.
Privatize the other fraction.
Normalize the fraction and the other fraction.
If the fraction's numerator is less than or equal to the other fraction's numerator, say yes.
Say no.

\PAL
Para decidir se uma fração é negativa;
\CAL
To decide if a_ fraction is negative:
If the fraction's numerator is less than 0, reverse a_ flag.
If the fraction's denominator is less than 0, reverse the flag.
\ Say the flag. \ doesn't work in SAL; no flag literals anymore
If the flag is set, say yes.
Say no.

\PAL
Para decidir se uma fração é um número;
\CAL
To decide if a_ fraction is a_ number:
If the fraction is the number / 1, say yes.
Say no.

\PAL
Para decidir se um índice está vazio;
Para decidir se um índice está vazia;
\CAL
To decide if an index is empty:
If the index is nil, say yes.
Loop.
Get a_ bucket given the index.
If the bucket is nil, say yes.
If the bucket's refers are not empty, say no.
Repeat.

To decide if an input is from windows telling us to refresh the cursor;
To decide if an input is from windows telling us to set the cursor:
If the input is nil, say no.
If the input's kind is "set cursor", say yes.
Say no.

To decide if an input is from windows telling us to show all our stuff;
To decide if an input is from windows telling us to show all of our stuff;
To decide if an input is from windows telling us to redraw all our stuff;
To decide if an input is from windows telling us to redraw all of our stuff:
If the input is nil, say no.
If the input's kind is "refresh", say yes.
Say no.

To decide if an input is from windows telling us we're done;
To decide if an input is from windows telling us that we're done;
To decide if an input is from windows telling us the user has quit:
If the input is nil, say yes.
Say no.

To decide if an input is a_ left click:
Void the left click.
If the input's kind is not "left click", say no.
Put the input into the left click.

\PAL
Para decidir se existe um item;
Para decidir se um item existe;
Para decidir se um item foi encontrado;
\CAL
To decide if an item is found:
If the item's kind is not blank, say yes.
Say no.

\PAL
Para decidir se uma tecla é qualquer dígito;
Para decidir se uma tecla é qualquer tecla de dígito;
\CAL
To decide if a_ key is any digit key:
If the key is between 48 and 57, say yes.
Say no.

\PAL
Para decidir se uma tecla é qualquer letra;
Para decidir se uma tecla é qualquer tecla de letra;
\CAL
To decide if a_ key is any letter key:
If the key is between 65 and 90, say yes.
Say no.

\PAL
Para decidir se uma tecla é qualquer modificadora;
Para decidir se uma tecla é qualquer tecla modificadora;
\CAL
To decide if a_ key is any modifier key:
If the key is the alt key, say yes.
If the key is the ctrl key, say yes.
If the key is the shift key ,say yes.
Say no.

\PAL
Para decidir se uma tecla é qualquer pad;
Para decidir se uma tecla é qualquer tecla pad;
Para decidir se uma tecla é qualquer tecla de pad;
\CAL
To decide if a_ key is any pad key:
If the key is between 96 and 111, say yes.
Say no.

\PAL
Para decidir se uma tecla é imprimível;
Para decidir se uma tecla é qualquer tecla imprimível;
Para decidir se uma tecla pode ser impressa;
\CAL
To decide if a_ key is any printable key:
If the key is the space key, say yes.
If the key is any digit key, say yes.
If the key is any letter key, say yes.
If the key is any pad key, say yes.
If the key is any symbol key, say yes.
Say no.

\PAL
Para decidir se uma tecla é qualquer símbolo;
Para decidir se uma tecla é qualquer tecla de símbolo;
\CAL
To decide if a_ key is any symbol key:
If the key is between 186 and 192, say yes.
If the key is between 219 and 222, say yes.
Say no.

To decide if a_ key is any wm-char key:
If the key is not any printable key , say no.
If the alt key was down, say no.
If the ctrl key was down, say no.
Say yes.

\PAL
Para decidir se uma tecla está pressionada;
\CAL
To decide if a_ key is down:
Call "user32.dll" "GetAsyncKeyState" with the key returning a_ wyrd.
Put the wyrd into a_ number.
If the number is less than 0, say yes.
Say no.

\PAL
Para decidir se uma tecla está levantada;
\CAL
To decide if a_ key is up:
If the key is down, say no.
Say yes.

\PAL
Para decidir se uma tecla foi pressionada;
\CAL
To decide if a_ key was down:
Call "user32.dll" "GetKeyState" with the key returning a_ wyrd.
Put the wyrd into a_ number.
If the number is less than 0, say yes.
Say no.

\PAL
Para decidir se uma tecla foi alternada;
\CAL
To decide if a_ key was toggled:
Call "user32.dll" "GetKeyState" with the key returning a_ wyrd.
Put the wyrd into a_ number.
Bitwise and the number with 1.
If the number is 1, say yes.
Say no.

\PAL
Para decidir se uma tecla foi levantada;
\CAL
To decide if a_ key was up:
If the key was down, say no.
Say yes.

To decide if a_ key with an l-param is any repeated escape or modifier key:
Put the l-param into a_ number.
Bitwise and the number with 1073741824 [$40000000].
If the number is 0, say no.
If the key is the escape key, say yes.
If the key is any modifier key, say yes.
Say no.

\PAL
Para decidir se o botão esquerdo do mouse está abaixo;
Para decidir se o botão esquerdo do mouse está pressionado;
\CAL
To decide if the left mouse button is down:
If the mouse's left button is down, say yes.
Say no.

\PAL
Para decidir se uma reta está acima de uma caixa;
\CAL
To decide if a_ line is above a_ box:
If the line's start's y-coord is greater than or equal to the box's top, say no.
If the line's end's y-coord is greater than or equal to the box's top, say no.
Say yes.

\PAL
Para decidir se uma reta está acima de uma coordenada;
\CAL
To decide if a_ line is above a_ coord:
If the line's start's y-coord is greater than or equal to the coord, say no.
If the line's end's y-coord is greater than or equal to the coord, say no.
Say yes.

\PAL
Para decidir se uma reta está abaixo de uma caixa;
\CAL
To decide if a_ line is below a_ box:
If the line's start's y-coord is less than or equal to the box's bottom, say no.
If the line's end's y-coord is less than or equal to the box's bottom, say no.
Say yes.

\PAL
Para decidir se uma reta está abaixo de uma coordenada;
\CAL
To decide if a_ line is below a_ coord:
If the line's start's y-coord is less than or equal to the coord, say no.
If the line's end's y-coord is less than or equal to the coord, say no.
Say yes.

\PAL
Para decidir se uma reta está em uma caixa;
\CAL
To decide if a_ line is still in a_ box;
To decide if a_ line is in a_ box:
If the line's start is not in the box, say no.
If the line's end is not in the box, say no.
Say yes.

To decide if a_ mixed is a_ number:
Convert the mixed to a_ fraction.
If the fraction is the number, say yes.
Say no.

\PAL
Para decidir se o mouse foi arrastado desde um loco dada uma grade;
\CAL
To decide if the mouse has been dragged from a_ spot given a_ grid:
If the mouse's left button is up, say no.
Put the mouse's spot into another spot.
Get a_ difference between the other spot and the spot.
If the difference is within the grid, repeat.
Say yes.

\PAL
Para decidir se o mouse está em uma caixa;
\CAL
To decide if the mouse is in a_ box:
If the mouse's spot is in the box, say yes.
Say no.

\PAL
Para decidir se um número é outro número e uma sequência é outra sequência;
\CAL
To decide if a_ number is another number and a_ string is another string:
If the number is not the other number, say no.
If the string is not the other string, say no.
Say yes.

\PAL
Para decidir se um número se encontra entre outro número e um terceiro número;
Para decidir se um número está entre outro número e um terceiro número;
\CAL
To decide if a_ number is between another number and a_ third number:
If the number is less than the other number, say no.
If the number is greater than the third number, say no.
Say yes.

\PAL
Para decidir se um número é par;
\CAL
To decide if a_ number is even:
If the number is odd, say no.
Say yes.

\PAL
Para decidir se um número é divisível por outro número;
\CAL
To decide if a_ number is evenly divisible by another number:
Privatize the number.
Divide the number by the other number giving a_ quotient and a_ remainder.
If the remainder is 0, say yes.
Say no.

\PAL
Para decidir se um número é múltiplo de outro número;
\CAL
To decide if a_ number is a_ multiple of another number:
If the number is evenly divisible by the other number, say yes.
Say no.

\PAL
Para decidir se um número é negativo;
\CAL
To decide if a_ number is negative:
If the number is less than 0, say yes.
Say no.

\PAL
Para decidir se um número é ímpar;
\CAL
To decide if a_ number is odd:
Privatize the number.
Bitwise and the number with 1.
If the number is 0, say no.
Say yes.

\PAL
Para decidir se um número é positivo;
\CAL
To decide if a_ number is positive:
If the number is less than 0, say no.
Say yes.

\PAL
Para decidir se um número é primo;
\CAL
To decide if a_ number is prime:
If the number is less than 2, say no.
If the number is 2, say yes.
Put the number minus 1 into another number.
Loop.
If the number is evenly divisible by the other number, say no.
Subtract 1 from the other number.
If the other number is greater than 1, repeat.
Say yes.

\PAL
Para decidir se um par é outro par;
\CAL
To decide if a_ pair is another pair:
If the pair's x-number is not the other pair's x-number, say no.
If the pair's y-number is not the other pair's y-number, say no.
Say yes.

\PAL
Para decidir se um par é um número;
\CAL
To decide if a_ pair is a_ number:
If the pair's x-number is not the number, say no.
If the pair's y-number is not the number, say no.
Say yes.

\PAL
Para decidir se um par é um número e outro número;
\CAL
To decide if a_ pair is a_ number and another number:
If the pair's x-number is not the number, say no.
If the pair's y-number is not the other number, say no.
Say yes.

\PAL
Para decidir se uma rota é qualquer pasta;
\CAL
To decide if a_ path is directory-format:
If the path is blank, say no.
If the path's last's target is the backslash byte, say yes.
Say no.

\PAL
Para decidir se uma rota é qualquer disco;
\CAL
To decide if a_ path is drive-format:
If the path starts with "\\", say yes.
If the path's length is not 3, say no.
If the path ends with ":\", say yes.
Say no.

\PAL
Para decidir se uma rota está vazia no sistema;
\CAL
To decide if a_ path is empty in the file system:
If the path is not in the file system, say yes.
Get a_ count of items in the path in the file system.
If the count is 0, say yes.
Say no.

\PAL
Para decidir se uma rota é qualquer arquivo;
\CAL
To decide if a_ path is file-format:
If the path is blank, say no.
If the path's last's target is the colon byte, say no.
If the path's last's target is the backslash byte, say no.
Say yes.

\PAL
Para decidir se uma rota está no sistema;
Para decidir se uma rota se encontra no sistema;
\CAL
To decide if a_ path is in the file system:
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "GetFileAttributesA" with the path's first returning a_ number.
If the number is less than 0, say no.
Say yes.

\PAL
Para decidir se uma rota é de somente leitura;
Para decidir se uma rota é de apenas leitura;
\CAL
To decide if a_ path is read-only:
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "GetFileAttributesA" with the path's first returning a_ number.
Bitwise and the number with 1 [file_attribute_readonly].
If the number is not 0, say yes.
Say no.

\PAL
Para decidir se um ponteiro existe;
Para decidir se um ponteiro pode ser encontrado;
\CAL
To decide if a_ pointer can be found;
To decide if a_ pointer is coming;
To decide if a_ pointer is found;
To decide if a_ pointer was found;
To decide if a_ pointer is there;
To decide if a_ pointer does exist:
If the pointer is nil, say no.
Say yes.

\PAL
Para decidir se um ponteiro é maior que outro ponteiro;
Para decidir se um número é maior que outro número;
\CAL
To decide if a_ pointer is greater than another pointer;
To decide if a_ number is greater than another number:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8F06000000. \ jg over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um ponteiro é maior ou igual a outro ponteiro;
Para decidir se um número é maior ou igual a outro número;
Para decidir se um número é outro número ou maior;
Para decidir se um número é outro número ou mais;
\CAL
To decide if a_ pointer is greater than or equal to another pointer;
To decide if a_ number is another number or more;
To decide if a_ number is greater than or equal to another number:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8D06000000. \ jge over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um ponteiro é menor que outro ponteiro;
Para decidir se um número é menor que outro número;
\CAL
To decide if a_ pointer is less than another pointer;
To decide if a_ number is less than another number:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8C06000000. \ jl over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL
Para decidir se um ponteiro é menor ou igual a outro ponteiro;
Para decidir se um número é menor ou igual a outro número;
Para decidir se um número é outro número ou menor;
Para decidir se um número é outro número ou menos;
\CAL
To decide if a_ pointer is less than or equal to another pointer;
To decide if a_ number is another number or less;
To decide if a_ number is another number or fewer;
To decide if a_ number is less than or equal to another number:
Intel $C7C001000000. \ mov eax,1 \ assume true
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8B1B. \ mov ebx,[ebx]
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the other number
Intel $3B19. \ cmp ebx,[ecx]
Intel $0F8E06000000. \ jle over the next 1 statement
Intel $C7C000000000. \ mov eax,0 \ now it's false

\PAL 
Para decidir se um ponteiro está faltando;
Para decidir se um ponteiro está ausente;
Para decidir se um ponteiro é null;
\CAL
To decide if a_ pointer is missing;
To decide if a_ pointer is null and void:
If the pointer is nil, say yes.
Say no.

\PAL 
Para decidir se um polígono está fechado;
\CAL
To decide if a_ polygon is closed:
If the polygon is nil, say no.
If the polygon's vertices' count is less than 3, say no.
If the polygon's first vertex's spot is the polygon's last vertex's spot, say yes.
Say no.

\PAL
Para decidir se um polígono está aberto:
Se o polígono estiver fechado, diga não.
Diga sim.

\PAL 
Para decidir se uma resposta é parecida com outra resposta;
Para decidir se uma resposta é algo como outra resposta;
Para decidir se uma resposta é como outra resposta;
\CAL
To decide if a_ reply is something like another reply:
Privatize the reply.
Privatize the other reply.
Simplify the reply.
Simplify the other reply.
If the reply is the other reply, say yes.
Say no.

\PAL 
Para decidir se uma linha está vazio;
Para decidir se uma linha está vazia;
\CAL
To decide if a_ row is blank:
If the row is nil, say yes.
Slap a_ substring on the row's string.
Loop.
If the substring is blank, say yes.
If the substring's first's target is not noise, say no.
Add 1 to the substring's first.
Repeat.

\PAL 
Para decidir se uma linha de um texto está selecionada;
\CAL
To decide if a_ row of a_ text is selected:
If the text is nil, say no.
If the row is nil, say no.
If nothing is selected in the text, say no.
Put the text's normalized selection into a_ selection.
If the row's row# is less than the selection's anchor row#, say no.
If the row's row# is greater than the selection's caret row#, say no.
If the row's row# is not the selection's caret row#, say yes.
If the selection's caret column# is 1, say no.
Say yes.

\PAL 
Para decidir se uma linha de um texto está visível;
\CAL
To decide if a_ row of a_ text is visible:
If the text is nil, say no.
If the row is nil, say  no.
Get a_ box given the row and the text.
Put the text's box into another box.
Adjust the other box given 0 and the tpp and 0 and - the tpp.
If the box is touching the other box, say yes.
Say no.

\PAL 
Para decidir se uma seleção é outra seleção;
\CAL
To decide if a_ selection is another selection:
If the selection's anchor is not the other selection's anchor, say no.
If the selection's caret is not the other selection's caret, say no.
Say yes.

\PAL 
Para decidir se algo está selecionado em um texto;
Para decidir se há seleção em um texto;
\CAL
To decide if something is selected in a_ text:
If the text's anchor is the text's caret, say no.
Say yes.

\PAL 
Para decidir se um loco está acima de uma caixa;
\CAL
To decide if a_ spot is above a_ box:
If the spot's y-coord is less than the box's top, say yes.
Say no.

\PAL 
Para decidir se um loco está acima de uma reta horizontal;
\CAL
To decide if a_ spot is above a_ horizontal line:
If the spot's y-coord is less than the horizontal line's start's y, say yes.
Say no.

\PAL 
Para decidir se um loco está acima ou abaixo de uma caixa;
\CAL
To decide if a_ spot is above or below a_ box:
If the spot is above the box, say yes.
If the spot is below the box, say yes.
Say no.

\PAL 
Para decidir se um loco está abaixo de uma caixa;
\CAL
To decide if a_ spot is below a_ box:
If the spot's y-coord is greater than the box's bottom, say yes.
Say no.

\PAL 
Para decidir se um loco está abaixo de uma reta horizontal;
\CAL
To decide if a_ spot is below a_ horizontal line:
If the spot's y-coord is greater than the horizontal line's start's y, say yes.
Say no.

\PAL 
Para decidir se um loco está em uma elipse;
\CAL
To decide if a_ spot is in an ellipse:
Create an hrgn given the ellipse.
Privatize the spot.
Divide the spot by the tpp.
Call "gdi32.dll" "PtInRegion" with the hrgn and the spot's x-coord and the spot's y-coord returning a_ number.
Destroy the hrgn.
If the number is 0, say no.
Say yes.

\PAL 
Para decidir se um loco está em uma imagem;
\CAL
To decide if a_ spot is in a_ picture:
If the picture is nil, say no.
If the spot is in the picture's box, say yes.
Say no.

\PAL 
Para decidir se um loco está em um polígono;
\CAL
To decide if a_ spot is in a_ polygon:
If the polygon is nil, say no.
Create a_ vertex array given the polygon's vertices.
Call "gdi32.dll" "CreatePolygonRgn" with the vertex array's spot pointer and the vertex array's count and 2 [winding] returning an hrgn.
Call "gdi32.dll" "PtInRegion" with the hrgn and the spot's x-coord and the spot's y-coord returning a_ number.
Call "gdi32.dll" "DeleteObject" with the hrgn.
Destroy the vertex array.
If the number is 0, say no.
Say yes.

\PAL 
Para decidir se um loco está em alguns polígonos;
\CAL
To decide if a_ spot is in some polygons:
Get a_ polygon from the polygons.
If the polygon is nil, say no.
If the spot is in the polygon, say yes.
Repeat.

\PAL 
Para decidir se um loco está em uma caixa arredondada;
\CAL
To decide if a_ spot is in a_ roundy box:
Privatize the roundy box.
Add the tpp to the roundy box's right-bottom.
Put the roundy box's radius times 2 into a_ diameter number.
Call "gdi32.dll" "CreateRoundRectRgn" with the roundy box's left and the roundy box's top and the roundy box's right and the roundy box's bottom 
And the diameter and the diameter returning an hrgn.
Call "gdi32.dll" "PtInRegion" with the hrgn and the spot's x-coord and the spot's y-coord returning a_ number.
Call "gdi32.dll" "DeleteObject" with the hrgn.
If the number is 0, say no.
Say yes.

\PAL 
Para decidir se um loco está em um texto;
\CAL
To decide if a_ spot is in a_ text:
If the text is nil, say no.
If the spot is in the text's box, say yes.
Say no.

\PAL 
Para decidir se um loco está em uma caixa;
Para decidir se um loco está dentro de uma caixa;
\CAL
To decide if a_ spot is inside a_ box;
To decide if a_ spot is within a_ box;
To decide if a_ spot is in a_ box:
If the spot's x-coord is less than the box's left, say no.
If the spot's y-coord is less than the box's top, say no.
If the spot's x-coord is greater than the box's right, say no.
If the spot's y-coord is greater than the box's bottom, say no.
Say yes.

\PAL 
Para decidir se um loco está à esquerda de uma caixa;
\CAL
To decide if a_ spot is to the left of a_ box:
If the spot's x-coord is less than the box's left, say yes.
Say no.

\PAL 
Para decidir se um loco está à esquerda ou à direita de uma caixa;
\CAL
To decide if a_ spot is left or right of a_ box:
If the spot is to the left of the box, say yes.
If the spot is to the right of the box, say yes.
Say no.

To decide if a_ spot is on a_ box:
Put the box into another box.
Put 2 times the tpp into a_ number.
Outdent the other box given the number.
If the spot is not in the other box, say no.
Put the box into a_ third box.
Put 3 times the tpp into another number.
Indent the third box given the other number.
If the spot is in the third box, say no.
Say yes.

To decide if a_ spot is on an ellipse:
Put the ellipse into another ellipse.
Put 2 times the tpp into a_ number.
Outdent the other ellipse's box given the number.
If the spot is not in the other ellipse, say no.
Put the ellipse into a_ third ellipse.
Put 3 times the tpp into another number.
Indent the third ellipse's box given the other number.
If the spot is in the third ellipse, say no.
Say yes.

To decide if a_ spot is on a_ line:
Privatize the line.
Put 3 times the tpp into a_ number.
Loop.
Get a_ distance between the spot and the line's center (chessboard).
If the distance is less than or equal to the number, say yes.
Get the distance between the line's start and the line's end (chessboard).
If the distance is less than or equal to the tpp, say no.
Split the line into the line and another line.
Get the distance between the spot and the line's center (chessboard).
Get another distance between the spot and the other line's center (chessboard).
If the distance is greater than the other distance, put the other line into the line.
Repeat.

To decide if a_ spot is on a_ picture:
If the picture is nil, say no.
If the spot is on the picture's box, say yes.
Say no.

To decide if a_ spot is on a_ polygon:
If the polygon is nil, say no.
Loop.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, say no.
If the vertex's next is nil, say no.
Put the vertex's spot and the vertex's next's spot into a_ line.
If the spot is on the line, say yes.
Repeat.

To decide if a_ spot is on a_ roundy box:
Put the roundy box into another roundy box.
Put 2 times the tpp into a_ number.
Outdent the other roundy box given the number.
If the spot is not in the other roundy box, say no.
Put the roundy box into a_ third roundy box.
Put 3 times the tpp into another number.
Indent the third roundy box given the other number.
If the spot is in the third roundy box, say no.
Say yes.

\PAL
Para decidir se um loco está fora de uma caixa;
\CAL
To decide if a_ spot is outside a_ box:
If the spot is inside the box, say no.
Say yes.

\PAL
Para decidir se um loco está à direita de uma caixa;
\CAL
To decide if a_ spot is to the right of a_ box:
If the spot's x-coord is greater than the box's right, say yes.
Say no.

To decide if a_ spot is touching a_ box:
If the spot is in the box, say yes.
Say no.

\PAL
Para decidir se um loco está em uma grade de outro loco;
Para decidir se um loco está dentro de uma grade de outro loco;
\CAL
To decide if a_ spot is within a_ grid of another spot:
Get a_ difference between the other spot and the spot.
If the difference is within the grid, say yes.
Say no.

\PAL
Para decidir se um loco está dentro de alguns twips de outro loco;
\CAL
To decide if a_ spot is within some twips of another spot:
Put the twips and the twips into a_ grid.
If the spot is within the grid of the other spot, say yes.
Say no.

\PAL
Para decidir se um loco está dentro de alguns twips de uma caixa;
\CAL
To decide if a_ spot is within some twips of a_ box:
Privatize the box.
Outdent the box given the twips.
If the spot is within the box, say yes.
Say no.

To decide if the stack has just one thing on it:
If the stack's count is 1, say yes.
Say no.

\PAL
Para decidir se uma sequência termina com outra sequência;
\CAL
To decide if a_ string does end with another string;
To decide if a_ string ends with another string:
If the other string's length is greater than the string's length, say no.
Slap a_ substring on the string.
Put the substring's last minus the other string's length plus 1 into the substring's first.
If the substring is the other string, say yes.
Say no.

\PAL
Para decidir se uma sequência começa com outra sequência;
\CAL
To decide if a_ string does start with another string;
To decide if a_ string starts with another string:
If the other string's length is greater than the string's length, say no.
Slap a_ substring on the string.
Put the substring's first plus the other string's length minus 1 into the substring's last.
If the substring is the other string, say yes.
Say no.

\PAL
Para decidir se uma sequência começa com um byte;
\CAL
To decide if a_ string does start with a_ byte;
To decide if a_ string starts with a_ byte:
If the string is blank, say no.
If the string's first's target is the byte, say yes.
Say no.

\PAL
Para decidir se uma sequência termina com um byte;
\CAL
To decide if a_ string does end with a_ byte; \ added by Mike Gonta
To decide if a_ string ends with a_ byte:
If the string is blank, say no.
If the string's last's target is the byte, say yes.
Say no.

\PAL
Para decidir se uma sequência é outra sequência (comparação sem acento);
\CAL
To decide if a_ string is another string (accent-free compare):
Compare the string to the other string given the string's length and the other string's length and the lowercase accent-free ascii table (equal only).

\PAL
Para decidir se uma sequência é outra sequência;
\CAL
To decide if a_ string is another string:
Compare the string to the other string given the string's length and the other string's length and the lowercase ascii table (equal only).

\PAL
Para decidir se uma sequência é outra sequência ou uma terceira sequência;
\CAL
To decide if a_ string is another string or a_ third string:
If the string is the other string, say yes.
If the string is the third string, say yes.
Say no.

\PAL
Para decidir se uma sequência é qualquer fração;
Para decidir se uma sequência é qualquer fração literal;
Para decidir se uma sequência é qualquer número fracionário;
\CAL
To decide if a_ string is any fraction literal;
To decide if a_ string is any ratio literal:
Slap a_ substring on the string.
If the substring is blank, say no.
If the substring's first's target is not any numeric starter, say no.
If the substring's first's target is any sign, add 1 to the substring's first.
Split the substring into a_ numerator substring and a_ denominator substring given the slash byte.
If the numerator substring is not any integer literal, say no.
If the denominator substring is not any integer literal, say no.
Say yes.

\To decide if a_ string is any integer: \ seemed to be a duplicate of the routine below
\Slap a_ substring on the string.
\If the substring is blank, say no.
\If the substring's first's target is any sign, add 1 to the substring's first.
\If the substring is blank, say no.
\Loop.
\If the substring's first's target is not any digit, say no.
\Add 1 to the substring's first.
\If the substring is blank, say yes.
\Repeat.

\PAL
Para decidir se uma sequência é qualquer inteiro;
Para decidir se uma sequência é qualquer inteiro literal;
Para decidir se uma sequência é qualquer número inteiro;
\CAL
To decide if a_ string is any integer;
To decide if a_ string is any integer literal:
Slap a_ substring on the string.
If the substring is blank, say no.
If the substring's first's target is any sign, add 1 to the substring's first.
If the substring is blank, say no.
Loop.
If the substring's first's target is not any digit, say no.
Add 1 to the substring's first.
If the substring is blank, say yes.
Repeat.

\PAL
Para decidir se uma sequência é qualquer número composto;
\CAL
To decide if a_ string is any mixed literal:
Slap a_ substring on the string.
If the substring is blank, say no.
If the substring's first's target is not any numeric starter, say no.
If the substring's first's target is any sign, add 1 to the substring's first.
Split the substring into an integer substring and a_ fraction substring given the dash byte.
If the integer substring is not any integer literal, say no.
If the fraction substring is not any fraction literal, say no.
Say yes.

\PAL
Para decidir se uma sequência é qualquer número literal;
\CAL
To decide if a_ string is any numeric literal:
If the string is blank, say no.
If the string's first's target is not any numeric starter, say no.
If the string is any integer literal, say yes.
If the string is any fraction literal, say yes.
If the string is any mixed literal, say yes.
Say no.

\PAL
Para decidir se uma sequência é qualquer sinal;
\CAL
To decide if a_ string is any sign:
If the string's length is not 1, say no.
If the string's first's target is any sign, say yes.
Say no.

To decide if a_ string is any word:
If the string's length is less than 2, say no.
Slap a_ substring on the string.
Subtract 1 from the substring's first.
Loop.
Add 1 to the substring's first.
If the substring is blank, say yes.
If the substring's first's target is any letter, repeat.
If the substring's first's target is the single-quote byte, repeat.
Say no.

\PAL
Para decidir se uma sequência está vazio;
Para decidir se uma sequência está vazia;
Para decidir se uma sequência está em branco;
\CAL
To decide if a_ string is blank:
\ assume true
Intel $B801000000. \ mov eax,1
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the string
\ if first is 0, exit
Intel $833B00. \ cmp [ebx],0
Intel $0F8410000000. \ je end
\ if last is less than first, exit
Intel $8B5304. \ mov edx,[ebx+4] \ last pointer
Intel $3B13. \ cmp edx,[ebx]
Intel $0F8C05000000. \ jl end
\ SAY NO:
Intel $B800000000. \ mov eax,0
\ END:

\PAL
Para decidir se uma sequência é um byte;
\CAL
To decide if a_ string is a_ byte:
If the string's length is not 1, say no.
If the string's first's target is the byte, say yes.
Say no.

\PAL
Para decidir se uma sequência é dos-compatível;
\CAL
To decide if a_ string is dos-compatible:
If the string is blank, say no.
If the string's first's target is the period byte, say no.
Slap a_ substring on the string.
Loop.
If the substring is blank, say yes.
If the substring's first's target is the slash byte, say no.
If the substring's first's target is the backslash byte, say no.
If the substring's first's target is the colon byte, say no.
If the substring's first's target is the asterisk byte, say no.
If the substring's first's target is the question-mark byte, say no.
If the substring's first's target is the double-quote byte, say no.
If the substring's first's target is the left-alligator byte, say no.
If the substring's first's target is the right-alligator byte, say no.
If the substring's first's target is the bar byte, say no.
Add 1 to the substring's first.
Repeat.

\PAL
Para decidir se uma sequência é maior que outra sequência;
\CAL
To decide if a_ string is greater than another string:
Compare the string to the other string given the string's length and the other string's length returning a_ number.
If the number is greater than 0, say yes.
Say no.

\PAL
Para decidir se uma sequência é maior ou igual a outra sequência;
\CAL
To decide if a_ string is greater than or equal to another string:
Compare the string to the other string given the string's length and the other string's length returning a_ number.
If the number is greater than or equal to 0, say yes.
Say no.

\PAL
Para decidir se uma sequência está em outra sequência;
Para decidir se uma sequência está contida em outra sequência;
Para decidir se uma sequência está dentro de outra sequência;
\CAL
To decide if a_ string is in another string:
Slap a_ substring on the other string.
Put the substring's first plus the string's length minus 1 into the substring's last.
Loop.
If the substring's last is greater than the other string's last, say no.
If the substring is the string, say yes.
Move the substring given 1.
Repeat.

\PAL
Para decidir se uma sequência está em um índice;
\CAL
To decide if a_ string is in an index:
If the index is nil, say no.
If the string is blank, say no.
Find a_ refer given the string and the index.
If the refer is nil, say no.
Say yes.

\PAL
Para decidir se uma sequência é menor que outra sequência;
\CAL
To decide if a_ string is less than another string:
Compare the string to the other string given the string's length and the other string's length returning a_ number.
If the number is less than 0, say yes.
Say no.

\PAL
Para decidir se uma sequência é menor ou igual a outra sequência;
\CAL
To decide if a_ string is less than or equal to another string:
Compare the string to the other string given the string's length and the other string's length returning a_ number.
If the number is less than or equal to 0, say yes.
Say no.

\PAL
Para decidir se uma sequência está mal escrita; \ needs work for Portuguese
\CAL
To decide if a_ string is misspelled:
If the lexicon is nil, say no.
If the string is not any word, say no.
Privatize the string.
If the string ends with "'s", remove the last two bytes from the string.
If the string is in the lexicon's index, say no.
Say yes.

\PAL
Para decidir se uma sequência é mais larga que uma caixa;
\CAL
To decide if a_ string is wider than a_ box: \ assumes font is selected on memory canvas
Get an abca and an abcc given the string and the memory canvas.
Get a_ width given the string and the memory canvas.
Subtract the abca from the width.
Subtract the abcc from the width.
If the width is greater than the box's width, say yes.
Say no.

Para decidir se uma sequência cabe em uma caixa:
Se a sequência for mais larga que a caixa, diga não.
Diga sim.

To decide if a_ substring is on any contraction:
Put the substring's first plus 1 into a_ byte pointer.
If the byte pointer is greater than the substring's last, say no.
If the substring's first's target is not the single-quote byte, say no.
If the byte pointer's target is not any letter, say no.
Say yes.

To decide if a_ terminal is full:
Put the terminal's height divided by 1/4 inch into a_ number.
If the terminal's quoras' count is greater than the number, say yes.
Say no.

\PAL
Para decidir se um texto pode ser refeito;
\CAL
To decide if a_ text can be redone:
If the text is nil, say no.
If the text's redos' last is nil, say no.
Say yes.

\PAL
Para decidir se um texto pode ser desfeito;
\CAL
To decide if a_ text can be undone:
If the text is nil, say no.
If the text's undos' last is nil, say no.
Say yes.

\PAL
Para decidir se um texto está modificado;
\CAL
To decide if a_ text is modified:
If the text is nil, say no.
If the text's modified flag is set, say yes.
Say no.

\PAL
Para decidir se há algo para retroceder em um texto;
Para decidir se um texto pode retroceder;
\CAL
To decide if there is something to backspace in a_ text:
If the text is nil, say no.
If something is selected in the text, say yes.
If the text's caret row# is not 1, say yes.
If the text's caret column# is not 1, say yes.
Say no.

\PAL
Para decidir se há algo para remover em um texto;
\CAL
To decide if there is something to remove in a_ text:
If the text is nil, say no.
If something is selected in the text, say yes.
If the text's caret row# is not the text's row count, say yes.
Get a_ row given the text's caret row# and the text.
If the text's caret column# is not the row's string's length, say yes.
Say no.

\PAL
Para decidir se tem texto na área de tranferência do windows;
Para decidir se há texto na área de tranferência do windows;
\CAL
To decide if there is text on the windows clipboard:
Call "user32.dll" "IsClipboardFormatAvailable" with 1 [cf_text] returning a_ number.
If the number is 0, say no.
Say yes.

\PAL
Para decidir se alguns elementos estão vazios;
Para decidir se alguns elementos estão vazias;
\CAL
To decide if some things are empty:
If the things' first is nil, say yes.
Say no.

To decide if a_ token is numeric:
Privatize the token.
Remove any leading noise from the token.
If the token is blank, say no.
Loop.
Get a_ byte from the token.
If the byte is not any digit, say no.
If the token is blank, say yes.
Repeat.

To decide if the user is clicking in some choices;
To decide if the user has clicked in some choices;
To decide if the user clicked in some choices;
To decide if the user clicks in some choices;
To decide if the user is clicking on some choices;
To decide if the user has clicked on some choices;
To decide if the user clicked on some choices;
To decide if the user clicks on some choices:
Loop.
If the mouse's left button is not down, say no.
Find a_ choice given the mouse's spot.
If the choice can't be found, say no.
Say yes.

To decide if we can find a_ pointer: \ should be "can" not "ca", compiler bug
If the pointer is nil, say no.
Say yes.

To decide if we could find a_ pointer:
If the pointer is nil, say no.
Say yes.

To decide if we did find a_ pointer:
If the pointer is nil, say no.
Say yes.

To decide if we're above a_ box:
If the context's y-coord is less than the box's top, say yes.
Say no.

To decide if we're above a_ coord:
If the context's y-coord is less than the coord, say yes.
Say no.

To decide if we're above a_ horizontal line:
If the context's spot is above the horizontal line, say yes.
Say no.

To decide if we're above or below a_ box:
If the context's y-coord is less than the box's top, say yes.
If the context's y-coord is greater than the box's bottom, say yes.
Say no.

To decide if we're above a_ spot:
If the context's y-coord is less than the spot's y, say yes.
Say no.

To decide if we're below a_ box:
If the context's y-coord is greater than the box's bottom, say yes.
Say no.

To decide if we're below a_ coord:
If the context's y-coord is greater than the coord, say yes.
Say no.

To decide if we're below a_ horizontal line:
If the context's spot is below the horizontal line, say yes.
Say no.

To decide if we're below a_ spot:
If the context's y-coord is greater than the spot's y, say yes.
Say no.

To decide if we're facing north: \ *** need east, south, west
Normalize the context's heading.
If the context's heading is 0, say yes.
Say no.

To decide if we're left of a_ box:
If the context's x-coord is less than the box's left, say yes.
Say no.

To decide if we're left or right of a_ box:
If the context's x-coord is less than the box's left, say yes.
If the context's x-coord is greater than the box's right, say yes.
Say no.

To decide if we're outside a_ box:
If the context's spot is outside the box, say yes.
Say no.

To decide if we're right of a_ box:
If the context's x-coord is greater than the box's right, say yes.
Say no.

To decide if we're still in a_ box;
To decide if we're in a_ box:
If the context's spot is in the box, say yes.
Say no.

To decide if we're within some twips of a_ box:
If the context's spot is within the twips of the box, say yes.
Say no.

\PAL
Para decidir se te apetece;
Para decidir se lhe apetece;
Para decidir se você sente vontade;
\CAL
To decide if you feel like it:
Pick a_ number between 1 and 100.
If the number is less than 51, say yes.
Say no.

To decrypt a_ buffer given a_ passphrase string: \ sets i/o error if failure
Clear o erro de e/s.
Create a_ crypt session given the passphrase.
If the crypt session is nil, exit.
Convert the buffer as_ a_ nibble string to a_ hex string.
Put the hex string's length into a_ length.
Call "advapi32.dll" "CryptDecrypt" with the crypt session's hcryptkey and 0 and 1 and 0 and the hex string's first
And the length's whereabouts returning a_ result number.
If the result number is 0, put "Error desencriptando datos." into o erro de e/s; destroy the crypt session; exit.
Destroy the crypt session.
Put the hex string into the buffer.

The default font is a_ font.

The default smtp server is "localhost".

a_ degree is a_ number [0 to 359].

The degree-symbol byte is a_ byte equal to 176.

The delete byte is a_ byte equal to 127.

The delete key is a_ key equal to 46.

a_ depth is some twips.

a_ description is a_ string.

\PAL
Para dermarcar um texto;
Para anular a seleção de um texto;
\CAL
To deselect a_ text:
If the text is nil, exit.
Put the text's caret into the text's anchor.

a_ designator is a_ string. \ rightmost directory with slash = folder2\ OR after the last slash to end of path = file.ext

To destroy a_ crypt session:
If the crypt session is nil, exit.
Call "advapi32.dll" "CryptDestroyKey" with the crypt session's hcryptkey.
Call "advapi32.dll" "CryptDestroyHash" with the crypt session's hcrypthash.
Call "advapi32.dll" "CryptReleaseContext" with the crypt session's hcryptprov and 0.
Deallocate the crypt session.

To destroy a_ gpimage:
If the gpimage is nil, exit.
Call "gdiplus.dll" "GdipDisposeImage" with the gpimage.
Void the gpimage.

To destroy a_ gpimageattributes:
If the gpimageattributes is nil, exit.
Call "gdiplus.dll" "GdipDisposeImageAttributes" with the gpimageattributes.
Void the gpimageattributes.

To destroy the hbrush of a_ canvas:
Call "gdi32.dll" "SelectObject" with the canvas and the null hbrush returning an hbrush.
Call "gdi32.dll" "DeleteObject" with the hbrush.

To destroy the hfont of a_ canvas:
Call "gdi32.dll" "SelectObject" with the canvas and the null hfont returning an hfont.
Call "gdi32.dll" "DeleteObject" with the hfont.

To destroy the hpen of a_ canvas:
Call "gdi32.dll" "SelectObject" with the canvas and the null hpen returning an hpen.
Call "gdi32.dll" "DeleteObject" with the hpen.

To destroy an hrgn:
Call "gdi32.dll" "DeleteObject" with the hrgn.

\PAL
Para destruir um índice;
\CAL
To destroy an index:
If the index is nil, exit.
Loop.
Get a_ bucket given the index.
If the bucket is nil, break.
Destroy the bucket's refers.
Repeat.
Unassign the index's first bucket.
Deallocate the index.

\PAL
Para destruir uma rota no sistema;
\CAL
To destroy a_ path in the file system:
Set the path to read-write mode.
If the path is directory-format, destroy the path in the file system (directory).
If the path is file-format, destroy the path in the file system (file).

\PAL
Para destruir uma rota no sistema (pasta);
\CAL
To destroy a_ path in the file system (directory):
Loop.
Get an item from the path.
If the item is not found, break.
Put the path into another path.
Append the item's designator to the other path.
Destroy the other path in the file system.
If o erro de e/s is not blank, exit.
Repeat.
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "RemoveDirectoryA" with the path's first returning a_ number.
Clear o erro de e/s.
If the number is not 0, exit.
Put "Error eliminando directorio '" then the path then "'." into o erro de e/s.

\PAL
Para destruir uma rota no sistema (arquivo);
\CAL
To destroy a_ path in the file system (file):
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "DeleteFileA" with the path's first returning a_ number.
Clear o erro de e/s.
If the number is not 0, exit.
Put "Error eliminando archivo '" then the path then "'." into o erro de e/s.

\PAL
Para destruir uma imagem;
\CAL
To destroy a_ picture:
If the picture is nil, exit.
Destroy the picture's gpbitmap.
Deallocate the picture.

To destroy a_ socket:
Call "ws2_32.dll" "closesocket" with the socket.

\PAL
Para destruir um vértice de um polígono;
\CAL
To destroy a_ vertex given a_ polygon:
If the vertex is nil, exit.
If the polygon is nil, exit.
Privatize the vertex.
Remove the vertex from the polygon's vertices.
Destroy the vertex.

To destroy a_ winhttp request:
If the winhttp request is nil, exit.
Call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's request.
Call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's connection.
Call "winhttp.dll" "WinHttpCloseHandle" with the winhttp request's session.
Deallocate the winhttp request.

The device-control-four byte is a_ byte equal to 20.

The device-control-one byte is a_ byte equal to 17.

The device-control-three byte is a_ byte equal to 19.

The device-control-two byte is a_ byte equal to 18.

a_ devmode is a_ record with
32 bytes called dmdevicename,
a_ wyrd called dmspecversion,
a_ wyrd called dmdriverversion,
a_ wyrd called dmsize,
a_ wyrd called dmdriverextra,
a_ number called dmfields,
a_ wyrd called dmorientation,
a_ wyrd called dmpapersize,
a_ wyrd called paperlength,
a_ wyrd called paperwidth,
a_ wyrd called dmscale,
a_ wyrd called dmcopies,
a_ wyrd called dmdefaultsource,
a_ wyrd called dmprintquality,
a_ wyrd called dmcolor,
a_ wyrd called dmduplex,
a_ wyrd called ydmresolution,
a_ wyrd called dmttoption,
a_ wyrd called dmcollate,
32 bytes called dmformname,
a_ wyrd called dmlogpixels,
a_ number called dmbitsperpel,
a_ number called dmpelswidth,
a_ number called dmpelsheight,
a_ number called dmdisplayflags,
a_ number called dmdisplayfrequency,
a_ number called dmicmmethod,
a_ number called dmicmintent,
a_ number called dmmediatype,
a_ number called dmdithertype,
a_ number called dmreserved1,
a_ number called dmreserved2.

The diaeresis byte is a_ byte equal to 168.

a_ difference is a_ pair.

a_ directory is a_ path. \ start of path to last slash inclusive = c:\folder1\folder2\

a_ directory name is a_ string. \ rightmost directory with slash = folder2\

a_ directory name w/o slash is a_ string. \ rightmost directory without slash = folder2

a_ distance is some twips.

\PAL
Para dividir uma fração por outra fração;
\CAL
To divide a_ fraction by another fraction:
Privatize the other fraction.
Flip the other fraction.
Multiply the fraction by the other fraction.

\PAL
Para dividir uma fração por um número;
\CAL
To divide a_ fraction by a_ number:
Multiply the fraction's denominator by the number.
Reduce the fraction.

\PAL
Para dividir um número por uma fração;
\CAL
To divide a_ number by a_ fraction:
Privatize the fraction.
Flip the fraction.
Multiply the number by the fraction.

\PAL
Para dividir um par por outro par;
\CAL
To divide a_ pair by another pair:
Divide the pair's x-number by the other pair's x-number.
Divide the pair's y-number by the other pair's y-number.

\PAL
Para dividir um par por um número;
\CAL
To divide a_ pair by a_ number:
Divide the pair's x-number by the number.
Divide the pair's y-number by the number.

\PAL
Para dividir um par por um número e outro número;
\CAL
To divide a_ pair by a_ number and another number:
Divide the pair's x-number by the number.
Divide the pair's y-number by the other number.

\PAL
Para dividir um ponteiro por um número;
Para dividir um número por outro número;
\CAL
To divide a_ pointer by a_ number;
To divide a_ number by another number:
If the other number is 0, put the largest number into the number; exit.
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
Intel $8B00. \ mov eax,[eax]
Intel $99. \ cdq
Intel $F73B. \ div [ebx] \ means div eax,[ebx] but is weird form
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8903. \ mov [ebx],eax

\PAL
Para dividir um ponteiro por um número dando um quociente e um resto;
Para dividir um ponteiro por um número gerando um quociente e um resto;
Para dividir um número por outro número dando um quociente e um resto;
Para dividir um número por outro número gerando um quociente e um resto;
\CAL
To divide a_ pointer by a_ number giving a_ quotient and a_ remainder;
To divide a_ number by another number giving a_ quotient and a_ remainder:
If the other number is 0, put the largest number into the quotient; put 0 into the remainder; exit.
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
Intel $8B00. \ mov eax,[eax]
Intel $99. \ cdq
Intel $F73B. \ idiv [ebx] \ means idiv eax,[ebx] but is weird form
Intel $8B9D10000000. \ mov ebx,[ebp+16] \ the quotient
Intel $8903. \ mov [ebx],eax
Intel $8B9D14000000. \ mov ebx,[ebp+20] \ the remainder
Intel $8913. \ mov [ebx],edx

The division-symbol byte is a_ byte equal to 247.

a_ docinfo is a_ record with
a_ number called cbsize,
a_ pointer called lpszdocname,
a_ pointer called lpszoutput,
a_ pointer called lpszdatadtype,
a_ number called fwtype.

The dollar-sign byte is a_ byte equal to 36.

a_ dot is an ellipse.

\PAL
Para duplicar um número;
\CAL
To double a_ number:
Add the number to the number.

The double-dagger byte is a_ byte equal to 135.

The double-quote byte is a_ byte equal to 34.

The down-arrow key is a_ key equal to 40.

\PAL
Para desenhar e preencher uma caixa com uma cor;
\CAL
To draw and fill a_ box with a_ color:
Draw the box with the color and the color.

\PAL
Para desenhar quaisquer linhas visíveis de um texto;
\CAL
To draw any visible rows of a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row of the text is not visible, repeat.
Draw the row of the text.
Repeat.

\PAL
Para desenhar quaisquer linhas visíveis de um texto (edição);
Para desenhar quaisquer linhas visíveis de um texto (editando);
\CAL
To draw any visible rows of a_ text (editing):
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row of the text is not visible, repeat.
Draw the row of the text (editing).
Repeat.

\PAL
Para desenhar uma caixa;
\CAL
To draw a_ box:
Draw the box with the black color and the clear color.

\PAL
Para desenhar uma caixa (com foco); 
Para desenhar uma caixa (estilo de enfoque); 
Para desenhar uma caixa (estilo com foco); 
\CAL
To draw a_ box (focus style):
Privatize the box.
Add the tpp to the box's right-bottom.
Call "gdi32.dll" "LPtoDP" with the current canvas and the box's whereabouts and 2.
Convert the white color to a_ colorref.
Call "gdi32.dll" "SetBkColor" with the current canvas and the colorref.
Convert the black color to another colorref.
Call "gdi32.dll" "SetTextColor" with the current canvas and the other colorref.
Call "gdi32.dll" "SetMapMode" with the current canvas and 1 [mm_text].
Call "user32.dll" "DrawFocusRect" with the current canvas and the box's whereabouts.
Normalize the current canvas.

\PAL
Para desenhar uma caixa com uma cor; 
\CAL
To draw a_ box in a_ color;
To draw a_ box with a_ color:
Draw the box with the color and the clear color.

\PAL
Para desenhar uma caixa com uma cor de borda e uma cor de preenchimento; 
\CAL
To draw a_ box with a_ border color and a_ fill color:
If the pdf state's page flag is set, draw the box with the border and the fill (pdf style); exit.
Privatize the box.
Create the hpen of the current canvas given the border.
Create the hbrush of the current canvas given the fill.
If the border is clear, add the tpp to the box's left-top.
Call "gdi32.dll" "Rectangle" with the current canvas and the box's left and the box's top and the box's right and the box's bottom.
Destroy the hbrush of the current canvas.
Destroy the hpen of the current canvas.

\PAL
Para desenhar uma caixa com uma cor de borda e uma cor de preenchimento (pdf); 
Para desenhar uma caixa com uma cor de borda e uma cor de preenchimento (estilo pdf); 
\CAL
To draw a_ box with a_ border color and a_ fill color (pdf style):
If the border and the fill are clear, exit.
Output setcolor given the border and the fill.
Output the box's left-bottom without advancing.
Output the box's x-extent without advancing.
Output the box's y-extent without advancing.
Output "re".
Output stroke and fill given the border and the fill.

To draw the caret in a_ text:
If the text is nil, exit.
Get a_ box for_ the caret in the text.
If the box is not touching the text's box, exit.
Put the box's left-top and the box's right-bottom into a_ line.
Draw the line with the black color.

To draw a_ circle about some twips wide;
To draw a_ circle given a_ width;
To draw a_ circle some twips in width;
To draw a_ circle some twips wide:
Put the twips times the pizza pie divided by 48 into a_ segment length.
Add 1 to the segment length.
Loop.
Stroke the segment length.
Turn right 1/48 of the way.
Add 1 to a_ count. If the count is 48, break.
Repeat.

To draw a_ circle some twips wide (backwards);
To draw a_ circle some twips wide (counterclockwise):
Put the twips times the pizza pie divided by 48 into a_ segment length.
Add 1 to the segment length.
Loop.
Stroke the segment length.
Turn left 1/48 of the way.
Add 1 to a_ count. If the count is 48, break.
Repeat.

\PAL
Para desenhar um console;
\CAL
To draw a_ console:
If the console is nil, exit.
Save the current canvas.
Mask only outside the console's box.
Draw the console's box with the console's border and the console's fill.
Draw the console's text.
Restore the current canvas.

To draw a_ dot some twips wide on the current spot with a_ color:
Make the dot the twips wide.
Center the dot on the context's spot.
Draw the dot with the color.

To draw a_ dot some twips wide on a_ spot with a_ color:
Make the dot the twips wide.
Center the dot on the spot.
Draw the dot with the color.

\PAL
Para desenhar uma elipse;
\CAL
To draw an ellipse:
Draw the ellipse with the black color and the clear color.

\PAL
Para desenhar uma elipse em um loco com uma cor;
\CAL
To draw an ellipse on a_ spot with a_ color:
Center the ellipse on the spot.
Draw the ellipse with the color and the clear color.

\PAL
Para desenhar uma elipse com uma cor de borda e uma cor de preenchimento;
\CAL
To draw an ellipse with a_ border color and a_ fill color:
If the pdf state's page flag is set, draw the ellipse with the border and the fill (pdf style); exit.
Privatize the ellipse.
Create the hpen of the current canvas given the border.
Create the hbrush of the current canvas given the fill.
If the border is clear, add the tpp to the ellipse's left-top.
Call "gdi32.dll" "Ellipse" with the current canvas and the ellipse's left and the ellipse's top and the ellipse's right and the ellipse's bottom.
Destroy the hbrush of the current canvas.
Destroy the hpen of the current canvas.

To draw an ellipse with a_ border color and a_ fill color (pdf style):
If the border and the fill are clear, exit.
Output setcolor given the border and the fill.
Put the ellipse's left and the ellipse's top into a_ spot.
Add the ellipse's y-extent divided by 2 to the spot's y-coord.
Output moveto given the spot.
Output the arc of the ellipse given "left-top".
Output the arc of the ellipse given "right-top".
Output the arc of the ellipse given "right-bottom".
Output the arc of the ellipse given "left-bottom".
Output stroke and fill given the border and the fill.

\PAL
Para desenhar uma elipse com uma cor;
\CAL
To draw an ellipse with a_ color:
Draw the ellipse with the color and the color.

To draw a_ fancy arrow some twips long with a_ color;
To stroke a_ fancy arrow some twips long with a_ color:
Put the color into the context's color.
Save the context.
Stroke the twips.
Turn around.
Move the twips divided by 8.
Save the context.
Turn left 1/8 of the way.
Draw a_ spiral starting with the twips divided by 4.
Restore the context.
Turn right 1/8 of the way.
Draw another spiral backwards starting with the twips divided by 4.
Restore the context.

\PAL
Para desenhar uma figura com uma cor;
\CAL
To draw a_ figure with a_ color:
Draw the figure with the color and the clear color.

To draw a_ figure with some sides about some twips wide:
Put 1 and the side count into a_ fraction.
Put the twips times the pizza pie divided by the sides into a_ segment length.
If the sides are 4, put the twips times 7/8 into the segment length. \ what is this? ***
Loop.
Stroke the segment length.
Turn the fraction.
Add 1 to a_ count. if the count is the sides, break.
Repeat.

To draw a_ figure with some sides some twips long;
To draw a_ figure with some sides and some twips:
Put 1 and the sides into a_ fraction.
Loop.
Stroke the twips.
Turn the fraction.
Add 1 to a_ count. If the count is the sides, break.
Repeat.

To draw a_ figure with some sides some twips long using a_ color;
To draw a_ figure with some sides and some twips using a_ color:
Put the color into the context's color.
Draw the figure with the sides and the twips.

To draw a_ gpbitmap at a_ spot (pdf style):
If the gpbitmap is nil, exit.
\ add xobject
Add an xobject pdf object given "image object".
Put "I" then the xobject's number into a_ name.
\  add to image resources in current page
Put "/" then the name then " " then the xobject's number then " 0 R" into a_ string.
Create a_ new string thing given the string.
Append the new string thing to the pdf state's current page's image strings.
\ finish setting up xobject
Append the xobject's number then " 0 obj" to the xobject.
Append "<<" to the xobject.
Append "/Type /XObject" to the xobject.
Append "/Subtype /Image" to the xobject.
Append "/ColorSpace /DeviceRGB" to the xobject.
Append "/Width " then the gpbitmap's width to the xobject.
Append "/Height " then the gpbitmap's height to the xobject.
Append "/BitsPerComponent 8" to the xobject.
Convert the gpbitmap to a_ buffer (pdf style).
Convert the buffer to a_ nibble string.
Append "/Filter /ASCIIHexDecode" to the xobject.
Append "/Length " then the nibble string's length to the xobject.
Append ">>" to the xobject.
Append "stream" to the xobject.
Append the nibble string to the xobject.
Append "endstream" to the xobject.
Append "endobj" to the xobject.
\ draw the image in the current contents
Put the gpbitmap's width times the tpp into a_ width.
Put the gpbitmap's height times the tpp into a_ height.
Put the spot's x-coord into an x-number.
Put the pdf state's current height minus the spot's y-coord minus the height into a_ y-number.
Output "q".
Output the width then " 0 0 " then the height then " " then the x-number then " " then the y-number then " cm".
Output "/" then the name then " Do".
Output "Q".

To draw a_ half circle about some twips wide;
To draw a_ half circle given a_ size:
Put the size times the pizza pie divided by 48 into a_ segment length.
Add 1 to the segment length.
Loop.
Stroke the segment length.
Turn right 1/48 of the way.
Add 1 to a_ count.
If the count is 24, exit.
Repeat.

To draw a_ half circle given a_ size (backwards);
To draw a_ half circle given a_ size (counterclockwise):
Put the size times the pizza pie divided by 48 into a_ segment length.
Add 1 to the segment length.
Loop.
Stroke the segment length.
Turn left 1/48 of the way.
Add 1 to a_ count.
If the count is 24, exit.
Repeat.

To draw a_ hexagon given a_ side length:
Stroke the side length.
Turn right 1/6 of the way.
Add 1 to a_ count. If the count is 6, break.
Repeat.

\PAL
Para desenhar uma reta;
\CAL
To draw a_ line:
Draw the line with the context's color.

To draw a_ line around some twips long; \ "around" is significant here
To draw a_ line about some twips long; \ "about" is significant here
To stroke a_ line around some twips long; \ "around" is significant here
To stroke a_ line about some twips long: \ "about" is significant here
Put the twips divided by 2 into some other twips.
Pick some third twips between the twips minus the other twips and the twips plus the other twips.
Stroke the line the third twips long.

To draw a_ line as_ high as_ a_ box with a_ color;
To draw a_ line as_ tall as_ a_ box with a_ color:
Put the color into the context's color.
Stroke the box's height.

To draw a_ line as_ wide as_ a_ box with a_ color:
Put the color into the context's color.
Stroke the box's width.

To draw a_ line between some twips and some other twips long;
To draw a_ line between some twips to some other twips long;
To draw a_ line some twips to some other twips long;
To stroke a_ line some twips to some other twips long:
Pick some third twips between the twips and the other twips.
Stroke the line the third twips long.

To draw a_ line some twips long;
To stroke a_ line some twips long:
\Wait for_ the delay. ***
Put the context's spot into the line's start.
Put the context's spot into the line's end.
Get a_ rise and a_ run given the context's heading.
Add the run times the twips divided by 10000 to the line's end's x-coord.
Add the rise times the twips divided by 10000 to the line's end's y-coord.
Put the line's end into the context's spot.
Draw the line with the context's color.
\If the delay is positive, refresh the screen.

\PAL
Para desenhar uma reta com um tamanho;
\CAL
To draw a_ line using some twips as_ the length;
To draw a_ line using some twips for_ the length:
Stroke the twips.

\PAL
Para desenhar uma reta com uma cor;
\CAL
To draw a_ line with a_ color:
If the pdf state's page flag is set, draw the line with the color (pdf style); exit.
Create the hpen of the current canvas given the color.
Call "gdi32.dll" "MoveToEx" with the current canvas and the line's start's x-coord and the line's start's y-coord and nil.
Call "gdi32.dll" "LineTo" with the current canvas and the line's end's x-coord and the line's end's y-coord.
Convert the color to a_ colorref.
Call "gdi32.dll" "SetPixelV" with the current canvas and the line's end's x-coord and the line's end's y-coord and the colorref.
Destroy the hpen of the current canvas.

To draw a_ line with a_ color (pdf style):
If the color is clear, exit.
Output setcolor given the color and the clear color.
Output moveto given the line's start.
Output lineto given the line's end.
Output stroke and fill given the color and the clear color.

To draw a_ line with a_ color around some twips long; \ "around" is significant here
To draw a_ line with a_ color about some twips long; \ "about" is significant here
To stroke a_ line with a_ color around some twips long; \ "around" is significant here
To stroke a_ line with a_ color about some twips long: \ "about" is significant here
Put the twips divided by 2 into some other twips.
Pick some third twips between the twips minus the other twips and the twips plus the other twips.
Stroke the line with the color the third twips long.

To draw a_ line with a_ color some twips long;
To stroke a_ line with a_ color some twips long:
Put the color into the context's color.
Put the context's spot into the line's start.
Stroke the twips.
Put the context's spot into the line's end.

To draw a_ line with a_ color some twips to some other twips long;
To stroke a_ line with a_ color some twips to some other twips long:
Pick some third twips between the twips and the other twips.
Stroke the line with the color the third twips long.

\PAL
Para desenhar um número em uma caixa com uma cor;
\CAL
To draw a_ number in a_ box with a_ color:
Put the number into a_ string.
Draw the string in the box with the color and "center".

\PAL
Para esboçar uma caixa (moldura);
Para emoldurar uma caixa;
\CAL
To draw only within a_ box;
To draw only inside a_ box;
To draw only in a_ box;
To draw only within a_ box from now on;
To draw only inside a_ box from now on;
To draw only in a_ box from now on;
To only draw within a_ box from now on;
To only draw inside a_ box from now on;
To only draw in a_ box from now on;
To only draw within a_ box;
To only draw inside a_ box;
To only draw in a_ box;
To draw within a_ box only;
To draw inside a_ box only;
To draw in a_ box only;
To put masking tape all around a_ box;
To put masking tape around a_ box: \ note that this masks the box's border as well
Privatize the box.
Indent the box 1 pixel.
Mask outside the box.
Put the original box into the context's box. \ *** original box? or indented one?

\PAL
Para desenhar uma imagem;
\CAL
To draw a_ picture:
If the pdf state's page flag is set, draw the picture (pdf style); exit.
If the picture is nil, exit.
Save the current canvas.
Mask outside the picture's box.
Call "gdiplus.dll" "GdipCreateFromHDC" with the current canvas and a_ gpgraphic's whereabouts.
Call "gdiplus.dll" "GdipSetPageUnit" with the gpgraphic and 2 [pixels].
Draw the picture on the gpgraphic at the picture's uncropped box's left and the picture's uncropped box's top.
Call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
Restore the current canvas.

\PAL
Para desenhar uma imagem (pdf);
Para desenhar uma imagem (estilo pdf);
\CAL
To draw a_ picture (pdf style):
If the picture is nil, exit.
Put the picture's box's left minus the picture's uncropped box's left divided by the tpp into an x-number.
Put the picture's box's top minus the picture's uncropped box's top divided by the tpp  into an y-number.
Put the picture's box's width divided by the tpp into a_ width.
Put the picture's box's height divided by the tpp into a_ height.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the width and the height and 0 and 137224 [pixelformat24bpprgb] and 0 and a_ gpbitmap's whereabouts.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" with the gpbitmap and a_ gpgraphic's whereabouts.
If the picture's grayscale flag is set, create a_ gpimageattributes (grayscale).
Call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
And 0 and 0 and the width and the height
And the x-number and the y-number and the width and the height
And 2 [unitpixel] and the gpimageattributes and nil and 0.
If the gpimageattributes is not nil, destroy the gpimageattributes.
Call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
Draw the gpbitmap at the picture's box's left-top (pdf style).
Call "gdiplus.dll" "GdipDisposeImage" with the gpbitmap.

To draw a_ picture on a_ gpgraphic at an x-coord and a_ y-coord:
If the picture is nil, exit.
If the picture's grayscale flag is set, create a_ gpimageattributes (grayscale).
Call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
And the x-coord and the y-coord and the picture's uncropped box's width and the picture's uncropped box's height
And 0 and 0 and the picture's gpbitmap's width and the picture's gpbitmap's height
And 2 [unitpixel] and the gpimageattributes and nil and 0.
If the gpimageattributes is not nil, destroy the gpimageattributes.

\PAL
Para desenhar um polígono;
\CAL
To draw a_ polygon:
Draw the polygon with the black color and the clear color.

\PAL
Para desenhar um polígono com uma cor de borda e uma cor de preenchimento;
\CAL
To draw a_ polygon with a_ border color and a_ fill color:
If the pdf state's page flag is set, draw the polygon with the border and the fill (pdf style); exit.
If the polygon is nil, exit.
Draw the polygon with the fill (fill only).
Draw the polygon with the border (border only).

To draw a_ polygon with a_ border color and a_ fill color (pdf style):
If the polygon is nil, exit.
If the border and the fill are clear, exit.
Output setcolor given the border and the fill.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, exit.
Output moveto given the vertex's spot.
Loop.
Get the vertex from the polygon's vertices.
If the vertex is nil, break.
Output lineto given the vertex's spot.
Repeat.
Output stroke and fill given the border and the fill.

\PAL
Para desenhar um polígono com uma cor;
\CAL
To draw a_ polygon with a_ color:
Draw the polygon with the color and the color.

\PAL
Para desenhar um polígono com uma cor (vazado);
Para desenhar um polígono com uma cor (bordas);
Para desenhar um polígono com uma cor (somente bordas);
Para desenhar um polígono com uma cor (arestas);
Para desenhar um polígono com uma cor (somente arestas);
\CAL
To draw a_ polygon with a_ color (border only):
If the polygon is nil, exit.
If the color is clear, exit.
Create the hpen of the current canvas given the color.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, exit.
Call "gdi32.dll" "MoveToEx" with the current canvas and the vertex's x-coord and the vertex's y-coord and nil.
Loop.
Get the vertex from the polygon's vertices.
If the vertex is nil, break.
Call "gdi32.dll" "LineTo" with the current canvas and the vertex's x-coord and the vertex's y-coord.
Repeat.
Destroy the hpen of the current canvas.
If the polygon's vertices' first's spot is the polygon's vertices' last's spot, exit.
Convert the color to a_ colorref.
Call "gdi32.dll" "SetPixelV" with the current canvas and the polygon's vertices' last's x-coord and the polygon's vertices' last's y-coord and the colorref.

\PAL
Para desenhar um polígono com uma cor (área);
Para desenhar um polígono com uma cor (somente área);
Para desenhar um polígono com uma cor (preenchimento);
Para desenhar um polígono com uma cor (somente preenchimento);
\CAL
To draw a_ polygon with a_ color (fill only):
If the polygon is nil, exit.
If the color is clear, exit.
Create the hpen of the current canvas given the clear color.
Create the hbrush of the current canvas given the color.
Call "gdi32.dll" "SetPolyFillMode" with the current canvas and 2 [winding].
Create a_ vertex array given the polygon's vertices.
Call "gdi32.dll" "Polygon" with the current canvas and the vertex array's spot pointer and the vertex array's count.
Destroy the vertex array.
Destroy the hbrush of the current canvas.
Destroy the hpen of the current canvas.

To draw a_ quarter circle about some twips wide;
To draw a_ quarter circle given a_ size:
Put the size times the pizza pie divided by 48 into a_ segment length.
Add 1 to the segment length.
Loop.
Stroke the segment length.
Turn right 1/48 of the way.
Add 1 to a_ count.
If the count is 12, exit.
Repeat.

To draw a_ quarter circle between some twips and some other twips wide:
Pick some third twips between the twips and the other twips.
Draw a_ quarter circle given the third twips.

To draw a_ quarter circle given a_ size (counterclockwise):
Put the size times the pizza pie divided by 48 into a_ segment length.
Add 1 to the segment length.
Loop.
Stroke the segment length.
Turn left 1/48 of the way.
Add 1 to a_ count.
If the count is 12, exit.
Repeat.

To draw a_ rectangle some twips by some other twips;
To draw a_ rectangle some twips wide by some other twips high:
Stroke the other twips.
Turn right.
Stroke the twips.
Turn right.
Stroke the other twips.
Turn right.
Stroke the twips.
Turn right.

\PAL
Para desenhar uma caixa arredondada;
\CAL
To draw a_ roundy box:
Draw the roundy box with the black color and the clear color.

\PAL
Para desenhar uma caixa arredondada com uma cor de borda e uma cor de preenchimento;
\CAL
To draw a_ roundy box with a_ border color and a_ fill color:
If the pdf state's page flag is set, draw the roundy box with the border and the fill (pdf style); exit.
Privatize the roundy box.
Create the hpen of the current canvas given the border.
Create the hbrush of the current canvas given the fill.
If the border is clear, add the tpp to the roundy box's left-top.
Put the roundy box's radius times 2 into a_ diameter number.
Call "gdi32.dll" "RoundRect" with the current canvas and the roundy box's left and the roundy box's top and the roundy box's right and the roundy box's bottom
And the diameter and the diameter.
Destroy the hbrush of the current canvas.
Destroy the hpen of the current canvas.

To draw a_ roundy box with a_ border color and a_ fill color (pdf style):
If the border and the fill are clear, exit.
If the roundy box's radius is 0, draw the roundy box as_ a_ box with the border and the fill (pdf style); exit.
Put the roundy box's radius into a_ radius.
Put the radius times 2 into an offset.
Put the roundy box into a_ box.
Output setcolor given the border and the fill.
\ initial moveto
Output moveto given the box's left and the box's top plus the radius.
\ left-top
Put the box's left and the box's top and the box's left plus the offset and the box's top plus the offset into an ellipse.
Output the arc of the ellipse given "left-top".
Output lineto given the box's right minus the radius and the box's top.
\ right-top
Put the box's right minus the offset and the box's top and the box's right and the box's top plus the offset into the ellipse.
Output the arc of the ellipse given "right-top".
Output lineto given the box's right and the box's bottom minus the radius.
\ right-bottom
Put the box's right minus the offset and the box's bottom minus the offset and the box's right and the box's bottom into the ellipse.
Output the arc of the ellipse given "right-bottom".
Output lineto given the box's left plus the radius and the box's bottom.
\ left-bottom
Put the box's left and the box's bottom minus the offset and the box's left plus the offset and the box's bottom into the ellipse.
Output the arc of the ellipse given "left-bottom".
\ finish up
Output "h".
Output stroke and fill given the border and the fill.

\PAL
Para desenhar uma caixa arredondada com uma cor;
\CAL
To draw a_ roundy box with a_ color:
Draw the roundy box with the color and the color.

To draw a_ row of a_ text:
If the text is nil, exit.
If the row is nil, exit.
Get a_ box given the row and the text.
Draw the row's working string in the box with the text's pen and the text's font and the text's alignment.

To draw a_ row of a_ text (editing):
If the text is nil, exit.
If the row is nil, exit.
Draw the selection box for_ the row of the text.
Get a_ box given the row and the text.
Draw the row's working string in the box with the text's pen and the text's font and the text's alignment.

To draw the selection box for_ a_ row of a_ text:
If the text is nil, exit.
If the row is nil, exit.
If the row of the text is not selected, exit.
Get a_ selection box given the row and the text.
Draw the selection box with the hilite color and the hilite color.

To draw a_ spiral backward given some twips;
To draw a_ spiral backward starting with some twips;
To draw a_ spiral given a_ size (backwards):
Privatize the size.
Loop.
Draw a_ half circle given the size (backwards).
Divide the size by 2.
Add 1 to a_ count.
If the count is 5, break.
Repeat.

To draw a_ spiral starting with some twips;
To draw a_ spiral given a_ size:
Privatize the size.
Loop.
Draw a_ half circle given the size.
Divide the size by 2.
Add 1 to a_ count. If the count is 5, break.
Repeat.

\PAL
Para esboçar um loco;
\CAL
To draw a_ spot:
Draw the spot with the black color.

\PAL
Para esboçar um loco com uma cor;
\CAL
To draw a_ spot with a_ color:
Convert the color to a_ colorref.
Call "gdi32.dll" "SetPixelV" with the current canvas and the spot's x-coord and the spot's y-coord and the colorref.

To draw a_ star given a_ point count and a_ size:
Put 1 and the point count into a_ fraction.
Loop.
Turn right 1/48 of the way.
Stroke the size.
Turn around.
Turn left 1/24 of the way.
Stroke the size.
Turn around.
Turn right 1/48 of the way.
Turn right the fraction of the way.
Add 1 to a_ count. If the count is the point count, break.
Repeat.

\PAL
Para desenhar uma sequência em uma caixa (à esquerda);
\CAL
To draw a_ string at the left of a_ box:
Draw the string at the left of the box with the black color and the default font.

\PAL
Para desenhar uma sequência em uma caixa com uma cor (à esquerda);
\CAL
To draw a_ string at the left of a_ box with a_ color:
Draw the string at the left of the box with the color and the default font.

\PAL
Para desenhar uma sequência em uma caixa com uma cor e uma fonte (à esquerda);
\CAL
To draw a_ string at the left of a_ box with a_ color and a_ font:
Draw the string in the box with the color and the font and "left".

\PAL
Para desenhar uma sequência em uma caixa com uma fonte (à esquerda);
\CAL
To draw a_ string at the left of a_ box with a_ font:
Draw the string at the left of the box with the black color and the font.

\PAL
Para desenhar uma sequência em uma caixa (à direita);
\CAL
To draw a_ string at the right of a_ box:
Draw the string at the right of the box with the black color and the default font.

\PAL
Para desenhar uma sequência em uma caixa com uma cor (à direita);
\CAL
To draw a_ string at the right of a_ box with a_ color:
Draw the string at the right of the box with the color and the default font.

\PAL
Para desenhar uma sequência em uma caixa com uma cor e uma fonte (à direita);
\CAL
To draw a_ string at the right of a_ box with a_ color and a_ font:
Draw the string in the box with the color and the font and "right".

\PAL
Para desenhar uma sequência em uma caixa com uma fonte (à direita);
\CAL
To draw a_ string at the right of a_ box with a_ font:
Draw the string at the right of the box with the black color and the font.

\PAL
Para desenhar uma sequência em um loco com uma cor;
\CAL
To draw a_ string at a_ spot with a_ color:
Draw the string at the spot with the color and the default font.

\PAL
Para desenhar uma sequência em um loco com uma cor e uma fonte;
\CAL
To draw a_ string at a_ spot with a_ color and a_ font:
If the pdf state's page flag is set, draw the string at the spot with the color and the font (pdf style); exit.
Set the colorref of the current canvas given the color.
Create the hfont of the current canvas given the font.
Adjust spacing given the string.
Put the string's first into a_ substring's first.
Put the substring's first plus the text cutoff minus 1 into the substring's last.
Privatize the spot.
Loop.
If the substring is blank, break.
If the substring's last is greater than the string's last, put the string's last into the substring's last.
Call "gdi32.dll" "TextOutA" with the current canvas and the spot's x-coord and the spot's y-coord and the substring's first and the substring's length.
Get a_ width given the substring and the current canvas.
Add the width to the spot's x-coord.
Move the substring given the text cutoff.
Repeat.
Destroy the hfont of the current canvas.

To draw a_ string at a_ spot with a_ color and a_ font (pdf style):
If the string is blank, exit.
Privatize the spot.  
Include the font in the current pdf.
Include the font in the pdf state's current page.
Find a_ definition pdf object given the font's name and the pdf state's font index.
If the definition is nil, exit. \ error
Create a_ font info given the font and the string.
Output the pdf border given the color.
Output the pdf fill given the color.
Output "BT".
Output "/" then the definition's font name then " " then the font's adjusted height then " Tf".
\  add the font's adjusted height minus the font info's internal leading to the spot's y. \ just plain wrong
Add the font info's ascent to the spot's y-coord. \ fix for line above
Output the spot without advancing.
Output "Td".
Output "[" without advancing.
Convert the font info to pdf em units.
Convert the string and the font info and the definition's font info into a_ buffer for_ pdf output.
Output the buffer without advancing.
Output "]" without advancing.
Output " TJ".
Output "ET".
Destroy the font info.

\PAL
Para desenhar uma sequência em uma caixa;
\CAL
To draw a_ string in a_ box:
Draw the string in the box with the black color and the default font and "left".

\PAL
Para desenhar uma sequência em uma caixa sobre um número com uma cor e uma fonte e um alinhamento;
\CAL
To draw a_ string in a_ box over a_ number with a_ color and a_ font and an alignment:
Privatize the box.
If the alignment is "esquerda", add the number to the box's left.
If the alignment is "left", add the number to the box's left.
If the alignment is "zquierda", add the number to the box's left.
If the alignment is "direita", subtract the number from the box's right.
If the alignment is "derecho", subtract the number from the box's right.
Draw the string in the box with the color and the font and the alignment.

\PAL
Para desenhar uma sequência em uma caixa com um alinhamento;
\CAL
To draw a_ string in a_ box with an alignment:
Draw the string in the box with the black color and the default font and the alignment.

\PAL
Para desenhar uma sequência em uma caixa com uma cor;
\CAL
To draw a_ string in a_ box with a_ color:
Draw the string in the box with the color and the default font and "left".

\PAL
Para desenhar uma sequência em uma caixa com uma cor e um alinhamento;
\CAL
To draw a_ string in a_ box with a_ color and an alignment:
Draw the string in the box with the color and the default font and the alignment.

\PAL
Para desenhar uma sequência em uma caixa com uma cor e uma fonte e um alinhamento;
\CAL
To draw a_ string in a_ box with a_ color and a_ font and an alignment:
Get an offset pair given the string and the box and the font and the alignment.
Draw the string at the box's left-top plus the offset pair with the color and the font.

\PAL
Para desenhar uma sequência em uma caixa com uma fonte e um alinhamento;
\CAL
To draw a_ string in a_ box with a_ font and an alignment:
Draw the string in the box with the black color and the font and the alignment.

\PAL
Para desenhar uma sequência em uma caixa (centralizando);
Para desenhar uma sequência no centro de uma caixa;
\CAL
To draw a_ string in the center of a_ box:
Draw the string in the center of the box with the black color and the default font.

\PAL
Para desenhar uma sequência em uma caixa com uma cor (centralizando);
Para desenhar uma sequência no centro de uma caixa com uma cor;
\CAL
To draw a_ string in the center of a_ box with a_ color:
Draw the string in the center of the box with the color and the default font.

\PAL
Para desenhar uma sequência em uma caixa com uma cor e uma fonte (centralizando);
Para desenhar uma sequência no centro de uma caixa com uma cor e uma fonte;
\CAL
To draw a_ string in the center of a_ box with a_ color and a_ font:
Draw the string in the box with the color and the font and "center".

\PAL
Para desenhar uma sequência em uma caixa com uma fonte (centralizando);
Para desenhar uma sequência no centro de uma caixa com uma fonte;
\CAL
To draw a_ string in the center of a_ box with a_ font:
Draw the string in the center of the box with the black color and the font.

\PAL
Para desenhar um terminal;
\CAL
To draw a_ terminal:
If the terminal is nil, exit.
Save the current canvas.
Mask only outside the terminal's box.
Draw and fill the terminal's box with the black color.
Write the terminal's quoras in the terminal's box.
Restore the current canvas.

\PAL
Para desenhar um texto;
\CAL
To draw a_ text:
If the text is nil, exit.
Save the current canvas.
Mask outside the text's box.
Draw any visible rows of the text.
Restore the current canvas.

\PAL
Para desenhar um texto (editando);
Para desenhar um texto (edição);
\CAL
To draw a_ text (editing):
If the text is nil, exit.
Save the current canvas.
Mask outside the text's box.
Draw any visible rows of the text (editing).
Draw the caret in the text.
Restore the current canvas.

a_ drive is a_ string. \ start of path to first slash = c:\ OR start of path to fourth slash = \\computer\share\

a_ drive kind is a_ string.

a_ drive name is a_ string.

\PAL
Para copiar uma rota em outra rota no sistema;
Para copiar uma rota para outra rota no sistema;
Para duplicar uma rota em outra rota no sistema;
\CAL
To duplicate a_ path to another path in the file system:
If the path is directory-format, duplicate the path to the other path in the file system (directory).
If the path is file-format, duplicate the path to the other path in the file system (file).

\PAL
Para copiar uma rota em outra rota no sistema (pasta);
Para copiar uma rota para outra rota no sistema (pasta);
Para duplicar uma rota em outra rota no sistema (pasta);
\CAL
To duplicate a_ path to another path in the file system (directory):
If the path is in the other path, put "Error duplicando directorio '" then the path then "' - invalid recursion." into o erro de e/s; exit.
If the path is not in the file system, put "Error duplicando directorio '" then the path then "'." into o erro de e/s; exit.
If the other path is not in the file system, create the other path in the file system.
Loop.
Get an item from the path.
If the item is not found, exit.
Put the path into a_ third path.
Append the item's designator to the third path.
Put the other path into a_ fourth path.
Append the item's designator to the fourth path.
Duplicate the third path to the fourth path in the file system.
Repeat.

\PAL
Para copiar uma rota em outra rota no sistema (arquivo);
Para copiar uma rota para outra rota no sistema (arquivo);
Para duplicar uma rota em outra rota no sistema (arquivo);
\CAL
To duplicate a_ path to another path in the file system (file):
Privatize the path.
Null terminate the path.
Privatize the other path.
Null terminate the other path.
Call "kernel32.dll" "CopyFileA" with the path's first and the other path's first and 0 returning a_ number.
Clear o erro de e/s.
If the number is not 0, set the path to read-write mode; exit.
Put "Error duplicando archivo '" then the path then "'." into o erro de e/s.

a_ dyad is a_ thing with
a_ name,
a_ value string.

The e-key is a_ key equal to 69.

The eight byte is a_ byte equal to 56.

The eight key is a_ key equal to 56.

An ellipse
has a_ box
\PAL
e uma caixa redefinindo o box.

The ellipsis byte is a_ byte equal to 133.

The em-dash byte is a_ byte equal to 151.

An email has
a_ smtp server,
a_ sender,
a_ recipient,
a_ subject,
a_ message.

The en-dash byte is a_ byte equal to 150.

To encrypt a_ buffer given a_ passphrase string: \ sets i/o error if failure
Clear o erro de e/s.
Create a_ crypt session given the passphrase.
If the crypt session is nil, exit.
Put the buffer into a_ temp buffer.
Put the temp buffer's length into a_ length.
Call "advapi32.dll" "CryptEncrypt" with the crypt session's hcryptkey and 0 and 1 and 0 and the temp buffer's first
And the length's whereabouts and the length returning a_ result number.
If the result number is 0, put "Error encriptando datos." into o erro de e/s; destroy the crypt session; exit.
Destroy the crypt session.
Convert the temp buffer to a_ nibble string.
Put the nibble string into the buffer.

The end key is a_ key equal to 35.

\PAL
Para completar a impressão;
\CAL
To end printing:
If the pdf state's document flag is set, end printing (pdf style); exit.
Call "gdi32.dll" "EndDoc" with the printer canvas.
Finalize the printer canvas.

To end printing (pdf style):
If the pdf state's document flag is not set, exit.
End printing the pdf state's pdf pointer's target.

To end printing a_ pdf:
End printing the pdf (finish the parent).
End printing the pdf (append the outline).
End printing the pdf (finish the root).
Clear the pdf.
End printing the pdf (append header).
End printing the pdf (offset and append objects).
End printing the pdf (append xref table).
End printing the pdf (append trailer).
End printing the pdf (append footer).
Destroy the pdf state's font index.
Destroy the pdf state's outline entries.
Destroy the pdf state's objects.
Clear the pdf state's document flag.

To end printing a_ pdf (append footer):
Append "startxref" then the crlf string to the pdf.
Append the pdf state's xref offset then the crlf string to the pdf.
Append "%%EOF" to the pdf.

To end printing a_ pdf (append header):
Append "%PDF-1.3" then the crlf string to the pdf.
Append "%âãÏÓ" then the crlf string to the pdf.
Append the crlf string to the pdf.

To end printing a_ pdf (append the outline entries - create the objects):
Get a_ pdf outline entry from the pdf state's outline entries.
If the pdf outline entry is nil, exit.
Add an entry pdf object given "outline entry".
Put the entry into the pdf outline entry's pdf object.
Repeat.

To end printing a_ pdf (append the outline entries):
If the pdf state's outline entries are empty, exit.
End printing the pdf (append the outline entries - create the objects).
Loop.
Get a_ pdf outline entry from the pdf state's outline entries.
If the pdf outline entry is nil, exit.
Put the pdf outline entry's pdf object into an object pdf object.
Append the object's number then " 0 obj" to the object.
Append "<<" to the object.
Convert the pdf outline entry's title to a_ pdf string.
Append "/Title " then the pdf string to the object.
Append "/Parent " then the pdf state's outline's number then " 0 R" to the object.
If the pdf outline entry's next is not nil, append "/Next " then the pdf outline entry's next's pdf object's number then " 0 R" to the object.
If the pdf outline entry's previous is not nil, append "/Prev " then the pdf outline entry's previous' pdf object's number then " 0 R" to the object.
Append "/Dest [" then the pdf outline entry's destination then " 0 R /XYZ null " then the pdf outline entry's  page height then " null]" to the object.
Append ">>" to the object.
Append "endobj" to the object.
Repeat.

To end printing a_ pdf (append the outline):
Void the pdf state's outline.
If the pdf state's outline entries are empty, exit.
Add an outline pdf object given "outline".
Put the outline into the pdf state's outline.
End printing the pdf (append the outline entries).
Append the outline's number then " 0 obj" to the outline.
Append "<<" to the outline.
Append "/Type /Outlines" to the outline.
Append "/First " then the pdf state's outline entries' first's pdf object's number then " 0 R" to the outline.
Append "/Last " then the pdf state's outline entries' last's pdf object's number then " 0 R" to the outline.
Append "/Count " then the pdf state's outline entries' count to the outline.
Append ">>" to the outline.
Append "endobj" to the outline.

To end printing a_ pdf (append trailer):
Append "trailer" then the crlf string to the pdf.
Append "<<" then the crlf string to the pdf.
Put the pdf state's objects' count plus 1 into a_ count.
Append "/Size " then the count then the crlf string to the pdf.
Append "/Root " then the pdf state's root's number then " 0 R" then the crlf string to the pdf.
Append ">>" then the crlf string to the pdf.
Append the crlf string to the pdf.

To end printing a_ pdf (append xref table):
Put the pdf's length into the pdf state's xref offset.
Append "xref" then the crlf string to the pdf.
Put the pdf state's objects' count plus 1 into a_ count.
Append "0 " then the count then the crlf string to the pdf.
Append "0000000000 65535 f" then the crlf string to the pdf.
Loop.
Get a_ pdf object from the pdf state's objects.
If the pdf object is nil, break.
Zero fill the pdf object's offset given 10 and append it to the pdf.
Append " 00000 n" then the crlf string to the pdf.
Repeat.
Append the crlf string to the pdf.

To end printing a_ pdf (finish the parent):
Put the pdf state's parent into a_ parent pdf object.
Append "/Kids [" to the parent without advancing.
Loop.
Get a_ pdf object from the pdf state's objects.
If the pdf object is nil, break.
If the pdf object's kind is not "page", repeat.
If a_ flag is set, append " " to the parent without advancing.
Append the pdf object's number then " 0 R" to the parent without advancing.
Set the flag.
Add 1 to a_ count.
If the count is evenly divisible by 20, append the crlf string then "  " to the parent without advancing.
Repeat.
Append "]" to the parent.
Append "/Count " then the count to the parent.
Append ">>" to the parent.
Append "endobj" to the parent.

To end printing a_ pdf (finish the root):
Put the pdf state's root into a_ root pdf object.
Append "/Pages " then the pdf state's parent's number then " 0 R" to the root.
Find a_ pdf object given "page".
Append "/OpenAction [" then the pdf object's number then " 0 R /XYZ null null 1]" to the root.
Append "/PageMode /UseNone" to the root.
If the pdf state's outline is not nil, append "/Outlines " then the pdf state's outline's number then " 0 R" to the root.
Append ">>" to the root.
Append "endobj" to the root.

To end printing a_ pdf (offset and append objects):
Get a_ pdf object from the pdf state's objects.
If the pdf object is nil, break.
Put the pdf's length into the pdf object's offset.
Append the pdf object's data to the pdf.
Append the crlf string to the pdf.
Repeat.

\PAL
Para completar uma folha vertical;
Para completar uma folha horizontal;
Para completar uma folha;
\CAL
To end a_ sheet:
If the pdf state's document flag is set, end the sheet (pdf style); exit.
Call "gdi32.dll" "EndPage" with the printer canvas.
Put the memory canvas into the current canvas.
Put the saved tpp into the tpp.

To end a_ sheet (pdf style - finish the current contents):
Put the pdf state's current contents into a_ content pdf object.
Put the content's data into a_ buffer.
Clear the content's data.
Append the content's number then " 0 obj" to the content.
Append "<</Length " then the buffer's length then " >>" to the content.
Append "stream" to the content.
Append the buffer to the content's data.
Append "endstream" to the content.
Append "endobj" to the content.
Clear the pdf state's page flag.

To end a_ sheet (pdf style - finish the current page - font resources):
Put the pdf state's current page into a_ page pdf object.
If the page's font strings are empty, exit.
Append "/Font <<" to the page without advancing.
Loop.
Get a_ string thing from the page's font strings.
If the string thing is nil, break.
If a_ flag is set, append " " to the page without advancing.
Append the string thing's string to the page without advancing.
Set the flag.
Repeat.
Append ">>" to the page.

To end a_ sheet (pdf style - finish the current page - image resources):
Put the pdf state's current page into a_ page pdf object.
If the page's image strings are empty, exit.
Append "/XObject <<" to the page without advancing.
Loop.
Get a_ string thing from the page's image strings.
If the string thing is nil, break.
If a_ flag is set, append " " to the page without advancing.
Append the string thing's string to the page without advancing.
Set the flag.
Repeat.
Append ">>" to the page.

To end a_ sheet (pdf style - finish the current page):
Put the pdf state's current page into a_ page pdf object.
Append "/Resources" to the page.
Append "<<" to the page.
Append "/ProcSet [/PDF /Text /ImageC]" to the page.
End the sheet (pdf style - finish the current page - font resources).
End the sheet (pdf style - finish the current page - image resources).
Append ">>" to the page. \ end resources
Append ">>" to the page. \ end page
Append "endobj" to the page.

To end a_ sheet (pdf style):
End the sheet (pdf style - finish the current page).
End the sheet (pdf style - finish the current contents).

The end-of-medium byte is a_ byte equal to 25.

The end-of-text byte is a_ byte equal to 3.

The end-of-transmission byte is a_ byte equal to 4.

The end-of-transmission-block byte is a_ byte equal to 23.

\PAL
Para aumentar uma caixa dado alguns twips;
Para aumentar uma caixa em alguns twips;
\CAL
To enlarge a_ box by some twips:
Subtract the twips from the box's left-top.
Add the twips to the box's right-bottom.

\PAL
Para aumentar uma elipse dado alguns twips;
Para aumentar uma elipse em alguns twips;
\CAL
To enlarge an ellipse by some twips:
Subtract the twips from the ellipse's left-top.
Add the twips to the ellipse's right-bottom.

\PAL
Para enfileirar um evento;
Para pôr um evento na fila;
\CAL
To enque an event:
Append the event to the event queue.

The enquiry byte is a_ byte equal to 5.

The enter key is a_ key equal to 13.

The equal-sign byte is a_ byte equal to 61.

The equal-sign key is a_ key equal to 187.

\PAL
Para apagar o interior de uma caixa;
Para apagar dentro de uma caixa;
\CAL
To erase the insides of a_ box;
To erase inside a_ box;
To clear inside a_ box:
Draw the box with the clear color and the black color.

The escape byte is a_ byte equal to 27.

The esc key is a_ key equal to 27.

The escape key is a_ key equal to 27.

\PAL
Para estimar uma elevação e uma corrida dada uma direção;
Para estimar uma subida e uma corrida dada uma direção;
\CAL
To estimate a_ rise and a_ run given a_ heading:
Put the heading into a_ low heading.
Round the low heading down to the nearest multiple of 20.
Get a_ low rise and a_ low run given the low heading.
Put the heading into a_ high heading.
Round the high heading up to the nearest multiple of 20.
Get a_ high rise and a_ high run given the high heading.
Put the low rise plus the high rise divided by 2 into the rise. 
Put the low run plus the high run divided by 2 into the run.

The euro-sign byte is a_ byte equal to 128.

\An event is a_ thing with
\a_ kind,
\a_ shift flag,
\a_ ctrl flag,
\an alt flag,
\a_ spot,
\a_ key, a_ byte.

An event is a_ thing with
a_ kind [refresh, set cursor, key down, left click, left double click, right click, right double click, deactivate, activate, done], \ English
\PAL
uma sequência chamada tipo [atualizar, definir cursor, tecla abaixo, clique, duplo clique, clique-dir, duplo clique-dir, desativar, ativar, feito],  \ kind in Portuguese
a_ shift flag,
a_ ctrl flag,
an alt flag,
a_ spot,
a_ key,
a_ byte,
\PAL
uma signa shift at the shift flag,
uma signa ctrl at the ctrl flag,
uma signa alt at the alt flag,
um loco at the spot,
uma tecla at the key.

The event queue is an event queue.

An event queue is some events.

The exclamation byte is a_ byte equal to 33.

The exclamation-mark byte is a_ byte equal to 33.

\PAL
Para aumanter qualquer seleção em um texto dado um loco;
\CAL
To extend any selection in a_ text given a_ spot:
If the text is nil, exit.
Get the text's caret given the spot and the text.
Clear the text's last operation.

\PAL
Para aumanter uma caixa para incluir outra caixa;
\CAL
To extend a_ box to include another box:
If the other box's left is less than the box's left, put the other box's left into the box's left.
If the other box's top is less than the box's top, put the other box's top into the box's top.
If the other box's right is greater than the box's right, put the other box's right into the box's right.
If the other box's bottom is greater than the box's bottom, put the other box's bottom into the box's bottom.

An extension is a_ string. \ last dot to end of path = .ext

Some extra points are some points.

\PAL
Para extrair um designador de uma rota;
\CAL
To extract a_ designator from a_ path:
Clear the designator.
Extract a_ drive from the path.
Slap a_ path substring on the path.
Add the drive's length to the path substring's first.
If the path substring is blank, put the drive into the designator; exit.
Slap a_ substring on the last byte of the path substring.
If the substring's first's target is the backslash byte, subtract 1 from the substring's first.
Loop.
If the substring's first is less than the path substring's first, break.
If the substring's first's target is the backslash byte, break.
Subtract 1 from the substring's first.
Repeat.
Add 1 to the substring's first.
Put the substring into the designator.

\PAL
Para extrair uma pasta de uma rota;
\CAL
To extract a_ directory from a_ path:
Clear the directory.
Extract a_ drive from the path.
If the drive is blank, exit.
Slap a_ substring on the path.
Add the drive's length to the substring's first.
If the substring is blank, exit.
If the substring's last's target is the backslash byte, subtract 1 from the substring's last.
Loop.
If the substring is blank, break.
If the substring's last's target is the backslash byte, break.
Subtract 1 from the substring's last.
Repeat.
Put the drive then the substring into the directory.

\PAL
Para extrair um nome de pasta de uma rota;
\CAL
To extract a_ directory name from a_ path:
Clear the directory name.
If the path is not directory-format, exit.
Extract the directory name as_ a_ designator from the path.

\PAL
Para extrair um nome de pasta de uma rota (sem barra);
\CAL
To extract a_ directory name w/o slash from a_ path:
Extract the directory name w/o slash as_ a_ directory name from the path.
If the directory name w/o slash is blank, exit.
Remove the last byte from the directory name w/o slash.

\PAL
Para extrair um disco de uma rota;
\CAL
To extract a_ drive from a_ path:
Clear the drive.
If the path's length is less than 3, exit.
Slap a_ substring on the first byte of the path.
Add 2 to the substring's last.
If the substring ends with ":\", put the substring into the drive; exit.
If the substring does not start with "\\", exit.
Slap the substring on the first byte of the path.
Loop.
If the substring's last is greater than the path's last, exit.
If the substring's last's target is the backslash byte, add 1 to a_ count.
If the count is 4, break. \ "\\computer\share\"
Add 1 to the substring's last.
Repeat.
Put the substring into the drive.

\PAL
Para extrair uma extensão de uma rota;
\CAL
To extract an extension from a_ path:
Clear the extension.
If the path is blank, exit.
Slap a_ substring on the last byte of the path.
Loop.
If the substring's first is less than the path's first, exit.
If the substring's first's target is the colon byte, exit.
If the substring's first's target is the backslash byte, exit.
If the substring's first's target is the period byte, break.
Subtract 1 from the substring's first.
Repeat.
Put the substring into the extension.

\PAL
Para extrair um nome de arquivo de uma rota;
\CAL
To extract a_ file name from a_ path:
Clear the file name.
If the path is not file-format, exit.
Extract the file name as_ a_ designator from the path.

\PAL
Para extrair um nome de arquivo sem extensão de uma rota;
\CAL
To extract a_ file name w/o extension from a_ path:
Extract the file name w/o extension as_ a_ file name from the path.
Extract an extension from the path.
Remove trailing bytes from the file name w/o extension given the extension's length.

\PAL
Para extrair uma imagem de uma caixa;
\CAL
To extract a_ picture given a_ box:
Put the box's width divided by the tpp into a_ width.
Put the box's height divided by the tpp into a_ height.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the width and the height and 0 and 137224 [pixelformat24bpprgb] and 0 and a_ gpbitmap's whereabouts.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" with the gpbitmap and a_ gpgraphic's whereabouts.
Call "gdiplus.dll" "GdipGetDC" with the gpgraphic and a_ bitmap canvas' whereabouts.
Normalize the bitmap canvas.
Call "gdi32.dll" "BitBlt" with the bitmap canvas and 0 and 0 and the box's width and the box's height
And the current canvas and the box's left and the box's top and 13369376 [srccopy].
Call "gdiplus.dll" "GdipReleaseDC" with the gpgraphic and the bitmap canvas.
Call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
Create the picture given the gpbitmap.
Put the box into the picture's box.
Put the box into the picture's uncropped box.

\PAL
Para extrair uma sequência de um texto;
\CAL
To extract a_ string from a_ text:
If the text is nil, clear the string; exit.
Convert the text's rows to the string.
Remove any trailing linefeed byte from the string.
Remove any trailing return byte from the string.

\PAL
Para extrair uma sequência de um texto (sem adicação de avanço de linha);
\CAL
To extract a_ string from a_ text (no linefeed additions):
If the text is nil, clear the string; exit.
Convert the text's rows to the string (no linefeed additions).
Remove any trailing return byte from the string.

\PAL
Para extrair uma sequência de um texto (bytes selecionados);
\CAL
To extract a_ string from a_ text (selected bytes):
Clear the string.
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
Slap a_ substring on any selected bytes in the row of the text.
If the substring is blank, repeat.
Append the substring to the string.
If the substring's last's target is the return byte, append the linefeed byte to the string.
Repeat.

The f-key is a_ key equal to 70.

The f1-key is a_ key equal to 112.

The f10-key is a_ key equal to 121.

The f11-key is a_ key equal to 122.

The f12-key is a_ key equal to 123.

The f2-key is a_ key equal to 113.

The f3-key is a_ key equal to 114.

The f4-key is a_ key equal to 115.

The f5-key is a_ key equal to 116.

The f6-key is a_ key equal to 117.

The f7-key is a_ key equal to 118.

The f8-key is a_ key equal to 119.

The f9-key is a_ key equal to 120.

\PAL
Para mirar qualquer direção;
Para fitar qualquer direção;
Para olhar para qualquer direção;
\CAL
To face any way you want;
To face any which way:
Pick a_ heading.

\PAL
Para mirar o leste;
Para fitar o leste;
Para olhar para o leste;
\CAL
To face east:
Put 960 into the context's heading.

\PAL
Para mirar o norte;
Para fitar o norte;
Para olhar para o norte;
\CAL
To face north:
Put 0 into the context's heading.

\PAL
Para mirar o sul;
Para fitar o sul;
Para olhar para o sul;
\CAL
To face south:
Put 1920 into the context's heading.

\PAL
Para mirar o oeste;
Para fitar o oeste;
Para olhar para o oeste;
\CAL
To face west:
Put 2880 into the context's heading.

a_ fancy arrow is a_ figure.

The feminine byte is a_ byte equal to 170.

a_ figure is a_ polygon.

The figures are some polygons.

a_ file is a_ handle.

a_ file name is a_ string. \ after the last slash to end of path = file.ext

a_ file name w/o extension is a_ string. \ after the last slash to last dot or end of path = file

The file-separator byte is a_ byte equal to 28.

a_ filetime is a_ record with
a_ number called dwlowdatetime,
a_ number called dwhighdatetime.

\PAL
Para preencher uma caixa com uma cor;
\CAL
To fill a_ box with a_ color:
Draw the box with the clear color and the color.

\PAL
Para preencher bytes com um byte iniciando em um ponteiro dado um contador de bytes;
\CAL
To fill bytes with a_ byte starting at a_ pointer for_ a_ byte count:
Intel $8BBD0C000000. \ mov edi,[ebp+12] \ the pointer
Intel $8B3F. \ mov edi,[edi]
Intel $8B8D10000000. \ mov ecx,[ebp+16] \ the count
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $8A00. \ mov al,[eax]
Intel $FC. \ cld
Intel $F3AA. \ rep stosb

\PAL
Para preencher uma elipse em um loco com uma cor;
\CAL
To fill an ellipse on a_ spot with a_ color:
Center the ellipse on the spot.
Draw the ellipse with the clear color and the color.

\PAL
Para preencher uma sequência com um byte dado um contador;
\CAL
To fill a_ string with a_ byte given a_ count:
Reassign the string's first given the count.
Fill bytes with the byte starting at the string's first for_ the count.
Put the string's first plus the count minus 1 into the string's last.

\PAL
Para finalizar depois de executar;
\CAL
To finalize after run:
If the heap count is 0, exit.
Put the heap count into a_ count.
Put the count then " drip(s)." into a_ string.
Debug the string.

To finalize the canvases:
Finalize the memory canvas.
Finalize the screen canvas.

To finalize the cgi:
Call "kernel32.dll" "FreeConsole".

To finalize the colors:

To finalize com:
Call "ole32.dll" "CoUninitialize".

To finalize a_ context:
Destroy the choices.
Destroy the figures.
Destroy the context stack.
Destroy the context.

To finalize the cursors:
Call "user32.dll" "DestroyCursor" with the i-beam cursor.
Call "user32.dll" "DestroyCursor" with the hand cursor.
Call "user32.dll" "DestroyCursor" with the arrow cursor.

To finalize the fonts:
Call "gdi32.dll" "RemoveFontMemResourceEx" with the osmosian font resource.

To finalize gdi+:
Call "gdiplus.dll" "GdiplusShutdown" with the gptoken.

To finalize the memory canvas:
Call "gdi32.dll" "SelectObject" with the memory canvas and the saved memory hbitmap returning an hbitmap.
Call "gdi32.dll" "DeleteObject" with the hbitmap.
Call "gdi32.dll" "DeleteDC" with the memory canvas.

To finalize the module:

To finalize the mouse:

To finalize the printer canvas:
Call "kernel32.dll" "GlobalFree" with the printer device mode handle.
Put 0 into the printer canvas.

To finalize the screen:

To finalize the screen canvas:

To finalize a_ talker:
If the talker is nil, exit.
Call the talker's vtable's release with the talker.
Put nil into the talker.

To finalize the window:
Call "user32.dll" "DestroyWindow" with the main window.
Loop.
Call "user32.dll" "GetMessageA" with an msg's whereabouts and 0 and 0 and 0 returning a_ number.
If the number is less than 1, break.
Call "user32.dll" "TranslateMessage" with the msg's whereabouts.
Call "user32.dll" "DispatchMessageA" with the msg's whereabouts.
Repeat.
Flush the event queue.
Destroy the current event.

To finalize winsock:
Call "ws2_32.dll" "WSACleanup".

The find anchor is an anchor.

\PAL
Para encontrar uma escolha dado um loco;
\CAL
To find a_ choice given a_ spot:
Start with nothing in the choice.
Loop.
Get the [first/next] choice from the choices.
If the choice is missing, exit.
If the spot is in the choice's box, break.
Repeat.

To find a_ dyad given some dyads and a_ name:
Void the dyad.
Loop.
Get the dyad from the dyads.
If the dyad is nil, exit.
If the dyad's name is the name, exit.
Repeat.

To find next given a_ row and a_ text and a_ flag:
Clear the flag.
If the text is nil, exit.
If the row is nil, exit.
Slap a_ substring on the row's string.
Put the substring's first plus the find string's length minus 1 into the substring's last.
If the row's row# is the find anchor's row#, move the substring given the find anchor's column# minus 1.
Loop.
If the substring's last is greater than or equal to the row's string's last, exit.
If the substring is the find string (accent-free compare), break. \ for portuguese incremental find
Move the substring given 1.
Repeat.
Set the flag.
Put the substring's first minus the row's string's first plus 1 into the text's anchor column#.
Put the row's row# into the text's anchor row#.
Put the substring's last minus the row's string's first plus 2 into the text's caret column#.
Put the row's row# into the text's caret row#.

To find next given a_ text and a_ flag:
If the text's wrap flag is set, find next given the text and the flag (wrapped text); exit.
Clear the flag.
If the text is nil, exit.
If the find string's length is 0, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row's row# is less than the find anchor's row#, repeat.
Find next given the row and the text and the flag.
If the flag is set, exit.
Repeat.

To find next given a_ text and a_ flag (wrapped text):
Clear the flag.
If the text is nil, exit.
Convert the find anchor to an absolute position called offset given the text.
Extract a_ string from the text (no linefeed additions).
Put the string's first plus the offset minus 1 into a_ substring's first.
Put the substring's first plus the find string's length minus 1 into the substring's last.
Loop.
If the substring's last is greater than the string's last, exit.
If the substring is the find string (accent-free compare), break. \ for portuguese incremental find
Move the substring given 1.
Repeat.
Set the flag.
Put the substring's first minus the string's first plus 1 into an anchor absolute position.
Put the substring's last minus the string's first plus 2 into a_ caret absolute position.
Convert the anchor absolute position to the text's anchor given the text.
Convert the caret absolute position to the text's caret given the text.

To find the next misspelling given a_ row and a_ text and a_ flag:
Clear the flag.
If the text is nil, exit.
If the row is nil, exit.
Slap a_ rider on the row's string.
If the row's row# is the find anchor's row#, add the find anchor's column# minus 1 to the rider's source's first.
If the rider's source's first is not the row's string's first, skip word characters in the rider's source.
Loop.
Move the rider (spell checking rules).
If the rider's token is blank, exit.
If the rider's token is not misspelled, repeat.
Set the flag.
Put the rider's token's first minus the row's string's first plus 1 into the text's anchor column#.
Put the row's row# into the text's anchor row#.
Put the rider's token's last minus the row's string's first plus 2 into the text's caret column#.
Put the row's row# into the text's caret row#.

To find the next misspelling in a_ text given a_ flag:
Clear the flag.
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row's row# is less than the find anchor's row#, repeat.
Find the next misspelling given the row and the text and the flag.
If the flag is set, exit.
Repeat.

To find a_ pdf object given a_ kind:
Void the pdf object.
Loop.
Get the pdf object given the pdf state's objects.
If the pdf object is nil, break.
If the pdf object's kind is the kind, break.
Repeat.

To find a_ pointer given a_ string and an index:
Find a_ refer given the string and the index.
If the refer is not nil, put the refer's pointer into the pointer; exit.
Void the pointer.

\PAL
Para encontrar uma referência dada uma sequência e um índice;
\CAL
To find a_ refer given a_ string and an index:
If the index is nil, exit.
If the string is blank, void the refer; exit.
Get a_ bucket given the string and the index.
Find the refer given the string and the bucket's refers.

\PAL
Para encontrar uma referência dada uma sequência e algumas referências;
\CAL
To find a_ refer given a_ string and some refers:
Void the refer.
Loop.
Get the refer from the refers.
If the refer is nil, exit.
If the string is the refer's string, exit.
Repeat.

To find a_ sector given a_ grid and a_ spot:
Put the spot's x-coord divided by the grid's x-number times the grid's x-number into the sector's x-coord.
Put the spot's y-coord divided by the grid's y-number times the grid's y-number into the sector's y-coord.

\PAL
Para calcular uma raiz quadrada de um número;
Para encontrar uma raiz quadrada de um número;
\CAL
To find a_ square root of a_ number: \ rounds down
Privatize the number.
De-sign the number.
If the number is 0, put 0 into the square root; exit.
If the number is 1, put 1 into the square root; exit.
Put 1 into a_ square number.
Put 3 into a_ delta number.
Loop.
If the square is greater than the number, break.
Add the delta to the square.
Add 2 to the delta.
Repeat.
Put the delta divided by 2 minus 1 into the square root.

\PAL
Para encontrar uma sequência dadas alguns elementos de sequência e um número;
\CAL
To find a_ string given some string things and a_ string#:
Clear the string.
Loop.
Get a_ string thing from the string things.
If the string thing is nil, exit.
Add 1 to a_ count.
If the count is not the string#, repeat.
Put the string thing's string into the string.

The find string is a_ string.

\PAL
Para encontrar um elemento de sequência dada uma sequência e alguns elementos de sequências;
\CAL
To find a_ string thing given a_ string and some string things:
Void the string thing.
Loop.
Get the string thing given the string things.
If the string thing is nil, break.
If the string thing's string is the string, break.
Repeat.

\PAL
Para encontrar um segmento em uma sequência dada outra sequência;
\CAL
To find a_ substring in a_ string given another string:
Slap the substring on the string.
Loop.
If the substring is blank, exit.
If the substring starts with the other string, break.
Add 1 to the substring's first.
Repeat.
Put the substring's first plus the other string's length minus 1 into the substring's last.

To find a_ value string given some dyads and a_ name:
Find a_ dyad given the dyads and the name.
If the dyad is nil, clear the value; exit.
Put the dyad's value into the value.

To find a_ value string given the environment variables and a_ name:
Privatize the name.
Null terminate the name.
Put 32767 into a_ length. \ max size for environment variable
Reassign the value's first given the length.
Call "kernel32.dll" "GetEnvironmentVariableA" with the name's first and the value's first and the length returning the length.
Put the value's first plus the length minus 1 into the value's last.

a_ finger is a_ byte pointer.

The five byte is a_ byte equal to 53.

The five key is a_ key equal to 53.

a_ flag has 4 bytes.

\PAL
Para inverter uma fração;
\CAL
To flip a_ fraction:
Swap the fraction's numerator with the fraction's denominator.

To flip the gpbitmap in a_ picture:
If the picture is nil, exit.
Reverse the picture's mirror flag.
Add 1800 to the picture's rotate angle.
Normalize the picture's rotate angle.
Flip the picture's gpbitmap.

To flip a_ gpimage:
Call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 6 [rotatenoneflipy aka rotate180flipx].

\PAL
Para inverter uma imagem;
\CAL
To flip a_ picture:
If the picture is nil, exit.
Put the picture's box's center's y-coord minus the picture's uncropped box's center's y-coord into a_ pair's y-number.
Multiply the pair's y-number by 2.
Move the picture's uncropped box given the pair.
Flip the gpbitmap in the picture.

\PAL
Para inverter um polígono;
\CAL
To flip a_ polygon:
If the polygon is nil, exit.
Put the polygon's box into a_ box.
Loop.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, exit.
Subtract the box's top from the vertex's y-coord.
Put the box's bottom minus the vertex's y-coord into the vertex's y-coord.
Repeat.

To flush all input;
To flush all inputs;
Para descartar todos los eventos;
To flush all events:
Flush any messages.
Flush the event queue.

To flush any messages:
Call "user32.dll" "PeekMessageA" with an msg's whereabouts and 0 and 0 and 0 and 1 [pm_remove] returning a_ number.
If the number is 0, exit.
If the msg's message is 15 [wm_paint], call "user32.dll" "ValidateRect" with the main window and 0.
Repeat.

\PAL
Para descarregar uma fila de eventos;
\CAL
To flush an event queue:
Get an event from the event queue.
If the event is nil, exit.
Remove the event from the event queue.
Destroy the event.
Repeat.

a_ font has
a_ name
and a_ height
\PAL
e um nome at the name
e uma altura at the height.

a_ font height is some twips. \ indicates line height - the letters will fit nicely in a_ box of this height

a_ font info is a_ thing with \ used for pdf conversion
a_ font,
An emsquare number,
An internal leading number,
a_ flags number,
An ascent number,
a_ descent number,
a_ capheight number,
An italicangle number,
a_ stemv number,
a_ font box,
Some font widths.

a_ font resource is a_ handle.

Some font widths is a_ thing with \ used for pdf conversion
a_ font,
a_ count,
a_ number pointer called data.

a_ foot is 12 inches.

The form-feed byte is a_ byte equal to 12.

\PAL
Para formatar um número e uma sequência singular ou uma sequência plural em uma sequência;
\CAL
To format a_ number and a_ singular string or a_ plural string into a_ string:
Convert the number to the string.
Append the space byte to the string.
If the number is 1, append the singular to the string.
If the number is not 1, append the plural to the string.

The four byte is a_ byte equal to 52.

The four key is a_ key equal to 52.

a_ fraction has
a_ numerator number
and a_ denominator number
and a_ top number at the numerator
and a_ bottom number at the denominator
\PAL
e um número chamado numerador at the numerator
e um número chamado denominador at the denominator.

a_ fraction pair has a_ fraction and another fraction.

The g-key is a_ key equal to 71.

a_ gcd is a_ number.

a_ gcpresults is a_ record with
a_ number called lstructsize,
a_ pchar called lpoutstring,
a_ number pointer called lporder,
a_ number pointer called lpdx,
a_ number pointer called lpcaretpos,
a_ pointer called lpclass,
a_ pointer called lpglyphs,
a_ number called nglyphs,
a_ number called maxfit.

a_ gdiplusstartupinput is a_ record with
a_ number called gdiplusversion,
a_ pointer called debugeventcallback,
a_ number called suppressbackgroundthread,
a_ number called suppressexternalcodecs.

a_ geometric figure is a_ figure.

To get an abca and an abcc given a_ string and a_ canvas:
Put 0 into the abca.
Put 0 into the abcc.
If the string's length is less than 1, exit.
Call "gdi32.dll" "GetCharABCWidthsA" with the canvas and the string's first's target and the string's first's target and an abc's whereabouts.
Put the abc's abca into the abca.
Call "gdi32.dll" "GetCharABCWidthsA" with the canvas and the string's last's target and the string's last's target and another abc's whereabouts.
Put the other abc's abcc into the abcc.

To get an abca given a_ string and a_ canvas:
Put 0 into the abca.
If the string's length is less than 1, exit.
Call "gdi32.dll" "GetCharABCWidthsA" with the canvas and the string's first's target and the string's first's target and an abc's whereabouts.
Put the abc's abca into the abca.

To get some addrinfo routines:
Clear o erro de e/s.
Call "kernel32.dll" "LoadLibraryA" with "ws2_32.dll"'s first returning a_ handle.
If the handle is 0, put "No se pudo leer ws2_32.dll." into o erro de e/s; exit.
Call "kernel32.dll" "GetProcAddress" with the handle and "getaddrinfo"'s first returning a_ pointer.
If the pointer is nil, put "Lamento que estas rutinas solo funcionan en Windows XP o superior." into o erro de e/s; exit.
Put the pointer into the addrinfo routines' getaddrinfo pointer.
Call "kernel32.dll" "GetProcAddress" with the handle and "freeaddrinfo"'s first returning the pointer.
If the pointer is nil, put "Lamento que estas rutinas solo funcionan en Windows XP o superior." into o erro de e/s; exit.
Put the pointer into the addrinfo routines' freeaddrinfo pointer.

To get a_ box for_ the caret in a_ text:
If the text is nil, zero the box; exit.
Get a_ spot given the text's caret and the text.
Put the spot and the spot into the box.
Add the text's row height to the box's bottom.
Adjust the box given 0 and the tpp and 0 and - the tpp.
Put the text's globalized origin into an origin.
If the box's left is less than the origin's x-coord, put the origin's x-coord into the box's left; put the origin's x-coord into the box's right.
If the text's wrap flag is not set, exit.
Limit the box's left to the text's left and the text's right.
Limit the box's right to the text's left and the text's right.

\PAL
Para obter uma caixa para uma reta;
\CAL
To get a_ box for_ a_ line:
Put the line's start into the box's left-top.
Put the line's end into the box's right-bottom.
Normalize the box.

To get a_ box given a_ row and a_ text:
If the text is nil, zero the box; exit.
If the row is nil, zero the box; exit.
Put the text's globalized origin into the box's left-top.
Add the row's row# minus 1 times the text's row height to the box's top.
Put the text's right into the box's right.
Put the box's top plus the text's row height into the box's bottom.

To get a_ bucket given a_ bucket# and an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
Put the index's first bucket into the bucket.
Add the bucket# times a_ bucket record's magnitude to the bucket.

To get a_ bucket given an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
If the bucket is nil, put the index's first bucket into the bucket; exit.
If the bucket is the index's last bucket, void the bucket; exit.
Add a_ bucket record's magnitude to the bucket.

To get a_ bucket given a_ string and an index:
\  if the index is nil, void the bucket; exit. \ to make compiler faster
Get a_ bucket# given the string and the index.
Get the bucket given the bucket# and the index.

To get a_ bucket# given a_ string and an index: \ based on the djb2 algorithm
\  if the index is nil, put 0 into the bucket#; exit. \ to make compiler faster
Put the string's length into the bucket#.
If the bucket# is 0, exit.
Add 5381 to the bucket#.
Slap a_ substring on the string.
Loop.
Put the substring's first's target into a_ byte.
Lowercase the byte.
Put the bucket# into a_ number.
Shift the bucket# left 5 bits.
Add the number to the bucket#.
Add the byte to the bucket#.
Add 3 to the substring's first.
If the substring is blank, break.
Repeat.
Bitwise and the bucket# with the largest number.
Divide the bucket# by the index's bucket count giving a_ quotient and the bucket#.

\PAL
Para obter um byte de uma sequência;
\CAL
To get a_ byte from a_ string:
If the string is blank, put the null byte into the byte; exit.
Put the string's first's target into the byte.
Remove the first byte from the string.

\PAL
Para obter um byte de uma sequência (detrás);
\CAL
To get a_ byte from a_ string (backwards):
If the string is blank, put the null byte into the byte; exit.
Put the string's last's target into the byte.
Remove the last byte from the string.

\PAL
Para obter um loco central dado um loco e outro loco;
\CAL
To get a_ center spot given a_ spot and another spot:
Put the spot and the other spot into a_ line.
Put the line's center into the center.

\PAL
Para obter uma cor em um loco;
\CAL
To get a_ color given a_ spot:
Call "gdi32.dll" "GetPixel" with the current canvas and the spot's x-coord and the spot's y-coord returning a_ colorref.
Convert the colorref to the color.

To get a_ column# given a_ row and a_ spot and a_ text:
Put 0 into the column#.
If the text is nil, exit.
If the row is nil, exit.
Get a_ box given the row and the text.
If the spot's y-coord is greater than the box's bottom, put the row's string's length into the column#; exit. \ only happens on last row of text
Create the hfont of the memory canvas given the text's font.
Get a_ start width and a_ substring given the row and the spot and the text (for "get a column# given a row...").
Loop.
If the substring's last is the row's string's last, break.
Get a_ width given the substring and the memory canvas.
Add the start width to the width.
Get another width given the substring's last's target and the memory canvas.
Divide the other width by 2.
Subtract the other width from the width.
If the spot's x-coord is less than the width, break.
Add 1 to the substring's last.
Repeat.
Put the substring's last minus the row's string's first plus 1 into the column#.
Destroy the hfont of the memory canvas.

\PAL
Para obter um contador de recursos em uma rota no sistema;
\CAL
To get a_ count of items in a_ path in the file system:
Put 0 into the count.
Loop.
Get an item from the path.
If the item is not found, exit.
Add 1 to the count.
Repeat.

\PAL
Para obter uma descrição de uma rota;
\CAL
To get a_ description for_ a_ path:
Clear the description.
Get a_ drive kind for_ the path.
Put the drive kind into the description.
Get a_ drive name for_ the path.
If the drive name is not blank, put the drive name into the description.
Lowercase the description.

\PAL
Para obter uma diferença entre uma par e outro par;
\CAL
To get a_ difference between a_ pair and another pair:
Put the pair into the difference.
Subtract the other pair from the difference.

\PAL
Para obter uma diferença entre uma par e outro par dado um par de grade;
\CAL
To get a_ difference between a_ pair and another pair given a_ grid pair:
Get the difference between the pair and the other pair.
Round the difference to the grid.

\PAL
Para obter uma distância entre um loco e outro loco (aproximada);
\CAL
To get a_ distance between a_ spot and another spot (approximate):
Put the spot's x-coord minus the other spot's x-coord into a_ number.
De-sign the number.
Put the spot's y-coord minus the other spot's y-coord into another number.
De-sign the other number.
Put the number times the number into the distance.
Add the other number times the other number to the distance.
Find a_ square root of the distance.
Put the square root into the distance.
If the d-key is down, debug the distance.

\PAL
Para obter uma distância entre um loco e outro loco (tabuleiro de xadrez);
\CAL
To get a_ distance between a_ spot and another spot (chessboard):
Put the spot's x-coord minus the other spot's x-coord into a_ number.
De-sign the number.
Put the spot's y-coord minus the other spot's y-coord into another number.
De-sign the other number.
Put the number into the distance.
If the other number is greater than the number, put the other number into the distance.

\PAL
Para obter um tipo de disco para uma rota;
\CAL
To get a_ drive kind for_ a_ path:
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "GetDriveTypeA" with the path's first returning a_ number.
If the number is 2 [drive_removable], put "disco removible" into the drive kind; exit. \ removable drive
If the number is 3 [drive_fixed], put "disco duro o flash" into the drive kind; exit.\ hard disk / flash drive
If the number is 4 [drive_remote], put "unidad de red" into the drive kind; exit. \ network drive
If the number is 5 [drive_cdrom], put "unidad de cd/dvd-rom" into the drive kind; exit. \ cd-rom / dvd drive
If the number is 6 [drive_ramdisk], put "unidad virtual en memoria" into the drive kind; exit. \ virtual drive in memory
Put "" into the drive kind.

\PAL
Para obter um nome de disco para uma rota;
\CAL
To get a_ drive name for_ a_ path:
Privatize the path.
Null terminate the path.
Put 512 into a_ length.
Reassign a_ buffer's first given the length.
Call "kernel32.dll" "GetVolumeInformationA" with the path's first and the buffer's first and the length and 0 and 0 and 0 and 0 and 0 returning a_ number.
If the number is 0, clear the drive name; exit.
Convert the buffer's first as_ a_ pchar to the drive name.

To get the first-eighth equivalent of a_ heading:
Get the first-quarter equivalent of the heading.
If the heading is less than 480, exit.
Subtract 960 from the heading.
De-sign the heading.

To get the first-quarter equivalent of a_ heading:
If the heading is less than 960, exit.
Subtract 960 from the heading.
Repeat.

\PAL
Para semear o gerador de números aleatórios;
\CAL
To get fresh random numbers;
To get new random numbers;
To seed the random number generator:
Put the system's tick count into the seed.

To get a_ gcd given a_ number and another number:
Put the number into a_ dividend number.
Put the other number into the gcd.
De-sign the dividend number.
De-sign the gcd.
If the dividend is less than the gcd, swap the dividend with the gcd.
If the gcd is 0, put 1 into the gcd; exit.
Loop.
Divide the dividend by the gcd giving a_ quotient and a_ remainder.
If the remainder is 0, exit.
Put the gcd into the dividend.
Put the remainder into the gcd.
Repeat.

To get an ip address given a_ host string:
Clear the ip address.
Get a_ sockaddr given the host string.
If o erro de e/s is not blank, exit.
Put the sockaddr's sin_addr's s_addr into the ip address' number.
Call "ws2_32.dll" "inet_ntoa" with the ip address' number returning a_ pchar.
Convert the pchar to the ip address' string.

To get an item (not first time):
Clear o erro de e/s.
Call "kernel32.dll" "FindNextFileA" with the item's handle and the item's win32finddata's whereabouts returning a_ number.
If the number is not 0, adjust the item; exit.
Clear the item's kind.
Call "kernel32.dll" "FindClose" with the item's handle.

\PAL
Para obter um recurso de uma rota;
\CAL
To get an item from a_ path:
If the path is not directory-format, exit.
Put the path into the item's directory.
If the item's kind is blank, get the item from the path (first time); exit.
Get the item (not first time).

To get an item from a_ path (first time):
Clear o erro de e/s.
Privatize the path.
Append "*.*" to the path.
Null terminate the path.
Clear the item's kind.
Call "kernel32.dll" "FindFirstFileA" with the path's first and the item's win32finddata's whereabouts returning the item's handle.
If the item's handle is -1 [invalid_handle_value], exit.
Adjust the item.

To get an lcm given a_ number and another number:
Get a_ gcd given the number and the other number.
Call "kernel32.dll" "MulDiv" with the number and the other number and the gcd returning the lcm.

\PAL
Para obter uma carta do alfabeto;
\CAL
To get a_ letter from the alphabet:
Put the next letter into the letter.
Bump the next letter limiting it to the big-a byte and the big-z byte.
Add 1 to the next letter.
If the next letter is greater than the big-z byte, put the big-a byte into the next letter.

To get a_ number from the stack:
Put 0 into the number.
Get a_ stack entry from the stack.
If the stack entry is nil, exit.
Convert the stack entry's string to the number.
Remove the stack entry from the stack.
Destroy the stack entry.

To get an offset pair given a_ string and a_ box and a_ font and an alignment:
Create the hfont of the memory canvas given the font.
Get the offset pair given the string and the box and the font and the alignment (fast).
Destroy the hfont of the memory canvas.

To get an offset pair given a_ string and a_ box and a_ font and an alignment (fast):
If the alignment is "left", get the offset pair's x-number given the string and the box (fast - left).
If the alignment is "right", get the offset pair's x-number given the string and the box  (fast - right).
If the alignment is "center", get the offset pair's x-number given the string and the box (fast - center).
Call "gdi32.dll" "GetTextMetricsA" with the memory canvas and a_ textmetric's whereabouts.
Add the box's height minus the textmetric's tmheight divided by 2 to the offset pair's y-number.

To get an outlinetextmetric given a_ font:
Create the hfont of the memory canvas given the font.
Call "gdi32.dll" "GetOutlineTextMetricsA" with the memory canvas and 0 and 0 returning a_ result number.
Assign a_ poutlinetextmetric given the result.
Call "gdi32.dll" "GetOutlineTextMetricsA" with the memory canvas and the result and the poutlinetextmetric.
Put the poutlinetextmetric's target into the outlinetextmetric.
Destroy the hfont of the current canvas.
Unassign the poutlinetextmetric.

To get a_ position given a_ spot and a_ text:
If the text is nil, clear the position; exit.
Get a_ row given the spot and the text.
Put the row's row# into the position's row#.
Get the position's column# given the row and the spot and the text.

To get a_ rgb pointer from a_ bitmapdata at a_ row# and a_ column#: \ 1 based
Put the bitmapdata's scan0 into the rgb pointer.
Add the row# minus 1 times the bitmapdata's stride to the rgb pointer.
Add the column# minus 1 times a_ rgb's magnitude to the rgb pointer.

\PAL
Para obter uma elevação e uma corrida dada uma direção;
\CAL
To get a_ rise and a_ run given a_ heading: \ see Madhava's Numbers
Privatize the heading.
Normalize the heading.
Normalize the original heading.
If the heading is not evenly divisible by 20, estimate the rise and the run given the heading; exit.
\ special cases
If the heading is 0, put -10000 in the rise; put -0 in the run; exit. \ 0 degrees
If the heading is 960, put 10000 in the run; put -0 in the rise; exit. \ 90 degrees
If the heading is 1920, put 10000 in the rise; put 0 in the run; exit. \ 180 degrees
If the heading is 2880, put -10000 in the run; put 0 in the rise; exit. \ 270 degrees
If the heading is 3840, debug "invalid heading"; debug the heading; debug the original heading.
\ force it into the first eighth of the circle
Get the first-eighth equivalent of the heading.
\ find the first eighth of the circle unsigned values
If the heading is 20, put 0327 in the run; put 9995 in the rise; break. \ 1.875 degrees
If the heading is 40, put 0654 in the run; put 9979 in the rise; break. \ 3.75 degrees
If the heading is 60, put 0980 in the run; put 9952 in the rise; break. \ 5.625 degrees = 1/64 of the way
If the heading is 80, put 1305 in the run; put 9914 in the rise; break. \7.5 degrees
If the heading is 100, put 1629 in the run; put 9866 in the rise; break. \ 9.375 degrees
If the heading is 120, put 1951 in the run; put 9808 in the rise; break. \ 11.25 degrees = 2/64 of the way
If the heading is 140, put 2271 in the run; put 9739 in the rise; break. \ 13.125 degrees
If the heading is 160, put 2588 in the run; put 9659 in the rise; break. \ 15 degrees
If the heading is 180, put 2903 in the run; put 9569 in the rise; break. \ 16.875 degrees = 3/64 of the way
If the heading is 200, put 3214 in the run; put 9469 in the rise; break. \ 18.75 degrees
If the heading is 220, put 3523 in the run; put 9359 in the rise; break. \ 20.625 degrees
If the heading is 240, put 3827 in the run; put 9239 in the rise; break. \ 22.5 degrees = 4/64 of the way
If the heading is 260, put 4127 in the run; put 9109 in the rise; break. \ 24.375 degrees
If the heading is 280, put 4423 in the run; put 8969 in the rise; break. \ 26.25 degrees
If the heading is 300, put 4714 in the run; put 8819 in the rise; break. \ 28.125 degrees = 5/64 of the way
If the heading is 320, put 5000 in the run; put 8660 in the rise; break. \ 30 degrees
If the heading is 340, put 5281 in the run; put 8492 in the rise; break. \ 31.875 degrees
If the heading is 360, put 5556 in the run; put 8315 in the rise; break. \ 33.75 degrees = 6/64 of the way
If the heading is 380, put 5825 in the run; put 8128 in the rise; break. \ 35.625 degrees
If the heading is 400, put 6088 in the run; put 7934 in the rise; break. \ 37.5 degrees
If the heading is 420, put 6344 in the run; put 7730 in the rise; break. \ 39.375 degrees = 7/64 of the way
If the heading is 440, put 6593 in the run; put 7518 in the rise; break. \ 41.25 degrees
If the heading is 460, put 6836 in the run; put 7299 in the rise; break. \ 43.125 degrees
If the heading is 480, put 7071 in the run; put 7071 in the rise; break. \ 45 degrees = 8/64 of the way
Repeat. \ not really a repeat, just a label for the above breaks.
\ adjust for other eighths of the circle
If the original heading is between 0 and 480, negate the rise; exit. \ 1st eighth (12:00 to 1:30)
If the original heading is between 480 and 960, swap the run with the rise; negate the rise; exit. \ 2nd eighth (1:30 to 3:00)
If the original heading is between 960 and 1440, swap the run with the rise; exit. \ 3rd eighth (3:00 to 4:30)
If the original heading is between 1440 and 1920, exit. \ 4th eighth (4:30 to 6:00)
If the original heading is between 1920 and 2400, negate the run; exit. \ 5th eighth (6:00 to 7:30)
If the original heading is between 2400 and 2880, swap the run with the rise; negate the run; exit. \ 6th eighth (7:30 to 9:00)
If the original heading is between 2880 and 3360, swap the run with the rise; negate the run; negate the rise; exit. \ 7th eighth (9:00 to 10:30)
If the original heading is between 3360 and 3840, negate the run; negate the rise; exit. \ 8th eighth (10:30 to 12:00)

To get a_ row given a_ row# and a_ text:
Void the row.
If the text is nil, exit.
Loop.
Get the row from the text's rows.
If the row is nil, exit.
If the row's row# is the row#, exit.
Repeat.

To get a_ row given a_ spot and a_ text:
If the text is nil, void the row; exit.
Put the spot's y-coord into a_ y-coord.
Limit the y-coord to the text's top and the text's bottom.
Put the y-coord minus the text's globalized origin's y-coord divided by the text's row height plus 1 into a_ row#.
Limit the row# to 1 and the text's row count.
Get the row given the row# and the text.

To get a_ selection box given a_ row and a_ text:
Clear the selection box.
If the text is nil, exit.
If the row is nil, exit.
Get a_ box given the row and the text.
Put the box into the selection box.
Get the selection box given the row and the text (left side).
Get the selection box given the row and the text (right side).

To get a_ selection box given a_ row and a_ text (left side):
Put the text's normalized selection into a_ selection.
Put the text's globalized origin's x-coord into the selection box's left.
If the selection's anchor row# is the row's row#, get a_ spot given the selection's anchor and the text; put the spot's x-coord into the selection box's left.
Limit the selection box's left to the text's left and the text's right.

To get a_ selection box given a_ row and a_ text (right side):
Put the text's normalized selection into a_ selection.
Put the text's right into the selection box's right.
If the selection's caret row# is the row's row#, get a_ spot given the selection's caret and the text; put the spot's x-coord into the selection box's right.
Limit the selection box's right to the text's left and the text's right.

\PAL
Para obter um tamanho dada uma rota no sistema;
\CAL
To get a_ size given a_ path in the file system:
If the path is directory-format, get the size given the path in the file system (directory).
If the path is file-format, get the size given the path in the file system (file).

\PAL
Para obter um tamanho dada uma rota no sistema (pasta);
\CAL
To get a_ size given a_ path in the file system (directory):
Put 0 into the size.
Loop.
Get an item from the path.
If the item is not found, exit.
If the item's kind is "file", add the item's size to the size; repeat.
Put the path into another path.
Append the item's designator to the other path.
Get another size given the other path in the file system.
Add the other size to the size.
Repeat.

\PAL
Para obter um tamanho dada uma rota no sistema (arquivo);
\CAL
To get a_ size given a_ path in the file system (file):
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "GetFileAttributesExA" with the path's first and 0 and a_ win32finddata's whereabouts.
Put the win32finddata's nfilesizelow into the size.

To get a_ sockaddr given a_ host string:
Clear o erro de e/s.
\ prepare strings
Privatize the host string.
Null terminate the host string.
\ get the function addresses
Get some addrinfo routines.
If o erro de e/s is not blank, exit.
\ get the sockaddr
Put 2 [af_inet] into a_ addrinfo's ai_family.
Put 1 [sock_stream] into the addrinfo's ai_sockettype.
Put 6 [ipproto_tcp] into the addrinfo's ai_protocol.
Call the addrinfo routines' getaddrinfo with the host string's first and 0 and the addrinfo's whereabouts and a_ addrinfoptr's whereabouts returning a_ result number.
If the result number is not 0, put "No pude resolver nombre de anfitrión (host) '" then the host then "'." into o erro de e/s; exit.
If the addrinfoptr is nil, put "No pude resolver nombre de anfitrión (host) '" then the host then "'." into o erro de e/s; exit.
Put the addrinfoptr's ai_addr's target into the sockaddr.
Call the addrinfo routines' freeaddrinfo with the addrinfoptr.

To get a_ spot given a_ position and a_ text:
Clear the spot.
If the text is nil, exit.
Get a_ row given the position's row# and the text.
Get a_ box given the row and the text.
Put the box's top into the spot's y-coord.
Put the row's string's first into a_ substring's first.
Put the substring's first plus the position's column# minus 2 into the substring's last.
Get a_ width given the substring and the memory canvas and the text's font.
Put the box's left plus the width into the spot's x-coord.
Get an offset pair given the row's working string and the box and the text's font and the text's alignment.
Add the offset pair's x-number to the spot's x-coord.

To get a_ start width and a_ substring given a_ row and a_ spot and a_ text (for "get a column# given a row..."):
Clear the start width.
Clear the substring.
If the text is nil, exit.
If the row is nil, exit.
Get a_ box given the row and the text.
Slap the substring on the row's working string.
Get an offset pair given the substring and the box and the text's font and the text's alignment (fast).
Put the text's globalized origin's x-coord plus the offset pair's x-number into the start width.
Put the substring's first plus the text cutoff minus 1 into the substring's last.
Loop.
If the substring's last is greater than or equal to the row's string's last, break.
Get a_ width given the substring and the memory canvas.
Put the start width plus the width into another width.
If the spot's x-coord is less than or equal to the other width, break.
Add the width to the start width.
Move the substring given the text cutoff.
Repeat.
Put the substring's first into the substring's last.

To get a_ string from the command line arguments:
Call "kernel32.dll" "GetCommandLineA" returning a_ pchar.
Convert the pchar to another string.
Slap a_ substring on the other string.
Loop.
If the substring is blank, clear the string; exit.
If the substring's first's target is not the space byte, add 1 to the substring's first; repeat.
Put the substring into the string.
Trim the string.

To get a_ string from the stack:
Clear the string.
Get an stack entry from the stack.
If the stack entry is nil, put "ERROR" into the string; exit.
Put the stack entry's string to the string.
Remove the stack entry from the stack.
Destroy the stack entry.

\PAL
Para obter uma sequência da área de tranferência do sistema;
Para obter uma sequência da área de tranferência do windows;
\CAL
To get a_ string from the windows clipboard:
Clear the string.
Call "user32.dll" "OpenClipboard" with the main window.
Call "user32.dll" "GetClipboardData" with 1 [cf_text] returning a_ handle.
If the handle is 0, call "user32.dll" "CloseClipboard"; exit.
Call "kernel32.dll" "GlobalLock" with the handle returning a_ pchar.
Convert the pchar to the string.
Call "kernel32.dll" "GlobalUnlock" with the handle.
Call "user32.dll" "CloseClipboard".

\PAL
Para obter um elemento de alguns elementos;
\CAL
To get a_ thing from some things:
If the things are empty, void the thing; exit.
If the thing is nil, put the things' first into the thing; exit.
Put the thing's next into the thing.

\PAL
Para obter um elemento de alguns elementos (detrás);
\CAL
To get a_ thing from some things (backwards):
If the things are empty, void the thing; exit.
If the thing is nil, put the things' last into the thing; exit.
Put the thing's previous into the thing.

\PAL
Para obter uma palavra de uma resposta;
\CAL
To get a_ token from a_ reply:
Remove any leading noise from the reply.
Clear the token.
Loop.
If the reply is blank, exit.
Get a_ byte from the reply.
If the byte is the space byte, exit.
Append the byte to the token.
Repeat.

To get a_ width given a_ byte and a_ canvas:
Call "gdi32.dll" "GetTextExtentPoint32A" with the canvas and the byte's whereabouts and 1 and a_ pair's whereabouts.
Put the pair's x-number into the width.

To get a_ width given a_ byte and some font widths:
Put the byte into a_ number.
Get the width given the number and the font widths.

To get a_ width given a_ number and some font widths: \ indexes are 0 based
If the font widths are nil, clear the width; exit.
Put the font widths' data into a_ number pointer.
Add the number times the number's magnitude to the number pointer.
Put the number pointer's target into the width.

To get a_ width given a_ string and a_ canvas: \ assumes font is already selected in canvas
Call "gdi32.dll" "GetTextExtentPoint32A" with the canvas and the string's first and the string's length and a_ pair's whereabouts.
Put the pair's x-number into the width.

To get a_ width given a_ string and a_ canvas and a_ font:
Create the hfont of the canvas given the font.
Get the width given the string and the canvas.
Destroy the hfont of the canvas.

To get a_ width given a_ string and a_ font: \ assumes memory canvas
Get the width given the string and the memory canvas and the font.

To get an x-coord given a_ string and a_ box (fast - center):
Get a_ width given the string and the memory canvas.
Get an abca and an abcc given the string and the memory canvas.
Put the width minus the abca minus the abcc into the width.
Put the box's width minus the width divided by 2 minus the abca into the x-coord.

To get an x-coord given a_ string and a_ box (fast - left):
Get an abca given the string and the memory canvas.
Put - the abca into the x-coord.

To get an x-coord given a_ string and a_ box (fast - right):
Get an abca and an abcc given the string and the memory canvas.
Get a_ width given the string and the memory canvas.
Put the width minus the abca minus the abcc into the width.
Put the box's width minus the width minus the abca into the x-coord.

a_ gigabyte is 1024 megabytes.

To globalize a_ box given a_ pair:
Move the box given the pair.

To globalize a_ spot given a_ pair:
Move the spot given the pair.

\PAL
Para voltar para onde estávamos;
\CAL
To go back to where we were:
Restore the context.

The gold color is a_ color.

The gold pen is a_ pen.

a_ gpbitmap is a_ gpimage.

a_ gpgraphic is a_ pointer.

a_ gpimage is a_ pointer.

a_ gpimageattributes is a_ pointer.

a_ gprect is a_ record with
a_ number called x-coord,
a_ number called y-coord,
a_ number called width,
a_ number called height.

The gptoken is a_ gptoken.

a_ gptoken is a_ number.

a_ grain is 10 milliseconds.

The gray color is a_ color.

The gray pen is a_ pen.

The grayscale color matrix is a_ hex string equal to $8716993E8716993E8716993E0000000000000000A245163FA245163FA245163F0000000000000000D578E93DD578E93DD578E93D00000000000000000000000000000000000000000000803F00000000000000000000000000000000000000000000803F.

The greater-than-sign byte is a_ byte equal to 62.

The green color is a_ color.

The green pen is a_ pen.

a_ greenish color is a_ color.

a_ grid is a_ pair.

The group-separator byte is a_ byte equal to 29.

To guarantee one row in a_ text:
If the text is nil, exit.
If the text's rows are not empty, exit.
Create a_ row given the return byte.
Append the row to the text's rows.
Renumber the text's rows.

a_ guid is a_ uuid.

The h-key is a_ key equal to 72.

The hand cursor is a_ cursor.

To handle align given a_ text and an alignment:
If the text is nil, exit.
Remember the text with "alignment".
Align the text given the alignment.

To handle any wm-activate with a_ w-param:
Split the w-param into a_ wyrd and another wyrd.
Put the other wyrd into a_ number.
If the number is 0, handle any wm-activate with the w-param (deactivate); exit.
Handle any wm-activate with the w-param (activate).

To handle any wm-activate with a_ w-param (activate):
Call "user32.dll" "SetFocus" with the main window.
Call "user32.dll" "ClipCursor" with 0.
\  seterrormode(sem_failcriticalerrors) \ keeps certain disk errors from appearing
Create an event.
Put "activate" into the event's kind.
Put "ativar" into the event's tipo.
Enque the event.
Call "user32.dll" "PostMessageA" with the main window and 0 [wm_null] and 0 and 0.

To handle any wm-activate with a_ w-param (deactivate):
Create an event.
Put "deactivate" into the event's kind.
Put "desativar" into the event's tipo.
Enque the event.
Call "user32.dll" "PostMessageA" with the main window and 0 [wn_null] and 0 and 0.

To handle any wm-char with a_ w-param and an l-param:
\If the alt key was down, exit. \ removed for portuguese keyboard AltGr and ctrl+alt characters
\If the ctrl key was down, exit.  \ removed for portuguese keyboard AltGr and ctrl+alt characters
Put the w-param into a_ byte.
If the byte is not printable, exit.
Create an event.
Put "key down" into the event's kind.
Put "tecla abaixo" into the event's tipo.
If the shift key was down, set the event's shift flag.
Put the byte into the event's byte.
Convert the l-param to the event's key.
Enque the event.

To handle any wm-create with a_ window:
Put the window into the main window.

To handle any wm-destroy:
Call "user32.dll" "PostQuitMessage" with 0.

To handle any wm-lbuttondblclk with a_ l-param:
Create an event.
Put "left double click" into the event's kind.
Put "duplo clique" into the event's tipo.
If the alt key was down, set the event's alt flag.
If the ctrl key was down, set the event's ctrl flag.
If the shift key was down, set the event's shift flag.
Convert the l-param to the event's spot.
Enque the event.

To handle any wm-lbuttondown with a_ l-param:
Create an event.
Put "left click" into the event's kind.
Put "clique" into the event's tipo.
If the alt key was down, set the event's alt flag.
If the ctrl key was down, set the event's ctrl flag.
If the shift key was down, set the event's shift flag.
Convert the l-param to the event's spot.
Enque the event.

To handle any wm-paint with a_ window:
Call "user32.dll" "BeginPaint" with the window and a_ paintstruct's whereabouts.
Call "user32.dll" "EndPaint" with the window and the paintstruct's whereabouts.
Create an event.
Put "refresh" into the event's kind.
Put "atualizar" into the event's tipo.
Enque the event.

To handle any wm-rbuttondblclk with a_ l-param:
Create an event.
Put "right double click" into the event's kind.
Put "duplo clique-dir" into the event's tipo.
If the alt key was down, set the event's alt flag.
If the ctrl key was down, set the event's ctrl flag.
If the shift key was down, set the event's shift flag.
Convert the l-param to the event's spot.
Enque the event.

To handle any wm-rbuttondown with a_ l-param:
Create an event.
Put "right click" into the event's kind.
Put "clique-dir" into the event's tipo.
If the alt key was down, set the event's alt flag.
If the ctrl key was down, set the event's ctrl flag.
If the shift key was down, set the event's shift flag.
Convert the l-param to the event's spot.
Enque the event.

To handle any wm-setcursor:
Refresh the cursor.

To handle any wm-syskeydown with a_ w-param and an l-param;
To handle any wm-keydown with a_ w-param and an l-param:
Put the w-param into a_ key.
If the key with the l-param is any repeated escape or modifier key, exit.
If the key is any wm-char key, exit.
Create an event.
Put "key down" into the event's kind.
Put "tecla abaixo" into the event's tipo.
If the alt key was down, set the event's alt flag.
If the ctrl key was down, set the event's ctrl flag.
If the shift key was down, set the event's shift flag.
Put the key into the event's key.
Enque the event.

\PAL
Para manejar capitalizar dado um texto;
\CAL
To handle capitalize given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Remember the text with "capitalize".
Capitalize any selected rows in the text.
Square up any selection in the text.
Wrap the text.

\PAL
Para manejar copiar dado um texto;
\CAL
To handle copy given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Extract a_ string from the text (selected bytes).
Put the string on the windows clipboard.

\PAL
Para manejar cortar dado um texto;
\CAL
To handle cut given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Remember the text.
Extract a_ string from the text (selected bytes).
Put the string on the windows clipboard.
Remove any selected bytes in the text.
Wrap the text.
Scroll the text to the caret.

To handle an event given a_ console:
If the console is nil, exit.
If the event's kind is "key down", handle the event given the console (key down); exit.
If the event's kind is "refresh", handle the event given the console (refresh); exit.
If the event's kind is "right click", handle the event given the console (right click); exit.
If the event's kind is "set cursor", handle the event given the console (set cursor); exit.

To handle an event given a_ console (backspace key):
If the console's reply is blank, exit.
If the event is modified, exit.
Handle the event given the console's text (backspace key).
Remove the last byte from the console's reply.
Show the console.

To handle an event given a_ console (down-arrow key):
Scroll the console's text down one line.
Show the console.

To handle an event given a_ console (end key):
Scroll the console's text to the bottom.
Show the console.

To handle an event given a_ console (enter key):
Handle the event given the console's text (enter key).
Relinquish control.

To handle an event given a_ console (home key):
Scroll the console's text to the top.
Show the console.

To handle an event given a_ console (key down):
If the event's key is the backspace key, handle the event given the console (backspace key); exit.
If the event's key is the down-arrow key, handle the event given the console (down-arrow key); exit.
If the event's key is the end key, handle the event given the console (end key); exit.
If the event's key is the enter key, handle the event given the console (enter key); exit.
If the event's key is the home key, handle the event given the console (home key); exit.
If the event's key is the page-down key, handle the event given the console (page-down key); exit.
If the event's key is the page-up key, handle the event given the console (page-up key); exit.
If the event's key is the up-arrow key, handle the event given the console (up-arrow key); exit.
If the event's byte is not printable, exit.
Append the event's byte to the console's reply.
Handle the event given the console's text (printable key).
Show the console.

To handle an event given a_ console (page-down key):
Scroll the console's text down one page.
Show the console.

To handle an event given a_ console (page-up key):
Scroll the console's text up one page.
Show the console.

To handle an event given a_ console (refresh):
Show the console.

To handle an event given a_ console (right click):
Show the hand cursor.
Scroll the console given the event.
Refresh the cursor.

To handle an event given a_ console (set cursor):
Show the arrow cursor.

To handle an event given a_ console (up-arrow key):
Scroll the console's text up one line.
Show the console.

To handle an event given a_ terminal:
If the terminal is nil, exit.
If the event's kind is "key down", handle the event given the terminal (key down); exit.
If the event's kind is "refresh", handle the event given the terminal (refresh); exit.
If the event's kind is "set cursor", handle the event given the terminal (set cursor); exit.
If the event's kind is "left click", relinquish control. \ *** added for invisible turtle book questionable

To handle an event given a_ terminal (backspace key):
If the terminal's reply is blank, exit.
If the event is modified, exit.
Remove the last byte from the terminal's reply.
Remove the last byte from the terminal's quoras' last's string.
Show the terminal.

To handle an event given a_ terminal (enter key):
Relinquish control.

To handle an event given a_ terminal (key down):
If the event's key is the backspace key, handle the event given the terminal (backspace key); exit.
If the event's key is the enter key, handle the event given the terminal (enter key); exit.
If the event's byte is not printable, exit.
Append the event's byte to the terminal's reply.
Append the event's byte to the terminal's quoras' last's string.
Show the terminal.

To handle an event given a_ terminal (refresh):
Show the terminal.

To handle an event given a_ terminal (set cursor):
Show the arrow cursor.

\PAL
Para manejar um evento dado um texto (tecla retroceso);
\CAL
To handle an event given a_ text (backspace key):
If the text is nil, exit.
If there is nothing to backspace in the text, exit.
Remember the text with "backspace".
If the event is modified, remove bytes from the text (backspace with jump).
If the event is not modified, remove bytes from the text (backspace).
Wrap the text.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla suprimir);
\CAL
To handle an event given a_ text (delete key):
If the text is nil, exit.
If there is nothing to remove in the text, exit.
Remember the text with "delete".
If the event is modified, remove bytes from the text (forward delete with jump).
If the event is not modified, remove bytes from the text (forward delete).
Wrap the text.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla seta-abaixo);
Para manejar um evento dado um texto (tecla seta abaixo);
\CAL
To handle an event given a_ text (down-arrow key):
If the text is nil, exit.
If the caret of the text is on the last line, set a_ flag.
If the flag is set, move the caret to the last byte of the text.
If the flag is not set, move the caret down in the text.
If the event's shift flag is not set, deselect the text.
Clear the text's last operation.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla fim);
\CAL
To handle an event given a_ text (end key):
If the text is nil, exit.
If the event is modified, move the caret to the last byte of the text.
If the event is not modified, move the caret to the last byte of the current row of the text.
If the event's shift flag is not set, deselect the text.
Clear the text's last operation.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla entra);
Para manejar um evento dado um texto (tecla entrar);
Para manejar um evento dado um texto (tecla enter);
\CAL
To handle an event given a_ text (enter key):
If the text is nil, exit.
Remember the text with "insert return".
Remove any selected bytes in the text.
Insert the return byte into the text.
Wrap the text.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla esc);
\CAL
To handle an event given a_ text (escape key):
If the text is nil, exit.
Deselect the text.

\PAL
Para manejar um evento dado um texto (tecla início);
\CAL
To handle an event given a_ text (home key):
If the text is nil, exit.
If the event is modified, move the caret to the first byte of the text.
If the event is not modified, move the caret to the first byte of the current row of the text.
If the event's shift flag is not set, deselect the text.
Clear the text's last operation.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (duplo clique esquerdo);
\CAL
To handle an event given a_ text (left double click):
If the text is nil, exit.
Deselect the text.
Move the caret right to any non-alphanumeric byte in the text.
Move the anchor left to any non-alphanumeric byte in the text.

\PAL
Para manejar um evento dado um texto (tecla seta esquerda);
Para manejar um evento dado um texto (tecla seta-esquerda);
\CAL
To handle an event given a_ text (left-arrow key):
If the text is nil, exit.
If the event is modified, jump the caret left in the text.
If the event is not modified, move the caret left in the text.
If the event's shift flag is not set, deselect the text.
Clear the text's last operation.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla avanço de página);
Para manejar um evento dado um texto (tecla avanço-de-página);
\CAL
To handle an event given a_ text (page-down key):
If the text is nil, exit.
Scroll the text down one page.
Move the caret down one page in the text.
If the event's shift flag is not set, deselect the text.
Clear the text's last operation.

\PAL
Para manejar um evento dado um texto (tecla retrocesso de página);
Para manejar um evento dado um texto (tecla retrocesso-de-página);
\CAL
To handle an event given a_ text (page-up key):
If the text is nil, exit.
Scroll the text up one page.
Move the caret up one page in the text.
If the event's shift flag is not set, deselect the text.
Clear the text's last operation.

\PAL
Para manejar um evento dado um texto (tecla imprimir);
\CAL
To handle an event given a_ text (printable key):
Remember the text with "insert".
Remove any selected bytes in the text.
Insert the event's byte into the text.
Wrap the text.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla seta direita);
Para manejar um evento dado um texto (tecla seta-direita);
\CAL
To handle an event given a_ text (right-arrow key):
If the text is nil, exit.
If the event is modified, jump the caret right in the text.
If the event is not modified, move the caret right in the text.
If the event's shift flag is not set, deselect the text.
Clear the text's last operation.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla tab);
\CAL
To handle an event given a_ text (tab key):
If the text is nil, exit.
Remember the text with "insert".
Remove any selected bytes in the text.
Insert the space byte into the text.
Divide the text's caret column# by 2 giving a_ quotient and a_ remainder.
If the remainder is 0, insert the space byte into the text.
Scroll the text to the caret.

\PAL
Para manejar um evento dado um texto (tecla seta acima);
Para manejar um evento dado um texto (tecla seta-acima);
\CAL
To handle an event given a_ text (up-arrow key):
If the text is nil, exit.
Move the caret up in the text.
If the event's shift flag is not set, deselect the text.
Clear the text's last operation.
Scroll the text to the caret.

To handle events given a_ console:
If the console is nil, exit.
Loop.
Deque an event.
If the event is nil, exit.
Handle the event given the console.
Repeat.

To handle events given a_ terminal:
If the terminal is nil, exit.
Loop.
Deque an event.
If the event is nil, exit.
Handle the event given the terminal.
Repeat.

To handle font height given a_ text and a_ box and a_ font height:
If the text is nil, exit.
Remember the text with "font height".
Change the text given the box.
Change the text given the font height.

\PAL
Para manejar a altura de fonte dado um texto e uma altura de fonte;
\CAL
To handle font height given a_ text and a_ font height:
If the text is nil, exit.
Remember the text with "font height".
Change the text given the font height.

\PAL
Para manejar o nome de fonte dado um texto e um nome de fonte;
\CAL
To handle font name given a_ text and a_ font name:
If the text is nil, exit.
Remember the text with "font name".
Change the text given the font name.

\PAL
Para manejar identação dado um texto;
Para manejar mais identação dado um texto;
\CAL
To handle indent given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Remember the text with "dent".
Indent any selected rows in the text.
Square up any selection in the text.
Wrap the text.

a_ handle is a_ number.

\PAL
Para manejar minúsculas dado um texto;
\CAL
To handle lowercase given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Remember the text with "case".
Lowercase any selected bytes in the text.
Wrap the text.

\PAL
Para manejar recuo de identação dado um texto;
Para manejar menos identação dado um texto;
\CAL
To handle outdent given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Remember the text with "dent".
Outdent any selected rows in the text.
Square up any selection in the text.
Wrap the text.

\PAL
Para manejar colar dado um texto;
\CAL
To handle paste given a_ text:
If the text is nil, exit.
If there is not text on the windows clipboard, exit.
Remember the text.
Remove any selected bytes in the text.
Get a_ string from the windows clipboard.
Insert the string into the text.
Wrap the text.
Scroll the text to the caret.

\PAL
Para manejar cor dado um texto e uma cor;
\CAL
To handle pen given a_ text and a_ color:
If the text is nil, exit.
Remember the text with "pen".
Put the color into the text's pen.

\PAL
Para manejar refazer dado um texto;
\CAL
To handle redo given a_ text:
If the text is nil, exit.
If the text's redos' last is nil, exit.
Copy the text into another text.
Append the other text to the text's undos.
Put the text's redos' last into a_ third text.
Remove the third text from the text's redos.
Copy the guts of the third text into the text.
Destroy the third text.
Set the text's modified flag.

\PAL
Para manejar inverter dado um texto;
\CAL
To handle reverse given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Remember the text with "reverse".
Reverse any selected rows of the text.
Square up any selection in the text.
Wrap the text.

\PAL
Para manejar selecionar tudo dado um texto;
\CAL
To handle select all given a_ text:
If the text is nil, exit.
Select every byte in the text.

To handle sort any selected rows given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Remember the text with "sort selected rows".
Sort any selected rows in the text.
Square up any selection in the text.
Wrap the text.

\PAL
Para manejar deafazer dado um texto;
\CAL
To handle undo given a_ text:
If the text is nil, exit.
If the text's undos' last is nil, exit.
Copy the text into another text.
Append the other text to the text's redos.
Put the text's undos' last into a_ third text.
Remove the third text from the text's undos.
Copy the guts of the third text into the text.
Destroy the third text.
Set the text's modified flag.

\PAL
Para manejar maiúsculas dado um texto;
\CAL
To handle uppercase given a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Remember the text with "case".
Uppercase any selected bytes in the text.
Wrap the text.

The hash-tag byte is a_ byte equal to 163.

The hashtag byte is a_ byte equal to 163.

An hbitmap is a_ handle.

An hbrush is a_ handle.

An hdc is a_ handle.

a_ heading is some points.

The heap count is a_ number.

The heap pointer is a_ pointer.

a_ height is some twips.

a_ hex string is a_ string.

An hfont is a_ handle.

An hicon is a_ handle.

\PAL
Para esconder o cursor;
\CAL
To hide the cursor:
Call "user32.dll" "ShowCursor" with 0 returning a_ number.
If the number is less than 0, exit.
Repeat.

The hilite color is a_ color.

The home key is a_ key equal to 36.

a_ horizontal line is a_ line.

An hour is 60 minutes.

An hpen is a_ handle.

An hrgn is a_ handle.

a_ hue is some precise degrees [0 to 3599].

a_ hundred is 100 units.

The i-beam cursor is a_ cursor.

The i-key is a_ key equal to 73.

a_ iid is a_ uuid.

\PAL
Para imaginar uma caixa alguns twips por alguns outros twips;
Para fazer uma caixa alguns twips por alguns outros twips;
\CAL
To imagine a_ box some twips by some other twips;
To make a_ box some twips by some other twips:
Put 0 into the box's left.
Put 0 into the box's top.
Put the twips into the box's right.
Put the other twips into the box's bottom.

To imagine a_ box some twips high by some other twips wide;
To make a_ box some twips high by some other twips wide:
Put 0 and 0 and the other twips and the twips into the box.

To imagine a_ box some twips smaller than another box;
To make a_ box some twips smaller than another box:
Put the other box into the box.
Indent the box by the twips divided by 2.

To imagine a_ box some twips smaller than another box on every side:
Put the other box into the box.
Indent the box by the twips.

To imagine a_ box some twips wide by some other twips high;
To make a_ box some twips wide by some other twips high:
Put 0 and 0 and the twips and the other twips into the box.

To imagine a_ box with a_ left coord and a_ top coord and a_ right coord and a_ bottom coord;
To make a_ box with a_ left coord and a_ top coord and a_ right coord and a_ bottom coord:
Put the left coord and the top coord and the right coord and the bottom coord into the box.

To imagine a_ box with a_ spot and another spot;
To make a_ box with a_ spot and another spot:
Put the spot and the other spot into the box.

To imagine a_ color from a_ hue and a_ saturation and a_ lightness;
To make a_ color from a_ hue and a_ saturation and a_ lightness:
Put the hue and the saturation and the lightness into the color.

To imagine a_ dot about some twips wide;
To make a_ dot about some twips wide;
To make a_ dot some twips wide:
Make the dot the twips by the twips.

To imagine a_ dot between some twips and some other twips wide;
To make a_ dot between some twips and some other twips wide:
Pick some third twips between the twips and the other twips.
Make the dot the third twips wide.

To imagine an ellipse given a_ box;
To make an ellipse given a_ box:
Put the box into the ellipse's box.

To imagine an ellipse some twips by some other twips;
To make an ellipse some twips by some other twips:
Put 0 into the ellipse's left.
Put 0 into the ellipse's top.
Put the twips into the ellipse's right.
Put the other twips into the ellipse's bottom.

To imagine an ellipse with a_ left coord and a_ top coord and a_ right coord and a_ bottom coord;
To make an ellipse with a_ left coord and a_ top coord and a_ right coord and a_ bottom coord:
Put the left coord and the top coord and the right coord and the bottom coord into the ellipse.

To imagine an ellipse with a_ spot and another spot;
To make an ellipse with a_ spot and another spot:
Put the spot and the other spot into the ellipse.

To imagine a_ figure using a_ string and a_ spot;
To make a_ figure using a_ string and a_ spot;
To create a_ figure using a_ string and a_ center spot:
Create the figure.
Append the figure to the figures.
Privatize the string.
Lowercase the string.
Slap a_ substring on the string.
Loop.
Skip any leading noise in the substring.
If the substring's length is less than 2, exit.
Put the substring's first's target into a_ byte.
Put the byte minus the little-a byte into a_ spot's y-coord.
Add 1 to the substring's first.
Put the substring's first's target into the byte.
Put the byte minus the little-a byte into the spot's x-coord.
Multiply the spot by 1/4 inch.
Add the center spot's x-coord minus 3-1/8 inches plus 1 pixel to the spot's x-coord.
Add the center spot's y-coord minus 3-1/8 inches plus 1 pixel to the spot's y-coord.
Append the spot to the figure.
Add 1 to the substring's first.
Repeat.

To imagine a_ horizontal line a_ fraction of the way up from the bottom of a_ box;
To make a_ horizontal line a_ fraction of the way up from the bottom of a_ box:
Imagine the horizontal line across the box the fraction of the way up from the bottom.

To imagine a_ line across the bottom of a_ box;
To make a_ line across the bottom of a_ box;
To imagine a_ line along the bottom of a_ box;
To make a_ line along the bottom of a_ box:
Put the box's bottom line into the line.

To imagine a_ line across a_ box a_ fraction of the way up from the bottom;
To make a_ line across a_ box a_ fraction of the way up from the bottom:
Put the box's left into the line's start's x-coord.
Put the box's right into the line's end's x-coord.
Put the box's bottom times the fraction into some twips.
Put the box's bottom minus the twips into the line's start's y-coord.
Put the box's bottom minus the twips into the line's end's y-coord.

To imagine a_ line across the top of a_ box;
To make a_ line across the top of a_ box;
To imagine a_ line along the top of a_ box;
To make a_ line along the top of a_ box:
Put the box's top line into the line.

To imagine a_ line in the middle of a_ box;
To make a_ line in the middle of a_ box;
To imagine a_ line across the middle of a_ box;
To make a_ line across the middle of a_ box;
To imagine a_ line in the center of a_ box;
To make a_ line in the center of a_ box;
To imagine a_ line across the center of a_ box;
To make a_ line across the center of a_ box:
Put the box's left into the line's start's x-coord.
Put the box's right into the line's end's x-coord.
Put the box's center's y-coord into the line's start's y-coord.
Put the box's center's y-coord into the line's end's y-coord.

To imagine a_ line some twips up from the bottom of a_ box;
To make a_ line some twips up from the bottom of a_ box:
Put the box's left into the line's start's x-coord.
Put the box's right into the line's end's x-coord.
Put the box's bottom minus the twips into the line's start's y-coord.
Put the box's bottom minus the twips into the line's end's y-coord.

\PAL
Para fazer uma reta com um loco e outro loco;
\CAL
To imagine a_ line with a_ spot and another spot;
To make a_ line with a_ spot and another spot:
Put the spot and the other spot into the line.

\PAL
Para fazer uma reta com uma coordenada-x e uma coordenada-y e outra coordenada-x e outra coordenada-y;
\CAL
To imagine a_ line with an x-coord and a_ y-coord and another x-coord and another y-coord;
To make a_ line with an x-coord and a_ y-coord and another x-coord and another y-coord:
Put the x-coord and the y-coord and the other x-coord and the other y-coord into the line.

\PAL
Para fazer uma caixa arredondada dados uma caixa e um raio;
\CAL
To imagine a_ roundy box from a_ box and a_ radius;
To make a_ roundy box from a_ box and a_ radius:
Put the box and the radius into the roundy box.

\PAL
Para fazer uma caixa arredondada dados uma largura e uma altura com um raio;
\CAL
To imagine a_ roundy box some twips by some other twips;
To make a_ roundy box some twips by some other twips with a_ radius:
Put 0 into the roundy box's left.
Put 0 into the roundy box's top.
Put the twips into the roundy box's right.
Put the other twips into the roundy box's bottom.
Put the radius into the roundy box's radius.

\PAL
Para fazer uma caixa arredondada com uma esquerda e uma superior e uma direita e uma inferior e um raio;
\CAL
To imagine a_ roundy box with a_ left coord and a_ top coord and a_ right coord and a_ bottom coord and a_ radius;
To make a_ roundy box with a_ left coord and a_ top coord and a_ right coord and a_ bottom coord and a_ radius:
Put the left coord and the top coord and the right coord and the bottom coord and the radius into the roundy box.

\PAL
Para fazer uma caixa arredondada com um loco e outro loco e um raio;
\CAL
To imagine a_ roundy box with a_ spot and another spot and a_ radius;
To make a_ roundy box with a_ spot and another spot and a_ radius:
Put the spot and the other spot and the radius into the roundy box.

\PAL
Para imaginar um loco com uma coordenada-x e uma coordenada-y;
Para fazer um loco com uma coordenada-x e uma coordenada-y;
\CAL
To imagine a_ spot with an x-coord and a_ y-coord;
To make a_ spot with an x-coord and a_ y-coord:
Put the x-coord and the y-coord into the spot.

An inch is 1440 twips.

To include a_ font in the current pdf: 
Find a_ pdf object given the font's name and the pdf state's font index.
If the pdf object is not nil, exit.
Create a_ font info given the font.
Convert the font info to pdf em units.
\ stream
Put the actual data of the font into a_ buffer.
Convert the buffer to a_ nibble string.
Add a_ stream pdf object given "font stream".
Append the stream's number then " 0 obj" to the stream.
Append "<<" to the stream without advancing.
Append "/Filter /ASCIIHexDecode" to the stream without advancing.
Append " /Length " then the nibble string's length to the stream without advancing.
Append " /Length1 " then the buffer's length to the stream without advancing.
Append ">>" to the stream.
Append "stream" to the stream.
Append the nibble string to the stream.
Append "endstream" to the stream.
Append "endobj" to the stream.
\ descriptor
Add a_ descriptor pdf object given "font descriptor".
Put "F" then the descriptor's number into a_ font name.
Put the font's name into a_ font base name.
Replace the space byte with the underscore byte in the font base name.
Append the descriptor's number then " 0 obj" to the descriptor.
Append "<<" to the descriptor.
Append "/Type /FontDescriptor" to the descriptor.
Append "/FontName /" then the font base name to the descriptor.
Append "/FontFile2 " then the stream's number then " 0 R" to the descriptor.
Append "/Flags " then the font info's flags to the descriptor.
Append "/FontBBox [" then the font info's font box then "]" to the descriptor.
Append "/Ascent " then the font info's ascent to the descriptor.
Append "/Descent " then the font info's descent to the descriptor.
Append "/CapHeight " then the font info's capheight to the descriptor.
Append "/ItalicAngle " then the font info's italicangle to the descriptor.
Append "/StemV " then the font info's stemv to the descriptor.
Append ">>" to the descriptor.
Append "endobj" to the descriptor.
\ definition
Add a_ definition pdf object given "font definition".
Put the font name into the definition's font name.
Append the definition's number then " 0 obj" to the definition.
Append "<<" to the definition.
Append "/Type /Font" to the definition.
Append "/Subtype /TrueType" to the definition.
Append "/Name /" then the font name to the definition.
Append "/BaseFont /" then the font base name to the definition.
Append "/Encoding /WinAnsiEncoding" to the definition.
Append "/FontDescriptor " then the descriptor's number then " 0 R" to the definition.
Append "/FirstChar 0" to the definition.
Append "/LastChar 255" to the definition.
Put the font info's font widths into another buffer.
Append "/Widths [" to the definition.
Append the other buffer then "]" to the definition.
Append ">>" to the definition.
Append "endobj" to the definition.
Put the font info into the definition's font info.
Index the definition given the font's name and the pdf state's font index.

To include a_ font in a_ pdf object:
If the pdf object is nil, exit.
Find a_ font pdf object given the font's name and the pdf state's font index.
If the font pdf object is nil, exit.
Put "/" then the font pdf object's font name then " " then the font pdf object's number then " 0 R" into a_ string.
Find a_ string thing given the string and the pdf object's font strings.
If the string thing is not nil, exit.
Create a_ new string thing given the string.
Append the new string thing to the pdf object's font strings.

To indent any selected rows in a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row of the text is not selected, repeat.
If the row is blank, repeat.
Prepend the space byte to the row's string.
Prepend the space byte to the row's string.
Repeat.

An indent is a_ count.

An index is a_ thing with
a_ bucket count,
a_ first bucket and a_ last bucket.

To index a_ pointer given a_ string and an index:
\  if the index is nil, exit. \ to make compiler faster
If the string's length is 0, exit.
Get a_ bucket given the string and the index.
Create a_ refer.
Append the refer to the bucket's refers.
Put the string into the refer's string.
Put the pointer into the refer's pointer.

To index a_ string in an index:
\  if the index is nil, exit. \ to make compiler faster
Index nil given the string and the index.

To initalize the terminal:
Create the terminal in the screen's box.

To initialize before run:
Call "user32.dll" "DisableProcessWindowsGhosting".
Call "kernel32.dll" "GetProcessHeap" returning the heap pointer.
Call "kernel32.dll" "LoadLibraryA" with "kernel32.dll"'s first returning a_ handle.
If the handle is not 0, call "kernel32.dll" "GetProcAddress" with the handle and "HeapSetInformation"'s first returning a_ pointer.
If the pointer is not nil, call the pointer with the heap pointer and 0 and 2's whereabouts and 4.

To initialize the canvases:
Initialize the screen canvas.
Initialize the memory canvas.
Put the memory canvas into the current canvas.

To initialize the cgi:
Call "kernel32.dll" "AllocConsole".
Call "kernel32.dll" "GetStdHandle" with -10 [std_input_handle] returning the stdin handle.
Call "kernel32.dll" "GetStdHandle" with -11 [std_output_handle] returning the stdout handle.

To initialize the colors:
Put 1 into the pen size.
Call "gdi32.dll" "GetStockObject" with 8 [null_pen] returning the null hpen.
Call "gdi32.dll" "GetStockObject" with 5 [null_brush] returning the null hbrush.
Put -1 and 0 and 0 into the clear color.
Put 0 and 0 and 1000 into the white color.
Put 0 and 0 and 875 into the lightest gray color.
Put 0 and 0 and 750 into the lighter gray color.
Put 0 and 0 and 625 into the light gray color.
Put 0 and 0 and 500 into the gray color.
Put 0 and 0 and 375 into the dark gray color.
Put 0 and 0 and 250 into the darker gray color.
Put 0 and 0 and 125 into the darkest gray color.
Put 0 and 0 and 0 into the black color.
Put 0 and 1000 and 875 into the lightest red color.
Put 0 and 1000 and 750 into the lighter red color.
Put 0 and 1000 and 625 into the light red color.
Put 0 and 1000 and 500 into the red color.
Put 0 and 1000 and 375 into the dark red color.
Put 0 and 1000 and 250 into the darker red color.
Put 0 and 1000 and 125 into the darkest red color.
Put 300 and 1000 and 875 into the lightest orange color.
Put 300 and 1000 and 750 into the lighter orange color.
Put 300 and 1000 and 625 into the light orange color.
Put 300 and 1000 and 500 into the orange color.
Put 300 and 1000 and 375 into the dark orange color.
Put 300 and 1000 and 250 into the darker orange color.
Put 300 and 1000 and 125 into the darkest orange color.
Put 600 and 1000 and 875 into the lightest yellow color.
Put 600 and 1000 and 750 into the lighter yellow color.
Put 600 and 1000 and 625 into the light yellow color.
Put 600 and 1000 and 500 into the yellow color.
Put 600 and 1000 and 375 into the dark yellow color.
Put 600 and 1000 and 250 into the darker yellow color.
Put 600 and 1000 and 125 into the darkest yellow color.
Put 900 and 1000 and 875 into the lightest lime color.
Put 900 and 1000 and 750 into the lighter lime color.
Put 900 and 1000 and 625 into the light lime color.
Put 900 and 1000 and 500 into the lime color.
Put 900 and 1000 and 375 into the dark lime color.
Put 900 and 1000 and 250 into the darker lime color.
Put 900 and 1000 and 125 into the darkest lime color.
Put 1200 and 1000 and 875 into the lightest green color.
Put 1200 and 1000 and 750 into the lighter green color.
Put 1200 and 1000 and 625 into the light green color.
Put 1200 and 1000 and 500 into the green color.
Put 1200 and 1000 and 375 into the dark green color.
Put 1200 and 1000 and 250 into the darker green color.
Put 1200 and 1000 and 125 into the darkest green color.
Put 1500 and 1000 and 875 into the lightest teal color.
Put 1500 and 1000 and 750 into the lighter teal color.
Put 1500 and 1000 and 625 into the light teal color.
Put 1500 and 1000 and 500 into the teal color.
Put 1500 and 1000 and 375 into the dark teal color.
Put 1500 and 1000 and 250 into the darker teal color.
Put 1500 and 1000 and 125 into the darkest teal color.
Put 1800 and 1000 and 875 into the lightest cyan color.
Put 1800 and 1000 and 750 into the lighter cyan color.
Put 1800 and 1000 and 625 into the light cyan color.
Put 1800 and 1000 and 500 into the cyan color.
Put 1800 and 1000 and 375 into the dark cyan color.
Put 1800 and 1000 and 250 into the darker cyan color.
Put 1800 and 1000 and 125 into the darkest cyan color.
Put 2100 and 1000 and 875 into the lightest sky color.
Put 2100 and 1000 and 750 into the lighter sky color.
Put 2100 and 1000 and 625 into the light sky color.
Put 2100 and 1000 and 500 into the sky color.
Put 2100 and 1000 and 375 into the dark sky color.
Put 2100 and 1000 and 250 into the darker sky color.
Put 2100 and 1000 and 125 into the darkest sky color.
Put 2400 and 1000 and 875 into the lightest blue color.
Put 2400 and 1000 and 750 into the lighter blue color.
Put 2400 and 1000 and 625 into the light blue color.
Put 2400 and 1000 and 500 into the blue color.
Put 2400 and 1000 and 375 into the dark blue color.
Put 2400 and 1000 and 250 into the darker blue color.
Put 2400 and 1000 and 125 into the darkest blue color.
Put 2700 and 1000 and 875 into the lightest purple color.
Put 2700 and 1000 and 750 into the lighter purple color.
Put 2700 and 1000 and 625 into the light purple color.
Put 2700 and 1000 and 500 into the purple color.
Put 2700 and 1000 and 375 into the dark purple color.
Put 2700 and 1000 and 250 into the darker purple color.
Put 2700 and 1000 and 125 into the darkest purple color.
Put 3000 and 1000 and 875 into the lightest magenta color.
Put 3000 and 1000 and 750 into the lighter magenta color.
Put 3000 and 1000 and 625 into the light magenta color.
Put 3000 and 1000 and 500 into the magenta color.
Put 3000 and 1000 and 375 into the dark magenta color.
Put 3000 and 1000 and 250 into the darker magenta color.
Put 3000 and 1000 and 125 into the darkest magenta color.
Put 3300 and 1000 and 875 into the lightest violet color.
Put 3300 and 1000 and 750 into the lighter violet color.
Put 3300 and 1000 and 625 into the light violet color.
Put 3300 and 1000 and 500 into the violet color.
Put 3300 and 1000 and 375 into the dark violet color.
Put 3300 and 1000 and 250 into the darker violet color.
Put 3300 and 1000 and 125 into the darkest violet color.
Put 0 and 0 and 800 into the hilite color.
\ special colors
Put the lightest orange color into the tan color.
Put the dark orange color into the brown color.
Put the darker orange color into the dark brown color.
Put the darkest orange color into the darker brown color.
Put the darkest orange color into the darkest brown color.
Put the lightest red color into the pink color.
Put the lighter red color into the dark pink color.
Put 500 and 1000 and 500 into the gold color.
\ colors as pens
Put the clear color into the clear pen.
Put the white color into the white pen.
Put the black color into the black pen.
Put the lightest gray color into the lightest gray pen.
Put the lighter gray color into the lighter gray pen.
Put the light gray color into the light gray pen.
Put the gray color into the gray pen.
Put the dark gray color into the dark gray pen.
Put the darker gray color into the darker gray pen.
Put the darkest gray color into the darkest gray pen.
Put the lightest red color into the lightest red pen.
Put the lighter red color into the lighter red pen.
Put the light red color into the light red pen.
Put the red color into the red pen.
Put the dark red color into the dark red pen.
Put the darker red color into the darker red pen.
Put the darkest red color into the darkest red pen.
Put the lightest orange color into the lightest orange pen.
Put the lighter orange color into the lighter orange pen.
Put the light orange color into the light orange pen.
Put the orange color into the orange pen.
Put the dark orange color into the dark orange pen.
Put the darker orange color into the darker orange pen.
Put the darkest orange color into the darkest orange pen.
Put the lightest yellow color into the lightest yellow pen.
Put the lighter yellow color into the lighter yellow pen.
Put the light yellow color into the light yellow pen.
Put the yellow color into the yellow pen.
Put the dark yellow color into the dark yellow pen.
Put the darker yellow color into the darker yellow pen.
Put the darkest yellow color into the darkest yellow pen.
Put the lightest lime color into the lightest lime pen.
Put the lighter lime color into the lighter lime pen.
Put the light lime color into the light lime pen.
Put the lime color into the lime pen.
Put the dark lime color into the dark lime pen.
Put the darker lime color into the darker lime pen.
Put the darkest lime color into the darkest lime pen.
Put the lightest green color into the lightest green pen.
Put the lighter green color into the lighter green pen.
Put the light green color into the light green pen.
Put the green color into the green pen.
Put the dark green color into the dark green pen.
Put the darker green color into the darker green pen.
Put the darkest green color into the darkest green pen.
Put the lightest teal color into the lightest teal pen.
Put the lighter teal color into the lighter teal pen.
Put the light teal color into the light teal pen.
Put the teal color into the teal pen.
Put the dark teal color into the dark teal pen.
Put the darker teal color into the darker teal pen.
Put the darkest teal color into the darkest teal pen.
Put the lightest cyan color into the lightest cyan pen.
Put the lighter cyan color into the lighter cyan pen.
Put the light cyan color into the light cyan pen.
Put the cyan color into the cyan pen.
Put the dark cyan color into the dark cyan pen.
Put the darker cyan color into the darker cyan pen.
Put the darkest cyan color into the darkest cyan pen.
Put the lightest sky color into the lightest sky pen.
Put the lighter sky color into the lighter sky pen.
Put the light sky color into the light sky pen.
Put the sky color into the sky pen.
Put the dark sky color into the dark sky pen.
Put the darker sky color into the darker sky pen.
Put the darkest sky color into the darkest sky pen.
Put the lightest blue color into the lightest blue pen.
Put the lighter blue color into the lighter blue pen.
Put the light blue color into the light blue pen.
Put the blue color into the blue pen.
Put the dark blue color into the dark blue pen.
Put the darker blue color into the darker blue pen.
Put the darkest blue color into the darkest blue pen.
Put the lightest purple color into the lightest purple pen.
Put the lighter purple color into the lighter purple pen.
Put the light purple color into the light purple pen.
Put the purple color into the purple pen.
Put the dark purple color into the dark purple pen.
Put the darker purple color into the darker purple pen.
Put the darkest purple color into the darkest purple pen.
Put the lightest magenta color into the lightest magenta pen.
Put the lighter magenta color into the lighter magenta pen.
Put the light magenta color into the light magenta pen.
Put the magenta color into the magenta pen.
Put the dark magenta color into the dark magenta pen.
Put the darker magenta color into the darker magenta pen.
Put the darkest magenta color into the darkest magenta pen.
Put the lightest violet color into the lightest violet pen.
Put the lighter violet color into the lighter violet pen.
Put the light violet color into the light violet pen.
Put the violet color into the violet pen.
Put the dark violet color into the dark violet pen.
Put the darker violet color into the darker violet pen.
Put the darkest violet color into the darkest violet pen.
\ special color pens
Put the tan color into the tan pen.
Put the brown color into the brown pen.
Put the dark brown color into the dark brown pen.
Put the darker brown color into the darker brown pen.
Put the darkest brown color into the darkest brown pen.
Put the pink color into the pink pen.
Put the dark pink color into the dark pink pen.
Put the gold color in the gold pen.
\ "sky" renamed "sky blue"
Put the lightest sky color into the lightest sky blue color.
Put the lighter sky color into the lighter sky blue color.
Put the light sky color into the light sky blue color.
Put the sky color into the sky blue color.
Put the dark sky color into the dark sky blue color.
Put the darker sky color into the darker sky blue color.
Put the darkest sky color into the darkest sky blue color.
Put the lightest sky color into the lightest sky blue pen.
Put the lighter sky color into the lighter sky blue pen.
Put the light sky color into the light sky blue pen.
Put the sky color into the sky blue pen.
Put the dark sky color into the dark sky blue pen.
Put the darker sky color into the darker sky blue pen.
Put the darkest sky color into the darkest sky blue pen.
\PAL
\\ Portuguese colors
Put the clear color no transparente.
Put the black color no preto.
Put the white color no branco.
Put the lightest gray color no cinza claríssimo.
Put the lighter gray color no cinza muito claro.
Put the light gray color no cinza claro.
Put the gray color no cinza.
Put the dark gray color no cinza escuro.
Put the darker gray color no cinza muito escuro.
Put the darkest gray color no cinza escuríssimo.
Put the lightest red color no vermelho claríssimo.
Put the lighter red color no vermelho muito claro.
Put the light red color no vermelho claro.
Put the red color no vermelho.
Put the dark red color no vermelho escuro.
Put the darker red color no vermelho muito escuro.
Put the darkest red color no vermelho escuríssimo.
Put the lightest orange color no laranja claríssimo.
Put the lighter orange color no laranja muito claro.
Put the light orange color no laranja claro.
Put the orange color no laranja.
Put the dark orange color no laranja escuro.
Put the darker orange color no laranja muito escuro.
Put the darkest orange color no laranja escuríssimo.
Put the lightest yellow color no amarelo claríssimo.
Put the lighter yellow color no amarelo muito claro.
Put the light yellow color no amarelo-claro.
Put the yellow color no amarelo.
Put the dark yellow color no amarelo escuro.
Put the darker yellow color no amarelo muito escuro.
Put the darkest yellow color no amarelo escuríssimo.
Put the lightest lime color no limão claríssimo.
Put the lighter lime color no limão muito claro.
Put the light lime color no limão claro.
Put the lime color no limão.
Put the dark lime color no limão escuro.
Put the darker lime color no limão muito escuro.
Put the darkest lime color no limão escuríssimo.
Put the lightest green color no verde claríssimo.
Put the lighter green color no verde muito claro.
Put the light green color no verde-claro.
Put the green color no verde.
Put the dark green color no verde-escuro.
Put the darker green color no verde muito escuro.
Put the darkest green color no verde escuríssimo.
Put the lightest teal color no turquesa claríssimo.
Put the lighter teal color no turquesa muito claro.
Put the light teal color no turquesa claro.
Put the teal color no turquesa.
Put the dark teal color no turquesa escuro.
Put the darker teal color no turquesa muito escuro.
Put the darkest teal color no turquesa escuríssimo.
Put the lightest cyan color no cíano claríssimo.
Put the lighter cyan color no cíano muito claro.
Put the light cyan color no cíano claro.
Put the cyan color no cíano.
Put the dark cyan color no cíano escuro.
Put the darker cyan color no cíano muito escuro.
Put the darkest cyan color no cíano escuríssimo.
Put the lightest sky color no azul-celeste claríssimo.
Put the lighter sky color no azul-celeste muito claro.
Put the light sky color no azul-celeste claro.
Put the sky color no azul-celeste.
Put the dark sky color no azul-celeste escuro.
Put the darker sky color no azul-celeste muito escuro.
Put the darkest sky color no azul-celeste escuríssimo.
Put the lightest blue color no azul claríssimo.
Put the lighter blue color no azul muito claro.
Put the light blue color no azul-claro.
Put the blue color no azul.
Put the dark blue color no azul escuro.
Put the darker blue color no azul muito escuro.
Put the darkest blue color no azul escuríssimo.
Put the lightest purple color no púrpura claríssimo.
Put the lighter purple color no púrpura muito claro.
Put the light purple color no púrpura claro.
Put the purple color no púrpura.
Put the dark purple color no púrpura escuro.
Put the darker purple color no púrpura muito escuro.
Put the darkest purple color no púrpura escuríssimo.
Put the lightest magenta color no magenta claríssimo.
Put the lighter magenta color no magenta muito claro.
Put the light magenta color no magenta claro.
Put the magenta color no magenta.
Put the dark magenta color no magenta escuro.
Put the darker magenta color no magenta muito escuro.
Put the darkest magenta color no magenta escuríssimo.
Put the lightest violet color no roxo claríssimo.
Put the lighter violet color no roxo muito claro.
Put the light violet color no roxo claro.
Put the violet color no roxo.
Put the dark violet color no roxo escuro.
Put the darker violet color no roxo muito escuro.
Put the darkest violet color no roxo escuríssimo.
Put the lightest violet color no violeta claríssimo.
Put the lighter violet color no violeta muito claro.
Put the light violet color no violeta claro.
Put the violet color no violeta.
Put the dark violet color no violeta escuro.
Put the darker violet color no violeta muito escuro.
Put the darkest violet color no violeta escuríssimo.
\ Portuguese special colors
Put the lightest cyan color no ciã claríssimo.
Put the lighter cyan color no ciã muito claro.
Put the light cyan color no ciã claro.
Put the cyan color no ciã.
Put the dark cyan color no ciã escuro.
Put the darker cyan color no ciã muito escuro.
Put the darkest cyan color no ciã escuríssimo.
Put the lightest sky color no cerúleo claríssimo.
Put the lighter sky color no cerúleo muito claro.
Put the light sky color no cerúleo claro.
Put the sky color no cerúleo.
Put the dark sky color no cerúleo escuro.
Put the darker sky color no cerúleo muito escuro.
Put the darkest sky color no cerúleo escuríssimo.
Put the lightest orange color no marrom claríssimo.
Put the lighter orange color no marrom muito claro.
Put the light orange color no marrom claro.
Put the orange color no marrom.
Put the dark orange color no marrom escuro.
Put the darker orange color no marrom muito escuro.
Put the darkest orange color no marrom escuríssimo.
Put the pink color no rosa.
Put the gold color no dourado.

To initialize com:
Call "ole32.dll" "CoInitializeEx" with 0 and 2 [coinit_apartmentthreaded].

To initialize a_ context:
Allocate memory for_ the context.
Put the screen's center into the context's spot.
Put 0 into the context's heading.
Put the green color into the context's color.
Put the small letter height into the context's letter height.
\Put 1/60 second into the delay. ***
Seed the random number generator.

To initialize the cursors:
Initialize the cursors (arrow cursor).
Initialize the cursors (hand cursor).
Initialize the cursors (i-beam cursor).
\PAL
Put o arrow cursor no cursor flecha.
Put o hand cursor no cursor mão.
Put o i-beam cursor no cursor feixe-i.
Hide the cursor.

To initialize the cursors (arrow cursor):
Append $00000000000000004000000060000000 to an xor-mask.
Append $70000000780000007C0000007E000000 to the xor-mask.
Append $7F0000007F8000007C0000006C000000 to the xor-mask.
Append $46000000060000000300000003000000 to the xor-mask.
Append $01800000018000000000000000000000  to the xor-mask.
Append $00 to the xor-mask given 48.
Append $7FFFFFFF3FFFFFFF1FFFFFFF0FFFFFFF  to an and-mask.
Append $07FFFFFF03FFFFFF01FFFFFF00FFFFFF to the and-mask.
Append $007FFFFF003FFFFF001FFFFF01FFFFFF to the and-mask.
Append $10FFFFFF30FFFFFF787FFFFFF87FFFFF to the and-mask.
Append $FC3FFFFFFC3FFFFFFE7FFFFFFFFFFFFF to the and-mask.
Append $FF to the and-mask given 48.
Call "user32.dll" "CreateCursor" with the module's handle and 0 and 0 and 32 and 32 and the and-mask's first and the xor-mask's first returning the arrow cursor.

To initialize the cursors (hand cursor):
Append $000000000180000019B0000019B00000 to an xor-mask.
Append $0DB200000DB6000007F6000067FE0000 to the xor-mask.
Append $7FFC00003FFC00001FFC00001FF80000 to the xor-mask.
Append $0FF8000007F0000003F0000003F00000 to the xor-mask.
Append $00 to the xor-mask given 64.
Append $FE7FFFFFE40FFFFFC007FFFFC005FFFF to an and-mask.
Append $E000FFFFE000FFFF9000FFFF0000FFFF to the and-mask.
Append $0001FFFF8001FFFFC001FFFFC003FFFF to the and-mask.
Append $E003FFFFF007FFFFF807FFFFF807FFFF to the and-mask.
Append $FF to the and-mask given 64.
Call "user32.dll" "CreateCursor" with the module's handle and 2 and 1 and 32 and 32 and the and-mask's first and the xor-mask's first returning the hand cursor.

To initialize the cursors (i-beam cursor):
Append $EE000000100000001000000010000000  to an xor-mask.
Append $10000000100000001000000010000000 to the xor-mask.
Append $10000000100000001000000010000000 to the xor-mask.
Append $100000001000000010000000EE000000 to the xor-mask.
Append $00 to the xor-mask given 64.
Append $FF to an and-mask given 128.
Call "user32.dll" "CreateCursor" with the module's handle and 3 and 7 and 32 and 32 and the and-mask's first and the xor-mask's first returning the i-beam cursor.

To initialize the fonts:
Call "gdi32.dll" "GetStockObject" with 11 [ansi_fixed_font] returning the null hfont.
Call "gdi32.dll" "AddFontMemResourceEx" with the osmosian font source's first and the osmosian font source's length and 0 and a_ number's whereabouts
Returning the osmosian font resource.
Put "osmosian" and 1/4 inch into the default font.
\ stroked fonts below
Put 1/8 inch into the small letter height.
Put 1/4 inch into the medium letter height.
Put 1/2 inch into the large letter height.

To initialize gdi+:
Put 1 into a_ gdiplusstartupinput's gdiplusversion.
Call "gdiplus.dll" "GdiplusStartup" with the gptoken's whereabouts and the gdiplusstartupinput's whereabouts and 0.

To initialize the memory canvas:
Call "gdi32.dll" "CreateCompatibleDC" with the screen canvas returning the memory canvas.
Call "gdi32.dll" "GetCurrentObject" with the memory canvas and 7 [obj_bitmap] returning the saved memory hbitmap.
Call "gdi32.dll" "CreateCompatibleBitmap" with the screen canvas and the screen's pixel width and the screen's pixel height returning an hbitmap.
Call "gdi32.dll" "SelectObject" with the memory canvas and the hbitmap.
Normalize the memory canvas.

To initialize the module:
\ temp path
Put 512 into a_ length.
Reassign the temp path's first given the length.
Call "kernel32.dll" "GetTempPathA" with the length and the temp path's first returning the length.
Put the temp path's first plus the length minus 1 into the temp path's last.
Null terminate the temp path.
\ module handle
Call "kernel32.dll" "GetModuleHandleA" with 0 returning the module's handle.
\ module name
Put 512 into the length.
Reassign the module's path's first given the length.
Call "kernel32.dll" "GetModuleFileNameA" with the module's handle and the module's path's first and the length returning the length.
Put the module's path's first plus the length minus 1 into the module's path's last.
If the module's path starts with "\\?\", remove leading bytes from the module's path given 4.
Lowercase the module's path.
Null terminate the module's path.
\ module's other path pieces
Extract the module's name from the module's path.
Null terminate the module's name.
Extract the module's directory from the module's path.
Null terminate the module's directory.
Extract the module's root directory from the module's directory.
Null terminate the module's root directory.

To initialize the mouse:
Put 1 into the mouse's left button.
Put 2 into the mouse's right button.
Call "user32.dll" "GetSystemMetrics" with 23 [sm_swapbutton] returning a_ number.
If the number is 0, exit.
Swap the mouse's left button with the mouse's right button.

To initialize the printer canvas:
Put a_ printdlgex's magnitude into the printdlgex's lstructsize.
Put the main window into the printdlgex's hwndowner.
Put 1288 [pd_returndc + pd_returndefault + pd_nopageenums] into the printdlgex's flags.
Put -1 [start_page_general] into the printdlgex's nstartpage.
Call "comdlg32.dll" "PrintDlgExA" with the printdlgex's whereabouts.
Call "kernel32.dll" "GlobalFree" with the printdlgex's hdevnames.
Put the printdlgex's hdevmode into the printer device mode handle.
Put the printdlgex's hdc into the printer canvas.

To initialize the screen:
Call "user32.dll" "GetSystemMetrics" with 0 [sm_cxscreen] returning the screen's pixel width.
Call "user32.dll" "GetSystemMetrics" with 1 [sm_cyscreen] returning the screen's pixel height.
Put 96 into the ppi.
Put the tpi divided by the ppi into the tpp.
Put the screen's pixel width times the tpp into a_ width.
Put the screen's pixel height times the tpp into a_ height.
Put 0 and 0 and the width and the height into the screen's box.
Subtract the tpp from the screen's right-bottom.
\PAL
Put the screen's box na caixa da tela.
Put the screen's pixel height na altura de pixel da tela.
Put the screen's pixel width na largura de pixel da tela.

To initialize the screen canvas:
Call "user32.dll" "GetDC" with the main window returning the screen canvas.
Normalize the screen canvas.

To initialize a_ talker:
Convert "{96749377-3391-11D2-9EE3-00C04F797396}" [clsid_spvoice] to a_ clsid.
Convert "{6C44DF74-72B9-4992-A1EC-EF996E0422D4}" [iid_ispvoice] to an iid.
Call "ole32.dll" "CoCreateInstance" with the clsid's whereabouts and 0 and 7 [clsctx_all] and the iid's whereabouts and the talker's whereabouts.

To initialize the window:
Put a_ window class's magnitude into the window class' cbsize.
Put 40 [cs_owndc + cs_dblclks] into the window class' style.
Point the window class' lpfnwndproc to routine handle any message with a_ window a_ message number a_ w-param and a_ l-param.
Put the module's handle into the window class' hinstance.
Put the module's name's first into the window class' lpszclassname.
Call "user32.dll" "RegisterClassExA" with the window class's whereabouts.
Call "user32.dll" "CreateWindowExA" with 0 and the module's name's first and the module's name's first and -2147483648 [ws_popup] 
And 0 and 0 and the screen's pixel width and the screen's pixel height and 0 and 0 and the module's handle and 0.
Call "user32.dll" "ShowWindow" with the main window and 1 [sw_shownormal].

To initialize winsock:
Call "ws2_32.dll" "WSAStartup" with 2 and a_ wsadata's whereabouts.

An input is an event.

\PAL
Para inserir um byte em um texto;
\CAL
To insert a_ byte into a_ text:
If the text is nil, exit.
Put the byte into a_ string.
Insert the string into the text.

The insert key is a_ key equal to 45.

\PAL
Para inserir um loco em um polígono depois de um vértice;
Para inserir um loco em um polígono após um vértice;
\CAL
To insert a_ spot into a_ polygon after a_ vertex:
If the polygon is nil, exit.
Create another vertex given the spot.
Insert the other vertex into the polygon's vertices after the vertex.

\PAL
Para inserir uma sequência em outra sequência ante de uma posição de sequência;
\CAL
To insert a_ string into another string before a_ byte#:
\CAL
If the string's length is 0, exit.
Privatize the byte#.
Limit the byte# to 1 and the other string's length plus 1.
Slap a_ substring on the other string. \ left side
Put the substring's first plus the byte# minus 2 into the substring's last.
Slap another substring on the other string. \ right side
Put the other substring's first plus the byte# minus 1 into the other substring's first.
Put the other string's length plus the string's length into a_ combined length.
Reassign a_ pointer given the combined length.
Put the pointer into a_ third substring's first.
Copy bytes from the substring's first to the third substring's first for_ the substring's length.
Add the substring's length to the third substring's first.
Copy bytes from the string's first to the third substring's first for_ the string's length.
Add the string's length to the third substring's first.
Copy bytes from the other substring's first to the third substring's first for_ the other substring's length.
Unassign the other string's first. \ don't use put a string into a string to prevent extra allocating and copying
Put the pointer into the other string's first.
Put the other string's first plus the combined length minus 1 into the other string's last.

\PAL
Para inserir uma sequência em um texto;
\CAL
To insert a_ string into a_ text:
If the text is nil, exit.
Get a_ row given the text's caret row# and the text.
Put the row's string's length minus the text's caret column# into a_ number.
Put the row's string into another string.
Insert the string into the other string before the text's caret column#.
Convert the other string to some rows.
Put the rows' last into another row.
Insert the rows into the text's rows before the row.
Remove the row from the text's rows.
Destroy the row.
Renumber the text's rows.
Put the other row's row# into the text's caret row#.
Put the other row's string's length minus the number into the text's caret column#.
Deselect the text.

\PAL
Para inserir um elemento em alguns elementos depois de outro elemento;
Para inserir um elemento em alguns elementos após outro elemento;
\CAL
To insert a_ thing into some things after another thing:
If the thing is nil, exit.
If the other thing is nil, prepend the thing to the things; exit.
Insert the thing into the things before the other thing's next.

\PAL
Para inserir um elemento em alguns elementos antes de outro elemento;
\CAL
To insert a_ thing into some things before another thing:
If the thing is nil, exit.
If the things are empty, append the thing to the things; exit.
If the other thing is nil, append the thing to the things; exit.
If the other thing is the things' first, prepend the thing to the things; exit.
Put the thing into a_ new thing.
Put the other thing into a_ previous thing.
Put the new thing into the previous thing's previous' next.
Put the previous thing into the new thing's next.
Put the previous thing's previous into the new thing's previous.
Put the new thing into the previous thing's previous.

\PAL
Para inserir alguns elementos em alguns outros elementos depois de um elemento;
Para inserir alguns elementos em alguns outros elementos após um elemento;
\CAL
To insert some things into some other things after a_ thing:
If the thing is nil, prepend the things to the other things; exit.
Insert the things into the other things before the thing's next.

\PAL
Para inserir alguns elementos em alguns outros elementos antes de um elemento;
\CAL
To insert some things into some other things before a_ thing:
Privatize the thing.
Loop.
Put the things' first into another thing.
If the other thing is nil, exit.
Remove the other thing from the things.
Insert the other thing into the other things before the thing.
Repeat.

\PAL
Para inserir um vértice em um polígono depois de outro vértice;
Para inserir um vértice em um polígono após outro vértice;
\CAL
To insert a_ vertex into a_ polygon after another vertex:
If the polygon is nil, exit.
If the vertex is nil, exit.
Insert the vertex into the polygon's vertices after the other vertex.

\PAL
Para inserir um vértice em um polígono dado um loco;
\CAL
To insert a_ vertex into a_ polygon at a_ spot:
If the polygon is nil, exit.
If the vertex is nil, exit.
Loop.
Get another vertex from the polygon's vertices.
If the other vertex is nil, exit.
If the other vertex's next is nil, exit.
Put the other vertex's spot and the other vertex's next's spot into a_ line.
If the spot is not on the line, repeat.
Insert the vertex into the polygon's vertices after the other vertex.

\PAL
Para inserir um vértice em um polígono antes de outro vértice;
\CAL
To insert a_ vertex into a_ polygon before another vertex:
If the polygon is nil, exit.
If the vertex is nil, exit.
Insert the vertex into the polygon's vertices before the other vertex.

\PAL
Para interseccionar uma caixa com outra caixa dando uma terceira caixa;
Para interseccionar uma caixa com outra caixa gerando uma terceira caixa;
Para interseccionar uma caixa com outra caixa resultando uma terceira caixa;
\CAL
To intersect a_ box with another box giving a_ third box:
\ boxes do not touch
Clear the third box.
If the box's left is greater than the other box's right, exit.
If the box's top is greater than the other box's bottom, exit.
If the box's right is less than the other box's left, exit.
If the box's bottom is less than the other box's top, exit.
\ boxes touch
Put the box into the third box.
If the box's left is less than the other box's left, put the other box's left into the third box's left.
If the box's top is less than the other box's top, put the other box's top into the third box's top.
If the box's right is greater than the other box's right, put the other box's right into the third box's right.
If the box's bottom is greater than the other box's bottom, put the other box's bottom into the third box's bottom.

\To invert a_ flag: \ see "reverse a flag"
\If the flag is yes, put no into the flag; exit.
\Put yes into the flag.

The inverted-exclamation-mark byte is a_ byte equal to 161.

The inverted-question-mark byte is a_ byte equal to 191.

a_ in_addr is a_ record with
a_ byte called s_b1,
a_ byte called s_b2,
a_ byte called s_b3,
a_ byte called s_b4,
a_ wyrd [unsigned] called  s_w1 at the s_b1,
a_ wyrd [unsigned] called s_w2 at the s_b3,
a_ number called s_addr at the s_b1.

An ip address has
a_ number,
a_ string,
\PAL
um número redefinindo o number,
uma sequência redefinindo o string.

An istream is a_ pointer to an istream object.

An istream object is a_ record with an istream vtable called vtable.

An istream vtable is a_ pointer to an istream vtable record.

An istream vtable record is a_ record with
\ iunknown
a_ pointer called queryinterface,
a_ pointer called addref,
a_ pointer called release, \ function(this:istream):number; stdcall;
\ istream
a_ pointer called read,
a_ pointer called write,
a_ pointer called seek,
a_ pointer called setsize,
a_ pointer called copyto,
a_ pointer called commit,
a_ pointer called revert,
a_ pointer called lockregion,
a_ pointer called unlockregion,
a_ pointer called stat,
a_ pointer called clone.

An item has
a_ kind [directory, file], \ English
\PAL
uma sequência chamada tipo [pasta, arquivo], \ Portuguese kind
a_ path,
a_ directory,
a_ designator,
an extension,
a_ size,
a_ creation date/time string,
a_ win32finddata,
a_ handle,
\PAL
uma rota at the path, um caminho at the path,
uma pasta at the path,
um designador at the designator,
uma extensão at the extension,
um tamanho at the size.

The j-key is a_ key equal to 74.

To jump the caret left in a_ text:
If the text is nil, exit.
Move the caret left to any non-noise byte in the text.
If the text's caret column# is 1, exit.
Get a_ row given the text's caret row# and the text.
Put the row's string's first plus the text's caret column# minus 2 into a_ byte pointer.
If the byte pointer's target is alphanumeric, move the caret left to any non-alphanumeric byte in the text.
If the byte pointer's target is not alphanumeric, move the caret left to any non-symbolic byte in the text.
Move the caret left to any non-noise byte in the text.

To jump the caret right in a_ text:
If the text is nil, exit.
Move the caret right to any non-noise byte in the text.
Get a_ row given the text's caret row# and the text.
If the text's caret column# is the row's string's length, exit.
Put the row's string's first plus the text's caret column# minus 1 into a_ byte pointer.
If the byte pointer's target is alphanumeric, move the caret right to any non-alphanumeric byte in the text.
If the byte pointer's target is not alphanumeric, move the caret right to any non-symbolic byte in the text.
Move the caret right to any non-noise byte in the text.

The k-key is a_ key equal to 75.

a_ key is a_ number.

a_ kilobyte is 1024 units.

a_ kind is a_ string.

The l-key is a_ key equal to 76.

a_ l-param is a_ number.

a_ landscape sheet is a_ sheet.

The large letter height is a_ letter height.

The largest number is 2147483647.

An lcm is a_ number.

a_ left click is an input.

a_ left is some twips.

The left-alligator byte is a_ byte equal to 60.

The left-alligator-quote byte is a_ byte equal to 139.

The left-arrow key is a_ key equal to 37.

The left-brace byte is a_ byte equal to 123.

The left-bracket byte is a_ byte equal to 91.

The left-double-alligator-quote byte is a_ byte equal to 171.

The left-double-quote byte is a_ byte equal to 147.

The left-paren byte is a_ byte equal to 40.

The left-single-quote byte is a_ byte equal to 145.

The left-window key is a_ key equal to 91.

a_ length is some twips.

The less-than-sign byte is a_ byte equal to 60.

a_ letter height is some twips. \ indicates actual height of a_ typical uppercase letter

a_ letter is a_ byte.

The lexicon is a_ thing with an index.

The light blue color is a_ color.

The light blue pen is a_ pen.

a_ light color is a_ color.

The light cyan color is a_ color.

The light cyan pen is a_ pen.

The light gray color is a_ color.

The light gray pen is a_ pen.

The light green color is a_ color.

The light green pen is a_ pen.

The light lime color is a_ color.

The light lime pen is a_ pen.

The light magenta color is a_ color.

The light magenta pen is a_ pen.

The light orange color is a_ color.

The light orange pen is a_ pen.

The light purple color is a_ color.

The light purple pen is a_ pen.

The light red color is a_ color.

The light red pen is a_ pen.

The light sky blue color is a_ color.

The light sky blue pen is a_ pen.

The light sky color is a_ color.

The light sky pen is a_ pen.

The light teal color is a_ color.

The light teal pen is a_ pen.

The light violet color is a_ color.

The light violet pen is a_ pen.

The light yellow color is a_ color.

The light yellow pen is a_ pen.

\PAL
Para clarear uma cor em uma quantidade;
\CAL
To lighten a_ color by an amount:
Add the amount to the color's lightness.
Limit the color's lightness to 0 and 1000.

\PAL
Para clarear uma cor em uma porcentagem;
\CAL
To lighten a_ color by some percent;
To lighten a_ color about some percent;
To lighten a_ color by about some percent;
To lighten a_ color some percent:
Put the color's lightness plus the percent into the color's lightness.
Limit the color's lightness to 0 and 1000.

\PAL
Para clarear a cor atual em uma porcentagem;
\CAL
To lighten the current color about some percent:
Lighten the context's color by the percent.

\PAL
Para clarear uma matiz em alguns graus;
\CAL
To lighten a_ hue by some degrees:
Add the degrees to the hue.

\PAL
Para clarear uma matiz em alguns degraus;
\CAL
To lighten a_ hue by some points:
Convert the hue to some other points.
Add the points to the other points.
Convert the other points to the hue.

The lighter blue color is a_ color.

The lighter blue pen is a_ pen.

The lighter cyan color is a_ color.

The lighter cyan pen is a_ pen.

The lighter gray color is a_ color.

The lighter gray pen is a_ pen.

The lighter green color is a_ color.

The lighter green pen is a_ pen.

The lighter lime color is a_ color.

The lighter lime pen is a_ pen.

The lighter magenta color is a_ color.

The lighter magenta pen is a_ pen.

The lighter orange color is a_ color.

The lighter orange pen is a_ pen.

The lighter purple color is a_ color.

The lighter purple pen is a_ pen.

The lighter red color is a_ color.

The lighter red pen is a_ pen.

The lighter sky blue color is a_ color.

The lighter sky blue pen is a_ pen.

The lighter sky color is a_ color.

The lighter sky pen is a_ pen.

The lighter teal color is a_ color.

The lighter teal pen is a_ pen.

The lighter violet color is a_ color.

The lighter violet pen is a_ pen.

The lighter yellow color is a_ color.

The lighter yellow pen is a_ pen.

The lightest blue color is a_ color.

The lightest blue pen is a_ pen.

The lightest cyan color is a_ color.

The lightest cyan pen is a_ pen.

The lightest gray color is a_ color.

The lightest gray pen is a_ pen.

The lightest green color is a_ color.

The lightest green pen is a_ pen.

The lightest lime color is a_ color.

The lightest lime pen is a_ pen.

The lightest magenta color is a_ color.

The lightest magenta pen is a_ pen.

The lightest orange color is a_ color.

The lightest orange pen is a_ pen.

The lightest purple color is a_ color.

The lightest purple pen is a_ pen.

The lightest red color is a_ color.

The lightest red pen is a_ pen.

The lightest sky blue color is a_ color.

The lightest sky blue pen is a_ pen.

The lightest sky color is a_ color.

The lightest sky pen is a_ pen.

The lightest teal color is a_ color.

The lightest teal pen is a_ pen.

The lightest violet color is a_ color.

The lightest violet pen is a_ pen.

The lightest yellow color is a_ color.

The lightest yellow pen is a_ pen.

a_ lightness is a_ number [0 to 1000].

The lime color is a_ color.

The lime pen is a_ pen.

\PAL
Para limitar uma caixa a outra caixa;
\CAL
To limit a_ box to another box:
Limit the box's left to the other box's left and the other box's right.
Limit the box's top to the other box's top and the other box's bottom.
Limit the box's right to the other box's left and the other box's right.
Limit the box's bottom to the other box's top and the other box's bottom.

To limit the caret in a_ text:
If the text is nil, exit.
Limit the text's caret row# to 1 and the text's row count.
Get a_ row given the text's caret row# and the text.
Limit the text's caret column# to 1 and the row's string's length.

\PAL
Para limitar um número a outro número e um terceiro número;
\CAL
To limit a_ number to another number and a_ third number:
If the number is less than the other number, put the other number into the number; exit.
If the number is greater than the third number, put the third number into the number.

To limit the origin of a_ text:
If the text is nil, exit.
Limit the text's x-coord to the smallest number and the text's margin.
Put the text's row count minus 1 times the text's row height into a_ number.
Limit the text's y-coord to - the number and 0.

\PAL
Para limitar um loco a uma caixa;
\CAL
To limit a_ spot to a_ box:
If the spot's x-coord is less than the box's left, put the box's left into the spot's x-coord.
If the spot's y-coord is less than the box's top, put the box's top into the spot's y-coord.
If the spot's x-coord is greater than the box's right, put the box's right into the spot's x-coord.
If the spot's y-coord is greater than the box's bottom, put the box's bottom into the spot's y-coord.

\PAL
Para limitar alguns textos a um contador;
\CAL
To limit some texts to a_ count:
Put the texts' count into another count.
Loop.
If the other count is less than or equal to the count, exit.
Put the texts' first into a_ text.
Remove the text from the texts.
Destroy the text.
Subtract 1 from the other count.
Repeat.

a_ line has
a_ start spot,
an end spot,
\PAL
um loco inicial at the start,
um loco final at the end.

The linefeed byte is a_ byte equal to 10.

\PAL
Para listar algumas escolhas em uma caixa;
Para desenhar algumas escolhas em uma caixa;
\CAL
To list some choices in a_ box;
To draw some choices in a_ box:
\Draw really fast. ***
Get a_ [first/next] choice from the choices.
If the choice is missing [because we've drawn them all], exit.
Put the box's left plus 1/4 inch into the choice's left.
Put the box's right minus 1/4 inch into the choice's right.
If the choice is the choices' first, put the box's top plus 1/4 inch into the choice's top.
If the choice is not the choices' first, put the choice's previous' bottom into the choice's top.
Put the choice's top plus 1/4 inch into the choice's bottom.
\Draw the choice's box with the purple color. \ temp ***
Stroke the choice's name in the choice's box with the context's color.
Repeat.

\PAL
Para listar algumas escolhas em uma caixa com uma cor;
Para desenhar algumas escolhas em uma caixa com uma cor;
\CAL
To list some choices in a_ box with a_ color;
To draw some choices in a_ box with a_ color:
Put the color into the context's color.
Draw the choices in the box.

The little-a byte is a_ byte equal to 97.

The little-a-acute byte is a_ byte equal to 225.

The little-a-circumflex byte is a_ byte equal to 226.

The little-a-diaeresis byte is a_ byte equal to 228.

The little-a-grave byte is a_ byte equal to 224.

The little-a-ring byte is a_ byte equal to 229.

The little-a-tilde byte is a_ byte equal to 227.

The little-ae byte is a_ byte equal to 230.

The little-b byte is a_ byte equal to 98.

The little-c byte is a_ byte equal to 99.

The little-c-cedilla byte is a_ byte equal to 231.

The little-d byte is a_ byte equal to 100.

The little-e byte is a_ byte equal to 101.

The little-e-acute byte is a_ byte equal to 233.

The little-e-circumflex byte is a_ byte equal to 234.

The little-e-diaeresis byte is a_ byte equal to 235.

The little-e-grave byte is a_ byte equal to 232.

The little-eth byte is a_ byte equal to 240.

The little-f byte is a_ byte equal to 102.

The little-f-hook byte is a_ byte equal to 131.

The little-g byte is a_ byte equal to 103.

The little-h byte is a_ byte equal to 104.

The little-i byte is a_ byte equal to 105.

The little-i-acute byte is a_ byte equal to 237.

The little-i-circumflex byte is a_ byte equal to 238.

The little-i-diaeresis byte is a_ byte equal to 239.

The little-i-grave byte is a_ byte equal to 236.

The little-j byte is a_ byte equal to 106.

The little-k byte is a_ byte equal to 107.

The little-l byte is a_ byte equal to 108.

The little-m byte is a_ byte equal to 109.

The little-n byte is a_ byte equal to 110.

The little-n-tilde byte is a_ byte equal to 241.

The little-o byte is a_ byte equal to 111.

The little-o-acute byte is a_ byte equal to 243.

The little-o-circumflex byte is a_ byte equal to 244.

The little-o-diaeresis byte is a_ byte equal to 246.

The little-o-grave byte is a_ byte equal to 242.

The little-o-stroke byte is a_ byte equal to 248.

The little-o-tilde byte is a_ byte equal to 245.

The little-oe byte is a_ byte equal to 156.

The little-p byte is a_ byte equal to 112.

The little-q byte is a_ byte equal to 113.

The little-r byte is a_ byte equal to 114.

The little-s byte is a_ byte equal to 115.

The little-s-caron byte is a_ byte equal to 154.

The little-t byte is a_ byte equal to 116.

The little-thorn byte is a_ byte equal to 254.

The little-tilde byte is a_ byte equal to 152.

The little-u byte is a_ byte equal to 117.

The little-u-acute byte is a_ byte equal to 250.

The little-u-circumflex byte is a_ byte equal to 251.

The little-u-diaeresis byte is a_ byte equal to 252.

The little-u-grave byte is a_ byte equal to 249.

The little-v byte is a_ byte equal to 118.

The little-w byte is a_ byte equal to 119.

The little-x byte is a_ byte equal to 120.

The little-y byte is a_ byte equal to 121.

The little-y-acute byte is a_ byte equal to 253.

The little-y-diaeresis byte is a_ byte equal to 255.

The little-z byte is a_ byte equal to 122.

The little-z-caron byte is a_ byte equal to 158.

\PAL
Para carregar o léxico;
\CAL
To load the lexicon:
If the lexicon is not nil, exit.
Extract a_ directory from the module's path.
Loop.
If the directory is blank, exit.
Put the directory then "lexicon\" into a_ path.
If the path is in the file system, load the lexicon given the path; exit.
Extract the directory from the directory.
Repeat.

\PAL
Para carregar o léxico dado um depósito;
\CAL
To load the lexicon given a_ buffer:
If the lexicon is nil, create the lexicon.
Slap a_ rider on the buffer.
Loop.
Move the rider (index lexicon rules).
If the rider's token is blank, exit.
Index the rider's token in the lexicon's index.
Repeat.

\PAL
Para carregar o léxico dada uma rota;
\CAL
To load the lexicon given a_ path:
Get an item from the path.
If the item is not found, exit.
If the item's kind is not "file", repeat.
Read the item's path into a_ buffer.
If o erro de e/s is not blank, repeat.
Load the lexicon given the buffer.
Repeat.

To localize a_ box given a_ pair:
Privatize the pair.
Negate the pair.
Move the box given the pair.

To localize a_ spot given a_ pair:
Privatize the pair.
Negate the pair.
Move the spot given the pair.

To lock a_ gpbitmap given a_ bitmapdata (24-bit rgb):
Put the gpbitmap's gprect into a_ gprect.
Call "gdiplus.dll" "GdipBitmapLockBits" with the gpbitmap and the gprect's whereabouts and 3 [imagelockmoderead or imagelockmodewrite]
And 137224 [pixelformat24bpprgb] and the bitmapdata's whereabouts.

a_ logbrush has
a_ number called lbstyle,
a_ colorref called lbcolor,
a_ number called lbhatch.

The lower-double-quote byte is a_ byte equal to 132.

The lower-single-quote byte is a_ byte equal to 130.

\PAL
Para passar para minúsculas os bytes selecionados em um texto;
Para passar os bytes selecionados em um texto para minúsculas;
\CAL
To lowercase any selected bytes in a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row of the text is not selected, repeat.
Slap a_ substring on any selected bytes in the row of the text.  
Lowercase the substring.
Repeat.

\PAL
Para passar para minúscula um byte;
Para passar um byte para minúscula;
\CAL
To lowercase a_ byte:
Translate the byte given the lowercase ascii table.

To lowercase the character under a_ finger and put it into a_ string:
If the finger is nil, exit.
Put the finger's target into the string.
Lowercase the string.

\PAL
Para passar para minúsculas uma sequência;
Para passar uma sequência para minúsculas;
\CAL
To lowercase a_ string:
Slap a_ substring on the string.
Loop.
If the substring is blank, exit.
Lowercase the substring's first's target.
Add 1 to the substring's first.
Repeat.

\PAL
Para passar para minúsculas um texto;
Para passar um texto para minúsculas;
\CAL
To lowercase a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, break.
Lowercase the row's string.
Repeat.
Wrap the text.

The m-key is a_ key equal to 77.

The magenta color is a_ color.

The magenta pen is a_ pen.

The main window is a_ window.

\PAL
Para fazer uma fração com um número e outro número;
\CAL
To make a_ fraction with a_ number and another number:
Put the number into the fraction's numerator.
Put the other number into the fraction's denominator.

To make a_ ratio pair given a_ box and another box;
To make a_ fraction pair given a_ box and another box:
Put the box's x-extent into the fraction pair's fraction's numerator.
Put the other box's x-extent into the fraction pair's fraction's denominator.
Put the box's y-extent into the fraction pair's other fraction's numerator.
Put the other box's y-extent into the fraction pair's other fraction's denominator.

a_ margin is a_ number.

The masculine byte is a_ byte equal to 186.

\PAL
Para mascarar dentro de uma caixa;
\CAL
To mask inside a_ box:
Create an hrgn given the box.
Mask inside the hrgn.
Destroy the hrgn.

\PAL
Para mascarar dentro de uma elipse;
\CAL
To mask inside an ellipse:
Create an hrgn given the ellipse.
Mask inside the hrgn.
Destroy the hrgn.

To mask inside an hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 4 [rgn_diff].

\PAL
Para mascarar dentro de um polígono;
\CAL
To mask inside a_ polygon:
Create an hrgn given the polygon.
Mask inside the hrgn.
Destroy the hrgn.

\PAL
Para mascarar dentro de uma caixa arredondada;
\CAL
To mask inside a_ roundy box:
Create an hrgn given the roundy box.
Mask inside the hrgn.
Destroy the hrgn.

a_ mask is a_ hex string.

\PAL
Para mascarar somente dentro de uma caixa;
\CAL
To mask only inside a_ box:
Unmask everything.
Mask inside the box.

\PAL
Para mascarar somente dentro de uma elipse;
\CAL
To mask only inside an ellipse:
Unmask everything.
Mask inside the ellipse.

\PAL
Para mascarar somente dentro de um polígono;
\CAL
To mask only inside a_ polygon:
Unmask everything.
Mask inside the polygon.

\PAL
Para mascarar somente dentro de uma caixa arredondada;
\CAL
To mask only inside a_ roundy box:
Unmask everything.
Mask inside the roundy box.

\PAL
Para mascarar somente fora de uma caixa;
\CAL
To mask only outside a_ box:
Unmask everything.
Mask outside the box.

\PAL
Para mascarar somente fora de uma elipse;
\CAL
To mask only outside an ellipse:
Unmask everything.
Mask outside the ellipse.

\PAL
Para mascarar somente fora de um polígono;
\CAL
To mask only outside a_ polygon:
Unmask everything.
Mask outside the polygon.

\PAL
Para mascarar somente fora de uma caixa arredondada;
\CAL
To mask only outside a_ roundy box:
Unmask everything.
Mask outside the roundy box.

\PAL
Para mascarar fora de uma caixa;
\CAL
To mask outside a_ box:
Create an hrgn given the box.
Mask outside the hrgn.
Destroy the hrgn.

\PAL
Para mascarar fora de uma elipse;
\CAL
To mask outside an ellipse:
Create an hrgn given the ellipse.
Mask outside the hrgn.
Destroy the hrgn.

To mask outside an hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 1 [rgn_and].

\PAL
Para mascarar fora de um polígono;
\CAL
To mask outside a_ polygon:
Create an hrgn given the polygon.
Mask outside the hrgn.
Destroy the hrgn.

\PAL
Para mascarar fora de uma caixa arredondada;
\CAL
To mask outside a_ roundy box:
Create an hrgn given the roundy box.
Mask outside the hrgn.
Destroy the hrgn.

The max text undos is a_ count equal to 32.

The medium letter height is a_ letter height.

a_ megabyte is 1024 kilobytes.

The memory canvas is a_ canvas.

The menu key is a_ key equal to 93.

a_ message is a_ string.

The micro byte is a_ byte equal to 181.

a_ million is 1000 thousands.

a_ millisecond is a_ number.

\PAL
Para minimizar uma janela;
\CAL
To minimize a_ window:
Call "user32.dll" "ShowWindow" with the window and 6 [sw_minimize].

The minus-sign byte is a_ byte equal to 45.

a_ minute is 60 seconds.

To mirror the gpbitmap in a_ picture:
If the picture is nil, exit.
Reverse the picture's mirror flag.
Mirror the picture's gpbitmap.

To mirror a_ gpimage:
Call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 4 [rotatenoneflipx].

\PAL
Para refletir uma imagem;
\CAL
To mirror a_ picture:
If the picture is nil, exit.
Put the picture's box's center's x-coord minus the picture's uncropped box's center's x-coord into a_ pair's x-number.
Multiply the pair's x-number by 2.
Move the picture's uncropped box given the pair.
Mirror the gpbitmap in the picture.

\PAL
Para refletir um polígono;
\CAL
To mirror a_ polygon:
If the polygon is nil, exit.
Put the polygon's box into a_ box.
Loop.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, exit.
Subtract the box's left from the vertex's x-coord.
Put the box's right minus the vertex's x-coord into the vertex's x-coord.
Repeat.

a_ mixed has a_ whole number and a_ ratio and a_ fraction at the ratio.

The module has
a_ handle,
a_ path,
a_ directory,
a_ root directory, \ one up from the directory that exe is run from
a_ file name w/o extension called name.

The mouse has
a_ key called left button,
a_ key called right button,
\PAL
uma tecla chamada botão esquerdo at the left button,
uma tecla chamada botão direito at the right button.

To move the anchor left to any non-alphanumeric byte in a_ text:
If the text is nil, exit.
Get a_ row given the text's anchor row# and the text.
Loop.
If the text's anchor column# is 1, exit.
Put the row's string's first plus the text's anchor column# minus 2 into a_ byte pointer.
If the byte pointer's target is not alphanumeric, exit.
Subtract 1 from the text's anchor column#.
Repeat.

\PAL
Para voltar alguns twips;
Para retroceder alguns twips;
\CAL
To move back some twips:
Turn around.
Move the twips.
Turn around.

To move a_ box to the bottom of another box:
Move the box down the other box's bottom minus the box's bottom.

To move a_ box close to the left side of another box;
To move a_ box close to the left of another box:
Move the box to the left of the other box.
Pick a_ length between 0 and the box's width times 3/4.
Move the box right the length.

\PAL
Para mover uma caixa para baixo em alguns twips;
Para mover uma caixa para baixo alguns twips;
Para mover uma caixa abaixo em alguns twips;
Para mover uma caixa abaixo alguns twips;
\CAL
To move a_ box down some twips:
Move the box given 0 and the twips.

\PAL
Para mover uma caixa dado um par;
\CAL
To move a_ box given a_ pair:
Move the box given the pair's x-number and the pair's y-number.

To move a_ box given a_ ratio pair and a_ spot;
To move a_ box given a_ fraction pair and a_ spot:
Get a_ difference between the box's left-top and the spot.
Put the difference into another difference.
Scale the other difference given the fraction pair.
Subtract the difference from the other difference.
Move the box given the other difference.

Some x-twips are some twips.
Some y-twips are some twips.

\PAL
Para mover uma caixa dado alguns x-twips e alguns y-twips;
\CAL
To move a_ box given some x-twips and some y-twips:
Add the x-twips to the box's left.
Add the y-twips to the box's top.
Add the x-twips to the box's right.
Add the y-twips to the box's bottom.

\PAL
Para mover uma caixa à esquerda de uma coordenada;
\CAL
To move a_ box left to a_ coord:
Move the box left the box's left minus the coord.

\PAL
Para mover uma caixa para o lado esquerdo de outra caixa;
\CAL
To move a_ box to the left side of another box;
To move a_ box to the left of another box:
Move the box left the box's left minus the other box's left.

\PAL
Para mover uma caixa para a esquerda em alguns twips;
Para mover uma caixa para a esquerda alguns twips;
Para mover uma caixa à esquerda em alguns twips;
Para mover uma caixa à esquerda alguns twips;
\CAL
To move a_ box left some twips:
Move the box given - the twips and 0.

\PAL
Para mover uma caixa para o lado direito de outra caixa;
\CAL
To move a_ box to the right side of another box;
To move a_ box to the right of another box:
Move the box right the other box's right minus the box's right.

\PAL
Para mover uma caixa para a direita em alguns twips;
Para mover uma caixa para a direita alguns twips;
Para mover uma caixa à direita em alguns twips;
Para mover uma caixa à direita alguns twips;
\CAL
To move a_ box right some twips:
Move the box given the twips and 0.

\PAL
Para mover uma caixa para um loco;
\CAL
To move a_ box to a_ spot:
Get a_ difference between the spot and the box's left-top.
Move the box given the difference.

\PAL
Para mover uma caixa para o canto superior esquerdo de outra caixa;
\CAL
To move a_ box to the top left corner of another box:
Move the box to the other box's left-top.

\PAL
Para mover uma caixa para o topo de outra caixa;
\CAL
To move a_ box to the top of another box:
Move the box up the box's top minus the other box's top.

\PAL
Para mover uma caixa para cima em alguns twips;
Para mover uma caixa para cima alguns twips;
Para mover uma caixa acima em alguns twips;
Para mover uma caixa acima alguns twips;
\CAL
To move a_ box up some twips:
Move the box given 0 and - the twips.

To move the caret down in a_ text:
If the text is nil, exit.
Add 1 to the text's caret row#.
Limit the caret in the text.

To move the caret down one page in a_ text:
If the text is nil, exit.
Add the text's rows/box to the text's caret row#.
Subtract 1 from the text's caret row#.
Limit the caret in the text.

To move the caret to the first byte of the current row of a_ text:
If the text is nil, exit.
Put 1 into the text's caret column#.

To move the caret to the first byte of a_ text:
If the text is nil, exit.
Put 1 and 1 into the text's caret.

To move the caret to the last byte of the current row of a_ text:
If the text is nil, exit.
Get a_ row given the text's caret row# and the text.
Put the row's string's length into the text's caret column#.

To move the caret to the last byte of a_ text:
If the text is nil, exit.
Put the text's row count into the text's caret row#.
Get a_ row given the text's caret row# and the text.
Put the row's string's length into the text's caret column#.

To move the caret left to any non-alphanumeric byte in a_ text:
If the text is nil, exit.
Get a_ row given the text's caret row# and the text.
Loop.
If the text's caret column# is 1, exit.
Put the row's string's first plus the text's caret column# minus 2 into a_ byte pointer.
If the byte pointer's target is not alphanumeric, exit.
Subtract 1 from the text's caret column#.
Repeat.

To move the caret left to any non-noise byte in a_ text:
If the text is nil, exit.
Get a_ row given the text's caret row# and the text.
Loop.
If the text's caret column# is 1, exit.
Put the row's string's first plus the text's caret column# minus 2 into a_ byte pointer.
If the byte pointer's target is not noise, exit.
Subtract 1 from the text's caret column#.
Repeat.

To move the caret left to any non-symbolic byte in a_ text:
If the text is nil, exit.
Get a_ row given the text's caret row# and the text.
Loop.
If the text's caret column# is 1, exit.
Put the row's string's first plus the text's caret column# minus 2 into a_ byte pointer.
If the byte pointer's target is not symbolic, exit.
Subtract 1 from the text's caret column#.
Repeat.

To move the caret left in a_ text:
If the text is nil, exit.
Subtract 1 from the text's caret column#.
Limit the caret in the text.

To move the caret right to any non-alphanumeric byte in a_ text:
If the text is nil, exit.
Get a_ row given the text's caret row# and the text.
Loop.
If the text's caret column# is the row's string's length, exit.
Put the row's string's first plus the text's caret column# minus 1 into a_ byte pointer.
If the byte pointer's target is not alphanumeric, exit.
Add 1 to the text's caret column#.
Repeat.

To move the caret right to any non-noise byte in a_ text:
If the text is nil, exit.
Get a_ row given the text's caret row# and the text.
Loop.
If the text's caret column# is the row's string's length, exit.
Put the row's string's first plus the text's caret column# minus 1 into a_ byte pointer.
If the byte pointer's target is not noise, exit.
Add 1 to the text's caret column#.
Repeat.

To move the caret right to any non-symbolic byte in a_ text:
If the text is nil, exit.
Get a_ row given the text's caret row# and the text.
Loop.
If the text's caret column# is the row's string's length, exit.
Put the row's string's first plus the text's caret column# minus 1 into a_ byte pointer.
If the byte pointer's target is not symbolic, exit.
Add 1 to the text's caret column#.
Repeat.

To move the caret right in a_ text:
If the text is nil, exit.
Add 1 to the text's caret column#.
Limit the caret in the text.

To move the caret up in a_ text:
If the text is nil, exit.
Subtract 1 from the text's caret row#.
Limit the caret in the text.

To move the caret up one page in a_ text:
If the text is nil, exit.
Subtract the text's rows/box from the text's caret row#.
Add 1 to the text's caret row#.
Limit the caret in the text.

\PAL
Para mover uma elipse para baixo em alguns twips;
Para mover uma elipse para baixo alguns twips;
Para mover uma elipse abaixo em alguns twips;
Para mover uma elipse abaixo alguns twips;
\CAL
To move an ellipse down some twips:
Move the ellipse given 0 and the twips.

\PAL
Para mover uma elipse dado um par;
\CAL
To move an ellipse given a_ pair:
Move the ellipse given the pair's x-number and the pair's y-number.

\PAL
Para mover uma elipse dado alguns x-twips e alguns y-twips;
\CAL
To move an ellipse given some x-twips and some y-twips:
Move the ellipse's box given the x-twips and the y-twips.

\PAL
Para mover uma elipse para a esquerda em alguns twips;
Para mover uma elipse para a esquerda alguns twips;
Para mover uma elipse à esquerda em alguns twips;
Para mover uma elipse à esquerda alguns twips;
\CAL
To move an ellipse left some twips:
Move the ellipse given - the twips and 0.

\PAL
Para mover uma elipse para a direita em alguns twips;
Para mover uma elipse para a direita alguns twips;
Para mover uma elipse à direita em alguns twips;
Para mover uma elipse à direita alguns twips;
\CAL
To move an ellipse right some twips:
Move the ellipse given the twips and 0.

\PAL
Para mover uma elipse para um loco;
\CAL
To move an ellipse to a_ spot:
Get a_ difference between the spot and the ellipse's left-top.
Move the ellipse given the difference.

\PAL
Para mover uma elipse para cima em alguns twips;
Para mover uma elipse para cima alguns twips;
Para mover uma elipse acima em alguns twips;
Para mover uma elipse acima alguns twips;
\CAL
To move an ellipse up some twips:
Move the ellipse given 0 and - the twips.

To move a_ finger over a_ number:
If the finger is nil, exit.
Add 1 to the finger.

\PAL
Para mover para a esquerda alguns twips e para baixo alguns outros twips;
Para mover para a esquerda alguns twips e abaixo alguns outros twips;
Para mover à esquerda alguns twips e para baixo alguns outros twips;
Para mover à esquerda alguns twips e abaixo alguns outros twips;
\CAL
To move to the left some twips and down some other twips;
To move left some twips and down some other twips;
To move some twips to the left and some other twips down;
To move some twips left and some other twips down:
Move the context's spot left the twips.
Move the context's spot down the other twips.

\PAL
Para mover para a esquerda alguns twips e para cima alguns outros twips;
Para mover para a esquerda alguns twips e acima alguns outros twips;
Para mover à esquerda alguns twips e para cima alguns outros twips;
Para mover à esquerda alguns twips e acima alguns outros twips;
\CAL
To move to the left some twips and up some other twips;
To move left some twips and up some other twips;
To move some twips to the left and some other twips up;
To move some twips left and some other twips up:
Move the context's spot left the twips.
Move the context's spot up the other twips.

\PAL
Para mover uma reta para baixo em alguns twips;
Para mover uma reta para baixo alguns twips;
Para mover uma reta abaixo em alguns twips;
Para mover uma reta abaixo alguns twips;
\CAL
To move a_ line down some twips:
Move the line given 0 and the twips.

\PAL
Para mover uma reta dado um par;
\CAL
To move a_ line given a_ pair:
Move the line given the pair's x-number and the pair's y-number.

\PAL
Para mover uma reta dado alguns x-twips e alguns y-twips;
\CAL
To move a_ line given some x-twips and some y-twips:
Add the x-twips to the line's start's x-coord.
Add the y-twips to the line's start's y-coord.
Add the x-twips to the line's end's x-coord.
Add the y-twips to the line's end's y-coord.

\PAL
Para mover uma reta para a esquerda em alguns twips;
Para mover uma reta para a esquerda alguns twips;
Para mover uma reta à esquerda em alguns twips;
Para mover uma reta à esquerda alguns twips;
\CAL
To move a_ line left some twips:
Move the line given - the twips and 0.

\PAL
Para mover uma reta para um loco;
\CAL
To move a_ line to a_ spot:
Get a_ difference between the spot and the line's start.
Move the line given the difference.

\PAL
Para mover uma reta para a direita em alguns twips;
Para mover uma reta para a direita alguns twips;
Para mover uma reta à direita em alguns twips;
Para mover uma reta à direita alguns twips;
\CAL
To move a_ line some twips to the right;
To move a_ line right some twips:
Move the line given the twips and 0.

\PAL
Para mover uma reta para cima em alguns twips;
Para mover uma reta para cima alguns twips;
Para mover uma reta acima em alguns twips;
Para mover uma reta acima alguns twips;
\CAL
To move a_ line up some twips:
Move the line given 0 and - the twips.

\PAL
Para iniciar no centro;
\CAL
To move to the middle;
To start in the middle;
To move to the center;
To start in the center:
Put the context's box's center into the context's spot.

\PAL
Para iniciar no centro em uma caixa;
\CAL
To move to the middle of a_ box;
To start in the middle of a_ box;
To move to the center of a_ box;
To start in the center of a_ box:
Put the box's center into the context's spot.

\PAL
Para mover uma imagem para baixo em alguns twips;
Para mover uma imagem para baixo alguns twips;
Para mover uma imagem abaixo em alguns twips;
Para mover uma imagem abaixo alguns twips;
\CAL
To move a_ picture down some twips:
Move the picture given 0 and the twips.

\PAL
Para mover uma imagem dado um par;
\CAL
To move a_ picture given a_ pair:
Move the picture given the pair's x-number and the pair's y-number.

\PAL
Para mover uma imagem dado alguns x-twips e alguns y-twips;
\CAL
To move a_ picture given some x-twips and some y-twips:
If the picture is nil, exit.
Move the picture's box given the x-twips and the y-twips.
Move the picture's uncropped box given the x-twips and the y-twips.

\PAL
Para mover uma imagem para a esquerda em alguns twips;
Para mover uma imagem para a esquerda alguns twips;
Para mover uma imagem à esquerda em alguns twips;
Para mover uma imagem à esquerda alguns twips;
\CAL
To move a_ picture left some twips:
Move the picture given - the twips and 0.

\PAL
Para mover uma imagem para a direita em alguns twips;
Para mover uma imagem para a direita alguns twips;
Para mover uma imagem à direita em alguns twips;
Para mover uma imagem à direita alguns twips;
\CAL
To move a_ picture right some twips:
Move the picture given the twips and 0.

\PAL
Para mover uma imagem para um loco;
\CAL
To move a_ picture to a_ spot:
If the picture is nil, exit.
Get a_ difference between the spot and the picture's left-top.
Move the picture given the difference.

\PAL
Para mover uma imagem para cima em alguns twips;
Para mover uma imagem para cima alguns twips;
Para mover uma imagem acima em alguns twips;
Para mover uma imagem acima alguns twips;
\CAL
To move a_ picture up some twips:
Move the picture given 0 and - the twips.

\PAL
Para mover uma polígono para baixo em alguns twips;
Para mover uma polígono para baixo alguns twips;
Para mover uma polígono abaixo em alguns twips;
Para mover uma polígono abaixo alguns twips;
\CAL
To move a_ polygon down some twips:
Move the polygon given 0 and the twips.

\PAL
Para mover um polígono dado um par;
\CAL
To move a_ polygon given a_ pair:
Move the polygon given the pair's x-number and the pair's y-number.

\PAL
Para mover um polígono dado alguns x-twips e alguns y-twips;
\CAL
To move a_ polygon given some x-twips and some y-twips:
If the polygon is nil, exit.
Loop.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, exit.
Move the vertex given the x-twips and the y-twips.
Repeat.

\PAL
Para mover um polígono alguns twips à esquerda;
\CAL
To move a_ polygon left some twips:
Move the polygon given - the twips and 0.

\PAL
Para mover um polígono alguns twips à esquerda e outros twips abaixo;
\CAL
To move a_ polygon left some twips and down some other twips:
Move the polygon left the twips.
Move the polygon down the other twips.

\PAL
Para mover um polígono alguns twips à esquerda e outros twips acima;
\CAL
To move a_ polygon left some twips and up some other twips:
Move the polygon left the twips.
Move the polygon up the other twips.

\PAL
Para mover um polígono alguns twips à direita;
\CAL
To move a_ polygon right some twips:
Move the polygon given the twips and 0.

\PAL
Para mover um polígono alguns twips à direita e outros twips abaixo;
\CAL
To move a_ polygon right some twips and down some other twips:
Move the polygon right the twips.
Move the polygon down the other twips.

\PAL
Para mover um polígono alguns twips à direita e outros twips acima;
\CAL
To move a_ polygon right some twips and up some other twips:
Move the polygon right the twips.
Move the polygon up the other twips.

\PAL
Para mover um polígono para um loco;
Para mover um polígono até um loco;
\CAL
To move a_ polygon to a_ spot:
If the polygon is nil, exit.
Get a_ difference between the spot and the polygon's box's left-top.
Move the polygon given the difference.

\PAL
Para mover um polígono alguns twips acima;
\CAL
To move a_ polygon up some twips:
Move the polygon given 0 and - the twips.

\PAL
Para mover um iterador (regras do índice léxico);
\CAL
To move a_ rider (index lexicon rules):
Skip any leading noise in the rider's source.
Position the rider's token on the rider's source.
Loop.
If the rider's source is blank, exit.
Bump the rider.
If the rider's source's first's target is noise, exit.
Repeat.

\PAL
Para mover um iterador (regras de citações);
\CAL
To move a_ rider (quoted string rules):
Bump the rider.
If the rider's source is blank, exit.
If the rider's source's first's target is not the double-quote byte, repeat.
If the rider's source's first is the rider's source's last, bump the rider; exit.
Bump the rider.
If the rider's source's first's target is not the double-quote byte, exit.
Repeat.

\PAL
Para mover um iterador (regras de correção ortográfica);
\CAL
To move a_ rider (spell checking rules):
Skip any non-alphanumeric bytes in the rider's source.
Position the rider's token on the rider's source.
Loop.
If the rider's source is blank, exit.
Bump the rider.
If the rider's source is on any contraction, bump the rider; repeat.
If the rider's source's first's target is not alphanumeric, exit.
Repeat.

\PAL
Para mover um iterador (regras de arquivo texto);
\CAL
To move a_ rider (text file rules):
Position the rider's token on the rider's source.
Loop.
If the rider's source is blank, exit.
If the rider's source's first's target is the return byte, bump the rider; break.
If the rider's source's first's target is the linefeed byte, bump the rider; exit. \ *dahn new to handle lines terminated by just linefeed
Bump the rider.
Repeat.
If the rider's source is blank, exit.
If the rider's source's first's target is the linefeed byte, add 1 to the rider's source's first.

\PAL
Para mover um iterador (regras de quebra de linha);
\CAL
To move a_ rider (word wrapping rules):
Position the rider's token on the rider's source.
If the rider's source is blank, exit.
If the rider's source's first's target is the return byte, bump the rider; exit.
Loop.
If the rider's source is blank, exit.
If the rider's source's first's target is the return byte, exit.
If the rider's token is blank, bump the rider; repeat.
If the rider's source's first's target is like the rider's token's last's target, bump the rider; repeat.

\PAL
Para mover um iterador dada uma caixa (regras de quebra de linha);
\CAL
To move a_ rider given a_ box (word wrapping rules):
Skip any leading linefeed byte in the rider's source.
Position the rider's token on the rider's source.
If the rider's source is blank, exit.
Slap another rider on the rider.
Loop.
If the rider's source is blank, exit.
Move the other rider (word wrapping rules).
If the other rider's token is blank, exit.
If the other rider's token's first's target is the return byte, bump the rider; exit.
If the other rider's token's first's target is whitespace, bump the rider by the other rider's token's length; repeat.
If the rider's token is blank, bump the rider by the other rider's token's length; repeat.
If the rider's token then the other rider's token is wider than the box, exit.
Bump the rider by the other rider's token's length.
Repeat.

\PAL
Para mover um iterador dada um byte separador;
\CAL
To move a_ rider given a_ separator byte:
Position the rider's token on the rider's source.
Loop.
If the rider's source is blank, exit.
If the rider's source's first's target is the separator byte, add 1 to the rider's source's first; exit.
Bump the rider.
Repeat.

\PAL
Para mover alguns twips à direita e outros twips abaixo;
\CAL
To move to the right some twips and down some other twips;
To move right some twips and down some other twips;
To move some twips to the right and some other twips down;
To move some twips right and some other twips down:
Move the context's spot right the twips.
Move the context's spot down the other twips.

\PAL
Para mover alguns twips à direita e outros twips acima;
\CAL
To move to the right some twips and up some other twips;
To move right some twips and up some other twips;
To move some twips to the right and some other twips up;
To move some twips right and some other twips up:
Move the context's spot right the twips.
Move the context's spot up the other twips.

\PAL
Para mover para um loco;
Para mover até um loco;
\CAL
To move to a_ spot:
Put the spot into the context's spot.

\PAL
Para mover um loco sobre alguns twips em qualquer direção;
Para mover um loco em alguns twips para qualquer direção;
\CAL
To move a_ spot about some twips in any direction:
Pick another spot within the twips of the spot.
Put the other spot into the spot.

\PAL
Para mover um loco para outro loco;
Para mover um loco até outro loco;
\CAL
To move a_ spot to another spot:
Put the other spot into the spot.

\PAL
Para mover um loco dado um par;
\CAL
To move a_ spot given a_ pair:
Move the spot given the pair's x-number and the pair's y-number.

\PAL
Para mover um loco dado alguns x-twips e alguns y-twips;
\CAL
To move a_ spot given some x-twips and some y-twips:
Add the x-twips to the spot's x-coord.
Add the y-twips to the spot's y-coord.

\PAL
Para mover um loco alguns twips abaixo;
\CAL
To move a_ spot some twips down;
To move a_ spot down some twips:
Move the spot given 0 and the twips.

\PAL
Para mover um loco alguns twips à esquerda;
\CAL
To move a_ spot some twips to the left;
To move a_ spot some twips left;
To move a_ spot left some twips:
Move the spot given - the twips and 0.

\PAL
Para mover um loco alguns twips à direita;
\CAL
To move a_ spot some twips right;
To move a_ spot some twips to the right;
To move a_ spot right some twips:
Move the spot given the twips and 0.

\PAL
Para mover um loco alguns twips à direita e outros twips abaixo;
\CAL
To move a_ spot some twips to the right and some other twips down;
To move a_ spot some twips right and some other twips down:
Add the twips to the spot's x-coord.
Add the other twips to the spot's y-coord.

\PAL
Para mover um loco alguns twips acima;
\CAL
To move a_ spot some twips up;
To move a_ spot up some twips:
Move the spot given 0 and - the twips.

To move some squares:
Move the square size times the squares divided by 1 square. \ squares are scaled up for precision hence the division at the end

To move some squares diagonally;
To move some squares slantways:
Move the square size times the squares times the squirt o' two divided by 1 square. \ squares are scaled up for precision hence the division at the end

\PAL
Para mover um segmento dado um número;
\CAL
To move a_ substring given a_ number:
Add the number to the substring's first.
Add the number to the substring's last.

\PAL
Para mover um texto alguns twips abaixo;
\CAL
To move a_ text down some twips:
Move the text given 0 and the twips.

\PAL
Para mover um texto dado um par;
\CAL
To move a_ text given a_ pair:
Move the text given the pair's x-number and the pair's y-number.

\PAL
Para mover um texto dado alguns x-twips e alguns y-twips;
\CAL
To move a_ text given some x-twips and some y-twips:
If the text is nil, exit.
Move the text's box given the x-twips and the y-twips.

\PAL
Para mover um texto alguns twips à esquerda;
\CAL
To move a_ text left some twips:
Move the text given - the twips and 0.

\PAL
Para mover um texto alguns twips à direita;
\CAL
To move a_ text right some twips:
Move the text given the twips and 0.

\PAL
Para mover um texto para um loco;
Para mover um texto até um loco;
\CAL
To move a_ text to a_ spot:
If the text is nil, exit.
Get a_ difference between the spot and the text's left-top.
Move the text given the difference.

\PAL
Para mover um texto alguns twips acima;
\CAL
To move a_ text up some twips:
Move the text given 0 and - the twips.

\PAL
Para mover um elemento de alguns elementos para outros elementos;
\CAL
To move a_ thing from some things to some other things:
If the thing is nil, exit.
Privatize the thing.
Remove the thing from the things.
Append the thing to the other things.

\PAL
Para mover alguns elementos para alguns outros elementos;
\CAL
To move some things to some other things:
Put the things' first into the other things' first.
Put the things' last into the other things' last.
Clear the things.

\PAL
Para mover alguns twips;
\CAL
To move some twips:
\Wait for_ the delay. ***
Put the context's spot into a_ line's start.
Put the context's spot into the line's end.
Get a_ rise and a_ run given the context's heading.
Add the run times the twips divided by 10000 to the line's end's x-coord.
Add the rise times the twips divided by 10000 to the line's end's y-coord.
Put the line's end into the context's spot.

\PAL
Para mover alguns twips abaixo;
\CAL
To move some twips down;
To move down some twips:
Add the twips to the context's y-coord.

\PAL
Para mover alguns twips à esquerda;
\CAL
To move some twips to the left;
To move some twips left;
To move left some twips:
Subtract the twips from the context's x-coord.

\PAL
Para mover alguns twips à direita;
\CAL
To move some twips to the right;
To move some twips right;
To move right some twips: 
Add the twips to the context's x-coord.

\PAL
Para mover alguns twips acima;
\CAL
To move some twips up;
To move up some twips: 
Subtract the twips from the context's y-coord.

\PAL
Para mover um vértice alguns twips abaixo;
\CAL
To move a_ vertex down some twips:
Move the vertex given 0 and the twips.

\PAL
Para mover um vértice dado um par;
\CAL
To move a_ vertex given a_ pair:
Move the vertex given the pair's x-number and the pair's y-number.

\PAL
Para mover um vértice dado alguns x-twips e alguns y-twips;
\CAL
To move a_ vertex given some x-twips and some y-twips:
If the vertex is nil, exit.
Add the x-twips to the vertex's x-coord.
Add the y-twips to the vertex's y-coord.

\PAL
Para mover um vértice alguns twips à esquerda;
\CAL
To move a_ vertex left some twips:
Move the vertex given - the twips and 0.

\PAL
Para mover um vértice alguns twips à direita;
\CAL
To move a_ vertex right some twips:
Move the vertex given the twips and 0.

\PAL
Para mover um vértice para um loco;
Para mover um vértice até um loco;
\CAL
To move a_ vertex to a_ spot:
If the vertex is nil, exit.
Put the spot into the vertex's spot.

\PAL
Para mover um vértice alguns twips acima;
\CAL
To move a_ vertex up some twips:
Move the vertex given 0 and - the twips.

To move a_ window left:
Call "user32.dll" "GetWindowRect" with the main window and a_ box's whereabouts.
Subtract the screen's pixel width from the box's left.
Call "user32.dll" "MoveWindow" with the window and the box's left and the box's top and the screen's pixel width and the screen's pixel height and 1.

To move a_ window right:
Call "user32.dll" "GetWindowRect" with the main window and a_ box's whereabouts.
Add the screen's pixel width to the box's left.
Call "user32.dll" "MoveWindow" with the window and the box's left and the box's top and the screen's pixel width and the screen's pixel height and 1.

a_ ms is 1 millisecond.

a_ msg is a_ record with
a_ window called hwnd,
a_ number called message,
a_ w-param called wparam,
a_ l-param called lparam,
a_ number called time,
a_ spot called pt.

a_ multiple is a_ number.

The multiplication-symbol byte is a_ byte equal to 215.

\PAL
Para multiplicar uma fração por um número;
\CAL
To multiply a_ fraction by a_ number:
Multiply the fraction's numerator by the number.
Reduce the fraction.

\PAL
Para multiplicar um número por uma fração;
\CAL
To multiply a_ number by a_ fraction;
To scale a_ number given a_ ratio;
To scale a_ number given a_ fraction:
If the fraction's denominator is 0, exit.
Call "kernel32.dll" "MulDiv" with the number and the fraction's numerator and the fraction's denominator returning the number.

\PAL
Para multiplicar um par por outro par;
\CAL
To multiply a_ pair by another pair:
Multiply the pair's x-number by the other pair's x-number.
Multiply the pair's y-number by the other pair's y-number.

\PAL
Para multiplicar um par por um número;
\CAL
To multiply a_ pair by a_ number:
Multiply the pair's x-number by the number.
Multiply the pair's y-number by the number.

\PAL
Para multiplicar um par por um número e outro número;
\CAL
To multiply a_ pair by a_ number and another number:
Multiply the pair's x-number by the number.
Multiply the pair's y-number by the other number.

\PAL
Para multiplicar um ponteiro por um número;
\CAL
To multiply a_ pointer by a_ number;
Para multiplicar un número por otro número;
To multiply a_ number by another number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
Intel $F72B.\ mul [ebx] \ means mul eax,[ebx] but is weird form
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8903. \ mov [ebx],eax

The n-key is a_ key equal to 78.

a_ name is a_ string.

\PAL
Para negar uma fração;
Para negativar uma fração;
\CAL
To negate a_ fraction:
Negate the fraction's numerator.

\PAL
Para negar um número;
Para negativar um número;
\CAL
To negate a_ number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $F718.\ neg [eax]

\PAL
Para negar um par;
Para negativar um par;
\CAL
To negate a_ pair:
Negate the pair's x-number.
Negate the pair's y-number.

The negative-acknowledge byte is a_ byte equal to 21.

The next letter is a_ letter equal to 65 [the big-a byte].

a_ nibble is a_ byte. \ only low order 4 bits are valid

a_ nibble string is a_ string. \ $0010A0...

The nine byte is a_ byte equal to 57.

The nine key is a_ key equal to 57.

The non-breaking-space byte is a_ byte equal to 160.

To non-destructively resize a_ picture given a_ ratio pair;
To non-destructively resize a_ picture given a_ fraction pair:
If the picture is nil, exit.
Move the picture's uncropped box given the fraction pair and the picture's box's left-top.
Resize the picture's uncropped box given the fraction pair.
Resize the picture's box given the fraction pair.
If the picture's right is less than the picture's left, mirror the gpbitmap in the picture.
If the picture's bottom is less than the picture's top, flip the gpbitmap in the picture.

To non-destructively resize a_ picture given a_ twip pair:
If the picture is nil, exit.
Put the picture's box into a_ box.
Resize the box given the twip pair.
Make a_ fraction pair given the box and the picture's box.
Non-destructively resize the picture given the fraction pair.

\PAL
Para normalizar um ângulo;
\CAL
To normalize an angle:
divide the angle by 3600 giving a_ quotient and the angle.

\PAL
Para normalizar uma caixa;
\CAL
To normalize a_ box:
If the box's right is less than the box's left, swap the box's left with the box's right.
If the box's bottom is less than the box's top, swap the box's top with the box's bottom.

To normalize a_ canvas:
Call "gdi32.dll" "SetGraphicsMode" with the canvas and 2 [gm_advanced].
Call "gdi32.dll" "SetBkMode" with the canvas and 1 [transparent].
Call "gdi32.dll" "SetMapMode" with the canvas and 8 [mm_anisotropic].
Call "gdi32.dll" "SetViewportOrgEx" with the canvas and 0 and 0 and nil.
Call "gdi32.dll" "SetViewportExtEx" with the canvas and the ppi and the ppi and nil.
Call "gdi32.dll" "SetWindowOrgEx" with the canvas and 0 and 0 and nil.
Call "gdi32.dll" "SetWindowExtEx" with the canvas and the tpi and the tpi and nil.

\PAL
Para normalizar uma elipse;
\CAL
To normalize an ellipse:
Normalize the ellipse's box.

\PAL
Para normalizar uma fração e outra fração;
\CAL
To normalize a_ fraction and another fraction:
Get a_ lcm given the fraction's denominator and the other fraction's denominator.
Multiply the fraction's numerator by the lcm divided by the fraction's denominator.
Put the lcm into the fraction's denominator.
Multiply the other fraction's numerator by the lcm divided by the other fraction's denominator.
Put the lcm into the other fraction's denominator.

\PAL
Para normalizar uma direção;
\CAL
To normalize a_ heading:
Divide the heading by 3840 giving a_ quotient and a_ remainder.
Put the remainder into the heading.
If the heading is less than 0, add 3840 to the heading.

\PAL
Para normalizar uma reta (horizontal);
\CAL
To normalize a_ horizontal line:
If the line's end is less than the line's start, swap the line's end with the line's start.

\PAL
Para normalizar uma matiz;
\CAL
To normalize a_ hue:
Divide the hue by 3600 giving a_ quotient and a_ remainder.
Put the remainder into the hue.
If the hue is less than 0, add 3600 to the hue.

\PAL
Para normalizar uma imagem;
\CAL
To normalize a_ picture:
If the picture is nil, exit.
Normalize the picture's box.
Normalize the picture's uncropped box.

\PAL
Para normalizar uma seleção;
\CAL
To normalize a_ selection:
If the selection's anchor row# is less than the selection's caret row#, exit.
If the selection's anchor row# is greater than the selection's caret row#, swap the selection's anchor with the selection's caret; exit.
If the selection's anchor column# is greater than the selection's caret column#, swap the selection's anchor column# with the selection's caret column#.

\PAL
Para normalizar um texto;
\CAL
To normalize a_ text:
If the text is nil, exit.
Normalize the text's box.

\PAL
Para normalizar uma reta (vertical);
\CAL
To normalize a_ vertical line:
If the line's end is less than the line's start, swap the line's end with the line's start.

The not byte is a_ byte equal to 172.

The null byte is a_ byte equal to 0.

The null hbrush is an hbrush.

The null hfont is an hfont.

The null hpen is an hpen.

To null terminate a_ string:
Put the string's length into a_ saved length.
Reassign the string's first given the saved length plus 1.
Put the string's first plus the saved length minus 1 into the string's last.
Put the string's last plus 1 into a_ byte pointer.
Put the null byte into the byte pointer's target.

To null terminate a_ wide string:
Put the wide string's length into a_ saved length.
Reassign the wide string's first given the saved length plus 2.
Put the wide string's first plus the saved length minus 1 into the wide string's last.

a_ number has
a_ first byte,
a_ second byte,
a_ third byte,
a_ fourth byte,
a_ low wyrd at the first byte,
a_ high wyrd at the third byte.

a_ number pointer is a_ pointer to a_ number.

The number-sign byte is a_ byte equal to 35.

The numlock key is a_ key equal to 144.

The numpad-astrisk key is a_ key equal to 106.

The numpad-cross key is a_ key equal to 107.

The numpad-dash key is a_ key equal to 109.

The numpad-eight key is a_ key equal to 104.

The numpad-five key is a_ key equal to 101.

The numpad-four key is a_ key equal to 100.

The numpad-nine key is a_ key equal to 105.

The numpad-one key is a_ key equal to 97.

The numpad-period key is a_ key equal to 110.

The numpad-seven key is a_ key equal to 103.

The numpad-six key is a_ key equal to 102.

The numpad-slash key is a_ key equal to 111.

The numpad-three key is a_ key equal to 99.

The numpad-two key is a_ key equal to 98.

The numpad-zero key is a_ key equal to 96.

The o-key is a_ key equal to 79.

An offset is a_ number.

The one byte is a_ byte equal to 49.

The one key is a_ key equal to 49.

The one-half byte is a_ byte equal to 189.

The one-quarter byte is a_ byte equal to 188.

\PAL
Para abrir um arquivo dada uma rota;
\CAL
To open a_ file given a_ path:
Clear o erro de e/s.
Extract a_ directory from the path.
If the directory is not in the file system, put "Directory '" then the directory then "' doesn't exist." into o erro de e/s; exit.
Set the path to read-write mode.
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "CreateFileA" with the path's first and -1073741824 [generic_read+generic_write] and 0 and 0 and 4 [open_always] 
And -2147483520 [file_flag_write_through or file_attribute_normal] and 0 returning the file.
If the file is -1 [invalid_handle_value], put "Error abriendo archivo '" then the path then "'." into o erro de e/s; exit.

To open a_ file given a_ path and some milliseconds:
Start a_ timer.
Loop.
Open the file given the path.
If o erro de e/s is blank, exit.
If the timer's ticks are greater than the milliseconds, exit.
Repeat.

An operation is a_ string.

The orange color is a_ color.

The orange pen is a_ pen.

An origin is a_ spot.

The osmosian font resource is a_ font resource.

The osmosian font source is a_ hex string equal to $00010000000B0080000300304F532F32BB41B2760000013800000056636D6170E2B9EDE9000005440000032867617370FFFF000300008BDC00000008676C79664268E45D00000A4800007A6868656164E4394351000000BC00000036686865610D54057A000000F400000024686D747868C6405100000190000003B46C6F6361A327C3220000086C000001DC6D6178700559021500000118000000206E616D659DA64946000084B0000004FA706F73745544E6B3000089AC00000230000100000001000091EDF0B35F0F3CF5000B080000000000BF91DAB800000000C0031E39FFBAFE4805CC071A00000009000100000000000000010000073EFE4E0043063D0005000105CC0001000000000000000000000000000000ED0001000000ED00DF00070104000400020010002F00420000040C000000020001000102FB019000050008059A05330000011B059A0533000003D100660212000002000000000000000000A00002AF500078FB0000000000000000484C20200040002025CA05D3FE510133073E01B26000019FDFF70000000003E8007F00C8000000C8000001900000025800CE02BC007804B0002F03B6004603E8005D04B00050019000780284006402840064046D0022046700400190005703E80064019000640320006B03E8003603E8006B03E8003503E8003203E8002803E8003C03E8006403E8006C03E8007203E8005A01D400640190005604B0002E04B0005704A9002104B000C804B00064043F002803E8003B0460003C03AC00050460000E03C000640467002104740011039E0006039F000D03D4004B03CD004A047B0022044C003504B0005603E80064051400490403004203B600350453000D038C0036037700280535001403DB001B03690028041D00210258004903200022025800490384004204A9004A0258004303E8002F03EF005A0320002803D400280363002F0334002103E1004303A5005001980064021C000D033B00190161005405350064038A0050049500430341002803D7004302AF0038033B002102A1001E0377003603200014041700360348001B031300140409001B02580042019000490258004E03E8005D043F0028043F0028046000360460000E044C003504B00056038C003603E8002203E8003203E8002F03E8002F03E8002F03E8002F03200028036300220363002F0363002F0363002F0190FFBA0190FFD90190FFD90190FFBE038A0020049500360495004304950043049500430495004303770036037700360377003603770036034F0042025800490320007E046D00210438007802580063049C0078041D008505CB005D0517004904F3006A02AE006B02E4005E04EC0043051400560495005E0564005D048F006404590042048F0042042B003603AC006403B3006B048F005004B0006403E800720319008B0320006A051E001A046C007E04B0005004B000C80190007104600042044C007203E8006404B0005604B0005104B0007804B0006B02FF0042043F0036043F003D04B00056051A0067042B002F04670056063D008C0320005D02C3000701ED007802010078046700500453006B031300140369002804B0005D0438005602BC006402BC006403E5007F0190002F01F400560320005D053C0069043F00280460000E043F00280460000E0460000E039E002F039E001A039E0006039E002E04B0005604B0005D04B0005D038C0036038C0036038C0036019000780320005703E8006502BC007801F4004902C3004903B60035033B0021041D00210409001B025800DC0453004A041D0064036900280313001403A50050038B005704380057039F005002580071032000A0032000AE04B0006A0507006B0578007F03E8007904B0004A000000020001000000000014000300010000011A0000010600000100000000000000010200000002000000000000000000000000000000010000030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F60610062636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A009B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AA03ABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBD0000BEBFC0C1C2C3C4C5C6C7C8C9CACBCCCD00CECFD0D1D2D3D4000000D5D60000D70004020E00000048004000050008007E00FF0131015301610178017E019202C702DA02DC037E2014201A201E202220262030203A204420AC2122212622022206220F22122215221A221E222B22482260226525CAFFFF0000002000A00131015201600178017D019202C602DA02DC037E20132018201C2020202620302039204420AC2122212622022206220F221122152219221E222B22482260226425CAFFFFFFE30000FFA1FF5CFF78FF41FF5DFF130000FDFBFDF8FCA0E09D000000000000E084E092E083E076E00FDF6ADF78DE96DEA1DE8B0000DEA50000DE74DE70DE5EDE2FDE30DAED00010000004600000000000000000000000000F8000000000000000000F200F600FA000000000000000000000000000000000000000000EA000000EA0000000000000000000000000000000300A20084008500EB009600DC0086008E008B009C00A800A30010008A00EC0083009300E600E7008D0097008800BF00D600E5009D00A900E900E800EA00A100AB00C500C300AC006200630090006400C7006500C400C600CB00C800C900CA00DD006600CE00CC00CD00AD006700E4009100D100CF00D0006800DF00E10089006A0069006B006D006C006E009F006F0071007000720073007500740076007700DE0078007A0079007B007D007C00B600A0007F007E0080008100E000E200B800D300D700B400B500C000B200B300C1008200BE0087009900E300BF00A40000004E004E004E004E007E00AC011A01A0021C028202A202E0031C037803AE03D203F2040E043A04B404EA054805A8060C068E06FA073807C60844087608AE08E80928096209C00A5C0ADC0B600BBE0C380CAC0CFC0D8E0DFE0E380E7C0ED60F1A0F9C0FFE113011941232134E13B013EC1446149E152C159815DA162C165A168616B416E8170617241794180E186A18D0194619A41A461AB21AE41B281B8C1BB41C2E1C741CE41D401DB21DEA1E3E1E881ECE1F201F8C1FD8201E207820CC20EC213E217821842190219C21A821B421C021CC21D821E421F021FC220822142220222C223822442250225C226822762282228E229A22A622B222BE22CA22D622E222EE22FA233A237023B6244824D024F0255425C2265C26DC273C275C278627E2284428EA295E29B029FA2A442A9A2AE22B362B8A2BC82C102C502C942CFA2D782DF82E562E842EA82EF22F5C2FC43010306430B830E430F030FC3108318631FA32123228327032B832DC32FE3336339833A433B033F63456348234AE34FA3518353A3582362A36363642364E365A36663672367E368A369636A236AE36BA36C636D236DE3702372A3762379637C037EA37F63802380E381A384A38B439343940394C399A39F63A1C3A643A943AD23B183B943C103CA83D163D340002007F0000036B0560001E003400001333173317053332151114071507111615062B01262722273534271127113617111711161D011617143B01113735363D0127232527BF2C2C3420011C24C00C0810193BE02AE67C140C080878080C1EF21C98080C2828FEC420056008080454FEE0AD93202CFE3C15175C0B0544CCAD9301142C01804088FED42CFEE093AD8C08040801D82C1493ADF0040408000200CEFF8F017105FB0011001C000001161511071517150623263D01273537113613161D01062322273437340131401008083840081008294008383B191405FB0732FE367DA172E5390732E5728F7D01DC39FA74083860405C10284C00000000020078030602300582000D001B000013321714071106232635112734370532170711062326351126353437D03F09140838400C44012C3F090C08384014440582601A16FE5440083801B4302F25046030FE704008380198161A2F250002002FFFFA048F04BA0047005000000116150714172127353633161D01173325321714230723151F013215062B0122271517150623223522272623161D010623263D013427232635363B01352635232635363B01263534131733321735262735014F40041C0104040838400424010C270D74CC1C20BA580838201C86200838440818714F2008384028E8400838C830D8400838B418BC38103C800C0C04BA0D27407B6D309440083894301440441010DC0F40400314AF204064E31CE32960400838604BCD083840048622083840767A6CFE24B418047F2D1C00000000030046FFE60346056000470052005C000001161D01071536331615142706071536333437161D01140706072207060F01161706072637222707060F012635343F0136352627060F022227353635363736333736373536333403363734333735060706150517333732373237220701E2400840287589272D537D1C40240C140E161622501403165938280903444162184093801C0C241D6073183B19182C2847192040280A1AF488380C041C406401402404480B0906122D5705600838202C38282338390C2408D0240701083840153B0F3D3C184070958A3F0828964C341C1804083839175C0A067A962F4233045C60502C5A3258143F05847409FD1456490804B01D23713328B07C30241C0005005D002E03A1056200190028003100450053000001161507060703072207150623263D01363F011237323736353605321F0115062326272635343734370716333637352306070133321716171514070623222F01353633263534171514071715071517343735262702CD402C693F5C4807090838400A263C4454061A5C17FE956A1E08414F5448382C6814201C15132C150F01CC20315F310334153BA8180C0B0908840C0408242C053305620838A4A4ECFEB0B84434400838404D57A0011CE844945044DC4C2C40D808382C4441234434DC28213F28063EFE6C40352B202557604C2C4044153F3E76081D0704102C24081848100C1C000300500006044005C2002E0035004400000133321F0115061507161F01333637363316151407060F01161506232235272307140723222F013637363F010335361715173337352603140F011514173332373637262F010138203A8A2420382C2C4404DE4E2A2240403BBD50280838401404B848209F350440486117146C088C2804081A0E7C4C38341781252744301005C2885C806D437462B29CB1532C083829274696406E5A405C5C680C0C704CCE7AA8402002182040B404C8286440FD900EDAC814110B500E227BA1440001007803260114057A0012000013331615140715140F012635363D0127363334C0045010301C400C0C0E16057A0E3A1715F0E9030408383369E4305809000000010064FFB0022005BC00260000011615140702150706151114171617161D0106232227262F01263511343736373637323736373601E04034A044243C23157C0838283854204814401B192636072133192105BC08382B19FEEF0F88761EFEEC885C501C83210440544B5594822E0100659F213B595B44501418000000010064FFB0022005BC00260000172635343712353736351134272627263D0136333217161F011615111407060706072207060706A44034A044243C23157C0838283854204814401B19263607213319215008382B1901110F88761E0114885C501C83210440544B5594822EFF0064A0213B595B4450141800010022009A042204D6003D0000011615140706071537363316151407060F0101170623222F0123061507062326353637363523220F01140726353437363F01352627353633321F0136373602E64018101CC02014403851536401480408382B45D80448201B1D40201C20040B8DEC284098AA4A64D60A08382C3C8024141C04D608380F316860048C1408382E16453348FE80184064F8C15F941C0A32CE7A4A0E60540B05083843213E423004F61610405C90857760000000010040FFC0042004200020000001062B0107131714072235030607232635363B01363F01260336333217133733160420083874D44C044044488A72A04008389465830C28380838430D48E0804002504030FE5440270D740188141C08384018140892010E4080FEBC34080000010057FEB9010F00BD0015000037161532171506071423263D013637353427263D013697680B050C1840401C08281008BD0C3028C04A4A4C08382058346C0719151720400000000001006401C2038402AA00110000011615140714050607232635363B0136253403444064FEE0C7554040083834A3018102AA0838371D081C1C1408384024280C000100640000012C0124000E0000133217161706231407263D01343736C43A0A160E0C3428601C0E01244C1751600B05093F2061174400000001006BFFB002EF05C80017000000171507020F01020706071423222734371312373413363302E7085090045C60440D0B48380824645048CC233505C84008ACFECC38F4FEB6965F097C401C9C011801169E4401B060000000030036000003AE0584002A002E00560000013316150623153332171615321D0107151407140706230723222726272627263D01343736373437343736171533350115141714171617163B0136353635363D0137352627262B01062326353437352306071407060F0101BE2040091B8C507858080C2844745080207C3C17612C182828174D58641B5508FEC02C581C34151334A474240C081C543C6415174040102838401731380584083838046868581C60F030518B3672A41C44065E406C3D7FE06266736D13650943287C0404FDE8E05C5C41530B2D0C1C18874D812744F054472D5C10083830180424200947324AC40000000001006BFFBD038705A500230000011615113633321714230415060723263534373633110623062B01263534333F02353601C740E8602D0B5CFE246E2E0840CC222E7D0B1E1620405C5854140805A50838FB282040402E12181808384D1F1403C47C1408384458883020400000010035FFD703C7055B003F0000001716171615140706072207060733361733321F0132170623222734272324071407232227343736373637363D0134272607060706070623263534373637363702A92F30101F6B1F6611D8391704D7EA0F612C490A05083520344122FEF3ED351F351B3219ADBE1FB32A95A428371D1815193D41622B8B7C054435314F905495A33672F0271D4828203C284030110328641A0A5848282597D709DE7E1472866B8B17351C40140838334D620A56120001003200000396057300420000013332171615140714070607061532171617161D0114070607060723220726353437363B01363F0135342726272627263534373637363723072126352227363B01172102B2402B15205058167A2C3197973D0C30315340BC5421AB407C4B5934D63630443AB248A824EC77351622048CFEA07409030838202C01680573321426264508602F5D16074F63AA4B35226934453321292E083A440F1D2943424F863C60351E0B19264D4C515D0B2F110B1A25430900010028000003D7054000450000013217071506151F0136373633161514070607151615333617363316151407061706070623222735342726270706232227263511363334371615071117253526353437353433020C2B150414040CAC67271940A02DBA340403082D1740342A0B141019472D0B24060AE42E2631271C0C202440100401140C143C05403050404F91D00448311C08384523254C04E4501A132008382B191D1A0E4E204050B2A62808603C24685C0200B409030A3270FDD428740459B383613480000001003C000003C00570005C000001321714230607060714231407150715141715333637363736373637333217161D0106070607060714072635343736373637363D013427232207220F011407140723170623222735263D013437351233343716150607323F0136373633036C270D74F64E804C30240C140410242A366E3246664C51333C0553AA06127E3C4078241CCF010C3C383860158738283C080808385A12140C1F1940401C101351780E46FC5805704044442C4341080B09104C94445C58703056327D174C14588A4278477DB71D1E92210B083824882739DF2D0E1A683D6B609C68315727092440FC346B41803933140144320A083856663C400C1C5C000000000200640000037B0573002C0047000001161514070607060722073237363F01321F01150706070607060714072227222726352227353437123F013637032315141F02331733363736373637323F013527060706150706019040400B29301806060F8C10DC5458241C03371D124E3B3DCC0C244C543C0A0624343C501F11880C1C20309030042A1A3C1C141812010C142E169CDB140573083A1089264A84AE2E7F395A154F74844BD42977585F150C111967764580216587014275B63901FC9B4F457543210C1634318E17697529644A0A133722BD2900000001006C00010384054000260000013217161514030607060F0206232635363F023437363F0123260F022635343736373237032C301414A82E0654594D27181C40131449615C17454008AA667A9E40AA6B4B0FE505403C161A18FEC88B01CDB0A4BE180838923898C912C65E7A7C0B1B30AE083842A031130800000000020072000003620574004E0062000001161514071407060714070615060F0115161F01333437343F0134371615140706070607161714171615140706070607140727232227222F013437363736352627263D01343736373437363736333413140706071516331716173336373637352726270232405C48142C2C14372104239128084858703C406867052F1D495B340838064A132D3C2C405F351A3E14383F414012BE681C173D38422E2D3F2084461A130D10012B7020243C24300850057408383D0B0B051010071D0F112D4704142C2C1C1173228288210B08383068893F32522B811858223664641E622622210B08288868684C78484B152143561A0C611734481D1B390B2007FD45179D7840186C200C0C0D433E864460234D0002005AFFB9039E0592003C0054000001321F0232171617151407150607060706070607220F022635363B0137343F01363736370607060F01232635263D0134373536373637363F013E01011507151633141733363736372627222F0126070607220702AE392F241810100A221C1C0C0B0D3D232880132D7440400838246C3478242420185868297738209C540C1C262D27497F403240FE700C312728046969646E03190F191222485086134F0592686060CA212F10142C68515F0C80C3102F5D1C2404083840240C0C641EA1D9375D6B293F0C32224D6B0C393334B34B433B2D6324241AFD82304C40580C0818684C7E89737C2C2C212F66A40000000200640014017003D0000E001E000001321732171506070623263534373603161D01140722070623263D0136373601041C2C1B091E422014403C15015C380923310F400D272B03D028382064281408386B6510FD94193B403D3730180838206349440000020056FEB9011E034000150024000037161532171506071423263D013637353427263D0136133217161706231407263D0134373697680B050C1840401C08281008573A0A160E0C3428601C0EBD0C3028C04A4A4C08382058346C07191517204002834C1751600B05093F20611744000001002EFFF9043E043900220000052227262726272627263534253637363736331615140506051516173217161716150603BA39637D878CDC2838240180CE626A622E2640FEC48CFEA477CD0894596740080754497354C8100418246349343033453C0838539D404C047E8A78354B08384000000002005700DC0437030C00120028000001331615062B010607220F012635343F01253613331615062B0107230723062326353433373336373603B74040083854FEA290805C40689C0138E12F4040083840E0548C748844405CA49448D44F030C083840301020100838410B181C30FE940838401410200838402010041000000000010021000004310440002200001332171617161716171615140506070607062326353425362535262722272627263536A539637D878CDC283824FE80CE626A622E2640013C8C015C77CD089459674008044054497354C8100418246349343033453C0838539D404C047E8A78354B0838400000000200C8FF4F040005A90033003F00000132173217161D0106070607060715141F01142B0126353734272635343F013637363D013427232207061506232635343736253603321716150623270722273603205E16124A100D634E4AB41034083C084004241854583A6A7C4414DE36D8181C403C2E0126509B5B1D10083818202F190B05A924A05739206F5D612F6A02042E9E38800D274C265A534534343012627A3E147C582C451F1808382B2D21630CFA7D3E1D215B06067D5A0000000100640000046804B80071000001331732171615161D011407060723222F0107232627263536333633321F010623263D01232215141F013237353633161D01363F01353427262726272623342F0123220706070615061D0116171633163B013637363F01161514070623062B0122272627263D0134373637363736373637340270603C50484C3C5030540434400430206C384C182434745A2A08083840145C443C13210838404315042C130507111A12580854922A31434814477962322236705E3A38342440783F15721A809E5A5B69703806220933204C1E4A04B8145480406888208E3E461A400C0C163652967C38385C4008381440722610241C40083878382C2C346B49372D012738090F085026A67E3A432180873140083A121242080838364A20483C2B518B45646D9B015704783B5920240F0000020028FFCE03FC05E5004B005800000116151406153217141F01163B01371615140F011417161716171617321506232227262F012227263523060714070623220706072207062326353437343F0122273437363713363F013437360B0106072207333F0127342735020C402C0D23444C1206108040603048083020041206080838410B13090C1B4928080D539838482222320614081824402430200B053420086C13191838281C6814080701108C8C504805E50A4337501B651287BB2C220A434B0B0F14B120365F27035D224D7D234721CF501E0D190C2E22C07B3B642C0D3B5441197C86303220785B012E44304817AC1DFE69FED63960183039C11683180002003BFF8803B505C80053005F000013161D0137330417321715060714071533321F011615171514070615070615070623263534373635363F01363F013526232627262B0107232227151715161D01161D010623263D01263D012735273527113735361311171532373437363526238340042C0145096810097F342C7183543C08985C3C3C101B1D404C2C1E0E68223A0C052F2735493B908A1817150814100838401014080808087008AC564C28081805C808384C041206BC0446960F2504483C4B2D5064328A5014542A2A381C0A32546011231E1E64283018447C29131C08105060BC4F2D381517304008381C1517448CAC60F82C01802C3440FEFCFEF82C145409573A16300001003C0000041D055F003E0000013316151427062B0106070607220706071407061513171615141F01371732373316151407252435222726272635270334373437363736373237363334373402D018618120340813393F01154F2341203C06042084849EEC0E4F084095FEF8FEFE1468590F50080630402C4C14480F21443C84055F31404E280E100B3B0A45085D0B1E8859FEF7450F1F1D3E3C04042E0A404F2805091C373514722A4E011C58841962473A073D2A40120E080000000200050000038D05C000330052000013161D013320151617161F01161715071406071407140706070607062723170623263537352627361726272227353F01273F0136171507151407151716171637363736353637363726363526232627222726239D4070010457212157241F09142B4830341C79582C5B29080808385408571D1058230D070110143F142116741410180B0D5B677116441D1F3523050C131926520F291DCF05C00838381C14200761304050189C858454112B0A2A30633A1709022440153B2C040E42490A95CC3CE0A0952A4B1575F804602C6B35E4FC318B302B6A16540C13352C5893751D6C43251418000001000E000004160520005300000116151407232723072315071105333217062B012227230723150715161F01363B01173215062B01222723222723220F012327072322272627353723220F0126353437363711372326353437363717363B01173303564058D82CA4381414017C843A0E0838406E56D02C0808102008AF41ACCC48083830171508273DA437B9140C04041052161C100804093F1C4060440408104054174534232DAC2CAC052008383B11080C1850FEF004504010080C2C30FD57446C204040101074040404CC5AF64C20400408382E460F0D0108480838491B0804040C08000000000100640000039C06060035000013161D013305331617331615062B01262723252311140717153637363734371615140F010514071517150623263D0127352735371334B8404001082C286C5C400838646D3320FEF83C09013672A26C58407884FEFE500808384008081004060608383E200C08083840080C20FEC2275D643C150F24100D0B0838420E202C100440C0E6400838DEC0FC603454020C2D0000000001002100000421058C0065000001161514071407060706070607060F0115140706071516171617333217333637363F0235263D0123060F012635343736373637343716151407060F011F011106071407060706071407232623222726272627263D0136373237323F01363734373633343736025D405C2C012738283C241D13102814104438354704325A281963380C241C4C048B2D2440B4313F0F755440301769085C0C0818301B6D4020287845173A1A2E623F510814280E0E0D0F3C431D48391F343B058C0838351F0A0E090F3F153153167E1418193F2B4D906775411B181B252B2D3C68F0462A0C47450808384765200C1923250F08382B152A1A086834FEF84C20244053450D270B0518180A6A7B81112F94605C5464706F050632440913280000010011FFAC04640581004B0000131615061506151117253526031136331615111217153733161514071516173217150623263D01032627052315171516070617062322272637273527220F0126353437363327113437363736E74006040801FF100C0838400C10780840B8180C0808083840240B05FE1904120D10070308383A060414090E302C18403430340C04020C1B05800A32354B5544FEE068421041010B0100400838FF00FEF333082C083848240C8FE19C204008382001B0173D3E04D734854A283540443E6D7134CB240408382B19208401206D4C364A1C000000000100060000036605A40027000001331615062B012215161D011311331615062321263536332111342735262307232635363B0137330246C0400838D434181CF4400838FD40400838014C1C10148CA0400838A0A03405A40838400C534514FEF4FD2008384008384002E032CE34800C0838400C0001000D000003450580002C0000013217321F011617110223220706150607062B012635263D013633321716173336373437343F01352627352736024E453F09032122243E120E0E5C2470883020C04408383E062C64102FAD602830382F500805809524558290FF00FEEC28622A2E2A4036223B2920405432160C5024682020C8E4F75C108940000001004B000203BC0600003B000013161517160722171536133F011615140F02161716171615062322272627262715161D01161732071516071407223F01262F0135363511273727368B400D010409121BFB94404044C8A097CD96224408381E4AC3246DEC081306070B122140440D06030210020A040D080600083846394969FF09010E881408383117BCA020D6C61933254044DF288A3804153F146CD6426A3A312D0B907181B35034B61F010BDB103A4000000001004A000003BE0574002B00001316151407150715031217161715373337363736371615142706230607230623222734270313353735343736B6401810040C1C0F091458BE3B65147C5AAA34604ED01C1A2A4038281804102014057408381C18686C04FE40FEED4D173908041E120E0C2429384207201B1734942B75013401C0106C34601C200000010022000004440554005B00000132171617321732173337363336373437363B011615161D0114071112173217150623263D01262F0111373522072207060F01060F01150715062322352627032723140715070615220F01150623263D0112373637363D0137343734011C353B21130B210729044016120543903018185C0C141C04060A083840140C1014093B1331291F18240C080C08384410446810041C2034060C040838401C1E10140C1C1C05546423D17C8CC464165226722418400E1A1C2167FEB0FED28E844C40083844B6D6B4016C68183C601A6A506C4408087874407450B0014088204C3CC08973F610344008384801568817850E1A58681E563800000000010035FFA303F3059E0040000013161D01161F01141716171617161735131134273536333217321711140711161706272227262726273427222726272635231507111311062326351103113711368140265290840818323E114B1C1C08382E160C0C1C271333453416173719495C151B16DE3C040C04083840040C080540083858056390156B0127295B2044640120016E10300C403848FE8646C6FEE28D7045439C106825700B753005EB32124830FEBCFEFFFE984008380158012501403001304000000100560000045A057800DE000001173733173733161F0116173217161D0107171507171507171514030607060706070607062322272227262726353327353727353727353727353727353727353727353727353727353727353727353727353437363B011615140F01171506231715071715071715071715071715071715071715071715071715071715071617161516171617163736373637343712352735372735373427342726272623350723272207060722072207220723171507171507171507171507171507141715062322272635332735372735372735372735372735372735363734373637363702EE04041C040410364624290F151330040404040404101418104E15614C8C60501933395F25174C0404040404040404040404040404040404040C0404040404243C200440240404091B0404040C0404040404040404040404040404040418281C1C142014695F605D5F30201804040404341805271D2F041C041E76081C0612130D0E1204040404040404040404045008382E16480404040404040404040404041418400745299705780404040406322C38285038380C04041C04041C04040461FEE63F2540854334511B0D28AC5D0F9977041C04041C04041C04041C04041C04041C04041C04041C04041034041C04041C04040453194808381B290C041038041C04041034041C04041C04041C04041C04041C04041C04041C04041C04A52B26121F41232538062E455D970E36013B40041C04041C041A4E1D131933340404043C0553245C58041C04041C04041C04041C04041C04377D1040386B5D041C04041C04041C04041C04041C04041058303C48404C340C0000020064FFE60390060C003400440000011615140714071533363F01331615161715140F022207062317151423151617061707062322272637263D01372635113F02361323071136373637363735262B010607010040181404875D68847C1E0ED0906417891E16040C160C11111C08383014030E0D041014141C164A0C18911F0967D5371428508147060C0838142845170C1C241018181A4A485FB5685C94141C100824CA1E383846403C5D9A962134182D37019488649C70FE9090FE9496061D478E76381C0B2500010049FF7B049D05BF006E000001331615142306070607060F031517151417141F01163B0137323735273427263536333217321F0137363F01262F0123060714072635343F01363B01161716130706071407161716173217062326352627262722270623060723222726273427263D0127353736371237363F010259204064163A6A2A261E381C1008404060643824580A2A804018083829230B415C307A0614146034407A0638405080153F2050506814141C5C60810B290B210B0838583B1917110A265E1A372920EA721A4A20300820182458406B454005BF083844140C47555761989844242C34424A2147322640300488083C2117403C505C40C262B2A5350C450B1A0A083830384408083867FEFF7CA781107C863A261A3C40182837450E26306036027804741626496B142C40908F45011438770D1C000000010042FFC403EA056E00CF000013321733363315373317373332171617150717150717150717150717151407060706071407011617161506232227012227343732373637363537273537342F01062335062307171507171507171507171507171507171507171507171507172317150717150717150717150717150717150717150717150717150716152317150717150717150623263D013727353727353727332735372735372735372735372735372735372635332735372735372733273537273537273537273537273537273537273537273537273537273536338E231D0442325C0C040404986C453704040404040404042C53675B1B180190522E1408382F81FE88301C680E26903820040404F8103B316C1C04040404040404040404040404040404040C040404040410040404040404040C04040404041804040404040408384004040404041804040404040C040404040404041004040404040C04040404040404040404040404040404040404040D33056E291404110404362C541D04041D04051C05041D0404101E318E3B460B0C19FEA45413171B4280014367306E2E3383292104041D0455270511041914041D04051D04041D04041D04041D04041D04051D04041D046F051D04041D045F0C04051C05041D04041D043A0C04051C05041D048832041D04041D04041177096E0D04041D04041D04BA041D04041D043A0D04041D04041D04041D043D33041D04041D0470041D04041D04051C05041D04041D04041D04041D04051C05041D0404108D0000000100350000037D056C004000000116150627060F010623060715171417161F011617161D01140706070623072225273633321F01363F01363D012627252726232627263D013637363732373237360243B11AB66F1547202B400C5942228BFC302C1B353A1E7F4D1F75FEFF09093D1FE5425A30351F1E67FEE1051A2D3340580D2423470F2F30356F056C5F389EB51020243C45533C3C0D0B1A22481A361C58402567394F9404BD20409508366E403F15602B115404141B35215740613343353C3428000001000DFFA3041705440026000001330415161506232523150711140716151706232227352637113706072207062326353437343702A7380120180A32FEFC1814030710083840100E0A14F16D1B352E16406CF20544220A181C40200478FDB471A2774F40407008ABF602A05C140A2820083832360E1C0000010036FFF20350055D0039000001161D010717150717031607060F0106070607232627262F023327113633161D01071307141716171617363F013637323727132735372735360310400404040406021B063A2C3814202040D44F2C4C200804040838400404043C214302B94711241D0A1107041004040408055D08380C04041C0404FD63F016414F5D2D0A0C20437C1DDB6C640402504008380C04FDC4043EB2634D154A0C30441073940402CC041C04041040000100280000033C04D8003A000001161514070607060F0214070607060F01062322272227353727332735372627262F02363332173217161F021533343F01133637363F013602FC404C241C0B0D24281C18280E0E18161A390F0903040804040410281D4F4C200838380C060E505040080824283C0F091311581604D808381779698F174D986C0E3A5E52145C2C1454240C0448041C04A2568898E49C40486CF5ABE02414204C6C010C2355264E941400010014FFF704F80573005800000116170F02030603070E01072627262726272627230306070607060726272627262726272627263726272627373617160F0116171607161716170617161F02363F033617160716071617161F023312371337363704D81D0314080C2A08541E0728384404111F3E0C0A17043A053B292F19353E0E0C183A112C241A1E3B04180C0B01060E383F0604090D20053710022F024C0229190456053216150E383D022003130D161F1C3D0447082A11082805711C3854542BFE4E5BFEB66E3B310307633A89C7510973FEED3A9586273918073D0B7D63554D8319918D311B650128403F050E38340E542E359050136218AC24444301E52CF08BDF3F05065455231F6021857BCB01125801BE5F6E440000000001001BFFF9039B05C9004700000116151407060F01171617161716171615142B0122272227262F01262726270607060706070306070623263534373637363736373526272635363332171617321733343736373633032F405467351430110B3533132148441830240D13212310271517154B1D2030162E5C0F19181C404048283937313F0B49500838331507310D33044C4F3D1D2705C908382C74F52F2844091B256F113F05375C4C3C284418192B14245F411490465EFF00093F1808381B75E044BF3D5D47041B458F154044025E400C6CC3514C000000010028FF81034405A4002700000116151407060F01060706070607060714072635263F013E01272627263D013633321716171237360304405C2C284C2A1A17191A16260140400E452C2E1A1381707C0A327076415F9C321B05A408381E8A5577D47D5F4197455F38CF320A0838C483A87FB726E688123A044074959D01B14B4400000000010021FFD103FC0547003400000132171615140714070306072207061507153605171615140726250722353437343736373437363F0123040722072635343732372403111B21103C20B92C23076560046101928C543873FE68D85C3070552F6E523C1004FEB0941F4D40781B5D018E05473C15171C501A42FEEA7544D87D530404281C2136382E1657042C4412823DAFB070129E6390381B34140838430D203B00000000010049FF1002290648001D000013211615062B011517110711331615062321223D01343711371127353437C90100400838D8080CFC400838FF00A0240C084406480838402C2CFD40A0FD800838403C0C1A2E0270A002B42C602F2500010022FFB002A605C8001700001332171215161B0116150623223526272603272603273536623523CC485064240838480B0D44605C0490500805C860FE50449EFEEAFEE89C1C407C095F96014AF4380134AC084000000000010049FF1002290648001D000005212635363B013527113711232635363321321D0114071107111715140701A9FF00400838D8080CFC4008380100A0240C0844F00838402C2C02C0A002800838403C0C192FFD90A0FD4C2C602E260001004203CD02FE0585001F00000132173217163316150623263526272306070607062326353437363736373637021E37150917382418083854263E04446C3375141440400785584419530585545884181C40191B1AA2404C16560C08383018124A3C40342400000001004A0000044A00A8001000002516151407230507232635363B01372533040A4080F0FE70A02040083820A00190E4A80838430D0C0C0838400C0C000100430460023305DC001000001332171617163332170623222F01263536831D5323813315401408382850A4940805DC481060285C403C785137400002002FFFD0039303E80039004B0000013304151617161D01161506231707170623222F01352207060F012326272627353637363736213334273427232207060714072635343736333603151633141733363F01352723200706070601A76001002C2C1C14060E0C04100838410B080A628B3D5080315F23191B3D7D4B3B013D1C40A8681E4E260E40402C4242269A1B1D2498257BB80430FEDD254E5A1F03E82D3F33A9B53388161A2C68045840683818403F2D0403492454209040891F4432861A1E180D27270D0A324A1A4818FCC804400C08243070B4283C26762E0000000001005AFFAA03BC05FE0051000013161714071506171617363F0136373637363F013316171617161D01140706070607060F01060F0223263534333637363736373237363D01262F0123060F010615060F02060722272627033537362726AC401426160803260B1844262E41431C3C14604D3B1D0B0C200A0A091B164A5C4D833C18204058C04040241612090B20101C203C283428742E1A10431439391A0C1A010C150A0205FE08671CC5FCB2375AB12854DC2D574E1E0A2604104C1448154B40662E13390460167A8C585C2004083844728E53450B5940352F745410141C141CA533A11740824C0F5193800185AC9C12AD4D0000010028000002E80448003D0000011615062B0107060706070607060F0115161716171617141733363536371615140706230607232227262326272635223D0136373637343736373637323702A8400838344434406513123A211F101408141018143824783F3540501E2E295B402C581D07101C340C172133454042322957104804480838401C2B196E0A27494C24605457050C24082C0C1013313705083834184C181040300735294B5C40AB096359182C541C0C401C0000020028FF9C03C80610002D0041000001160703141715173734371615062314071F01140722352627230607062B01223527363736373637363F01171336011F01333237363727352F01372706070615070602EE5C52180408603C40142C94280440441408043ABA3B1920C4280D1F30300F314E42726A212EFDF9184020089E4268040804040CAC2080402306104F45FDE874A4887C2427090838600533C4242D0B641B651DA32C6C99AFE34458172948303B0B01BB98FAAC702A7D3245043080A07C571137711764CE00000001002FFFCB032B040B0051000001333217141F011516151407060706071407060F012635343734373637363734273427232207220706070615111417163B0136373637363736331615140706072207062B012227262711343736353637363701B780354B30044078063E555F58015710406C6008554348282C58243C132536222438254F0C1B5528403309272940454F300F752E1A20B636380858582523194F040B7C1476180C08383F15091733150C0C090F0408383810110B0B10202527315A24485027834A1AFEE23D2F100F2613311249400838256046283D24505050015029C36C1430103319000000010021FF6A031305D1003E0000013332171615062322272227230615061507173336333615060F01220715061D011607160306232637362736273537060F012635343727363F013637323736021B2461175C08381D2F0A12405450100E04644B8C0845532E710C0E0106041D6038250B0905060442421840E40E14081C23350B393B05D11C2D33402C102D075C80509216213F40140E1604251F2C71A475FEF168367993A88C8B243017310408384B49B6625A4C3F45242400000000030043FE5503CB04390046005800710000013217161507161506070E01070E013315370516171417161D011407060706070623222723222F013534373437363335263D013637352227262F013437363732373335262735360115163B01363736353635342F01070607060315161733321F01333237363F0135262325272306072207140246216B180C440C4834503C50071C14010C3933402C282F5124382A6A3E8E405983081C883014100714294F3F15047C6779147C04460A08FED862222C255F44443408C83D2B50233D2F1831933C040E2E7F35104F15FEF804044C3C2D4F04394C310F30364E53F13C29073A460404040830094F3C1C205F35412B19133C249424406117286C18041517202632044C273D4C3F895D1B240424201040FDF41C5C0C0C2507F01C0E0A0838212365FD59544907200428353F2834780404111F640A00010050FFB7035805C3004A00001316150F011507113237323F013637363736331615161D01161D0107151706070623263527323D013437353427353427230607060706070607060714070607150623223527263511123736C840240C080B090D371C2E22113FA421602C140C1B090B181C401B080C141404195B412C07150A16181050081C08384004100A220B05C30838909F3480FDCC3CC0448937342828142C4F79146B41A04C54DB021E180838CF1430393394445C203D47074019940143095B4C182484028348405CA1224A02800181327000000000020064FFDF010805B800140020000013161D0107111715170706232237263D012711363337223D01343B011615071714B0400C1410100838471B1414062E26443C0840040404000838204CFE944C74DB2E40C5663250500164BCBC740C800D274C4C270002000DFE7001BD0540000B002C000001321D01142B01263537273413161D01141F02151407140706232635343736373637363735342703222735360121443C08400404404014282060A0452B40343F4D12262A0E1C300907080540740C800D274C4C27FEAD0838203C48E4DCDC877530745008382B194731104C2A4EE04583011880204000000000010019FFBA031D05C70044000013161D010615111733363F013437323736333437161514070623060706072207321716171615161F01062322272227262F011514071407062F013637363D013711343735368540010404261E1C5809671D1F5440382C2C294B1C200D23165E4B0DA92B2108083840801E5B2B55611308104D3203141301010805C7083840EB7CFECC1C17311819475014141808382E16282A2A1C3434705C23D1263F1D2040FEAC1E6230543A8278643C023B43889236588C01407AF93440000000010054FFB6011005AD0015000013161707110615131417062322273703343711342736A2402E1814040808384616140414021505AD084560FEC03F3DFDBE38D440A0B002464242011067561000000000010064FF7B04E203D400530000013217321715363734373332173217321711161707263F011127342723061506072207151407142326352637112735232207060F0106070607160706232637352635262711363316151114173637323736373637025488180903386C28602A360B150C0C140A62631B0C182030990C04100F0C4C400410084C34540A1E181C1418101414083868281C080C0838400C140406420D1F4F3903D44C24302C100B05506048FDE46A503738594C022448251726360D37A4A011567E0838743501182CF094054B6C2C5C851767394014C028315793290140400838FECC1D0349337C063A5E0E00000000010050FF96033803F2002E000013161511373637363B013217141F01161314171407223534272627263523060706070615140715062326351103353690404C48443E1E203E2A3424202C084044400F1D3C046E3E182C3010083840080803F20838FEE88C6B3130781A82C42BFEA79D2B2D0B70EAF613C1862A4A961A8659372212F440083801B00100D040000200430000043704140025004A00000116150733161F011615161D0106071407062B01262F012627262726273534373637363736330115141714171E0117333637363F0135262726232723220F01263534373633272307220706026B600454753B4018141C28708A2A807867613E32172121034046724C0C5D3FFE94283C2856B664644C1420141804520E2C44085C3840482616084C6C2E86200414093F1C1E4E582A3E155B608C303D6358142E3E2C4C095F352F80228A644C270D40FE246813491C3C3C3A261D5F3C34547454286C144C0C0838380C300848882F00000000020028FE4D031F044A0027003A0000131615140F01153637363B011617161115060714070607062716071607262736372736351134373613111716373637363734232627230607060706D240280810717464144F552C2A3A4C2E777E6E061B1B4F5701100D3222381C2C04817C6937171D2C171D1C5728384C48044A083810603C04183A6C0F6D2EFEFE0CDA47105C2A524F22CE7478231948AED649396601B065C358FE60FE2C3022635A6A20A9F81E0E2B243625440000010043FE4E03D6043C004E00000116151407220F010607060F01151417163B0136373637363D0136373633161D01140714070615070617363F0116151407060F01232227263F0123060706232627262F01353437363F013637363334037340701E32B45048A03C08B40E1A1477316E1614121E291F40382018271B3517351C40182E375C0C39132C1B27041C802266A828412B1470293F9850A45C54043C0838410B285024304D8F701467250C245081872D1340761628083820119715633FB1E7D2A035440408380F313F350E907DEAC740402027211C585020CC64342C582C44440700010038FFC602A80426002100000116170627060F0206170615070623263537343734032734373215173637363736020C7E1E3478800C541C1911090D0838400D0524184048101B1D2490180426246A6B717444982858988D485B4008385B33BE310147E42D0B8C84184C5E7216000000010021FFB1030D042A003900000116151427060F010607163B01051617321715140714071407140706232227222736333217323736373437352723263522273534373637363336023B4D913B9D1C2E342F1984013C41130B055E58246C42421246320A08382A3A1E52364E46F0C07831135629977A4E27042A3638441E066E1876401804192B284026B11B3108241351282840402848522A0F981C040B1D6020229062524C14000001001EFFB00272057C00300000011615140711363B011615062B01220714171417061F010706232237222735263726272637062326353437363311363736012640106E4E20400838206256050F0312070D15384B2007010E020C04101367194038641C100418057C0838462AFEA41C0838402427A55D682F433D6E8AF41C300C902D871C644408382E16440198324A2400000000010036FF95033603DD002F000013161D010715161F0136133727353633321715071715141714171506232227222726352302232227263D01343F013536A640300CB828296F200408383F09041C281808382E1609171C0462526BB96428080803DD0838C0C0C4495F10510153604C60406060489850AFB1352F084038B47E62FEBC8C51778C467E28B4400000010014000002F803F00035000001161514071407060F01060722072317150623222726272627222726272635263536333217161716171617161734373637363736373602B840283C1C1814190F0B09040408382E161E2A1834112B3014303408384020130D240C261E363228243C140C0B211803F008381E5E49BB557B541E6234140440380F3D0B5178453F475D8C1040943B553335265E5B211E5EBAAE496F026A1800010036FFCE03EE041C0047000001161506150207060706070623222722272635262723060F01060F0115062322272627262F01353633161D01163317363736373637363F01363332171517121F013336373637123303AE4030380C141C26121428390F0F11380C0C0414183854100808383D0B1C380B1D1008384009134035131C101F050E0E10152B3B1928281C0C042008181C2F19041C083BD838FECF6E61537A042A587EC63D2686306B8A933F082E436083A72F3EB08643093A86ACCD51452B5C5141179558326037C4FEC44E37946355E60108000001001BFFDE032B03F6003100000116151407060F01153217161D010623222F01070607060706070623263534373437363F0126272635363332171617363736029B40701E32080AB65808382B4DA440334D2329162615174040682B4D2C6448540838126639573D632503F608382E561F790804A0531D04406488604B99217317491008381E621FA1626E48541C2830403C1D439F3D380000010014FE4802F103EC002A000001161707060F01061507020F01062326373436373626272627262726273633161F0114173736373536373602B73901290814251824462424181C4007242F18242835633D59200D0838545BAC3418141D141E1803EC1552662283BE3C50C0FED46E761808600F64E12173305E8641C124304014E2F41044985A903462626E0001001BFFC803FC0421003B00000132171407171407060F0114070615373637361734371615060726070607060706232635343F013437343F02060F01060F0126353437363736333402DC2D0B0C043C712F3C6C20E0063E7469246F0E59545AB8AB2F55201440404074487018735A5815A318405C5ACE955C0421461517272521E1495C0FB23E0D650A193D080A03093D501F372964472A2016093D36637716B8106ACE35312834045605093E30411D69540D0000010042FF3E01FE0642003A00000133161514230615071514171617161D0114230715161507140F011F011615062B01222F011233373427232635343F013637352F01263D013437360192204070880C381523101C245C71141C429340083840A42849230D71286040543010182C401450A806420838443E0610347947443C2311207034084CBCA00F29D074140838408292010C9079270838390F2C261A30608C4F49403642540000010049FF74012D063400110000131615111615140714072635112227343734C54028284040320A2406340838FA5C1D231D43320A083805B440113F230000000001004EFF3E01FE0642003A00001723263534333635373534272627263D0134333735263537343F0127232635363B01321F010223071417331615140F010607151F01161D01140706AE2040706E0C1D1623101C245C71141C5D6440083840A41B42220E71286040543010182C341444A8C20838443F0510347947443C2311207034084CB6A01028D08E08384081A0FEFB9073270838390F2C261A30607F4E4A403550540001005D0168037D02B40026000001161D010623140723262F01262B0106150623263D0134373633321F0114173336353235323736033D40251B5C606B29305622105C1824407036227527903C4C140807051802B4083820AC2319112B2450434D2408382033713030700709251F144C24000000FFFF0028FFCE03FC07060222002400000003008E009D0145FFFF0028FF5D03FC070902220024008F000300D500A50198FFFF0036FE5D041705CA02220026FA6B000300D6016AFF8FFFFF000E0000041607060222002800000003008D00A20152FFFF0035FFA303F30711022200310000000300D4000A01CBFFFF00560000045A070D0222003200000003008E00EA014CFFFF0036FFF20350070D0222003800000003008E0070014CFFFF0022FFD0038605C802220044F3000002008D5C140000FFFF0032FFD0039605BA0222004403000003004300AAFFDEFFFF002FFFD0039305B2022200440000000200D357FA0000FFFF002FFFD0039305780222004400000002008E74B70000FFFF002FFFD003930589022200440000000200D4DE430000FFFF002FFFD003930599022200440000000300D5008E0028FFFF0028FE5D02E804B302220046006B000200D6388F0000FFFF0022FFCB031E05A702220048F3000002008D33F30000FFFF002FFFCB032B05AD0222004800000003004300A0FFD1FFFF002FFFCB032B05B8022200480000000200D331000000FFFF002FFFCB032B057E0222004800000002008E48BD0000FFFFFFBAFFDF01AA05AD022200D2F3000003008DFF4FFFF9FFFFFFD9FFDF01C905A0022200D200000002004396C40000FFFFFFD9FFDF01B605B8022200D20000004200D39400333340000000FFFFFFBEFFDF01C20571022200D200000003008EFF60FFB0FFFF0020FF96033C0582022200510000000200D4BB3C0000FFFF00360000042A05C802220052F3000003008D00D60014FFFF00430000043705CF022200520000000300430112FFF3FFFF00430000043705B8022200520000000300D300C00000FFFF00430000043705850222005200000003008E0112FFC4FFFF0043000004370589022200520000000200D443430000FFFF0036FF95033605A70222005800000002008D66F30000FFFF0036FF95033605A0022200580000000300430093FFC4FFFF0036FF95033605B8022200580000000200D338000000FFFF0036FF95033605710222005800000002008E57B0000000010042FF95030205B5002A00000116150F01153733373217142306071715161315062B01222734373503273507232635363B01373534373401CA401C041404C82D0B708E1A040C40163A083F0920400CAC4040083840A82405B50A32883CE4041040440C0814049EFDE244A0601A264002348C081008384010F85B752700000002004903CE020905A600160021000001321732171617150623062322272627263D01343F0136071514173F0135342707060161231D2E162103111B2A325771243C105458356198200828403005A62838382C40785C2C03411652202D473C30F4300E26342C281B352C16000001007E003C02A205280031000001161D0133161506232227230607061D011433143B013237363316150623140723150623263D012227263D01343F01273536019640505C08381A16205262408450143B15151740183068180838407A461CC01C040805280838CC193B401411776A52283C082C1008385C0D13F0400838FC58332120E4A01444C84000000000010021FFAA041D058A0068000001321732173217062322272623270607061507220715161F012533161514072207171506070607220733173217161F013326353633321F01151407062B01222722272627262F01232207062B0126353437363732373523072326353433363727342735363336373637029962261F2D1B0908382636290F28AA16543010081A1A2801040840701B89040913211F0606346431B33F2D2808140838313B043820202014701040285C1B790864202C2117204094283C070904CC204064088428301B1D171D4296058A243C38403C180409171937443444223E40340838410B201CA05D172D3F1020683A0A18161A406014202E16243C302626161A0830180838317B2173449034083844081C4C0C4C707C1D43512300000000020078FF88039805B8004B0060000005262726353633321716173336373526272627263D0134373637352635223D01343F01363B01321716150623222F0123220F0115163316171617161716171514231407151615171407060714133427262F0123060F011514171617153637363F01021496461808381D2F235118625E52C656C64C70445C40084848614F1C4147280838263224084868180D1B1D7B028A6404160E1C6C6404607D2BA89C0C380C808E1610386CC40C581B3504781A42181C402C160E2890344C48156F4F9920384C1C1004365A1C402D633440442C1C404408583C24641947084C5820175140701E3204453334625E7D070C02F45854090B0C1523100C83113E42040C041814040001006301CF01F3038D0012000001333217161D01140F0123263D013437363334012425463F2545459373402A37038D454834504E46190C702380375E09000000020078FF310424059D003200410000013217361707151714171106232635112F01112307151615161503110623263511343734272326232227222726353437363736011417161732173503350607060706030C76224D0B080828083840280888080C1C0C0838400C0C14682C3F4D3480207C32BEADFE6770451F554F0C69672B3140059D0804404CE8EC40BCFD5C4008380294F0FC01041CF0ADB78D4FFEF4FEAC400838014039E73349242C983B79AC44355738FE608A5A190F2004013CF4164214282700000000010085002103790551004B00000133161516151714070623151617321F01150607060706232227343336373637363D0126232627263534373637363537353427262B010607060F01111716150623222F011134373637363734022D20745808902616715B2B29040953CB71E1432D0B64C672B410140E224167A0341E5E6C04300828383B45274510182408383B2918582D1F6B29055118185321507E5E28042F499C3C604B558B194040442C2C691F20107054442016462A1A34205C10101C311F18122A0C5828FE7C74261E407480016486463A0A4404140000000004005D003C05490558002500480065006E000001333217161716173217140706070607232227262726272635263D0134373635363316153334150623220706072207151417161F01163B013637363F013403272627262B012207263517321F011506230607231F0132170623222F02150623263511343334171533323735342B01033920607C4F1D7E120F09381A828662A0959B38942D2F2C0C789C88403C04053713C57507090320153B60B4809C70901632046C2010783038281E4E3C3CB232141C241C6404745C281808382B6D445C083840641C0436726440055890403CF8949C824658585E12500E7E22523A0E2B3D80AC84A60A8C0927606848DC734D3CA8361638344C681983137544900104403A5E48180927E86440205C20185C485840743040DC4008380240440787643404340000030049005E04C50532001E003B0059000001331617161532171617161716151407060F01232227262F0135343736373601151617163B013237323736353427262734272627342723220706150625321506232723061507151633163B01371615140722272227263D01343702A9205692301D3F37250B1110B459A78020BBE931470C6439CB83FE952745C0683482562884302439532407694428466AC85401A4A00838401084107739163A082C40605E4633A11C6C05320A56291B685D6711634F41E18B53350C941B8930C089A37DBB48FD68C46F21683C9041735E7E9769150F15270E0A40D72590945040101D1B101880180808383F0924A423194031570002006A031304760577002600420000013217161715062322353427060706070623222F01150623263D013437343732171417333637360533161514230623161D01170623222722032707232635343336333603C2430D491B083840401C08090B181C2341240838404024353720043C1C18FE442040701B11101408383A06130908642040706A5617057780EB9124405C18E41F35021E18481CD8400838E0763A0903580B19725E1808083844107583246C4044014C2C10083844140F0000000001006B0438025B05B4001000000017140F0106232227363332373637363302530894A450283808144015338123531D05B4403751783C405C286010480000000002005E04E5026205C1000D0019000001321D0106231715062322273536071615140F0123263D01363301EA78050B04193B3B150BDF4C54182040155305C140042804105C5C40400411372F410408382058000000010043FF24047B0474003E0000011615140F01331617161506232723060717331615062B012F0107140722070623263534371327232227263536331F013317132325232635363B01053337360377402C4434A147180838CC501448F84840083840D854443807091B1D40285C04D073791408388040906C6004FEE0C0400838C00120245434047408382028BC161A181C402462CE1C0838401808E8198B381C0A322F5101280438161A40240404012C1008384010E85800000200560064049E0524003B004200000132151733253332171423072315161F01331615062B012715132116150623211407263D010335210607060F0226353437343F013637363736373403333427060F0102824004200144042D0B8CF40C3014E44840083864B4240108400838FEF0384024FED4432D101C3024402458504B31333D2B0978D4401A265405245C3418404810049587040838400410FEA40838401A0A0838600160049C40125A4C080838163E2490AC8F4570643F452DFDCF37D1225A880003005EFF24043A05F00042005D0071000001161D01060F011714071516173217161D01020714070607062B01222706151407140F01263534373437343F01263D01373437363736373637363B01321F0133363736011514173637363736373437363727262B0106070615060706150601140F01060F0133363736373637363D0127262703CA402430140424311B1133281329500D67AA36804A1618284C204030281C04A8283C181C10249B294315402F652804420618FD386C3B593B310D4F1C2222046D1B245A2A50210F5018024864502C346898347843112E261848172105F0083820802828241F1104393B783E1A60FEEC1C16863359540C290F0B3D27510808381B3D183C1A2A187FBDA0B0498728580F5DAB0120441C505C24FC4CA8615BA5C3D23A377D0B295127045017413E323838906C3A016A0AAAAC9F69FC04403F3943618A42548C1147000003005D011E04ED03BA002D003C004E00000132171617161F01151407062B012627262706070623072627342F01353633343732173637343733321F013736331706070615161F0133323735262F0105231514171417323736372627230615060703954A2E8004282C084C415B204C64702C521E622A3C5C50500818282C1C185F3530404C341878451728412F3852823028441027356CFD48104450263622523814286C293703BA448C20443420602E4220073948545A425C081B7112AA2860580E06182E0205076C28804C7C3F3D2818833108203C256F7C8014108C243C443D5F6D13130D0B210002006400000420043C00230036000001161D01253316150623222723051407150623263D01343F01230607263534373637353601331615062322272322070607263534372536022840011C405C08381A162CFEE428083840200804E35D406823F908018810600838171504B1DB77AD4070016068043C0838C008193B401408817F40400838203A7664181C0838410B0C1CCC40FCA4153B4010300C240838410B381C0000020042003C041603F0001E002C000001161514070607060F02041716150623242526272635343F013637363736013305331615062B012523263536031E40346B3D6854702401E3911C0838FEDBFEF5765A40749884204C486EFDC2C00180E0400838E0FE80C0400803F008382B19681C68204C201C181B1D401C0C14180838392B684E1A482870FCD40808384008083840000000020042003C041603F0001E002C000000171617161F0116151407060704052227343736252F012627262726353437001714072305232227343733253301646E484C20849874405A76FEF5FEDB38081C9101E3247054683D6B344002A00840C0FE80E0380840E00180C003F07028481A4E682B39380818140C1C401D1B181C204C20681C68192B3808FCD440380808403808080000010036FFC403DA0584003C000013321516171633373637363316151407220F0115331615062B011517211615062B011711062326351127232235363317333527232635363B010027353676442672B50BEC23511513407C105C8CB8400838B80C0110400838F004083840088CA0083840900CC8400838ACFE9D31080584645183ACD80C6C0C08382D73607C0C083840047C08384050FEA040083801743C504010047C0838400126CA20400000010064FF1D031C03250030000001161D0116153217161506232227222706070623222723031423263D011332373637363B01161D0114173337363F013536029C40140606200838331D0A062020342C5038046C4040680A0E2513093B04402C044029130C080325083834739D30281C4050241F3D4460FE4C50083820019CE09527640838E08C2064417748344000000002006BFFC4032F04900028003900000132171615161D011407062314072322272635343736373637332F01262B0107150623263D01343736131433163B01323F01352723060714070601A3833184543C465230205A8E38440A724070243C342F2114C00838403C22A21C583808582C0C0C346F5D2810049060EA46C9A760B0486805078C2692924A264E1F19B46C600850400838602B2D20FC786460688460800C500A362200000001005000570410054B0038000001331615142304231617161716151407060706070607151617163B011615062B0122272627263D013437363736373637352726272635363337039C204064FDCC2836AA5C5C60540864497F327A63FD7FC13040083830C28EE458C4A04E52564A063E407DAB80191BCC054B08384494305C4430442C3E060B25255B0D7F04231D280838402820143A2A1039834C24461E0917042057616034542800010064FF95044803FD0028000013163321363316151407061D0113150623263D01033534372122270711100706232635363511363334C8AD5301B44D3F4034140C0838400C18FE3045830824161A4014101403FD241008381656497B24FE70F0400838F0019010A74D1820FE4CFE8E3A140A32A2E201C08C0E000000010072FEE1035A0651002D0000013217140F0106070607061511161511140F011407060F012635343736373637363F01113427113437363736373403222D0B4844035D40180820183488365A184048063E0F590D2F0C205C3F292054065140380C38174558801222FE987F6DFEE0581C740B8515470408382C280E1E045C027E0C014C627E01608BB9570D37391A000002008B035C02A705C80020002A00000133321F0115171407222707232227263D01363F0133161735342F0123072635341315141F013332372623011F60C23E240440301C3840693B74134544A03913581C7030404C6024481D070E3205C8A08C709C270D480C28275528720A040810044B29040C08383EFEAA180D23040C400002006A034802B60610001A002C00000132171417161D01062306072326352627263D0134373637333536171407270607061D0116173317333237352601B6343850442331313360942666147018701408403818333120452B242C44390F19061050155F932580A025070F15156B290F609E5A22260C40B01A0A040A3E2838644A1A085C647500000001001AFFD804A6042C00470000013332173217161532173217151407331615062321263534373637363D0126272627222722272307230615071516171617161716150623212635363B012F023534373637363B0101F28017212765940616090350C4400838FEA040382C18300C1808640E3A2A12604C4C3C402A2202562F15280838FEA0400838DC683430480844296B14042C184C995FB824C024B808384008382E16184C651BA425BB33752C14102C0C5CC0B632156F38301428400838409078BCCC394F2C30300000000003007EFFDE040A03FE003F004B005A000001321F0233363B0132171617151407060F01141F013633161D010623222717150623263D0107222726353437363B01373326272627230615142326353437360115173336353735232723220123151417163337353427342B01060172363E203004502020B6361008241C5C98A4581123400838BF6D0C08384080647C383C2014344C601C301C14185040406422015E0410C4140480140BFE77107C1513601C08643303FE503C783834133940153B4329202282141C083820407894204008383408A03E722B2D140CD547440C13654808389D372CFE7048141937202808FED40C3B690C080C3C68100C0000030050FEA00428051C0033004200550000013316151407060732171617161D01140F010607062B0122270306232635343F012627263D013637363F01363733173337363736011516173613373527230615061506250307151F013332373237363F01353427263503C8204044385021271D37302C382755A523402D73C40D3F4078703F59180C1407318413AD60401458323E15FD53224A71872820448C642E0206C8745C142818842C300A2E045438051C08383A06448C783D4F4F6160144C6848244848FE886C083845CFDC1F6D181CC0571D235980191F10944E460CFD28983C30D001144408081715541850C4FE7CD80830043C60076504702B75700C00000200C8FF4F040005A90033003F00000522272227263D0136373637363735342F01343B0116150714171615140F010607061D011417333237363536331615140706050613222726353633173732170601A85E16124A100D634E4AB41034083C084004241854583A6A7C4414DE36D8181C403C2EFEDA509B5A1E10083818202F190BB124A05739206F5D612F6A02042E9E38800D274C265A534534343012627A3E147C582C451F1808382B2D20640C05833E1E205B06067C5B00000000020071FF8F010D05FB0011001C00001627112735373534373217150715171114070235263536333217151407950810084038080810404814193B380840713D01F6849879F234083CF279AA85FE1D3508058C4C28105C40603808000001004200FD03EE0305001400001321053316151417150623263D0127232521263536820140018060400C0838400C20FE80FEC040080305080838859B6040083860E0080838400000010072FFD803E605AC0031000001331615142306071423161D01030623072227262726272306151423263D013437363F013217141317333711340335343736038620405C21C71834041030143F290C503A1E04544040445721203C20800C040434D08405AC0838400B0908E9FFC0FE2CB804940FD56761DB214808382013C1CF0D085C32FEF6243C01BCEB010520590B04000000010064FF4603A00642004B00000133161532170623222F012307140F01140F011517331615062B012715061506070607060F012322272635273437161D013217333736353735343735232635363B013534373437343736373602EC20800E0608382418240C28441C1C0480044008380480180A12294F0F4918401D53180440400E12183C4C14147C4008387C20204804542E0642142C2C4024083C175D7C2C68408C0408384004345FD110DC6F552A2E04403014242D0B0838101050429A9C54416B280838408C596739671F69255B180000000002005600AE0469032000240049000001333217163B013237363316151407062B012227262F01230607060714072635343736333413333217163B013237363316151407062B012227262F01230607060714072635343736333401A560334D6038781F25242C40543F396071471F551C7C10302F353840703C346160334D6038781F25242C40543F396071471F551C7C10302F353840703C340320446844440838206C3C3C14540811072F191A0A0838383C3C14FEBA446844440838206C3C3C14540811072F191A0A0838383C3C140000020051FFC50431042D001D002E0000013215161716171613321706230F012307230607232635343713363736371706070306153337333237262726272627023D441A323C7037710B0514406C809080D44F25084040A44440035D0434408C20E480A4761E494F5E364A02042D707E423DEB41FEF1285C1004080A16083818980198D9672375E85DC7FEA44A0E080CBF71C53F6729000000000200780000042C03F0001B0035000001161514070607061516171615062322272627263534373637363536051615140703060716171617161506232227262726353437133603BC4044693784C672600838206859BF44A435475408FEB04034E41C3806AA462E1008382D9F534D184CF84803F00A32465285639B11856B23354048578133254AB65D5B6C14401008381C38FEBC1C580B853F19151740903A4A28141C64016070000002006B0000041F03F0001B00350000001714171617161514070607062322273437363734272627263534370417131615140706070623222734373637363726270326353437011308544735A444BF59682038086072C6843769444001B848F84C184D539F2D3808102E46AA06381CE4344003F040146C5B5DB64A25338157484035236B85119B63855246320A1070FEA0641C14284A3A90401715193F850B581C0144381C380800000300420013029A00BA00080011001A00003716151407263D01361736333217062B01260526353437161D01068260604008D4153B3B1508382040013C60604008BA153B3B150838204060606040080F153B3B1508382040FFFF0036FF6A040A071A022200240E9C0003004300FD013EFFFF003DFF92041107170222002415C4000300D4003601D1FFFF00560000045A0703022200320000000300D4007401BD00020067005704AB05330039005800000116172116150623211617113337331615062B01072327230607060F011721321D01062327212723062B0126273427263D0137363F01363B01341714070607060722072207151633161F01333635363736353635112623262301D34D5B0170400838FEE01424C02C40400838342CCC040418100B211008016CA00A3264FEC0800C5020405662442C1C090B4C64480C2C38511B12160705070118143C242C241C3F0D3C1C3729261E0533064A083840247CFEF40808384008045765095710083C0C4008083812760D5F6C5CA0900864C8981B77121A597F23894C14A48C661A1C0C0C3E265A524F550110BC400003002F005703C303A7003300430050000001321716151734373437333217161D010607062B01161F0236331615140F0122272635230607062B0122272635113437363736170F0115161733323F01363D0126233425150733363536373534272306014B1824741C702C60424E2026324C2078253740281424404C2C619B2004175536661C246C48382448403080141C481813213C1C160E01041068301014304C3003A71C59232066360E064C392320873D3C93293014200838322608AC3B11573D60504E2601002F692C7C4888C844E42D2734382A1AD4641F0D306818240C48042410180000000001005601AA03F6022E000B000013172116150623212722273486F00240400838FDC0EC270D022E0408384004402B000001008C01B905CC02390009000013211615062321263536CC04C0400838FB404008023908384008384000000002005D037002A105D8001C00300000011615140714070607220715373316150623222F0135343734373633360516151407060715333217062322273536373633012D40302810180C04041040193B41330C242C3F0D2001484050160A083E0E153B5B29281C442005D808382B150A2E1E5244640408385C5038605E4623495C141008381C684B0D78605C74D07E2668000200070341024B05A9001C00300000012635343734373637323735072326353633321F0115140714070623062526353437363735232227363332171506070623017B40302810180C04041040193B41330C242C3F0D20FEB84050160A083D0F153B5B29281C4420034108382B150A2E1E5244640408385C5038605E4623495C141008381C684B0D78605C74D07E2668000100780333018405A70014000001331615062307061D013217062B01222F01343736012420400838301C4014093F204C1C04581F05A70838407046661C5C608C4CAD9B54000000000100780335018405A90014000013232635363337363D012227363B01321F01140706D820400838301C4014093F204C1C04581F03350838407046661C5C608C4CAD9B5400030050003C03F003C0000A00150021000001171615140723222735360117211615062321263536013217142B01222F0134333402106C2054283B1508FEB82C02F4400838FD00600801E0361A44202F25043403C028151F621E5C4040FE8C08083840093F40FECC786444147C0500000002006B000003C705880028003E000001161D01161716171617161F0114230603060723171506232227262726272627263D0134371237363717060706071516171615161733123735272627262F010247641010251F1E461D27101C4157150B04040838373D224259335D1B6C48FD0361170823612E86501484356F0477452C156F17351405881252381331315719734335387065FED92D67041040781D6F815F5F417616084430012B259612C8537142960458309C2041B701924A18543B8D47592C00FFFF0014FE4802F105770222005C00000002008E3CB60000FFFF0028FF81034406FA0222003C00000003008E006801390001005DFFDE04550572002B0000011615140F0106072207060706150607060714070607062326353437363F01363736373637363736373237360415402C6C2B39085820107059171C54742C041B1D40445E6648521638243E322739164E072125057208381937D03769801B319A0E55372F61097F342C1C083835576682705335375941532D6B0FA94430000001005600AD03BA050D0042000001331615062B010607060F0121161506232107211615062321141716331417161506232227222726352635232635363B01363F0127262726353633173336373633363702F640400838343A564C2820019C400838FE282001F4400838FE00B4304C441C0A3224385662903060400838640616040454442408388C28104479332E5E050D0838400133264A4C083840600838405E861C0B0D1B1D4014507F1D395708384001570404100418244010119F84290F0001006400A0023C039400190000011615140F01153217161F010623222726272635343F0136373601FC40A890226E77210408381F4D4157886C685A2A15039408382FD1800468442C18403C25533E3E2B555C71473000000001006400A0023C0394001900001217161F01161514070607062322273736373633352726353437CF152A5A686C8857414D1F38080421776E2290A84003943047715C552B3E3E53253C40182C44680480D12F38080000000001007FFFF9038305990033000001161D01133336331615142307231617211615062321121D010623263D01340323223D013633173303232722273633173503353601BF40088C3339405C449009130118400838FEF8340838403458A00A3264441804D42D0B0B2DD008080599083820FEE40C0838400CB15B083840FEF34B80400838803A011E3C0C4008010C04404004040118204000000001002F022A0147033E00100000133332153217140F012227222F01343736B9265011075117123A312E053E20033E6E383B2E051E551A352032000000010056FF25016201990014000017232635363337363D012227363B01321F01140706B620400838301C4014093F204C1C04581FDB0838407046661C5C608C4CAD9B54000002005DFED402A1013C001C00300000012635343734373637323735072326353633321F011514071407062306252635343736373523222736333217150607062301D140302810180C04041040193B41330C242C3F0D20FEB84050160A083D0F153B5B29281C4420FED408382C140A2E1F5144640408385C5038605E4623495C141008381D674B0D78605C74D07D276800070069006A04EC04AA00190033003F00520065006D00740000011615140F0106070607062314072635363736373637363F0136053217141F0214071407232227222F01373437363B0117333417061507333217333527342301321F01151423140723222722273534373237051737161F0115140706232227263D01363336051517333527230605151737352706037740A0649D0F32A64507244009BB581C02BA2B496415FDCD2050282C0820584061172C30041C4015170C0404141818040F196440140323325E144028401850260E4C2113FE6818242F550460290F6751141B1D3E01C230141C0417FE3B3C28283C04AA08382DE788AB3147B570090308384EBE6D330ED2495FAC10483C112740383824161A1C4C3854313710040B770D23381410540CFE285C4040A00B05385C803226180C0404086418602C5C18602711207C5088541C681810500C2034302433FFFF0028FF6403FC0718022200240096000300D300560160FFFF000E00000416070A022200280000000300D300740152FFFF0028FF7703FC070D0222002400A90003008D00970159FFFF000E0000041607070222002800000003008E00910146FFFF000E0000041607070222002800000003004300DD012BFFFF002FFFA3038F07140222002C29A30003008DFFEB0160FFFF001AFF95037A070B0222002C1495000300D3FFE60153FFFF00060000036607000222002C00000003008E0027013FFFFF002EFFB0038E07070222002C28B0000300430053012BFFFF0056FFCB045A06FA0222003200CB0003008D00E70146FFFF005DFFBD046107040222003207BD000300D300CC014CFFFF005DFF8F046106DE02220032078F00030043017E0102FFFF0036FFF2035006F20222003800000003008D006E013EFFFF0036FFF203500718022200380000000300D300440160FFFF0036FFF20350070002220038000000030043006A012400010078FFDF011C04000014000013161D0107111715170706232237263D0127113633C4400C1410100838471B1414062E04000838204CFE944C74DB2E40C5663250500164BC000000010057042402AB05B800160000013217161716150623222726270706232635343F01363701DB2E162A4A1808382B194616C84F1D403490495B05B8387153181C40344844A44008382B19783163000000010065043E0381054600240000013316171617163B01363F0116151407062B012227222F0123060722070623263D013437360175202B5D302C3B19081C2C2440682711203781103C38047A061C041824406816054603350B25201B41080838345C1450241411173424083820323E190002007803F50250057100130020000001161716151407062B012627263D01343F0136330715173337352623272306150601685F31583C38306047612C3034164A405C4830283C0404381605710C24442C77254008382F1D2022364824D0041C3014340411072A0000010049FECE017D00D6001A0000251615073217140722070623263D013437363D0123263534373637012540141D0F9C1513161A4044702840481F11D6083844788F4128140838203B052F2D2008382B453701000001004903FC02710574001900001332171617343732353633161506230607140722272627263536892E1621877808182440191B51333C30683C3C24080574380A96146C0C24083854454B210B804527321A4000FFFF0035FFB6037D07090222003600B6000300D7006C0195FFFF0021FFB1030D05D1022200560000000200D7275D0000FFFF0021FFD103FC07090222003D0000000300D7008A0195FFFF001BFFC803FC05E50222005D0000000200D772710000000200DCFF7A01780606000F001D000001161514071507150623263D0137353613161D0117150623263D01273536013840100C0838400C151F400C0838400C08060608381715D0A0A0400838A0A0E05CFBF40838A0A0C0400838C0A0A04000000002004A006B03FA053F0030004A000001161D01373337333217161F0115140706070607062322273433353327352306070623263534373637363D01342F0135361723061D01161D0136371615140F011136373637363D01022B01013E401C348C60466A503C044C7D9B65CB3F212D0B580404042B4115174048293F2C200808B4102420AD4B4070C8A781304C30488468053F0838080410545FCD4CC026A675533937104044083CC40D2F100838311B26120A0A4C9BED684040C4070920C8B4282C0C0838410B30FEF0315F184C7410D4012C0000030064000003B004980021003F00580000011615140706071716150623222F0106232635343736332627263522273633321736033217363332171417161D01140706230723202F013437363736373237361723070607060F0115163B013237363F013534273427263506028040383A12BC180A322E6A7090244034410B021E600B050838199F8E42231115135379403C5079375080FED149041C19378C20092F2236204C1C404B110432CA743755300C14585C4814049808382E16271544181C4030287808382B1934090B360628405C84FE401C0C6C073553314077755C14C84861173F2DA212280880342A464331045864301F2D40542F3D1B2912120C00FFFF0028FF4B034407000222003C00CA0003008D0045014CFFFF0014FE4802F105A00222005C00000002008D40EC000000020050FFF9034C05790024003300001316150715333217321716173217151407060714052315062307263D013735273711271136131517113336373637352726272623984008B49D731359152B09033C2567FED474062E18400C08081409771458F81C64182813357153057908382CC0687402A22440791B291F1814A8BC040838204CD02C2C012CE0014060FE5404D0FEE80917202058840B4D5800020057FE70031B05100030003E0000133215131533321716151714070607060723150607150706232635343735363735232635363B01033523263536333503341315133325363735342726232623B7441C80CD2F84047C5389057F18100C1018245C280C100840083808080840083820A8080C01043D27482E3A153F051070FED00468DA6E3C3D573414091B7041BF205C24163A241C10BC505C0838400138BC0838400401682DFDE7BCFED0441E2E04617F700800000000010057017C03B70240001500001316053317331617161506232227232723242726353697600100402CB433492408383933B42C34FECD511C0802401818080C041824400C081C1C1B1D4000000100500099033803A9002F0000011615140706071517141714171615062322272627071407062B0126353437343736372627263536333217161737363702F8404402B2843020140838375D3E2E885060140C405068017F20C4300838232D9A3E88453303A9083820441BA9046C093B0612161A40882828880A427008382947085C08781C80321E4038623288632D0000010071033401F105BC001D000001161D011615173316150623212635363B01372F010623263534373637340131400C0430400838FF00400838480404041E1E4030074105BC083880A89C0408384008384010DC1C2008381D3316422D000000000100A0034802B805C4002A00000116153217321D011407060F011533321D010623272126353437363F0135262B01060706232635343736330160B01D1710206A3220A0A00A3264FF005C8832421C0B69200533141440281C5405C40917346420601C701814043C0C4008193B386C1E3E2070101C500C08381D4358000100AE035502A605D5003000000133321F0114073217161D01140F011407232635363B01373237323734272627263534373437352723220F01263536333401624093211434362E0C5C7844A04008389460210B07115421471878141C80191F1C40184005D554542329741414202A6230090B08384024201C38141315181C3C1C09031004240408385C0C000003006A000004520554001D0035005700000116151117331615062B0107222734333527352306232635343734373536051615140706070607060706232635363F023637363736033332151615140F013316150623210722273437363F013523220706232635363334014E40082440083854742D0B5C0804181C4034440802B840B88331296F8F7D193B40046C84B43A5EB44815A5207C146C18D0400838FEEC542D0B6023450C281808181C401C2405540838FE6C280838401040440424B41808382B190A4E284018083828F8B0504D8FCBC57008384B95C8F86F79F3750CFD5434155B538D300838400C40246841633818201808385C100003006BFFFA048B056E001D0035005800000116151117331615062B0107222734333527352306232635343734373536051615140706070607060706232635363F023637363736131615113215062B0127161D010623263D0134272322352227353633161D0117331136014F40082440083854742D0B5C0804181C4034440802B840B88331296F8F7D193B40046C84B43A5EB44815274068083804140C0838400C68B80701083840287008056E0838FE6C280838401040440424B41808382B190A4E284018083828F8B0504D8FCBC57008384B95C8F86F79F3750CFDE40838FEDC44400443895040083850834D301C8040083848040120400003007FFFD105030565002D004B006B000001321F01150623151615171407140706072635343736353237352723072235343F01353423220F0123263534373405161514071407140103061506070623263534373637360134373637363303161507113217140F01150623263D0137232635373536331615071507331136021F3B351413255C04908C42824060845567106C3C649064103C484408409803284060B0FE64E8442711181C40587C28CC0138AC024A1F296840082D0B3C0808384008E45C20093F40080CB00905654840205C0836420C6D57112B1A1208383F091113700C1010443E2A4C0418201C083841270E020838267220A818FE68FEF4341C3F391808382C947642DC01380EB21A5244FDB408382CFEDC4030146C804008388064153B70706008382C7430013C600000020079014D038D043D0039004B00000132173736331615140F01161D0106071617161506232227222735230623222706230607263534373635263527363F012635273633321736333603151633363F013527262F010727230607060215336D701513406034380B293C20240838271D14440447414B611C2C313340443840041C14046C0408382759505811BD6F7D73110C2C172D10242C20481C12043D70500C083830302C742C2445333C102E1A403054083C34182507083832161709372D38781C0C640C1440604C1CFE88149449172C1074174D0C08082D371C0001004A04BD044A0565001000001333051733321714072327252326353437D6E40190A02038084020A0FE70F0804005550C0C4038080C0C0D4338080000002801E60001000000000000005000000001000000000001000800570001000000000002000700500001000000000003001500570001000000000004000800570001000000000005002E006C000100000000000600080057000100000000000A0040009A0003000104030002000C02CA0003000104050002001000DA0003000104060002000C00EA0003000104070002001000F60003000104080002001001060003000104090000007001160003000104090001001001940003000104090002000E01860003000104090003002A01940003000104090004001001940003000104090005005C01BE000300010409000600100194000300010409000A0080021A00030001040A0002000C02CA00030001040B00020010029A00030001040C0002000C02CA00030001040E0002000C02E80003000104100002000E02AA0003000104130002001202B80003000104140002000C02CA0003000104150002001002CA0003000104160002000C02CA0003000104190002000E02DA00030001041B0002001002E800030001041D0002000C02CA00030001041F0002000C02CA0003000104240002000E02F800030001042D0002000E030600030001080A0002000C02CA0003000108160002000C02CA000300010C0A0002000C02CA000300010C0C0002000C02CA4F736D6F7369616E20536C6F70707920A920323030352052656C6174696F6E616C2053797374656D7320436F72706F726174696F6E20323030352E20416C6C205269676874732052657365727665642E526567756C61726F736D6F7369616E3A56657273696F6E20312E303056657273696F6E20312E3030204E6F76656D62657220362C20323030352C20696E697469616C2072656C656173655468697320666F6E74207761732063726561746564207573696E6720466F6E742043726561746F7220352E302066726F6D20486967682D4C6F6769632E636F6D006F00620079010D0065006A006E00E9006E006F0072006D0061006C005300740061006E0064006100720064039A03B103BD03BF03BD03B903BA03AC004F0073006D006F007300690061006E002000A90020003200300030003600200054006800650020004F0073006D006F007300690061006E0020004F0072006400650072002E00200041006C006C0020005200690067006800740073002000520065007300650072007600650064002E0052006500670075006C00610072006F0073006D006F007300690061006E003A00560065007200730069006F006E00200033002E0030003000560065007200730069006F006E00200033002E003000300020004E006F00760065006D00620065007200200036002C00200032003000300035002C00200069006E0069007400690061006C002000720065006C0065006100730065005400680069007300200066006F006E00740020007700610073002000630072006500610074006500640020007500730069006E006700200046006F006E0074002000430072006500610074006F007200200035002E0030002000660072006F006D00200048006900670068002D004C006F006700690063002E0063006F006D004E006F0072006D00610061006C0069004E006F0072006D0061006C0065005300740061006E00640061006100720064004E006F0072006D0061006C006E0079041E0431044B0447043D044B0439004E006F0072006D00E1006C006E0065004E0061007600610064006E006F0041007200720075006E0074006100000002000000000000FF270096000000000000000000000000000000000000000000ED0000010201030003000400050006000700080009000A000B000C000D000E000F0010001100120013001400150016001700180019001A001B001C001D001E001F0020002100220023002400250026002700280029002A002B002C002D002E002F0030003100320033003400350036003700380039003A003B003C003D003E003F0040004100420043004400450046004700480049004A004B004C004D004E004F0050005100520053005400550056005700580059005A005B005C005D005E005F0060006100620063006400650066006700680069006A006B006C006D006E006F0070007100720073007400750076007700780079007A007B007C007D007E007F0080008100820083008400850086008700880089008A008B008C008D008E008F0090009100920093009400950096009700980099009A009C009D009E009F00A000A100A200A300A400A500A600A700A800A900AA00AB00AD00AE00AF00B000B100B200B300B400B500B600B700B800B900BA00BB00BC010400BE00BF00C200C300C400C500C600C700C800C900CA00CB00CC00CD00CE00CF00D000D100D300D400D500D600D700D800D900DD00DE00E100E400E500E600E700E800E900EA00EB00EC00ED00EE00EF00F001050106010700F400F500F600BD00DA052E6E756C6C106E6F6E6D61726B696E6772657475726E044575726F07756E693030423907756E693030423207756E693030423300000001FFFF0002.

To outdent any selected rows in a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row of the text is not selected, repeat.
If the row's string's first's target is the space byte, remove the first byte from the row's string.
If the row's string's first's target is the space byte, remove the first byte from the row's string.
Repeat.

To outdent a_ box some twips;
To outdent a_ box given some twips:
Subtract the twips from the box's left.
Subtract the twips from the box's top.
Add the twips to the box's right.
Add the twips to the box's bottom.

An outdent is a_ number.

\PAL
Para delinear uma caixa com uma cor;
\CAL
To outline a_ box with a_ color:
Draw the box with the color and the clear color.

a_ outlinetextmetric is a_ record with
a_ number called otmsize,
a_ textmetric called otmtextmetrics,
3 bytes, \ needed to align structure
a_ byte called otmfiller,
a_ panose called otmpanosenumber,
1 bytes, \ needed to align structure
a_ number called otmfsselection,
a_ number called otmfstype,
a_ number called otmscharsloperise,
a_ number called otmscharsloperun,
a_ number called otmitalicangle,
a_ number called otmemsquare,
a_ number called otmascent,
a_ number called otmdescent,
a_ number called otmlinegap,
a_ number called otmscapemheight,
a_ number called otmsxheight,
a_ box called otmrcfontbox,
a_ number called otmmacascent,
a_ number called otmmacdescent,
a_ number called otmmaclinegap,
a_ number called otmusminiumppem,
a_ spot called otmptsubscriptsize,
a_ spot called otmptsubscriptoffset,
a_ spot called otmptsuperscriptsize,
a_ spot called otmptsuperscriptoffset,
a_ number called otmsstrikeoutsize,
a_ number called otmsstrikeoutposition,
a_ number called otmsunderscoresize,
a_ number called otmsunderscoreposition,
a_ pointer called otmpfamilyname,
a_ pointer called otmpfacename,
a_ pointer called otmpstylename,
a_ pointer called otmpfullname.

An x-offset is an offset.
a_ y-offset is an offset.

To output the arc of an ellipse given a_ string:
Put 2761/10000 into a_ fraction. \ 2/3*(sqrt(2)-1)
Put the ellipse's center into a_ center spot.
Put the ellipse's x-extent divided by 2 into a_ half width.
Put the ellipse's y-extent divided by 2 into a_ half height.
Put the ellipse's x-extent times the fraction into an x-offset.
Put the ellipse's y-extent times the fraction into a_ y-offset.
\ control point 1
If the string is "left-top", put the ellipse's left and the center's y-coord minus the y-offset into a_ first control spot. 
If the string is "right-top", put the center's x-coord plus the x-offset and the ellipse's top into the first control spot.
If the string is "right-bottom", put the ellipse's right and the center's y-coord plus the y-offset into the first control spot.
If the string is "left-bottom", put the center's x-coord minus the x-offset and the ellipse's bottom into the first control spot.
\ control point 2
If the string is "left-top", put the center's x-coord minus the x-offset and the ellipse's top into a_ second control spot.
If the string is "right-top", put the ellipse's right and the center's y-coord minus the y-offset into the second control spot.
If the string is "right-bottom", put the center's x-coord plus the x-offset and the ellipse's bottom into the second control spot.
If the string is "left-bottom", put the ellipse's left and the center's y-coord plus the y-offset into the second control spot.
\ ending point
If the string is "left-top", put the ellipse's left plus the half width and the ellipse's top into an ending spot.
If the string is "right-top", put the ellipse's right and the ellipse's top plus the half height into the ending spot.
If the string is "right-bottom", put the ellipse's right minus the half width and the ellipse's bottom into the ending spot.
If the string is "left-bottom", put the ellipse's left and the ellipse's bottom minus the half height into the ending spot.
\ spit it out
Output the first control spot without advancing.
Output the second control spot without advancing.
Output the ending spot without advancing.
Output "c".

To output a_ color without advancing:
Convert the color to a_ rgb.
Put the rgb's red byte / 255 into a_ fraction.
Convert the fraction to a_ red string given 4.
Put the rgb's green byte / 255 into the fraction.
Convert the fraction to a_ green string given 4.
Put the rgb's blue byte / 255 into the fraction.
Convert the fraction to a_ blue string given 4.
Output the red string then " " then the green string then " " then the blue string without advancing.

To output lineto given a_ spot:
Output the spot without advancing.
Output "l".

To output lineto given an x-number and a_ y-number:
Put the x-number and the y-number into a_ spot.
Output lineto given the spot.

To output moveto given a_ spot:
Output the spot without advancing.
Output "m".

To output moveto given an x-number and a_ y-number:
Put the x-number and the y-number into a_ spot.
Output moveto given the spot.

To output a_ number without advancing:
Convert the number to a_ string.
Output the string without advancing.
Output " " without advancing.

To output the pdf border given a_ color:
If the color is the pdf state's current border, exit.
Output the color without advancing.
Output " RG".
Put the color into the pdf state's current border.

To output the pdf fill given a_ color:
If the color is the pdf state's current fill, exit.
Output the color without advancing.
Output " rg".
Put the color into the pdf state's current fill.

To output setcolor given a_ border color and a_ fill color:
If the fill is not clear, output the pdf fill given the fill.
If the border is not clear, output the pdf border given the border.

To output a_ spot without advancing:
Output the spot's x-coord without advancing.
Output the pdf state's current height minus the spot's y-coord without advancing.

To output a_ string:
Append the string to the pdf state's current contents.

To output a_ string without advancing:
Append the string to the pdf state's current contents without advancing.

To output stroke and fill given a_ border color and a_ fill color:
Put "B" into a_ string. \ stroke and fill
If the fill is clear, put "S" into the string. \ stroke
If the border is clear, put "f" into the string. \ fill
Output the string.

The p-key is a_ key equal to 80.

a_ pabc is a_ pointer to an abc.

The page-down key is a_ key equal to 34.

The page-up key is a_ key equal to 33.

a_ paintstruct is a_ record with
An hdc called hdc,
a_ number called ferase,
a_ box called rcpaint,
a_ number called frestore,
a_ number called fincupdate,
32 bytes.

An x-number is a_ number.
a_ y-number is a_ number.

a_ pair has
an x-number
and a_ y-number
\PAL
e um número chamado número-x at the x-number
e um número chamado número-y at the y-number.

a_ panose is a_ record with
a_ byte called bfamilytype,
a_ byte called bserifstyle,
a_ byte called bweight,
a_ byte called bproportion,
a_ byte called bcontrast,
a_ byte called bstrokevariation,
a_ byte called barmstyle,
a_ byte called bletterform,
a_ byte called bmidline,
a_ byte called bxheight.

The paragraph byte is a_ byte equal to 182.

a_ pastel color is a_ color.

a_ path is a_ string. \ complete name = c:\folder1\folder2\file.ext

The pause key is a_ key equal to 19.

a_ pchar is a_ byte pointer.

a_ pdevmode is a_ pointer to a_ devmode.

a_ pdf is a_ buffer.

a_ pdf object is a_ thing with
a_ kind [contents, font definition, font descriptor, font streamoutline, image object, outline entry, page, parent, root],
a_ number,
An offset,
a_ data buffer,
a_ font name [font definition],
a_ font info [font definition],
Some string things called font strings [page],
Some string things called image strings [page].

a_ pdf outline entry is a_ thing with
a_ pdf object (reference),
a_ title string,
a_ page height,
a_ destination number.

a_ pdf pointer is a_ pointer to a_ pdf.

a_ pdf state has
a_ pdf pointer,
a_ document flag,
a_ page flag,
An object number,
Some pdf objects called objects,
An xref offset,
An outline pdf object (reference),
Some pdf outline entries called outline entries,
a_ root pdf object (reference),
a_ parent pdf object (reference),
a_ current contents pdf object (reference),
a_ current page pdf object (reference),
a_ current height,
a_ current border color,
a_ current fill color,
a_ font index.

The pdf state is a_ pdf state.

a_ pdf string is a_ string. \ string surrounded by ( ) and has \( for left paren, \) for right paren, \\ for backslash

a_ pen is a_ color.

The pen size is a_ number.

The per-mille-sign byte is a_ byte equal to 137.

a_ percent is a_ number. \ a_ scale with 100 in the denominator

The percent-sign byte is a_ byte equal to 37.

The period byte is a_ byte equal to 46.

\PAL
Para escolher uma luminosidade entre um porcento e outro porcento;
Para escolher uma luminosidade entre uma porcentagem e outra porcentagem;
\CAL
To pick a_ brightness between a_ percent and another percent;
To vary a_ lightness between a_ percent and another percent;
To pick a_ lightness between a_ percent and another percent:
Pick a_ number between the percent and the other percent.
Put the number times 10 into the lightness.
Put the lightness into the context's lightness.

\PAL
Para escolher uma cor acastanhada;
Para escolher uma cor parda;
\CAL
To pick a_ brownish color:
Pick the brownish color's hue between 250 and 350.
Pick the brownish color's saturation between 500 and 1000.
Pick the brownish color's brightness between 125 and 375.
Put the brownish color into the context's color.

To pick a_ brownish color about some percent of the time: \ *** generalize this for all colors
Pick a_ number between 1 and 100.
If the number is greater than the percent, exit.
Pick the brownish color.
Put the brownish color into the context's color.

\PAL
Para escolher uma cor;
\CAL
To pick a_ color:
Pick the color's hue between 0 and 3600.
Pick the color's saturation between 0 and 1000.
Pick the color's lightness between 0 and 1000.
Put the color into the context's color.

\PAL
Para escolher uma cor entre outra cor e uma terceira cor;
\CAL
To pick a_ color between another color and a_ third color:
Pick the color's hue between the other color's hue and the third color's hue.
Pick the color's saturation between the other color's saturation and the third color's saturation.
Pick the color's lightness between the other color's lightness and the third color's lightness.
Put the color into the context's color.

\PAL
Para escolher uma cor como outra cor;
\CAL
To pick a_ color like another color:
Put the other color into the color.
Pick a_ number between -100 and 100.
Add the number to the color's hue.
Limit the color's hue to 0 and 3599.
Set the color's saturation to something between 100 and 1000.
Set the color's lightness to something between 0 and 800.
Put the color into the context's color.

\PAL
Para escolher uma cor escura;
\CAL
To pick a_ dark color:
Pick the dark color's hue between 0 and 3599.
Put 1000 into the dark color's saturation.
Put 375 into the dark color's lightness.
Put the dark color into the context's color.

\PAL
Para escolher uma cor esverdeada;
\CAL
To pick a_ greenish color:
Pick the greenish color's hue between 900 and 1200.
Pick the greenish color's saturation between 500 and 1000.
Pick the greenish color's brightness between 250 and 875.
Put the greenish color into the context's color.

To pick a_ greenish color about some percent of the time: \ *** generalize this for all colors
Pick a_ number between 1 and 100.
If the number is greater than the percent, exit.
Pick the greenish color.
Put the greenish color into the context's color.

\PAL
Para escolher uma direção;
\CAL
To pick a_ heading:
Pick the heading between 0 and 3839.
Put the heading into the context's heading.

\PAL
Para escolher uma altura de letra entre alguns twips e alguns outros twips;
\CAL
To pick a_ letter height between some twips and some other twips:
Pick a_ random number between the twips and the other twips.
Put the random number into the letter height.
Put the random number into the context's letter height.

To pick a_ letter of the alphabet:  \ put letter into context? ***
Pick a_ number between 65 and 90.
Put the number into the letter.

\PAL
Para escolher uma cor clara;
\CAL
To pick a_ light color:
Pick the light color's hue between 0 and 3599.
Put 1000 into the light color's saturation.
Put 625 into the light color's lightness.
Put the light color into the context's color.

\PAL
Para escolher um número;
\CAL
To pick a_ number:
Pick the number between 0 and the largest number. 
Put the number into the context's number.

\PAL
Para escolher um número dentro de uma quantidade de outro número;
\CAL
To pick a_ number within an amount of another number:
Pick the number between the other number minus the amount and the other number plus the amount.
Put the number into the context's number.

\PAL
Para escolher uma cor pastel;
\CAL
To pick a_ pastel color:
Pick the pastel color's hue between 0 and 3599.
Put 1000 into the pastel color's saturation.
Put 875 into the pastel color's lightness.
Put the pastel color into the context's color.

\PAL
Para escolher uma furta-cor;
\CAL
To pick a_ rainbow color:
Add 1 to the current rainbow color number.
If the current rainbow color number is greater than 6, put 1 into the current rainbow color number.
If the current rainbow color number is 1, put the red color into the rainbow color.
If the current rainbow color number is 2, put the orange color into the rainbow color.
If the current rainbow color number is 3, put the yellow color into the rainbow color.
If the current rainbow color number is 4, put the green color into the rainbow color.
If the current rainbow color number is 5, put the blue color into the rainbow color.
If the current rainbow color number is 6, put the purple color into the rainbow color.
Put the rainbow color into the context's color.

\PAL
Para escolher uma cor sólida;
\CAL
To pick a_ solid color:
Pick the solid color's hue between 0 and 3599.
Put 1000 into the solid color's saturation.
Put 500 into the solid color's lightness.
Put the solid color into the context's color.

To pick a_ spot anywhere in the bottom a_ fraction of a_ box;
To pick a_ spot in the bottom a_ fraction of a_ box:
Privatize the box.
Put the box's height times the fraction into some twips.
Put the box's bottom minus the twips into the box's top.
Pick the spot in the box.

\PAL
Para escolher um loco em qualquer lugar em uma caixa;
\CAL
To pick a_ spot anywhere in a_ box:
Pick the spot's x-coord between the box's left and the box's right.
Pick the spot's y-coord between the box's top and the box's bottom.
Put the spot into the context's spot.

To pick a_ spot anywhere in the middle a_ fraction of a_ box;
To pick a_ spot in the middle a_ fraction of a_ box:
Privatize the box.
Put the box's center's y-coord into a_ coord.
Put the box's height times the fraction divided by 2 into a_ number.
Put the coord minus the number into the box's top.
Put the coord plus the number into the box's bottom.
Pick the spot in the box.

To pick a_ spot anywhere in the top half of a_ box;
To pick a_ spot in the top half of a_ box:
Privatize the box.
Put the box's center's y-coord into the box's bottom.
Pick the spot in the box.

To pick a_ spot anywhere in the top middle a_ fraction of a_ box;
To pick a_ spot in the top middle a_ fraction of a_ box:
Privatize the box.
Put the box's center's y-coord into a_ coord.
Put the box's height times the fraction into a_ number.
Put the coord minus the number into the box's top.
Put the coord into the box's bottom.
Pick the spot in the box.

To pick a_ spot anywhere on a_ horizontal line;
To pick a_ spot on a_ horizontal line:
Pick the spot's x-coord between the horizontal line's start's x-coord and the horizontal line's end's x-coord.
Put the horizontal line's y-coord into the spot's y-coord.

\PAL
Para escolher um loco em uma caixa;
\CAL
To pick a_ spot in a_ box:
Pick the spot's x-coord between the box's left and the box's right.
Pick the spot's y-coord between the box's top and the box's bottom.
Put the spot into the context's spot.

To pick a_ spot in a_ box about some twips above the middle;
To pick a_ spot in a_ box about some twips above the center:
Put the box into a_ bounding box.
Put the twips divided by 2 into some other twips.
Put the box's center's y-coord minus the other twips into the bounding box's bottom.
Put the bounding box's bottom minus the twips into the bounding box's top.
Pick the spot anywhere in the bounding box.

To pick a_ spot in a_ box about some twips below the middle;
To pick a_ spot in a_ box about some twips below the center:
Put the box into a_ bounding box.
Put the twips divided by 2 into some other twips.
Put the box's center's y-coord plus the other twips into the bounding box's top.
Put the bounding box's top plus the twips into the bounding box's bottom.
Pick the spot anywhere in the bounding box.

To pick a_ spot in a_ box some twips to some other twips above the middle;
To pick a_ spot in a_ box some twips to some other twips above the center:
Put the box into a_ bounding box.
Put the box's center's y-coord minus the twips into the bounding box's bottom.
Put the bounding box's bottom minus the other twips into the bounding box's top.
Pick the spot anywhere in the bounding box.

To pick a_ spot in a_ box some twips to some other twips below the middle;
To pick a_ spot in a_ box some twips to some other twips below the center:
Put the box into a_ bounding box.
Put the box's center's y-coord plus the twips into the bounding box's top.
Put the bounding box's top plus the other twips into the bounding box's bottom.
Pick the spot anywhere in the bounding box.

\PAL
Para escolher um loco usando uma distância e outro loco;
\CAL
To pick a_ spot within a_ distance of another spot:
Pick the spot's x-coord within the distance of the other spot's x-coord.
Pick the spot's y-coord within the distance of the other spot's y-coord.
Put the spot into the context's spot.

To pick some twips between some min twips and some other twips; \ are all these necessary? ***
To pick a_ number between some min twips and some other twips;
To pick a_ number between a_ min number and a_ max number;
To pick a_ number from a_ min number to a_ max number;
To set a_ number to something between another number and a_ third number;
Para elegir un número entre otro número y un tercer número;
To pick a_ random number between a_ min number and a_ max number:
Put the seed's whereabouts into eax.
\ put address of randseed into ecx
Intel $8BC8. \ mov ecx,eax
\ calculate zero based max
Intel $8B8510000000. \ mov eax,[ebp+16] \ the max
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the min
Intel $2B03. \ sub eax,[ebx]
Intel $40. \ inc eax
\ adjust randseed
Intel $691105840808. \ imul edx,[ecx],134775813
Intel $42. \ inc edx
Intel $8911. \ mov [ecx],edx
\ mul adjusted randseed by the zero based max
Intel $F7E2. \ mul edx
\ add the min to un-zero base the number
Intel $0313. \ add edx,[ebx] the min
\ store the result
Intel $8B9D08000000. \ mov ebx,[ebp+08] \ the random number
Intel $8913. \ mov [ebx],edx
Put the random number into the context's number.

\PAL
Para escolher uma cor muito escura;
\CAL
To pick a_ very dark color;
To pick a_ really dark color:
Pick the really dark color's hue between 0 and 3599.
Put 500 into the really dark color's saturation.
Put 250 into the really dark color's lightness.
Put the really dark color into the context's color.

\PAL
Para escolher uma cor muito clara;
\CAL
To pick a_ very light color;
To pick a_ really light color:
Pick the really light color's hue between 0 and 3599.
Put 1000 into the really light color's saturation.
Put 750 into the really light color's lightness.
Put the really light color into the context's color.

\PAL
Para escolher uma cor escuríssima;
\CAL
To pick a_ very very dark color;
To pick a_ really really dark color:
Pick the really really dark color's hue between 0 and 3599.
Put 500 into the really really dark color's saturation.
Put 125 into the really really dark color's lightness.
Put the really really dark color into the context's color.

\PAL
Para escolher uma cor claríssima;
\CAL
To pick a_ very very light color;
To pick a_ really really light color:
Pick the really really light color's hue between 0 and 3599.
Put 1000 into the really really light color's saturation.
Put 875 into the really really light color's lightness.
Put the really really light color into the context's color.

a_ picture is a_ thing with
\ all boxes are in twits
a_ box [location of cropped picture on the page],
a_ uncropped box [location of entire picture on the page],
a_ grayscale flag,
a_ mirror flag,
a_ rotate angle, \ rotation is clockwise
a_ hex string called data [original bytes in original format],
a_ gpbitmap,
\PAL
uma caixa redefinindo o box.

The pink color is a_ color.

The pink pen is a_ pen.

a_ pixel is 15 twips.

The pizza pie is a_ fraction equal to 355/113.

\PAL
Para tocar um som;
Para reproduzir um som;
\CAL
To play a_ wave:
Call "winmm.dll" "PlaySound" with the wave's first and 0 and 5 [snd_memory+snd_async].

\PAL
Para tocar um som e aguardar;
Para reproduzir um som e aguardar;
\CAL
To play a_ wave and wait:
Call "winmm.dll" "PlaySound" with the wave's first and 0 and 4 [snd_memory+snd_sync].

\PAL
Para tocar um arquivo de som;
Para reproduzir um arquivo de som;
\CAL
To play a_ wave file:
Privatize the wave file.
Null terminate the wave file.
Call "winmm.dll" "PlaySound" with the wave file's first and 0 and 131073 [snd_filename+snd_async].

\PAL
Para tocar um arquivo de som e aguardar;
Para reproduzir um arquivo de som e aguardar;
\CAL
To play a_ wave file and wait:
Privatize the wave file.
Null terminate the wave file.
Call "winmm.dll" "PlaySound" with the wave file's first and 0 and 131072 [snd_filename+snd_sync].

The plus-or-minus byte is a_ byte equal to 177.

The plus-sign byte is a_ byte equal to 43.

a_ point is a_ number [0 to 3839; for dividing a_ circle into compass points; 0 is noon; 960 points per quarter].

a_ pointer has 4 bytes.

a_ polygon is a_ thing with some vertices.

a_ portrait sheet is a_ sheet.

a_ position is a_ pair with
a_ column#,
a_ row#,
\PAL
um número chamado coluna redefinindo a column#,
um número chamado linha redefinindo a row#.

\PAL
Para posicionar um segmento em uma sequência;
\CAL
To position a_ substring on a_ string:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the substring
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the string
\ put the string's first into the substring's first
Intel $8B8B00000000. \ mov ecx,[ebx+0] \ the string's first
Intel $898800000000. \ mov [eax+0],ecx \ the substring's first
\ put the string's first minus 1 into the substring's last
Intel $49. \ dec ecx
Intel $898804000000. \ mov [eax+4],ecx \ the substring's last

To post a_ data string to a_ url and receive a_ response string: \ only works with http and https
Clear the response.
Clear o erro de e/s.
Create a_ winhttp request for_ posting to the url.
If o erro de e/s is not blank, exit.
Send the data to the winhttp request.
If o erro de e/s is not blank, destroy the winhttp request; exit.
Receive the response from the winhttp request.
If o erro de e/s is not blank, destroy the winhttp request; exit.
Read the response from the winhttp request.
If o erro de e/s is not blank, destroy the winhttp request; exit.
Destroy the winhttp request.

The pound-sign byte is a_ byte equal to 163.

a_ poutlinetextmetric is a_ pointer to an outlinetextmetric.

The ppi is some twips.

a_ precise degree is a_ number [0 to 3599].

\PAL
Para prepor um byte a uma sequência;
\CAL
To prepend a_ byte to a_ string:
Put the string's length into a_ saved length.
Reassign the string's first given the string's length plus 1.
Copy bytes from the string's first to the string's first plus 1 for_ the saved length.
Put the string's first plus the saved length into the string's last.
Put the byte into the string's first's target.

\PAL
Para prepor uma sequência a outra sequência;
\CAL
To prepend a_ string to another string:
Put the other string's length plus the string's length into a_ combined length.
Reassign a_ pointer given the combined length.
Put the pointer into a_ substring's first.
Copy bytes from the string's first to the substring's first for_ the string's length.
Add the string's length to the substring's first.
Copy bytes from the other string's first to the substring's first for_ the other string's length.
Unassign the other string's first. \ to avoid extra allocates and copies
Put the pointer into the other string's first.
Put the other string's first plus the combined length minus 1 into the other string's last.

\PAL
Para prepor um elemento a alguns elementos;
\CAL
To prepend a_ thing to some things:
If the thing is nil, exit.
Put the things' first into the thing's next.
If the things is not empty, put the thing into the things' first's previous.
If the things are empty, put the thing into the things' last.
Put the thing into the things' first.

\To prepend some things to some other things: \ bug found by Mike Gonta - corrected version below
\Get a_ thing from the things (backwards).
\If the thing is nil, exit.
\Remove the thing from the things.
\Prepend the thing to the other things.
\Repeat.

\PAL
Para prepor alguns elementos a alguns outros elementos;
\CAL
To prepend some things to some other things:
Put the things' last into a_ thing.
If the thing is nil, exit.
Remove the thing from the things.
Prepend the thing to the other things.
Repeat.

The print-screen key is a_ key equal to 44.

a_ printdlgex is a_ record with
a_ number called lstructsize,
a_ window called hwndowner,
a_ handle called hdevmode,
a_ handle called hdevnames,
a_ canvas called hdc,
a_ number called flags,
a_ number called flags2,
a_ number called exclusionflags,
a_ number called npageranges,
a_ number called nmaxpageranges,
a_ pointer called lppageranges,
a_ number called nminpage,
a_ number called nmaxpage,
a_ number called ncopies,
a_ handle called hinstance,
a_ pointer called lpprinttemplatename,
a_ pointer called lpcallback,
a_ number called npropertypages,
a_ pointer called lphpropertypages,
a_ number called nstartpage,
a_ number called dwresultaction.

The printer canvas is a_ canvas.

The printer device mode handle is a_ handle.

a_ process is a_ handle.

a_ process pointer is a_ pointer to a_ process.

a_ processinfo is a_ record with
a_ handle called hprocess,
a_ handle called hthread,
a_ number called dwprocessid,
a_ number called dwthreadid.

a_ punch line is a_ string.

The purple color is a_ color.

The purple pen is a_ pen.

To put the actual data of a_ font into a_ buffer: \ only works with true/open type fonts
Create the hfont of the memory canvas given the font.
Call "gdi32.dll" "GetFontData" with the memory canvas and 0 and 0 and nil and 0 returning a_ count.
Reassign the buffer's first given the count.
Call "gdi32.dll" "GetFontData" with the memory canvas and 0 and 0 and the buffer's first and the count.
Put the buffer's first plus the count minus 1 into the buffer's last.
Destroy the hfont of the memory canvas.

\PAL
Para pôr a base que pertence a uma caixa numa reta horizontal;
Para pôr a base pertencente a uma caixa numa reta horizontal;
\CAL
To put the bottom of a_ box into a_ horizontal line;
To put the bottom edge of a_ box into a_ horizontal line;
To put the bottom side of a_ box into a_ horizontal line:
Put the box's left-bottom into the horizontal line's start.
Put the box's right-bottom into the horizontal line's end.

\PAL
Para pôr a base que pertence a uma caixa numa reta;
Para pôr a base pertencente a uma caixa numa reta;
\CAL
To put the bottom of a_ box into a_ line:
Make the line with the box's left-bottom and the box's right-bottom.

\PAL
Para pôr uma caixa e um raio numa caixa arredondada;
\CAL
To put a_ box and a_ radius into a_ roundy box:
Put the box's left into the roundy box's left.
Put the box's top into the roundy box's top.
Put the box's right into the roundy box's right.
Put the box's bottom into the roundy box's bottom.
Put the radius into the roundy box's radius.

\PAL
Para pôr uma caixa no centro de outra caixa;
Para centralizar uma caixa em outra caixa;
\CAL
To put a_ box in the center of another box;
To center a_ box in another box:
Center the box in the other box (horizontally).
Center the box in the other box (vertically).

To put a_ box in the center of the screen;
To center a_ box on the screen:
Center the box in the screen's box.

\PAL
Para pôr uma caixa em outra caixa;
\CAL
To put a_ box into another box:
Put the box's left into the other box's left.
Put the box's top into the other box's top.
Put the box's right into the other box's right.
Put the box's bottom into the other box's bottom.

\PAL
Para pôr uma caixa em um loco;
Para centralizar uma caixa em um loco;
\CAL
To put a_ box on a_ spot;
To center a_ box on a_ spot:
Get a_ difference between the spot and the box's center.
Round the difference to the nearest multiple of the tpp.
Move the box given the difference.

\PAL
Para centralizar uma caixa alguns twips por outros twips em outra caixa;
\CAL
To put a_ box some twips by some other twips in the center of another box;
To center a_ box some twips by some other twips in another box:
Make the box the twips by the other twips.
Center the box in the other box.

To put a_ box's bottom line into a_ horizontal line: \ and "vertical" for left and right
Put the box's left and the box's bottom into the horizontal line's start.
Put the box's right and the box's bottom into the horizontal line's end.

To put a_ box's bottom-center into a_ spot: \ *** need these without dashs too
Put the box's center's x-coord into the spot's x-coord.
Put the box's bottom into the spot's y-coord.

\PAL
Para pôr o centro de uma caixa em um loco;
\CAL
To put a_ box's center into a_ spot:
Put the box's left plus the box's right into the spot's x-coord.
Put the box's top plus the box's bottom into the spot's y-coord.
Divide the spot by 2.

To put a_ box's center-bottom into a_ spot:
Put the box's center's x-coord into the spot's x-coord.
Put the box's bottom into the spot's y-coord.

To put a_ box's center-top into a_ spot:
Put the box's center's x-coord into the spot's x-coord.
Put the box's top into the spot's y-coord.

\PAL
Para pôr a altura de uma caixa em uma altura;
\CAL
To put a_ box's height into a_ height:
Put the box's bottom into the height.
Subtract the box's top from the height.
Add the tpp to the height.

To put a_ box's left line into a_ line:
Put the box's left and the box's top into the line's start.
Put the box's left and the box's bottom into the line's end.

To put a_ box's left-bottom into a_ spot:
Put the box's left into the spot's x-coord.
Put the box's bottom into the spot's y-coord.

To put a_ box's left-center into a_ spot:
Put the box's left into the spot's x-coord.
Put the box's center's y-coord into the spot's y-coord.

To put a_ box's right line into a_ line:
Put the box's right and the box's top into the line's start.
Put the box's right and the box's bottom into the line's end.

To put a_ box's right-center into a_ spot:
Put the box's right into the spot's x-coord.
Put the box's center's y-coord into the spot's y-coord.

To put a_ box's right-top into a_ spot:
Put the box's right into the spot's x-coord.
Put the box's top into the spot's y-coord.

To put a_ box's top line into a_ horizontal line:
Put the box's left and the box's top into the horizontal line's start.
Put the box's right and the box's top into the horizontal line's end.

To put a_ box's top-center into a_ spot:
Put the box's center's x-coord into the spot's x-coord.
Put the box's top into the spot's y-coord.

\PAL
Para pôr a largura de uma caixa em uma largura;
\CAL
To put a_ box's width into a_ width:
Put the box's right into the width.
Subtract the box's left from the width.
Add the tpp to the width.

\PAL
Para pôr a extensão-x de uma caixa em uma largura;
\CAL
To put a_ box's x-extent into a_ width:
Put the box's right into the width.
Subtract the box's left from the width.

\PAL
Para pôr a extensão-y de uma caixa em uma altura;
\CAL
To put a_ box's y-extent into a_ height:
Put the box's bottom into the height.
Subtract the box's top from the height.

\PAL
Para pôr um byte e um número em uma fração;
\CAL
To put a_ byte and a_ number into a_ fraction:
Put the byte into the fraction's numerator.
Put the number into the fraction's denominator.

\PAL
Para pôr um byte em outro byte;
\CAL
To put a_ byte into another byte:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $8A00. \ mov al,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other byte
Intel $8803. \ mov [ebx],al

To put a_ byte into eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the byte
Intel $0FB603. \ movzx eax,byte ptr [ebx]

\PAL
Para pôr um byte em um número;
\CAL
To put a_ byte into a_ number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $0FB600. \ movzx eax,byte ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
Intel $8903. \ mov [ebx],eax

\PAL
Para pôr um byte em uma sequência;
\CAL
To put a_ byte into a_ string:
Put 1 into a_ length.
Reassign the string's first given the length.
Put the byte into the string's first's target.
Put the string's first into the string's last.

\PAL
Para pôr um byte em uma wyrd;
\CAL
To put a_ byte into a_ wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $660FB600. \ movzx eax,byte ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the wyrd
Intel $668903. \ mov [ebx],ah

To put the character under a_ finger into a_ character:
If the finger is nil, clear the character; exit.
Put the finger's target into the character.

\PAL
Para pôr uma cor em outra cor;
\CAL
To put a_ color into another color:
Put the color's hue into the other color's hue.
Put the color's saturation into the other color's saturation.
Put the color's lightness into the other color's lightness.

\PAL
Para pôr uma data/hora em outra data/hora;
\CAL
To put a_ date/time into another date/time:
Put the date/time's year into the other date/time's year.
Put the date/time's month into the other date/time's month.
Put the date/time's week day into the other date/time's week day.
Put the date/time's day into the other date/time's day.
Put the date/time's hour into the other date/time's hour.
Put the date/time's minute into the other date/time's minute.
Put the date/time's second into the other date/time's second.
Put the date/time's millisecond into the other date/time's millisecond.

\PAL
Para pôr uma sequência de data/hora em uma sequência;
\CAL
To put a_ date/time's string into a_ string:
Clear the string.
Append the date/time's year to the string.
Append "/" to the string.
Zero fill the date/time's month given 2 and append it to the string.
Append "/" to the string.
Zero fill the date/time's day given 2 and append it to the string.
Append " " to the string.
Zero fill the date/time's hour given 2 and append it to the string.
Append ":" to the string.
Zero fill the date/time's minute given 2 and append it to the string.
Append ":" to the string.
Zero fill the date/time's second given 2 and append it to the string.
Append ":" to the string.
Zero fill the date/time's millisecond given 3 and append it to the string.

To put eax into a_ byte:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8803. \ mov [ebx],al

To put eax into a_ flag;
To put eax into a_ pointer;
To put eax into a_ number:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8903. \ mov [ebx],eax

To put eax into a_ wyrd:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the wyrd
Intel $668903. \ mov [ebx],ax

\PAL
Para centralizar uma elipse em uma caixa;
\CAL
To put an ellipse in the middle of a_ box;
To center an ellipse in a_ box:
Center the ellipse in the box (horizontally).
Center the ellipse in the box (vertically).

\PAL
Para pôr uma elipse em outra elipse;
\CAL
To put an ellipse into another ellipse:
Put the ellipse's box into the other ellipse's box.

\PAL
Para centralizar uma elipse em um loco;
\CAL
To put an ellipse on a_ spot;
To center an ellipse on a_ spot:
Center the ellipse's box on the spot.

To put a_ finger on the first character of a_ string:
Put the string's first into the finger.

\PAL
Para pôr um ponteiro em outro ponteiro;
Para pôr um número em outro número;
\CAL
To put a_ flag into another flag;
To put a_ flag into a_ number;
To put a_ pointer into a_ number;
To put a_ pointer into another pointer;
To put a_ number into a_ flag;
To put a_ number into a_ pointer;
To put a_ number into another number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
Intel $8903. \ mov [ebx],eax

To put a_ flag into eax;
To put a_ pointer into eax;
To put a_ number into eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the number
Intel $8B03. \ mov eax,[ebx]

\PAL
Para pôr uma signa em uma sequência;
\CAL
To put a_ flag into a_ string;
To convert a_ flag to a_ string:
If the flag is set, put "yes" into the string; exit. \ has to be english for externalized reams
Put "no" into the string.

\PAL
Para pôr uma fonte em outra fonte;
\CAL
To put a_ font into another font:
Put the font's name into the other font's name.
Put the font's height into the other font's height.

To put some font widths into a_ buffer: \ used for pdf conversion
Clear the buffer.
If the font widths are nil, exit.
Put the font widths' data into a_ number pointer.
Loop.
If a_ counter is past the font widths' count, break.
Append the number pointer's target then " " to the buffer.
Add 1 to a_ count.
If the count is evenly divisible by 16, append the crlf string to the buffer.
Add a_ number's magnitude to the number pointer.
Repeat.

To put a_ font's adjusted height into a_ height:
Put the font's height times 3/4 into the height.

\PAL
Para pôr uma fração em outra fração;
\CAL
To put a_ fraction into another fraction:
Put the fraction's numerator into the other fraction's numerator.
Put the fraction's denominator into the other fraction's denominator.

\PAL
Para converter uma fração em uma sequência;
Para pôr uma fração em uma sequência;
\CAL
To put a_ fraction into a_ string;
To convert a_ fraction to a_ string:
Clear the string.
Privatize the fraction.
If the fraction is negative, put "-" into the string; de-sign the fraction.
Reduce the fraction.
Convert the fraction to a_ mixed.
If the mixed is 0, append "0" to the string; exit.
If the mixed's whole number is not 0, append the mixed's whole number to the string.
If the mixed's fraction is 0, exit.
If the string is not blank, append the dash byte to the string.
Append the mixed's numerator then "/" then the mixed's denominator to the string.

To put a_ fraction pair into another fraction pair:
Put the fraction pair's fraction into the other fraction pair's fraction.
Put the fraction pair's other fraction into the other fraction pair's other fraction.

\PAL
Para pôr o valor absoluto de uma fração em outra fração;
\CAL
To put a_ fraction's absolute value into another fraction:
Put the fraction into the other fraction.
De-sign the other fraction.

To put a_ gpimage's gprect into a_ gprect:
Put 0 into the gprect's x-coord.
Put 0 into the gprect's y-coord.
Put the gpimage's width into the gprect's width.
Put the gpimage's height into the gprect's height.

To put a_ gpimage's height into a_ height:
If the gpimage is nil, put 0 into the height; exit.
Call "gdiplus.dll" "GdipGetImageHeight" with the gpimage and the height's whereabouts.

To put a_ gpimage's width into a_ width:
If the gpimage is nil, put 0 into the width; exit.
Call "gdiplus.dll" "GdipGetImageWidth" with the gpimage and the width's whereabouts.

To put a_ gprect into another gprect:
Put the gprect's x-coord into the other gprect's x-coord.
Put the gprect's y-coord into the other gprect's y-coord.
Put the gprect's width into the other gprect's width.
Put the gprect's height into the other gprect's height.

\PAL
Para pôr uma matiz e uma saturação e uma luminosidade em uma cor;
\CAL
To put a_ hue and a_ saturation and a_ lightness into a_ color:
Put the hue into the color's hue.
If the color's hue is not -1, limit the color's hue to 0 and 3599. \ -1 is clear
Put the saturation into the color's saturation.
Limit the color's saturation to 0 and 1000.
Put the lightness into the color's lightness.
Limit the color's lightness to 0 and 1000.

\PAL
Para pôr o contador de um índice em um contador;
\CAL
To put an index's count into a_ count:
Put 0 into the count.
If the index is nil, exit.
Loop.
Get a_ bucket given the index.
If the bucket is nil, exit.
Add the bucket's refers' count to the count.
Repeat.

\PAL
Para pôr o contador de cubos usados de um índice em um contador;
\CAL
To put an index's used bucket count into a_ count:
Put 0 into the count.
If the index is nil, exit.
Loop.
Get a_ bucket given the index.
If the bucket is nil, exit.
If the bucket's refers are empty, repeat.
Add 1 to the count.
Repeat.

\PAL
Para pôr uma esquerda e uma superior e uma direita e uma inferior e um raio em uma caixa arredondada;
\CAL
To put a_ left coord and a_ top coord and a_ right coord and a_ bottom coord and a_ radius into a_ roundy box:
Put the left into the roundy box's left.
Put the top into the roundy box's top.
Put the right into the roundy box's right.
Put the bottom into the roundy box's bottom.
Put the radius into the roundy box's radius.

\PAL
Para pôr uma esquerda e uma superior e uma direita e uma inferior em uma caixa;
\CAL
To put a_ left coord and a_ top coord and a_ right coord and a_ bottom coord into a_ box:
Put the left into the box's left.
Put the top into the box's top.
Put the right into the box's right.
Put the bottom into the box's bottom.

\PAL
Para pôr uma esquerda e uma superior e uma direita e uma inferior em uma elipse;
\CAL
To put a_ left coord and a_ top coord and a_ right coord and a_ bottom coord into an ellipse:
Put the left into the ellipse's left.
Put the top into the ellipse's top.
Put the right into the ellipse's right.
Put the bottom into the ellipse's bottom.

\PAL
Para pôr a esquerda de uma caixa em uma reta vertical;
\CAL
To put the left of a_ box into a_ vertical line;
To put the left edge of a_ box into a_ vertical line;
To put the left side of a_ box into a_ vertical line:
Put the box's left-top into the vertical line's start.
Put the box's left-bottom into the vertical line's end.

To put a_ line in the middle of a_ box;
To center a_ line in a_ box:
Center the line in the box (horizontally).
Center the line in the box (vertically).

To put a_ line into another line:
Put the line's start into the other line's start.
Put the line's end into the other line's end.

To put a_ line's bottom into a_ coord:
Put the line's start's y-coord into the coord.
If the line's end's y-coord is greater than the line's start's y, put the line's end's y-coord into the coord.

To put a_ line's box into a_ box:
Put the line's start into the box's left-top.
Put the line's end into the box's right-bottom.
Normalize the box.

\PAL
Para pôr o centro de uma reta em um loco;
\CAL
To put a_ line's center into a_ spot:
Put the line's start's x-coord plus the line's end's x-coord into the spot's x-coord.
Put the line's start's y-coord plus the line's end's y-coord into the spot's y-coord.
Divide the spot by 2.

To put a_ line's left into a_ coord:
Put the line's start's x-coord into the coord.
If the line's end's x-coord is less than the line's start's x-coord, put the line's end's x-coord into the coord.

To put a_ line's right into a_ coord:
Put the line's start's x-coord into the coord.
If the line's end's x-coord is greater than the line's start's x-coord, put the line's end's x-coord into the coord.

To put a_ line's top into a_ coord:
Put the line's start's y-coord into the coord.
If the line's end's y-coord is less than the line's start's y-coord, put the line's end's y-coord into the coord.

\PAL
Para mascarar abaixo de uma figura;
\CAL
To put masking tape below a_ figure:
If the figure is nil, exit.
If the figure's vertices' count is less than 2, exit.
Copy the figure to another figure.
Put the screen's bottom into a_ spot's y-coord.
Put the figure's last's x-coord into the spot's x-coord.
Append the spot to the other figure.
Put the figure's first's x-coord into the spot's x-coord.
Append the spot to the other figure.
Append the figure's first's spot to the other figure.
Mask inside the other figure.
Destroy the other figure.

\PAL
Para centralizar uma reta em um loco;
\CAL
To put the middle of a_ line on a_ spot;
To center a_ line on a_ spot:
Get a_ difference between the spot and the line's center.
Round the difference to the nearest multiple of the tpp.
Move the line given the difference.

\PAL
Para pôr o loco do mouse em outro loco;
\CAL
To put the mouse's spot into a_ spot:
Call "user32.dll" "GetCursorPos" with the spot's whereabouts.
Call "user32.dll" "ScreenToClient" with the main window and the spot's whereabouts. \ in case window is on another monitor.
Call "gdi32.dll" "DPtoLP" with the screen canvas and the spot's whereabouts and 1.

\PAL
Para pôr um nome e uma altura em uma fonte;
\CAL
To put a_ name and a_ height into a_ font:
Put the name into the font's name.
Put the height into the font's height.

\PAL
Para pôr um nome em uma fonte;
\CAL
To put a_ name into a_ font:
Put the name into the font's name.

\PAL
Para pôr um número e outro número em um par;
\CAL
To put a_ number and another number into a_ pair:
Put the number into the pair's x-number.
Put the other number into the pair's y-number.

To put a_ number into a_ big-endian unsigned wyrd:
Put the number into a_ wyrd.
Put the wyrd into the big-endian unsigned wyrd.

\PAL
Para pôr um número em um byte;
\CAL
To put a_ number into a_ byte:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
Intel $8803. \ mov [ebx],al

\PAL
Para pôr um número em uma fração;
\CAL
To put a_ number into a_ fraction:
Put the number into the fraction's numerator.
Put 1 into the fraction's denominator.

\PAL
Para pôr um número em um par;
\CAL
To put a_ number into a_ pair:
Put the number into the pair's x-number.
Put the number into the pair's y-number.

\PAL
Para pôr um número em uma sequência;
Para converter um número em uma sequência;
\CAL
To put a_ number into a_ string;
To convert a_ number to a_ string:
Clear the string.
Privatize the number.
De-sign the number.
Loop.
Divide the number by 10 giving a_ quotient and a_ remainder.
Add 48 to the remainder.
Put the remainder into a_ byte.
Prepend the byte to the string.
If the quotient is 0, break.
Put the quotient into the number.
Repeat.
If the original number is less than 0, prepend the dash byte to the string.

\PAL
Para pôr um número em uma wyrd;
\CAL
To put a_ number into a_ wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the wyrd
Intel $668903. \ mov [ebx],ax

To put a_ number on the stack:
Convert the number to a_ token.
Put the token on the stack.

\PAL
Para pôr um número e outro número em uma fração;
\CAL
To put a_ number over another number in a_ fraction;
To put a_ number and another number into a_ fraction:
Put the number into the fraction's numerator.
Put the other number into the fraction's denominator.

\PAL
Para pôr o valor absoluto de um número em outro número;
\CAL
To put a_ number's absolute value into another number:
Put the number into the other number.
De-sign the other number.

To put an outlinetextmetric into another outlinetextmetric:
Copy bytes from the outlinetextmetric's whereabouts to the other outlinetextmetric's whereabouts for_ the outlinetextmetric's magnitude.

\PAL
Para pôr um loco em outro loco;
Para pôr um par em outro par;
\CAL
To put a_ pair into another pair:
Put the pair's x-number into the other pair's x-number.
Put the pair's y-number into the other pair's y-number.

\PAL
Para pôr o valor absoluto de um par em outro par;
\CAL
To put a_ pair's absolute value into another pair:
Put the pair into the other pair.
De-sign the other pair.

\PAL
Para centralizar uma imagem em uma caixa;
\CAL
To put a_ picture in the middle of a_ box;
To center a_ picture in a_ box:
If the picture is nil, exit.
Center the picture in the box (horizontally).
Center the picture in the box (vertically).

\PAL
Para centralizar uma imagem em um loco;
\CAL
To put a_ picture on a_ spot;
To center a_ picture on a_ spot:
If the picture is nil, exit.
Get a_ difference between the spot and the picture's box's center.
Round the difference to the nearest multiple of the tpp.
Move the picture given the difference.

\PAL
Para centralizar um polígono em uma caixa;
\CAL
To put a_ polygon in the middle of a_ box;
To center a_ polygon in a_ box:
If the polygon is nil, exit.
Center the polygon in the box (horizontally).
Center the polygon in the box (vertically).

\PAL
Para centralizar um polígono na tela;
\CAL
To put a_ polygon in the middle of the screen;
To center a_ polygon on the screen:
Center the polygon in the screen's box.

\PAL
Para centralizar um polígono em um loco;
\CAL
To put a_ polygon on a_ spot;
To center a_ polygon on a_ spot:
If the polygon is nil, exit.
Get a_ difference between the spot and the polygon's box's center.
Round the difference to the nearest multiple of the tpp.
Move the polygon given the difference.

\PAL
Para pôr uma cixa de polígono em uma caixa;
\CAL
To put a_ polygon's box into a_ box:
If the polygon is nil, zero the box; exit.
If the polygon's vertices are empty, zero the box; exit.
Put the largest number and the largest number and the smallest number and the smallest number into the box.
Loop.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, break.
If the vertex's x-coord is less than the box's left, put the vertex's x-coord into the box's left.
If the vertex's y-coord is less than the box's top, put the vertex's y-coord into the box's top.
If the vertex's x-coord is greater than the box's right, put the vertex's x-coord into the box's right.
If the vertex's y-coord is greater than the box's bottom, put the vertex's y-coord into the box's bottom.
Repeat.

\PAL
Para pôr o centro de uma polígono em um loco;
\CAL
To put a_ polygon's center into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's center into the spot.

To put a_ polygon's center-bottom into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's center-bottom into the spot.

To put a_ polygon's center-top into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's center-top into the spot.

\PAL
Para pôr a altura de uma polígono em uma altura;
\CAL
To put a_ polygon's height into a_ height:
If the polygon is nil, clear the height; exit.
Put the polygon's box's height into the height.

To put a_ polygon's left-bottom into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's left-bottom into the spot.

To put a_ polygon's left-center into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's left-center into the spot.

To put a_ polygon's left-top into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's left-top into the spot.

To put a_ polygon's right-bottom into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's right-bottom into the spot.

To put a_ polygon's right-center into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's right-center into the spot.

To put a_ polygon's right-top into a_ spot:
If the polygon is nil, clear the spot; exit.
Put the polygon's box's right-top into the spot.

\PAL
Para pôr a largura de uma polígono em uma largura;
\CAL
To put a_ polygon's width into a_ width:
If the polygon is nil, clear the width; exit.
Put the polygon's box's width into the width.

To put a_ polygon's x-extent into a_ width:
If the polygon is nil, clear the width; exit.
Put the polygon's box's x-extent into the width.

To put a_ polygon's y-extent into a_ height:
If the polygon is nil, clear the height; exit.
Put the polygon's box's y-extent into the height.

\PAL
Para pôr um iterador em outro iterador;
\CAL
To put a_ rider into another rider:
Copy bytes from the rider's whereabouts to the other rider's whereabouts for_ the rider's magnitude.

\PAL
Para pôr a direita de uma caixa em uma reta vertical;
\CAL
To put the right of a_ box into a_ vertical line;
To put the right edge of a_ box into a_ vertical line;
To put the right side of a_ box into a_ vertical line:
Put the box's right-top into the vertical line's start.
Put the box's right-bottom into the vertical line's end.

\PAL
Para pôr uma caixa arredondada em outra caixa arredondada;
\CAL
To put a_ roundy box into another roundy box:
Put the roundy box's left into the other roundy box's left.
Put the roundy box's top into the other roundy box's top.
Put the roundy box's right into the other roundy box's right.
Put the roundy box's bottom into the other roundy box's bottom.
Put the roundy box's radius into the other roundy box's radius.

To put a_ row's working string into a_ substring:
If the row is nil, clear the substring; exit.
Slap the substring on the row's string.
Subtract 1 from the substring's last.

To put a_ selection into another selection:
Put the selection's anchor into the other selection's anchor.
Put the selection's caret into the other selection's caret.

To put a_ sockaddr into another sockaddr:
Copy bytes from the sockaddr's whereabouts to the other sockaddr's whereabouts for_ the sockaddr's magnitude.

\PAL
Para pôr um loco e outro loco e um raio em uma caixa arredondada;
\CAL
To put a_ spot and another spot and a_ radius into a_ roundy box:
Put the spot into the roundy box's left-top.
Put the other spot into the roundy box's right-bottom.
Put the radius into the roundy box's radius.

\PAL
Para pôr um loco e outro loco em uma caixa;
\CAL
To put a_ spot and another spot into a_ box:
Put the spot into the box's left-top.
Put the other spot into the box's right-bottom.

\PAL
Para pôr um loco e outro loco em uma elipse;
\CAL
To put a_ spot and another spot into an ellipse:
Put the spot into the ellipse's left-top.
Put the other spot into the ellipse's right-bottom.

\PAL
Para pôr um loco e outro loco em uma reta;
\CAL
To put a_ spot and another spot into a_ line:
Put the spot into the line's start.
Put the other spot into the line's end.

\PAL
Para centralizar um loco em uma caixa;
\CAL
To put a_ spot in the middle of a_ box;
To center a_ spot in a_ box:
Center the spot in the box (horizontally).
Center the spot in the box (vertically).

\PAL
Para pôr uma sequência em outra sequência;
\CAL
To put a_ string into another string:
Put the string's length into a_ saved length.
Assign a_ pointer given the saved length.
Copy bytes from the string's first to the pointer for_ the saved length.
Unassign the other string's first.
Put the pointer into the other string's first.
Put the other string's first plus the saved length minus 1 into the other string's last.

To put a_ string into a_ letter:
Put the string's first's target into the letter.

\PAL
Para pôr uma sequência em um texto;
\CAL
To put a_ string into a_ text:
If the text is nil, exit.
Destroy the text's rows.
Reset the origin of the text.
Reset the caret of the text.
Deselect the text.
Privatize the string.
Append the return byte to the string.
Convert the string to the text's rows.
Wrap the text.

\PAL
Para pôr uma sequência na área de transferência do windows;
Para pôr uma sequência na área de transferência do sistema;
\CAL
To put a_ string on the windows clipboard:
Call "user32.dll" "OpenClipboard" with the main window.
Call "user32.dll" "EmptyClipboard".
Put the string's length plus 1 into a_ number.
Call "kernel32.dll" "GlobalAlloc" with 66 [ghnd] and the number returning a_ handle.
Call "kernel32.dll" "GlobalLock" with the handle returning a_ pointer.
Copy bytes from the string's first to the pointer for_ the string's length.
Call "kernel32.dll" "GlobalUnlock" with the handle.
Call "user32.dll" "SetClipboardData" with 1 [cf_text] and the handle.
Call "user32.dll" "CloseClipboard".

\PAL
Para pôr o tamanho de uma sequência em um tamanho;
\CAL
To put a_ string's length into a_ length:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the string
\ load default result
Intel $B900000000. \ mov ecx,0
\ if first is 0, store 0
Intel $833B00. \ cmp [ebx],0
Intel $0F8414000000. \ je store it
\ if last is less than first, store 0
Intel $8B5304. \ mov edx,[ebx+4] \ last pointer
Intel $3B13. \ cmp edx,[ebx]
Intel $0F8C09000000. \ jl store it
\ calc length
Intel $8B8B04000000. \ mov ecx,[ebx+4] \ last pointer
Intel $2B0B. \ sub ecx,[ebx] \ subtract first
Intel $41. \ inc ecx \ add 1
\ STORE IT:
Intel $8B950C000000. \ mov edx,[ebp+12] \ the number
Intel $890A. \ mov [edx],ecx

\PAL
Para pôr a largura de uma sequência numa largura;
\CAL
To put a_ string's width into a_ width:
Get the width given the string and the memory canvas and the default font.

To put a_ substring into another substring:
Copy bytes from the substring's whereabouts to the other substring's whereabouts for_ the substring's magnitude.

\PAL
Para pôr a data/hora do sistema em uma data/hora;
\CAL
To put the system's date/time into a_ date/time:
Call "kernel32.dll" "GetLocalTime" with a_ systemtime's whereabouts.
Put the systemtime's wyear into the date/time's year.
Put the systemtime's wmonth into the date/time's month.
Put the systemtime's wdayofweek into the date/time's week day.
Put the systemtime's wday into the date/time's day.
Put the systemtime's whour into the date/time's hour.
Put the systemtime's wminute into the date/time's minute.
Put the systemtime's wsecond into the date/time's second.
Put the systemtime's wmilliseconds into the date/time's millisecond.

\PAL
Para pôr o último erro do sistema em um número;
\CAL
To put the system's last error into a_ number:
Call "kernel32.dll" "GetLastError" returning the number.

To put the system's last winsock error into a_ number:
Call "ws2_32.dll" "WSAGetLastError" returning the number.

\PAL
Para pôr os tiques do sistema em alguns tiques;
\CAL
To put the system's tick count into some ticks: \ wraps every 24.8 days or so
Call "kernel32.dll" "GetTickCount" returning the ticks.
Bitwise and the ticks with the largest number.

\PAL
Para pôr um terminal no meio de uma caixa;
Para centralizar um terminal numa caixa;
\CAL
To put a_ terminal in the middle of a_ box;
To center a_ terminal in a_ box:
Privatize the box.
Indent the box 1/4 inch.
Put the box into the terminal's box.

\PAL
Para pôr um texto no meio de uma caixa;
Para centralizar um texto numa caixa;
\CAL
To put a_ text in the middle of a_ box;
To center a_ text in a_ box:
If the text is nil, exit.
Center the text in the box (horizontally).
Center the text in the box (vertically).

\PAL
Para pôr um texto num loco;
Para centralizar um texto num loco;
\CAL
To put a_ text on a_ spot;
To center a_ text on a_ spot:
If the text is nil, exit.
Get a_ difference between the spot and the text's box's center.
Round the difference to the nearest multiple of the tpp.
Move the text given the difference.

To put a_ text's first line into a_ string:
If the text is nil, clear the string; exit.
Put the text's first row's string into the string.
Remove the last byte from the string.

To put a_ text's first non-blank line into a_ string: \ *** new
Clear the string.
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
Put the row's string into the string.
Remove the last byte from the string. \ cr or space (see text rules)
Remove any leading noise from the string.
Remove any trailing noise from the string.
If the string is blank, repeat.

To put a_ text's globalized origin into a_ spot:
If the text is nil, clear the spot; exit.
Put the text's origin into the spot.
Globalize the spot given the text's left-top.

To put a_ text's grid into a_ grid:
If the text is nil, clear the grid; exit.
Put the text's font's height times 4 into the grid's x-number.
Put the text's font's height into the grid's y-number.

To put a_ text's normalized selection into a_ selection:
If the text is nil, exit.
Put the text's selection into the selection.
Normalize the selection.

To put a_ text's row count into a_ count:
If the text is nil, put 0 into the count; exit.
If the text's rows are empty, put 0 into the count; exit.
Put the text's rows' last's row# into the count.

To put a_ text's row height into a_ height:
If the text is nil, put 0 into the height; exit.
Put the text's font's height into the height.

To put a_ text's rows/box into a_ count:
If the text is nil, put 0 into the count; exit.
Put the text's box's height divided by the text's row height into the count.

To put a_ text's selected byte count into a_ count:
Put 0 into the count.
If the text is nil, exit.
If nothing is selected in the text, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
Slap a_ substring on any selected bytes in the row of the text.
Add the substring's length to the count.
Repeat.

To put a_ text's selected row count into a_ count:
Put 0 into the count.
If the text is nil, exit.
Put the text's normalized selection into a_ selection.
If the selection's anchor row# is the selection's caret row#, exit.
Put the selection's caret row# into the count.
Subtract the selection's anchor row# from the count.
If the selection's caret column# is not 1, add 1 to the count.

To put a_ text's status string into a_ string:
If the text is nil, clear the string; exit.
Put the text's selected row count into a_ count.
If the count is not 0, format the count and "línea" or "líneas" into the string; exit.
Put the text's selected byte count into another count.
If the other count is not 0, format the other count and "byte" or "bytes" into the string; exit.
Convert the text's caret row# to the string.
Append ":" to the string.
Append the text's caret column# to the string.

\PAL
Para pôr um elemento no final de alguns elementos;
Para pospor um elemento a alguns elementos;
\CAL
To put a_ thing at the end of some things;
To append a_ thing to some things:
If the thing is nil, exit.
Put the things' last into the thing's previous.
If the things are not empty, put the thing into the things' last's next.
If the things are empty, put the thing into the things' first.
Put the thing into the things' last.

\PAL
Para pôr alguns elementos em alguns outros elementos;
\CAL
To put some things into some other things:
Put the things' first into the other things' first.
Put the things' last into the other things' last.

\PAL
Para pôr o contador de alguns elementos em um contador;
\CAL
To put some things' count into a_ count:
Put 0 into the count.
Loop.
Get a_ thing from the things.
If the thing is nil, exit.
Add 1 to the count.
Repeat.

\PAL
Para converter um temporizador em uma sequência;
Para pôr um temporizador em uma sequência;
\CAL
To put a_ timer into a_ string;
To convert a_ timer to a_ string:
Convert the timer's ticks to the string.

\PAL
Para pôr a sequência de um temporizador em uma sequência;
\CAL
To put a_ timer's string into a_ string:
Convert the timer's ticks to the string.

\PAL
Para pôr os tiques de um temporizador em alguns tiques;
\CAL
To put a_ timer's ticks into some ticks:
Put the timer's total ticks into the ticks.
If the timer's count is 0, exit.
Put the system's tick count into some other ticks.
Subtract the timer's start ticks from the other ticks.
Add the other ticks to the ticks.

To put a_ token on the stack:
Allocate memory for_ an stack entry.
Put the token into the stack entry's string.
Prepend the stack entry to the stack.

To put the top of a_ box into a_ horizontal line;
To put the top edge of a_ box into a_ horizontal line;
To put the top side of a_ box into a_ horizontal line:
Put the box's left-top into the horizontal line's start.
Put the box's right-top into the horizontal line's end.

To put the top of a_ box into a_ line:
Make the line with the box's left-top and the box's right-top.

\PAL
Para pôr uma wyrd em outra wyrd;
\CAL
To put a_ wyrd into another wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
Intel $668B00. \ mov ax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other wyrd
Intel $668903. \ mov [ebx],ax

To put a_ wyrd into a_ big-endian unsigned wyrd:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
Intel $668B00. \ mov ax,word ptr [eax]
Intel $86E0. \ xchg al,ah
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the big-endian unsigned wyrd
Intel $668903. \ mov word ptr [ebx],ax

\PAL
Para pôr uma wyrd em um byte;
\CAL
To put a_ wyrd into a_ byte:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
Intel $668B00. \ mov ax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
Intel $8803. \ mov [ebx],al

To put a_ wyrd into eax:
Intel $8B9D08000000. \ mov ebx,[ebp+8] \ the wyrd
Intel $0FBF03. \ movsx eax,word ptr [ebx]

\PAL
Para pôr uma wyrd em um número;
\CAL
To put a_ wyrd into a_ number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
Intel $0FBF00. \ movsx eax,wyrd ptr [eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
Intel $8903. \ mov [ebx],eax

a_ x-coord is a_ coord.
a_ y-coord is a_ coord.

\PAL
Para pôr uma coordenada-x e uma coordenada-y e outra coordenada-x e outra coordenada-y em uma reta;
\CAL
To put an x-coord and a_ y-coord and another x-coord and another y-coord into a_ line:
Put the x-coord into the line's start's x-coord.
Put the y-coord into the line's start's y-coord.
Put the other x-coord into the line's end's x-coord.
Put the other y-coord into the line's end's y-coord.

The q-key is a_ key equal to 81.

a_ query byte is a_ query string.

a_ query string is a_ string.

The question-mark byte is a_ byte equal to 63.

\PAL
Para sair;
Para abandonar;
\CAL
To quit;
To tell Windows we're done;
To tell Windows the user has quit;
To relinquish control:
Flush the event queue.
Create an event.
Put "done" into the event's kind.
Put "feito" into the event's tipo.
Enque the event.

a_ quora is a_ thing with a_ string and a_ color. \ quora is short for "question or answer"

\PAL
Para citar uma sequência;
Para incluir as aspas em uma sequência;
\CAL
To quote a_ string: \ inserts leading, trailing and nested double-quotes
Put the double-quote byte into another string.
Slap a_ substring on the string.
Loop.
If the substring is blank, break.
Append the substring's first's target to the other string.
If the substring's first's target is the double-quote byte, append the double-quote byte to the other string.
Add 1 to the substring's first.
Repeat.
Append the double-quote byte to the other string.
Put the other string into the string.

a_ quotient is a_ number.

The r-key is a_ key equal to 82.

a_ radius is some twips.

a_ rainbow color is a_ color.

\PAL
Para elevar um número a outro número;
\CAL
To raise a_ number to another number:
If the other number is 0, put 1 into the number; exit.
If the other number is less than 0, put 0 into the number; exit. \ should be 1/the raised result, but always comes out 0 with numbers
Put 1 into a_ result number.
Loop.
If a_ counter is past the other number, break.
Multiply the result by the number.
Repeat.
Put the result into the number.

a_ random number is a_ number.

a_ ratio is a_ fraction.

a_ ratio pair is a_ fraction pair.

To read the bible:
If the bible is not nil, exit.
Extract a_ directory from the module's path.
Loop.
If the directory is blank, exit.
Put the directory then "bible.txt" into a_ path.
If the path is in the file system, read the bible given the path; exit.
Extract the directory from the directory.
Repeat.

\PAL
Para ler a Bíblia dada uma rota;
\CAL
To read the bible given a_ path:
If the bible is not nil, exit.
Read the path into a_ buffer.
If o erro de e/s is not blank, exit.
Allocate memory for_ the Bible.
Slap a_ rider on the buffer.
Loop.
If the rider's source is blank, exit.
Allocate memory for_ a_ verse. Append the verse to the Bible's verses.
Move the rider (text file rules).
Put the rider's token into the verse's string.
Remove any leading noise from the verse's string. 
Remove any trailing noise from the verse's string.
Repeat.

\PAL
Para ler um byte de um console;
\CAL
To read a_ byte from a_ console:
Read a_ string from the console.
If the string is blank, put the null byte into the byte; exit.
Put the string's first's target into the byte.

\PAL
Para ler um console em uma sequência;
\CAL
To read a_ console into a_ string:
If the console is nil, clear the string; exit.
Flush all events.
Clear the console's reply.
Show the console.
Handle events given the console.
Put the console's reply into the string.
Flush all events.
Refresh the cursor.

\PAL
Para ler um arquivo em um depósito;
\CAL
To read a_ file into a_ buffer:
Clear o erro de e/s.
Call "kernel32.dll" "GetFileSize" with the file and nil returning a_ size.
Reassign the buffer's first given the size.
Put the buffer's first plus the size minus 1 into the buffer's last.
Call "kernel32.dll" "ReadFile" with the file and the buffer's first and the size and a_ number's whereabouts and 0 returning a_ result number.
If the result number is 0, put "Error leyendo archivo." into o erro de e/s; exit.

To read a_ flag from a_ console:
Read a_ string from the console.
Convert the string to the flag.

\PAL
Para ler uma fração de um console;
\CAL
To read a_ fraction from a_ console:
Read a_ string from the console.
Convert the string to the fraction.

\PAL
Para ler um número de um console;
\CAL
To read a_ number from a_ console:
Read a_ string from the console.
Convert the string to the number.

\PAL
Para carregar uma rota em um depósito;
Para ler um rota em um depósito;
\CAL
To load a_ path into a_ buffer;
To read a_ path into a_ buffer:
Clear o erro de e/s.
Privatize the path.
Null terminate the path.
If the path is not in the file system, put "Archivo '" then the path then "' no existe." into o erro de e/s; exit.
\  set the path to read-write mode.
Call "kernel32.dll" "CreateFileA" with the path's first and -2147483648 [generic_read] and 3 [file_share_read+file_share_write] and 0 
And 3 [open_existing] and 0 and 0 returning a_ handle.
If the handle is -1 [invalid_handle_value], put "Error abriendo archivo '" then the path then "'." into o erro de e/s; exit.
Call "kernel32.dll" "GetFileSize" with the handle and nil returning a_ size.
Reassign the buffer's first given the size.
Put the buffer's first plus the size minus 1 into the buffer's last.
Call "kernel32.dll" "ReadFile" with the handle and the buffer's first and the size and a_ number's whereabouts and 0 returning the number.
Call "kernel32.dll" "CloseHandle" with the handle.
If the number is not 0, exit.
Put "Error leyendo archivo '" then the path then "'." into o erro de e/s.

\PAL
Para carregar uma rota em uma imagem;
Para ler uma rota em uma imagem;
\CAL
To load a_ path into a_ picture:
To read a_ path into a_ picture:
Read the path into a_ buffer.
If o erro de e/s is not blank, void the picture; exit.
Create the picture given the buffer.

\PAL
Para ler uma resposta de um terminal;
\CAL
To read a_ reply from a_ terminal:
If the terminal is nil, clear the reply; exit.
Flush all events.
Clear the terminal's reply.
Add a_ quora to the terminal.
Put "> " into the quora's string.
Put the terminal's input color into the quora's color.
Show the terminal.
Handle events given the terminal.
\  show the terminal.
Put the terminal's reply into the reply.
Remove any leading noise from the reply.
Remove any trailing noise from the reply.
Flush all events.
\ questionable below
Create an event.
Put "left click" into the event's kind.
Put "clique" into the event's tipo.
Put the mouse's spot into the event's spot.
Enque the event.
Refresh the cursor.

To read a_ response string from a_ winhttp request:
If the winhttp request is nil, exit.
Clear the response.
Put 8 kilobytes into a_ buffer size.
Loop.
Put 0 into a_ size.  
Call "winhttp.dll" "WinHttpQueryDataAvailable"
With the winhttp request's request and the size's whereabouts returning a_ result number.
If the result is 0, put "No se pudo consultar los datos disponibles." into o erro de e/s; clear the response; break.
Put the response's length into a_ saved length.
Reassign the response's first given the saved length plus the buffer size.
Put the response's first plus the saved length into a_ pointer.
Call "winhttp.dll" "WinHttpReadData" with the winhttp request's request and the pointer
And the buffer size and a_ count's whereabouts returning the result number.
If the result number is 0, put "Error leyendo datos." into o erro de e/s; clear the response; break.
Put the pointer plus the count minus 1 into the response's last.
If the count is 0, break.
Repeat.

To read stdin into a_ buffer:
Clear o erro de e/s.
Clear the buffer.
Find a_ string given the environment variables and "CONTENT_LENGTH".
If the string is blank, put "Error obteniendo 'CONTENT_LENGTH'." into o erro de e/s; exit.
Convert the string into a_ length.
If the length is 0, exit.
Reassign the buffer's first given the length.
Call "kernel32.dll" "ReadFile" with the stdin handle and the buffer's first and the length and a_ number's whereabouts and nil.
If the number is not the length, put "Error leyendo datos 'stdin'." into o erro de e/s; clear the buffer; exit.
Put the buffer's first plus the length minus 1 into the buffer's last.

\PAL
Para ler uma sequência de um console;
\CAL
To read a_ string from a_ console:
Read the console into the string.

\PAL
Para carregar uma URL em um depósito;
Para ler uma URL em um depósito;
\CAL
To read a_ url into a_ buffer:
\ prepare
Clear the buffer.
Clear o erro de e/s.
\ internet open
Call "wininet.dll" "InternetOpenA" with the module's name's first and 0 [internet_open_type_preconfig] and nil and nil returning a_ internet handle.
If the internet handle is 0, put "No pude conectarme a internet." into o erro de e/s; exit.
\ internet open url
Privatize the url.
Null terminate the url.
Call "wininet.dll" "InternetOpenUrlA" with the internet handle and the url's first and nil and 0 and 0 and 0 returning a_ url handle.
If the url handle is 0, put "No pude conectarme a url '" then the url then "'." into o erro de e/s; call "wininet.dll" "InternetCloseHandle" with the internet handle; exit.
\ read the file
Put 64 kilobytes into a_ buffer size.
Loop.
Put the buffer's length into a_ saved length.
Reassign the buffer's first given the saved length plus the buffer size.
Put the buffer's first plus the saved length into a_  pointer.
Call "wininet.dll" "InternetReadFile" with the url handle and the pointer and the buffer size and a_ count's whereabouts returning a_ result number.
If the result number is 0, put "Error leyendo url '" then the url then "'." into o erro de e/s; break.
Put the pointer plus the count minus 1 into the buffer's last.
If the count is 0, break.
Repeat.
\ clean up
Call "wininet.dll" "InternetCloseHandle" with the url handle.
Call "wininet.dll" "InternetCloseHandle" with the internet handle.

a_ really dark color is a_ color.

a_ really light color is a_ color.

a_ really really dark color is a_ color.

a_ really really light color is a_ color.

To reassign a_ pointer given a_ byte count:
If the pointer is nil, assign the pointer given the byte count; exit.
If the byte count is 0, unassign the pointer; exit.
Privatize the byte count.
Round the byte count up to the nearest power of two.
Call "kernel32.dll" "HeapReAlloc" with the heap pointer and 8 [heap_zero_memory] and the pointer and the byte count returning the pointer.

To receive a_ buffer from a_ socket:
Clear o erro de e/s.
Clear the buffer.
Put 8 kilobytes into a_ buffer size.
Loop.
Put 0 into a_ size.  
Put the buffer's length into a_ saved length.
Reassign the buffer's first given the saved length plus the buffer size.
Put the buffer's first plus the saved length into a_  pointer.
Call "ws2_32.dll" "recv" with the socket and the pointer and the buffer size and 0 returning a_ count.
If the count is not -1 [socket_error], put the pointer plus the count minus 1 into the buffer's last; exit.
If the system's last winsock error is not 10040 [wsamsgsize], put "Error recibiendo datos." into o erro de e/s; clear the buffer; exit.
Put the pointer plus the count minus 1 into the buffer's last.
Repeat.

To receive the response from a_ winhttp request:
If the winhttp request is nil, exit.
Call "winhttp.dll" "WinHttpReceiveResponse"
With the winhttp request's request
And 0
Returning a_ result number.
If the result is 0, put "No pude enviar el pedido." into o erro de e/s; exit.

a_ recipient is a_ string.

The record-separator byte is a_ byte equal to 30.

a_ rectangle is a_ figure.
a_ skinny rectangle is a_ rectangle.
a_ diamond is a_ figure.
a_ desert landscape is a_ thing.
An octagon is a_ figure.
An arc is a_  figure.
a_ circle is a_  figure.
a_ fractal forest is a_ thing.
a_ joke is a_ thing.
a_ triangle is a_  figure.
a_ heptagon is a_ figure. \ 7 sides
a_ nonagon is a_ figure. \ 9 sides
a_ decagon is a_ figure. \ 10 sides
a_ hexagon is a_ figure.
a_ koch curve is a_ figure.
a_ twelve-sided figure is a_ figure.
a_ half circle is a_ figure.
a_ half circle flower is a_ figure.
a_ quarter circle is a_ figure.
a_ spiral is a_ figure.
a_ leaf is a_ figure.
a_ half leaf is a_ figure.
a_ five pointed star is a_ figure.
a_ six pointed star is a_ figure.
a_ left crescent is a_ figure.
a_ right crescent is a_ figure.
a_ pentagon is a_ figure.
a_ solid is a_ figure.
a_ star is a_ thing.
a_ cube is a_ figure.
a_ yew tree is a_ figure.
a_ tree is a_ figure.

The red color is a_ color.

The red pen is a_ pen.

\PAL
Para reduzir uma fração;
\CAL
To reduce a_ fraction:
Get a_ gcd given the fraction's numerator and the fraction's denominator.
Divide the fraction's numerator by the gcd.
Divide the fraction's denominator by the gcd.

a_ refer is a_ thing with 
a_ string
and a_ pointer (reference)
\PAL
e uma sequência at the string
e um ponteiro (referência) at the pointer.

\PAL
Para atualizar o cursor;
\CAL
To refresh the cursor:
Create an event.
Put "set cursor" into the event's kind.
Put "definir cursor" into the event's tipo.
If the alt key is down, set the event's alt flag.
If the ctrl key is down, set the event's ctrl flag.
If the shift key is down, set the event's shift flag.
Put the mouse's spot into the event's spot.
Enque the event.

\PAL
Para atualizar a tela dada uma caixa;
\CAL
To refresh the screen given a_ box:
Call "gdi32.dll" "BitBlt" with the screen canvas and the box's left and the box's top and the box's width and the box's height 
And the current canvas and the box's left and the box's top and 13369376 [srccopy].

The registered byte is a_ byte equal to 174.

The registered-trade-mark byte is a_ byte equal to 174.

a_ remainder is a_ number.

\PAL
Para recordar um texto;
\CAL
To remember a_ text:
If the text is nil, exit.
Destroy the text's redos.
Copy the text into another text.
Scale the other text to 1/1.
Append the other text to the text's undos.
Limit the text's undos to the max text undos.
Set the text's modified flag.

\PAL
Para recordar um texto com uma operação;
\CAL
To remember a_ text with an operation:
If the text is nil, exit.
If the text's last operation is the operation, set the text's modified flag; exit.
Remember the text.
Put the operation into the text's last operation.

\PAL
Para recordar onde estamos;
\CAL
To remember where we are:
Save the context.

The remembered pdf path is a_ path.

To remove any selected bytes in a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Put the text's selection into a_ selection.
Normalize the selection.
Get a_ row given the selection's anchor row# and the text.
Slap a_ substring on the row's string.
Put the substring's first plus the selection's anchor column# minus 2 into the substring's last.
Get another row given the selection's caret row# and the text.
Slap another substring on the other row's string.
Put the other substring's first plus the selection's caret column# minus 1 into the other substring's first.
Put the substring then the other substring into the row's string.
Remove the rows of the text between the row's next and the other row.
Put the selection's anchor into the text's caret.
Deselect the text.

To remove any trailing backslash from a_ string:
If the string is blank, exit.
If the string's last's target is not the backslash byte, exit.
Remove the last byte from the string.

To remove any trailing linefeed byte from a_ string:
If the string is blank, exit.
If the string's last's target is not the linefeed byte, exit.
Remove the last byte from the string.

To remove any trailing return byte from a_ string:
If the string is blank, exit.
If the string's last's target is not the return byte, exit.
Remove the last byte from the string.

\PAL
Para remover um byte de uma sequência dada um segmento;
\CAL
To remove bytes from a_ string given a_ substring:
If the string is blank, exit.
If the substring is blank, exit.
Put the string's last minus the substring's last into a_ length.
Put the substring's last plus 1 into a_ pointer.
Copy bytes from the pointer to the substring's first for_ the length.
Put the string's length minus the substring's length into a_ new length.
Reassign the string's first given the new length.
Put the string's first plus the new length minus 1 into the string's last.

To remove bytes from a_ text (backspace over a return):
If the text is nil, exit.
If the text's caret row# is 1, exit.
Get a_ row given the text's caret row# minus 1 and the text.
Put the row's string's length and the text's caret row# minus 1 into the text's caret.
Remove any selected bytes in the text.

To remove bytes from a_ text (backspace with jump):
If the text is nil, exit.
If something is selected in the text, remove any selected bytes in the text; exit.
If the text's caret column# is 1, remove bytes from the text (backspace over a return); exit.
Jump the caret left in the text.
Remove any selected bytes in the text.

To remove bytes from a_ text (backspace):
If the text is nil, exit.
If something is selected in the text, remove any selected bytes in the text; exit.
If the text's caret column# is 1, remove bytes from the text (backspace over a return); exit.
Move the caret left in the text.
Remove any selected bytes in the text.

To remove bytes from a_ text (forward delete a return):
If the text is nil, exit.
If the text's caret row# is the text's row count, exit.
Put 1 and the text's caret row# plus 1 into the text's caret.
Remove any selected bytes in the text.

To remove bytes from a_ text (forward delete with jump):
If the text is nil, exit.
If something is selected in the text, remove any selected bytes in the text; exit.
Get a_ row given the text's caret row# and the text.
If the text's caret column# is the row's string's length, remove bytes from the text (forward delete a return); exit.
Jump the caret right in the text.
Remove any selected bytes in the text.

To remove bytes from a_ text (forward delete):
If the text is nil, exit.
If something is selected in the text, remove any selected bytes in the text; exit.
Get a_ row given the text's caret row# and the text.
If the text's caret column# is the row's string's length, remove bytes from the text (forward delete a return); exit.
Move the caret right in the text.
Remove any selected bytes in the text.

To remove every byte in a_ text:
If the text is nil, exit.
Put "" into the text.

\PAL
Para remover o primeiro byte de uma sequência;
\CAL
To remove the first byte from a_ string:
Slap a_ substring on the first byte of the string.
Remove bytes from the string given the substring.

\PAL
Para remover o último byte de uma sequência;
\CAL
To remove the last byte from a_ string:
Slap a_ substring on the last byte of the string.
Remove bytes from the string given the substring.

\PAL
Para remover os dois últimos bytea de uma sequência;
\CAL
To remove the last two bytes from a_ string:
Remove trailing bytes from the string given 2.

\PAL
Para remover os primeiros bytes de uma sequência dado um contador;
\CAL
To remove leading bytes from a_ string given a_ count:
Privatize the count.
If the count is greater than the string's length, clear the string; exit.
Slap a_ substring on the first byte of the string.
Put the substring's first plus the count minus 1 into the substring's last.
Remove bytes from the string given the substring.

\PAL
Para remover os ruídos iniciais de uma sequência;
\CAL
To remove leading noise from a_ string;
To remove any leading noise from a_ string:
If the string is blank, exit.
If the string's first's target is not noise, exit.
Remove the first byte from the string.
Repeat.

To remove the rows of a_ text between a_ row and another row:
If the text is nil, exit.
If the row is nil, exit.
If the other row is nil, exit.
If the row's row# is greater than the other row's row#, exit.
Privatize the row.
Put the other row's next into a_ stop row.
Loop.
If the row is the stop row, break.
Put the row's next into a_ next row.
Remove the row from the text's rows.
Destroy the row.
Put the next row into the row.
Repeat.
Renumber the text's rows.

\PAL
Para remover um elemento de alguns elementos;
\CAL
To remove a_ thing from some things:
If the thing is nil, exit.
If the thing is the things' first, put the thing's next into the things' first.
If the thing is the things' last, put the thing's previous into the things' last.
If the thing's next is not nil, put the thing's previous into the thing's next's previous.
If the thing's previous is not nil, put the thing's next into the thing's previous' next.
Void the thing's next.
Void the thing's previous.

\PAL
Para remover os bytes finais de uma sequência dado um contador;
\CAL
To remove trailing bytes from a_ string given a_ count:
Privatize the count.
If the count is greater than the string's length, clear the string; exit.
Slap a_ substring on the last byte of the string.
Put the substring's last minus the count plus 1 into the substring's first.
Remove bytes from the string given the substring.

\PAL
Para remover os ruídos finais de uma sequência;
\CAL
To remove trailing noise from a_ string;
To remove any trailing noise from a_ string:
If the string is blank, exit.
If the string's last's target is not noise, exit.
Remove the last byte from the string.
Repeat.

\PAL
Para renomear uma rota para outra rota no sistema;
\CAL
To rename a_ path to another path in the file system:
Privatize the path.
Remove any trailing backslash from the path.
Null terminate the path.
Privatize the other path.
Remove any trailing backslash from the other path.
Null terminate the other path.
Call "kernel32.dll" "MoveFileA" with the path's first and the other path's first returning a_ number.
Clear o erro de e/s.
If the number is not 0, exit.
Put "Error renombrando archivo '" then the path then "'." into o erro de e/s.

To renumber some rows:
Get a_ row from the rows.
If the row is nil, exit.
Add 1 to a_ row#.
Put the row# into the row's row#.
Repeat.

\PAL
Para trocar um byte para outro byte em uma sequência;
\CAL
To replace a_ byte with another byte in a_ string:
Slap a_ substring on the string.
Loop.
If the substring is blank, exit.
If the substring's first's target is not the byte, add 1 to the substring's first; repeat.
Put the other byte into the substring's first's target.
Add 1 to the substring's first.
Repeat.

The reply is a_ reply.

a_ reply is a_ string.

To reque an event:
Copy the event into another event.
Enque the other event.

\PAL
Para restabelecer o alfabeto;
\CAL
To reset the alphabet:
Put the big-a byte into the next letter.

To reset the caret of a_ text:
If the text is nil, exit.
Put 1 and 1 into the text's caret.

To reset the context:
Restore the context.
Save the context.

\PAL
Para restabelecer um contador;
\CAL
To reset a_ count:
Put 0 into the count.

To reset the drawing origin:
Set the drawing origin to the zero spot.

To reset a_ flag:
Clear the flag.

To reset the origin of a_ text:
If the text is nil, exit.
Put the text's margin into the text's x-coord.
Put 0 into the text's y-coord.

\PAL
Para restabelecer um ponteiro;
\CAL
To reset a_ pointer;
To reset a_ pointer for_ the next time around;
To void a_ pointer:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the pointer
Intel $C70000000000. \ mov [eax],0

\PAL
Para restabelecer as furta-cores;
\CAL
To reset the rainbow colors:
Put 0 into the current rainbow color number.

\PAL
Para restabelecer um temporizador;
\CAL
To reset a_ timer:
Put 0 into the timer's count.
Put 0 into the timer's start ticks.
Put 0 into the timer's total ticks.

To resize a_ box given a_ ratio pair;
To resize a_ box given a_ fraction pair:
Put the box's x-extent into a_ width.
Put the box's y-extent into a_ height.
Scale the width given the fraction pair's fraction.
Scale the height given the fraction pair's other fraction.
Put the box's left plus the width into the box's right.
Put the box's top plus the height into the box's bottom.

To resize a_ box given a_ twip pair:
Add the twip pair's x-number to the box's right.
Add the twip pair's y-number to the box's bottom.

To resize an ellipse given a_ ratio pair;
To resize an ellipse given a_ fraction pair:
Resize the ellipse's box given the fraction pair.

To resize an ellipse given a_ twip pair:
Resize the ellipse's box given the twip pair.

To resize a_ line given a_ ratio pair;
To resize a_ line given a_ fraction pair:
Put the line's box into a_ box.
Subtract the box's left-top from the line's start.
Scale the line's start given the fraction pair.
Add the box's left-top to the line's start.
Subtract the box's left-top from the line's end.
Scale the line's end given the fraction pair.
Add the box's left-top to the line's end.

To resize a_ line given a_ twip pair:
Put the line's box into a_ box.
Put the box into another box.
Resize the other box given the twip pair.
Make a_ fraction pair given the other box and the box.
Resize the line given the fraction pair.

\PAL
Para redimensionar uma imagem em uma largura por uma altura;
\CAL
To resize a_ picture to a_ width by a_ height:
If the picture is nil, exit.
Put the width divided by the tpp into a_ pixel width.
Put the height divided by the tpp into a_ pixel height.
Call "gdiplus.dll" "GdipCreateBitmapFromScan0" with the pixel width and the pixel height and 0 and 137224 [pixelformat24bpprgb] and 0 and a_ gpbitmap's whereabouts.
Call "gdiplus.dll" "GdipGetImageGraphicsContext" with the gpbitmap and a_ gpgraphic's whereabouts.
Call "gdiplus.dll" "GdipDrawImageRectRectI" with the gpgraphic and the picture's gpbitmap
And 0 and 0 and the pixel width and the pixel height
And 0 and 0 and the picture's gpbitmap's width minus 1 and the picture's gpbitmap's height minus 1
And 2 [unitpixel] and nil and nil and 0.
Call "gdiplus.dll" "GdipDeleteGraphics" with the gpgraphic.
Destroy the picture's gpbitmap.
Put the gpbitmap into the picture's gpbitmap.
Adjust the picture (extract boxes from gpbitmap).
Clear the picture's data.

To resize a_ polygon given a_ ratio pair;
To resize a_ polygon given a_ fraction pair:
If the polygon is nil, exit.
Put the polygon's box into a_ box.
Loop.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, exit.
Subtract the box's left-top from the vertex's spot.
Scale the vertex's spot given the fraction pair.
Add the box's left-top to the vertex's spot.
Repeat.

To resize a_ polygon given a_ twip pair:
If the polygon is nil, exit.
Put the polygon's box into a_ box.
Put the box into another box.
Resize the other box given the twip pair.
Make a_ fraction pair given the other box and the box.
Resize the polygon given the fraction pair.

To resize a_ text given a_ ratio pair;
To resize a_ text given a_ fraction pair:
If the text is nil, exit.
Resize the text's box given the fraction pair.
Wrap the text.

To resize a_ text given a_ twip pair:
If the text is nil, exit.
Resize the text's box given the twip pair.
Wrap the text.

\PAL
Para reiniciar um temporizador;
\CAL
To restart a_ timer:
Add 1 to the timer's count.
If the timer's count is not 1, exit.
Put the system's tick count into the timer's start ticks.

To restore a_ canvas:
Call "gdi32.dll" "RestoreDC" with the canvas and -1. \ need to use -1, windows documentation is wrong

To restore a_ context:
Get a_ saved context from the context stack.
If the saved context is nil, exit.
Put the saved context's spot into the context's spot.
Put the saved context's heading into the context's heading.
Put the saved context's letter height into the context's letter height.
Put the saved context's color into the context's color.
Put the saved context's number into the context's number.
Remove the saved context from the context stack.
Destroy the saved context.

To restore a_ window:
Call "user32.dll" "ShowWindow" with the window and 9 [sw_restore].

The return byte is a_ byte equal to 13.

To reverse any selected rows of a_ text:
If the text is nil, exit.
Split the rows of the text into some rows and some selected rows and some other rows.
Reverse the selected rows.
Append the rows to the text's rows.
Append the selected rows to the text's rows.
Append the other rows to the text's rows.
Renumber the text's rows.

To reverse a_ color:
If the color is the black color, put the white color into the color; exit.
If the color is the white color, put the black color into the color; exit.
Put 1000 minus the color's lightness into the color's lightness.
\Put 1000 minus the color's saturation into the color's saturation.
Add 1800 to the color's hue. Normalize the color's hue.

To invert a_ flag;
To reverse a_ flag:
If the flag is 1, put 0 into the flag; exit.
Put 1 into the flag.

\PAL
Para inverter o sinal de um número;
\CAL
To reverse a_ number;
To invert a_ number:
Multiply the number by -1.

To reverse a_ string: \ could be more efficient
Privatize the string.
Clear the original string.
Loop.
If the string is blank, break.
Get a_ character from the string (backwards).
Append the character to the original string.
Repeat.

To reverse some things:
Swap the things with some other things.
Loop.
Put the other things' last into a_ thing.
If the thing is nil, exit.
Move the thing from the other things to the things.
Repeat.

a_ rgb is a_ record with
a_ byte called blue byte,
a_ byte called green byte,
a_ byte called red byte.

a_ rgb pointer is a_ pointer to a_ rgb.

a_ rider has \ fix "bump a rider" and "unbump a rider" if you change me
an original substring,
a_ source substring,
a_ token substring,
\PAL
um segmento chamado cópia at the original substring,
um segmento chamado origem at the source substring,
um segmento chamado componente at the token substring.
\sinônimos de token
um segmento chamado signo at the token substring.
um segmento chamado marca at the token substring.

The right-alligator byte is a_ byte equal to 62.

The right-alligator-quote byte is a_ byte equal to 155.

The right-arrow key is a_ key equal to 39.

The right-brace byte is a_ byte equal to 125.

The right-bracket byte is a_ byte equal to 93.

The right-double-alligator-quote byte is a_ byte equal to 187.

The right-double-quote byte is a_ byte equal to 148.

The right-paren byte is a_ byte equal to 41.

The right-single-quote byte is a_ byte equal to 146.

The right-window key is a_ key equal to 92.

a_ rise is a_ number.
a_ run is a_ number.

\PAL
Para girar uma caixa;
\CAL
To rotate a_ box:
Put the box's center into a_ center spot.
Put the box into another box.
Put the center's y-coord minus the other box's top plus the center's x-coord into the box's right.
Put the other box's left minus the center's x-coord plus the center's y-coord into the box's top.
Put the center's y-coord minus the other box's bottom plus the center's x-coord into the box's left.
Put the other box's right minus the center's x-coord plus the center's y-coord into the box's bottom.

\PAL
Para girar uma elipse;
\CAL
To rotate an ellipse:
Rotate the ellipse's box.

To rotate a_ gpimage:
If the gpimage is nil, exit.
Call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and 1 [rotate90flipnone].

To rotate a_ gpimage given an angle: \ angle can be 0, 900, 1800, 2700
If the gpimage is nil, exit.
Put 0 [rotatenoneflipnone] into a_ number.
If the angle is 900, put 1 [rotate90flipnone] into the number.
If the angle is 1800, put 2 [rotate180flipnone ] into the number.
If the angle is 2700, put 3 [rotate270flipnone ] into the number.
Call "gdiplus.dll" "GdipImageRotateFlip" with the gpimage and the number.

\PAL
Para girar uma reta;
\CAL
To rotate a_ line:
Put the line's center into a_ center spot.
Rotate the line's start around the center.
Rotate the line's end around the center.

\PAL
Para girar uma imagem;
\CAL
To rotate a_ picture:
If the picture is nil, exit.
Add 900 to the picture's rotate angle.
If the picture's mirror flag is set, add 1800 to the picture's rotate angle.
Normalize the picture's rotate angle.
Rotate the picture's box.
Rotate the picture's uncropped box.
Put the picture's box's center into a_ center spot.
Put the picture's uncropped box's center into another center spot.
Put the center's y-coord minus the other center's y-coord plus the center's x-coord into a_ twip pair's x-number.
Subtract the other center's x-coord from the twip pair's x-number.
Put the center's y-coord plus the other center's x-coord minus the center's x-coord into the twip pair's y-number.
Subtract the other center's y-coord from the twip pair's y-number.
Move the picture's uncropped box given the twip pair.
Rotate the picture's gpbitmap.

\PAL
Para girar um polígono;
\CAL
To rotate a_ polygon:
If the polygon is nil, exit.
Put the polygon's center into a_ center spot.
Loop.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, exit.
Rotate the vertex's spot around the center.
Repeat.

\PAL
Para girar um loco ao redor de um loco central;
\CAL
To rotate a_ spot around a_ center spot:
Put the spot into another spot.
Put the center's y-coord minus the other spot's y-coord plus the center's x-coord into the spot's x-coord.
Put the other spot's x-coord minus the center's x-coord plus the center's y-coord into the spot's y-coord.

\PAL
Para girar um texto;
\CAL
To rotate a_ text:
If the text is nil, exit.
Rotate the text's box.
Wrap the text.

\PAL
Para arredondar um número a outro número;
\CAL
To round a_ number to another number: 
Round the number to the nearest multiple of the other number.

To round a_ number down to the nearest multiple of another number:
Divide the number by the other number.
Multiply the number by the other number.

To round a_ number to the nearest multiple of another number:
If the other number is 0, exit.
Privatize the other number.
Divide the number by the other number giving a_ quotient and a_ remainder.
Divide the other number by 2.
If the remainder is greater than or equal to the other number, round the number up to the nearest multiple of the original other number; exit.
Round the number down to the nearest multiple of the original other number.

To round a_ number up to the nearest multiple of another number:
Divide the number by the other number giving a_ quotient and a_ remainder.
If the remainder is 0, exit.
Add the other number minus the remainder to the number.

To round a_ number up to the nearest power of two:
Intel $8B8D08000000. \ mov ecx,[ebp+8] \ the number
Intel $8B09. \ mov ecx,[ecx]
Intel $49. \ dec ecx
Intel $0FBDC9. \ bsr ecx,ecx
Intel $41. \ inc ecx
Intel $81F904000000. \ cmp ecx,4
Intel $0F8F05000000. \ jg over the next 1 statement
Intel $B904000000. \ mov ecx,4
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $C70001000000. \ mov [eax],1
Intel $D320. \ shl [eax],ecx  

To round a_ pair to another pair:
Round the pair to the nearest multiple of the other pair.

To round a_ pair to the nearest multiple of another pair:
Round the pair's x-number to the nearest multiple of the other pair's x-number.
Round the pair's y-number to the nearest multiple of the other pair's y-number.

To round a_ pair to the nearest multiple of a_ number:
Round the pair's x-number to the nearest multiple of the number.
Round the pair's y-number to the nearest multiple of the number.

To round a_ pair to a_ number:
Round the pair to the nearest multiple of the number.

a_ roundy box is a_ box with
a_ left coord,
a_ top coord,
a_ right coord,
a_ bottom coord,
a_ left-top spot at the left,
a_ right-bottom spot at the right,
a_ radius,
\PAL
uma coordenada chamada esquerda redefinindo a left coord,
uma coordenada chamada topo redefinindo a top coord,
uma coordenada chamada direita redefinindo a right coord,
uma coordenada chamada base redefinindo a bottom coord,
um loco esquerdo-superior redefinindo a left,
um loco direito-inferior redefinindo a right,
um raio redefinindo o radius.

a_ row is a_ thing with
\CAL
a_ row#
and a_ string
\PAL
e um número chamado posição redefinindo a row#
e uma sequência redefinindo o string.

a_ row# is a_ number.

The s-key is a_ key equal to 83.

a_ saturation is a_ number [0 to 1000].

To save a_ canvas:
Call "gdi32.dll" "SaveDC" with the canvas.

To save a_ context:
Allocate memory for_ a_ saved context.
Put the context's spot into the saved context's spot.
Put the context's heading into the saved context's heading.
Put the context's letter height into the saved context's letter height.
Put the context's color into the saved context's color.
Put the context's number into the saved context's number.
Prepend the saved context to the context stack.

The saved memory hbitmap is a_ hbitmap.

The saved tpp is a_ number.

\PAL
Para falar um número;
\CAL
To say a_ number:
Put the number into a_ string.
Say the string.

\PAL
Para falar uma sequência;
\CAL
To say a_ string;
To speak a_ string:
If the silent flag is set, exit.
If la bandera silenciosa is set, exit.
If the talker is nil, exit.
If the string is blank, exit.
Convert the string to a_ wide string.
Null terminate the wide string.
Call the talker's vtable's speak with the talker and the wide string's first and 17 [svsfdefault+svsflagsasyn+svsfisnotxml] and 0.

\PAL
Para falar uma sequência e aguardar;
\CAL
To say a_ string and wait;
To speak a_ string and wait:
If the silent flag is set, exit.
If la bandera silenciosa is set, exit.
If the talker is nil, exit.
If the string is blank, exit.
Convert the string to a_ wide string.
Null terminate the wide string.
Call the talker's vtable's speak with the talker and the wide string's first and 16 [svsfdefault+svsfisnotxml] and 0.

To scale a_ box given a_ ratio;
To scale a_ box given a_ fraction:
If the fraction is 1/1, exit.
Scale the box's left given the fraction.
Scale the box's top given the fraction.
Scale the box's right given the fraction.
Scale the box's bottom given the fraction.

To scale a_ box to a_ percent:
Put the percent / 100 into a_ fraction.
Scale the box given the fraction.

To scale an ellipse given a_ ratio;
To scale an ellipse given a_ fraction:
If the fraction is 1/1, exit.
Scale the ellipse's box given the fraction.

To scale an ellipse to a_ percent:
Put the percent / 100 into a_ fraction.
Scale the ellipse given the fraction.

To scale a_ font given a_ ratio;
To scale a_ font given a_ fraction:
If the fraction is 1/1, exit.
Scale the font's height given the fraction.

To scale a_ fraction given another fraction;
To multiply a_ fraction by another fraction:
Multiply the fraction's numerator by the other fraction's numerator.
Multiply the fraction's denominator by the other fraction's denominator.
Reduce the fraction.

To scale a_ line given a_ ratio;
To scale a_ line given a_ fraction:
If the fraction is 1/1, exit.
Scale the line's start given the fraction.
Scale the line's end given the fraction.  

To scale a_ line to a_ percent:
Put the percent / 100 into a_ fraction.
Scale the line given the fraction.

To scale a_ pair given a_ ratio;
To scale a_ pair given a_ fraction:
If the fraction is 1/1, exit.
Scale the pair's x-number given the fraction.
Scale the pair's y-number given the fraction.

To scale a_ pair given a_ ratio pair;
To scale a_ pair given a_ fraction pair:
Scale the pair's x-number given the fraction pair's fraction.
Scale the pair's y-number given the fraction pair's other fraction.

To scale a_ pair to a_ percent:
Put the percent / 100 into a_ fraction.
Scale the pair given the fraction.

To scale a_ picture given a_ ratio;
To scale a_ picture given a_ fraction:
If the picture is nil, exit.
If the fraction is 1/1, exit.
Scale the picture's box given the fraction.
Scale the picture's uncropped box given the fraction.

To scale a_ picture to a_ percent:
If the picture is nil, exit.
Put the percent / 100 into a_ fraction.
Scale the picture given the fraction.

To scale a_ polygon given a_ ratio;
To scale a_ polygon given a_ fraction:
If the polygon is nil, exit.
If the fraction is 1/1, exit.
Loop.
Get a_ vertex from the polygon's vertices.
If the vertex is nil, exit.
Scale the vertex given the fraction.
Repeat.

To scale a_ polygon to a_ percent:
If the polygon is nil, exit.
Put the percent / 100 into a_ fraction.
Scale the polygon given the fraction.

To scale a_ roundy box given a_ ratio;
To scale a_ roundy box given a_ fraction:
If the fraction is 1/1, exit.
Scale the roundy box as_ a_ box given the fraction.
Scale the roundy box's radius given the fraction.

To scale a_ roundy box to a_ percent:
Put the percent / 100 into a_ fraction.
Scale the roundy box given the fraction.

To scale a_ text to a_ fraction: \ absolute
If the text is nil, exit.
Put the text's scale into another fraction.
Flip the other fraction.
Multiply the other fraction by the fraction.
Scale the text given the other fraction.

To scale a_ text given a_ ratio;
To scale a_ text given a_ fraction:
If the text is nil, exit.
If the fraction is 1/1, exit.
Scale the text's box given the fraction.
Scale the text's origin given the fraction.
Scale the text's font given the fraction.
Scale the text's scale given the fraction.

To scale a_ text to a_ percent:
If the text is nil, exit.
Put the percent / 100 into a_ fraction.
Scale the text given the fraction.

To scale a_ vertex given a_ ratio;
To scale a_ vertex given a_ fraction:
If the vertex is nil, exit.
If the fraction is 1/1, exit.
Scale the vertex's x-coord given the fraction.
Scale the vertex's y-coord given the fraction.

The screen canvas is a_ canvas.

The screen has a_ box, a_ pixel height and a_ pixel width.

To scroll a_ console given an event:
If the console is nil, exit.
Find a_ sector given the console's grid and the event's spot.
Loop.
If the mouse's right button is up, exit.
Find another sector given the console's grid and the mouse's spot.
Get a_ difference between the other sector and the sector.
If the difference is 0, repeat.
Scroll the console's text given the difference.
Show the console.
Add the difference to the sector.
Repeat.

To scroll a_ text to the bottom:
If the text is nil, exit.
If the text's vertical scroll flag is not set, exit.
Put the text's row count minus 1 into a_ number.
Put - the number times the text's row height into the text's y-coord.
Limit the origin of the text.

To scroll a_ text to the caret:
If the text is nil, exit.
If the text's caret's column# is 1, put the text's margin into the text's x-coord.
Get a_ box for_ the caret in the text.
Adjust the box given 0 and - the tpp and 0 and the tpp. \ caret boxes don't fill entire row
If the box's top is less than the text's top, put the text's top minus the box's top into a_ difference's y-number.
If the box's bottom is greater than the text's bottom, put the text's bottom minus the box's bottom into the difference's y-number.
If the box's left is less than the text's left, put the text's left minus the box's left into the difference's x-number.
If the box's right is greater than the text's right, put the text's right minus the box's right into the difference's x-number.
If the difference is 0, exit.
Scroll the text given the difference.

To scroll a_ text to the caret and center it:
If the text is nil, exit.
Put the text's margin into the text's x-coord.
Get a_ box for_ the caret in the text.
If the box is inside the text's box, exit.
Adjust the box given 0 and - the tpp and 0 and the tpp. \ caret boxes don't fill entire row
Put the text's box's y-extent divided by 2 into a_ height.
Round the height down to the nearest multiple of the text's row height.
Put the text's box's top plus the height into a_ top coord.
Put the top plus the text's row height into a_ bottom coord.
If the box's top is less than the top, put the top minus the box's top into a_ difference's y-number.
If the box's bottom is greater than the bottom, put the bottom minus the box's bottom into the difference's y-number.
If the box's left is less than the text's left, put the text's left minus the box's left into the difference's x-number.
If the box's right is greater than the text's right, put the text's right minus the box's right into the difference's x-number.
If the difference is 0, exit.
Scroll the text given the difference.

To scroll a_ text down one line:
If the text is nil, exit.
If the text's vertical scroll flag is not set, exit.
Put - the text's row height into a_ difference's y-number.
Scroll the text given the difference.

To scroll a_ text down one page:
If the text is nil, exit.
If the text's vertical scroll flag is not set, exit.
Subtract the text's box's y-extent from the text's y-coord.
Add the text's row height to the text's y-coord.
Limit the origin of the text.

To scroll a_ text given a_ difference:
If the text is nil, exit.
Privatize the difference.
If the text's horizontal scroll flag is not set, put 0 into the difference's x-number.
If the text's vertical scroll flag is not set, put 0 into the difference's y-number.
If the difference is 0, exit.
Move the text's origin given the difference.
Limit the origin of the text.

To scroll a_ text to the top:
If the text is nil, exit.
If the text's vertical scroll flag is not set, exit.
Put 0 into the text's y-coord.
Limit the origin of the text.

To scroll a_ text up one line:
If the text is nil, exit.
If the text's vertical scroll flag is not set, exit.
Put the text's row height into a_ difference's y-number.
Scroll the text given the difference.

To scroll a_ text up one page:
If the text is nil, exit.
If the text's vertical scroll flag is not set, exit.
Add the text's box's y-extent to the text's y-coord.
Subtract the text's row height from the text's y-coord.
Limit the origin of the text.

The scrolllock key is a_ key equal to 145.

a_ second is 1000 milliseconds.

The sector byte is a_ byte equal to 167.

a_ sector is a_ pair with an x-coord and an y-coord [indicating the left-top of the sector].

The seed is a_ number.

\PAL
Para selecionar cada byte em um texto;
\CAL
To select every byte in a_ text:
If the text is nil, exit.
Put 1 and 1 into the text's anchor.
Put the text's rows' last's string's length and the text's row count into the text's caret.

To select a_ row# given a_ text:
If the text is nil, exit.
Get a_ row given the row# and the text.
If the row is nil, exit.
Put the row# into the text's anchor row#.
Put 1 into the text's anchor column#.
Put the row# into the text's caret row#.
Put the row's string's length into the text's caret column#.

a_ selection box is a_ box.

a_ selection has 
An anchor column#,
an anchor row#,
an anchor at the anchor column#,
a_ caret column#,
a_ caret row#,
a_ caret at the caret column#,
\PAL
Um número chamado coluna âncora redefinindo a anchor column#,
Um número chamado linha âncora redefinindo a anchor row#,
Uma âncora redefinindo a anchor column#,
Um número chamado coluna marcadora redefinindo a caret column#,
Um número chamado linha marcadora redefinindo a caret row#,
Um marcador redefinindo a caret column#.

The semi-colon byte is a_ byte equal to 59.

To send a_ buffer to a_ socket:
Clear o erro de e/s.
Put the buffer's first into a_ pointer.
Put the buffer's length into a_ length.
Loop.
If the length is 0, break.
Call "ws2_32.dll" "send" with the socket and the pointer and the length and 0 returning a_ number.
If the number is -1 [socket_error], put "Error enviando datos." into o erro de e/s; exit.
Subtract the number from the length.
Add the number to the pointer.
Repeat.

To send a_ data string to a_ winhttp request:
If the winhttp request is nil, exit.
Call "winhttp.dll" "WinHttpSendRequest"
With the winhttp request's request
And 0 [winhttp_no_additional_headers]
And 0 
And the data's first
And the data's length
And the data's length
And 0
Returning a_ result number.
If the result is 0, put "No pude enviar el pedido." into o erro de e/s; exit.

To send an email:
Clear o erro de e/s.
\ create socket
Create a_ socket given the email's smtp server and 25.
If o erro de e/s is not blank, exit.
\ initial receive here for date/time stuff from server
Receive a_ response string from the socket.
If o erro de e/s is not blank, destroy the socket; exit.
If the response starts with "5", put the response into o erro de e/s; trim o erro de e/s; destroy the socket; exit.
\ send HELO
Send "HELO " then the module's name then the crlf string to the socket and receive the response string.
If o erro de e/s is not blank, destroy the socket; exit.
If the response starts with "5", put the response into o erro de e/s; trim o erro de e/s; destroy the socket; exit.
\ send MAIL FROM: <xxx>
Send "MAIL FROM: <" then the email's sender then ">" then the crlf string to the socket and receive the response string.
If o erro de e/s is not blank, destroy the socket; exit.
If the response starts with "5", put the response into o erro de e/s; trim o erro de e/s; destroy the socket; exit.
\ send RCPT TO: <xxx>
Send "RCPT TO: <" then the email's recipient then ">" then the crlf string to the socket and receive the response string.
If o erro de e/s is not blank, destroy the socket; exit.
If the response starts with "5", put the response into o erro de e/s; trim o erro de e/s; destroy the socket; exit.
\ send DATA
Send "DATA" then the crlf string to the socket and receive the response string.
If o erro de e/s is not blank, destroy the socket; exit.
If the response starts with "5", put the response into o erro de e/s; trim o erro de e/s; destroy the socket; exit.
\ send From: xxx crlf To: xxx crlf Subject: xxx crlf Reply-To: xxx crlf message crlf . crlf
Clear a_ temp string.
Append "From: " then the email's sender then the crlf string to the temp string.
Append "To: " then the email's recipient then the crlf string to the temp string.
Append "Subject: " then the email's subject then the crlf string into the temp string.
Append "Reply-To: " then the email's sender then the crlf string into the temp string.
Append the crlf string to the temp string.
Append the email's message to the temp string (handling email transparency).
Append the crlf string then "." then the crlf string to the temp string.
Send the temp string to the socket and receive the response string.
If o erro de e/s is not blank, destroy the socket; exit.
If the response starts with "5", put the response into o erro de e/s; trim o erro de e/s; destroy the socket; exit.
\ send QUIT
Send "QUIT" then the crlf string to the socket.
\ destroy socket
Destroy the socket.

To send a_ message from a_ sender to a_ recipient:
Send the message to the recipient from the sender.

To send a_ message from a_ sender to a_ recipient via a_ smtp server:
Send the message to the recipient from the sender via the smtp server.

To send a_ message from a_ sender to a_ recipient with a_ subject:
Send the message to the recipient from the sender with the subject.

To send a_ message from a_ sender to a_ recipient with a_ subject via a_ smtp server:
Send the message to the recipient from the sender with the subject via the smtp server.

To send a_ message to a_ recipient from a_ sender:
Put the default smtp server into an email's smtp server.
Put the recipient into the email's recipient.
Put the sender into the email's sender.
Put the message into the email's message.
Send the email.

To send a_ message to a_ recipient from a_ sender via a_ smtp server:
Put the smtp server into an email's smtp server.
Put the recipient into the email's recipient.
Put the sender into the email's sender.
Put the message into the email's message.
Send the email.

To send a_ message to a_ recipient from a_ sender with a_ subject:
Put the default smtp server into an email's smtp server.
Put the recipient into the email's recipient.
Put the sender into the email's sender.
Put the subject into the email's subject.
Put the message into the email's message.
Send the email.

To send a_ message to a_ recipient from a_ sender with a_ subject via a_ smtp server:
Put the smtp server into an email's smtp server.
Put the recipient into the email's recipient.
Put the sender into the email's sender.
Put the subject into the email's subject.
Put the message into the email's message.
Send the email.

To send a_ string to a_ socket and receive a_ response string:
Clear the response string.
Send the string to the socket.
If o erro de e/s is not blank, exit.
Receive the response string from the socket.

a_ sender is a_ string.

To set the colorref of a_ canvas given a_ color:
Convert the color to a_ colorref.
Call "gdi32.dll" "SetTextColor" with the canvas and the colorref.

To set the drawing origin to a_ spot:
Call "gdi32.dll" "GetDeviceCaps" with the current canvas and 112 [physicaloffsetx] returning a_ pair's x-number.
Call "gdi32.dll" "GetDeviceCaps" with the current canvas and 113 [physicaloffsety] returning the pair's y-number.
Negate the pair.
If the current canvas is not the printer canvas, clear the pair.
Call "gdi32.dll" "SetViewportOrgEx" with the current canvas and the pair's x-number and the pair's y-number and nil.
Privatize the spot.
Call "gdi32.dll" "LPtoDP" with the current canvas and the spot's whereabouts and 1.
Call "gdi32.dll" "SetViewportOrgEx" with the current canvas and the spot's x-coord and the spot's y-coord and nil.

\PAL
Para ligar uma signa;
Para positivar uma signa;
\CAL
To set a_ flag:
Put 1 into the flag. \ was "Put yes into the flag." Value of yes inherited from the CAL-1000 according to Dan.

To set a_ path to read-write mode:
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "GetFileAttributesA" with the path's first returning a_ number.
Bitwise and the number with -2 [everything except file_attribute_readonly].
Call "kernel32.dll" "SetFileAttributesA" with the path's first and the number.

The seven byte is a_ byte equal to 55.

The seven key is a_ key equal to 55.

The sharp-s byte is a_ byte equal to 223.

a_ sheet is a_ box.

\PAL
Para deslocar um byte à esquerda em alguns bits;
\CAL
To shift a_ byte left some bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $D220. \ shl byte pointer [eax],ecx

\PAL
Para deslocar um byte à direita em alguns bits;
\CAL
To shift a_ byte right some bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $D228. \ shr byte pointer [eax],ecx

The shift key is a_ key equal to 16.

\PAL
Para deslocar um número à esquerda em alguns bits;
\CAL
To shift a_ number left some bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $D320. \ shl [eax],ecx

\PAL
Para deslocar um número à direita em alguns bits;
\CAL
To shift a_ number right some bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $D328. \ shr [eax],ecx

\PAL
Para deslocar uma wyrd à esquerda em alguns bits;
\CAL
To shift a_ wyrd left some bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
Intel $66D320. \ shl word ptr [eax],ecx

\PAL
Para deslocar uma wyrd à direita em alguns bits;
\CAL
To shift a_ wyrd right some bits:
Intel $8B8D0C000000. \ mov ecx,[ebp+12] \ the bits
Intel $8B09. \ mov ecx,[ecx]
Intel $8B8508000000. \ mov eax,[ebp+8] \ the wyrd
Intel $66D328. \ shr word ptr [eax],ecx

The shift-in byte is a_ byte equal to 15.

The shift-out byte is a_ byte equal to 14.

\PAL
Para mostrar um console;
\CAL
To show a_ console:
If the console is nil, exit.
Save the current canvas.
Draw the console.
Refresh the screen given the console's box.
Restore the current canvas.

\PAL
Para mostrar um cursor;
\CAL
To show a_ cursor:
Call "user32.dll" "SetCursor" with the cursor.
Call "user32.dll" "ShowCursor" with 1 returning a_ number.
If the number is greater than 0, exit.
Repeat.

\PAL
Para mostrar um terminal;
\CAL
To show a_ terminal:
If the terminal is nil, exit.
Save the current canvas.
Draw the terminal.
Refresh the screen given the terminal's box.
Restore the current canvas.

\PAL
Para reduzir uma caixa em alguns twips;
\CAL
To shrink a_ box by some twips;
To indent a_ box some twips;
To indent a_ box by some twips;
To indent a_ box some twips on every side;
To indent a_ box given some twips:
Add the twips to the box's left.
Add the twips to the box's top.
Subtract the twips from the box's right.
Subtract the twips from the box's bottom.

\PAL
Para terminar;
Para desligar;
\CAL
To shut down:
Destroy the bible.
Destroy the stack.
Destroy the lexicon.
Destroy the console.
Destroy the terminal.
Finalize the context.
Finalize the canvases.
Finalize the mouse.
Finalize the cursors.
Finalize the fonts.
Finalize the window.
Finalize the screen.
Finalize the colors.
Finalize the module.
Finalize the talker.
Finalize gdi+.
Finalize winsock.
Finalize com.

To shut down the cgi:
Finalize the cgi.
Finalize the module.
Finalize winsock.

a_ side is 1 unit.

The silent flag is a_ flag.

\PAL
Para simplificar uma resposta;
\CAL
To simplify a_ reply:
If the reply is blank, break.
Get a_ byte  from the reply.
If the byte is any punctuation mark, repeat.
Append the byte to a_ string.
Repeat.
Put the string into the reply.

The single-quote byte is a_ byte equal to 39.

The six byte is a_ byte equal to 54.

The six key is a_ key equal to 54.

a_ size is some twips.

To skip any leading linefeed byte in a_ substring:
If the substring is blank, exit.
If the substring's first's target is not the linefeed byte, exit.
Add 1 to the substring's first.

To skip any leading noise in a_ substring:
If the substring is blank, exit.
If the substring's first's target is not noise, exit.
Add 1 to the substring's first.
Repeat.

To skip any non-alphanumeric bytes in a_ substring:
If the substring is blank, exit.
If the substring's first's target is alphanumeric, exit.
Add 1 to the substring's first.
Repeat.

\PAL
Para pular uma linha no terminal;
\CAL
To skip a_ line on the terminal:
Write "" on the terminal.

To skip word characters in a_ substring:
If the substring is blank, exit.
If the substring is on any contraction, add 1 to the substring's first; repeat.
If the substring's first's target is not alphanumeric, exit.
Add 1 to the substring's first.
Repeat.

The sky blue color is a_ color.

The sky blue pen is a_ pen.

The sky color is a_ color.

The sky pen is a_ pen.

\PAL
Para assentar um iterador em outro iterador;
Para aplicar um iterador em outro iterador;
\CAL
To slap a_ rider on another rider:
Slap the rider's source on the other rider's source.
Position the rider's token on the rider's source.

\PAL
Para assentar um iterador em uma sequência;
Para aplicar um iterador em uma sequência;
\CAL
To slap a_ rider on a_ string:
Slap the rider's original on the string.
Slap the rider's source on the string.
Position the rider's token on the rider's source.

To slap a_ substring on any selected bytes in a_ row of a_ text:
Clear the substring.
If the text is nil, exit.
If the row of the text is not selected, exit.
Slap the substring on the row's string.
Put the text's normalized selection into a_ selection.
If the row's row# is the selection's caret row#, put the substring's first plus the selection's caret column# minus 2 into the substring's last.
If the row's row# is the selection's anchor row#, put the substring's first plus the selection's anchor column# minus 1 into the substring's first.

\PAL
Para assentar um segmento no primeiro byte de uma sequência;
Para aplicar um segmento no primeiro byte de uma sequência;
\CAL
To slap a_ substring on the first byte of a_ string:
Slap the substring on the string.
If the string is blank, exit.
Put the string's first into the substring's last.

\PAL
Para assentar um segmento no último byte de uma sequência;
Para aplicar um segmento no último byte de uma sequência;
\CAL
To slap a_ substring on the last byte of a_ string:
Slap the substring on the string.
If the string is blank, exit.
Put the string's last into the substring's first.

\PAL
Para assentar um segmento em uma sequência;
Para aplicar um segmento em uma sequência;
\CAL
To slap a_ substring on a_ string:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the substring
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the string
\ put the string's first into the substring's first
Intel $8B8B00000000. \ mov ecx,[ebx+0] \ the string's first
Intel $898800000000. \ mov [eax+0],ecx \ the substring's first
\ put the string's last into the substring's last
Intel $8B8B04000000. \ mov ecx,[ebx+4] \ the string's last
Intel $898804000000. \ mov [eax+4],ecx \ the substring's last

The slash byte is a_ byte equal to 47.

The small letter height is a_ letter height.

The small-bullet byte is a_ byte equal to 183.

The smallest number is -2147483648.

\PAL
Para suavizar um polígono;
\CAL
To smooth a_ polygon:
If the polygon is nil, exit.
If the polygon's vertices' count is less than 3, exit.
If the polygon is closed, append the polygon's first vertex's next's spot to the polygon; set a_ flag.
Put the polygon's first vertex into a_ left vertex.
Loop.
If the left vertex's next is nil, break.
Put the left vertex's next into a_ right vertex.
Get a_ center spot given the left vertex's spot and the right vertex's spot.
Insert the center into the polygon after the left vertex.
Put the left vertex's next into a_ new vertex.
If the left vertex's previous is nil, put the right vertex into the left vertex; repeat.
Get another center spot given the left vertex's previous' spot and the new vertex's spot.
Get a_ difference between the other center and the left vertex's spot.
Divide the difference by 2.
Add the difference to the left vertex's spot.
Put the right vertex into the left vertex.
Repeat.
If the flag is not set, exit.
Destroy the polygon's first vertex given the polygon.
Destroy the polygon's last vertex given the polygon.

\PAL
Para suavizar um polígono dado um contador;
\CAL
To smooth a_ polygon some times: \ this use to "times" is a fluke, I think -- see "some times is a number"
Privatize the times.
Loop.
If the times is 0, exit.
Smooth the polygon.
Subtract 1 from the times.
Repeat.

An smtp server is a_ string.

a_ sockaddr is a_ record with
a_ wyrd called sin_family,
a_ big-endian unsigned wyrd called sin_port,
a_ in_addr called sin_addr,
8 bytes called sin_zero.

a_ sockaddrptr is a_ pointer to a_ sockaddr.

a_ socket is a_ pointer.

The soft-dash byte is a_ byte equal to 173.

a_ solid color is a_ color.

To sort any selected rows in a_ text:
If the text is nil, exit.
Split the rows of the text into some rows and some selected rows and some other rows.
Sort the selected rows.
Append the rows to the text's rows.
Append the selected rows to the text's rows.
Append the other rows to the text's rows.
Renumber the text's rows.

To sort some rows:
If the rows' first is the rows' last, exit.
Split the rows into some left rows and some right rows.
Sort the left rows.
Sort the right rows.
Loop.
Put the left rows' first into a_ left row.
Put the right rows' first into a_ right row.
If the left row is nil, append the right rows to the rows; exit.
If the right row is nil, append the left rows to the rows; exit.
If the left row's string is greater than the right row's string, move the right row from the right rows to the rows; repeat.
Move the left row from the left rows to the rows.
Repeat.

To space between glyphs:
Turn right. Move 3 squares. Turn left.

The space byte is a_ byte equal to 32.

The space key is a_ key equal to 32.

The space string is a_ string equal to " ".

To split a_ buffer into some dyads:
Destroy the dyads.
If the buffer is blank, exit.
Slap a_ rider on the buffer.
Loop.
Move the rider given the ampersand byte.
If the rider's token is blank, exit.
Create a_ dyad. 
Append the dyad to the dyads.
Split the rider's token into a_ name substring and a_ query substring given the equal-sign byte.
Put the name substring into the dyad's name.
Convert the query substring as_ a_ query string into the dyad's value.
Repeat.

To split a_ byte into a_ nibble and another nibble:
Put the byte into the nibble.
Shift the nibble right 4 bits.
Put the byte into the other nibble.
Bitwise and the other nibble with 15.

\PAL
Para desmembrar uma reta em outra reta e uma terceira reta;
Para dividir uma reta em outra reta e uma terceira reta;
\CAL
To split a_ line into another line and a_ third line:
Privatize the line.
Put the line's center into a_ center spot.
Put the line's start and the center into the other line.
Put the center and the line's end into the third line. 

To split a_ number into a_ wyrd and another wyrd:
Privatize the number.
Shift the number right 16 bits.
Put the number into the wyrd.
Put the original number into the other wyrd.

To split the rows of a_ text into some rows and some selected rows and some other rows:
If the text is nil, clear the rows; clear the selected rows; clear the other rows; exit.
Loop.
Put the text's rows' first into a_ row.
If the row is nil, exit.
Remove the row from the text's rows.
If the row of the text is selected, set a_ flag; append the row to the selected rows; repeat.
If the flag is set, append the row to the other rows; repeat.
Append the row to the rows.
Repeat.

To split a_ string into a_ left substring and a_ right substring given a_ separator byte:
Clear the left.
Clear the right.
If the string is blank, exit.
Put the string's first into a_ substring's first.
Put the substring's first minus 1 into the substring's last.
Loop.
If the substring's last is greater than the string's last, exit.
Add 1 to the substring's last.
If the substring's last's target is the separator byte, break.
Repeat.
Put the substring's first into the left's first.
Put the substring's last minus 1 into the left's last.
Put the substring's last plus 1 into the right's first.
Put the string's last into the right's last.

To split a_ string into some string things given a_ separator byte:
Destroy the string things.
If the string is blank, exit.
Slap a_ rider on the string.
Loop.
Move the rider given the separator byte.
Add the rider's token to the string things.
If the rider's source is blank, break.
Repeat.
If the string's last's target is not the separator byte, exit.
Add "" to the string things.

To split some things into some left things and some right things:
If the things are empty, clear the left things; clear the right things; exit.
Put the things' count divided by 2 into a_ count.
Loop.
Get a_ thing from the things.
If the count is 0, break.
Subtract 1 from the count.
Repeat.
Split the things into the left things and the right things at the thing. 

To split some things into some left things and some right things at a_ thing:
Clear the left things.
Clear the right things.
If the thing is nil, swap the things with the left things; exit.
If the thing's previous is nil, swap the things with the left things; exit.
\ set up the left chain
Put the things' first into the left things' first.
Put the thing's previous into the left things' last.
Void the thing's previous' next.
\ set up the right chain
Put the thing into the right things' first.
Void the thing's previous.
Put the things' last into the right things' last.
\ fix the original chain
Clear the things.

\PAL
Para desmembrar uma wyrd em um byte e outro byte;
Para dividir uma wyrd em um byte e outro byte;
\CAL
To split a_ wyrd into a_ byte and another byte:
Privatize the wyrd.
Shift the wyrd right 8 bits.
Put the wyrd into the byte.
Put the original wyrd into the other byte.

a_ spot is a_ pair with
an x-coord
and a_ y-coord
and a_ left at the x-coord
and a_ top at the y-coord
\PAL
e uma coordenada chamada coordenada-x at the x-coord
e uma coordenada chamada coordenada-y at the y-coord
e uma coordenada chamada esquerda at the x-coord
e uma coordenada chamada topo at the y-coord.

a_ spot pointer is a_ pointer to a_ spot.

a_ square is 1440 units. \ arbitrary number high enough for precision divides

a_ square root is a_ number.

The square size is some twips.

To square up any selection in a_ text:
If the text is nil, exit.
If nothing is selected in the text, exit.
Normalize the text's selection.
Get a_ row given the text's caret row# and the text.
Put 1 into the text's anchor column#.
If the text's caret column# is not 1, add 1 to the text's caret row#; put 1 into the text's caret column#.
If the text's caret row# is less than or equal to the text's row count, exit.
Put the text's row count into the text's caret's row#.
Put the row's string's length into the text's caret's column#.

The squirt o' two is a_ fraction equal to 99/70.

a_ stack entry is a_ thing with a_ string.

The stack is some stack entries.

\PAL
Para iniciar em qualquer lugar de uma caixa;
\CAL
To start anywhere in a_ box:
Pick the context's spot in the box.

\PAL
Para iniciar em qualquer lugar de uma reta horizontal;
\CAL
To start anywhere on a_ horizontal line:
Pick a_ spot on the horizontal line.
Put the spot into the context's spot.

To start at the bottom left corner of a_ box facing east:
Put the box's left-bottom into the context's spot.
Face east.

To start at the bottom left corner of a_ box facing north:
Put the box's left-bottom into the context's spot.
Face north.

To start at the bottom left corner of a_ box facing south:
Put the box's left-bottom into the context's spot.
Face south.

To start at the bottom left corner of a_ box facing west:
Put the box's left-bottom into the context's spot.
Face west.

To start at the bottom of a_ horizontal line:
Put the vertical line's end into the context's spot.

To start at the bottom right corner of a_ box facing east:
Put the box's right-bottom into the context's spot.
Face east.

To start at the bottom right corner of a_ box facing north:
Put the box's right-bottom into the context's spot.
Face north.

To start at the bottom right corner of a_ box facing south:
Put the box's right-bottom into the context's spot.
Face south.

To start at the bottom right corner of a_ box facing west:
Put the box's right-bottom into the context's spot.
Face west.

To start at the left of a_ horizontal line:
Put the horizontal line's start into the context's spot.

To start at the middle of the bottom of a_ box;
To start in the middle of the bottom of a_ box;
To start at the center of the bottom of a_ box;
To start in the center of the bottom of a_ box:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's bottom into the context's spot's y-coord.

To start at the middle of the bottom of a_ box facing east;
To start in the middle of the bottom of a_ box facing east;
To start at the center of the bottom of a_ box facing east;
To start in the center of the bottom of a_ box facing east:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's bottom into the context's spot's y-coord.
Face east.

To start at the middle of the bottom of a_ box facing north;
To start in the middle of the bottom of a_ box facing north;
To start at the center of the bottom of a_ box facing north;
To start in the center of the bottom of a_ box facing north:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's bottom into the context's spot's y-coord.
Face north.

To start at the middle of the bottom of a_ box facing south;
To start in the middle of the bottom of a_ box facing south;
To start at the center of the bottom of a_ box facing south;
To start in the center of the bottom of a_ box facing south:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's bottom into the context's spot's y-coord.
Face south.

To start at the middle of the bottom of a_ box facing west;
To start in the middle of the bottom of a_ box facing west;
To start at the center of the bottom of a_ box facing west;
To start in the center of the bottom of a_ box facing west:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's bottom into the context's spot's y-coord.
Face west.

To start at the middle of the left of a_ box facing east;
To start in the middle of the left of a_ box facing east;
To start at the center of the left of a_ box facing east;
To start in the center of the left of a_ box facing east:
Put the box's left into the context's spot's x-coord.
Put the box's center's y-coord into the context's spot's y-coord.
Face east.

To start at the middle of the left of a_ box facing north;
To start in the middle of the left of a_ box facing north;
To start at the center of the left of a_ box facing north;
To start in the center of the left of a_ box facing north:
Put the box's left into the context's spot's x-coord.
Put the box's center's y-coord into the context's spot's y-coord.
Face north.

To start at the middle of the left of a_ box facing south;
To start in the middle of the left of a_ box facing south;
To start at the center of the left of a_ box facing south;
To start in the center of the left of a_ box facing south:
Put the box's left into the context's spot's x-coord.
Put the box's center's y-coord into the context's spot's y-coord.
Face south.

To start at the middle of the left of a_ box facing west;
To start in the middle of the left of a_ box facing west;
To start at the center of the left of a_ box facing west;
To start in the center of the left of a_ box facing west:
Put the box's left into the context's spot's x-coord.
Put the box's center's y-coord into the context's spot's y-coord.
Face west.

To start at the middle of the right of a_ box facing east;
To start in the middle of the right of a_ box facing east;
To start at the center of the right of a_ box facing east;
To start in the center of the right of a_ box facing east:
Put the box's right into the context's spot's x-coord.
Put the box's center's y-coord into the context's spot's y-coord.
Face east.

To start at the middle of the right of a_ box facing north;
To start in the middle of the right of a_ box facing north;
To start at the center of the right of a_ box facing north;
To start in the center of the right of a_ box facing north:
Put the box's right into the context's spot's x-coord.
Put the box's center's y-coord into the context's spot's y-coord.
Face north.

To start at the middle of the right of a_ box facing south;
To start in the middle of the right of a_ box facing south;
To start at the center of the right of a_ box facing south;
To start in the center of the right of a_ box facing south:
Put the box's right into the context's spot's x-coord.
Put the box's center's y-coord into the context's spot's y-coord.
Face south.

To start at the middle of the right of a_ box facing west;
To start in the middle of the right of a_ box facing west;
To start at the center of the right of a_ box facing west;
To start in the center of the right of a_ box facing west:
Put the box's right into the context's spot's x-coord.
Put the box's center's y-coord into the context's spot's y-coord.
Face west.

To start at the middle of the top of a_ box;
To start in the middle of the top of a_ box;
To start at the center of the top of a_ box;
To start in the center of the top of a_ box:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's top into the context's spot's y-coord.

To start at the middle of the top of a_ box facing east;
To start in the middle of the top of a_ box facing east;
To start at the center of the top of a_ box facing east;
To start in the center of the top of a_ box facing east:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's top into the context's spot's y-coord.
Face east.

To start at the middle of the top of a_ box facing north;
To start in the middle of the top of a_ box facing north;
To start at the center of the top of a_ box facing north;
To start in the center of the top of a_ box facing north:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's top into the context's spot's y-coord.
Face north.

To start at the middle of the top of a_ box facing south;
To start in the middle of the top of a_ box facing south;
To start at the center of the top of a_ box facing south;
To start in the center of the top of a_ box facing south:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's top into the context's spot's y-coord.
Face south.

To start at the middle of the top of a_ box facing west;
To start in the middle of the top of a_ box facing west;
To start at the center of the top of a_ box facing west;
To start in the center of the top of a_ box facing west:
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's top into the context's spot's y-coord.
Face west.

To start at the right of a_ horizontal line:
Put the horizontal line's end into the context's spot.

\PAL
Para iniciar em um loco;
\CAL
To start at a_ spot:
Put the spot into the context's spot.

To start at a_ spot facing east:
Put the spot into the context's spot.
Face east.

To start at a_ spot facing north:
Put the spot into the context's spot.
Face north.

To start at a_ spot facing south:
Put the spot into the context's spot.
Face south.

To start at a_ spot facing west:
Put the spot into the context's spot.
Face west.

To start at the top left corner of a_ box facing east:
Put the box's left-top into the context's spot.
Face east.

To start at the top left corner of a_ box facing north:
Put the box's left-top into the context's spot.
Face north.

To start at the top left corner of a_ box facing south:
Put the box's left-top into the context's spot.
Face south.

To start at the top left corner of a_ box facing west:
Put the box's left-top into the context's spot.
Face west.

To start at the top of a_ vertical line:
Put the vertical line's start into the context's spot.

To start at the top right corner of a_ box facing east:
Put the box's right-top into the context's spot.
Face east.

To start at the top right corner of a_ box facing north:
Put the box's right-top into the context's spot.
Face north.

To start at the top right corner of a_ box facing south:
Put the box's right-top into the context's spot.
Face south.

To start at the top right corner of a_ box facing west:
Put the box's right-top into the context's spot.
Face west.

To start in the middle of a_ box facing east;
To start at the middle of a_ box facing east;
To move to the middle of a_ box facing east;
To move to the middle of a_ box and face east;
To start in the center of a_ box facing east;
To start at the center of a_ box facing east;
To move to the center of a_ box facing east;
To move to the center of a_ box and face east:
Put the box's center into the context's spot.
Face east.

To start in the middle of a_ box facing north;
To start at the middle of a_ box facing north;
To move to the middle of a_ box facing north;
To move to the middle of a_ box and face north;
To start in the center of a_ box facing north;
To start at the center of a_ box facing north;
To move to the center of a_ box facing north;
To move to the center of a_ box and face north:
Put the box's center into the context's spot.
Face north.

To start in the middle of a_ box facing north minus some points;
To start in the center of a_ box facing north minus some points:
Put the box's center into the context's spot.
Face north.
Turn left the points.

To start in the middle of a_ box facing south;
To start at the middle of a_ box facing south;
To move to the middle of a_ box facing south;
To move to the middle of a_ box and face south;
To start in the center of a_ box facing south;
To start at the center of a_ box facing south;
To move to the center of a_ box facing south;
To move to the center of a_ box and face south:
Put the box's center into the context's spot.
Face south.

To start in the middle of a_ box facing west;
To start at the middle of a_ box facing west;
To move to the middle of a_ box facing west;
To move to the middle of a_ box and face west;
To start in the center of a_ box facing west;
To start at the center of a_ box facing west;
To move to the center of a_ box facing west;
To move to the center of a_ box and face west:
Put the box's center into the context's spot.
Face west.

To start a_ process given a_ path: \ must be called with a global variable
Clear o erro de e/s.
If the process is not 0, put "Lo lamento, pero el proceso ya se está ejecutando." into o erro de e/s; exit.
Put a_ startupinfo's magnitude into the startupinfo's cb.
Extract a_ directory from the path. null terminate the directory.
Privatize the path. null terminate the path.
Call "kernel32.dll" "CreateProcessA" with the path's first and 0 and 0 and 0 and 0 and 67108904 [create_default_error_mode + normal_priority_class + detached_process] and 0 
And the directory's first and the startupinfo's whereabouts and a_ processinfo's whereabouts returning a_ number.
If the number is 0, put "No puedo ejecutar el programa." into o erro de e/s; exit.
Put the processinfo's hprocess into the process.
Call "kernel32.dll" "CloseHandle" with the processinfo's hthread.
Point a_ pointer to routine wait for_ a_ process pointer.
Call "kernel32.dll" "CreateThread" with 0 and 0 and the pointer and the process's whereabouts and 0 and another number's whereabouts returning a_ handle.
Call "kernel32.dll" "CloseHandle" with the handle. \ does not end the thread, just dumps the handle

\PAL
Para iniciar um temporizador;
\CAL
To start a_ timer:
Reset the timer.
Restart the timer.

To start some twips above the middle of the bottom of a_ box: \ incomplete set of these
Put the box's center's x-coord into the context's spot's x-coord.
Put the box's bottom minus the twips into the context's spot's y-coord.

To start some twips down from a_ spot;
To start some twips below a_ spot:
Put the spot's x-coord into the context's x-coord.
Put the spot's y-coord plus the twips into the context's y-coord.

To start some twips from the center of a_ box:
Put the box's center into the context's spot.
Move the twips.

To start some twips to the left and some other twips down from a_ spot;
To start some twips left and some other twips down from a_ spot:
Put the spot's x-coord minus the twips into the context's x-coord.
Put the spot's y-coord plus the other twips into the context's y-coord.

To start some twips left and some other twips up from a_ spot:
Put the spot's x-coord minus the twips into the context's x-coord.
Put the spot's y-coord minus the other twips into the context's y-coord.

To start some twips to the left and some other twips up from a_ spot;
To start some twips to the left of a_ spot;
To start some twips left of a_ spot:
Put the spot's x-coord minus the twips into the context's x-coord.

To start some twips to the right and some other twips down from a_ spot;
To start some twips right and some other twips down from a_ spot:
Put the spot's x-coord plus the twips into the context's x-coord.
Put the spot's y-coord plus the other twips into the context's y-coord.

To start some twips to the right and some other twips up from a_ spot;
To start some twips right and some other twips up from a_ spot:
Put the spot's x-coord plus the twips into the context's x-coord.
Put the spot's y-coord minus the other twips into the context's y-coord.

To start some twips up from a_ coord:
Put the coord minus the twips into the context's y-coord.

To start some twips up from a_ spot;
To start some twips above a_ spot:
Put the spot's y-coord into the context's y-coord.
Subtract the twips from the context's y-coord.

\PAL
Para iniciar o programa;
\CAL
To start up:
Initialize com.
Initialize winsock.
Initialize gdi+.
Initialize the talker.
Initialize the module.
Initialize the colors.
Initialize the screen.
Initialize the window.
Initialize the fonts.
Initialize the cursors.
Initialize the mouse.
Initialize the canvases.
Initialize the context.
Initalize the terminal.
Create the console.

To start up the cgi:
Initialize winsock.
Initialize the module.
Initialize the cgi.

\PAL
Para iniciar com uma cor;
\CAL
To start with a_ color:
Put the color into the context's color.

To start with nothing in a_ pointer:
Void the pointer.

The start-of-heading byte is a_ byte equal to 1.

The start-of-text byte is a_ byte equal to 2.

a_ startupinfo is a_ record with
a_ number called cb,
a_ pointer called lpreserved,
a_ pointer called lpdesktop,
a_ pointer called lptitle,
a_ number called dwx,
a_ number called dwy,
a_ number called dwxsize,
a_ number called dwysize,
a_ number called dwxcountchars,
a_ number called cwycountchars,
a_ number called dwfillattribute,
a_ number called dwflags,
a_ wyrd called wshowwindow,
a_ wyrd called cbreserved2,
a_ pointer called lpreserved2,
a_ handle called hstdinput,
a_ handle called hstdoutput,
a_ handle called hstderror.

The stdin handle is a_ handle.

The stdout handle is a_ handle.

To stop a_ process:
If the process is 0, exit.
Call "kernel32.dll" "TerminateProcess" with the process and 0.
Put 0 into the process.

\PAL
Para parar um temporizador;
Para interromper um temporizador;
\CAL
To stop a_ timer:
If the timer's count is 0, exit.
Subtract 1 from the timer's count.  
If the timer's count is not 0, exit.
Put the system's tick count into some ticks.
Subtract the timer's start ticks from the ticks.
Add the ticks to the timer's total ticks.

a_ string has a_ first byte pointer and a_ last byte pointer
\PAL
e um ponteiro de byte chamado início at the first byte pointer
e um ponteiro de byte chamado final at the last byte pointer.

a_ string thing is a_ thing with
a_ string
\PAL
e uma sequência at the string.

a_ string# is a_ number.

To stroke the accent glyph:
Save the context.
Move 4 squares.
Turn right.
Turn right 7/96 of the way.
Stroke 9/4 square.
Restore the context.

To stroke the asterisk glyph:
Save the context.
Move 2 squares.
Turn right.
Stroke 2 squares.
Turn left.
Move 1 square.
Turn left.
Move 1 square.
Turn left.
Stroke 2 squares.
Reset the context.
Move 1 square.
Turn right 1/8.
Stroke 2 squares slantways.
Reset the context.
Move 3 squares.
Turn right 3/8.
Stroke 2 squares slantways.
Restore the context.

To stroke the at-sign glyph:
Save the context.
Turn right.
Move 2 squares.
Turn around.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn right 3/8.
Stroke 1/2 square slantways.
Turn left.
Stroke 1/2 square slantways.
Turn left.
Stroke 1/2 square slantways.
Turn left.
Stroke 1/2 square slantways.
Restore the context.

To stroke the backslash glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Turn left 7/96 of the way.
Stroke 9/2 square.
Restore the context.

To stroke the big-a glyph:
Save the context.
Stroke 3 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 3 squares.
Turn around.
Move 2 squares.
Turn left.
Stroke 1 square.
Restore the context.

To stroke the big-b glyph:
Save the context.
Stroke 4 squares.
Turn right.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the big-c glyph:
Save the context.
Move 2 squares.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Reset the context.
Move 2 squares.
Turn around.
Stroke 1 square.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Restore the context.

To stroke the big-d glyph:
Save the context.
Stroke 4 squares.
Turn right.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Restore the context.

To stroke the big-e glyph:
Save the context.
Stroke 4 squares.
Turn right.
Stroke 2 squares.
Reset the context.
Move 2 squares.
Turn right.
Stroke 1 square.
Reset the context.
Turn right.
Stroke 2 squares.
Restore the context.

To stroke the big-f glyph:
Save the context.
Stroke 4 squares.
Turn right.
Stroke 2 squares.
Reset the context.
Move 2 squares.
Turn right.
Stroke 1 square.
Restore the context.

To stroke the big-g glyph:
Save the context.
Move 2 squares.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Reset the context.
Move 2 squares.
Turn around.
Stroke 1 square.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1 square.
Turn left.
Stroke 1 square.
Restore the context.

To stroke the big-h glyph:
Save the context.
Stroke 4 squares.
Reset the context.
Move 2 squares.
Turn right.
Stroke 2 squares.
Reset the context.
Turn right.
Move 2 squares.
Turn left.
Stroke 4 squares.
Restore the context.

To stroke the big-i glyph:
Save the context.
Turn right.
Move 1 square.
Turn left.
Stroke 4 squares.
Reset the context.
Turn right.
Stroke 2 squares.
Reset the context.
Move 4 squares.
Turn right.
Stroke 2 squares.
Restore the context.

To stroke the big-j glyph:
Save the context.
Move 2 squares.
Turn around.
Stroke 1 square.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 3 squares.
Restore the context.

To stroke the big-k glyph:
Save the context.
Stroke 4 squares.
Turn around.
Move 2 squares.
Turn left.
Stroke 1 square.
Save the context.
Turn left 1/8.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1 square.
Restore the context.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Restore the context.

To stroke the big-l glyph:
Save the context.
Move 4 squares.
Turn around.
Stroke 4 squares.
Turn left.
Stroke 2 squares.
Restore the context.

To stroke the big-m glyph:
Save the context.
Stroke 4 squares.
Turn right 41/96.
Stroke 9/4 square.
Turn right 62/96.
Stroke 9/4 square.
Turn right 41/96.
Stroke 4 squares.
Restore the context.

To stroke the big-n glyph:
Save the context.
Stroke 4 squares.
Turn right 41/96.
Stroke 9/2 square.
Turn left 41/96.
Stroke 4 squares.
Restore the context.

To stroke the big-o glyph:
Save the context.
Move 1 square.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/4.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/4.
Stroke 1 square slantways.
Restore the context.

To stroke the big-p glyph:
Save the context.
Stroke 4 squares.
Turn right.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the big-q glyph:
Save the context.
Move 1 square.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/4.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/4.
Stroke 1 square slantways.
Reset the context.
Move 1 square.
Turn right.
Move 1 square.
Turn right 1/8 of the way.
Stroke 1-1/2 square.
Restore the context.

To stroke the big-r glyph:
Save the context.
Stroke 4 squares.
Turn right.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn left 1/8.
Turn left 7/96.
Stroke 7/2 square.
Restore the context.

To stroke the big-s glyph:
Save the context.
Move 1 square.
Turn around.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left.
Stroke 2 squares slantways.
Turn right.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the big-t glyph:
Save the context.
Turn right.
Move 1 square.
Turn left.
Stroke 4 squares.
Turn left.
Move 1 square.
Turn around.
Stroke 2 squares.
Restore the context.

To stroke the big-u glyph:
Save the context.
Move 4 squares.
Turn around.
Stroke 4 squares.
Turn left.
Stroke 2 squares.
Turn left.
Stroke 4 squares.
Restore the context.

To stroke the big-v glyph:
Save the context.
Move 4 squares.
Turn around.
Stroke 3 squares.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 3 squares.
Restore the context.

To stroke the big-w glyph:
Save the context.
Move 4 squares.
Turn around.
Stroke 4 squares.
Turn left 41/96.
Stroke 9/4 square.
Turn left 61/96.
Stroke 9/4 square.
Turn left 41/96.
Stroke 4 squares.
Restore the context.

To stroke the big-x glyph:
Save the context.
Stroke 1 square.
Turn right 1/8.
Stroke 2 squares slantways.
Turn left 1/8.
Stroke 1 square.
Reset the context.
Turn right.
Move 2 squares.
Turn left.
Stroke 1 square.
Turn left 1/8.
Stroke 2 squares slantways.
Turn right 1/8.
Stroke 1 square.
Restore the context.

To stroke the big-y glyph:
Save the context.
Move 4 squares.
Turn around.
Stroke 1 square.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1 square.
Reset the context.
Turn right.
Move 1 square.
Turn left.
Stroke 2 squares.
Restore the context.

To stroke the big-z glyph:
Save the context.
Move 4 squares.
Turn right.
Stroke 2 squares.
Turn right.
Stroke 1 square.
Turn right 1/8.
Stroke 2 squares slantways.
Turn left 1/8.
Stroke 1 square.
Turn left.
Stroke 2 squares.
Restore the context.

\PAL
Para rabiscar uma caixa com uma cor;
\CAL
To stroke a_ box with a_ color:
Put the color into the context's color.
Put the box's left-bottom into the context's spot.
Face north.
Stroke the box's height.
Turn right.
Stroke the box's width.
Turn right.
Stroke the box's height.
Turn right.
Stroke the box's width.

\PAL
Para rabiscar um byte;
\CAL
To stroke a_ byte:
Put the context's letter height divided by 4 into the square size. \ ***
If the byte is the accent byte, stroke the accent glyph.
If the byte is the asterisk byte, stroke the asterisk glyph.
If the byte is the at-sign byte, stroke the at-sign glyph.
If the byte is the backslash byte, stroke the backslash glyph.
If the byte is the big-a byte, stroke the big-a glyph.
If the byte is the big-b byte, stroke the big-b glyph.
If the byte is the big-c byte, stroke the big-c glyph.
If the byte is the big-d byte, stroke the big-d glyph.
If the byte is the big-e byte, stroke the big-e glyph.
If the byte is the big-f byte, stroke the big-f glyph.
If the byte is the big-g byte, stroke the big-g glyph.
If the byte is the big-h byte, stroke the big-h glyph.
If the byte is the big-i byte, stroke the big-i glyph.
If the byte is the big-j byte, stroke the big-j glyph.
If the byte is the big-k byte, stroke the big-k glyph.
If the byte is the big-l byte, stroke the big-l glyph.
If the byte is the big-m byte, stroke the big-m glyph.
If the byte is the big-n byte, stroke the big-n glyph.
If the byte is the big-o byte, stroke the big-o glyph.
If the byte is the big-p byte, stroke the big-p glyph.
If the byte is the big-q byte, stroke the big-q glyph.
If the byte is the big-r byte, stroke the big-r glyph.
If the byte is the big-s byte, stroke the big-s glyph.
If the byte is the big-t byte, stroke the big-t glyph.
If the byte is the big-u byte, stroke the big-u glyph.
If the byte is the big-v byte, stroke the big-v glyph.
If the byte is the big-w byte, stroke the big-w glyph.
If the byte is the big-x byte, stroke the big-x glyph.
If the byte is the big-y byte, stroke the big-y glyph.
If the byte is the big-z byte, stroke the big-z glyph.
If the byte is the caret byte, stroke the caret glyph.
If the byte is the colon byte, stroke the colon glyph.
If the byte is the comma byte, stroke the comma glyph.
If the byte is the dollar-sign byte, stroke the dollar-sign glyph.
If the byte is the double-quote byte, stroke the double-quote glyph.
If the byte is the eight byte, stroke the eight glyph.
If the byte is the equal-sign byte, stroke the equal-sign glyph.
If the byte is the exclamation-mark byte, stroke the exclamation-mark glyph.
If the byte is the five byte, stroke the five glyph.
If the byte is the four byte, stroke the four glyph.
If the byte is the left-alligator byte, stroke the left-alligator glyph.
If the byte is the left-brace byte, stroke the left-brace glyph.
If the byte is the left-bracket byte, stroke the left-bracket glyph.
If the byte is the left-paren byte, stroke the left-paren glyph.
If the byte is the little-a byte, stroke the little-a glyph.
If the byte is the little-b byte, stroke the little-b glyph.
If the byte is the little-c byte, stroke the little-c glyph.
If the byte is the little-d byte, stroke the little-d glyph.
If the byte is the little-e byte, stroke the little-e glyph.
If the byte is the little-f byte, stroke the little-f glyph.
If the byte is the little-g byte, stroke the little-g glyph.
If the byte is the little-h byte, stroke the little-h glyph.
If the byte is the little-i byte, stroke the little-i glyph.
If the byte is the little-j byte, stroke the little-j glyph.
If the byte is the little-k byte, stroke the little-k glyph.
If the byte is the little-l byte, stroke the little-l glyph.
If the byte is the little-m byte, stroke the little-m glyph.
If the byte is the little-n byte, stroke the little-n glyph.
If the byte is the little-o byte, stroke the little-o glyph.
If the byte is the little-p byte, stroke the little-p glyph.
If the byte is the little-q byte, stroke the little-q glyph.
If the byte is the little-r byte, stroke the little-r glyph.
If the byte is the little-s byte, stroke the little-s glyph.
If the byte is the little-t byte, stroke the little-t glyph.
If the byte is the little-u byte, stroke the little-u glyph.
If the byte is the little-v byte, stroke the little-v glyph.
If the byte is the little-w byte, stroke the little-w glyph.
If the byte is the little-x byte, stroke the little-x glyph.
If the byte is the little-y byte, stroke the little-y glyph.
If the byte is the little-z byte, stroke the little-z glyph.
If the byte is the minus-sign byte, stroke the minus-sign glyph.
If the byte is the nine byte, stroke the nine glyph.
If the byte is the number-sign byte, stroke the number-sign glyph.
If the byte is the one byte, stroke the one glyph.
If the byte is the percent-sign byte, stroke the percent-sign glyph.
If the byte is the period byte, stroke the period glyph.
If the byte is the plus-sign byte, stroke the plus-sign glyph.
If the byte is the question-mark byte, stroke the question-mark glyph.
If the byte is the right-alligator byte, stroke the right-alligator glyph.
If the byte is the right-brace byte, stroke the right-brace glyph.
If the byte is the right-bracket byte, stroke the right-bracket glyph.
If the byte is the right-paren byte, stroke the right-paren glyph.
If the byte is the semi-colon byte, stroke the semi-colon glyph.
If the byte is the seven byte, stroke the seven glyph.
If the byte is the single-quote byte, stroke the single-quote glyph.
If the byte is the six byte, stroke the six glyph.
If the byte is the slash byte, stroke the slash glyph.
If the byte is the three byte, stroke the three glyph.
If the byte is the tilde byte, stroke the tilde glyph.
If the byte is the two byte, stroke the two glyph.
If the byte is the underscore byte, stroke the underscore glyph.
If the byte is the vertical-bar byte, stroke the vertical-bar glyph.
If the byte is the zero byte, stroke the zero glyph.
\ Refresh the screen. \ *** questionable doesn't work screws up console.

To stroke the caret glyph:
Save the context.
Move 3 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the colon glyph:
Save the context.
Turn right.
Move 1 square.
Turn left.
Stroke 1/2 square.
Move 1/2 square.
Move 1 square.
Stroke 1/2 square.
Restore the context.

To stroke the comma glyph:
Save the context.
Turn around.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1/2 square.
Restore the context.

To stroke the dollar-sign glyph:
Save the context.
Move 1 square.
Turn around.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left.
Stroke 2 squares slantways.
Turn right.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Reset the context.
Turn right.
Move 1 square.
Turn right.
Move 1/2 square.
Turn around.
Stroke 5 squares.
Restore the context.

To stroke the double-quote glyph:
Save the context.
Turn right.
Move 1/2 square.
Turn left.
Move 2-1/2 squares.
Stroke 1-1/2 squares.
Reset the context.
Turn right.
Move 1-1/2 squares.
Turn left.
Move 2-1/2 squares.
Stroke 1-1/2 squares.
Restore the context.

To stroke the eight glyph:
Save the context.
Turn right.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 2 squares slantways.
Turn left.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left.
Stroke 2 squares slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the equal-sign glyph:
Save the context.
Move 1-1/2 squares.
Turn right.
Stroke 2 squares.
Turn left.
Move 1 square.
Turn left.
Stroke 2 squares.
Restore the context.

To stroke the exclamation-mark glyph:
Save the context.
Move 4 squares.
Turn right.
Move 1 square.
Turn right.
Stroke 3 squares.
Move 1 square.
Stroke 1/2 square.
Restore the context.

To stroke the five glyph:
Save the context.
Turn around.
Move 1 square.
Turn left 3/8.
Stroke 2 squares slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1 square.
Turn right.
Stroke 2 squares.
Turn right.
Stroke 2 squares.
Restore the context.

To stroke the four glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Stroke 4 squares.
Turn left 3/8.
Stroke 2 squares slantways.
Turn left 3/8.
Stroke 1 square.
Restore the context.

To stroke the left-alligator glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Move 1 square.
Turn left 17/96 of the way.
Stroke 9/4 square.
Turn right 34/96 of the way.
Stroke 9/4 square.
Restore the context.

To stroke the left-brace glyph:
Save the context.
Turn right.
Move 2 squares.
Turn around.
Stroke 1 square.
Turn right.
Stroke 1 square.
Turn left 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1 square.
Turn right.
Stroke 1 square.
Restore the context.

To stroke the left-bracket glyph:
Save the context.
Turn right.
Move 2 squares.
Turn around.
Stroke 1 square.
Turn right.
Stroke 4 squares.
Turn right.
Stroke 1 square.
Restore the context.

To stroke the left-paren glyph:
Save the context.
Turn right.
Move 1-1/2 squares.
Turn left 3/8.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Restore the context.

To stroke a_ line as_ high as_ a_ box;
To stroke a_ line as_ tall as_ a_ box;
To draw a_ line as_ high as_ a_ box;
To draw a_ line as_ tall as_ a_ box:
Stroke the box's height.

To stroke a_ line as_ wide as_ a_ box;
To draw a_ line as_ wide as_ a_ box:
Stroke the box's width.

To stroke the little-a glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Stroke 3 squares.
Turn around.
Move 1 square.
Turn right 3/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1 square.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Restore the context.

To stroke the little-b glyph:
Save the context.
Stroke 4 squares.
Turn around.
Move 2 squares.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the little-c glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the little-d glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Stroke 4 squares.
Turn around.
Move 2 squares.
Turn right 3/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1 square.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Restore the context.

To stroke the little-e glyph:
Save the context.
Turn right.
Move 2 squares.
Turn around.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1/2 square.
Turn right.
Stroke 2 squares.
Restore the context.

To stroke the little-f glyph:
Save the context.
Turn right.
Move 1 square.
Turn left.
Save the context.
Turn around.
Turn right 1/8.
Stroke 1 square slantways.
Restore the context.
Stroke 4 squares.
Turn right 1/8.
Stroke 1 square slantways.
Reset the context.
Move 3 squares.
Turn right.
Stroke 2 squares.
Restore the context.

To stroke the little-g glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Reset the context.
Move 3 squares.
Turn right.
Move 2 squares.
Turn right.
Stroke 3 squares.
Turn right 1/8.
Stroke 1-1/2 square slantways.
Restore the context.

To stroke the little-h glyph:
Save the context.
Stroke 4 squares.
Turn around.
Move 2 squares.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 2 squares.
Restore the context.

To stroke the little-i glyph:
Save the context.
Turn right.
Stroke 2 squares.
Turn around.
Move 1 square.
Turn right.
Stroke 3 squares.
Turn left.
Stroke 1 square.
Turn around.
Move 1 square.
Turn left.
Move 1/2 square.
Stroke 1/2 square.
Restore the context.

To stroke the little-j glyph:
Save the context.
Move 1 square.
Turn around.
Stroke 1 square.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 3 squares.
Move 1/2 square.
Stroke 1/2 square.
Restore the context.

To stroke the little-k glyph:
Save the context.
Stroke 4 squares.
Turn around.
Move 2 squares.
Turn left 1/8.
Stroke 2 squares slantways.
Reset the context.
Move 2 squares.
Turn right 17/96.
Stroke 9/4 square.
Restore the context.

To stroke the little-l glyph:
Save the context.
Turn right.
Stroke 2 squares.
Turn around.
Move 1 square.
Turn right.
Stroke 4 squares.
Turn left.
Stroke 1 square.
Restore the context.

To stroke the little-m glyph:
Save the context.
Stroke 3 squares.
Turn around.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn right 3/8.
Stroke 2 squares.
Turn around.
Move 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 3/8.
Stroke 3 squares.
Restore the context.

To stroke the little-n glyph:
Save the context.
Stroke 3 squares.
Turn around.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 2 squares.
Restore the context.

To stroke the little-o glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Restore the context.

To stroke the little-p glyph:
Save the context.
Move 3 squares.
Turn around.
Stroke 4 squares.
Turn around.
Move 3 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the little-q glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn left 3/8.
Move 1 square.
Turn around.
Stroke 4 squares.
Restore the context.

To stroke the little-r glyph:
Save the context.
Stroke 3 squares.
Turn around.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the little-s glyph:
Save the context.
Move 1 square.
Turn right 3/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Reset the context.
Move 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Reset the context.
Move 2 squares.
Turn right 31/96.
Stroke 9/4 squares.
Restore the context.

To stroke the little-t glyph:
Save the context.
Turn right.
Move 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Reset the context.
Turn right.
Move 1 square.
Turn left.
Stroke 4 squares.
Turn around.
Move 1 square.
Turn right.
Move 1 square.
Turn around.
Stroke 2 squares.
Restore the context.

To stroke the little-u glyph:
Save the context.
Move 3 squares.
Turn around.
Stroke 2 squares.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Move 2 squares.
Turn around.
Stroke 3 squares.
Restore the context.

To stroke the little-v glyph:
Save the context.
Move 3 squares.
Turn around.
Stroke 2 squares.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 2 squares.
Restore the context.

To stroke the little-w glyph:
Save the context.
Move 3 squares.
Turn around.
Stroke 3 squares.
Turn around.
Turn right 7/96.
Stroke 9/4 squares.
Turn right 34/96.
Stroke 9/4 squares.
Turn left 41/96.
Stroke 3 squares.
Restore the context.

To stroke the little-x glyph:
Save the context.
Stroke 1 square.
Turn right 17/96.
Stroke 9/4 square.
Turn left 17/96.
Stroke 1 square.
Reset the context.
Turn right.
Move 2 squares.
Turn left.
Stroke 1 square.
Turn left 17/96.
Stroke 9/4 square.
Turn right 17/96.
Stroke 1 square.
Restore the context.

To stroke the little-y glyph:
Save the context.
Move 3 squares.
Turn around.
Stroke 2 squares.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Move 2 squares.
Turn around.
Stroke 3 squares.
Turn right 1/8.
Stroke 1-1/2 squares slantways.
Restore the context.

To stroke the little-z glyph:
Save the context.
Move 3 squares.
Turn right.
Stroke 2 squares.
Turn right.
Stroke 1 square.
Turn right 17/96.
Stroke 9/4 square.
Turn left 17/96.
Stroke 1 square.
Turn left.
Stroke 2 squares.
Restore the context.

To stroke the minus-sign glyph:
Save the context.
Move 2 squares.
Turn right.
Stroke 2 squares.
Restore the context.

To stroke the nine glyph:
Save the context.
Move 1 square.
Turn right 3/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 2 squares.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Restore the context.

To stroke the number-sign glyph:
Save the context.
Move 3 squares.
Turn right.
Stroke 2 squares.
Reset the context.
Move 1 square.
Turn right.
Stroke 2 squares.
Reset the context.
Turn right.
Move 1/2 square.
Turn left.
Stroke 4 squares.
Reset the context.
Turn right.
Move 1-1/2 squares.
Turn left.
Stroke 4 squares.
Restore the context.

To stroke the one glyph:
Save the context.
Turn right.
Move 1 square.
Turn left.
Stroke 4 squares.
Reset the context.
Turn right.
Stroke 2 squares.
Reset the context.
Move 3 squares.
Turn right 1/8.
Stroke 1 square slantways.
Restore the context.

To stroke the percent-sign glyph:
Save the context.
Turn right 7/96.
Stroke 9/2 squares.
Reset the context.
Move 2-1/2 squares.
Stroke 1/2 square.
Reset the context.
Turn right.
Move 2 squares.
Turn left.
Move 1 square.
Stroke 1/2 square.
Restore the context.

To stroke the period glyph:
Save the context.
Turn right.
Move 1 square.
Turn left.
Stroke 1/2 square.
Restore the context.

To stroke the plus-sign glyph:
Save the context.
Move 2 squares.
Turn right.
Stroke 2 squares.
Turn left.
Move 1 square.
Turn left.
Move 1 square.
Turn left.
Stroke 2 squares.
Restore the context.

To stroke the question-mark glyph:
Save the context.
Move 3 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1 square.
Move 1 square.
Stroke 1/2 square.
Restore the context.

To stroke the right-alligator glyph:
Save the context.
Move 1 square.
Turn right 17/96 of the way.
Stroke 9/4 square.
Turn left 34/96 of the way.
Stroke 9/4 square.
Restore the context.

To stroke the right-brace glyph:
Save the context.
Turn right.
Stroke 1 square.
Turn left.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 1 square.
Turn left.
Stroke 1 square.
Restore the context.

To stroke the right-bracket glyph:
Save the context.
Turn right.
Stroke 1 square.
Turn left.
Stroke 4 squares.
Turn left.
Stroke 1 square.
Restore the context.

To stroke the right-paren glyph:
Save the context.
Turn right.
Move 1/2 square.
Turn left.
Turn right 1/8.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 2 squares.
Turn left 1/8.
Stroke 1 square slantways.
Restore the context.

To stroke the semi-colon glyph:
Save the context.
Turn around.
Move 1 square.
Turn left 3/8.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 1/2 square.
Move 1/2 square.
Move 1 square.
Stroke 1/2 square.
Restore the context.

To stroke the seven glyph:
Save the context.
Move 3 squares.
Stroke 1 square.
Turn right.
Stroke 2 squares.
Turn right.
Stroke 1 square.
Turn right 1/8.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 2 squares.
Restore the context.

To stroke the single-quote glyph:
Save the context.
Turn right.
Move 1 square.
Turn left.
Move 2-1/2 squares.
Stroke 1-1/2 squares.
Restore the context.

To stroke the six glyph:
Save the context.
Turn right.
Move 2 squares.
Turn left.
Move 3 squares.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left 1/8.
Stroke 2 squares.
Turn left 1/8.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Restore the context.

To stroke the slash glyph:
Save the context.
Turn right 7/96 of the way.
Stroke 9/2 square.
Restore the context.

To stroke some squares:
Stroke the square size times the squares divided by 1 square. \ squares are scaled up for precision hence the division at the end

To stroke some squares diagonally;
To stroke some squares slantways:
Stroke the square size times the squares times the squirt o' two divided by 1 square. \ squares are scaled up for precision hence the division at the end

To stroke the three glyph:
Save the context.
Move 3 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn left.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Restore the context.

To stroke the tilde glyph:
Save the context.
Move 2 squares.
Turn right 7/96 of the way.
Stroke 9/8 square.
Turn right.
Stroke 9/6 square.
Turn left.
Stroke 9/8 square.
Restore the context.

To stroke some twips:
Draw a_ line the twips long.

To stroke the two glyph:
Save the context.
Move 3 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right.
Stroke 1 square slantways.
Turn right.
Stroke 2 squares slantways.
Turn left 1/8.
Stroke 1 square.
Turn left.
Stroke 2 squares.
Restore the context.

To stroke the underscore glyph:
Save the context.
Turn around.
Move 1 square.
Turn left.
Stroke 2 squares.
Restore the context.

To stroke the vertical-bar glyph:
Save the context.
Turn right.
Move 1 square.
Turn right.
Move 1 square.
Turn around.
Stroke 5 squares.
Restore the context.

To stroke the zero glyph:
Save the context.
Move 1 square.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/4.
Stroke 1 square slantways.
Turn right 1/8.
Stroke 2 squares.
Turn right 1/8.
Stroke 1 square slantways.
Turn right 1/4.
Stroke 1 square slantways.
Turn right 1/8.
Move 1 square.
Turn right.
Move 1 square.
Stroke 1 pixel.
Restore the context.

a_ subject is a_ string.

The substitute byte is a_ byte equal to 26.

a_ substring is a_ string.

\PAL
Para subtrair um byte de outro byte;
\CAL
To subtract a_ byte from another byte:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other byte
Intel $2803. \ sub [ebx],al

\PAL
Para subtrair um byte de um número;
\CAL
To subtract a_ byte from a_ number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the byte
Intel $0FB600. \ movzx eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the number
Intel $2903. \ sub [ebx],eax

\PAL
Para subtrair uma fração de outra fração;
\CAL
To subtract a_ fraction from another fraction:
Privatize the fraction.
Normalize the fraction and the other fraction.
Subtract the fraction's numerator from the other fraction's numerator.
Reduce the other fraction.

\PAL
Para subtrair um número e outro número de um par;
\CAL
To subtract a_ number and another number from a_ pair:
Subtract the number from the pair's x-number.
Subtract the other number from the pair's y-number.

\PAL
Para subtrair um número de um byte;
\CAL
To subtract a_ number from a_ byte:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the byte
Intel $0FB60B. \ movzx ecx,[ebx]
Intel $2BC8. \ sub ecx,eax
Intel $880B. \ mov [ebx],cl

\PAL
Para subtrair um número de uma fração;
\CAL
To subtract a_ number from a_ fraction:
Subtract the number / 1 from the fraction.

\PAL
Para subtrair um número de um par;
\CAL
To subtract a_ number from a_ pair:
Subtract the number from the pair's x-number.
Subtract the number from the pair's y-number.

\PAL
Para subtrair um par de outro par;
\CAL
To subtract a_ pair from another pair:
Subtract the pair's x-number from the other pair's x-number.
Subtract the pair's y-number from the other pair's y-number.

\PAL
Para subtrair um ponteiro de outro ponteiro;
Para subtrair um número de um ponteiro;
Para subtrair um número de outro número;
\CAL
To subtract a_ pointer from another pointer;
To subtract a_ number from a_ pointer;
To subtract a_ number from another number:
Intel $8B8508000000. \ mov eax,[ebp+8] \ the number
Intel $8B00. \ mov eax,[eax]
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the other number
Intel $2903. \ sub [ebx],eax

The superscript-one byte is a_ byte equal to 185.

The superscript-three byte is a_ byte equal to 179.

The superscript-two byte is a_ byte equal to 178.

\PAL
Para trocar uma cor por outra cor;
Para trocar uma cor para outra cor;
\CAL
To swap a_ color with another color:
Swap the color's hue with the other color's hue.
Swap the color's saturation with the other color's saturation.
Swap the color's lightness with the other color's lightness.

\PAL
Para trocar um par por outro par;
Para trocar um par para outro par;
\CAL
To swap a_ pair with another pair:
Swap the pair's x-number with the other pair's x-number.
Swap the pair's y-number with the other pair's y-number.

\PAL
Para trocar um número por outro número;
Para trocar um número para outro número;
\CAL
To swap a_ pointer with another pointer;
Para intercambiar un número con otro número;
To swap a_ number with another number:
Put the number into a_ third number.
Put the other number into the number.
Put the third number into the other number.

\PAL
Para trocar alguns elementos por alguns outros elementos;
Para trocar alguns elementos para alguns outros elementos;
\CAL
To swap some things with some other things:
Swap the things' first with the other things' first.
Swap the things' last with the other things' last.

The synchronous-idle byte is a_ byte equal to 22.

a_ systemtime is a_ record with
a_ wyrd called wyear,
a_ wyrd called wmonth,
a_ wyrd called wdayofweek,
a_ wyrd called wday,
a_ wyrd called whour,
a_ wyrd called wminute,
a_ wyrd called wsecond,
a_ wyrd called wmilliseconds.

The t-key is a_ key equal to 84.

The tab byte is a_ byte equal to 9.

The tab key is a_ key equal to 9.

To take off all the masking tape: unmask everything.

To take off any masking tape: unmask everything.

a_ talker is a_ pointer to a_ talker object.

The talker is a_ talker.

a_ talker object is a_ record with a_ talker vtable called vtable.

a_ talker vtable is a_ pointer to a_ talker vtable record.

a_ talker vtable record is a_ record with
\ iunknown
a_ pointer called queryinterface,
a_ pointer called addref,
a_ pointer called release, \ in this:pspvoice out number
\ italker
a_ pointer called setnotifysink,
a_ pointer called setnotifywindowmessage,
a_ pointer called setnotifycallbackfunction,
a_ pointer called setnotifycallbackinterface,
a_ pointer called setnotifywin32event,
a_ pointer called waitfornotifyevent,
a_ pointer called getnotifyeventhandle,
a_ pointer called setinterest,
a_ pointer called getevents,
a_ pointer called getinfo,
a_ pointer called setoutput,
a_ pointer called getoutputobjecttoken,
a_ pointer called getoutputstream,
a_ pointer called pause,
a_ pointer called resume,
a_ pointer called setvoice,
a_ pointer called getvoice,
a_ pointer called speak, \ in this:pspvoice; pwcs:pwchar; dwflags:number; pulstreamnumber:pnumber out number
a_ pointer called speakstream,
a_ pointer called getstatus,
a_ pointer called skip,
a_ pointer called setpriority,
a_ pointer called getpriority,
a_ pointer called setalertboundary,
a_ pointer called getalertboundary,
a_ pointer called setrate,
a_ pointer called getrate,
a_ pointer called setvolume,
a_ pointer called getvolume,
a_ pointer called waituntildone,
a_ pointer called setsyncspeaktimeout,
a_ pointer called getsyncspeaktimeout,
a_ pointer called speakcompleteevent,
a_ pointer called isuisupported,
a_ pointer called displayui.

The tan color is a_ color.

The tan pen is a_ pen.

The teal color is a_ color.

The teal pen is a_ pen.

The temp path is a_ path.

The terminal is a_ terminal.

a_ terminal is a_ thing with  a_ box, some quoras, an output color, an input color, and a_ reply string.

The text cutoff is a_ number equal to 500.

a_ text is a_ thing with 
\CAL
a_ box,
An origin,
a_ pen color,
a_ font,
An alignment,
Some rows,
a_ margin,
a_ scale fraction,
a_ wrap flag,
a_ horizontal scroll flag,
a_ vertical scroll flag,
a_ selection,
a_ modified flag,
a_ last operation,
Some texts called undos,
Some texts called redos,
\PAL
uma caixa redefinindo o box,
um loco chamado origem redefinindo a origin,
uma cor redefinindo a pen color,
uma fonte redefinindo o font,
um alinhamento redefinindo o alignment,
algumas linhas redefinindo a rows,
um número chamado margem redefinindo a margin,
uma fração chamada escala redefinindo a scale fraction,
uma signa envolver redefinindo o wrap flag,
uma signa de rolagem horizontal redefinindo o horizontal scroll flag,
uma signa de rolagem vertical redefinindo o vertical scroll flag,
uma seleção redefinindo a selection,
uma signa de modificação redefinindo o modified flag,
uma sequência chamada última operação redefinindo a last operation,
alguns textos chamados desfazer redefinindo o undos,
alguns textos chamados refazer redefinindo o redos.

a_ textmetric is a_ record with
a_ number called tmheight,
a_ number called tmascent,
a_ number called tmdescent,
a_ number called tminternalleading,
a_ number called tmexternalleading,
a_ number called tmavecharwidth,
a_ number called tmmaxcharwidth,
a_ number called tmweight,
a_ number called tmoverhang,
a_ number called tmdigitizedaspectx,
a_ number called tmdigitizedaspecty,
a_ byte called tmfirstchar,
a_ byte called tmlastchar,
a_ byte called tmdefaultchar,
a_ byte called tmbreakchar,
a_ byte called tmitalic,
a_ byte called tmunderlined,
a_ byte called tmstruckout,
a_ byte called tmpitchandfamily,
a_ byte called tmcharset.

a_ thing is a_ pointer to a_ thing record.

a_ thing record has a_ next thing and a_ previous thing.

Some things has a_ first thing and a_ last thing.

a_ thousand is 10 hundreds.

The three byte is a_ byte equal to 51.

The three key is a_ key equal to 51.

The three-quarter byte is a_ byte equal to 190.

a_ tick is a_ number.

The tilde byte is a_ byte equal to 126.

a_ timer has a_ count, some start ticks and some total ticks.

Some times is a_ number. \ this is a fluke, I think -- see "smooth a polygon some times"

a_ token is a_ string.

a_ top is some twips.

The tpi is some twips equal to 1440.

The tpp is some twips.

The trade-mark byte is a_ byte equal to 153.

\PAL
Para aparar uma sequência;
Para podar uma sequência;
\CAL
To trim a_ string:
Remove any leading noise from the string.
Remove any trailing noise from the string.

To turn around:
Turn right 1/2.

To turn a_ fraction equal to a_ number over another number:
Put the number into the fraction's top.
Put the other number into the fraction's bottom.
Turn the fraction.

To turn a_ fraction of the way;
To turn a_ fraction of the way around;
To turn a_ fraction:
If the fraction is 1/1, exit.
Put 3840 times the fraction plus the context's heading into the context's heading.
Normalize the context's heading.

\PAL
Para virar à esquerda;
\CAL
To turn left:
Turn -1/4.

To turn left a_ fraction equal to a_ number over another number:
Put the number into the fraction's top.
Put the other number into the fraction's bottom.
Turn left the fraction.

To turn left a_ fraction of the way;
To turn left a_ fraction of the way around;
To turn left a_ fraction:
Privatize the fraction.
Negate the fraction.
Turn the fraction.

To turn left some points:
Put the points and 3840 into a_ fraction.
Turn left the fraction.

\PAL
Para virar à direita;
\CAL
To turn right:
Turn 1/4.

To turn right some degrees:
Put the degrees times 10 and 3600 into a_ fraction.
Turn right the fraction.

\PAL
Para virar alguns graus;
\CAL
To turn some degrees:
Put the degrees times 10 and 3600 into a_ fraction.
\If the degrees are negative, turn left the fraction; exit.
Turn right the fraction.

To turn right a_ fraction equal to a_ number over another number:
Put the number into the fraction's top.
Put the other number into the fraction's bottom.
Turn right the fraction.

To turn right a_ fraction of the way;
To turn right a_ fraction of the way around;
To turn right a_ fraction:
Turn the fraction.

To turn right a_ fraction of the way some percent of the time;
To turn right a_ fraction about some percent of the time;
To turn right a_ fraction of the way about some percent of the time;
To turn right a_ fraction some percent of the time:
Pick a_ number between 1 and 100.
If the number is greater than the percent, exit.
Turn right the fraction.

To turn right some points:
Put the points and 3840 into a_ fraction.
Turn right the fraction.

a_ twip is a_ number.

The two byte is a_ byte equal to 50.

The two key is a_ key equal to 50.

The u-key is a_ key equal to 85.

To unassign a_ pointer:
If the pointer is nil, exit.
Call "kernel32.dll" "HeapFree" with the heap pointer and 0 [no options] and the pointer returning a_ number.
If the number is 0, exit.
Void the pointer.
Subtract 1 from the heap count.

The underscore byte is a_ byte equal to 95.

a_ unit is a_ number.

The unit-separator byte is a_ byte equal to 31.

To unlock a_ gpbitmap given a_ bitmapdata:
Call "gdiplus.dll" "GdipBitmapUnlockBits" with the gpbitmap and the bitmapdata's whereabouts.

\PAL
Para desmascarar tudo;
\CAL
To unmask everything:
Call "gdi32.dll" "SelectClipRgn" with the current canvas and 0.

\PAL
Para desmascarar dentro de uma caixa;
\CAL
To unmask inside a_ box:
Create an hrgn given the box.
Unmask inside the hrgn.
Destroy the hrgn.

\PAL
Para desmascarar dentro de uma elipse;
\CAL
To unmask inside an ellipse:
Create an hrgn given the ellipse.
Unmask inside the hrgn.
Destroy the hrgn.

To unmask inside an hrgn:
Call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 2 [rgn_or].

\PAL
Para desmascarar dentro de um polígono;
\CAL
To unmask inside a_ polygon:
Create an hrgn given the polygon.
Unmask inside the hrgn.
Destroy the hrgn.

\PAL
Para desmascarar dentro de uma caixa arredondada;
\CAL
To unmask inside a_ roundy box:
Create an hrgn given the roundy box.
Unmask inside the hrgn.
Destroy the hrgn.

\PAL
Para desmascarar fora de uma caixa;
\CAL
To unmask outside a_ box:
Create an hrgn given the box.
Unmask outside the hrgn.
Destroy the hrgn.

\PAL
Para desmascarar fora de uma elipse;
\CAL
To unmask outside an ellipse:
Create an hrgn given the ellipse.
Unmask outside the hrgn.
Destroy the hrgn.

To unmask outside an hrgn:
Create an old hrgn given the zero box.
Call "gdi32.dll" "GetClipRgn" with the current canvas and the old hrgn returning a_ number.
If the number is not 1, clear the old hrgn.
Call "gdi32.dll" "SelectClipRgn" with the current canvas and 0.
Call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the hrgn and 4 [rgn_diff].
Call "gdi32.dll" "ExtSelectClipRgn" with the current canvas and the old hrgn and 2 [rgn_or].
Destroy the old hrgn.

\PAL
Para desmascarar fora de um polígono;
\CAL
To unmask outside a_ polygon:
Create an hrgn given the polygon.
Unmask outside the hrgn.
Destroy the hrgn.

\PAL
Para desmascarar fora de uma caixa arredondada;
\CAL
To unmask outside a_ roundy box:
Create an hrgn given the roundy box.
Unmask outside the hrgn.
Destroy the hrgn.

\PAL
Para remover as aspas de uma sequência;
\CAL
To unquote a_ string:
Slap a_ substring on the string.
If the substring is blank, break.
If the substring's first's target is not the double-quote byte, exit.
Add 1 to the substring's first.
Loop.
If the substring is blank, break.
If the substring's first is the substring's last, break.
Append the substring's first's target to another string.
If the substring's first's target is the double-quote byte, add 1 to the substring's first.
Add 1 to the substring's first.
Repeat.
Put the other string into the string.

The up-arrow key is a_ key equal to 38.

\PAL
Para atualizar a tela;
\CAL
To update the screen;
To show it;
To show it all;
To show reveal the canvas;
To refresh the screen:
Refresh the screen given the screen's box.

To uppercase any selected bytes in a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, exit.
If the row of the text is not selected, repeat.
Slap a_ substring on any selected bytes in the row of the text.  
Uppercase the substring.
Repeat.

\PAL
Para passar para maiúsculas um byte;
Para passar um byte para maiúsculas;
\CAL
To uppercase a_ byte:
Translate the byte using the uppercase ascii table.

To translate a_ byte using a_ translation hex string:
Intel $8B8D08000000. \ mov ecx,[ebp+8] \ the byte pointer
Intel $8B01. \ mov eax,[ecx] \ the byte
Intel $8B9D0C000000. \ mov ebx,[ebp+12] \ the translation table
Intel $8B1B. \ mov ebx,[ebx] the translation table's first
Intel $D7. \ xlat al,[ebx]
Intel $8901. \ mov [ecx],eax

To uppercase the character under a_ finger and put it into a_ string:
If the finger is nil, exit.
Put the finger's target into the string.
Uppercase the string.

\PAL
Para passar para maiúsculas uma sequência;
Para passar uma sequência para maiúsculas;
\CAL
To uppercase a_ string:
Slap a_ substring on the string.
Loop.
If the substring is blank, exit.
Uppercase the substring's first's target.
Add 1 to the substring's first.
Repeat.

\PAL
Para passar para maiúsculas um texto;
Para passar um texto para maiúsculas;
\CAL
To uppercase a_ text:
If the text is nil, exit.
Loop.
Get a_ row from the text's rows.
If the row is nil, break.
Uppercase the row's string.
Repeat.
Wrap the text.

The upperscore byte is a_ byte equal to 175.

a_ url is a_ string.

a_ url record has
a_ scheme string,
a_ host name string,
a_ path string,
An extra string,
a_ port number.

a_ urlcomponents is a_ record with
a_ number called dwstructsize,
a_ pchar called lpszscheme,
a_ number called dwschemelength,
a_ number called nscheme,
a_ pchar called lpszhostname,
a_ number called dwhostnamelength,
a_ number called nport, \ this is typed as a wyrd in windows documentation, but dosen't work
a_ pchar called lpszusername,
a_ number called dwusernamelength,
a_ pchar called lpszpassword,
a_ number called dwpasswordlength,
a_ pchar called lpszurlpath,
a_ number called dwurlpathlength,
a_ pchar called lpszextrainfo,
a_ number called dwextrainfolength.  

\PAL
Para usar uma cor;
\CAL
To use a_ color:
Put the color into the context's color.

\PAL
Para usar o pincel grosso;
\CAL
To use the fat pen:
Put 3 into the pen size.

To use a_ letter height:
Put the letter height into the context's letter height.

\PAL
Para usar uma altura de letra de alguns twips;
\CAL
To use a_ letter height of some twips:
Put the twips into the letter height.
Put the twips into the context's letter height.

\PAL
Para usar um pincel;
\CAL
To use a_ pen:
Put the pen into the context's pen.

\PAL
Para usar o pincel fino;
\CAL
To use the skinny pen:
Put 1 into the pen size.

To use small pointy letters: \ as opposed to "roundy letters" not yet implemented
Use small letters.

a_ uuid is a_ record with
a_ number called d1,
a_ wyrd called d2,
a_ wyrd called d3,
8 bytes called d4.

The v-key is a_ key equal to 86.

a_ vertex array is a_ pointer to a_ vertex array record.

a_ vertex array record has a_ count and a_ spot pointer.

a_ vertex is a_ thing with an x-coord, a_ y-coord, a_ spot at the x-coord.

The vertical-bar byte is a_ byte equal to 124.

The vertical-tab byte is a_ byte equal to 11.

a_ very dark color is a_ color.

a_ very light color is a_ color.

a_ very very dark color is a_ color.

a_ very very light color is a_ color.

The violet color is a_ color.

The violet pen is a_ pen.

The w-key is a_ key equal to 87.

a_ w-param is a_ number.

\PAL
Para aguardar um evento;
\CAL
To wait for_ an event;
To deque an event:
Yield to windows.
Put the event queue's first into the event.
If the event is nil, repeat.
Remove the event from the event queue.
If the event's kind is "done", destroy the event; exit.
Destroy the current event.
Put the event into the current event.

\PAL
Para aguardar alguns milissegundos;
\CAL
To wait for_ some grains of sand;
To wait for_ some grains of sand to fall;
To wait for_ some grains of sand to fall in the hourglass;
To wait some milliseconds;
To wait for_ some milliseconds:
If the milliseconds are less than or equal to 0, exit.
Call "kernel32.dll" "Sleep" with the milliseconds.

To wait for_ a_ key to come back up:
If the key is not up, repeat.

To wait for_ a_ key to come up:
If the key is not up, repeat.

To wait for_ a_ key to go down:
If the key is not down, repeat.

To wait on that there key with the ESC on it:
Wait for_ the escape key.

\PAL
Para aguardar até que se termine de falar;
\CAL
To wait until speaking is done:
If the talker is nil, exit.
Call the talker's vtable's waituntildone with the talker and -1.

\PAL
Para aguardar uma tecla;
\CAL
To wait until we hit a_ key;
To wait for_ a_ key:
Wait for_ the key to go down.
Wait for_ the key to come up.
Flush all events.

a_ wave file is a_ path.

a_ wave is a_ hex string.

The white color is a_ color.

The white pen is a_ pen.

a_ wide string is a_ string.

a_ width is some twips.

a_ win32finddata is a_ record with
a_ number called dwfileattributes,
a_ filetime called ftcreationtime,
a_ filetime called ftlastaccesstime,
a_ filetime called ftlastwritetime,
a_ number called nfilesizehigh,
a_ number called nfilesizelow,
a_ number called dwreserved0,
a_ number called dwreserved1,
260 bytes called cfilename,
14 bytes called calternatefilename.

a_ window class is a_ record with
a_ number called cbsize,
a_ number called style,
a_ pointer called lpfnwndproc,
a_ number called cbclsextra,
a_ number called cbwndextra,
a_ handle called hinstance,
a_ hicon called hicon,
a_ cursor called hcursor,
An hbrush called hbrbackground,
a_ pointer called lpszmenuname,
a_ pointer called lpszclassname,
a_ hicon called hiconsm.

The window class is a_ window class.

a_ window is a_ handle.

a_ winhttp request is a_ thing with
a_ session handle,
a_ connection handle,
a_ request handle.

a_ word is a_ substring.

To wrap a_ text:
If the text is nil, exit.
If the text's wrap flag is not set, exit.
Convert the text's anchor to an absolute position given the text.
Convert the text's caret to another absolute position given the text.
Put the text's scale into a_ fraction.
Scale the text to 1/1.
Extract a_ string from the text.
Append the return byte to the string.
Destroy the text's rows.
Slap a_ rider on the string.
Create the hfont of the memory canvas given the text's font.
Loop.
Move the rider given the text's box (word wrapping rules).
If the rider's token is blank, break.
Create a_ row given the rider's token.
Append the row to the text's rows.
Repeat.
Destroy the hfont of the memory canvas.
Renumber the text's rows.
Scale the text to the fraction.
Convert the absolute position to the text's anchor given the text.
Convert the other absolute position to the text's caret given the text.
Limit the origin of the text.

\PAL
Para gravar um depósito em um arquivo;
Para escrever um depósito em um arquivo;
\CAL
To store a_ buffer in a_ file;
To write a_ buffer to a_ file:
Clear o erro de e/s.
Call "kernel32.dll" "SetFilePointer" with the file and 0 and 0 and 0 [file_begin] returning a_ result number.
If the result number is -1, put "Error posicionando puntero de archivo." into o erro de e/s; exit.
Call "kernel32.dll" "WriteFile" with the file and the buffer's first and the buffer's length and a_ number's whereabouts and 0 returning the result number.
If the result number is 0, put "Error escribiendo archivo." into o erro de e/s; exit.

\PAL
Para gravar um depósito em uma rota;
Para escrever um depósito em uma rota;
\CAL
To store a_ buffer in a_ path;
To write a_ buffer to a_ path:
Clear o erro de e/s.
Extract a_ directory from the path.
If the directory is not in the file system, put "Directorio '" then the directory then "' no existe." into o erro de e/s; exit.
Set the path to read-write mode.
Privatize the path.
Null terminate the path.
Call "kernel32.dll" "CreateFileA" with the path's first and 1073741824 [generic_write] 
And 0 and 0 and 2 [create_always] and -2147483520 [file_flag_write_through or file_attribute_normal] and 0 returning a_ handle.
If the handle is -1 [invalid_handle_value], put "Error opening file '" then the path then "'." into o erro de e/s; exit.
Call "kernel32.dll" "WriteFile" with the handle and the buffer's first and the buffer's length and a_ number's whereabouts and 0 returning the number.
Call "kernel32.dll" "CloseHandle" with the handle.
If the number is not 0, exit.
Put "Error escribiendo archivo '" then the path then "'." into o erro de e/s.

\PAL
Para escrever um byte;
\CAL
To write a_ byte:
Put the byte into a_ string.
Write the string.

To write a_ byte to stdout:
Call "kernel32.dll" "WriteFile" with the stdout handle and the byte's whereabouts and 1 and a_ number's whereabouts and nil.

\PAL
Para escrever um byte sem avançar;
\CAL
To write a_ byte without advancing:
Put the byte into a_ string.
Write the string without advancing.

\PAL
Para escrever uma signa;
\CAL
To write a_ flag:
Convert the flag to a_ string.
Write the string.

\PAL
Para escrever uma signa sem avançar;
\CAL
To write a_ flag without advancing:
Convert the flag to a_ string.
Write the string without advancing.

\PAL
Para escrever uma fração;
\CAL
To write a_ fraction:
Convert the fraction to a_ string.
Write the string.

\PAL
Para escrever uma fração sem avançar;
\CAL
To write a_ fraction without advancing:
Convert the fraction to a_ string.
Write the string without advancing.

\PAL
Para escrever um número;
\CAL
To write a_ number:
Convert the number to a_ string.
Write the string.

\PAL
Para escrever um número sem avançar;
\CAL
To write a_ number without advancing:
Convert the number to a_ string.
Write the string without advancing.

\PAL
Para escrever um número em um console;
\CAL
To write a_ number on a_ console:
Convert the number to a_ string.
Write the string on the console.

To write some quoras in a_ box:
\Draw the box with the red color and the clear color. \ temp ***
Put the box into a_ quora box.
Put the quora box's top plus 1/4 inch into the quora box's bottom.
Loop.
Get a_ quora from the quoras.
If the quora is nil, break.
\draw really fast. ***
\ Draw the quora box with the yellow color. \ temp ***
Write the quora's string in the quora box with the quora's color.
Move the quora box down 1/4 inch.
Repeat.

\PAL
Para escrever uma sequência;
Para rabiscar uma sequência;
\CAL
To write a_ string;
To stroke a_ string:
Privatize the string.
Loop.
If the string is blank, exit.
Get a_ byte from the string.
Stroke the byte.
If the string is not blank, space between glyphs.
Repeat.

\PAL
Para rabiscar uma sequência com um loco central e um raio;
Para escrever uma sequência com um loco central e um raio;
\CAL
To write a_ string around a_ center spot at a_ radius;
To write a_ string given a_ center spot and a_ radius;
To stroke a_ string around a_ center spot at a_ radius;
To stroke a_ string given a_ center spot and a_ radius:
Privatize the string.
Put 1 and the string's length into a_ fraction.
Loop.
If the string is blank, exit.
Get a_ byte from the string.
Start at the center spot.
Move the radius.
Stroke the byte.
Turn the fraction.
Repeat.

\PAL
Para escrever uma sequência em um loco com uma cor;
Para rabiscar uma sequência em um loco com uma cor;
\CAL
To write a_ string at a_ spot with a_ color;
To stroke a_ string at a_ spot with a_ color:
Start at the spot.
Put the color into the context's color.
Stroke the string.

\PAL
Para escrever uma sequência em um console;
\CAL
To write a_ string on a_ console:
If the console is nil, exit.
Insert the string into the console's text.
Insert the return byte into the console's text.
Wrap the console's text.
Scroll the console's text to the caret.
Show the console.

\PAL
Para escrever uma sequência em um console sem avançar;
\CAL
To write a_ string to a_ console without advancing;
To write a_ string on a_ console without advancing:
If the console is nil, exit.
Insert the string into the console's text.
Wrap the console's text.
Scroll the console's text to the caret.
Show the console.

\PAL
Para escrever uma sequência em uma caixa;
Para rabiscar uma sequência em uma caixa;
\CAL
To write a_ string in a_ box;
To stroke a_ string in a_ box:
Stroke the string in the box with the context's color.

\PAL
Para escrever uma sequência em uma caixa com uma cor;
Para rabiscar uma sequência em uma caixa com uma cor;
\CAL
To write a_ string in a_ box with a_ color;
To stroke a_ string in a_ box with a_ color:
Put the color into the context's color.
Put the box's left-bottom into the context's spot.
Put the box's height divided by 2 into the context's letter height.
\Put the box's height into the context's letter height.
Face north.
Move the box's height divided by 4. \ was 4 and still is now! ***
Stroke the string.

\PAL
Para escrever uma sequência no centro de uma caixa;
Para rabiscar uma sequência no centro de uma caixa;
\CAL
To write a_ string in the middle of a_ box;
To stroke a_ string in the middle of a_ box:
Put the context's letter height divided by 4 into a_ square size. \ was 4 ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at the end.
Put the string's length times the square size times 3 minus the square size into a_ width.
Divide the width by 2.
Start in the middle of the box.
Move down the context's letter height divided by 2. \ was 2 ***
Move left the width.
Face north.
Stroke the string.

\PAL
Para escrever uma sequência no centro da tela;
\CAL
To write a_ string in the middle of the screen:
Stroke the string in the middle of the screen's box.
Refresh the screen.

\PAL
Para escrever uma sequência em um terminal;
\CAL
To write a_ string on a_ terminal:
If the terminal is nil, exit.
Add a_ quora to the terminal.
Put the string into the quora's string.
Put the terminal's output color into the quora's color.
Show the terminal.

To write a_ string a_ radius away from a_ center spot;
To write a_ string a_ radius around a_ center spot;
To write a_ string about a_ radius from a_ center spot;
To write a_ string a_ radius from a_ center spot;
To stroke a_ string a_ radius away from a_ center spot;
To stroke a_ string a_ radius around a_ center spot;
To stroke a_ string about a_ radius from a_ center spot;
To stroke a_ string a_ radius from a_ center spot:
Stroke the string given the center spot and the radius.

To write a_ string a_ radius away from the middle of a_ box;
To write a_ string a_ radius around the middle of a_ box;
To write a_ string about a_ radius from the middle of a_ box;
To write a_ string a_ radius from the middle of a_ box;
To stroke a_ string a_ radius away from the middle of a_ box;
To stroke a_ string a_ radius around the middle of a_ box;
To stroke a_ string about a_ radius from the middle of a_ box;
To stroke a_ string a_ radius from the middle of a_ box:
Stroke the string given the box's center and the radius.

To write a_ string to stdout:
Call "kernel32.dll" "WriteFile" with the stdout handle and the string's first and the string's length and a_ number's whereabouts and nil.

To write a_ string while turning a_ fraction of the way;
To write a_ string while turning a_ fraction of the way around;
To write a_ string while turning a_ fraction;
To stroke a_ string while turning a_ fraction of the way;
To stroke a_ string while turning a_ fraction of the way around;
To stroke a_ string while turning a_ fraction:
Privatize the string.
Loop.
If the string is blank, exit.
Get a_ byte from the string.
Stroke the byte.
Turn the fraction.
If the string is not blank, space between glyphs.
Repeat.

\PAL
Para escrever uma sequência com uma cor;
Para rabiscar uma sequência com uma cor;
\CAL
To write a_ string with a_ color;
To stroke a_ string with a_ color:
Put the color into the context's color.
Stroke the string.

To write a_ string with a_ color at the bottom of a_ box;
To stroke a_ string with a_ color at the bottom of a_ box:
Put the context's letter height divided by 4 into a_ square size. \ ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at the end.
Put the string's length times the square size times 3 minus the square size into a_ width.
Divide the width by 2.
Start in the middle of the bottom of the box.
Move up the context's letter height times 2. \ was without the times 2 ***
Move left the width.
Face north.
Stroke the string with the color.

To write a_ string with a_ color at the top of a_ box;
To stroke a_ string with a_ color at the top of a_ box:
Put the context's letter height divided by 4 into a_ square size. \ ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at the end.
Put the string's length times the square size times 3 minus the square size into a_ width.
Divide the width by 2.
Start in the middle of the top of the box.
Move down the context's letter height times 4. \ was times 2 ***
Move left the width.
Face north.
Stroke the string with the color.

To write a_ string with a_ color in the middle of a_ box;
To stroke a_ string with a_ color in the middle of a_ box:
Put the context's letter height divided by 4 into a_ square size. \ was 4 ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at the end.
Put the string's length times the square size times 3 minus the square size into a_ width.
Divide the width by 2.
Start in the middle of the box.
Move down the context's letter height divided by 2. \ was 2 ***
Move left the width.
Face north.
Stroke the string with the color.

To write a_ string with a_ color a_ radius away from a_ center spot;
To write a_ string with a_ color a_ radius around a_ center spot;
To write a_ string with a_ color about a_ radius from a_ center spot;
To write a_ string with a_ color a_ radius from a_ center spot;
To stroke a_ string with a_ color a_ radius away from a_ center spot;
To stroke a_ string with a_ color a_ radius around a_ center spot;
To stroke a_ string with a_ color about a_ radius from a_ center spot;
To stroke a_ string with a_ color a_ radius from a_ center spot:
Put the color into the context's color.
Stroke the string given the center spot and the radius.

To write a_ string with a_ color some twips down from the top of a_ box;
To write a_ string with a_ color some twips down from the top center of a_ box;
To stroke a_ string with a_ color some twips down from the top of a_ box;
To stroke a_ string with a_ color some twips down from the top center of a_ box:
Put the context's letter height divided by 4 into a_ square size. \ was 4 ***
\ glyphs are two squares wide plus one square of intercharacter spacing. no spacing at the end.
Put the string's length times the square size times 3 minus the square size into a_ width.
Divide the width by 2.
Start in the middle of the top of the box.
Move down the twips.
Move left the width.
Face north.
Stroke the string with the color.

\PAL
Para escrever uma sequência com uma fonte e um tamanho e uma cor e um loco;
\CAL
To write a_ string with a_ font and a_ size and a_ color and a_ spot:
Put the size into the font's height.
Put the string's width into a_ width.
Put the spot and the spot into a_ box.
Subtract the width divided by 2 from the box's left.
Add the width divided by 2 to the box's right.
Subtract the size divided by 2 from the box's top.
Add the size divided by 2 to the box's bottom.
Draw the string in the box with the color and the font and "center".
Refresh the screen.

\PAL
Para escrever com letras grandes;
Para usar letras grandes;
\CAL
To write with large letters;
To use large letters:
Put the large letter height into the context's letter height.

\PAL
Para escrever com letras medianas;
Para usar letras medianas;
\CAL
To write with medium letters;
To use medium size letters;
To use medium-size letters;
To use medium sized letters;
To use medium-sized letters;
To use medium letters:
Put the medium letter height into the context's letter height.

\PAL
Para escrever com letras pequenas;
Para usar letras pequenas;
\CAL
To write with small letters;
To use small letters:
Put the small letter height into the context's letter height.

a_ wsadata is a_ record with
a_ wyrd called wversion,
a_ wyrd called whighversion,
257 bytes called szdescription,
127 bytes called szsystemstatus,
a_ wyrd [unsigned] called imaxsockets,
a_ wyrd [unsigned] called imaxudpdg,
a_ pointer called lpvendorinfo.

a_ wyrd has a_ low byte and a_ high byte.

The x-key is a_ key equal to 88.

An xor-mask is a_ mask.

The y-key is a_ key equal to 89.

The yellow color is a_ color.

The yellow pen is a_ pen.

The yen-sign byte is a_ byte equal to 165.

To yield to windows:
If the event queue is not empty, exit.
Call "user32.dll" "GetMessageA" with an msg's whereabouts and 0 and 0 and 0 returning a_ number.
If the number is 0, exit.
Call "user32.dll" "TranslateMessage" with the msg's whereabouts.
Call "user32.dll" "DispatchMessageA" with the msg's whereabouts.

The z-key is a_ key equal to 90.

To zero a_ box: \ was clear a box, got confounded with "clear a box" (which should draw the box all black as does "clear the screen")
Put 0 into the box's left.
Put 0 into the box's top.
Put 0 into the box's right.
Put 0 into the box's bottom.

The zero box is a_ box.

The zero byte is a_ byte equal to 48.

To zero fill a_ number given a_ count and append it to a_ string:
Convert the number to another string.
Zero fill the other string given the count.
Append the other string to the string.

\PAL
Para preencher com zeros uma sequência dado um contador;
Para preencher uma sequência com zeros dado um contador;
\CAL
To zero fill a_ string given a_ count:
If the string's length is greater than or equal to the count, exit.
Prepend the zero byte to the string.
Repeat.

The zero key is a_ key equal to 48.

The zero line is a_ line. \ tracer

The zero spot is a_ spot.

a_ translation table is a_ hex string.

The ascii table is a_ translation table equal to $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF.

The lowercase accent-free ascii table is a_ translation table equal to $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F406162636465666768696A6B6C6D6E6F707172737475767778797A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788899A8B9C8D9E8F909192939495969798999A9B9C9D9E79A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF616161616161E6636565656569696969F06E6F6F6F6F6FD7F87575757579FEDF616161616161E6636565656569696969F06E6F6F6F6F6FF7F87575757579FE79.

The lowercase ascii table is a_ translation table equal to $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F406162636465666768696A6B6C6D6E6F707172737475767778797A5B5C5D5E5F606162636465666768696A6B6C6D6E6F707172737475767778797A7B7C7D7E7F808182838485868788899A8B9C8D9E8F909192939495969798999A9B9C9D9EFFA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6D7F8F9FAFBFCFDFEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEFF0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF.

The uppercase ascii table is a_ translation table equal to $000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F505152535455565758595A5B5C5D5E5F604142434445464748494A4B4C4D4E4F505152535455565758595A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798998A9B8C9D8E9FA0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFC0C1C2C3C4C5C6C7C8C9CACBCCCDCECFD0D1D2D3D4D5D6F7D8D9DADBDCDDDE9F.

\# definições do Português

\ tipos de cores em Português (turtle)

Uma cor muito escura é uma cor.                                      \ very dark color        
Uma cor muito clara é uma cor.                                       \ very light color       
Uma cor escuríssima é uma cor.                                       \ very very dark color   
Uma cor claríssima é uma cor.                                        \ very very light color  
Uma cor sólida é uma cor.                                            \ solid color            
Uma cor acastanhada é uma cor.                                       \ brownish color         
Uma cor parda é uma cor.                                             \ brownish color         
Uma cor esverdeada é uma cor.                                        \ greenish color         
Uma furta-cor é uma cor.                                             \ rainbow                
Uma cor clara é uma cor.                                             \ light color            
Uma cor escura é uma cor.                                            \ dark color             
Uma cor pastel é uma cor.                                            \ pastel color           

\ cores globais em Português

O transparente é uma cor.
O preto é uma cor.
O branco é uma cor.
O cinza claríssimo é uma cor.
O cinza muito claro é uma cor.
O cinza claro é uma cor.
O cinza é uma cor.
O cinza escuro é uma cor.
O cinza muito escuro é uma cor.
O cinza escuríssimo é uma cor.
O vermelho claríssimo é uma cor.
O vermelho muito claro é uma cor.
O vermelho claro é uma cor.
O vermelho é uma cor.
O vermelho escuro é uma cor.
O vermelho muito escuro é uma cor.
O vermelho escuríssimo é uma cor.
O laranja claríssimo é uma cor.
O laranja muito claro é uma cor.
O laranja claro é uma cor.
O laranja é uma cor.
O laranja escuro é uma cor.
O laranja muito escuro é uma cor.
O laranja escuríssimo é uma cor.
O amarelo claríssimo é uma cor.
O amarelo muito claro é uma cor.
O amarelo-claro é uma cor.
O amarelo é uma cor.
O amarelo escuro é uma cor.
O amarelo muito escuro é uma cor.
O amarelo escuríssimo é uma cor.
O limão claríssimo é uma cor.
O limão muito claro é uma cor.
O limão claro é uma cor.
O limão é uma cor.
O limão escuro é uma cor.
O limão muito escuro é uma cor.
O limão escuríssimo é uma cor.
O verde claríssimo é uma cor.
O verde muito claro é uma cor.
O verde-claro é uma cor.
O verde é uma cor.
O verde-escuro é uma cor.
O verde muito escuro é uma cor.
O verde escuríssimo é uma cor.
O turquesa claríssimo é uma cor.
O turquesa muito claro é uma cor.
O turquesa claro é uma cor.
O turquesa é uma cor.
O turquesa escuro é uma cor.
O turquesa muito escuro é uma cor.
O turquesa escuríssimo é uma cor.
O cíano claríssimo é uma cor.
O cíano muito claro é uma cor.
O cíano claro é uma cor.
O cíano é uma cor.
O cíano escuro é uma cor.
O cíano muito escuro é uma cor.
O cíano escuríssimo é uma cor.
O azul-celeste claríssimo é uma cor.
O azul-celeste muito claro é uma cor.
O azul-celeste claro é uma cor.
O azul-celeste é uma cor.
O azul-celeste escuro é uma cor.
O azul-celeste muito escuro é uma cor.
O azul-celeste escuríssimo é uma cor.
O azul claríssimo é uma cor.
O azul muito claro é uma cor.
O azul-claro é uma cor.
O azul é uma cor.
O azul escuro é uma cor.
O azul muito escuro é uma cor.
O azul escuríssimo é uma cor.
O púrpura claríssimo é uma cor.
O púrpura muito claro é uma cor.
O púrpura claro é uma cor.
O púrpura é uma cor.
O púrpura escuro é uma cor.
O púrpura muito escuro é uma cor.
O púrpura escuríssimo é uma cor.
O magenta claríssimo é uma cor.
O magenta muito claro é uma cor.
O magenta claro é uma cor.
O magenta é uma cor.
O magenta escuro é uma cor.
O magenta muito escuro é uma cor.
O magenta escuríssimo é uma cor.
O roxo claríssimo é uma cor.
O roxo muito claro é uma cor.
O roxo claro é uma cor.
O roxo é uma cor.
O roxo escuro é uma cor.
O roxo muito escuro é uma cor.
O roxo escuríssimo é uma cor.
O violeta claríssimo é uma cor.
O violeta muito claro é uma cor.
O violeta claro é uma cor.
O violeta é uma cor.
O violeta escuro é uma cor.
O violeta muito escuro é uma cor.
O violeta escuríssimo é uma cor.

\ cores especiais em Português

O ciã claríssimo é uma cor.
O ciã muito claro é uma cor.
O ciã claro é uma cor.
O ciã é uma cor.
O ciã escuro é uma cor.
O ciã muito escuro é uma cor.
O ciã escuríssimo é uma cor.
O cerúleo claríssimo é uma cor.
O cerúleo muito claro é uma cor.
O cerúleo claro é uma cor.
O cerúleo é uma cor.
O cerúleo escuro é uma cor.
O cerúleo muito escuro é uma cor.
O cerúleo escuríssimo é uma cor.
O marrom claríssimo é uma cor.
O marrom muito claro é uma cor.
O marrom claro é uma cor.
O marrom é uma cor.
O marrom escuro é uma cor.
O marrom muito escuro é uma cor.
O marrom escuríssimo é uma cor.
O rosa é uma cor.
O dourado é uma cor.

\ teclas em Português

A tecla-retornar é uma tecla igual a 8.          
A tecla-retrocesso é uma tecla igual a 8.        
A tecla-tab é uma tecla igual a 9.               
A tecla-limpar é uma tecla igual a 12.           
A tecla-entrar é uma tecla igual a 13.           
A tecla-maiúsculo é uma tecla igual a 16.            
A tecla-shift é uma tecla igual a 16.            
A tecla-ctrl é uma tecla igual a 17.             
A tecla-alt é uma tecla igual a 18.              
A tecla-pausa é uma tecla igual a 19.            
A tecla-fixar é uma tecla igual a 20.            
A tecla-esc é uma tecla igual a 27.              
A tecla-escapar é uma tecla igual a 27.           
A tecla-espaço é uma tecla igual a 32.           
A tecla voltar-página é uma tecla igual a 33.    
A tecla página-acima é uma tecla igual a 33.    
A tecla avançar-página é uma tecla igual a 34.   
A tecla página-abaixo é uma tecla igual a 34.   
A tecla-fim é uma tecla igual a 35.              
A tecla-início é uma tecla igual a 36.           
A tecla-esquerda é uma tecla igual a 37.  
A tecla-àesquerda é uma tecla igual a 37.  
A tecla-acima é uma tecla igual a 38.     
A tecla-direita é uma tecla igual a 39.   
A tecla-àdireita é uma tecla igual a 39.   
A tecla-abaixo é uma tecla igual a 40.    
A tecla-imprimir é uma tecla igual a 44.    
A tecla-inserir é uma tecla igual a 45.          
A tecla-ins é uma tecla igual a 45.          
A tecla-deletar é uma tecla igual a 46.          
A tecla-del é uma tecla igual a 46.          
A tecla-0 é uma tecla igual a 48.                
A tecla-1 é uma tecla igual a 49.                
A tecla-2 é uma tecla igual a 50.
A tecla-3 é uma tecla igual a 51.
A tecla-4 é uma tecla igual a 52.
A tecla-5 é uma tecla igual a 53.
A tecla-6 é uma tecla igual a 54.
A tecla-7 é uma tecla igual a 55.
A tecla-8 é uma tecla igual a 56.
A tecla-9 é uma tecla igual a 57.
A tecla-a é uma tecla igual a 65.
A tecla-b é uma tecla igual a 66.
A tecla-c é uma tecla igual a 67.
A tecla-d é uma tecla igual a 68.
A tecla-e é uma tecla igual a 69.
A tecla-f é uma tecla igual a 70.
A tecla-g é uma tecla igual a 71.
A tecla-h é uma tecla igual a 72.
A tecla-i é uma tecla igual a 73.
A tecla-j é uma tecla igual a 74.
A tecla-k é uma tecla igual a 75.
A tecla-l é uma tecla igual a 76.
A tecla-m é uma tecla igual a 77.
A tecla-n é uma tecla igual a 78.
A tecla-o é uma tecla igual a 79.
A tecla-p é uma tecla igual a 80.
A tecla-q é uma tecla igual a 81.
A tecla-r é uma tecla igual a 82.
A tecla-s é uma tecla igual a 83.
A tecla-t é uma tecla igual a 84.
A tecla-u é uma tecla igual a 85.
A tecla-v é uma tecla igual a 86.
A tecla-w é uma tecla igual a 87.
A tecla-x é uma tecla igual a 88.
A tecla-y é uma tecla igual a 89.
A tecla-z é uma tecla igual a 90.
A tecla windows-esquerda é uma tecla igual a 91.      
A tecla win-esq é uma tecla igual a 91.      
A tecla windows-direita é uma tecla igual a 92.   
A tecla win-dir é uma tecla igual a 92.   
A tecla-menu é uma tecla igual a 93.                  
A tecla numpad-0 é uma tecla igual a 96.           
A tecla-nump0 é uma tecla igual a 96.           
A tecla numpad-1 é uma tecla igual a 97.             
A tecla-nump1 é uma tecla igual a 97.             
A tecla numpad-2 é uma tecla igual a 98.           
A tecla-nump2 é uma tecla igual a 98.           
A tecla numpad-3 é uma tecla igual a 99.           
A tecla-nump3 é uma tecla igual a 99.           
A tecla numpad-4 é uma tecla igual a 100.        
A tecla-nump4 é uma tecla igual a 100.        
A tecla numpad-5 é uma tecla igual a 101.         
A tecla-nump5 é uma tecla igual a 101.         
A tecla numpad-6 é uma tecla igual a 102.          
A tecla-nump6 é uma tecla igual a 102.          
A tecla numpad-7 é uma tecla igual a 103.          
A tecla-nump7 é uma tecla igual a 103.          
A tecla numpad-8 é uma tecla igual a 104.          
A tecla-nump8 é uma tecla igual a 104.          
A tecla numpad-9 é uma tecla igual a 105.          
A tecla-nump9 é uma tecla igual a 105.          
A tecla numpad-asterisco é uma tecla igual a 106.         
A tecla nump-asterisco é uma tecla igual a 106.         
A tecla numpad-mais é uma tecla igual a 107.          
A tecla nump-mais é uma tecla igual a 107.          
A tecla numpad-traço é uma tecla igual a 109.         
A tecla nump-traço é uma tecla igual a 109.         
A tecla numpad-ponto é uma tecla igual a 110. 
A tecla nump-ponto é uma tecla igual a 110. 
A tecla numpad-barra é uma tecla igual a 111.      
A tecla nump-barra é uma tecla igual a 111.      
A tecla-f1 é uma tecla igual a 112.
A tecla-f2 é uma tecla igual a 113.
A tecla-f3 é uma tecla igual a 114.
A tecla-f4 é uma tecla igual a 115.
A tecla-f5 é uma tecla igual a 116.
A tecla-f6 é uma tecla igual a 117.
A tecla-f7 é uma tecla igual a 118.
A tecla-f8 é uma tecla igual a 119.
A tecla-f9 é uma tecla igual a 120.
A tecla-f10 é uma tecla igual a 121.
A tecla-f11 é uma tecla igual a 122.
A tecla-f12 é uma tecla igual a 123.
A tecla-numérico é uma tecla igual a 144.      
A tecla-numlock é uma tecla igual a 144.      
A tecla-deslocamento é uma tecla igual a 145.  
A tecla-igual é uma tecla igual a 187.         
A tecla-sublinhado é uma tecla igual a 189.    
A tecla-acento é uma tecla igual a 192.  

\ bytes ASCII em Português

O byte-nul é um byte igual a 0.
O byte-soh é um byte igual a 1.
O byte-stx é um byte igual a 2.
O byte-etx é um byte igual a 3.
O byte-eot é um byte igual a 4.
O byte-enq é um byte igual a 5.
O byte-ack é um byte igual a 6.
O byte-bel é um byte igual a 7.
O byte-bs é um byte igual a 8.
O byte-ht é um byte igual a 9.
O byte-lf é um byte igual a 10.
O byte-vt é um byte igual a 11.
O byte-ff é um byte igual a 12.
O byte-cr é um byte igual a 13.
O byte-so é um byte igual a 14.
O byte-si é um byte igual a 15.
O byte-dle é um byte igual a 16.
O byte-dc1 é um byte igual a 17.
O byte-dc2 é um byte igual a 18.
O byte-dc3 é um byte igual a 19.
O byte-dc4 é um byte igual a 20.
O byte-nak é um byte igual a 21.
O byte-syn é um byte igual a 22.
O byte-etb é um byte igual a 23.
O byte-can é um byte igual a 24.
O byte-em é um byte igual a 25.
O byte-sub é um byte igual a 26.
O byte-esc é um byte igual a 27.
O byte-fs é um byte igual a 28.
O byte-gs é um byte igual a 29.
O byte-rs é um byte igual a 30.
O byte-us é um byte igual a 31.
O byte-espaço é um byte igual a 32.
O byte-esclamação é um byte igual a 33.
O byte-aspas é um byte igual a 34.
O byte-# é um byte igual a 35.
O byte-número é um byte igual a 35.
O byte-cifrão é um byte igual a 36.
O byte-% é um byte igual a 37.
O byte-porcento é um byte igual a 37.
O byte-& é um byte igual a 38.
O byte-ampersand é um byte igual a 38.
O byte-apóstrofo é um byte igual a 39.
O byte paren-esq é um byte igual a 40.
O byte abre-parênteses é um byte igual a 40.
O byte paren-dir é um byte igual a 41.
O byte fecha-parênteses é um byte igual a 41.
O byte-asterisco é um byte igual a 42.
O byte-+ é um byte igual a 43.
O byte-mais é um byte igual a 43.
O byte-vírgula é um byte igual a 44.
O byte-traço é um byte igual a 45.
O byte-menos é um byte igual a 45.
O byte-ponto é um byte igual a 46.
O byte-/ é um byte igual a 47.
O byte-barra é um byte igual a 47.
O byte-0 é um byte igual a 48.
O byte-1 é um byte igual a 49.
O byte-2 é um byte igual a 50.
O byte-3 é um byte igual a 51.
O byte-4 é um byte igual a 52.
O byte-5 é um byte igual a 53.
O byte-6 é um byte igual a 54.
O byte-7 é um byte igual a 55.
O byte-8 é um byte igual a 56.
O byte-9 é um byte igual a 57.
O byte dois-pontos é um byte igual a 58.
O byte ponto-vírgula é um byte igual a 59.
O byte menor-que é um byte igual a 60.
O byte igual-a é um byte igual a 61.
O byte maior-que é um byte igual a 62.
O byte-interrogação é um byte igual a 63.
O byte-@ é um byte igual a 64.
O byte-arroba é um byte igual a 64.
O byte-a maiúsculo é um byte igual a 65.
O byte-b maiúsculo é um byte igual a 66.
O byte-c maiúsculo é um byte igual a 67.
O byte-d maiúsculo é um byte igual a 68.
O byte-e maiúsculo é um byte igual a 69.
O byte-f maiúsculo é um byte igual a 70.
O byte-g maiúsculo é um byte igual a 71.
O byte-h maiúsculo é um byte igual a 72.
O byte-i maiúsculo é um byte igual a 73.
O byte-j maiúsculo é um byte igual a 74.
O byte-k maiúsculo é um byte igual a 75.
O byte-l maiúsculo é um byte igual a 76.
O byte-m maiúsculo é um byte igual a 77.
O byte-n maiúsculo é um byte igual a 78.
O byte-o maiúsculo é um byte igual a 79.
O byte-p maiúsculo é um byte igual a 80.
O byte-q maiúsculo é um byte igual a 81.
O byte-r maiúsculo é um byte igual a 82.
O byte-s maiúsculo é um byte igual a 83.
O byte-t maiúsculo é um byte igual a 84.
O byte-u maiúsculo é um byte igual a 85.
O byte-v maiúsculo é um byte igual a 86.
O byte-w maiúsculo é um byte igual a 87.
O byte-x maiúsculo é um byte igual a 88.
O byte-y maiúsculo é um byte igual a 89.
O byte-z maiúsculo é um byte igual a 90.
O byte colchete-esq é um byte igual a 91.
O byte abre-colchetes é um byte igual a 91.
O byte barra-inv é um byte igual a 92.
O byte barra-invertida é um byte igual a 92.
O byte colchete-dir é um byte igual a 93.
O byte fecha-colchetes é um byte igual a 93.
O byte-circunflexo é um byte igual a 94.
O byte-_ é um byte igual a 95.
O byte-sublinhado é um byte igual a 95.
O byte-` é um byte igual a 96.
O byte-acento é um byte igual a 96.
O byte-a é um byte igual a 97.
O byte-b é um byte igual a 98.
O byte-c é um byte igual a 99.
O byte-d é um byte igual a 100.
O byte-e é um byte igual a 101.
O byte-f é um byte igual a 102.
O byte-g é um byte igual a 103.
O byte-h é um byte igual a 104.
O byte-i é um byte igual a 105.
O byte-j é um byte igual a 106.
O byte-k é um byte igual a 107.
O byte-l é um byte igual a 108.
O byte-m é um byte igual a 109.
O byte-n é um byte igual a 110.
O byte-o é um byte igual a 111.
O byte-p é um byte igual a 112.
O byte-q é um byte igual a 113.
O byte-r é um byte igual a 114.
O byte-s é um byte igual a 115.
O byte-t é um byte igual a 116.
O byte-u é um byte igual a 117.
O byte-v é um byte igual a 118.
O byte-w é um byte igual a 119.
O byte-x é um byte igual a 120.
O byte-y é um byte igual a 121.
O byte-z é um byte igual a 122.
O byte abre-chaves é um byte igual a 123.
O byte chave-esq é um byte igual a 123.
O byte barra-vert é um byte igual a 124.
O byte barra-vertical é um byte igual a 124.
O byte chave-dir é um byte igual a 125.
O byte fecha-chaves é um byte igual a 125.
O byte-~ é um byte igual a 126.
O byte-til é um byte igual a 126.
O byte-del é um byte igual a 127.
O byte-deletar é um byte igual a 127.
O byte-euro é um byte igual a 128.
O byte-subaspa é um byte igual a 130.
O byte aspa-inf é um byte igual a 130.
O byte- é um byte igual a 131.
O byte-subaspas é um byte igual a 132.
O byte aspas-inf é um byte igual a 132.
O byte-elipse é um byte igual a 133.
O byte-adaga é um byte igual a 134.
O byte-dupladaga é um byte igual a 135.
O byte adaga-dupla é um byte igual a 135.
O byte acento-cir é um byte igual a 136.
O byte por-milha é um byte igual a 137.
O byte- maiúsculo é um byte igual a 138.
O byte angular-esq é um byte igual a 139.
O byte- maiúsculo é um byte igual a 140.
O byte- maiúsculo é um byte igual a 142.
O byte aspa-esq é um byte igual a 145.
O byte aspa-dir é um byte igual a 146.
O byte aspas-esq é um byte igual a 147.
O byte aspas-dir é um byte igual a 148.
O byte-marcador é um byte igual a 149.
O byte meia-risca é um byte igual a 150.
O byte-travessão é um byte igual a 151.
O byte-acento-til é um byte igual a 152.
O byte-marca-registrada é um byte igual a 153.
O byte- é um byte igual a 154.
O byte angular-dir é um byte igual a 155.
O byte- é um byte igual a 156.
O byte- é um byte igual a 158.
O byte-ÿ maiúsculo é um byte igual a 159.
O byte-nbsp é um byte igual a 160.
O byte exclam-inv é um byte igual a 161.
O byte-centavo é um byte igual a 162.
O byte-libra é um byte igual a 163.
O byte-dinheiro é um byte igual a 164.
O byte-yen é um byte igual a 165.
O byte barra-int é um byte igual a 166.
O byte-parágrafo é um byte igual a 167.
O byte-dieresis é um byte igual a 168.
O byte-copyright é um byte igual a 169.
O byte ordinal-a é um byte igual a 170.
O byte angulares-esq é um byte igual a 171.
O byte-não é um byte igual a 172.
O byte marcador-leve é um byte igual a 173.
O byte byte traço-leve é um byte igual a 173.
O byte-registrado é um byte igual a 174.
O byte-mácron é um byte igual a 175.
O byte-grau é um byte igual a 176.
O byte mais-menos é um byte igual a 177.
O byte-super2 é um byte igual a 178.
O byte-super3 é um byte igual a 179.
O byte acento-agudo é um byte igual a 180.
O byte-µ é um byte igual a 181.
O byte-micro é um byte igual a 181.
O byte-¶ é um byte igual a 182.
O byte indic-par é um byte igual a 182.
O byte marcador-pequeno é um byte igual a 183.
O byte-cedilha é um byte igual a 184.
O byte-super1 é um byte igual a 185.
O byte ordinal-o é um byte igual a 186.
O byte angulares-dir é um byte igual a 187.
O byte um-quarto é um byte igual a 188.
O byte um-meio é um byte igual a 189.
O byte três-quartos é um byte igual a 190.
O byte interrog-inv é um byte igual a 191.
O byte-à maiúsculo é um byte igual a 192.
O byte-á maiúsculo é um byte igual a 193.
O byte-â maiúsculo é um byte igual a 194.
O byte-ã maiúsculo é um byte igual a 195.
O byte-ä maiúsculo é um byte igual a 196.
O byte-å maiúsculo é um byte igual a 197.
O byte-æ maiúsculo é um byte igual a 198.
O byte-ç maiúsculo é um byte igual a 199.
O byte-è maiúsculo é um byte igual a 200.
O byte-é maiúsculo é um byte igual a 201.
O byte-ê maiúsculo é um byte igual a 202.
O byte-ë maiúsculo é um byte igual a 203.
O byte-ì maiúsculo é um byte igual a 204.
O byte-í maiúsculo é um byte igual a 205.
O byte-î maiúsculo é um byte igual a 206.
O byte-ï maiúsculo é um byte igual a 207.
O byte-ð maiúsculo é um byte igual a 208.
O byte-ñ maiúsculo é um byte igual a 209.
O byte-ò maiúsculo é um byte igual a 210.
O byte-ó maiúsculo é um byte igual a 211.
O byte-ô maiúsculo é um byte igual a 212.
O byte-õ maiúsculo é um byte igual a 213.
O byte-ö maiúsculo é um byte igual a 214.
O byte-multiplicação é um byte igual a 215.
O byte-ø maiúsculo é um byte igual a 216.
O byte-ù maiúsculo é um byte igual a 217.
O byte-ú maiúsculo é um byte igual a 218.
O byte-û maiúsculo é um byte igual a 219.
O byte-ü maiúsculo é um byte igual a 220.
O byte-ý maiúsculo é um byte igual a 221.
O byte-þ maiúsculo é um byte igual a 222.
O byte-ß é um byte igual a 223.
O byte s-duplo é um byte igual a 223.
O byte-à é um byte igual a 224.
O byte-á é um byte igual a 225.
O byte-â é um byte igual a 226.
O byte-ã é um byte igual a 227.
O byte-ä é um byte igual a 228.
O byte-å é um byte igual a 229.
O byte a-anelado é um byte igual a 229.
O byte-æ é um byte igual a 230.
O byte-ae é um byte igual a 230.
O byte-ç é um byte igual a 231.
O byte-è é um byte igual a 232.
O byte-é é um byte igual a 233.
O byte-ê é um byte igual a 234.
O byte-ë é um byte igual a 235.
O byte-ì é um byte igual a 236.
O byte-í é um byte igual a 237.
O byte-î é um byte igual a 238.
O byte-ï é um byte igual a 239.
O byte-ð é um byte igual a 240.
O byte-ñ é um byte igual a 241.
O byte-ò é um byte igual a 242.
O byte-ó é um byte igual a 243.
O byte-ô é um byte igual a 244.
O byte-õ é um byte igual a 245.
O byte-ö é um byte igual a 246.
O byte-divisão é um byte igual a 247.
O byte-ø é um byte igual a 248.
O byte o-cortado é um byte igual a 248.
O byte-ù é um byte igual a 249.
O byte-ú é um byte igual a 250.
O byte-û é um byte igual a 251.
O byte-ü é um byte igual a 252.
O byte-ý é um byte igual a 253.
O byte-þ é um byte igual a 254.
O byte-thorn é um byte igual a 254.
O byte-ÿ é um byte igual a 255.

\ unidades de medida em Português

Um cm é 567 twips.
Um mm é 1/10 cm.

\ tipos de dados em Português

\ angle 
Um ângulo é alguns graus precisos [0 a 3599].

\ box
Uma caixa é a_ box.
\ roundy box
Uma caixa arredondada é a_ roundy box.

\ buffer
Um depósito é a_ buffer.

\ color
Uma cor é a_ color.
\ sinônimos de color
Um tom é um cor.

\ coord
Uma coordenada é a_ coord.

\ count
Um contador é um número.

\ date/time
Uma data/hora é a_ date/time.

\ degree
Um grau é um número [0 to 359].
\ precise degree
Um grau preciso é um número [0 a 3599].

\ description
Uma descrição é uma sequência.

\ directory
Uma pasta é uma rota.
\ directory name
Um nome de pasta é uma sequência.

\ dot
Um ponto é a_ dot.

\ drive
Um disco é uma sequência.

\ drive kind
Um tipo de disco é uma sequência.

\ drive name
Um nome de disco é uma sequência.

\ event
Um evento é a_ event.

\ ellipse
Uma elipse é an ellipse.

\ file 
Um arquivo é a_ handle.
\ file name
Um nome de arquivo é uma sequência.

\ flag
Uma signa é a_ flag.
\ sinõnimos de flag
Um sinalizador é a_ flag.

\ figure
Uma figura é a_ figure.

\ font
Uma fonte é a_ font.
\ sinônimos de font
Um tipo de letra é uma fonte.

\ font height
Uma altura de fonte é alguns twips.
Uma altura de tipo de letra é alguns twips.

\ fraction
Uma fração é a_ fraction.

\ grid
Uma grade é a_ grid.

\ height
Uma altura é alguns twips.

\ hue
Uma matiz é a_ hue.

\ inch
Uma polegada é 1440 twips.

\ index
Um índice é an index.

\ ip address
Um endereço ip é an ip address.

\ item
Um recurso é an item.

\ key
Uma tecla is a_ key.

\ lightness
Um brilho é a_ lightness.
\ sinônimos de lightness
Uma luminosidade é um brilho.

\ line
Uma reta é a_ line.
Um traço é uma reta.
Uma reta vertical é uma reta.
Um traço vertical é uma reta.
\ horizontal line
Uma reta horizontal é uma reta.
Um traço horizontal é uma reta.

\ millisecond
Um milissegundo é a_ millisecond.

\ name
Um nome é uma sequência.

\ number
Um número é a_ number.

\ pair
Um par é a_ pair.

\ path
Uma rota é a_ path.
\ sinônimos de path
Um caminho é uma rota.

\ pen
Um pincel é a_ pen.

\ percent
Um porcento é um número.
Uma porcentagem é um número.

\ picture
Uma imagem é a_ picture.

\ point
Um degrau é a_ point.
\ sinônimos de point
Uma graduação é a_ point.
Uma gradação é a_ point.

\ pointer
Um ponteiro é a_ pointer.
\ byte pointer
Um ponteiro de byte é a_ pointer to a_ byte.

\ polygon
Um polígono é a_ polygon.

\ position
Uma posição é a_ position.

\ quotient
Um quociente é um número.

\ radius
Um raio é a_ radius.

\ refer
Uma referência é a_ refer.

\ remainder
Um resto é um número.

\ rider
Um iterador is a_ rider.
\ sinônimos de rider
Um percorredor é um iterador.

\ row
Uma linha é a_ row.

\ saturation
Uma saturação é a_ saturation.

\ second 
Um segundo é 1000 milissegundos.

\ selection
Uma seleção é a_ selection.

\ sheet
Uma folha é a_ sheet.
\ landscape sheet
Uma folha horizontal é a_ landscape sheet.
\ portrait sheet
Uma folha vertical é a_ portrait sheet.

\ spot 
Um loco é a_ spot.

\ square root
Uma raiz quadrada é um número.

\ string
Uma sequência é a_ string.
\ sinônimos de string
Uma sequência binária é uma sequência.
Uma série é uma sequência.
Um escrito é uma sequência.
Uma escrita é uma sequência.

\ substring
Um segmento é a_ substring.
\ sinônimos de substring
Uma subsequência é um segmento.
Uma subsérie é um segmento.

\ text
Um texto é a_ text.

\ thing
Um elemento é a_ thing.
\ string thing
Um elemento de sequência é a_ string thing.
\ sinônimos de string thing
Um elemento de série é um elemento de sequência.
Um elemento de escrito é um elemento de sequência.
Um elemento de escrita é um elemento de sequência.

\ tick
Um tique é a_ tick.

\ timer
Um temporizador é a_ timer.

\ vertex
Um vértice é a_ vertex.

\ wave
Um som é a_ wave.
\ wave file
Um arquivo de som é a_ wave file.                                       

\ width
Uma largura é alguns twips.

\ window
Uma janela é a_ window.


Uma âncora é uma posição.


Uma elevação é a_ number.
Uma subida é a_ number.
Um designador é uma sequência.
Um marcador é uma posição.
Um múltiplo é um número.
Um número-x é um número.
Um número-y é um número.
\Um poco é a_ number.
Um alcance é um número.
Uma contagem de elementos é a_ number.
Um tamanho é a_ size.
Um tipo é a_ kind.
Um verso é um elemento com uma sequência.
Um alinhamento é uma sequência [centro, esquerda ou direita].
Uma quantidade é um número.
Uma carta é a_ byte.
Uma corrida é a_ number.
\Uma classe é uma sequência.
Uma bolha de eventos são alguns eventos.
\Um console é a_ console.
Uma consulta é uma sequência.
Uma coord-x é uma coordenada.
Uma coord-y é uma coordenada.
Uma coordenada-x é uma coordenada.
Uma coordenada-y é uma coordenada.
Uma direita é uma coordenada.
Uma diferença é a_ pair.
Uma direção é alguns degraus. \ heading
Uma distância é alguns twips.
Uma escolha é um elemento com um nome e uma caixa.
Uma entrada é an event.
Uma extensão é uma sequência.
Uma inferior é uma coordenada.
Uma esquerda é uma coordenada.
\Uma letra é um byte.                                               \ do not use -tipo de letra is a font \ use carta
Uma palavra é uma sequência.
Uma posição de sequência é a_ number.
Uma operação é uma sequência.                                        \ for remembering text for undo and redo so we don't waste saves on every character typed
Uma resposta é uma sequência.
Uma superior é uma coordenada.

\ variáveis globais em Português

O cursor flecha é um cursor.
O cursor mão é um cursor.
O cursor feixe-i é um cursor.

O erro de e/s é uma sequência.

O número máximo é 2147483647.
O número mínimo é -2147483648.

O sinalizador silencioso é uma signa.

A Bíblia é um elemento com alguns versos.

As escolhas são algumas escolhas.

A tela tem uma caixa, uma altura de pixel e uma largura de pixel.
