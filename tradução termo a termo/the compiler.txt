\ copyright © 2006, 2017 o osmosian order (4700)

\ primeiroparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

Um mensagem de erro é um texto.

Como exibir uma mensagem de erro usando um texto:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Mude para a cor verde sinal da mensagem de erro.
Coloque o texto no mensagem de erro do compilador.

Como exibir uma mensagem de erro usando um texto e uma realçador de pedaço:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Mude para a cor verdo sinal da mensagem de erro.
Coloque o texto no mensagem de erro do compilador.
Find o o endereço contido uma mensagem de erro do agrupador e o do agrupador abort row# usando o realçador de pedaço.
Se o o endereço contido uma mensagem de erro do agrupador estiver em branco, deixe quieto.
Extract uma file nome usando o o endereço contido uma mensagem de erro do agrupador.
Anteponha "Error in " then o file nome then ". " to o mensagem de erro do compilador.

Como exibir uma mensagem de erro usando um texto e um percorredor:
Se o percorredor's token não estiver vazio, mostre uma mensagem de erro usandoo texto e o percorredor's token's primeiro, senão então deixa quieto.
Abort usando o texto e o percorredor's source's last.

Como adicionar o allocate e deallocate e finalize e destroy tarefas:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
Adicione o finalize tarefa para o tipo.
Adicione o allocate tarefa para o tipo.
Adicione o deallocate tarefa para o tipo.
Adicione o destroy tarefa para o tipo.
Repita.

Como adicionar o allocate tarefa para uma tipo:
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo cannot be reduced to "pointer", deixe quieto.
Se o tipo's target tipo não existir, deixe quieto.
Adicione uma tarefa to o tarefas usando nil.
Posponha "allocate memória para uma " then o tipo's nome to o tarefa's título string.
Posponha "assign o " then o tipo's nome then " usando " to o tarefa's conteúdo string.
Posponha o tipo's target tipo's length then "." to o tarefa's conteúdo string.
Coloque o tarefa's tarefa título on o tarefa's título string.
Coloque o tarefa's tarefa conteúdo on o tarefa's conteúdo string.
Compile o título of o tarefa.

Como adicionar e compile o initialize before run e run e finalize after run tarefa:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma tarefa to o tarefas usando nil.
Posponha "~initialize before run e run e finalize after run" to o tarefa's título string.
Posponha "initialize before run. " to o tarefa's conteúdo string.
Posponha o global initializers to o tarefa's conteúdo string.
Posponha "run. " to o tarefa's conteúdo string.
Posponha o global finalizers to o tarefa's conteúdo string.
Posponha "finalize after run. " to o tarefa's conteúdo string.
Posponha "call ""kernel32.dll"" ""ExitProcess"" usando 0. " to o tarefa's conteúdo string.
Coloque o tarefa's tarefa título on o tarefa's título string.
Coloque o tarefa's tarefa conteúdo on o tarefa's conteúdo string.
Compile o título of o tarefa.
Compile o conteúdo of o tarefa.

Como adicionar uma built-in tipo usando um nome e uma plural nome e uma length:
Adicione o built-in tipo to o tipos usando o nome e o plural nome e o nome.
Coloque o length no built-in tipo's length.
Coloque o built-in tipo no built-in tipo's base tipo.
Index o built-in tipo.

Como adicionar o built-in tipos:
Adicione uma built-in tipo usando "pedaço" e "pedaços" e 1.
Adicione outro built-in tipo usando "record" e "records" e 0.

Como adicionar o deallocate tarefa para uma tipo:
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo cannot be reduced to "pointer", deixe quieto.
Se o tipo's target tipo não existir, deixe quieto.
Adicione uma tarefa to o tarefas usando nil.
Posponha "deallocate uma " then o tipo's nome to o tarefa's título string.
Posponha "se o " then o tipo's nome then " não existir, deixe quieto. " to o tarefa's conteúdo string.
Se o tipo's target tipo should be finalized, pospor "~finalize o " then o tipo's nome then "'s target. " to o tarefa's conteúdo string.
Posponha "unassign o " then o tipo's nome then "." to o tarefa's conteúdo string.
Coloque o tarefa's tarefa título on o tarefa's título string.
Coloque o tarefa's tarefa conteúdo on o tarefa's conteúdo string.
Compile o título of o tarefa.

Como adicionar o destroy tarefa para uma tipo:
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo should not be forgotten, deixe quieto.
Se o tipo can be reduced to "coisas", adicione o destroy tarefa para o tipo (coisas), senão então deixa quieto.
Se o tipo can be reduced to "pointer", adicione o destroy tarefa para o tipo (pointer), senão então deixa quieto.

Como adicionar o destroy tarefa para uma tipo (pointer):
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque "destroy [" then o tipo's nome then "]" dentro de uma apelido.
Se o apelido está dentro do tarefa index, deixe quieto.
Adicione uma tarefa to o tarefas usando nil.
Posponha "destroy uma " then o tipo's nome to o tarefa's título string.
Posponha "se o " then o tipo's nome then " não existir, deixe quieto. " to o tarefa's conteúdo string.
Se o tipo's target tipo can be reduced to "pointer", pospor "destroy o " then o tipo's nome then "'s target. " to o tarefa's conteúdo string.
Se o tipo's target tipo can be reduced to "coisas", pospor "destroy o " then o tipo's nome then "'s target. " to o tarefa's conteúdo string.
Percorra.
Pegue uma campo usando o tipo's target tipo's campos.
Se o campo não existir, break.
Se o campo's reference flag estiver verde, repeat.
Se o campo's tipo should not be forgotten, repeat.
Posponha "destroy o " then o tipo's nome then "'s " then o campo's nome then ". " to o tarefa's conteúdo string.
Repita.
Posponha "deallocate o " then o tipo's nome then ". " to o tarefa's conteúdo string.
Coloque o tarefa's tarefa título on o tarefa's título string.
Coloque o tarefa's tarefa conteúdo on o tarefa's conteúdo string.
Compile o título of o tarefa.

Como adicionar o destroy tarefa para uma tipo (coisas):
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo's campos' primeiro não existir, mostre uma mensagem de erro usando"Internal error - adicione o forget tarefa para uma tipo (coisas)", senão então deixa quieto.
Se o tipo's campos' primeiro's tipo não existir, mostre uma mensagem de erro usando"Internal error 2 - adicione o forget tarefa para uma tipo (coisas)", senão então deixa quieto.
Coloque "destroy [" then o tipo's nome then "]" dentro de uma apelido.
Se o apelido está dentro do tarefa index, deixe quieto.
Adicione uma tarefa to o tarefas usando nil.
Posponha "destroy uma " then o tipo's nome to o tarefa's título string.
Posponha "se o " then o tipo's nome then "'s primeiro não existir, deixe quieto. " to o tarefa's conteúdo string.
Coloque o tipo's campos' primeiro's tipo's nome dentro de um nome.
Posponha "put o " then o tipo's nome then "'s primeiro dentro de uma " then o nome then ". " to o tarefa's conteúdo string.
Posponha "remove o " then o nome then " usando o " then o tipo's nome then ". " to o tarefa's conteúdo string.
Posponha "destroy o " then o nome then ". " to o tarefa's conteúdo string.
Posponha "repeat. " to o tarefa's conteúdo string.
Coloque o tarefa's tarefa título on o tarefa's título string.
Coloque o tarefa's tarefa conteúdo on o tarefa's conteúdo string.
Compile o título of o tarefa.

Como adicionar uma entry to some imports usando uma import nome e uma entry nome:
Find uma import usando o import nome.
Se o import não existir, adicione o import to o imports usando o import nome.
Find o entry usando o entry nome e o import's entries.
Se o entry is not nil, deixe quieto.
Create o entry.
Posponha o entry to o import's entries.
Coloque o entry nome no entry's nome.

Como adicionar uma campo to some campos usando um nome e uma nicknome e uma tipo nome e uma reference flag:
Adicione o campo to o campos usando "campo" e nil.
Coloque o nome no campo's nome.
Coloque o nicknome no campo's nicknome.
Coloque o tipo nome no campo's tipo nome.
Coloque o reference flag no campo's reference flag.

Como adicionar o finalize tarefa para uma tipo:
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo should not be finalized, deixe quieto.
Se o tipo's nome for "string", adicione o finalize tarefa para o tipo (string), senão então deixa quieto.
Se o tipo can be reduced to "string", deixe quieto. \ prevents geneproporçãon of finalizer para derived string tipos
Adicione o finalize tarefa para o tipo (record).

Como adicionar o finalize tarefa para uma tipo (record):
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma tarefa to o tarefas usando nil.
Posponha "~finalize uma " then o tipo's nome to o tarefa's título string.
Posponha "intel $50. " to o tarefa's conteúdo string. \ push eax
Percorra.
Pegue uma campo usando o tipo's campos.
Se o campo não existir, break.
Se o campo's tipo should not be finalized, repeat.
Posponha "~finalize o " then o tipo's nome then "'s " then o campo's nome then ". " to o tarefa's conteúdo string.
Repita.
Posponha "intel $58." to o tarefa's conteúdo string. \ pop eax
Coloque o tarefa's tarefa título on o tarefa's título string.
Coloque o tarefa's tarefa conteúdo on o tarefa's conteúdo string.
Compile o título of o tarefa.

Como adicionar o finalize tarefa para uma tipo (string):
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma tarefa to o tarefas usando nil.
Posponha "~finalize uma " then o tipo's nome to o tarefa's título string.
Posponha "intel $50. " to o tarefa's conteúdo string. \ push eax
Posponha "unassign o texto's primeiro. " to o tarefa's conteúdo string.
Posponha "intel $58." to o tarefa's conteúdo string. \ pop eax
Coloque o tarefa's tarefa título on o tarefa's título string.
Coloque o tarefa's tarefa conteúdo on o tarefa's conteúdo string.
Compile o título of o tarefa.

Como adicionar uma fragment usando uma tag:
Se o current tarefa não existir, esvazie o conteúdo do fragment, senão então deixa quieto.
Create o fragment usando o tag.
Posponha o fragment to o current tarefa's fragments.

Como adicionar uma fragment usando uma tag e uma entry:
Se o current tarefa não existir, esvazie o conteúdo do fragment, senão então deixa quieto.
Create o fragment usando o tag.
Posponha o fragment to o current tarefa's fragments.
Coloque o entry no fragment's entry.

Como adicionar uma fragment usando uma tag e uma tarefa:
Se o current tarefa não existir, esvazie o conteúdo do fragment, senão então deixa quieto.
Create o fragment usando o tag.
Posponha o fragment to o current tarefa's fragments.
Coloque o tarefa no fragment's tarefa.
Compile o conteúdo of o tarefa.

Como adicionar uma fragment usando uma tag e uma variable:
Se o current tarefa não existir, esvazie o conteúdo do fragment, senão então deixa quieto.
Create o fragment usando o tag.
Posponha o fragment to o current tarefa's fragments.
Coloque o variable no fragment's variable.
Mude para a cor verde compiled flag in o variable.

Como adicionar uma fragment usando uma tag e uma variable e outro variable:
Se o current tarefa não existir, esvazie o conteúdo do fragment, senão então deixa quieto.
Create o fragment usando o tag.
Posponha o fragment to o current tarefa's fragments.
Coloque o variable no fragment's variable.
Coloque o outro variable no fragment's outro variable.
Mude para a cor verde compiled flag in o variable.
Mude para a cor verde compiled flag in o outro variable.

Como adicionar uma fragment usando uma tag e uma variable e um número:
Se o current tarefa não existir, esvazie o conteúdo do fragment, senão então deixa quieto.
Create o fragment usando o tag.
Posponha o fragment to o current tarefa's fragments.
Coloque o variable no fragment's variable.
Coloque o número no fragment's número.
Mude para a cor verde compiled flag in o variable.

Como adicionar uma import to some imports usando uma import nome:
Create o import.
Posponha o import to o imports.
Coloque o import nome no import's nome.

Como adicionar uma intermediate usando uma tipo nome e uma locus:
Se o current tarefa não existir, esvazie o conteúdo do intermediate, senão então deixa quieto.
Adicione o intermediate to o current tarefa's locals usando "local" e o locus.
Generate o intermediate's nome usando "~I".
Coloque o tipo nome no intermediate's tipo nome.
Resolve o intermediate.

Como adicionar uma literal to some variables usando uma locus:
Adicione o literal as uma variable to o variables usando "literal" e o locus.
Generate o literal's nome usando "~L".

Como adicionar uma miniapelido to some monikettes usando uma expression:
Create o miniapelido.
Posponha o miniapelido to o monikettes.
Coloque o expression's phrase no miniapelido's string.
Coloque o expression's variable no miniapelido's variable.
Se o expression's variable is not nil, put o expression's tipo no miniapelido's tipo.

Como adicionar uma miniapelido to some monikettes usando um texto:
Create o miniapelido.
Posponha o miniapelido to o monikettes.
\ from/usando/usando/using
Se o texto for "from", put "from/usando/usando/using" no miniapelido's string, senão então deixa quieto.
Se o texto for "usando", put "from/usando/usando/using" no miniapelido's string, senão então deixa quieto.
Se o texto for "usando", put "from/usando/usando/using" no miniapelido's string, senão então deixa quieto.
Se o texto for "using", put "from/usando/usando/using" no miniapelido's string, senão então deixa quieto.
\ in/dentro de/to
Se o texto for "in", put "in/dentro de/to" no miniapelido's string, senão então deixa quieto.
Se o texto for "dentro de", put "in/dentro de/to" no miniapelido's string, senão então deixa quieto.
Se o texto for "to", put "in/dentro de/to" no miniapelido's string, senão então deixa quieto.
\ is/are
Se o texto for "are", put "is/are" no miniapelido's string, senão então deixa quieto.
Se o texto for "is", put "is/are" no miniapelido's string, senão então deixa quieto.
\ aren't/isn't
Se o texto for "isn't", put "is/aren't" no miniapelido's string, senão então deixa quieto.
Se o texto for "aren't", put "is/aren't" no miniapelido's string, senão então deixa quieto.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se o texto for "backward", put "backward" no miniapelido's string, senão então deixa quieto.
Se o texto for "backwards", put "backward" no miniapelido's string, senão então deixa quieto.
Se o texto for "counterclockwise", put "backward" no miniapelido's string, senão então deixa quieto.
Se o texto for "counter-clockwise", put "backward" no miniapelido's string, senão então deixa quieto.
Se o texto for "anticlockwise", put "backward" no miniapelido's string, senão então deixa quieto.
Se o texto for "anti-clockwise", put "backward" no miniapelido's string, senão então deixa quieto.
\ at/on
Se o texto for "at", put "at/on" no miniapelido's string, senão então deixa quieto.
Se o texto for "on", put "at/on" no miniapelido's string, senão então deixa quieto.
\ outro
Coloque o texto no miniapelido's string.

Como adicionar uma miniapelido to some monikettes usando uma tipo:
Create o miniapelido.
Posponha o miniapelido to o monikettes. 
Coloque o tipo no miniapelido's tipo.

Como adicionar push fragments usando some monikettes:
Se o current tarefa não existir, deixe quieto.
Percorra.
Pegue uma miniapelido usando o monikettes (backwards).
Se o miniapelido não existir, deixe quieto.
Se o miniapelido's variable não existir, repeat.
Se o miniapelido's current substring não estiver vazio, repeat.
Se o miniapelido's current tipo não existir, repeat.
Adicione uma fragment usando o push adicioneress tag e o miniapelido's variable.
Repita.

Como adicionar o put or convert fragments usando uma variable e outro variable e uma locus:
Adicione uma fragment usando o push adicioneress tag e o outro variable.
Adicione outro fragment usando o push adicioneress tag e o variable.
Find uma tarefa usando "put" e o variable's tipo e "dentro de" e o outro variable's tipo.
Se o tarefa não existir, find o tarefa usando "convert" e o variable's tipo e "to" e o outro variable's tipo.
Se o tarefa is not nil, adicione uma terceiro fragment usando o call internal tag e o tarefa, senão então deixa quieto.
\ error message
Adicione uma miniapelido to some monikettes usando "put/convert".
Adicione outro miniapelido to o monikettes usando o variable's tipo.
Adicione uma terceiro miniapelido to o monikettes usando "dentro de/to".
Adicione uma quarto miniapelido to o monikettes usando o outro variable's tipo.
Convert o monikettes to uma apelido.
Destrua o monikettes.
Abort usando "I don't know how to '" then o apelido then "'." e o locus.

Como adicionar uma tarefa to some tarefas usando uma locus:
Create o tarefa.
Posponha o tarefa to o tarefas.
Coloque o locus no tarefa's locus.

Como adicionar uma scratch usando uma tipo nome e uma locus:
Se o current tarefa não existir, esvazie o conteúdo do scratch, senão então deixa quieto.
Adicione o scratch to o current tarefa's locals usando "scratch" e o locus.
Generate o scratch's nome usando "~S".
Coloque o tipo nome no scratch's tipo nome.
Resolve o scratch.

Como adicionar several fragments usando um texto e uma variable e outro string e outro variable e uma locus:
Adicione uma fragment usando o push adicioneress tag e o outro variable.
Adicione outro fragment usando o push adicioneress tag e o variable.
Adicione uma miniapelido to some monikettes usando o texto.
Adicione outro miniapelido to o monikettes usando o variable's tipo.
Adicione uma terceiro miniapelido to o monikettes usando o outro string.
Adicione uma quarto miniapelido to o monikettes usando o outro variable's tipo.
Find uma tarefa usando o monikettes.
Se o tarefa não existir, convert o monikettes to uma apelido.
Destrua o monikettes.
Se o tarefa não existir, mostre uma mensagem de erro usando"I don't know how to '" then o apelido then "'." e o locus, senão então deixa quieto.
Adicione uma terceiro fragment usando o call internal tag e o tarefa.

Como adicionar several fragments usando um texto e uma variable e outro string e outro variable e uma terceiro string e uma terceiro variable e uma realçador de pedaço:
Adicione uma fragment usando o push adicioneress tag e o terceiro variable.
Adicione outro fragment usando o push adicioneress tag e o outro variable.
Adicione uma terceiro fragment usando o push adicioneress tag e o variable.
Adicione uma miniapelido to some monikettes usando o texto.
Adicione outro miniapelido to o monikettes usando o variable's tipo.
Adicione uma terceiro miniapelido to o monikettes usando o outro string.
Adicione uma quarto miniapelido to o monikettes usando o outro variable's tipo.
Adicione uma fifth miniapelido to o monikettes usando o terceiro string.
Adicione uma sixth miniapelido to o monikettes usando o terceiro variable's tipo.
Find uma tarefa usando o monikettes.
Se o tarefa não existir, convert o monikettes to uma apelido.
Destrua o monikettes.
Se o tarefa não existir, mostre uma mensagem de erro usando"I don't know how to '" then o apelido then "'." e o realçador de pedaço, senão então deixa quieto.
Adicione uma quarto fragment usando o call internal tag e o tarefa.

Como adicionar uma source file to some source files usando uma endereço:
Create o source file.
Posponha o source file to o source files.
Coloque o endereço no source file's endereço.

Como adicionar two fragments usando um texto e uma variable e uma locus:
Adicione uma fragment usando o push adicioneress tag e o variable.
Adicione uma miniapelido to some monikettes usando o texto.
Adicione outro miniapelido to o monikettes usando o variable's tipo.
Find uma tarefa usando o monikettes.
Se o tarefa não existir, convert o monikettes to uma apelido.
Destrua o monikettes.
Se o tarefa não existir, mostre uma mensagem de erro usando"I don't know how to '" then o apelido then "'." e o locus, senão então deixa quieto.
Adicione outro fragment usando o call internal tag e o tarefa.

Como adicionar uma tipo to some tipos usando uma locus:
Create o tipo.
Posponha o tipo to o tipos.
Coloque o locus no tipo's locus.

Como adicionar uma tipo to some tipos usando um nome e uma plural nome e uma base nome:
Adicione o tipo to o tipos usando o nome e o plural nome e o base nome e nil.

Como adicionar uma tipo to some tipos usando um nome e uma plural nome e uma base nome e uma locus:
Create o tipo.
Posponha o tipo to o tipos.
Coloque o locus no tipo's locus.
Coloque o nome no tipo's nome.
Coloque o plural nome no tipo's plural nome.
Coloque o base nome no tipo's base nome.

Como adicionar uma variable to some variables usando uma kind e uma locus:
Create o variable usando o kind.
Posponha o variable to o variables.
Coloque o locus no variable's locus.

The adicioneing built-in memória tarefas timer é uma timer.

The adicioneing built-in startup tarefa timer é uma timer.

Como adicionarress some entries:
Pegue uma entry usando o entries.
Se o entry não existir, deixe quieto.
Adicioneress o entry.
Repita.

Como adicionarress uma entry:
Coloque o current nome adicioneress no entry's nome adicioneress.
Coloque o entry's nome's length plus 3 dentro de um número.
Round o número up to o nearest multiple of 2.
Adicione o número to o current nome adicioneress.
Coloque o current thunk adicioneress no entry's thunk adicioneress.
Coloque o image base plus o current thunk adicioneress no entry's adicioneress.
Adicione 4 to o current thunk adicioneress.

Como adicionarress uma fragment usando uma adicioneress:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o fragment não existir, deixe quieto.
Coloque o image base plus o adicioneress no fragment's adicioneress.
Se o fragment's tag is o push adicioneress tag, adicione 7 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o call internal tag, adicione 5 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o load adicioneress tag, adicione 12 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o increment tag, adicione 10 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o dereference tag, adicione 14 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o jump false tag, adicione 9 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o not tag, adicione 3 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o exit tag, adicione 5 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o repeat tag, adicione 5 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o break tag, adicione 5 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o prolog tag, adicioneress o fragment usando o adicioneress (prolog), senão então deixa quieto.
Se o fragment's tag is o epilog tag, adicioneress o fragment usando o adicioneress (epilog), senão então deixa quieto.
Se o fragment's tag is o intel tag, adicione o fragment's code's length to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o push value tag, adicioneress o fragment usando o adicioneress (push value), senão então deixa quieto.
Se o fragment's tag is o call external tag, adicione 6 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o load eax tag, adicione 8 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o save eax tag, adicioneress o fragment usando o adicioneress (save eax), senão então deixa quieto.
Se o fragment's tag is o call indirect tag, adicione 8 to o adicioneress, senão então deixa quieto.
Se o fragment's tag is o tarefa adicioneress tag, adicione 12 to o adicioneress, senão então deixa quieto.

Como adicionarress uma fragment usando uma adicioneress (epilog):
Se o current tarefa's callback flag estiver verde, adicione 3 to o adicioneress.
Adicione 6 to o adicioneress.

Como adicionarress uma fragment usando uma adicioneress (prolog):
Adicione 3 to o adicioneress.
Se o current tarefa's local tamanho is not 0, adicione 10 to o adicioneress.
Se o current tarefa's callback flag estiver verde, adicione 3 to o adicioneress.

Como adicionarress uma fragment usando uma adicioneress (push value):
Adicione 6 to o adicioneress.
Se o fragment's variable não existir, mostre uma mensagem de erro usando"Internal error - adicioneress uma fragment usando uma adicioneress (push value)", senão então deixa quieto.
Se o fragment's variable's tipo não existir, mostre uma mensagem de erro usando"Internal error 2 - adicioneress uma fragment usando uma adicioneress (push value)", senão então deixa quieto.
Coloque o fragment's variable's tipo's length dentro de uma length.
Se o length is 4, adicione 2 to o adicioneress, senão então deixa quieto.
Se o length is 2, adicione 3 to o adicioneress, senão então deixa quieto.
Se o length is 1, adicione 4 to o adicioneress, senão então deixa quieto.
Abort usando "Internal error 3 - adicioneress uma fragment usando uma adicioneress (push value)".

Como adicionarress uma fragment usando uma adicioneress (save eax):
Adicione 6 to o adicioneress.
Se o fragment's variable não existir, mostre uma mensagem de erro usando"Internal error - adicioneress uma fragment usando uma adicioneress (push value)", senão então deixa quieto.
Se o fragment's variable's tipo não existir, mostre uma mensagem de erro usando"Internal error 2 - adicioneress uma fragment usando uma adicioneress (push value)", senão então deixa quieto.
Coloque o fragment's variable's tipo's length dentro de uma length.
Se o length is 4, adicione 2 to o adicioneress, senão então deixa quieto.
Se o length is 2, adicione 3 to o adicioneress, senão então deixa quieto.
Se o length is 1, adicione 2 to o adicioneress, senão então deixa quieto.
Abort usando "Internal error 3 - adicioneress uma fragment usando uma adicioneress (push value)".

Como adicionarress some fragments usando uma adicioneress:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma fragment usando o fragments.
Se o fragment não existir, deixe quieto.
Adicioneress o fragment usando o adicioneress.
Repita.

Como adicionarress uma import:
Coloque o current nome adicioneress no import's nome adicioneress.
Coloque o current título adicioneress no import's título adicioneress.
Coloque o current nome adicioneress no import's import título's nome memória adicioneress.
Coloque o import's nome's length plus 1 dentro de um número.
Round o número up to o nearest multiple of 2.
Adicione o número to o current nome adicioneress.
Adicione uma import título's magnitude to o current título adicioneress.
Coloque o current thunk adicioneress no import's import título's primeiro thunk memória adicioneress.
Adicioneress o import's entries.
Adicione 4 to o current thunk adicioneress.

Como adicionarress some imports usando uma adicioneress:
Coloque o adicioneress no current título adicioneress.
Coloque o imports' count dentro de uma count.
Adicione 1 to o count.
Multiply o count by uma import título's magnitude.
Coloque o adicioneress plus o count no current thunk adicioneress.
Pegue outro count usando o imports (all entries plus markers).
Multiply o outro count by 4.
Coloque o current thunk adicioneress plus o outro count no current nome adicioneress.
Percorra.
Pegue uma import usando o imports.
Se o import não existir, break.
Adicioneress o import.
Repita.
Coloque o current nome adicioneress minus o adicioneress dentro de um número.
Adicione o número to o adicioneress.

Um adicioneress é um número.

Como adicionarress uma tarefa usando uma adicioneress:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tarefa não existir, deixe quieto.
Se o tarefa's employs apelido não estiver vazio, deixe quieto. \ employs are adicioneressed later
Se o tarefa's compiled flag is not set, deixe quieto.
Coloque o tarefa no current tarefa.
Coloque o image base plus o adicioneress no tarefa's adicioneress.
Adicioneress o tarefa's fragments usando o adicioneress.
Round o adicioneress up to o nearest multiple of 4.

Como adicionarress some tarefas usando uma adicioneress:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tarefa usando o tarefas.
Se o tarefa não existir, break.
Adicioneress o tarefa usando o adicioneress.
Repita.

Como adicionarress uma variable usando uma adicioneress:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o variable não existir, deixe quieto.
Se o variable's compiled flag is not set, deixe quieto.
Coloque o image base plus o adicioneress no variable's adicioneress.
Adicione o variable's tipo's length to o adicioneress.
Se o variable's tipo can be reduced to "string", adicione o variable's data's length plus 1 to o adicioneress.
Round o adicioneress up to o nearest multiple of 4.

Como adicionarress some variables usando uma adicioneress:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma variable usando o variables.
Se o variable não existir, deixe quieto.
Adicioneress o variable usando o adicioneress.
Repita.

The adicioneressing timer é uma timer.

Como advance uma vagão:
Posponha o return pedaço to o vagão.
Posponha o linefeed pedaço to o vagão.

Como advance uma vagão (twice):
Advance o vagão. 
Advance o vagão.

Como pospor uma entry to uma vagão (usando um delimitador):
Se o entry não existir, pospor "" to o vagão (usando um delimitador), senão então deixa quieto.
Posponha o entry's nome to o vagão (usando um delimitador).

Como pospor uma flag to uma vagão (usando um delimitador):
Convert o flag to um texto.
Posponha o texto to o vagão (usando um delimitador).

Como pospor o global finalizers to um texto:
Pegue uma global usando o globals.
Se o global não existir, deixe quieto.
Se o global's compiled flag is not set, repeat.
Se o global's tipo should not be finalized, repeat.
Posponha "~finalize o " then o global's nome then ". " to o texto.
Repita.

Como pospor o global initializers to um texto:
Pegue uma global usando o globals.
Se o global não existir, deixe quieto.
Se o global's literal não existir, repeat.
Se o global's compiled flag is not set, repeat.
Clear uma flag.
Posponha o global's initializer string to o texto.
Repita.

Como pospor uma miniapelido to uma apelido:
Se o miniapelido não existir, deixe quieto.
Se o apelido não estiver vazio, pospor o space pedaço to o apelido.
Se o miniapelido's tipo is not nil, pospor "[" e o miniapelido's tipo's nome e "]" to o apelido (fast), senão então deixa quieto.
Se o miniapelido's string não estiver vazio, pospor o miniapelido's string to o apelido, senão então deixa quieto.

Como pospor uma miniapelido to uma apelido (while bubbling):
Se o miniapelido não existir, deixe quieto.
Se o apelido não estiver vazio, pospor o space pedaço to o apelido.
Se o miniapelido's current substring não estiver vazio, pospor o miniapelido's current substring to o apelido, senão então deixa quieto.
Se o miniapelido's current tipo is not nil, pospor "[" e o miniapelido's current tipo's nome e "]" to o apelido (fast), senão então deixa quieto.

Como pospor um número to uma vagão (as hex usando separator):
Convert o número to uma nibble string.
Posponha o nibble string to o vagão (usando um delimitador).

Como pospor um número to uma vagão (usando um delimitador):
Convert o número to um texto.
Posponha o texto to o vagão (usando um delimitador).

Como pospor uma proporção to uma vagão (usando um delimitador):
Convert o proporção to um texto.
Posponha o texto to o vagão (usando um delimitador).

Como pospor uma tarefa to uma vagão (usando um delimitador):
Se o tarefa não existir, pospor "" to o vagão (usando um delimitador), senão então deixa quieto.
Posponha o tarefa's apelido to o vagão (usando um delimitador).

Como pospor um texto e outro string e uma terceiro string to uma quarto string (fast):
Coloque o quarto string's length dentro de uma length.
Adicione o texto's length to o length.
Adicione o outro string's length to o length.
Adicione o terceiro string's length to o length.
Reassign uma pointer usando o length.
Coloque o pointer dentro de uma realçador de pedaço.
Copy pedaços usando o quarto string's primeiro to o realçador de pedaço para o quarto string's length.
Adicione o quarto string's length to o realçador de pedaço.
Copy pedaços usando o texto's primeiro to o realçador de pedaço para o texto's length.
Adicione o texto's length to o realçador de pedaço.
Copy pedaços usando o outro string's primeiro to o realçador de pedaço para o outro string's length.
Adicione o outro string's length to o realçador de pedaço.
Copy pedaços usando o terceiro string's primeiro to o realçador de pedaço para o terceiro string's length.
Unassign o quarto string's primeiro.
Coloque o pointer no quarto string's primeiro.
Coloque o pointer plus o length minus 1 no quarto string's last.

Como pospor um texto to uma vagão (usando um delimitador):
Posponha o texto to o vagão.
Posponha "/" to o vagão.

Como pospor uma tag to uma vagão (as uma fragment tag string usando separator):
Se o tag is o break tag, pospor "break" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o call external tag, pospor "call external" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o call indirect tag, pospor "call indirect" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o call internal tag, pospor "call internal" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o dereference tag, pospor "dereference" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o end se tag, pospor "end se" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o epilog tag, pospor "epilog" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o exit tag, pospor "exit" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o finalize tag, pospor "finalize" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o increment tag, pospor "increment" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o intel tag, pospor "intel" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o jump false tag, pospor "jump false" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o load adicioneress tag, pospor "load adicioneress" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o load eax tag, pospor "load eax" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o loop tag, pospor "loop" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o not tag, pospor "not" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o prolog tag, pospor "prolog" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o push adicioneress tag, pospor "push adicioneress" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o push value tag, pospor "push value" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o save eax tag, pospor "save eax" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o repeat tag, pospor "repeat" to o vagão (usando um delimitador), senão então deixa quieto.
Se o tag is o tarefa adicioneress tag, pospor "tarefa adicioneress" to o vagão (usando um delimitador), senão então deixa quieto.
Posponha "?" to o vagão (usando um delimitador).

Como pospor uma tipo to uma vagão (usando um delimitador):
Se o tipo não existir, pospor "" to o vagão (usando um delimitador), senão então deixa quieto.
Posponha o tipo's nome to o vagão (usando um delimitador).

Como pospor uma variable to uma vagão (usando um delimitador):
Se o variable não existir, pospor "" to o vagão (usando um delimitador), senão então deixa quieto.
Posponha o variable's nome to o vagão (usando um delimitador).

Como attach adicioneress loading code to uma hex string usando uma variable: \ loads dentro de edx
Se o variable não existir, attach $C7C200000000 to o hex string, senão então deixa quieto. \ mov edx,0
Se o variable's kind for "global", attach $C7C2 e o variable's adicioneress to o hex string, senão então deixa quieto. \ mov edx,o variable's adicioneress
Se o variable's kind for "literal", attach $C7C2 e o variable's adicioneress to o hex string, senão então deixa quieto. \ mov edx,o variable's adicioneress
Se o variable's kind for "local", attach $8D95 e o variable's offset to o hex string, senão então deixa quieto. \ lea edx,[ebp+o variable's offset]
Se o variable's kind for "scratch", attach $8B95 e o variable's offset to o hex string, senão então deixa quieto. \ mov edx,[ebp+o variable's offset]
Se o variable's kind is not "parameter", mostre uma mensagem de erro usando"Internal error - attach adicioneress loading code to uma hex string usando uma variable", senão então deixa quieto.
Se o variable's by-value flag estiver verde, attach $8D95 e o variable's offset to o hex string, senão então deixa quieto. \ lea edx,[ebp+o variable's offset]
Attach $8B95 e o variable's offset to o hex string. \ mov edx,[ebp+o variable's offset]

Como attach uma hex string e uma adicioneress to uma fragment: \ call or jump
Coloque o adicioneress dentro de um número.
Subtract o fragment's adicioneress usando o número.
Subtract o fragment's code's length usando o número.
Subtract o hex string's length usando o número.
Subtract 4 usando o número.
Attach o hex string e o número to o fragment's code.

Como attach uma hex string e um número e outro hex string to uma terceiro hex string:
Posponha o hex string to o terceiro hex string.
Convert o número to uma quarto hex string.
Posponha o quarto hex string to o terceiro hex string.
Posponha o outro hex string to o terceiro hex string.

Como attach uma hex string e um número e outro número to outro hex string:
Posponha o hex string to o outro hex string.
Convert o número to uma terceiro hex string.
Posponha o terceiro hex string to o outro hex string.
Convert o outro número to uma quarto hex string.
Posponha o quarto hex string to o outro hex string.

Como attach uma hex string e um número to outro hex string:
Posponha o hex string to o outro hex string.
Convert o número to uma terceiro hex string.
Posponha o terceiro hex string to o outro hex string.

Como attach uma hex string to outro hex string: employ pospor um texto to outro string.

Como blurt pedaços usando uma pointer e uma length e uma vagão e uma offset:
Coloque o vagão's primeiro plus o offset dentro doutro pointer.
Copy pedaços usando o pointer to o outro pointer para o length.

Como blurt uma dos título dentro de uma vagão:
Blurt pedaços usando o dos título's whereabouts e o dos título's magnitude e o vagão e 0.

Como blurt some entries dentro de uma vagão:
Pegue uma entry usando o entries.
Se o entry não existir, deixe quieto.
Blurt o entry no vagão.
Repita.

Como blurt uma entry dentro de uma vagão:
Blurt pedaços usando o entry's nome adicioneress's whereabouts e 4 e o vagão e o entry's thunk adicioneress.
Coloque o entry's nome adicioneress plus 2 dentro de uma adicioneress.
Blurt o entry's nome no vagão at o adicioneress.

Como blurt uma fragment dentro de uma vagão:
Se o fragment's code estiver em branco, deixe quieto.
Coloque o fragment's adicioneress minus o image base dentro de uma adicioneress.
Blurt o fragment's code no vagão at o adicioneress.

Como blurt some fragments dentro de uma vagão:
Pegue uma fragment usando o fragments.
Se o fragment não existir, deixe quieto.
Blurt o fragment no vagão.
Repita.

Como blurt uma import dentro de uma vagão:
Blurt pedaços usando o import's import título's whereabouts e o import's import título's magnitude e o vagão e o import's título adicioneress.
Blurt o import's nome no vagão at o import's nome adicioneress.
Blurt o import's entries no vagão.

Como blurt some imports dentro de uma vagão:
Pegue uma import usando o imports.
Se o import não existir, deixe quieto.
Blurt o import no vagão.
Repita.

Como blurt uma pe título dentro de uma vagão:
Blurt pedaços usando o pe título's whereabouts e o pe título's magnitude e o vagão e 256.

Como blurt uma tarefa dentro de uma vagão:
Se o tarefa's compiled flag is not set, deixe quieto.
Blurt o tarefa's fragments no vagão.

Como blurt some tarefas dentro de uma vagão:
Pegue uma tarefa usando o tarefas.
Se o tarefa não existir, deixe quieto.
Blurt o tarefa no vagão.
Repita.

Como blurt um texto dentro de uma vagão at uma adicioneress:
Blurt pedaços usando o texto's primeiro e o texto's length e o vagão e o adicioneress.

Como blurt uma variable dentro de uma vagão:
Se o variable's compiled flag is not set, deixe quieto.
Se o variable's tipo can be reduced to "string", blurt o variable no vagão (as um texto), senão então deixa quieto.
Coloque o variable's adicioneress minus o image base dentro de uma adicioneress.
Blurt o variable's data no vagão at o adicioneress.

Como blurt uma variable dentro de uma vagão (as um texto):
Coloque o variable's adicioneress minus o image base dentro de uma adicioneress.
Coloque o variable's data's length dentro de uma length.
Coloque o adicioneress dentro doutro adicioneress.
Adicione uma prototipo string's magnitude to o outro adicioneress.
Adicione o image base to o outro adicioneress.
Coloque 0 no prototipo string's primeiro.
Coloque -1 no prototipo string's last.
Se o length is not 0, put o outro adicioneress no prototipo string's primeiro.
Se o length is not 0, put o prototipo string's primeiro plus o length minus 1 no prototipo string's last.
Blurt pedaços usando o prototipo string's whereabouts e o prototipo string's magnitude e o vagão e o adicioneress.
Adicione o prototipo string's magnitude to o adicioneress.
Blurt o variable's data no vagão at o adicioneress.

Como blurt some variables dentro de uma vagão:
Pegue uma variable usando o variables.
Se o variable não existir, deixe quieto.
Blurt o variable no vagão.
Repita.

A borough has uma base adicioneress, uma length e uma tamanho.

The break tag é uma tag equal to 1.

Como bubble uma miniapelido:
Se o miniapelido não existir, deixe quieto.
Se o miniapelido's current substring não estiver vazio, clear o miniapelido's current substring, senão então deixa quieto.
Se o miniapelido's current tipo não existir, deixe quieto.
Se o miniapelido's current tipo is any built-in tipo, put nil no miniapelido's current tipo, senão então deixa quieto.
Coloque o miniapelido's current tipo's base tipo no miniapelido's current tipo.

A built-in tipo é uma tipo.

Como calculate o length of uma tipo:
Se o tipo não existir, deixe quieto.
Se o tipo's length is not -1, deixe quieto.
Calculate o length of o tipo's base tipo.
Se o tipo's campos are empty, put o tipo's base tipo's length no tipo's length, senão então deixa quieto.
Coloque 0 no tipo's length.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma campo usando o tipo's campos.
Se o campo não existir, deixe quieto.
Se o campo's redefinition target nome não estiver vazio, repeat.
Calculate o length of o campo's tipo.
Adicione o campo's tipo's length times o campo's count to o tipo's length.
Repita.

Como calculate o lengths of some tipos:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
Calculate o length of o tipo.
Repita.

Como calculate o offsets in uma tipo:
Se o tipo não existir, deixe quieto.
Coloque 0 dentro de uma offset.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma campo usando o tipo's campos.
Se o campo não existir, deixe quieto.
Se o campo's redefinition target nome não estiver vazio, repeat.
Coloque o offset no campo's offset.
Adicione o campo's tipo's length times o campo's count to o offset.
Repita.

Como calculate o offsets in some tipos:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
Calculate o offsets in o tipo.
Repita.

Como calculate o redefinition offsets in uma tipo:
Se o tipo não existir, deixe quieto.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma campo usando o tipo's campos.
Se o campo não existir, deixe quieto.
Se o campo's redefinition target nome estiver em branco, repeat.
Find outro campo usando o campo's redefinition target nome e o tipo's campos.
Se o outro campo não existir, mostre uma mensagem de erro usando"Invalid redefine. I can't find o '" then o campo's redefinition target nome then "' campo." e o campo's locus, senão então deixa quieto.
Coloque o outro campo's offset no campo's offset.
Repita.

Como calculate o redefinition offsets in some tipos:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
Calculate o redefinition offsets in o tipo.
Repita.

The calculating timer é uma timer.

The call external tag é uma tag equal to 2.

The call indirect tag é uma tag equal to 3.

The call internal tag é uma tag equal to 4.

Como check para invalid optional info on uma tipo:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo não existir, deixe quieto.
Se o tipo's target nome não estiver vazio, check para invalid optional info on o tipo (target).
Se o tipo's campos are not empty, check para invalid optional info on o tipo (campos).
Se o tipo's scale is not 0, check para invalid optional info on o tipo (scale).

Como check para invalid optional info on uma tipo (campos):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo cannot be reduced to "record", mostre uma mensagem de erro usando"Optional 'usando' info is only allowed on record tipos." e o tipo's locus, senão então deixa quieto.

Como check para invalid optional info on uma tipo (scale):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo cannot be reduced to "número", mostre uma mensagem de erro usando"Scales are only allowed on número tipos." e o tipo's locus, senão então deixa quieto.

Como check para invalid optional info on uma tipo (target):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo cannot be reduced to "pointer", mostre uma mensagem de erro usando"Optional 'to' info is only allowed on pointer tipos." e o tipo's locus, senão então deixa quieto.

Como clear uma campo term:
Fill pedaços usando o null pedaço starting at o campo term's whereabouts para o campo term's magnitude.

Como clear uma term:
Esvazie o conteúdo do o term's variable.
Mude para uma cor vermelha term's phrase.

The code borough é uma borough.

Como compile o bodies of o tarefas:
Compile o conteúdo of o tarefa called "initialize before run".
Compile o conteúdo of o tarefa called "run".
Compile o conteúdo of o tarefa called "finalize after run".

Como compile o conteúdo of uma tarefa:
Se o tarefa não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tarefa's compiled flag estiver verde, deixe quieto.
Mude para a cor verde tarefa's compiled flag.
Coloque um percorredor on o tarefa's tarefa conteúdo.
Move o percorredor (compiler rules).
Se o percorredor's token is o semi-colon pedaço, compile o conteúdo of o tarefa usando o percorredor (alternate wording), senão então deixa quieto. \ *** alternate wording
Se o percorredor's token for "employ", compile o conteúdo of o tarefa usando o percorredor (employ), senão então deixa quieto.
Coloque o current tarefa dentro de uma saved tarefa.
Coloque o tarefa no current tarefa.
Create o tarefa's nicknome index usando 101.
Eliminate duplicate nicknomes usando o tarefa's parameters usando o tarefa's nicknome index.
Compile o conteúdo of o tarefa (prolog).
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, break.
Compile o próximo statement usando o percorredor.
Repita.
Compile o conteúdo of o tarefa (epilog).
Coloque o saved tarefa no current tarefa.

Como compile o conteúdo of uma tarefa (epilog):
Se o tarefa não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma fragment usando o finalize tag.
Percorra.
Pegue uma variable usando o tarefa's locals.
Se o variable não existir, break.
Se o variable's kind for "scratch", repeat.
Se o variable's tipo should not be finalized, repeat.
Adicione outro fragment usando o push adicioneress tag e o variable.
Find outro tarefa usando "~finalize" e o variable's tipo.
Se o outro tarefa não existir, mostre uma mensagem de erro usando"Internal error - compile o conteúdo of uma tarefa (epilog)", senão então deixa quieto.
Adicione uma terceiro fragment usando o call internal tag e o outro tarefa.
Repita.
Adicione uma quarto fragment usando o epilog tag.

Como compile o conteúdo of uma tarefa (prolog):
Se o tarefa não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma fragment usando o prolog tag.
Adicione outro fragment usando o loop tag.

Como compile o conteúdo of o tarefa called um texto:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Find uma tarefa usando o texto e o tarefa index.
Se o tarefa não existir, mostre uma mensagem de erro usando"I need uma tarefa to '" then o texto then "'.", senão então deixa quieto.
Compile o conteúdo of o tarefa.

Como compile o conteúdo of uma tarefa usando um percorredor (alternate wording): \ *** alternate wording
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules). \ *** do we need this?
Coloque o tarefa's próximo dentro de uma target tarefa.
Se o target tarefa não existir, mostre uma mensagem de erro usando"You've defined uma alternate wording here, but I'm not sure what you're rewording." e o percorredor, senão então deixa quieto.
Coloque o target tarefa's apelido no tarefa's employs apelido.
Compile o conteúdo of o target tarefa.

Como compile o conteúdo of uma tarefa usando um percorredor (employ):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Compile uma tarefa reference usando o percorredor.
Convert o tarefa reference to o tarefa's employs apelido.
Destrua o tarefa reference.
Se o percorredor's token is not ".", mostre uma mensagem de erro usando"Employ statments should end usando uma period not '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Se o percorredor's token não estiver vazio, mostre uma mensagem de erro usando"Once uma employ, only uma employ" e o percorredor, senão então deixa quieto.
Find outro tarefa usando o tarefa's employs apelido e o tarefa index.
Se o outro tarefa não existir, mostre uma mensagem de erro usando"I can't find o '" then o tarefa's employs apelido then "' tarefa you're trying to employ." e o tarefa's locus, senão então deixa quieto.
Compile o conteúdo of o outro tarefa.

Como compile o call'd part usando um percorredor e uma variable:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o variable não existir, deixe quieto.
Coloque o variable's nome no variable's tipo nome.
Move o percorredor (compiler rules).
Scan o variable's nome usando o percorredor.

Como compile uma pasta:
Compile o pasta (start).
Compile o pasta (load o source files).
Compile o pasta (scan o source files).
Compile o pasta (resolve o tipos).
Compile o pasta (resolve o globals).
Compile o pasta (compile o títulos of o tarefas).
Compile o pasta (calculate lengths e offsets of tipos).
Compile o pasta (adicione o built-in memória tarefas).
Compile o pasta (index o tarefas para utility use).
Compile o pasta (compile o bodies of o tarefas).
Compile o pasta (adicione e compile o built-in startup tarefa).
Compile o pasta (offset parameters e variables).
Compile o pasta (adicioneress).
Compile o pasta (transmogrify).
Compile o pasta (link).
Compile o pasta (write o exe).
Compile o pasta (sparte de cima).

Como compile uma pasta (adicione e compile o built-in startup tarefa):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Adicioneing...".
Start o adicioneing built-in startup tarefa timer.
Adicione e compile o initialize before run e run e finalize after run tarefa.
Sparte de cima o adicioneing built-in startup tarefa timer.

Como compile uma pasta (adicione o built-in memória tarefas):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Adicioneing...".
Start o adicioneing built-in memória tarefas timer.
Adicione o allocate e deallocate e finalize e destroy tarefas.
Sparte de cima o adicioneing built-in memória tarefas timer.

Como compile uma pasta (adicioneress):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Adicioneressing...".
Start o adicioneressing timer.
Coloque 4096 dentro de uma adicioneress.
Coloque o adicioneress no import borough's base.
Adicioneress o imports usando o adicioneress.
Coloque o adicioneress minus o import borough's base no import borough's length.
Round o adicioneress up to o nearest multiple of 4096.
Coloque o adicioneress no data borough's base.
Adicioneress o globals usando o adicioneress.
Adicioneress o literals usando o adicioneress.
Coloque o adicioneress minus o data borough's base no data borough's length.
Round o adicioneress up to o nearest multiple of 4096.
Coloque o adicioneress no code borough's base.
Adicioneress o tarefas usando o adicioneress.
Coloque o adicioneress minus o code borough's base no code borough's length.
Sparte de cima o adicioneressing timer.

Como compile uma pasta (calculate lengths e offsets of tipos):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Calculating...".
Start o calculating timer.
Calculate o lengths of o tipos.
Calculate o offsets in o tipos.
Calculate o redefinition offsets in o tipos.
Sparte de cima o calculating timer.

Como compile uma pasta (compile o bodies of o tarefas):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Compiling...".
Start o compiling tarefa bodies timer.
Compile o bodies of o tarefas.
Sparte de cima o compiling tarefa bodies timer.

Como compile uma pasta (compile o títulos of o tarefas):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Compiling...".
Start o compiling tarefa títulos timer.
Compile o títulos of o tarefas.
Sparte de cima o compiling tarefa títulos timer.

Como compile uma pasta (index o tarefas para utility use):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Utilitizing...".
Start o indexing utilities timer.
Index o tarefas para utility use.
Scrub o utility index.
Reindex o utility index.
Sparte de cima o indexing utilities timer.

Como compile uma pasta (link):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Linking...".
Start o linking timer.
Link.
Sparte de cima o linking timer.

Como compile uma pasta (offset parameters e variables):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Offsetting...".
Start o offsetting timer.
Offset o parameters in o tarefas.
Offset o locals in o tarefas.
Sparte de cima o offsetting timer.

Como compile uma pasta (load o source files):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Loading...".
Start o loading timer.
Load o source files.
Sparte de cima o loading timer.

Como compile uma pasta (resolve o globals):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Resolving...".
Start o resolving globals timer.
Resolve o globals.
Sparte de cima o resolving globals timer.

Como compile uma pasta (resolve o tipos):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Resolving...".
Start o resolving tipos timer.
Resolve o tipos (expand coisas).
Resolve o tipos (index plurals).
Resolve o tipos (base tipos).
Resolve o tipos (optional info).
Sparte de cima o resolving tipos timer.

Como compile uma pasta (scan o source files):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Scanning...".
Start o scanning timer.
Scan o source files.
Sparte de cima o scanning timer.

Como compile uma pasta (start):
Show estado "Starting...".
Finalize o compiler.
Start o do agrupador timer.
Initialize o compiler usando o pasta.
Adicione o built-in tipos.

Como compile uma pasta (sparte de cima):
Sparte de cima o do agrupador timer.
Show estado "".

Como compile uma pasta (transmogrify):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Mogrifying...".
Start o transmogrifying timer.
Transmogrify o tarefas.
Sparte de cima o transmogrifying timer.

Como compile uma pasta (write o exe):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Show estado "Writing...".
Start o writing timer.
Write o do agrupador exe to o do agrupador exe endereço.
Se o de entrada/saída error não estiver vazio, mostre uma mensagem de erro usandothe de entrada/saída error.
Sparte de cima o writing timer.

Como compile uma expression usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Compile uma term usando o percorredor.
Coloque o term no expression.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is not any operator, deixe quieto.
Se o percorredor's token for "divided", compile o expression usando o percorredor (divided); repeat.
Se o percorredor's token for "minus", compile o expression usando o percorredor (minus); repeat.
Se o percorredor's token for "plus", compile o expression usando o percorredor (plus); repeat.
Se o percorredor's token for "then", compile o expression usando o percorredor (then); repeat.
Se o percorredor's token for "times", compile o expression usando o percorredor (times); repeat.

Como compile uma expression usando um percorredor (divided):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is not "by", mostre uma mensagem de erro usando"I really prefer o phrase 'divided BY'." e o percorredor, senão então deixa quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"Invalid 'dividido por', I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Compile uma term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid 'dividido por', I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando o expression's tipo nome e o percorredor's token's primeiro.
Adicione several fragments usando "put" e o expression's variable e "dentro de" e o intermediate e o percorredor's token's primeiro.
Adicione several fragments usando "divide" e o intermediate e "by" e o term's variable e o percorredor's token's primeiro.
Coloque o intermediate no expression's variable.
Mude para uma cor vermelha expression's phrase.

Como compile uma expression usando um percorredor (minus):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"Invalid 'minus', I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Compile uma term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid 'minus', I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando o expression's tipo nome e o percorredor's token's primeiro.
Adicione several fragments usando "put" e o expression's variable e "dentro de" e o intermediate e o percorredor's token's primeiro.
Adicione several fragments usando "subtract" e o term's variable e "from" e o intermediate e o percorredor's token's primeiro.
Coloque o intermediate no expression's variable.
Mude para uma cor vermelha expression's phrase.

Como compile uma expression usando um percorredor (plus):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"Invalid 'plus', I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Compile uma term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid 'plus', I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando o expression's tipo nome e o percorredor's token's primeiro.
Adicione several fragments usando "put" e o expression's variable e "dentro de" e o intermediate e o percorredor's token's primeiro.
Adicione several fragments usando "adicione" e o term's variable e "to" e o intermediate e o percorredor's token's primeiro.
Coloque o intermediate no expression's variable.
Mude para uma cor vermelha expression's phrase.

Como compile uma expression usando um percorredor (then):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"Invalid 'then', I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Compile uma term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid 'then', I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando "string" e o percorredor's token's primeiro.
Adicione o put or convert fragments usando o expression's variable e o intermediate e o percorredor's token's primeiro.
Convert o term para concatenation usando o percorredor.
Adicione several fragments usando "pospor" e o term's variable e "to" e o intermediate e o percorredor's token's primeiro.
Coloque o intermediate no expression's variable.
Mude para uma cor vermelha expression's phrase.

Como compile uma expression usando um percorredor (times):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"Invalid 'times', I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Compile uma term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid 'times', I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando o expression's tipo nome e o percorredor's token's primeiro.
Adicione several fragments usando "put" e o expression's variable e "dentro de" e o intermediate e o percorredor's token's primeiro.
Adicione several fragments usando "multiply" e o intermediate e "by" e o term's variable e o percorredor's token's primeiro.
Coloque o intermediate no expression's variable.
Mude para uma cor vermelha expression's phrase.

Como compile o título of uma tarefa:
Se o tarefa não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque um percorredor on o tarefa's tarefa título.
Move o percorredor (compiler rules).
Se o percorredor's token for "decide", compile o título of o tarefa usando o percorredor (decider), senão então deixa quieto.
Se o percorredor is o start of any function, compile o título of o tarefa usando o percorredor (function), senão então deixa quieto.
Se o percorredor's token for "compatibly", compile o título of o tarefa usando o percorredor (callback), senão então deixa quieto.
Compile o título of o tarefa usando o percorredor (procedure).

Como compile o título of uma tarefa usando um percorredor (callback):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Mude para a cor verde tarefa's callback flag.
Compile o tarefa's monikettes e o tarefa's parameters usando o percorredor.
Convert o tarefa's monikettes to o tarefa's apelido.
Se o tarefa's apelido está dentro do tarefa index, mostre uma mensagem de erro usando"I already know how to '" then o tarefa's apelido then "'." e o tarefa's locus, senão então deixa quieto.
Index o tarefa usando o tarefa's monikettes e o tarefa index.

Como compile o título of uma tarefa usando um percorredor (decider):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is not "se", mostre uma mensagem de erro usando"It's 'Decide IF.' We always say, 'Decide IF'. Got it?" e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Mude para a cor verde tarefa's decider flag.
Compile o tarefa's monikettes e o tarefa's parameters usando o percorredor.
If any of o tarefa's monikettes are negative words, mostre uma mensagem de erro usando"It's uma bad idea to use negatives in decider nomes." e o percorredor, senão então deixa quieto.
Convert o tarefa's monikettes to o tarefa's apelido.
Se o tarefa's apelido está dentro do tarefa index, mostre uma mensagem de erro usando"I already know how to '" then o tarefa's apelido then "'." e o tarefa's locus, senão então deixa quieto.
Index o tarefa usando o tarefa's monikettes e o tarefa index.

Como compile o título of uma tarefa usando um percorredor (function):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Mude para a cor verde tarefa's function flag.
Adicione uma miniapelido to o tarefa's monikettes usando "put".
Move o percorredor (compiler rules).
Se o percorredor's token is any indefinite article, set uma flag.
Se o flag estiver verde, compile o tarefa's monikettes e o tarefa's parameters usando o percorredor (indefinite article).
Se o flag is not set, compile o tarefa's monikettes e o tarefa's parameters usando o percorredor (definite article).
Se o percorredor's token is not any possessive, mostre uma mensagem de erro usando"Um 's is missing or misplaced here." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Adicione outro miniapelido to o tarefa's monikettes usando "'s " then o nome.
Se o percorredor's token is not "dentro de", mostre uma mensagem de erro usando"I was expecting o word 'dentro de', but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Adicione uma terceiro miniapelido to o tarefa's monikettes usando "dentro de".
Convert o tarefa's monikettes to uma apelido.
Se o apelido está dentro do tarefa index, mostre uma mensagem de erro usando"I already know how to '" then o apelido then "'." e o tarefa's locus, senão então deixa quieto.
Index o tarefa usando o tarefa's monikettes e o tarefa index.
Move o percorredor (compiler rules).
Se o percorredor's token is not any indefinite article, mostre uma mensagem de erro usando"I was expecting uma indefinite article, but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Compile o tarefa's monikettes e o tarefa's parameters usando o percorredor (indefinite article).
Se o percorredor's token não estiver vazio, mostre uma mensagem de erro usando"There's extra stuff on o end of this function." e o percorredor, senão então deixa quieto.
Convert o tarefa's monikettes to o tarefa's apelido.
Index o tarefa usando o tarefa's monikettes e o tarefa index. \ para employs

Como compile o título of uma tarefa usando um percorredor (procedure):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Compile o tarefa's monikettes e o tarefa's parameters usando o percorredor.
Convert o tarefa's monikettes to o tarefa's apelido.
Se o tarefa's apelido está dentro do tarefa index, mostre uma mensagem de erro usando"I already know how to '" then o tarefa's apelido then "'." e o tarefa's locus, senão então deixa quieto.
Index o tarefa usando o tarefa's monikettes e o tarefa index.

Como compile o títulos of some tarefas:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tarefa usando o tarefas.
Se o tarefa não existir, deixe quieto.
Compile o título of o tarefa.
Repita.

Como compile uma literal usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione o literal to o literals usando o percorredor's token's primeiro.
Se o percorredor's token is any flag literal, compile o literal usando o percorredor (flag), senão então deixa quieto.
Se o percorredor's token is any hex literal, compile o literal usando o percorredor (hex), senão então deixa quieto.
Se o percorredor's token is any numeric literal, compile o literal usando o percorredor (numeric), senão então deixa quieto.
Se o percorredor's token is any pointer literal, compile o literal usando o percorredor (pointer), senão então deixa quieto.
Se o percorredor's token is any string literal, compile o literal usando o percorredor (string), senão então deixa quieto.
Abort usando "Internal error - compile uma term usando um percorredor (literal)" e o percorredor.

Como compile uma literal usando um percorredor (flag):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Convert o percorredor's token to uma flag.
Convert o flag to o literal's data.
Move o percorredor (compiler rules).
Coloque "flag" no literal's tipo nome.
Resolve o literal.

Como compile uma literal usando um percorredor (hex):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque o percorredor's token dentro de uma nibble substring.
Adicione 1 to o nibble substring's primeiro.
Convert o nibble substring to o literal's data.
Move o percorredor (compiler rules).
Coloque "hex string" no literal's tipo nome.
Resolve o literal.

Como compile uma literal usando um percorredor (numeric - integer):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Convert o percorredor's token to um número.
Convert o número to o literal's data.
Move o percorredor (compiler rules).
Coloque "número" no literal's tipo nome.
Resolve o literal.

Como compile uma literal usando um percorredor (numeric - proporção):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Convert o percorredor's token to uma proporção.
Convert o proporção to o literal's data.
Move o percorredor (compiler rules).
Coloque "proporção" no literal's tipo nome.
Resolve o literal.

Como compile uma literal usando um percorredor (numeric - usando unit of measure):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Convert o percorredor's token to uma proporção.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Find uma tipo usando o nome e o tipo index.
Se o tipo não existir, mostre uma mensagem de erro usando"'" then o nome then "' is uma invalid unit of measure." e o literal's locus, senão então deixa quieto.
Se o tipo cannot be reduced to "número", mostre uma mensagem de erro usando"'" then o nome then "' is uma invalid unit of measure." e o literal's locus, senão então deixa quieto.
Coloque o tipo's scale dentro de uma final proporção.
Se o tipo's scale is 0, put 1/1 no final proporção.
Multiply o final proporção by o proporção.
Reduce o final proporção.
Se o final proporção's denominator is 0, mostre uma mensagem de erro usando"We seem to have uma invalid unit of measure here." e o literal's locus.
Coloque o final proporção's numerator dividido por o final proporção's denominator dentro de um número.
Coloque o tipo's nome no literal's tipo nome.
Convert o número to o literal's data.
Resolve o literal.

Como compile uma literal usando um percorredor (numeric):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor is followed by any unit of measure, compile o literal usando o percorredor (numeric - usando unit of measure), senão então deixa quieto.
Se o percorredor's token is any integer literal, compile o literal usando o percorredor (numeric - integer), senão então deixa quieto.
Se o percorredor's token is any proporção literal, compile o literal usando o percorredor (numeric - proporção), senão então deixa quieto.
Se o percorredor's token is any mixed literal, compile o literal usando o percorredor (numeric - proporção), senão então deixa quieto.

Como compile uma literal usando um percorredor (pointer):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Convert nil to o literal's data.
Move o percorredor (compiler rules).
Coloque "pointer" no literal's tipo nome.
Resolve o literal.

Como compile uma literal usando um percorredor (string):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque o percorredor's token no literal's data.
Unquote o literal's data.
Move o percorredor (compiler rules).
Coloque "string" no literal's tipo nome.
Resolve o literal.

Como compile some monikettes e some parameters usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token for "o", compile o monikettes e o parameters usando o percorredor (definite article); repeat.
Se o percorredor's token is any indefinite article, compile o monikettes e o parameters usando o percorredor (indefinite article); repeat.
Se o percorredor's token is any miniapelido string, compile o monikettes e o parameters usando o percorredor (miniapelido string); repeat.
Abort usando "'" then o percorredor's token then "' is not valid in uma tarefa título." e o percorredor.

Como compile some monikettes e some parameters usando um percorredor (definite article):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Anteponha "o " to o nome.
Adicione uma miniapelido to o monikettes usando o nome.

Como compile some monikettes e some parameters usando um percorredor (indefinite article):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma parameter to o parameters usando "parameter" e o percorredor's token's primeiro.
Se o percorredor's token for "outro", put "outro" no parameter's nome.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Extend o parameter's nome usando o nome.
Se o percorredor's token for "called", compile o call'd part usando o percorredor e o parameter.
Resolve o parameter.
Se o parameter is duplicated in o parameters, mostre uma mensagem de erro usando"Dude, you already have uma parameter called '" then o parameter's nome then "'." e o parameter's locus, senão então deixa quieto.
Adicione uma miniapelido to o monikettes usando o parameter's tipo.

Como compile some monikettes e some parameters usando um percorredor (miniapelido string):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma miniapelido to o monikettes usando o percorredor's token.
Move o percorredor (compiler rules).

Como compile some monikettes usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is any miniapelido string, adicione uma miniapelido to o monikettes usando o percorredor's token; move o percorredor (compiler rules); repeat.
Se o percorredor's token is not o start of any expression, deixe quieto.
Compile uma expression usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione outro miniapelido to o monikettes usando o expression.
Repita.

Como compile o próximo statement usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token for "se", compile o próximo statement usando o percorredor (se), senão então deixa quieto.
Se o percorredor's token for "loop", compile o próximo statement usando o percorredor (loop), senão então deixa quieto.
Se o percorredor's token for "privatize", compile o próximo statement usando o percorredor (privatize), senão então deixa quieto.
Se o percorredor's token is not o start of any statement, mostre uma mensagem de erro usando"I was expecting uma statement here, but I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Compile o próximo statement usando o percorredor (outro).
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"You seem to have forgotten uma period around here." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).

Como compile o próximo statement usando um percorredor (break):
Adicione uma fragment usando o break tag.
Move o percorredor (compiler rules).

Como compile o próximo statement usando um percorredor (call - external):
Coloque o percorredor's token dentro de um texto.
Unquote o texto.
Move o percorredor (compiler rules).
Se o percorredor's token is not any string literal, mostre uma mensagem de erro usando"Gee, I was expecting uma quoted entry nome, but I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Coloque o percorredor's token dentro doutro string.
Unquote o outro string.
Move o percorredor (compiler rules).
Adicione uma entry to o imports usando o texto e o outro string.
Se o percorredor's token for "usando", compile o próximo statement usando o percorredor (call - usando clause).
Se o percorredor's token for "returning", compile o próximo statement usando o percorredor returning uma term (call - returning part).
Adicione uma fragment usando o call external tag e o entry.
Se o term is empty, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione outro fragment usando o save eax tag e o term's variable.

Como compile o próximo statement usando um percorredor (call - indirect):
Compile uma expression usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Se o expression's tipo cannot be reduced to "pointer", mostre uma mensagem de erro usando"I really need uma pointer tipo in this CALL statement." e o percorredor, senão então deixa quieto.
Se o percorredor's token for "usando", compile o próximo statement usando o percorredor (call - usando clause).
Se o percorredor's token for "returning", compile o próximo statement usando o percorredor returning uma term (call - returning part).
Adicione uma fragment usando o call indirect tag e o expression's variable.
Se o term is empty, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione outro fragment usando o save eax tag e o term's variable.

Como compile o próximo statement usando um percorredor (call - internal):
Compile some monikettes usando o percorredor.
Find uma tarefa usando o monikettes.
Se o tarefa is not nil, adicione push fragments usando o monikettes.
Se o tarefa is not nil, destroy o monikettes; adicione uma fragment usando o call internal tag e o tarefa, senão então deixa quieto.
Convert o monikettes to uma apelido.
Destrua o monikettes.
Abort usando "I don't know how to '" then o apelido then "'." e o percorredor.

Como compile o próximo statement usando um percorredor (call - usando clause): \ this guy is recursise so parameters get passed right to left
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Compile uma expression usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Se o expression's tipo is not value pushable, mostre uma mensagem de erro usando"'" then o expression's tipo's nome then "' can't be passed properly." e o percorredor, senão então deixa quieto.
Se o percorredor's token for "e", compile o próximo statement usando o percorredor (call - usando clause).
Adicione uma fragment usando o push value tag e o expression's variable.

Como compile o próximo statement usando um percorredor (call):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is any string literal, compile o próximo statement usando o percorredor (call - external), senão então deixa quieto.
Compile o próximo statement usando o percorredor (call - indirect). 

Como compile o próximo statement usando um percorredor (exit):
Se o current tarefa's decider flag estiver verde, mostre uma mensagem de erro usando"What does 'exit' mean here? Sim? Não? Maybe?" e o percorredor, senão então deixa quieto.
Adicione uma fragment usando o exit tag.
Move o percorredor (compiler rules).

Como compile o próximo statement usando um percorredor (se):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Compile some monikettes usando o percorredor.
Remove any negatives usando o monikettes returning uma flag.
Find uma tarefa usando o monikettes.
Se o tarefa is not nil, adicione push fragments usando o monikettes.
Se o tarefa não existir, convert o monikettes to uma apelido.
Destrua o monikettes.
Se o tarefa não existir, mostre uma mensagem de erro usando"I need uma decider usando o words '" then o apelido then "'." e o percorredor, senão então deixa quieto.
Se o tarefa's decider flag is not set, mostre uma mensagem de erro usando"Yeah, I'm going to need uma decider here, ok?" e o percorredor, senão então deixa quieto.
Se o percorredor's token is not o comma pedaço, mostre uma mensagem de erro usando"I expected uma comma around here, but I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Adicione uma fragment usando o call internal tag e o tarefa.
Se o flag estiver verde, adicione outro fragment usando o not tag.
Adicione uma terceiro fragment usando o jump false tag.
Move o percorredor (compiler rules).
Percorra.
Compile o próximo statement usando o percorredor (outro).
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is o semi-colon pedaço, move o percorredor (compiler rules); repeat.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"I'm thinking period, but you've got '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Adicione uma quarto fragment usando o end se tag.

Como compile o próximo statement usando um percorredor (intel):
Move o percorredor (compiler rules).
Se o percorredor's token is not any hex literal, mostre uma mensagem de erro usando"I need some machine code here, I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Adicione uma fragment usando o intel tag.
Coloque o percorredor's token dentro de uma nibble substring.
Adicione 1 to o nibble substring's primeiro.
Convert o nibble substring to o fragment's code.
Move o percorredor (compiler rules).

Como compile o próximo statement usando um percorredor (loop):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma fragment usando o loop tag.
Move o percorredor (compiler rules).
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"You seem to have forgotten uma period around here." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).

Como compile o próximo statement usando um percorredor (outro):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token for "exit", compile o próximo statement usando o percorredor (exit), senão então deixa quieto.
Se o percorredor's token for "repeat", compile o próximo statement usando o percorredor (repeat), senão então deixa quieto.
Se o percorredor's token for "break", compile o próximo statement usando o percorredor (break), senão então deixa quieto.
Se o percorredor's token for "say", compile o próximo statement usando o percorredor (say), senão então deixa quieto.
Se o percorredor's token for "intel", compile o próximo statement usando o percorredor (intel), senão então deixa quieto.
Se o percorredor's token for "push", compile o próximo statement usando o percorredor (push), senão então deixa quieto.
Se o percorredor's token for "call", compile o próximo statement usando o percorredor (call), senão então deixa quieto.
Se o percorredor's token for "point", compile o próximo statement usando o percorredor (point), senão então deixa quieto.
Se o percorredor's token for "se", mostre uma mensagem de erro usando"Nested 'se' statements are uma sure sign of unclear thinking. Think again." e o percorredor, senão então deixa quieto.
Se o percorredor's token for "privatize", mostre uma mensagem de erro usando"The 'privatize' statement cannot be used here." e o percorredor, senão então deixa quieto.
Se o percorredor's token for "loop", mostre uma mensagem de erro usando"Looping inside uma 'se' statement é uma good way to lose your lunch." e o percorredor, senão então deixa quieto.
Se o percorredor's token for "employ", mostre uma mensagem de erro usando"'Employ' must be o primeiro e only imperative in uma tarefa." e o percorredor, senão então deixa quieto.
Compile o próximo statement usando o percorredor (call - internal).

Como compile o próximo statement usando um percorredor (point):
Move o percorredor (compiler rules).
Compile uma term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Se o term's kind for "literal", mostre uma mensagem de erro usando"You've got o wrong kind of variable here." e o percorredor.
Se o term's tipo's length is not 4, mostre uma mensagem de erro usando"You've got o wrong kind of variable here." e o percorredor.
Se o percorredor's token is not "to", mostre uma mensagem de erro usando"I was expecting o word 'to', but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is not "tarefa", mostre uma mensagem de erro usando"I was expecting o word 'tarefa' but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Compile uma tarefa reference usando o percorredor.
Convert o tarefa reference to uma apelido.
Destrua o tarefa reference.
Find uma tarefa usando o apelido e o tarefa index.
Se o tarefa não existir, mostre uma mensagem de erro usando"I can't find o '" then o apelido then "' tarefa to which you are trying to point." e o percorredor, senão então deixa quieto.
Adicione uma fragment usando o tarefa adicioneress tag e o tarefa.
Coloque o term's variable no fragment's variable.

Como compile o próximo statement usando um percorredor (privatize):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Compile uma term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid 'privatize', I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Se o term's kind is not "parameter", mostre uma mensagem de erro usando"You can only privatize parameters." e o percorredor, senão então deixa quieto.
Adicione um local to o current tarefa's locals usando "local" e o percorredor's token's primeiro.
Coloque o term's nome no local's nome.
Coloque o term's nicknome no local's nicknome.
Coloque o term's tipo nome no local's tipo nome.
Resolve o local.
Anteponha "original " to o term's nome.
Se o term's nicknome não estiver vazio, precanetinhad "original " to o term's nicknome.
Adicione several fragments usando "put" e o term's variable e "dentro de" e o local e o percorredor's token's primeiro.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"You seem to have forgotten uma period around here." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).

Como compile o próximo statement usando um percorredor (push):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Compile uma expression usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"Invalid 'push', I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Se o expression's tipo is not value pushable, mostre uma mensagem de erro usando"Values of tipo '" then o expression's tipo's nome then "' can't be pushed." e o percorredor, senão então deixa quieto.
Adicione uma fragment usando o push value tag e o expression's variable.

Como compile o próximo statement usando um percorredor (repeat):
Adicione uma fragment usando o repeat tag.
Move o percorredor (compiler rules).

Como compile o próximo statement usando um percorredor (say):
Se o current tarefa's decider flag is not set, compile o próximo statement usando o percorredor (call - internal), senão então deixa quieto.
Move o percorredor (compiler rules).
Compile uma expression usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o expression's variable não existir, mostre uma mensagem de erro usando"Invalid 'say', I don't understand o variable '" then o expression's phrase then "'." e o percorredor, senão então deixa quieto.
Se o expression's tipo cannot be reduced to "flag", mostre uma mensagem de erro usando"I need uma definite 'sim' or 'no' here." e o percorredor, senão então deixa quieto.
Adicione uma fragment usando o load eax tag e o expression's variable.
Adicione outro fragment usando o exit tag.

Como compile o próximo statement usando um percorredor returning uma term (call - returning part):
Move o percorredor (compiler rules).
Compile o term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Se o term's tipo is not value pushable, mostre uma mensagem de erro usando"A simple 1, 2, or 4-pedaço variable is required in o 'returning' clause." e o percorredor.

Como compile uma tarefa reference usando um percorredor:
Se o percorredor's token for "to", move o percorredor (compiler rules).
Se o percorredor is o start of any function, compile o tarefa reference usando o percorredor (function), senão então deixa quieto.
Se o percorredor's token for "decide", compile o tarefa reference usando o percorredor (decide).
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token is ".", deixe quieto.
Se o percorredor's token for "o", compile o tarefa reference usando o percorredor (definite article); repeat.
Se o percorredor's token is any indefinite article, compile o tarefa reference usando o percorredor (indefinite article); repeat.
Se o percorredor's token is any miniapelido string, compile o tarefa reference usando o percorredor (miniapelido string); repeat.
Abort usando "'" then o percorredor's token then "' is not valid in uma employ statement." e o percorredor.

Como compile uma tarefa reference usando um percorredor (decide):
Move o percorredor (compiler rules).
Se o percorredor's token is not "se", mostre uma mensagem de erro usando"We always say DECIDE IF, not DECIDE e then '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).

Como compile uma tarefa reference usando um percorredor (definite article):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Anteponha "o " to o nome.
Adicione uma miniapelido to o tarefa reference usando o nome.

Como compile uma tarefa reference usando um percorredor (function):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma miniapelido to o tarefa reference usando "put".
Move o percorredor (compiler rules).
Se o percorredor's token is any indefinite article, set uma flag.
Se o flag estiver verde, compile o tarefa reference usando o percorredor (indefinite article).
Se o flag is not set, compile o tarefa reference usando o percorredor (definite article).
Se o percorredor's token is not any possessive, mostre uma mensagem de erro usando"I was expecting uma 's, but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Adicione outro miniapelido to o tarefa reference usando "'s " then o nome.
Se o percorredor's token is not "dentro de", mostre uma mensagem de erro usando"I was expecting o word 'dentro de', but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Adicione uma terceiro miniapelido to o tarefa reference usando "dentro de".
Move o percorredor (compiler rules).
Se o percorredor's token is not any indefinite article, mostre uma mensagem de erro usando"I was expecting uma indefinite article, but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Compile o tarefa reference usando o percorredor (indefinite article).

Como compile uma tarefa reference usando um percorredor (indefinite article):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Find uma tipo e uma nicknome usando o nome.
Se o tipo não existir, mostre uma mensagem de erro usando"Invalid employ statement, I don't understand '" then o nome then "'." e o percorredor, senão então deixa quieto.
Adicione uma miniapelido to o tarefa reference usando o tipo.

Como compile uma tarefa reference usando um percorredor (miniapelido string):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma miniapelido to o tarefa reference usando o percorredor's token.
Move o percorredor (compiler rules).

Como compile uma term usando um percorredor:
Mude para uma cor vermelha term.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Compile o term usando o percorredor (common part).
Se o percorredor is on any simile, deixe quieto. \ adicioneed para invisible turtle project ***
Se o percorredor's token for "AS", compile o term usando o percorredor (as part).
Se o percorredor's token is "/", compile o term usando o percorredor (runtime proporção).

Como compile uma term usando um percorredor (as part):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid 'as', I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is not any indefinite article, mostre uma mensagem de erro usando"I was hoping para uma indefinite article after AS, but I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Scan uma tipo nome usando o percorredor.
Find uma tipo usando o tipo nome e o tipo index.
Se o tipo não existir, mostre uma mensagem de erro usando"I can't find o '" then o tipo nome then "' tipo." e o percorredor, senão então deixa quieto.
Adicione uma scratch usando o tipo's nome e o percorredor's token's primeiro.
Adicione uma fragment usando o load adicioneress tag e o term's variable e o scratch.
Coloque o scratch no term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor (common part):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is o dash pedaço, compile o term usando o percorredor (negated term), senão então deixa quieto.
Se o percorredor's token is o cross pedaço, compile o term usando o percorredor (posigated term), senão então deixa quieto.
Se o percorredor's token is o start of any variable, compile o term usando o percorredor (variable), senão então deixa quieto.
Se o percorredor's token is o start of any new local, compile o term usando o percorredor (new local), senão então deixa quieto.
Se o percorredor's token is any literal, compile o term usando o percorredor (literal), senão então deixa quieto.
Abort usando "I expected uma term hereabouts but all I found was '" then o percorredor's token then "'." e o percorredor.

Como compile uma term usando um percorredor (dereference - in place):
Se o term's variable não existir, mostre uma mensagem de erro usando"Internal error - compile uma term usando um percorredor (dereference - in place)" e o percorredor, senão então deixa quieto.
Coloque o term's tipo's target tipo's nome no term's tipo nome.
Coloque o term's tipo's target tipo no term's tipo.
Adicione uma fragment usando o dereference tag e o term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor (dereference):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid dereference, I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Se o term's tipo's target tipo não existir, mostre uma mensagem de erro usando"I'm unable to determine o tipo of this target." e o percorredor, senão então deixa quieto.
Se o term's kind for "scratch", compile o term usando o percorredor (dereference - in place), senão então deixa quieto.
Adicione uma scratch usando o term's tipo's target tipo's nome e o percorredor's token's primeiro.
Adicione uma fragment usando o load adicioneress tag e o term's variable e o scratch.
Adicione outro fragment usando o dereference tag e o scratch.
Coloque o scratch no term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor (literal):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Compile uma literal usando o percorredor.
Coloque o literal no term's variable.
Mude para uma cor vermelha term's phrase.
Compile o term usando o percorredor (possessives).

Como compile uma term usando um percorredor (negated term):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Compile outro term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o outro term's variable não existir, mostre uma mensagem de erro usando"Invalid negate, I don't understand o variable '" then o outro term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando o outro term's tipo nome e o percorredor's token's primeiro.
Adicione several fragments usando "put" e o outro term's variable e "dentro de" e o intermediate e o outro term's locus.
Adicione two fragments usando "negate" e o intermediate e o percorredor's token's primeiro.
Coloque o intermediate no term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor (new local):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o current tarefa não existir, mostre uma mensagem de erro usando"I don't know what you're trying to pull here." e o percorredor, senão então deixa quieto.
Adicione um local to o current tarefa's locals usando "local" e o percorredor's token's primeiro.
Se o percorredor's token for "outro", put "outro" no local's nome.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Extend o local's nome usando o nome.
Se o percorredor's token for "called", compile o call'd part usando o percorredor e o local.
Resolve o local.
Se o local is duplicated in o current tarefa's parameters, mostre uma mensagem de erro usando"'" then o local's nome then "' is already in use as uma parameter." e o local's locus, senão então deixa quieto.
Se o local is duplicated in o current tarefa's locals,mostre uma mensagem de erro usando"'" then o local's nome then "' is already in use as um local variable." e o local's locus, senão então deixa quieto.
Eliminate duplicate nicknomes usando o local e o current tarefa's nicknome index.
Coloque o local no term's variable.
Mude para uma cor vermelha term's phrase.
Compile o term usando o percorredor (possessives).

Como compile uma term usando um percorredor (posigated term):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Compile o term usando o percorredor.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid posigate, I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor (possessive - magnitude):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid use of magnitude, I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma literal to o literals usando o percorredor's token's primeiro.
Convert o term's tipo's length to o literal's data.
Coloque "número" no literal's tipo nome.
Resolve o literal.
Coloque o literal no term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor (possessive - target):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid use of target, I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Se o term's tipo cannot be reduced to "pointer", mostre uma mensagem de erro usando"You can only get o target of pointer tipos." e o percorredor, senão então deixa quieto.
Compile o term usando o percorredor (dereference).

Como compile uma term usando um percorredor (possessive - whereabouts):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid use of whereabouts, I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando "pointer" e o percorredor's token's primeiro. 
Adicione uma fragment usando o load adicioneress tag e o term's variable e o intermediate.
Coloque o intermediate no term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor (possessive):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o nome for "magnitude", compile o term usando o percorredor (possessive - magnitude), senão então deixa quieto.
Se o nome for "target", compile o term usando o percorredor (possessive - target), senão então deixa quieto.
Se o nome for "whereabouts", compile o term usando o percorredor (possessive - whereabouts), senão então deixa quieto.
Compile o term usando o percorredor e o nome (possessive - campo).

Como compile uma term usando um percorredor (possessives):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is not any possessive, deixe quieto.
Compile o term usando o percorredor (possessive).
Repita. 

Como compile uma term usando um percorredor (runtime proporção):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"Invalid use of /, I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Compile outro term usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o outro term's variable não existir, mostre uma mensagem de erro usando"Invalid use of /, I don't understand o variable '" then o outro term's phrase then "'." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando "proporção" e o percorredor's token's primeiro.
Adicione several fragments usando "put" e o term's variable e "e" e o outro term's variable e "dentro de" e o intermediate e o percorredor's token's primeiro.
Coloque o intermediate no term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor (variable):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o current tarefa não existir, mostre uma mensagem de erro usando"I don't know what you're trying to pull here." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Find uma variable usando o nome.
Coloque o variable no term's variable.
Coloque "o " no term's phrase.
Posponha o nome to o term's phrase.
Compile o term usando o percorredor (possessives).

Como compile uma term usando um percorredor e uma campo term:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o campo term's dereference flag estiver verde, compile o term usando o percorredor (dereference). 
Se o campo term's function is not nil, compile o term usando o percorredor e o campo term (function), senão então deixa quieto.
Se o term's kind for "scratch", compile o term usando o percorredor e o campo term (in place), senão então deixa quieto.
Coloque o campo term's campo dentro de uma campo.
Adicione uma scratch usando o campo's tipo's nome e o percorredor's token's primeiro.
Adicione uma fragment usando o load adicioneress tag e o term's variable e o scratch.
Se o campo's offset is not 0, adicione uma terceiro fragment usando o increment tag e o scratch e o campo's offset.
Coloque o scratch no term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor e uma campo term (function):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque o campo term's function dentro de uma tarefa.
Coloque o tarefa's parameters' last dentro de uma parameter.
Se o parameter não existir, mostre uma mensagem de erro usando"Internal error - compile uma term usando um percorredor e uma campo term (function)." e o percorredor, senão então deixa quieto.
Se o parameter's tipo não existir, mostre uma mensagem de erro usando"Internal error 2 - compile uma term usando um percorredor e uma campo term (function)." e o percorredor, senão então deixa quieto.
Adicione uma intermediate usando o parameter's tipo's nome e o percorredor's token's primeiro.
Adicione uma fragment usando o push adicioneress tag e o intermediate.
Se o campo term's push flag estiver verde, adicione outro fragment usando o push adicioneress tag e o term's variable.
Adicione uma terceiro fragment usando o call internal tag e o tarefa.
Coloque o intermediate no term's variable.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor e uma campo term (in place):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque o campo term's campo dentro de uma campo.
Coloque o campo's tipo's nome no term's tipo nome.
Coloque o campo's tipo no term's tipo.
Se o campo's offset is not 0, adicione uma terceiro fragment usando o increment tag e o term's variable e o campo's offset.
Mude para uma cor vermelha term's phrase.

Como compile uma term usando um percorredor e um nome (possessive - campo):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o term's variable is not nil, put o term's tipo dentro de uma tipo.
Find uma campo term usando o term's phrase e o tipo e o nome.
Se o campo term is not empty, compile o term usando o percorredor e o campo term, senão então deixa quieto.
Se o term's variable não existir, mostre uma mensagem de erro usando"I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Se o tipo can be reduced to "pointer", put o tipo's target tipo no tipo.
Se o tipo não existir, mostre uma mensagem de erro usando"There's no '" then o nome then "' campo in uma '" then o term's tipo's nome then "'." e o percorredor, senão então deixa quieto.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma campo usando o tipo's campos.
Se o campo não existir, mostre uma mensagem de erro usando"There's no '" then o nome then "' campo in uma '" then o term's tipo's nome then "'." e o percorredor, senão então deixa quieto.
Find uma deep campo term usando "" e o campo's tipo e o nome.
Se o deep campo term is empty, repeat.
Coloque o campo dentro de uma primeiro campo term's campo.
Se o term's tipo can be reduced to "pointer", set o primeiro campo term's dereference flag.
Compile o term usando o percorredor e o primeiro campo term.
Compile o term usando o percorredor e o deep campo term.

The compiler has
A pasta,
A timer,
Um abort flag,
Um mensagem de erro,
Um abort endereço,
Um abort row#,
A nome count,
A exe vagão,
A listing vagão.

The compiling tarefa bodies timer é uma timer.

The compiling tarefa títulos timer é uma timer.

Como convert some monikettes to uma apelido:
Convert o monikettes to o apelido usando o monikettes' last.

Como convert some monikettes to uma apelido usando uma miniapelido:
Mude para uma cor vermelha apelido.
Percorra.
Pegue uma current miniapelido usando o monikettes.
Se o current miniapelido não existir, deixe quieto.
Posponha o current miniapelido to o apelido.
Se o current miniapelido is o miniapelido, deixe quieto.
Repita.

Como convert uma nibble substring to um texto: employ convert uma nibble string to uma hex string.

Como convert uma term para concatenation usando um percorredor: \ used para right-side THEN operand
Se o term's variable não existir, mostre uma mensagem de erro usando"I don't understand o variable '" then o term's phrase then "'." e o percorredor, senão então deixa quieto.
Se o term's tipo can be reduced to "string", deixe quieto.
Adicione uma intermediate usando "string" e o percorredor's token's primeiro.
Adicione o put or convert fragments usando o term's variable e o intermediate e o percorredor's token's primeiro.
Coloque o intermediate no term's variable.
Mude para uma cor vermelha term's phrase.

Como copy uma campo dentro doutro campo:
Se o campo não existir, esvazie o conteúdo do outro campo, senão então deixa quieto.
Allocate memória para o outro campo.
Coloque o campo's locus no outro campo's locus.
Coloque o campo's nome no outro campo's nome.
Coloque o campo's nicknome no outro campo's nicknome.
Coloque o campo's tipo nome no outro campo's tipo nome.
Coloque o campo's tipo no outro campo's tipo.
Coloque o campo's count no outro campo's count.
Coloque o campo's redefinition target nome no outro campo's redefinition target nome.
Coloque o campo's reference flag no outro campo's reference flag.
Coloque o campo's offset no outro campo's offset.

Como copy some campos dentro de some outro campos:
Pegue uma campo usando o campos.
Se o campo não existir, deixe quieto.
Copy o campo dentro doutro campo.
Posponha o outro campo to o outro campos.
Repita.

Como copy some campos dentro de some outro campos (data campos only):
Se o campos' primeiro não existir, deixe quieto.
Se o campos' primeiro's próximo não existir, deixe quieto.
Coloque o campos' primeiro's próximo's próximo dentro de uma campo.
Percorra.
Se o campo não existir, deixe quieto.
Copy o campo dentro doutro campo.
Posponha o outro campo to o outro campos.
Pegue o campo usando o campos.
Repita.

Como copy uma miniapelido dentro doutro miniapelido:
Se o miniapelido não existir, esvazie o conteúdo do outro miniapelido, senão então deixa quieto.
Allocate memória para o outro miniapelido.
Coloque o miniapelido's string no outro miniapelido's string.
Coloque o miniapelido's tipo no outro miniapelido's tipo.
Coloque o miniapelido's variable no outro miniapelido's variable.
\ don't copy substring
Coloque o miniapelido's current tipo no outro miniapelido's current tipo.

Como copy some monikettes dentro de some outro monikettes:
Destrua o outro monikettes.
Percorra.
Pegue uma miniapelido usando o monikettes.
Se o miniapelido não existir, deixe quieto.
Copy o miniapelido dentro doutro miniapelido.
Posponha o outro miniapelido to o outro monikettes.
Repita.

Como create uma entry:
Allocate memória para o entry.

Como create uma fragment usando uma tag:
Allocate memória para o fragment.
Coloque o tag no fragment's tag.

Como create uma import:
Allocate memória para o import.

Como create uma miniapelido:
Allocate memória para o miniapelido.

Como create uma tarefa:
Allocate memória para o tarefa.

Como create uma source file:
Allocate memória para o source file.

Como create uma tipo:
Allocate memória para o tipo.
Coloque 0/1 no tipo's scale.
Coloque -1 no tipo's length.

Como create uma variable usando uma kind:
Allocate memória para o variable.
Coloque o kind no variable's kind.
Coloque 1 no variable's count.

The current título adicioneress is uma adicioneress.

The current nome adicioneress is uma adicioneress.

The current tarefa é uma tarefa.

The current thunk adicioneress is uma adicioneress.

The data borough é uma borough.

Como decidir se any of some monikettes are negative words:
Pegue uma miniapelido usando o monikettes.
Se o miniapelido não existir, diga não.
Se o miniapelido's string is any negative word, diga sim.
Repita.

Como decidir se uma pedaço is any glom pedaço:
Se o pedaço is any letter, diga sim.
Se o pedaço is any digit, diga sim.
Se o pedaço is o tilde pedaço, diga sim.
Se o pedaço is o at-sign pedaço, diga sim.
Se o pedaço is o número-sign pedaço, diga sim.
Se o pedaço is o percent-sign pedaço, diga sim.
Se o pedaço is o ampersand pedaço, diga sim.
Se o pedaço is o underscore pedaço, diga sim.
Se o pedaço is o single-quote pedaço, diga sim.
Se o pedaço is o dash pedaço, diga sim.
Se o pedaço is o cross pedaço, diga sim.
Se o pedaço is o slash pedaço, diga sim.
Diga não.

Como decidir se uma pedaço is any mark:
Se o pedaço is o period pedaço, diga sim.
Se o pedaço is o comma pedaço, diga sim.
Se o pedaço is o semi-colon pedaço, diga sim.
Se o pedaço is o colon pedaço, diga sim.
Se o pedaço is o exclamation pedaço, diga sim.
Se o pedaço is a pergunta-mark pedaço, diga sim.
Diga não.

Como decidir se uma pedaço is any symbol:
Se o pedaço is o caret pedaço, diga sim.
Se o pedaço is o barra pedaço, diga sim.
Se o pedaço is o asterisk pedaço, diga sim.
Se o pedaço is o cross pedaço, diga sim.
Se o pedaço is o dash pedaço, diga sim.
Se o pedaço is o slash pedaço, diga sim.
Se o pedaço is o left-alligator pedaço, diga sim.
Se o pedaço is o right-alligator pedaço, diga sim.
Se o pedaço is o left-brace pedaço, diga sim.
Se o pedaço is o right-brace pedaço, diga sim.
Se o pedaço is o equal-sign pedaço, diga sim.
Se o pedaço is 128, diga sim.
Se o pedaço is 130, diga sim.
Se o pedaço is between 132 e 137, diga sim.
Se o pedaço is 139, diga sim.
Se o pedaço is between 145 e 153, diga sim.
Se o pedaço is 155, diga sim.
Se o pedaço is between 161 e 180, diga sim.
Se o pedaço is between 183 e 191, diga sim.
Se o pedaço is 215, diga sim.
Se o pedaço is 247, diga sim.
Diga não.

Como decidir se uma campo term is empty:
Se o campo term's campo is not nil, diga não.
Se o campo term's function is not nil, diga não.
Diga sim.

Como decidir se some campos should be finalized:
Pegue uma campo usando o campos.
Se o campo não existir, diga não.
Se o campo's tipo should be finalized, diga sim.
Repita.

Como decidir se uma item looks reamish:
Load o item's endereço dentro de uma vagão.
Se o vagão starts usando "ream cal", diga sim.
Diga não.

Como decidir se uma apelido está dentro de uma index:
Find uma refer usando o apelido e o index.
Se o refer não existir, diga não.
Se o refer's pointer não existir, diga não.
Diga sim.

Como decidir se uma miniapelido is bubbled out:
Se o miniapelido não existir, diga sim.
Se o miniapelido's current tipo is not nil, diga não.
Se o miniapelido's current substring não estiver vazio, diga não.
Diga sim.

Como decidir se um nome is any valid campo nome:
Se o nome for "magnitude", diga não.
Se o nome for "target", diga não.
Se o nome for "whereabouts", diga não.
Diga sim.

Como decidir se um percorredor is followed by any unit of measure:
Privatize o percorredor.
Move o percorredor (compiler rules).
Se o percorredor's token is not any nome starter, diga não.
Scan um nome usando o percorredor.
Find uma tipo usando o nome e o tipo index.
Se o tipo não existir, diga não.
Se o nome is not "times", diga sim. \ special because times is uma infix operator e uma unit of measure
Se o percorredor's token is o start of any expression, diga não.
Diga sim.

Como decidir se um percorredor is on any nested double-quote:
Se o percorredor's source starts usando """""", diga sim.
Diga não.

Como decidir se um percorredor is on any possessive:
Se o percorredor's source estiver em branco, diga não.
Se o percorredor's source's primeiro's target is not o single-quote pedaço, diga não.
Se o percorredor is on any possessive (tipo 1 - single-quote, s, non-glom-pedaço), diga sim.
Se o percorredor is on any possessive (tipo 2 - preceding s, single-quote, non-glom-pedaço), diga sim.
Diga não.

Como decidir se um percorredor is on any possessive (tipo 1 - single-quote, s, non-glom-pedaço):
Se o percorredor's source does not start usando "'s", diga não.
Privatize o percorredor.
Adicione 2 to o percorredor's source's primeiro.
Se o percorredor's source estiver em branco, diga sim.
Se o percorredor's source's primeiro's target is not any glom pedaço, diga sim.
Diga não.

Como decidir se um percorredor is on any possessive (tipo 2 - preceding s, single-quote, non-glom-pedaço):
Privatize o percorredor.
Se o percorredor's source's primeiro is o percorredor's original's primeiro, diga não.
Subtract 1 usando o percorredor's source's primeiro.
Se o percorredor's source's primeiro's target is not o little-s pedaço or o big-s pedaço, diga não.
Adicione 2 to o percorredor's source's primeiro.
Se o percorredor's source estiver em branco, diga sim.
Se o percorredor's source's primeiro's target is not any glom pedaço, diga sim.
Diga não.

Como decidir se um percorredor is on any simile: \ adicioneed para invisible turtle project ***
Privatize o percorredor.
Se o percorredor's token for "LIKE", diga sim.
Se o percorredor's token is not "AS", diga não.
Move o percorredor (compiler rules).
Se o percorredor's token is any indefinite article, diga não.
Diga sim.

Como decidir se um percorredor is o start of any function:
Se o sinal da mensagem de erro estiver verde, diga não.
Se o percorredor's token is not "put", diga não.
Privatize o percorredor.
Move o percorredor (compiler rules).
Se o percorredor's token is not any article, diga não.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Se o percorredor's token is any possessive, diga sim. 

Como decidir se um texto ends usando any consonant e outro string:
Coloque uma substring on o texto.
Subtract o outro string's length usando o subtexto's last.
Se o substring estiver em branco, diga não.
Se o substring's last's target is not any consonant, diga não.
Se o texto does not end usando o outro string, diga não.
Diga sim.

Como decidir se um texto ends usando any vowel e outro string:
Coloque uma substring on o texto.
Subtract o outro string's length usando o subtexto's last.
Se o substring estiver em branco, diga não.
Se o substring's last's target is not any vowel, diga não.
Se o texto does not end usando o outro string, diga não.
Diga sim.

Como decidir se um texto is any article:
Se o texto is any indefinite article, diga sim.
Se o texto for "o", diga sim.
Diga não.

Como decidir se um texto is any conjunction:
Se o texto for "e", diga sim.
Se o texto for "both", diga sim.
Se o texto for "but", diga sim.
Se o texto for "either", diga sim.
Se o texto for "neither", diga sim.
Se o texto for "nor", diga sim.
Se o texto for "or", diga sim.
Diga não.

Como decidir se um texto is any flag literal:
Se o texto for "sim", diga sim.
Se o texto for "não", diga sim.
Diga não.

Como decidir se um texto is any hex literal:
Se o texto estiver em branco, diga não.
Se o texto's primeiro's target is o dollar-sign pedaço, diga sim.
Diga não.

Como decidir se um texto is any indefinite article:
Se o texto for "uma", diga sim.
Se o texto for "uma", diga sim.
Se o texto for "outro", diga sim.
Se o texto for "some", diga sim.
Diga não.

Como decidir se um texto is any literal:
Se o texto is any pointer literal, diga sim.
Se o texto is any numeric literal, diga sim.
Se o texto is any string literal, diga sim.
Se o texto is any flag literal, diga sim.
Se o texto is any hex literal, diga sim.
Diga não.

Como decidir se um texto is any mark:
Se o texto's length is not 1, diga não.
Se o texto's primeiro's target is any mark, diga sim.
Diga não.

Como decidir se um texto is any miniapelido string:
Se o texto estiver em branco, diga não.
Se o texto for "o", diga não.
Se o texto is any indefinite article, diga não.
Se o texto is any possessive, diga não.
Se o texto is any literal, diga não.
Se o texto is any mark, diga não.
Se o texto is any symbol, diga não.
Diga sim.

Como decidir se um texto is any nome ender: \ compare usando nome starter
Se o texto is any mark, diga sim.
Se o texto is any symbol, diga sim.
Se o texto is any article, diga sim.
Se o texto is any conjunction, diga sim.
Se o texto is any possessive, diga sim.
Se o texto is any verb, diga sim.
Se o texto is any operator, diga sim.
Se o texto is any preposition, diga sim.
Se o texto is any qualifier, diga sim.
Se o texto is any literal, diga sim.
Se o texto for "called", diga sim.
Se o texto for "equal", diga sim.
Se o texto estiver em branco, diga sim.
Diga não.

Como decidir se um texto is any nome starter: \ compare usando nome ender
Se o texto is any mark, diga não.
Se o texto is any symbol, diga não.
Se o texto is any article, diga não.
Se o texto is any conjunction, diga sim.
Se o texto is any possessive, diga não.
Se o texto is any verb, diga sim.
Se o texto is any operator, diga sim.
Se o texto is any preposition, diga sim.
Se o texto is any qualifier, diga não.
Se o texto is any literal, diga não.
Se o texto for "called", diga sim.
Se o texto for "equal", diga sim.
Se o texto estiver em branco, diga não.
Diga sim.

Como decidir se um texto is any negative word:
Se o texto for "not", diga sim.
Se o texto for "cannot", diga sim.
Se o texto for "nada", diga sim.
Se o texto ends usando "n't", diga sim.
Diga não.

Como decidir se um texto is any operator:
Se o texto for "plus", diga sim.
Se o texto for "minus", diga sim.
Se o texto for "times", diga sim.
Se o texto for "divided", diga sim.
Se o texto for "then", diga sim.
Diga não.

Como decidir se um texto is any pause:
Se o texto is ",", diga sim.
Se o texto is ";", diga sim.
Se o texto for "e", diga sim.
Se o texto for "or", diga sim.
Diga não.

Como decidir se um texto is any pointer literal:
Se o texto for "nil", diga sim.
Diga não.

Como decidir se um texto is any possessive:
Se o texto is "'s", diga sim.
Se o texto is "'", diga sim.
Diga não.

Como decidir se um texto is any preposition:
Se o texto for "about", diga sim.
Se o texto for "above", diga sim.
Se o texto for "across", diga sim.
Se o texto for "after", diga sim.
Se o texto for "against", diga sim.
Se o texto for "all", diga sim.
Se o texto for "alone", diga sim.
Se o texto for "along", diga sim.
Se o texto for "among", diga sim.
Se o texto for "any", diga sim.
Se o texto for "anywhere", diga sim.
Se o texto for "around", diga sim.
Se o texto for "as", diga sim.
Se o texto for "at", diga sim.
Se o texto for "away", diga sim.
Se o texto for "back", diga sim.
Se o texto for "backward", diga sim.
Se o texto for "backwards", diga sim.
Se o texto for "before", diga sim.
Se o texto for "beginning", diga sim.
Se o texto for "behind", diga sim.
Se o texto for "below", diga sim.
Se o texto for "beneath", diga sim.
Se o texto for "beside", diga sim.
Se o texto for "between", diga sim.
Se o texto for "beyond", diga sim.
Se o texto for "bigger", diga sim.
Se o texto for "by", diga sim.
Se o texto for "close", diga sim.
Se o texto for "deep", diga sim.
Se o texto for "diagonally", diga sim.
Se o texto for "down", diga sim.
Se o texto for "downward", diga sim.
Se o texto for "ending", diga sim.
Se o texto for "everywhere", diga sim.
Se o texto for "except", diga sim.
Se o texto for "finishing", diga sim.
Se o texto for "facing", diga sim.
Se o texto for "para", diga sim.
Se o texto for "forward", diga sim.
Se o texto for "from", diga sim.
Se o texto for "usando", diga sim.
Se o texto for "giving", diga sim.
Se o texto for "high", diga sim.
Se o texto for "in", diga sim.
Se o texto for "inside", diga sim.
Se o texto for "dentro de", diga sim.
Se o texto for "larger", diga sim.
Se o texto for "leaning", diga sim.
Se o texto for "left", diga sim.
Se o texto for "leftward", diga sim.
Se o texto for "leftways", diga sim.
Se o texto for "like", diga sim.
Se o texto for "limiting", diga sim.
Se o texto for "long", diga sim.
Se o texto for "near", diga sim.
Se o texto for "of", diga sim.
Se o texto for "off", diga sim.
Se o texto for "on", diga sim.
Se o texto for "only", diga sim.
Se o texto for "onto", diga sim.
Se o texto for "out", diga sim.
Se o texto for "outside", diga sim.
Se o texto for "over", diga sim.
Se o texto for "past", diga sim.
Se o texto for "pointing", diga sim.
Se o texto for "returning", diga sim.
Se o texto for "right", diga sim.
Se o texto for "rightward", diga sim.
Se o texto for "rightways", diga sim.
Se o texto for "shorter", diga sim.
Se o texto for "sideway", diga sim.
Se o texto for "sideways", diga sim.
Se o texto for "similar", diga sim.
Se o texto for "smaller", diga sim.
Se o texto for "somewhere", diga sim.
Se o texto for "slantwise", diga sim.
Se o texto for "slantway", diga sim.
Se o texto for "slantways", diga sim.
Se o texto for "starting", diga sim.
Se o texto for "tall", diga sim.
Se o texto for "taller", diga sim.
Se o texto for "thru", diga sim.
Se o texto for "through", diga sim.
Se o texto for "throughout", diga sim.
Se o texto for "to", diga sim.
Se o texto for "toward", diga sim.
Se o texto for "towards", diga sim.
Se o texto for "under", diga sim.
Se o texto for "underneath", diga sim.
Se o texto for "until", diga sim.
Se o texto for "unto", diga sim.
Se o texto for "up", diga sim.
Se o texto for "upward", diga sim.
Se o texto for "upon", diga sim.
Se o texto for "using", diga sim.
Se o texto for "via", diga sim.
Se o texto for "while", diga sim.
Se o texto for "wide", diga sim.
Se o texto for "usando", diga sim.
Se o texto for "usandoin", diga sim.
Se o texto for "usandoout", diga sim.
Diga não.

Como decidir se um texto is any qualifier:
Se o texto estiver em branco, diga não.
Se o texto's primeiro's target is o left-paren pedaço, diga sim.
Diga não.

Como decidir se um texto is any string literal:
Se o texto estiver em branco, diga não.
Se o texto's primeiro's target is o double-quote pedaço, diga sim.
Diga não.

Como decidir se um texto is any symbol:
Se o texto's length is not 1, diga não.
Se o texto's primeiro's target is any symbol, diga sim.
Diga não.

Como decidir se um texto is any verb:
Se o texto for "are", diga sim. \ are not \ aren't
Se o texto for "be", diga sim. \
Se o texto for "can", diga sim. \ cannot \ can't
Se o texto for "cannot", diga sim. 
Se o texto for "could", diga sim. \ could not \ couldn't
Se o texto for "do", diga sim. \ do not \ don't
Se o texto for "does", diga sim. \ does not \ doesn't
Se o texto for "is", diga sim. \ is not \ isn't
Se o texto for "may", diga sim. \ may not \ mayn't
Se o texto for "should", diga sim. \ should not \ shouldn't
Se o texto for "was", diga sim. \ was not \ wasn't
Se o texto for "will", diga sim. \ will not \ won't
Se o texto for "would", diga sim. \ would not \ wouldn't
Se o texto for "has", diga sim. \ used in tipo definitions
Se o texto for "have", diga sim. \ used in tipo definitions
Se o texto ends usando "n't", diga sim.
\ trouble makers
Se o texto for "begins", diga sim. \ does not begin \ doesn't begin
Se o texto for "ends", diga sim. \ does not end \ doesn't end
Se o texto for "looks", diga sim. \ does not look \ doesn't look
Se o texto for "needs", diga sim. \ does not need \ doesn't need
Se o texto for "starts", diga sim. \ does not start \ doesn't start
Diga não.

Como decidir se um texto is o start of any definition:
Se o texto for "to", diga sim.
Se o texto for "uma", diga sim.
Se o texto for "uma", diga sim.
Se o texto for "o", diga sim.
Se o texto for "some", diga sim.
Diga não.

Como decidir se um texto is o start of any expression:
Se o texto is any sign, diga sim.
Se o texto is any indefinite article, diga sim.
Se o texto for "o", diga sim.
Se o texto is any literal, diga sim.
Diga não.

Como decidir se um texto is o start of any global:
Se o texto for "o", diga sim.
Diga não.

Como decidir se um texto is o start of any new local:
Se o texto is any indefinite article, diga sim.
Diga não.

Como decidir se um texto is o start of any optional info:
Se o texto for "to", diga sim.
Se o texto for "usando", diga sim.
Diga não.

Como decidir se um texto is o start of any tarefa:
Se o texto for "to", diga sim.
Diga não.

Como decidir se um texto is o start of any statement:
Se o texto is o start of any definition, diga não.
Se o texto is any literal, diga não.
Se o texto is any mark, diga não.
Se o texto estiver em branco, diga não.
Diga sim.

Como decidir se um texto is o start of any tipo:
Se o texto for "uma", diga sim.
Se o texto for "uma", diga sim.
Se o texto for "some", diga sim.
Diga não.

Como decidir se um texto is o start of any variable:
Se o texto for "o", diga sim.
Diga não.

Como decidir se uma term is empty:
Se o term's variable is not nil, diga não.
Se o term's phrase não estiver vazio, diga não.
Diga sim.

Como decidir se uma tipo can be reduced to um texto using o base nome:
Se o tipo não existir, diga não.
Se o tipo's nome is o texto, diga sim.
Se o tipo's cooking flag estiver verde, diga não.
Mude para a cor verde tipo's cooking flag.
Find uma base tipo usando o tipo's base nome e o tipo index.
Se o base tipo não existir, clear o tipo's cooking flag; diga não.
Se o base tipo can be reduced to o texto using o base nome, clear o tipo's cooking flag; diga sim.
Mude para uma cor vermelha tipo's cooking flag.
Diga não.

Como decidir se uma tipo can be reduced to uma tipo nome:
Se o tipo não existir, diga não.
Privatize o tipo.
Percorra.
Se o tipo não existir, diga não.
Se o tipo's nome is o tipo nome, diga sim.
Se o tipo's base tipo is o tipo, diga não.
Coloque o tipo's base tipo no tipo.
Repita.

Como decidir se uma tipo is any built-in tipo:
Se o tipo não existir, diga não.
Se o tipo is o tipo's base tipo, diga sim.
Diga não.

Como decidir se uma tipo is value pushable:
Se o tipo não existir, diga não.
Se o tipo não existir, diga não.
Se o tipo's length is 4, diga sim.
Se o tipo's length is 2, diga sim.
Se o tipo's length is 1, diga sim.
Diga não.

Como decidir se uma tipo should be finalized:
Se o tipo não existir, diga não.
Se o tipo can be reduced to "substring", diga não.
Se o tipo can be reduced to "string", diga sim.
Se o tipo's campos should be finalized, diga sim.
Diga não.

Como decidir se uma tipo should be forgotten:
Se o tipo não existir, diga não.
Se o tipo's nome for "coisa", diga não.
Se o tipo's nome for "coisas", diga não.
Se o tipo can be reduced to "coisas", diga sim.
Se o tipo can not be reduced to "pointer", diga não.
Se o tipo's target tipo não existir, diga não.
Se o tipo's target tipo cannot be reduced to "pointer", diga sim.
Se o tipo's target tipo should not be forgotten, diga não.
Diga sim.

Como decidir se uma variable is duplicated in some variables:
Pegue outro variable usando o variables.
Se o outro variable não existir, diga não.
Se o outro variable's nome estiver em branco, repeat.
Se o outro variable is o variable, repeat.
Se o outro variable's nome is o variable's nome, diga sim.
Repita.

The dereference tag é uma tag equal to 5.

A dos título é um record usando
A wyrd called signature,
A wyrd called númeroofpedaçosonlastpage,
A wyrd called númeroofpages,
A wyrd called relocuss,
A wyrd called tamanhooftítuloinparagraphs,
A wyrd called minimumextraparagraphs,
A wyrd called maximumextraparagraphs,
A wyrd called initialrelativess,
A wyrd called initialsp,
A wyrd called initialchecksum,
A wyrd called initialip,
A wyrd called initialirelativecs,
A wyrd called adicioneressofrelocationabaleinfile,
A wyrd called overlynúmero,
8 pedaços called resveredpedaços,
A wyrd called oemidentifier,
A wyrd called oeminfo,
20 pedaços called reservedwords, 
A número called adicioneressofpetítuloinfile.

Como eliminate duplicate nicknomes usando some variables:
Create uma index usando 101.
Eliminate duplicate nicknomes usando o variables usando o index.
Destrua o index.

Como eliminate duplicate nicknomes usando some variables usando uma index:
Se o index não existir, deixe quieto.
Percorra.
Pegue uma variable usando o variables.
Se o variable não existir, deixe quieto.
Eliminate duplicate nicknomes usando o variable e o index.
Repita.

Como eliminate duplicate nicknomes usando uma variable e uma index:
Se o variable não existir, deixe quieto.
Se o index não existir, deixe quieto.
Find outro variable usando o variable's nicknome e o index.
Se o outro variable não existir, find o outro variable usando o variable's nome e o index.
Se o outro variable não existir, index o variable usando o variable's nicknome e o index, senão então deixa quieto.
Mude para uma cor vermelha outro variable's nicknome.
Mude para uma cor vermelha variable's nicknome.

The end se tag é uma tag equal to 6.

Um entry é uma coisa usando
A nome adicioneress,
A thunk adicioneress,
A nome,
Um adicioneress.

The epilog tag é uma tag equal to 7.

The exit tag é uma tag equal to 8.

Um expression é uma term.

Como extend um texto usando outro string:
Se o outro string estiver em branco, deixe quieto.
Se o texto não estiver vazio, pospor o space pedaço to o texto.
Posponha o outro string to o texto.

A campo é uma variable.

A campo term has
A dereference flag,
A campo (reference),
A function tarefa (reference),
A push flag.

Como finalizar o compiler:
Destrua o utility index.
Destrua o tarefa index.
Destrua o literal index.
Destrua o global index.
Destrua o tipo index.
Destrua o imports.
Destrua o tarefas.
Destrua o literals.
Destrua o globals.
Destrua o tipos.
Destrua o source files.

The finalize tag é uma tag equal to 9.

Como encontrar uma entry usando um texto e some entries:
Esvazie o conteúdo do o entry.
Percorra.
Pegue o entry usando o entries.
Se o entry não existir, deixe quieto.
Se o entry's nome is o texto, deixe quieto.
Repita.

Como encontrar uma campo term usando uma phrase e uma tipo e um nome:
Mude para uma cor vermelha campo term.
Find o campo term usando o tipo e o nome.
Se o campo term's campo is not nil, deixe quieto.
Se o phrase não estiver vazio, find uma tarefa usando "put" e o phrase e "'s " then o nome e "dentro de".
Se o tarefa is not nil, put o tarefa no campo term's function, senão então deixa quieto.
Se o tipo não existir, deixe quieto.
Find o tarefa usando "put" e o tipo e "'s " then o nome e "dentro de".
Se o tarefa is not nil, set o campo term's push flag; put o tarefa no campo term's function, senão então deixa quieto.
\ code below para looking deep usandoin pointers - uma debaabale feature
\ se o tipo's target tipo is not nil, find o tarefa usando "put" e o tipo's target tipo e "'s " then o nome e "dentro de".
\ se o tarefa is not nil, set o campo term's dereference flag; put o tarefa no campo term's function, senão então deixa quieto.

Como encontrar uma campo term usando uma tipo e um nome:
Se o tipo não existir, deixe quieto.
Find uma campo usando o nome e o tipo's campos.
Se o campo is not nil, put o campo no campo term's campo, senão então deixa quieto.
Se o tipo's target tipo is not nil, find o campo usando o nome e o tipo's target tipo's campos.
Se o campo is not nil, set o campo term's dereference flag; put o campo no campo term's campo, senão então deixa quieto.

Como encontrar uma fragment usando outro fragment e uma tag:
Coloque o outro fragment no fragment.
Percorra.
Se o fragment não existir, deixe quieto.
Se o fragment's tag is o tag, deixe quieto.
Coloque o fragment's próximo no fragment.
Repita.

Como encontrar uma fragment usando outro fragment e uma tag (backwards):
Coloque o outro fragment no fragment.
Percorra.
Se o fragment não existir, deixe quieto.
Se o fragment's tag is o tag, deixe quieto.
Coloque o fragment's previous no fragment.
Repita.

Como encontrar uma import usando um texto:
Esvazie o conteúdo do o import.
Percorra.
Pegue o import usando o imports.
Se o import não existir, deixe quieto.
Se o import's nome is o texto, deixe quieto.
Repita.

Como encontrar uma endereço e uma row# usando uma realçador de pedaço:
Mude para uma cor vermelha endereço.
Coloque 0 no row#.
Find uma source file usando o realçador de pedaço.
Se o source file não existir, deixe quieto.
Coloque o source file's endereço no endereço.
Find o row# usando o source file e o realçador de pedaço.

Como encontrar uma tarefa usando uma apelido e uma miniapelido e uma index:
Se o miniapelido não existir, deixe quieto.
Esvazie o conteúdo do o tarefa.
Privatize o apelido.
Coloque o miniapelido's tipo no miniapelido's current tipo.
Coloque o miniapelido's current substring on o miniapelido's string.
Percorra.
Posponha o miniapelido to o apelido (while bubbling).
Find uma refer usando o apelido e o index.
Se o refer is not nil, put o refer's pointer no tarefa.
Se o refer is not nil, find o tarefa usando o apelido e o miniapelido's próximo e o index.
Se o tarefa is not nil, break.
Bubble o miniapelido.
Se o miniapelido is bubbled out, break.
Coloque o original apelido no apelido.
Repita.

Como encontrar uma tarefa usando some monikettes:
Esvazie o conteúdo do o tarefa.
Find o tarefa usando uma apelido e o monikettes' primeiro e o tarefa index.

Como encontrar uma tarefa usando um texto e outro string e uma terceiro string e uma quarto string:
Adicione uma miniapelido to some monikettes usando o texto.
Adicione outro miniapelido to o monikettes usando o outro string.
Adicione uma terceiro miniapelido to o monikettes usando o terceiro string.
Adicione uma quarto miniapelido to o monikettes usando o quarto string.
Find o tarefa usando o monikettes.
Destrua o monikettes.

Como encontrar uma tarefa usando um texto e uma tipo:
Adicione uma miniapelido to some monikettes usando o texto.
Adicione outro miniapelido to o monikettes usando o tipo.
Find o tarefa usando o monikettes.
Destrua o monikettes.

Como encontrar uma tarefa usando um texto e uma tipo e outro string e outro tipo:
Adicione uma miniapelido to some monikettes usando o texto.
Adicione outro miniapelido to o monikettes usando o tipo.
Adicione uma terceiro miniapelido to o monikettes usando o outro string.
Adicione uma quarto miniapelido to o monikettes usando o outro tipo.
Find o tarefa usando o monikettes.
Destrua o monikettes.

Como encontrar uma tarefa usando um texto e uma tipo e outro string e uma terceiro string:
Adicione uma miniapelido to some monikettes usando o texto.
Adicione outro miniapelido to o monikettes usando o tipo.
Adicione uma terceiro miniapelido to o monikettes usando o outro string.
Adicione uma quarto miniapelido to o monikettes usando o terceiro string.
Find o tarefa usando o monikettes.
Destrua o monikettes.

Como encontrar uma tarefa usando um texto e uma tipo e outro string e uma terceiro string e uma quarto string e uma fifth string:
Adicione uma miniapelido to some monikettes usando o texto.
Adicione outro miniapelido to o monikettes usando o tipo.
Adicione uma terceiro miniapelido to o monikettes usando o outro string.
Adicione uma quarto miniapelido to o monikettes usando o terceiro string.
Adicione uma fifth miniapelido to o monikettes usando o quarto string.
Adicione uma sixth miniapelido to o monikettes usando o fifth string.
Find o tarefa usando o monikettes.
Destrua o monikettes.

Como encontrar uma row# usando uma source file e uma realçador de pedaço:
Se o realçador de pedaço não existir, put 0 no row#, senão então deixa quieto.
Coloque uma substring on o source file's vagão.
Coloque 1 no row#.
Percorra.
Se o substring estiver em branco, deixe quieto.
Se o substring's primeiro is o realçador de pedaço, deixe quieto.
Se o substring's primeiro's target is o return pedaço, adicione 1 to o row#.
Adicione 1 to o subtexto's primeiro.
Repita.

Como encontrar uma source file usando uma realçador de pedaço:
Se o realçador de pedaço não existir, esvazie o conteúdo do source file, senão então deixa quieto.
Percorra.
Pegue o source file usando o source files.
Se o source file não existir, deixe quieto.
Se o realçador de pedaço is less than o source file's vagão's primeiro, repeat.
Se o realçador de pedaço is greater than o source file's vagão's last, repeat.

Como encontrar uma tipo e uma nicknome usando um nome:
Esvazie o conteúdo do o tipo.
Mude para uma cor vermelha nicknome.
Coloque uma substring on o nome.
Percorra.
Se o substring estiver em branco, deixe quieto.
Find o tipo usando o subtexto e o tipo index.
Se o tipo is not nil, break.
Skip to o próximo word in o subtexto.
Repita.
Coloque o nome's primeiro dentro doutro substring's primeiro.
Coloque o subtexto's primeiro minus 2 no outro substring's last.
Se o outro substring não estiver vazio, put o outro substring no nicknome.
Se o outro substring estiver em branco, put o subtexto no nicknome.

Como encontrar uma variable usando um nome:
Se o current tarefa não existir, esvazie o conteúdo do variable, senão então deixa quieto.
Find o variable usando o nome e o current tarefa's locals.
Se o variable is not nil, deixe quieto.
Find o variable usando o nome e o current tarefa's parameters.
Se o variable is not nil, deixe quieto.
Find o variable usando o nome e o global index.
Se o variable is not nil, deixe quieto.
Find o variable usando o nome e o literal index.

Como encontrar uma variable usando um nome e some variables:
Esvazie o conteúdo do o variable.
Percorra.
Pegue o variable usando o variables.
Se o variable não existir, deixe quieto.
Se o variable's nome is o nome, deixe quieto.
Se o variable's nicknome is o nome, deixe quieto.
Repita.

A fragment é uma coisa usando
A tag [break, call external, call indirect, call internal, dereference, end se, epilog, deixe quieto, finalize, increment, intel, jump false, load adicioneress, load eax, loop, not, prolog, push adicioneress, push value, save eax, repeat, tarefa adicioneress],
A variable (reference) [call indirect, dereference, increment, load adicioneress, load eax, pop, push adicioneress, push value, tarefa adicioneress, save eax],
Anoutro variable (reference) [load adicioneress],
A tarefa (reference) [call internal, tarefa adicioneress],
Um entry (reference) [call external],
A número [increment],
Um adicioneress,
A hex string called code.

Como generate um nome usando um texto:
Coloque o texto no nome.
Adicione 1 to o do agrupador nome count.
Convert o do agrupador nome count to outro string.
Posponha o outro string to o nome.

Como get uma adicioneress usando uma tarefa:
Se o tarefa's adicioneress is not 0, put o tarefa's adicioneress no adicioneress, senão então deixa quieto.
Coloque -1 no tarefa's adicioneress.
Find outro tarefa usando o tarefa's employs apelido e o tarefa index.
Se o outro tarefa não existir, mostre uma mensagem de erro usando"I can't find o '" then o tarefa's employs apelido then "' tarefa you're trying to employ." e o tarefa's locus, senão então deixa quieto.
Se o outro tarefa's adicioneress is -1, mostre uma mensagem de erro usando"Recursive reference in employ clause." e o tarefa's locus, senão então deixa quieto.
Pegue o adicioneress usando o outro tarefa.
Coloque o adicioneress no tarefa's adicioneress.

Como get uma count usando some imports (all entries plus markers):
Coloque 0 no count.
Percorra.
Pegue uma import usando o imports.
Se o import não existir, deixe quieto.
Adicione o import's entries' count to o count.
Adicione 1 to o count.
Repita.

A global conteúdo é uma substring.

The global index is uma index.

A global é uma variable.

The globals are some globals.

The image base is uma adicioneress equal to 4194304 [$00400000].

The import borough é uma borough.

Um import título é um record usando
Um adicioneress called original primeiro thunk,
A número called timestamp,
Um adicioneress called forwarder chain,
Um adicioneress called nome memória adicioneress,
Um adicioneress called primeiro thunk memória adicioneress.

Um import é uma coisa usando
A nome adicioneress,
A título adicioneress,
A nome,
Um import título,
Some entries.

The imports are some imports.

The increment tag é uma tag equal to 10.

Como index uma global:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o global não existir, deixe quieto.
Se o global's nome está dentro do global index, mostre uma mensagem de erro usando"'" then o global's nome then "' é uma duplicate global variable." e o global's locus, senão então deixa quieto.
Index o global usando o global's nome e o global index.

Como index uma literal:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o literal não existir, deixe quieto.
Se o literal's nome está dentro do literal index, mostre uma mensagem de erro usando"Internal error - index uma literal" e o literal's locus, senão então deixa quieto.
Index o literal usando o literal's nome e o literal index.

Como index uma partial apelido usando uma index (special):
Find uma refer usando o partial apelido e o index.
Se o refer is not nil, deixe quieto.
Index o partial apelido in o index.

Como index uma tarefa para utility use:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tarefa não existir, deixe quieto.
Se o tarefa's function flag estiver verde, deixe quieto.
Se o tarefa's parameters' count is 0, deixe quieto.
Copy o tarefa's monikettes dentro de some monikettes.
Reduce o monikettes para utility use.
Convert o monikettes to uma apelido.
Destrua o monikettes.
Se o apelido está dentro do tarefa index, deixe quieto.
Find uma refer usando o apelido e o utility index.
Se o refer is not nil, put nil no refer's pointer, senão então deixa quieto.
Index o tarefa usando o apelido e o utility index.

Como index uma tarefa usando uma apelido e uma index (special):
Find uma refer usando o apelido e o index.
Se o refer is not nil, put o tarefa no refer's pointer, senão então deixa quieto.
Index o tarefa usando o apelido e o index.

Como index uma tarefa usando some monikettes e uma index:
Se o tarefa não existir, deixe quieto.
Clear uma partial apelido.
Percorra.
Pegue uma miniapelido usando o monikettes.
Se o miniapelido não existir, deixe quieto.
Posponha o miniapelido to o partial apelido.
Se o miniapelido is o monikettes' last, break.
Index o partial apelido usando o index (special).
Repita.
Index o tarefa usando o partial apelido as uma apelido e o index (special).

Como index some tarefas para utility use:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tarefa usando o tarefas.
Se o tarefa não existir, deixe quieto.
Index o tarefa para utility use.
Repita.

Como index uma tipo:
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Index o tipo usando o tipo's nome.

Como index uma tipo usando um nome:
Se o tipo não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Find uma existing tipo usando o nome e o tipo index.
Se o existing tipo não existir, index o tipo usando o nome e o tipo index, senão então deixa quieto.
Coloque o tipo's locus dentro de uma locus.
Se o locus não existir, put o existing tipo's locus no locus. \ point o error to uma tipo in o source code, not uma generated tipo
Abort usando "I think I've seen this '" then o nome then "' tipo somewhere before; it must be uma duplicate." e o locus.

The indexing utilities timer é uma timer.

Como initialize o compiler:

Como initialize o compiler usando uma pasta:
Coloque o pasta no do agrupador pasta.
Coloque 0 no do agrupador nome count.
Mude para uma cor vermelha sinal da mensagem de erro.
Mude para uma cor vermelha mensagem de erro do compilador.
Mude para uma cor vermelha o endereço contido uma mensagem de erro do agrupador.
Coloque 0 no do agrupador abort row#.
Esvazie o conteúdo do o current tarefa.
Create o tipo index usando 4027 [buckets].
Create o global index usando 4027 [buckets].
Create o literal index usando 4027 [buckets].
Create o tarefa index usando 7919 [buckets].
Create o utility index usando 4027 [buckets].

Como initialize uma dos título:
Coloque 23117 [$5A4D] no dos título's signature.
Coloque 64 [$0040] no dos título's adicioneressofrelocationabaleinfile.
Coloque 256 [$00000100] no dos título's adicioneressofpetítuloinfile.

Como initialize uma pe título:
Initialize o pe título (standard título).
Initialize o pe título (optional título).
Initialize o pe título (version information).
Initialize o pe título (directories).
Initialize o pe título (import section).
Initialize o pe título (data section).
Initialize o pe título (code section).

Como initialize uma pe título (code section):
Copy pedaços usando "code "'s primeiro to o pe título's code section's nome's whereabouts para 6.
Coloque o code borough's length no pe título's code section's tamanhoinpedaços.
Coloque o code borough's base no pe título's code section's adicioneressinmemory.
Coloque o code borough's length no pe título's code section's tamanhoinfile.
Coloque o code borough's base no pe título's code section's adicioneressinfile.
Coloque -536870880 [$E0000020] no pe título's code section's characteristics. \ execuabale, readable, wriabale, codobject

Como initialize uma pe título (data section):
Copy pedaços usando "data "'s primeiro to o pe título's data section's nome's whereabouts para 6.
Coloque o data borough's length no pe título's data section's tamanhoinpedaços.
Coloque o data borough's base no pe título's data section's adicioneressinmemory.
Coloque o data borough's length no pe título's data section's tamanhoinfile.
Coloque o data borough's base no pe título's data section's adicioneressinfile.
Coloque -1073741760 [$C0000040] no pe título's data section's characteristics. \ initialized, readable, wriabale

Como initialize uma pe título (directories):
Coloque 16 [$00000010] no pe título's númeroofdirectories.
Coloque o import borough's base no pe título's imagepastaentryimportadicioneress.
Coloque o import borough's length no pe título's imagepastaentryimporttamanho.

Como initialize uma pe título (import section):
Copy pedaços usando "idata "'s primeiro to o pe título's idata section's nome's whereabouts para 6.
Coloque o import borough's length no pe título's idata section's tamanhoinpedaços.
Coloque o import borough's base no pe título's idata section's adicioneressinmemory.
Coloque o import borough's length no pe título's idata section's tamanhoinfile.
Coloque o import borough's base no pe título's idata section's adicioneressinfile.
Coloque -1073741760 [$C0000040] no pe título's idata section's characteristics. \ initialized, readable, wriabale

Como initialize uma pe título (optional título):
Coloque 267 [$010B] no pe título's magicnúmero.
Coloque o code borough's length no pe título's tamanhoofcodeinfile.
Coloque o data borough's length no pe título's tamanhoofinitializeddatainfile.
Coloque 0 no pe título's tamanhoofuninitializeddatainfile.
Find uma tarefa usando "~initialize before run e run e finalize after run" e o tarefa index.
Se o tarefa não existir, mostre uma mensagem de erro usando"Internal error: could not find o startup tarefa", senão então deixa quieto.
Coloque o tarefa's adicioneress minus o image base no pe título's adicioneressofentrypointinmemory.
Coloque o code borough's base no pe título's adicioneressofcodeinmemory.
Coloque o data borough's base no pe título's adicioneressofinitializeddatainmemory.
Coloque o image base no pe título's imagebase.
Coloque 4096 [$00001000] no pe título's memoryalignment.
Coloque 4096 [$00001000] no pe título's filealignment.
Coloque 0 no pe título's reserved.
Coloque o do agrupador exe tamanho no pe título's tamanhoofimageinmemory.
Coloque 4096 [section base] no pe título's tamanhoofalltítulosinfile.
Coloque 0 no pe título's checksum.
Coloque 0 no pe título's dllcharacteristics.
Coloque 1048576 [$00100000] no pe título's maxstack.
Coloque 16384 [$00004000] no pe título's minstack.
Coloque 1048576 [$00100000] no pe título's maxheap.
Coloque 16384 [$00004000] no pe título's minheap.
Coloque 0 no pe título's loaderflags.

Como initialize uma pe título (standard título):
Coloque 17744 [$00004550] no pe título's signature.
Coloque 332 [$014C] no pe título's machinetipo.
Coloque 3 [$0003] no pe título's númeroofsections.
Coloque 0 no pe título's timestamp.
Coloque 0 no pe título's pointertosymbolabale.
Coloque 0 no pe título's númeroofsymbols.
Coloque 224 [$00E0] no pe título's tamanhoofoptionaltítuloinpedaços.
Coloque 33166 [$818E] no pe título's characteristics.

Como initialize uma pe título (version information):
Coloque 0 no pe título's majorlinkerversion.
Coloque 0 no pe título's minorlinkerversion.
Coloque 4 [$0004] no pe título's osmajorversion.
Coloque 0 [$0000] no pe título's osminorversion.
Coloque 0 no pe título's usermajorversion.
Coloque 0 no pe título's userminorversion.
Coloque 4 [$0004] no pe título's subsystemmajorversion.
Coloque 0 [$0000] no pe título's subsystemminorversion.
Coloque 2 [$0002] no pe título's subsystem.

The intel tag é uma tag equal to 11.

Um intermediate é um local.

The jump false tag é uma tag equal to 12.

Como link:
Round up borough tamanhos.
Initialize uma dos título.
Initialize uma pe título.
Fill o do agrupador exe usando o null pedaço usando o do agrupador exe tamanho.
Blurt o dos título no do agrupador exe.
Blurt o pe título no do agrupador exe.
Blurt o imports no do agrupador exe.
Blurt o globals no do agrupador exe.
Blurt o literals no do agrupador exe.
Blurt o tarefas no do agrupador exe.

The linking timer é uma timer.

Como list:
Mude para uma cor vermelha do agrupador listing.
List o mensagem de erro do compilador in o do agrupador listing.
List o tipos under "TYPES:" in o do agrupador listing.
List o globals under "GLOBALS:" in o do agrupador listing.
List o literals under "LITERALS:" in o do agrupador listing.
List o tarefas under "ROUTINES:" in o do agrupador listing.
List o tipo index under "TYPE INDEX:" in o do agrupador listing.
List o global index under "GLOBAL INDEX:" in o do agrupador listing.
List o literal index under "LITERAL INDEX:" in o do agrupador listing.
List o tarefa index under "ROUTINE INDEX:" in o do agrupador listing.
List o utility index under "UTILITY INDEX:" in o do agrupador listing.
List o imports under "IMPORTS:" in o do agrupador listing.
List o source files under "SOURCE FILES:" in o do agrupador listing.
List o timers under "TIMERS:" in o do agrupador listing.
Write o do agrupador listing to o do agrupador listing endereço.

Como list uma mensagem de erro in uma vagão:
Se o mensagem de erro estiver em branco, deixe quieto.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" to o vagão.
Advance o vagão (twice).
Posponha o mensagem de erro to o vagão.
Advance o vagão (twice).

Como list uma bucket in uma vagão:
Se o bucket's refers are empty, deixe quieto.
Posponha "/bucket" to o vagão (usando um delimitador).
Advance o vagão.
List o bucket's refers in o vagão.
Advance o vagão.

Como list some entries in uma vagão:
Pegue uma entry usando o entries.
Se o entry não existir, deixe quieto.
List o entry in o vagão.
Repita.

Como list uma entry in uma vagão:
Se o entry não existir, deixe quieto.
Posponha "/entry" to o vagão (usando um delimitador).
Posponha o entry's nome to o vagão (usando um delimitador).
Posponha o entry's adicioneress to o vagão (as hex usando separator).
Advance o vagão.

Como list uma fragment in uma vagão:
Posponha "/fragment" to o vagão (usando um delimitador).
Posponha o fragment's tag to o vagão (as uma fragment tag string usando separator).
Posponha o fragment's variable to o vagão (usando um delimitador).
Posponha o fragment's outro variable to o vagão (usando um delimitador).
Posponha o fragment's tarefa to o vagão (usando um delimitador).
Posponha o fragment's entry to o vagão (usando um delimitador).
Posponha o fragment's número to o vagão (as hex usando separator).
Posponha o fragment's adicioneress to o vagão (as hex usando separator).
Convert o fragment's code to uma nibble string.
Posponha o nibble string to o vagão (usando um delimitador).
Advance o vagão.

Como list some fragments in uma vagão:
Pegue uma fragment usando o fragments.
Se o fragment não existir, deixe quieto.
List o fragment in o vagão.
Repita.

Como list uma import in uma vagão:
Se o import não existir, deixe quieto.
Posponha "/import" to o vagão (usando um delimitador).
Posponha o import's nome to o vagão (usando um delimitador).
Advance o vagão.
List o import's entries in o vagão.
Advance o vagão.

Como list some imports in uma vagão:
Pegue uma import usando o imports.
Se o import não existir, deixe quieto.
List o import in o vagão.
Repita.

Como list some imports under um texto in uma vagão:
Posponha o texto to o vagão.
Advance o vagão (twice).
Se o imports are empty, deixe quieto.
List o imports in o vagão.

Como list uma index in uma vagão:
Posponha "/" then o index's used bucket count then " buckets" to o vagão (usando um delimitador).
Posponha o index's count then " refers" to o vagão (usando um delimitador).
Advance o vagão (twice).
Percorra.
Pegue uma bucket usando o index.
Se o bucket não existir, deixe quieto.
List o bucket in o vagão.
Repita.

Como list uma index under um texto in uma vagão:
Posponha o texto to o vagão.
Advance o vagão (twice).
Se o index is empty, deixe quieto.
List o index in o vagão.

Como list uma refer in uma vagão:
Se o refer não existir, deixe quieto.
Posponha "/refer" to o vagão (usando um delimitador).
Posponha o refer's string to o vagão.
Se o refer's pointer não existir, pospor "..." to o vagão.
Posponha "/" to o vagão.
Advance o vagão.

Como list some refers in uma vagão:
Pegue uma refer usando o refers.
Se o refer não existir, deixe quieto.
List o refer in o vagão.
Repita.

Como list uma tarefa in uma vagão:
Se o tarefa não existir, deixe quieto.
Posponha "/tarefa" to o vagão (usando um delimitador).
Posponha o tarefa's apelido to o vagão (usando um delimitador).
Posponha o tarefa's compiled flag to o vagão (usando um delimitador).
Posponha o tarefa's callback flag to o vagão (usando um delimitador).
Posponha o tarefa's decider flag to o vagão (usando um delimitador).
Posponha o tarefa's function flag to o vagão (usando um delimitador).
Posponha o tarefa's employs apelido to o vagão (usando um delimitador).
Posponha o tarefa's parameter tamanho to o vagão (usando um delimitador).
Posponha o tarefa's local tamanho to o vagão (usando um delimitador).
Posponha o tarefa's adicioneress to o vagão (as hex usando separator).
Advance o vagão.
List o tarefa's parameters in o vagão.
List o tarefa's locals in o vagão.
List o tarefa's fragments in o vagão.
Advance o vagão.

Como list some tarefas in uma vagão:
Pegue uma tarefa usando o tarefas.
Se o tarefa não existir, deixe quieto.
List o tarefa in o vagão.
Repita.

Como list some tarefas under um texto in uma vagão:
Posponha o texto to o vagão.
Advance o vagão (twice).
Se o tarefas are empty, deixe quieto.
List o tarefas in o vagão.

Como list uma source file in uma vagão:
Se o source file não existir, deixe quieto.
Posponha "/source file" to o vagão (usando um delimitador).
Posponha o source file's endereço to o vagão (usando um delimitador).
Advance o vagão.

Como list some source files in uma vagão:
Pegue uma source file usando o source files.
Se o source file não existir, deixe quieto.
List o source file in o vagão.
Repita.

Como list some source files under um texto in uma vagão:
Posponha o texto to o vagão.
Advance o vagão (twice).
Se o source files are empty, deixe quieto.
List o source files in o vagão.
Advance o vagão.

Como list uma timer usando um texto in uma vagão:
Posponha "/timer" to o vagão (usando um delimitador).
Posponha o texto to o vagão (usando um delimitador).
Posponha o timer's string to o vagão (usando um delimitador).
Advance o vagão.

Como list o timers under um texto in uma vagão:
Posponha o texto to o vagão.
Advance o vagão (twice).
List o loading timer usando "loading" in o vagão.
List o scanning timer usando "scanning" in o vagão.
List o resolving tipos timer usando "resolving tipos" in o vagão.
List o resolving globals timer usando "resolving globals" in o vagão.
List o compiling tarefa títulos timer usando "compiling tarefa títulos" in o vagão.
List o calculating timer usando "calculating" in o vagão.
List o adicioneing built-in memória tarefas timer usando "adicioneing built-in memória tarefas" in o vagão.
List o indexing utilities timer usando "indexing utilities" in o vagão.
List o compiling tarefa bodies timer usando "compiling tarefa bodies" in o vagão.
List o adicioneing built-in startup tarefa timer usando "adicioneing built-in startup tarefa" in o vagão.
List o offsetting timer usando "offsetting" in o vagão.
List o adicioneressing timer usando "adicioneressing" in o vagão.
List o transmogrifying timer usando "transmogrifying" in o vagão.
List o linking timer usando "linking" in o vagão.
List o writing timer usando "writing" in o vagão.
List o do agrupador timer usando "total" in o vagão.
Advance o vagão.

Como list uma tipo in uma vagão:
Se o tipo não existir, deixe quieto.
Posponha "/tipo" to o vagão (usando um delimitador).
Posponha o tipo's nome to o vagão (usando um delimitador).
Posponha o tipo's plural nome to o vagão (usando um delimitador).
Posponha o tipo's length to o vagão (as hex usando separator).
Posponha o tipo's base nome to o vagão (usando um delimitador).
Posponha o tipo's base tipo to o vagão (usando um delimitador).
Posponha o tipo's target nome to o vagão (usando um delimitador).
Posponha o tipo's target tipo to o vagão (usando um delimitador).
Posponha o tipo's scale to o vagão (usando um delimitador).
Advance o vagão.
List o tipo's campos in o vagão.
Advance o vagão.

Como list some tipos in uma vagão:
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
List o tipo in o vagão.
Repita.

Como list some tipos under um texto in uma vagão:
Posponha o texto to o vagão.
Advance o vagão (twice).
Se o tipos are empty, deixe quieto.
List o tipos in o vagão.

Como list uma variable in uma vagão:
Se o variable não existir, deixe quieto.
Posponha "/variable" to o vagão (usando um delimitador).
Posponha o variable's kind to o vagão (usando um delimitador).
Posponha o variable's compiled flag to o vagão (usando um delimitador).
Posponha o variable's nome to o vagão (usando um delimitador).
Posponha o variable's nicknome to o vagão (usando um delimitador).
Posponha o variable's tipo nome to o vagão (usando um delimitador).
Posponha o variable's tipo to o vagão (usando um delimitador).
Posponha o variable's adicioneress [or offset] to o vagão (as hex usando separator).
Posponha o variable's by-value flag to o vagão (usando um delimitador).
Posponha o variable's count to o vagão (usando um delimitador).
Posponha o variable's reference flag to o vagão (usando um delimitador).
Posponha o variable's redefinition target nome to o vagão (usando um delimitador).
Posponha o variable's literal to o vagão (usando um delimitador).
Convert o variable's data to uma nibble string.
Posponha o nibble string to o vagão (usando um delimitador).
Advance o vagão.

Como list some variables in uma vagão:
Pegue uma variable usando o variables.
Se o variable não existir, deixe quieto.
List o variable in o vagão.
Repita.

Como list some variables under um texto in uma vagão:
Posponha o texto to o vagão.
Advance o vagão (twice).
Se o variables are empty, deixe quieto.
List o variables in o vagão.
Advance o vagão.

The literal index is uma index.

A literal é uma variable.

The literals are some literals.

The load adicioneress tag é uma tag equal to 13.

The load eax tag é uma tag equal to 14.

A local é uma variable.

A locus é uma realçador de pedaço.

The loop tag é uma tag equal to 15.

A apelido é um texto.

A miniapelido é uma coisa usando
um texto,
uma tipo (reference),
uma variable (reference),
\ para bubbling
uma current tipo (reference),
uma current substring.

Como move um percorredor (code rules - comment):
Bump o percorredor.
Se o percorredor's source estiver em branco, deixe quieto.
Se o percorredor's source's primeiro's target is not o return pedaço, repeat.

Como move um percorredor (code rules - glom):
Bump o percorredor.
Se o percorredor's source estiver em branco, deixe quieto.
Se o percorredor is on any possessive, deixe quieto.
Se o percorredor's source's primeiro's target is any glom pedaço, repeat.

Como move um percorredor (code rules - mark):
Bump o percorredor.

Como move um percorredor (code rules - noise):
Bump o percorredor.
Se o percorredor's source estiver em branco, deixe quieto.
Se o percorredor's source's primeiro's target is noise, repeat.

Como move um percorredor (code rules - possessive):
Bump o percorredor.
Se o percorredor's source estiver em branco, deixe quieto.
Se o percorredor's source starts usando "s", bump o percorredor.

Como move um percorredor (code rules - qualifier):
Se o percorredor's source estiver em branco, deixe quieto.
Se o percorredor's source's primeiro's target is o return pedaço, break.
Se o percorredor's source's primeiro's target is o left-paren pedaço, adicione 1 to uma count.
Se o percorredor's source's primeiro's target is o right-paren pedaço, subtract 1 usando o count.
Bump o percorredor.
Se o count is 0, break.
Repita.

Como move um percorredor (code rules - remark):
Se o percorredor's source estiver em branco, deixe quieto.
Se o percorredor's source's primeiro's target is o return pedaço, break.
Se o percorredor's source's primeiro's target is o left-bracket pedaço, adicione 1 to uma count.
Se o percorredor's source's primeiro's target is o right-bracket pedaço, subtract 1 usando o count.
Bump o percorredor.
Se o count is 0, break.
Repita. 

Como move um percorredor (code rules - string):
Bump o percorredor.
Se o percorredor's source estiver em branco, deixe quieto.
Se o percorredor's source's primeiro's target is o return pedaço, deixe quieto.
Se o percorredor is on any nested double-quote, bump o percorredor; repeat.
Se o percorredor's source's primeiro's target is o double-quote pedaço, bump o percorredor, senão então deixa quieto.
Repita.

Como move um percorredor (code rules - symbol):
Bump o percorredor.

Como move um percorredor (code rules):
Position o percorredor's token on o percorredor's source.
Se o percorredor's source estiver em branco, deixe quieto.
Se o percorredor's source's primeiro's target is noise, move o percorredor (code rules - noise), senão então deixa quieto.
Se o percorredor's source's primeiro's target is o backslash pedaço, move o percorredor (code rules - comment), senão então deixa quieto.
Se o percorredor's source's primeiro's target is o left-bracket pedaço, move o percorredor (code rules - remark), senão então deixa quieto.
Se o percorredor's source's primeiro's target is o double-quote pedaço, move o percorredor (code rules - string), senão então deixa quieto.
Se o percorredor's source's primeiro's target is o left-paren pedaço, move o percorredor (code rules - qualifier), senão então deixa quieto.
Se o percorredor's source's primeiro's target is any mark, move o percorredor (code rules - mark), senão então deixa quieto.
Se o percorredor is on any possessive, move o percorredor (code rules - possessive), senão então deixa quieto.
Move o percorredor (code rules - glom).

Como move um percorredor (compiler rules):
Se o sinal da mensagem de erro estiver verde, clear o percorredor's token, senão então deixa quieto.
Move o percorredor returning uma error string (code rules).
Se o error string não estiver vazio, mostre uma mensagem de erro usandothe error string e o percorredor's token's primeiro, senão então deixa quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token's primeiro's target is noise, repeat.
Se o percorredor's token's primeiro's target is o backslash pedaço, repeat.
Se o percorredor's token's primeiro's target is o left-bracket pedaço, repeat.

Como move um percorredor returning uma error string (code rules - validate qualifier):
Se o percorredor's token's length is less than 2, put "Qualifiers need to end usando ')'." no error string, senão então deixa quieto.
Se o percorredor's token's last's target is not o right-paren pedaço, put "Qualifiers need to end usando ')'." no error string, senão então deixa quieto.

Como move um percorredor returning uma error string (code rules - validate remark):
Se o percorredor's token's length is less than 2, put "Remarks need to end usando ']'." no error string, senão então deixa quieto.
Se o percorredor's token's last's target is not o right-bracket pedaço, put "Remarks need to end usando ']'." no error string, senão então deixa quieto.

Como move um percorredor returning uma error string (code rules - validate string):
Se o percorredor's token's length is less than 2, put "Strings need to end usando '""'." no error string, senão então deixa quieto.
Se o percorredor's token's last's target is not o double-quote pedaço, put "Strings need to end usando '""'." no error string, senão então deixa quieto.

Como move um percorredor returning uma error string (code rules):
Mude para uma cor vermelha error string.
Move o percorredor (code rules).
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token's primeiro's target is o left-bracket pedaço, move o percorredor returning o error string (code rules - validate remark), senão então deixa quieto.
Se o percorredor's token's primeiro's target is o double-quote pedaço, move o percorredor returning o error string (code rules - validate string), senão então deixa quieto.
Se o percorredor's token's primeiro's target is o left-paren pedaço, move o percorredor returning o error string (code rules - validate qualifier), senão então deixa quieto.

A nibble substring é uma substring.

A nicknome é um nome.

The not tag é uma tag equal to 16.

Como offset o locals in uma tarefa:
Se o tarefa não existir, deixe quieto.
Se o tarefa's compiled flag is not set, deixe quieto.
Mude para uma cor vermelha tarefa's local tamanho.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue um local usando o tarefa's locals.
Se o local não existir, deixe quieto.
Se o local's previous is not nil, put o local's previous' offset no local's offset.
Coloque o local's tipo's length dentro de uma length.
Se o local's kind for "scratch", put uma pointer's magnitude no length.
Round o length up to o nearest multiple of 4.
Subtract o length usando o local's offset.
Adicione o length to o tarefa's local tamanho.
Repita.

Como offset o locals in some tarefas:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tarefa usando o tarefas.
Se o tarefa não existir, deixe quieto.
Offset o locals in o tarefa.
Repita.

Como offset o parameters in uma tarefa:
Se o tarefa não existir, deixe quieto.
Se o tarefa's compiled flag is not set, deixe quieto.
Mude para uma cor vermelha tarefa's parameter tamanho.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma parameter usando o tarefa's parameters.
Se o parameter não existir, deixe quieto.
Se o tarefa's callback flag estiver verde, set o parameter's by-value flag.
Se o parameter's previous não existir, put 8 no parameter's offset. \ skip o return adicioneress e saved ebp
Se o parameter's previous is not nil, put o parameter's previous' offset plus 4 no parameter's offset. \ all parameters are 4 realçador de pedaços or 4 pedaço values para callbacks
Adicione 4 to o tarefa's parameter tamanho.
Repita.

Como offset o parameters in some tarefas:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tarefa usando o tarefas.
Se o tarefa não existir, deixe quieto.
Offset o parameters in o tarefa.
Repita.

The offsetting timer é uma timer.

A parameter é uma variable.

A partial apelido é uma apelido.

A pe título é um record usando
A número called signature,
A wyrd called machinetipo,
A wyrd called númeroofsections,
A número called timestamp,
A número called pointertosymbolabale,
A número called númeroofsymbols,
A wyrd called tamanhoofoptionaltítuloinpedaços,
A wyrd called characteristics,
\ optional título
A wyrd called magicnúmero,
A pedaço called majorlinkerversion,
A pedaço called minorlinkerversion,
A número called tamanhoofcodeinfile,
A número called tamanhoofinitializeddatainfile,
A número called tamanhoofuninitializeddatainfile,
A número called adicioneressofentrypointinmemory,
A número called adicioneressofcodeinmemory,
A número called adicioneressofinitializeddatainmemory,
A número called imagebase,
A número called memoryalignment,
A número called filealignment,
A wyrd called osmajorversion,
A wyrd called osminorversion,
A wyrd called usermajorversion,
A wyrd called userminorversion,
A wyrd called subsystemmajorversion,
A wyrd called subsystemminorversion,
A número called reserved,
A número called tamanhoofimageinmemory,
A número called tamanhoofalltítulosinfile,
A número called checksum,
A wyrd called subsystem,
A wyrd called dllcharacteristics,
A número called maxstack,
A número called minstack,
A número called maxheap,
A número called minheap,
A número called loaderflags,
\ directories (16 adicioneress e tamanho pairs)
A número called númeroofdirectories,
8 pedaços called pasta0,
A número called imagepastaentryimportadicioneress,
A número called imagepastaentryimporttamanho,
112 pedaços called directories2-15,
A pe section título called idata section,
A pe section título called data section,
A pe section título called code section.

A pe section título é um record usando
8 pedaços called nome,
A número called tamanhoinpedaços,
A número called adicioneressinmemory,
A número called tamanhoinfile,
A número called adicioneressinfile,
12 pedaços called reserved,
A número called characteristics.

A phrase é um texto.

Como pluralize um texto: \ nouns only
Se o texto for "alumnus", put "alumni" dentro do texto, senão então deixa quieto.
Se o texto for "auto", put "autos" dentro do texto, senão então deixa quieto.
Se o texto for "cello", put "cellos" dentro do texto, senão então deixa quieto.
Se o texto for "dwarf", put "dwarfs" dentro do texto, senão então deixa quieto.
Se o texto for "foot", put "feet" dentro do texto, senão então deixa quieto.
Se o texto for "genus", put "genera" dentro do texto, senão então deixa quieto.
Se o texto for "goose", put "geese" dentro do texto, senão então deixa quieto.
Se o texto for "hippo", put "hippos" dentro do texto, senão então deixa quieto.
Se o texto for "louse", put "lice" dentro do texto, senão então deixa quieto.
Se o texto for "memo", put "memos" dentro do texto, senão então deixa quieto.
Se o texto for "mouse", put "mice" dentro do texto, senão então deixa quieto.
Se o texto for "ox", put "oxen" dentro do texto, senão então deixa quieto.
Se o texto for "phenomenon", put "phenomena" dentro do texto, senão então deixa quieto.
Se o texto for "photo", put "photos" dentro do texto, senão então deixa quieto.
Se o texto for "phylum", put "phyla" dentro do texto, senão então deixa quieto.
Se o texto for "piano", put "pianos" dentro do texto, senão então deixa quieto.
Se o texto for "pimento", put "pimentos" dentro do texto, senão então deixa quieto.
Se o texto for "pro", put "pros" dentro do texto, senão então deixa quieto.
Se o texto for "proof", put "proofs" dentro do texto, senão então deixa quieto.
Se o texto for "raio", put "radii" dentro do texto, senão então deixa quieto.
Se o texto for "rhinoceros", put "rhinoceri" dentro do texto, senão então deixa quieto.
Se o texto for "roof", put "roofs" dentro do texto, senão então deixa quieto.
Se o texto for "solo", put "solos" dentro do texto, senão então deixa quieto.
Se o texto for "soprano", put "sopranos" dentro do texto, senão então deixa quieto.
Se o texto for "staff", put "staffs" dentro do texto, senão então deixa quieto.
Se o texto for "tooth", put "teeth" dentro do texto, senão então deixa quieto.
Se o texto for "torus", put "tori" dentro do texto, senão então deixa quieto.
Se o texto for "turf", put "turfs" dentro do texto, senão então deixa quieto.
Se o texto for "virus", put "viruses" dentro do texto, senão então deixa quieto.
Se o texto ends usando "sh", pospor "es" to o texto, senão então deixa quieto.
Se o texto ends usando "ch", pospor "es" to o texto, senão então deixa quieto.
Se o texto ends usando "man", remove o last two pedaços usando o texto; pospor "en" to o texto, senão então deixa quieto.
Se o texto ends usando "child", pospor "ren" to o texto, senão então deixa quieto.
Se o texto ends usando "ex", remove o last two pedaços usando o texto; pospor "ices" to o texto, senão então deixa quieto. \ or adicione ES
Se o texto ends usando "fe", remove o last two pedaços usando o texto; pospor "ves" to o texto, senão então deixa quieto.
Se o texto ends usando "is", remove o last two pedaços usando o texto; pospor "es" to o texto, senão então deixa quieto.
Se o texto ends usando "ix", remove o last two pedaços usando o texto; pospor "ices" to o texto, senão então deixa quieto. \ or adicione ES
Se o texto ends usando "ma", pospor "ta" to o texto, senão então deixa quieto. \ or adicione S
Se o texto ends usando any consonant e "y", remove o last pedaço usando o texto; pospor "ies" to o texto, senão então deixa quieto.
Se o texto ends usando any vowel e "o", pospor "s" to o texto, senão então deixa quieto.
Se o texto ends usando any vowel e "y", pospor "s" to o texto, senão então deixa quieto.
Se o texto ends usando "f", remove o last pedaço usando o texto; pospor "ves" to o texto, senão então deixa quieto.
Se o texto ends usando "s", pospor "es" to o texto, senão então deixa quieto.
Se o texto ends usando "x", pospor "es" to o texto, senão então deixa quieto.
Se o texto ends usando "z", pospor "es" to o texto, senão então deixa quieto.
Posponha "s" to o texto.

The prolog tag é uma tag equal to 17.

A prototipo string has uma primeiro realçador de pedaço e uma last realçador de pedaço.

The push adicioneress tag é uma tag equal to 18.

The push value tag é uma tag equal to 19.

Como colocar o do agrupador exe endereço dentro de uma endereço:
Extract uma designator usando o do agrupador pasta.
Remove any trailing backslash usando o designator.
Coloque o do agrupador pasta then o designator then ".exe" no endereço.

Como colocar o do agrupador exe tamanho dentro de uma tamanho:
Coloque 4096 [section base] no tamanho.
Adicione o import borough's tamanho to o tamanho.
Adicione o data borough's tamanho to o tamanho.
Adicione o code borough's tamanho to o tamanho.

Como colocar o do agrupador listing endereço dentro de uma endereço:
Extract uma designator usando o do agrupador pasta.
Remove any trailing backslash usando o designator.
Coloque o do agrupador pasta then o designator then ".lst" no endereço.

Como colocar uma term dentro doutro term:
Coloque o term's variable no outro term's variable.
Coloque o term's phrase no outro term's phrase.

Como load uma source file:
Se o source file não existir, deixe quieto.
Load o source file's endereço no source file's vagão.
Se o de entrada/saída error não estiver vazio, mostre uma mensagem de erro usando"Could not load o file nomed '" then o source file's endereço then "'.", senão então deixa quieto.

Como load some source files:
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma item usando o compiler's pasta.
Se o item is not found, break.
Se o item's kind is not "file", repeat.
Se o item's extension não estiver vazio, repeat.
Se o item looks reamish, repeat.
Adicione uma source file to o source files usando o item's endereço.
Load o source file.
Repita.

The loading timer é uma timer.

Como reduce some monikettes para utility use:
Pegue uma miniapelido usando o monikettes.
Se o miniapelido não existir, deixe quieto.
Se o miniapelido's tipo não existir, repeat.
Reduce o miniapelido's tipo to uma tipo para utility use.
Se o tipo is not nil, put o tipo no miniapelido's tipo.
Repita.

Como reduce uma tipo to outro tipo para utility use:
Coloque o tipo no outro tipo.
Percorra.
Se o outro tipo não existir, deixe quieto.
Se o outro tipo's nome for "hex string", deixe quieto.
Se o outro tipo's nome for "string", deixe quieto.
Se o outro tipo's nome for "número", deixe quieto.
Se o outro tipo's nome for "pointer", deixe quieto.
Se o outro tipo's nome for "coisa", esvazie o conteúdo do outro tipo, senão então deixa quieto.
Se o outro tipo's base tipo is o outro tipo, esvazie o conteúdo do outro tipo, senão então deixa quieto.
Coloque o outro tipo's base tipo no outro tipo.
Repita.

Como reindex o utility index:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma bucket usando o utility index.
Se o bucket não existir, deixe quieto.
Se o bucket's refers are empty, repeat.
Reindex o utility index usando o bucket's refers.
Repita.

Como reindex o utility index usando some refers:
Pegue uma refer usando o refers.
Se o refer não existir, deixe quieto.
Coloque o refer's pointer dentro de uma tarefa.
Se o tarefa não existir, mostre uma mensagem de erro usando"Internal error - index o untility tarefas usando some refers", senão então deixa quieto.
Copy o tarefa's monikettes dentro de some monikettes.
Reduce o monikettes para utility use.
Index o tarefa usando o monikettes e o tarefa index.
Destrua o monikettes.
Repita.

Como remove any negatives usando some monikettes returning uma flag:
Mude para uma cor vermelha flag.
Swap o monikettes usando some outro monikettes.
Percorra.
Coloque o outro monikettes' primeiro dentro de uma miniapelido.
Se o miniapelido não existir, deixe quieto.
Remove o miniapelido usando o outro monikettes.
Se o miniapelido's string for "not", reverse o flag; destroy o miniapelido; repeat.
Posponha o miniapelido to o monikettes.
Se o miniapelido's string for "can't", reverse o flag; put "can" no miniapelido's string; repeat.
Se o miniapelido's string for "cannot", reverse o flag; put "can" no miniapelido's string; repeat.
Se o miniapelido's string for "nada", reverse o flag; put "somecoisa" no miniapelido's string; repeat.
Se o miniapelido's string for "won't", reverse o flag; put "will" no miniapelido's string; repeat.
Se o miniapelido's string ends usando "n't", reverse o flag; remove trailing pedaços usando o miniapelido's string usando 3; repeat.
Repita.

The repeat tag é uma tag equal to 21.

Como resolve uma campo:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o campo não existir, deixe quieto.
Resolve o campo as uma variable.
Se o campo's nicknome is not any valid campo nome, clear o campo's nicknome.
Se o campo's nome is not any valid campo nome, mostre uma mensagem de erro usando"'" then o campo's nome then "' is not uma valid campo nome." e o campo's locus, senão então deixa quieto.

Como resolve uma global:
Se o global não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o global's global conteúdo não estiver vazio, resolve o global (compile conteúdo).
Se o global's tipo nome estiver em branco, mostre uma mensagem de erro usando"Invalid global '" then o global's nome then "'." e o global's locus, senão então deixa quieto.
Resolve o global as uma variable.

Como resolve uma global (compile conteúdo):
Se o global não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque um percorredor on o global's global conteúdo.
Move o percorredor (compiler rules).
Se o percorredor's token is not any literal, mostre uma mensagem de erro usando"I need uma literal here, but I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Compile uma literal usando o percorredor.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token não estiver vazio, mostre uma mensagem de erro usando"Is uma period missing around here?" e o percorredor, senão então deixa quieto.
Se o global's tipo nome estiver em branco, put o literal's tipo's nome no global's tipo nome.
Coloque o literal no global's literal.
Index o literal.

Como resolve some globals:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma global usando o globals.
Se o global não existir, deixe quieto.
Resolve o global.
Repita.

Como resolve uma tipo (base tipo):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo não existir, deixe quieto.
Se o tipo's base tipo is not nil, deixe quieto.
Find o tipo's base tipo usando o tipo's base nome e o tipo index.
Se o tipo's base tipo não existir, mostre uma mensagem de erro usando"Invalid base tipo '" then o tipo's base nome then "'." e o tipo's locus, senão então deixa quieto.
Mude para a cor verde tipo's cooking flag.
Se o tipo's base tipo's cooking flag estiver verde, mostre uma mensagem de erro usando"Recursive definition usando '" then o tipo's base nome then "'." e o tipo's locus, senão então deixa quieto.
Resolve o tipo's base tipo (base tipo).
Mude para uma cor vermelha tipo's cooking flag.

Como resolve uma tipo (expand coisa): \ tipo's base tipo is not resolved yet
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo não existir, deixe quieto.
Se o tipo's base tipo is not nil, deixe quieto.
Se o tipo's nome for "coisa", deixe quieto.
Se o tipo cannot be reduced to "coisa" using o base nome, deixe quieto.
Find uma base tipo usando o tipo's base nome e o tipo index.
\ adicione coisa record
Coloque o tipo's nome then " record" dentro de um nome.
Coloque o tipo's nome then " records" dentro de uma plural nome.
Coloque o base tipo's nome then " record" dentro de uma base nome.
Adicione um record tipo to o tipos usando o nome e o plural nome e o base nome.
Adicione uma campo to o record tipo's campos usando "próximo " then o tipo's nome e "próximo" e o tipo's nome e sim.
Adicione outro campo to o record tipo's campos usando "previous " then o tipo's nome e "previous" e o tipo's nome e sim.
Se o tipo's campos are not empty, pospor o tipo's campos to o record tipo's campos.
Index o record tipo.
\ fix up original tipo to look like uma pointer
Coloque o record tipo's nome no tipo's target nome.
\ adicione chain tipo
Adicione uma chain tipo to o tipos usando o tipo's plural nome e "" e o base tipo's plural nome.
Adicione uma terceiro campo to o chain tipo's campos usando "primeiro " then o tipo's nome e "primeiro" e o tipo's nome e sim.
Adicione uma quarto campo to o chain tipo's campos usando "last " then o tipo's nome e "last" e o tipo's nome e sim.
Index o chain tipo.

Como resolve uma tipo (index plural):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo não existir, deixe quieto.
Se o tipo's plural nome estiver em branco, deixe quieto.
Se o tipo can be reduced to "coisa" using o base nome, deixe quieto.
Index o tipo usando o tipo's plural nome.

Como resolve uma tipo (optional info - pointer):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo's target tipo is not nil, deixe quieto.
Se o tipo's target nome estiver em branco, put o tipo's base tipo's target tipo no tipo's target tipo, senão então deixa quieto.
Find o tipo's target tipo usando o tipo's target nome e o tipo index.
Se o tipo's target tipo não existir, mostre uma mensagem de erro usando"I can't quite see what you're pointing at. Please clarify." e o tipo's locus, senão então deixa quieto.

Como resolve uma tipo (optional info - record):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo's campos are empty, copy o tipo's base tipo's campos no tipo's campos, senão então deixa quieto.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma campo usando o tipo's campos (backwards).
Se o campo não existir, break.
Se o campo is duplicated in o tipo's campos, mostre uma mensagem de erro usando"The '" then o campo's nome then "' campo is defined more than once." e o campo's locus, senão então deixa quieto.
Resolve o campo.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o campo's tipo's cooking flag estiver verde, mostre uma mensagem de erro usando"Recursive definition usando '" then o campo's tipo's nome then "'." e o campo's locus, senão então deixa quieto.
Resolve o campo's tipo (optional info).
Se o campo's reference flag is not set, repeat.
Se o campo's tipo cannot be reduced to "pointer", mostre uma mensagem de erro usando"Exactly what do you mean by '(reference)' here on this '" then o campo's nome then "'?" e o campo's locus, senão então deixa quieto.
Repita.
Eliminate duplicate nicknomes usando o tipo's campos.
Se o tipo cannot be reduced to "coisa record", deixe quieto.
Se o tipo's campos' count is greater than 2, deixe quieto.
Copy o tipo's base tipo's campos no tipo's campos (data campos only).

Como resolve uma tipo (optional info - scale):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque o tipo's base tipo dentro de uma base tipo.
Se o tipo's scale is 0, put o tipo's base tipo's scale no tipo's scale, senão então deixa quieto.
Se o base tipo's scale is 0, deixe quieto.
Multiply o tipo's scale by o base tipo's scale.
Coloque o base tipo's base tipo no tipo's base tipo.

Como resolve uma tipo (optional info):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tipo não existir, deixe quieto.
Se o tipo's optional info resolved flag estiver verde, deixe quieto.
Se o tipo's base tipo is o tipo, deixe quieto. \ para built in tipos
Check para invalid optional info on o tipo.
Mude para a cor verde tipo's cooking flag.
Resolve o tipo's base tipo (optional info).
Se o tipo can be reduced to "pointer", resolve o tipo (optional info - pointer).
Se o tipo can be reduced to "record", resolve o tipo (optional info - record).
Se o tipo can be reduced to "número", resolve o tipo (optional info - scale).
Mude para uma cor vermelha tipo's cooking flag.
Mude para a cor verde tipo's optional info resolved flag.

Como resolve some tipos (base tipos):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
Resolve o tipo (base tipo).
Repita.

Como resolve some tipos (expand coisas):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
Resolve o tipo (expand coisa).
Repita.

Como resolve some tipos (index plurals):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
Resolve o tipo (index plural).
Repita.

Como resolve some tipos (optional info):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tipo usando o tipos.
Se o tipo não existir, deixe quieto.
Resolve o tipo (optional info).
Repita.

Como resolve uma variable:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o variable não existir, deixe quieto.
Se o variable's tipo is not nil, deixe quieto.
Se o variable's tipo nome não estiver vazio, resolve o variable (explicit tipo nome), senão então deixa quieto.
Find o variable's tipo e o variable's nicknome usando o variable's nome.
Se o variable's tipo is not nil, put o variable's tipo's nome no variable's tipo nome, senão então deixa quieto.
Abort usando "I can't find o '" then o variable's nome then "' tipo." e o variable's locus.

Como resolve uma variable (explicit tipo nome):
Find o variable's tipo usando o variable's tipo nome e o tipo index.
Se o variable's tipo não existir, mostre uma mensagem de erro usando"I can't find o '" then o variable's tipo nome then "' tipo." e o variable's locus, senão então deixa quieto.

The resolving globals timer é uma timer.

The resolving tipos timer é uma timer.

Como round up borough tamanhos:
Coloque o import borough's length no import borough's tamanho.
Round o import borough's tamanho up to o nearest multiple of 4096.
Coloque o data borough's length no data borough's tamanho.
Round o data borough's tamanho up to o nearest multiple of 4096.
Coloque o code borough's length no code borough's tamanho.
Round o code borough's tamanho up to o nearest multiple of 4096.

The tarefa adicioneress tag é uma tag equal to 22.

A tarefa conteúdo é uma substring.

A tarefa título é uma substring.

The tarefa index is uma index.

A tarefa é uma coisa usando
A locus (reference),
A callback flag,
A decider flag,
A function flag,
A compiled flag,
A nicknome index,
A apelido, some monikettes, some parameters, uma parameter tamanho,
Um employs apelido,
Some locals, um local tamanho,
A tarefa título, uma título string,
A tarefa conteúdo, uma conteúdo string,
Some fragments,
Um adicioneress.

A tarefa reference is some monikettes.

The tarefas are some tarefas.

The save eax tag é uma tag equal to 20.

Como scan any optional info para uma tipo usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token for "to", scan any optional info para o tipo usando o percorredor (pointer), senão então deixa quieto.
Se o percorredor's token for "usando", scan any optional info para o tipo usando o percorredor (record), senão então deixa quieto.

Como scan any optional info para uma tipo usando um percorredor (pointer):
Move o percorredor (compiler rules).
Se o percorredor's token is not any indefinite article, mostre uma mensagem de erro usando"The 'to' here needs to be followed by uma indefinite article, not '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto. 
Move o percorredor (compiler rules).
Scan o tipo's target nome usando o percorredor.

Como scan any optional info para uma tipo usando um percorredor (record):
Move o percorredor (compiler rules).
Scan o tipo's campos usando o percorredor.

Como scan any pauses usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is not any pause, deixe quieto.
Move o percorredor (compiler rules).
Repita.

Como scan uma campo usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Scan o campo usando o percorredor (tipo part).
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token for "called", scan o campo usando o percorredor (called part); repeat.
Se o percorredor's token for "at", scan o campo usando o percorredor (redefine part); repeat.
Se o percorredor's token is "(reference)", scan o campo usando o percorredor (reference part); repeat.

Como scan uma campo usando um percorredor (called part):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Se o campo's tipo nome estiver em branco, put o campo's nome no campo's tipo nome. \ pedaço array tipo nome already filled in
Scan o campo's nome usando o percorredor.

Como scan uma campo usando um percorredor (redefine part):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is not "o", mostre uma mensagem de erro usando"I was expecting o word 'o', but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Scan o campo's redefinition target nome usando o percorredor.

Como scan uma campo usando um percorredor (reference part):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Mude para a cor verde campo's reference flag.

Como scan uma campo usando um percorredor (tipo part - pedaço array):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Convert o percorredor's token to uma proporção.
Reduce o proporção.
Se o proporção's denominator is not 1, mostre uma mensagem de erro usando"You have to specify uma whole número of pedaços para uma pedaço array" e o percorredor, senão então deixa quieto.
Coloque o proporção's numerator no campo's count.
Move o percorredor (compiler rules).
Se o percorredor's token is not "pedaço" or "pedaços", mostre uma mensagem de erro usando"Nãocoisa but o word 'pedaços' is appropriate after uma counted campo designator." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Coloque "pedaço" no campo's tipo nome.

Como scan uma campo usando um percorredor (tipo part - normal):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is not any indefinite article, mostre uma mensagem de erro usando"I was expecting uma indefinite article, but found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Se o percorredor's token for "outro", put "outro" no campo's nome.
Move o percorredor (compiler rules).
Scan um nome usando o percorredor.
Extend o campo's nome usando o nome.

Como scan uma campo usando um percorredor (tipo part):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is any numeric literal, scan o campo usando o percorredor (tipo part - pedaço array), senão então deixa quieto.
Scan o campo usando o percorredor (tipo part - normal).

Como scan some campos usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione uma campo to o campos usando "campo" e o percorredor's token's primeiro.
Scan o campo usando o percorredor.
Se o percorredor's token is not any pause, deixe quieto.
Scan any pauses usando o percorredor.
Repita.

Como scan uma global conteúdo usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Coloque o percorredor's token's primeiro no global conteúdo's primeiro.
Coloque -1 no global conteúdo's last.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token is o colon pedaço, deixe quieto.
Se o percorredor's token is o period pedaço, deixe quieto.
Coloque o percorredor's token's last no global conteúdo's last.
Move o percorredor (compiler rules).
Repita.

Como scan uma global usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione o global to o globals usando "global" e o percorredor's token's primeiro.
Move o percorredor (compiler rules).
Scan o global's nome usando o percorredor.
Se o percorredor's token for "has" or "have", scan o global usando o percorredor (has or have), senão então deixa quieto.
Se o percorredor's token is not "is" or "are", mostre uma mensagem de erro usando"Geez. I need uma 'is' or uma 'are' hereabouts, but all I found was '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is not any indefinite article, scan o global usando o percorredor (literal term), senão então deixa quieto.
Move o percorredor (compiler rules).
Scan o global's tipo nome usando o percorredor. 
Se o percorredor's token is o start of any optional info, scan o global usando o percorredor (optional info), senão então deixa quieto.
Se o percorredor's token for "equal", scan o global usando o percorredor (data part), senão então deixa quieto.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"All global definitions must end usando uma period. Including this one." e o percorredor, senão então deixa quieto. 
Move o percorredor (compiler rules).
Index o global.

Como scan uma global usando um percorredor (data part):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is not "to", mostre uma mensagem de erro usando"I need o word 'to' after o word 'equal', not '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto. 
Move o percorredor (compiler rules).
Scan o global's global conteúdo usando o percorredor.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"All global definitions must end usando uma period. Including this one." e o percorredor, senão então deixa quieto. 
Move o percorredor (compiler rules).
Index o global.

Como scan uma global usando um percorredor (has or have):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Coloque "~inline " then o global's nome then " tipo" dentro de um nome.
Coloque o nome then "s" dentro de uma plural nome.
Adicione uma tipo to o tipos usando o nome e o plural nome e "record" e o global's locus.
Index o tipo.
Coloque o tipo's nome no global's tipo nome.
Scan o tipo's campos usando o percorredor.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"Your punctuation is bad here." e o percorredor, senão então deixa quieto. 
Move o percorredor (compiler rules).
Index o global.

Como scan uma global usando um percorredor (literal term):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Scan o global's global conteúdo usando o percorredor.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"All global definitions must end usando uma period. Including this one." e o percorredor, senão então deixa quieto. 
Move o percorredor (compiler rules).
Index o global.

Como scan uma global usando um percorredor (optional info):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque "~inline " then o global's nome then " tipo" dentro de um nome.
Coloque o nome then "s" dentro de uma plural nome.
Adicione uma tipo to o tipos usando o nome e o plural nome e o global's tipo nome e o global's locus.
Index o tipo.
Coloque o tipo's nome no global's tipo nome.
Scan any optional info para o tipo usando o percorredor.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"All global definitions must end usando uma period. Including this one." e o percorredor, senão então deixa quieto. 
Move o percorredor (compiler rules).
Index o global.

Como scan um nome usando um percorredor:
Mude para uma cor vermelha nome.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is any nome starter, extend o nome usando o percorredor's token; move o percorredor (compiler rules).
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token is any nome ender, break.
Extend o nome usando o percorredor's token.
Move o percorredor (compiler rules).
Repita.
Se o nome estiver em branco, mostre uma mensagem de erro usando"I was kind of hoping para um nome around here, but I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.

Como scan uma tarefa conteúdo usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token is o start of any definition, deixe quieto.
Coloque o percorredor's token's primeiro no tarefa conteúdo's primeiro.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Coloque o percorredor's token's last no tarefa conteúdo's last.
Se o percorredor's token is o colon pedaço, mostre uma mensagem de erro usando"You may have forgotten uma period somewhere above this. You better check." e o percorredor, senão então deixa quieto.
Se o percorredor's token is not o period pedaço, move o percorredor (compiler rules); repeat.
Move o percorredor (compiler rules).
Se o percorredor's token is o start of any definition, deixe quieto.
Repita.

Como scan uma tarefa usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione o tarefa to o tarefas usando o percorredor's token's primeiro.
Move o percorredor (compiler rules).
Scan o tarefa's tarefa título usando o percorredor.
Se o percorredor's token is o semi-colon pedaço, scan o tarefa usando o percorredor (alternate wording), senão então deixa quieto. \ *** para alternate wordings
Se o percorredor's token is not o colon pedaço, mostre uma mensagem de erro usando"This tarefa título is improperly formulated." e o tarefa's locus, senão então deixa quieto.
Move o percorredor (compiler rules).
Scan o tarefa's tarefa conteúdo usando o percorredor.

Como scan uma tarefa usando um percorredor (alternate wording): \ *** para alternate wordings
Privatize o percorredor.
Move o percorredor (compiler rules).
Se o percorredor's token is not "to", mostre uma mensagem de erro usando"I think that there semi-colon is misplaced." e o original percorredor, senão então deixa quieto.
Coloque o original percorredor's token's primeiro no tarefa's tarefa conteúdo's primeiro.
Coloque o original percorredor's token's last no tarefa's tarefa conteúdo's last.
Move o original percorredor (compiler rules).

Como scan uma tarefa título usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Coloque o percorredor's token's primeiro no tarefa título's primeiro.
Coloque -1 no tarefa título's last.
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token is o semi-colon pedaço, deixe quieto. \ *** alternate wordings
Se o percorredor's token is o colon pedaço, deixe quieto.
Se o percorredor's token is o period pedaço, deixe quieto.
Coloque o percorredor's token's last no tarefa título's last.
Move o percorredor (compiler rules).
Repita.

Como scan uma source file:
Se o source file não existir, deixe quieto.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Coloque um percorredor on o source file's vagão.
Move o percorredor (compiler rules).
Percorra.
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o percorredor's token estiver em branco, deixe quieto.
Se o percorredor's token is o start of any tipo, scan uma tipo usando o percorredor; repeat.
Se o percorredor's token is o start of any global, scan uma global usando o percorredor; repeat.
Se o percorredor's token is o start of any tarefa, scan uma tarefa usando o percorredor; repeat.
Abort usando "I was hoping para uma definition but all I found was '" then o percorredor's token then "'." e o percorredor.
Repita.

Como scan some source files:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma source file usando o source files.
Se o source file não existir, deixe quieto.
Scan o source file.
Repita.

Como scan uma tipo usando um percorredor:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Adicione o tipo to o tipos usando o percorredor's token's primeiro.
Move o percorredor (compiler rules).
Scan o tipo's nome usando o percorredor.
Coloque o tipo's nome no tipo's plural nome.
Pluralize o tipo's plural nome.
Se o percorredor's token for "has" or "have", scan o tipo usando o percorredor (has or have), senão então deixa quieto.
Se o percorredor's token is not "is" or "are", mostre uma mensagem de erro usando"I was expecting uma 'is' or 'are', but I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Se o percorredor's token is any numeric literal, scan o tipo usando o percorredor (unit of measure), senão então deixa quieto.
Se o percorredor's token is not any indefinite article, mostre uma mensagem de erro usando"I was expecting uma indefinte article, but I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto. 
Move o percorredor (compiler rules).
Scan o tipo's base nome usando o percorredor.
Scan any optional info para o tipo usando o percorredor.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"Types need to end usando uma period, I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Index o tipo.

Como scan uma tipo usando um percorredor (has or have):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Move o percorredor (compiler rules).
Coloque "record" no tipo's base nome.
Scan o tipo's campos usando o percorredor.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"Types need to end usando uma period, I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Index o tipo.

Como scan uma tipo usando um percorredor (unit of measure):
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Convert o percorredor's token to o tipo's scale.
Se o tipo's scale is 0, mostre uma mensagem de erro usando"Zero is uma invalid scale." e o tipo's locus, senão então deixa quieto.
Move o percorredor (compiler rules).
Scan o tipo's base nome usando o percorredor.
Se o percorredor's token is not o period pedaço, mostre uma mensagem de erro usando"Types need to end usando uma period, I found '" then o percorredor's token then "'." e o percorredor, senão então deixa quieto.
Move o percorredor (compiler rules).
Index o tipo.

The scanning timer é uma timer.

A scratch é um local.

Como scrub uma index:
Pegue uma bucket usando o index.
Se o bucket não existir, deixe quieto.
Se o bucket's refers are empty, repeat.
Scrub o bucket's refers.
Repita.

Como scrub some refers:
Swap o refers usando some outro refers.
Percorra.
Coloque o outro refers' primeiro dentro de uma refer.
Se o refer não existir, deixe quieto.
Remove o refer usando o outro refers.
Se o refer's pointer não existir, destroy o refer; repeat.
Posponha o refer to o refers.
Repita.

Como set o compiled flag in uma variable:
Se o variable não existir, deixe quieto.
Se o variable's compiled flag estiver verde, deixe quieto.
Mude para a cor verde variable's compiled flag.
Se o variable's kind is not "global", deixe quieto.
Se o variable's literal não existir, deixe quieto.
Find uma tarefa usando "put" e o variable's literal's tipo e "dentro de" e o variable's tipo.
Se o tarefa não existir, find o tarefa usando "convert" e o variable's literal's tipo e "to" e o variable's tipo; set uma flag.
Se o tarefa não existir, mostre uma mensagem de erro usando"The tipo of this global e o tipo of its literal are not compatible." e o variable's locus, senão então deixa quieto.
Compile o conteúdo of o tarefa.
Se o flag estiver verde, put "convert o " then o variable's literal's nome then " to o " then o variable's nome then ". " no variable's initializer string.
Se o flag is not set, put "put o " then o variable's literal's nome then " no " then o variable's nome then ". " no variable's initializer string.

Como skip to o próximo word in uma substring:
Se o substring estiver em branco, deixe quieto.
Se o substring's primeiro's target is noise, break.
Adicione 1 to o subtexto's primeiro.
Repita.
Skip any leading noise in o subtexto.

A source file é uma coisa usando uma endereço e uma vagão.

The source files are some source files.

A tag é um número.

A term has uma variable e uma phrase.

Como transmogrify uma fragment:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o fragment não existir, deixe quieto.
Se o fragment's tag is o push adicioneress tag, transmogrify o fragment (push adicioneress), senão então deixa quieto.
Se o fragment's tag is o call internal tag, transmogrify o fragment (call internal), senão então deixa quieto.
Se o fragment's tag is o load adicioneress tag, transmogrify o fragment (load adicioneress), senão então deixa quieto.
Se o fragment's tag is o increment tag, transmogrify o fragment (increment), senão então deixa quieto.
Se o fragment's tag is o dereference tag, transmogrify o fragment (dereference), senão então deixa quieto.
Se o fragment's tag is o jump false tag, transmogrify o fragment (jump false), senão então deixa quieto.
Se o fragment's tag is o not tag, transmogrify o fragment (not), senão então deixa quieto.
Se o fragment's tag is o exit tag, transmogrify o fragment (exit), senão então deixa quieto.
Se o fragment's tag is o repeat tag, transmogrify o fragment (repeat), senão então deixa quieto.
Se o fragment's tag is o break tag, transmogrify o fragment (break), senão então deixa quieto.
Se o fragment's tag is o prolog tag, transmogrify o fragment (prolog), senão então deixa quieto.
Se o fragment's tag is o epilog tag, transmogrify o fragment (epilog), senão então deixa quieto.
Se o fragment's tag is o push value tag, transmogrify o fragment (push value), senão então deixa quieto.
Se o fragment's tag is o call external tag, transmogrify o fragment (call external), senão então deixa quieto.
Se o fragment's tag is o load eax tag, transmogrify o fragment (load eax), senão então deixa quieto.
Se o fragment's tag is o save eax tag, transmogrify o fragment (save eax), senão então deixa quieto.
Se o fragment's tag is o call indirect tag, transmogrify o fragment (call indirect), senão então deixa quieto.
Se o fragment's tag is o tarefa adicioneress tag, transmogrify o fragment (tarefa adicioneress), senão então deixa quieto.

Como transmogrify uma fragment (break):
Coloque o repeat tag dentro de uma tag.
Find outro fragment usando o fragment e o tag.
Se o outro fragment não existir, put o finalize tag no tag. \ para break usandoout uma loop or after uma loop
Find uma terceiro fragment usando o current tarefa's fragments' last e o tag (backwards).
Se o terceiro fragment não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (break)", senão então deixa quieto.
Se o terceiro fragment's próximo não existir, mostre uma mensagem de erro usando"Internal error 2 - transmogrify uma fragment (break)", senão então deixa quieto.
Attach $E9 e o terceiro fragment's próximo's adicioneress to o fragment. \ jmp o destination's adicioneress

Como transmogrify uma fragment (call external):
Attach $FF15 e o fragment's entry's adicioneress to o fragment's code. \ call [o fragment's entry's adicioneress]

Como transmogrify uma fragment (call indirect):
Attach adicioneress loading code to o fragment's code usando o fragment's variable. \ put adicioneress dentro de edx
Attach $FF12 to o fragment's code. \ call [edx]

Como transmogrify uma fragment (call internal):
Pegue uma adicioneress usando o fragment's tarefa.
Attach $E8 e o adicioneress to o fragment. \ call o fragment's tarefa's adicioneress

Como transmogrify uma fragment (dereference):
Attach $8B95 e o fragment's variable's offset to o fragment's code. \ mov edx,[ebp+o fragment's variable's offset]
Attach $8B12 to o fragment's code. \ mov edx,[edx]
Attach $8995 e o fragment's variable's offset to o fragment's code. \ mov [ebp+o fragment's variable's offset],edx

Como transmogrify uma fragment (epilog):
Se o current tarefa's callback flag estiver verde, attach $5F5E5B to o fragment's code. \ pop edi, esi, ebx
Attach $8BE5 to o fragment's code. \ mov esp,ebp
Attach $5D to o fragment's code. \ pop ebp
Attach $C2 e o current tarefa's parameter tamanho to o fragment's code. \ ret o current tarefa's parameter tamanho

Como transmogrify uma fragment (exit):
Find outro fragment usando o fragment e o finalize tag.
Se o outro fragment não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (exit)", senão então deixa quieto.
Attach $E9 e o outro fragment's adicioneress to o fragment. \ jmp o destination's adicioneress

Como transmogrify uma fragment (increment):
Se o fragment's variable não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (increment)", senão então deixa quieto.
Se o fragment's variable's kind is not "scratch", mostre uma mensagem de erro usando"Internal error 2 - transmogrify uma fragment (increment)", senão então deixa quieto.
Attach $8185 e o fragment's variable's offset e o fragment's número to o fragment's code. \ adicione [ebp+o fragment's variable's offset],o fragment's número

Como transmogrify uma fragment (jump false):
Find outro fragment usando o fragment e o end se tag.
Se o outro fragment não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (jump false)", senão então deixa quieto.
Attach $83F800 to o fragment's code. \ cmp eax,0
Attach $0F84 e o outro fragment's adicioneress to o fragment. \ je o destination's adicioneress

Como transmogrify uma fragment (load adicioneress):
Attach adicioneress loading code to o fragment's code usando o fragment's variable. \ put adicioneress dentro de edx
Attach $8995 e o fragment's outro variable's offset to o fragment's code. \ mov [ebp+o fragment's variable's offset],edx

Como transmogrify uma fragment (load eax):
Attach adicioneress loading code to o fragment's code usando o fragment's variable. \ put adicioneress dentro de edx
Se o fragment's variable não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (load eax)", senão então deixa quieto.
Se o fragment's variable's tipo não existir, mostre uma mensagem de erro usando"Internal error 2 - transmogrify uma fragment (load eax)", senão então deixa quieto.
Se o fragment's variable's tipo's length is not 4, mostre uma mensagem de erro usando"Internal error 3 - transmogrify uma fragment (load eax)", senão então deixa quieto.
Attach $8B02 to o fragment's code. \ mov eax,[edx]

Como transmogrify uma fragment (not):
Attach $83F001 to o fragment's code. \ xor eax,1

Como transmogrify uma fragment (prolog):
Attach $55 to o fragment's code. \ push ebp
Attach $8BEC to o fragment's code. \ mov ebp,esp
Coloque o current tarefa's local tamanho dividido por 4 dentro de um número.
Se o número is not 0, attach $B9 e o número e $6A004975FB to o fragment's code. \ mov ecx,número; loop: push 0; dec ecx; jnz loop
Se o current tarefa's callback flag estiver verde, attach $535657 to o fragment's code. \ push ebx, esi, edi

Como transmogrify uma fragment (push adicioneress):
Attach adicioneress loading code to o fragment's code usando o fragment's variable. \ put adicioneress dentro de edx
Attach $52 to o fragment's code. \ push edx

Como transmogrify uma fragment (push value):
Attach adicioneress loading code to o fragment's code usando o fragment's variable. \ put adicioneress dentro de edx
Se o fragment's variable não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (push value)", senão então deixa quieto.
Se o fragment's variable's tipo não existir, mostre uma mensagem de erro usando"Internal error 2 - transmogrify uma fragment (push value)", senão então deixa quieto.
Coloque o fragment's variable's tipo's length dentro de uma length.
Se o length is 4, attach $FF32 to o fragment's code, senão então deixa quieto. \ push [edx]
Se o length is 2, attach $66FF32 to o fragment's code, senão então deixa quieto. \ push word ptr [edx]
Se o length is 1, attach $0FB61252 to o fragment's code, senão então deixa quieto. \ movzxb edx,[edx]; push edx
Abort usando "Internal error 3 - transmogrify uma fragment (push value)".

Como transmogrify uma fragment (repeat):
Find outro fragment usando o fragment e o loop tag (backwards).
Se o outro fragment não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (repeat)", senão então deixa quieto.
Attach $E9 e o outro fragment's adicioneress to o fragment. \ jmp o destination's adicioneress

Como transmogrify uma fragment (tarefa adicioneress):
Attach adicioneress loading code to o fragment's code usando o fragment's variable. \ put adicioneress dentro de edx
Se o fragment's tarefa não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (tarefa adicioneress)", senão então deixa quieto.
Pegue uma adicioneress usando o fragment's tarefa.
Attach $C702 e o adicioneress to o fragment's code. \ mov [edx],o adicioneress

Como transmogrify uma fragment (save eax):
Attach adicioneress loading code to o fragment's code usando o fragment's variable. \ put adicioneress dentro de edx
Se o fragment's variable não existir, mostre uma mensagem de erro usando"Internal error - transmogrify uma fragment (save eax)", senão então deixa quieto.
Se o fragment's variable's tipo não existir, mostre uma mensagem de erro usando "Internal error 2 - transmogrify uma fragment (save eax)", senão então deixa quieto.
Coloque o fragment's variable's tipo's length dentro de uma length.
Se o length is 4, attach $8902 to o fragment's code, senão então deixa quieto. \ mov [edx],eax
Se o length is 2, attach $668902 to o fragment's code, senão então deixa quieto. \ mov [edx],ax
Se o length is 1, attach $8802 to o fragment's code, senão então deixa quieto. \ mov [edx],al
Abort usando "Internal error 3 - transmogrify uma fragment (save eax)".

Como transmogrify some fragments:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma fragment usando o fragments.
Se o fragment não existir, deixe quieto.
Transmogrify o fragment.
Repita.

Como transmogrify uma tarefa:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Se o tarefa não existir, deixe quieto.
Se o tarefa's employs apelido não estiver vazio, deixe quieto.
Se o tarefa's compiled flag is not set, deixe quieto.
Coloque o tarefa no current tarefa.
Transmogrify o tarefa's fragments.

Como transmogrify some tarefas:
Se o sinal da mensagem de erro estiver verde, deixe quieto.
Pegue uma tarefa usando o tarefas.
Se o tarefa não existir, break.
Transmogrify o tarefa.
Repita.

The transmogrifying timer é uma timer.

The tipo index is uma index.

A tipo é uma coisa usando
A locus (reference),
A nome, uma plural nome,
A partial apelido,
A length,
A base nome, uma base tipo (reference),
A target nome, uma target tipo (reference) [pointers only],
A scale proporção,
Some campos [records only],
A cooking flag,
A optional info resolved flag.

A tipo nome é um nome.

The tipos are some tipos.

The utility index is uma index.

A variable é uma coisa usando
A locus (reference),
A kind [literal, global, local, parameter, scratch],
A compiled flag,
A nome, uma nicknome, uma tipo nome,
A tipo (reference), \ actual tipo on literal, global, local; dereferenced tipo on parameters e scratches
Um adicioneress [globals e literals only] or 
Um offset at o adicioneress [locals, parameters, e campos only],
A count [campos only],
A reference flag [campos only],
A redefinition target nome [campos only],
A by-value flag [parameters only],
Um global conteúdo [globals only],
Um initializer string [globals only],
A literal (reference) [globals only - constant usando which to initalize o global],
A hex string called data [literals only].

The writing timer é uma timer.
